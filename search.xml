<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>形式语义学学习笔记</title>
      <link href="/2020/04/29/Formal-Semantics/"/>
      <content type="html"><![CDATA[<p>这学期上whp老师的形式语义学课程，做一些简单的记录.</p><blockquote><p>教材：The Formal Semantics of Programming Languages_ An Introduction. <em>Gylnn Winskel</em>.</p></blockquote><ul><li>IMP: Simple Imperative Language</li><li>操作语义：MOS &amp; SOS</li><li>指称语义：Denotational Semantics</li><li>公理语义：Hoare Logic</li></ul><a id="more"></a><h2 id="imp-a-simple-imperative-language">IMP: a Simple Imperative Language</h2><p>IMP的指令分为 <span class="math inline">\(\mathbf{Aexp}\)</span>（算术表达式）, <span class="math inline">\(\mathbf{Bexp}\)</span>（布尔表达式）, 以及 <span class="math inline">\(\mathbf{Com}\)</span>（命令）三部分. 其抽象语法如下所示：</p><blockquote><p>其中 <span class="math inline">\(n\)</span> 为整数，<span class="math inline">\(X\)</span> 为地址.</p></blockquote><ul><li><span class="math inline">\(\mathbf{Aexp}\)</span> <span class="math inline">\(a::=n ~|~ X ~|~ a_1+a_2 ~|~ a_1-a_2 ~|~ a_1\times a_2\)</span>;</li><li><span class="math inline">\(\mathbf{Bexp}\)</span> <span class="math inline">\(b::=\mathbf{true} ~|~ \mathbf{false} ~|~ a_{0}=a_{1} ~|~ a_{0} \leq a_{1} ~|~ \neg b ~|~ b_{0} \wedge b_{1} ~|~ b_{0} \vee b_{1}\)</span>;</li><li><span class="math inline">\(\mathbf{Com}\)</span> <span class="math inline">\(c::=\mathbf{skip} ~|~ X:=a ~|~ \mathbf{if}~b~\mathbf{then}~c_{0}~\mathbf{else}~c_{1}~|~\mathbf{while}~b~\mathbf{do}~c ~|~ c_{0};~c_{1}\)</span>;</li></ul><p>举一个 IMP 的例子吧…计算阶乘：</p><p><span class="math display">\[\begin{align*}fu&amp;nc~\mathbf{Factorial}~X~:\\  &amp;Y := 1;\\  &amp;\mathbf{while}~\neg(X=0)~\mathbf{do}\\  &amp;\quad Y:=Y\times X;\\  &amp;\quad X:=X-1\\  &amp;\mathbf{end}\end{align*}\]</span></p><p>形式语义学可以对 IMP 的语义做一些解释，进而完成程序的形式化验证等工作.</p><h2 id="操作语义">操作语义</h2><p>操作语义首先规定了系统的状态，然后把指令视作系统状态间的转移（操作）.</p><blockquote><p>SDEC Machine: Stack-Environment-Device-Control 四元组：</p><ul><li>Stack：堆栈，记为 <span class="math inline">\(s\)</span>;</li><li>Environment：记录系统外的环境，记为 <span class="math inline">\(e\)</span>;</li><li>Device：记录存储的东西，记为 <span class="math inline">\(d\)</span>;</li><li>Control：存储命令，记为 <span class="math inline">\(c\)</span>.</li></ul><p>事实上，描述 IMP 的语义只需要 <span class="math inline">\((s,d,c)\)</span> 机器就够了：</p><ul><li><span class="math inline">\(s \in(\mathbb{N} \cup\{\mathbf{T}, \mathbf{F}\} \cup \mathbf{Loc} \cup \mathbf{Com})^{*}\)</span>;</li><li><span class="math inline">\(d \in \mathbf{Loc} \longrightarrow \mathbb{N}\)</span>; 地址 -&gt; 地址存储的值.</li><li><span class="math inline">\(c \in(\mathbf { Aexp } \cup \mathbf { Bexp } \cup \mathbf { Com } \cup \mathbf { Cs })^{*}\)</span>，其中 <span class="math inline">\(\mathbf{Cs}=\{\mathbf { if, while }, \rightarrow, ;,+,-, x,=, \leq, \neg, \vee, \wedge\}\)</span>.</li></ul></blockquote><p><font color="D0104C"><strong>操作语义分为 SOS 和 MOS 两个路数</strong></font></p><h3 id="sos-structural-operational-semantics">SOS: Structural Operational Semantics</h3><p><font color="D0104C"><strong><span class="math inline">\(\mathbf{Aexp}\)</span> 的求值</strong></font></p><ul><li>数字/地址：<span class="math display">\[\langle n,\sigma\rangle\longrightarrow n\qquad \langle X,\sigma\rangle\longrightarrow \sigma(X)\]</span></li><li>求和：（其中 <span class="math inline">\(n\)</span> 是 <span class="math inline">\(n_1\)</span> 与 <span class="math inline">\(n_2\)</span> 的和，减法乘法同理）<span class="math display">\[\frac{\left\langle a_{0}, \sigma\right\rangle \longrightarrow n_{0} \quad\left\langle a_{1}, \sigma\right\rangle \longrightarrow n_{1}}{\left\langle a_{0}+a_{1}, \sigma\right\rangle \longrightarrow n}\]</span></li></ul><p><font color="D0104C"><strong><span class="math inline">\(\mathbf{Bexp}\)</span> 的求值</strong></font></p><ul><li>真值：（注意，<span class="math inline">\(\mathbf{true}\)</span> 是一个语法对象，但 <span class="math inline">\(\mathrm{T}\)</span> 是一个语义中的真值）<span class="math display">\[\langle\mathbf { true }, \sigma\rangle \longrightarrow \mathbf{T}, \quad\langle\mathbf { false }, \sigma\rangle \longrightarrow \mathbf{F}\]</span></li><li>判断：（以 <span class="math inline">\(=\)</span> 为例，<span class="math inline">\(\leqslant\)</span> 同理）<span class="math display">\[\begin{align}  \frac{\langle a_0,\sigma\rangle\longrightarrow n_0\quad\langle a_1,\sigma\rangle\longrightarrow n_1}{\langle a_0=a_1,\sigma\rangle\longrightarrow \mathrm{T}}, &amp;\quad 若~n_0~与~n_1~\text{相等}\\  \frac{\langle a_0,\sigma\rangle\longrightarrow n_0\quad\langle a_1,\sigma\rangle\longrightarrow n_1}{\langle a_0=a_1,\sigma\rangle\longrightarrow \mathrm{F}}, &amp;\quad 若~n_0~与~n_1~\text{不等}\end{align}\]</span></li><li>取反：<span class="math display">\[\frac{\langle b,\sigma\rangle\longrightarrow\mathrm{T}}{\langle \neg b,\sigma\rangle\longrightarrow\mathrm{F}}\qquad\frac{\langle b,\sigma\rangle\longrightarrow\mathrm{F}}{\langle \neg b,\sigma\rangle\longrightarrow\mathrm{T}}\]</span></li><li>二元逻辑运算：（以 <span class="math inline">\(\wedge\)</span> 为例，其中 <span class="math inline">\(t=\begin{cases}\mathrm{T}\quad \text{if}~t_1\equiv t_2\equiv \mathrm{T} \\ \mathrm{F}\quad\text{otherwise} \end{cases}\)</span>，<span class="math inline">\(\vee\)</span> 同理. 其实和 <span class="math inline">\(\mathbf{Aexp}\)</span> 中的加法也是同理）<span class="math display">\[\begin{align*}\frac{\left\langle b_{0}, \sigma\right\rangle \longrightarrow t_{0} \quad\left\langle b_{1}, \sigma\right\rangle \longrightarrow t_{1}}{\langle b_0\wedge b_1,\sigma \rangle\longrightarrow t}\end{align*}\]</span></li></ul><p><font color="D0104C"><strong><span class="math inline">\(\mathbf{Com}\)</span> 的执行</strong></font></p><p><span class="math display">\[\begin{align*}\mathrm{Skip}~\frac{}{\langle \mathbf{skip},\sigma\rangle\longrightarrow\sigma} \qquad&amp;\qquad\qquad\qquad\mathrm{Assign}~\frac{\langle a,\sigma\rangle\longrightarrow n}{\langle X:=a,\sigma\rangle\longrightarrow\sigma[n/X]} \\\mathrm{If}~\frac{\langle b,\sigma\rangle\longrightarrow \mathrm{T}\quad \langle c_0,\sigma\rangle\longrightarrow\sigma&#39;}{\langle \mathbf{if}~b~\mathbf{then}~c_0~\mathbf{else}~c_1,\sigma \rangle\longrightarrow\sigma&#39;} &amp;\qquad\qquad\qquad \mathrm{If}~\frac{\langle b,\sigma\rangle\longrightarrow \mathrm{F}\quad \langle c_1,\sigma\rangle\longrightarrow\sigma&#39;}{\langle \mathbf{if}~b~\mathbf{then}~c_0~\mathbf{else}~c_1,\sigma \rangle\longrightarrow\sigma&#39;} \\\mathrm{While}~\frac{\langle b,\sigma\rangle\longrightarrow\mathrm{F}}{\langle \mathbf{while}~b~\mathbf{do}~c,\sigma \rangle\longrightarrow\sigma} &amp;\qquad  \mathrm{While}~\frac{\langle b,\sigma\rangle\longrightarrow\mathrm{T} \quad \langle c,\sigma\rangle\longrightarrow\sigma&#39; \quad \langle \mathbf{while}~b~\mathbf{do}~c,\sigma&#39; \rangle\longrightarrow\sigma&#39;&#39;}{\langle \mathbf{while}~b~\mathbf{do}~c,\sigma \rangle\longrightarrow\sigma&#39;&#39;}\end{align*}\]</span></p><p><font color="D0104C"><strong>SOS 的性质</strong></font></p><ol type="1"><li>确定性：SOS 具有确定性. 其中 <span class="math inline">\(\mathbf{Com}\)</span> 的确定性证明用到了良基归纳（Well-founded induction）.<ul><li>关于 well-founded induction 不多赘述.</li></ul></li><li>终止性：<span class="math inline">\(\mathbf{Aexp}\)</span> 和 <span class="math inline">\(\mathbf{Bexp}\)</span> 是终止的，但 <span class="math inline">\(\mathbf{Com}\)</span> 是不终止的.</li></ol><h3 id="mos-mechanical-operational-semantics">MOS: Mechanical Operational Semantics</h3><p><font color="D0104C"><strong><span class="math inline">\(\mathbf{Aexp}\)</span> 的语义</strong></font></p><ul><li>数字/地址：<span class="math display">\[(s,d,nc&#39;) \longrightarrow (ns, d, c&#39;)\qquad (s,d, Xc&#39;) \longrightarrow (d(X)s,d,c&#39;)\]</span></li><li><p>运算：（其中 <span class="math inline">\(n\)</span> 是 <span class="math inline">\(n_1\)</span> 与 <span class="math inline">\(n_2\)</span> 的和，减法乘法同理）<span class="math display">\[\begin{align*}(s,d,(a_1+a_2)c&#39;) &amp;\longrightarrow (s,d,a_1a_2+c&#39;)\\ (n_2n_1s,d,+c&#39;)&amp;\longrightarrow (ns, d, c&#39;)\end{align*}\]</span></p></li><li>真值：<span class="math display">\[\begin{align*}  (s,d,\mathbf{true}c&#39;) &amp;\longrightarrow (\mathrm{T}s, d, c&#39;) \\  (s,d,\mathbf{false}c&#39;) &amp;\longrightarrow (\mathrm{F}s, d, c&#39;)\end{align*}\]</span></li><li>比较：（以 <span class="math inline">\(=\)</span> 为例，<span class="math inline">\(\leqslant\)</span> 同理）<span class="math display">\[\begin{align*}  (s,d,(a_1=a_2)c&#39;)&amp;\longrightarrow(s,d,a_1a_2=c&#39;) \\  (n_2n_1s,d,=c&#39;)&amp;\longrightarrow (\mathrm{T}s,d,c&#39;)\quad \text{if}~n_1=n_2 \\  (n_2n_1s,d,=c&#39;)&amp;\longrightarrow (\mathrm{F}s,d,c&#39;)\quad \text{if}~n_1\neq n_2 \\\end{align*}\]</span></li><li>取反：<span class="math display">\[\begin{align*}  (s,d,(\neg b)c&#39;) &amp;\longrightarrow (s,d,b\neg c&#39;) \\  (\mathrm{T}s, d, \neg c&#39;) &amp;\longrightarrow (\mathrm{F}s, d, c&#39;) \\  (\mathrm{F}s, d, \neg c&#39;) &amp;\longrightarrow (\mathrm{T}s, d, c&#39;) \end{align*}\]</span></li><li><p>二元逻辑运算：（以 <span class="math inline">\(\wedge\)</span> 为例，其中 <span class="math inline">\(t=\begin{cases}\mathrm{T}\quad \text{if}~t_1=t_2=\mathrm{T} \\ \mathrm{F}\quad\text{otherwise} \end{cases}\)</span>，<span class="math inline">\(\vee\)</span> 同理. 其实和 <span class="math inline">\(\mathbf{Aexp}\)</span> 中的加法也是同理）<span class="math display">\[\begin{align*}  \left(s, d,\left(b_{1} \wedge b_{2}\right) c^{\prime}\right) &amp;\longrightarrow\left(s, d, b_{1} b_{2} \wedge c^{\prime}\right)\\  (t_2t_1s, d, \wedge c&#39;) &amp;\longrightarrow (ts, d, c&#39;) \\\end{align*}\]</span></p></li></ul><p><font color="D0104C"><strong><span class="math inline">\(\mathbf{Com}\)</span> 的语义</strong></font></p><ul><li>空语句：<span class="math display">\[(s,d,\mathbf{skip}~c&#39;)\longrightarrow(s,d,c&#39;)\]</span></li><li>赋值：<span class="math display">\[\begin{align*}  (s,d,X:=a~c&#39;) &amp;\longrightarrow (Xs, d, a\rightarrow c&#39;) \\  (nXs, d, \rightarrow c&#39;) &amp;\longrightarrow (s, d[n/X], c&#39;)\end{align*}\]</span></li><li>顺序：<span class="math display">\[\begin{align*}  (s, d, (c_0;~c_1)c&#39;) &amp;\longrightarrow (s,d,c_0;~(c_1c&#39;)) \\  (s&#39;, d&#39;, ;~c&#39;&#39;) &amp;\longrightarrow (s&#39;, d&#39;, c&#39;&#39;)\end{align*}\]</span></li><li>条件：<span class="math display">\[\begin{align*}  (s, d, (\mathbf{if}~b~\mathbf{then}~c_0~\mathbf{else}~c_1) c&#39;) &amp;\longrightarrow (c_0c_1s, d, b~\mathbf{if}~c&#39;)\\  (\mathrm{T}c_0c_1s, d, \mathbf{if}~c&#39;) &amp;\longrightarrow (s,d,c_0c&#39;) \\  (\mathrm{F}c_0c_1s, d, \mathbf{if}~c&#39;) &amp;\longrightarrow (s,d,c_1c&#39;)\end{align*}\]</span></li><li>循环：<span class="math display">\[\begin{align*}  (s, d, (\mathbf{while}~b~\mathbf{do}~c)c&#39;) &amp;\longrightarrow ((c;~\mathbf{while}~b~\mathbf{do}~c)s, d, b~\mathbf{while}~c&#39;)\\  (\mathrm{T}(c;~\mathbf{while}~b~\mathbf{do}~c)s, d, \mathbf{while}~c&#39;) &amp;\longrightarrow (s,d,(c;~\mathbf{while}~b~\mathbf{do}~c)c&#39;) \\  (\mathrm{F}(c;~\mathbf{while}~b~\mathbf{do}~c)s, d, \mathbf{while}~c&#39;) &amp;\longrightarrow (s,d,c&#39;)\end{align*}\]</span></li></ul><p><font color="D0104C"><strong>MOS 的性质</strong></font></p><ol type="1"><li>确定性：上述 MOS 所规定的的转移 <span class="math inline">\(\rightarrow\)</span> 是确定的，i.e. 若 <span class="math inline">\((s_0,d_0,c_0)\to(s_1,d_1,c_1)\)</span> 且 <span class="math inline">\((s_0,d_0,c_0)\to(s_2,d_2,c_2)\)</span>，则有 <span class="math inline">\((s_1,d_1,c_1)=(s_2,d_2,c_2)\)</span><ul><li>证明挺容易的（</li></ul></li><li>终止性：<span class="math inline">\(\mathbf{Aexp}\)</span> 和 <span class="math inline">\(\mathbf{Bexp}\)</span> 都是终止的，但 <span class="math inline">\(\mathbf{Com}\)</span> 不是（例如 <span class="math inline">\(\mathbf{while~true~do~skip}\)</span>）.</li></ol><blockquote><p>这两条应该都和 SOS 一样.</p></blockquote><p>现定义二元关系 <span class="math inline">\((s,d,c)\rightarrow^* (s&#39;,d&#39;,c&#39;)\)</span>，表示存在一个序列 <span class="math inline">\(\left\{\left(s_{i}, d_{i}, c_{i}\right)\right\}_{i=1}^{n}\)</span>，s.t. <span class="math display">\[(s, d, c)=\left(s_{1}, d_{1}, c_{1}\right) \rightarrow \cdots \rightarrow\left(s_{n}, d_{n}, c_{n}\right)=\left(s^{\prime}, d^{\prime}, c^{\prime}\right)\]</span> 则易得：</p><ul><li><span class="math inline">\(\rightarrow^*\)</span> 是自反的；</li><li><span class="math inline">\(\rightarrow^*\)</span> 是传递的；</li><li><font color="red">但 <span class="math inline">\(\rightarrow^*\)</span> 不是确定的.</font></li></ul><p>事实上，<span class="math inline">\(\rightarrow^*\)</span> 具有另一种意义下的确定性，称为 <strong>Church-Rosser Property</strong>：</p><blockquote><p>若 <span class="math inline">\((s,d,c)\rightarrow^* (s&#39;,d&#39;,c&#39;)\)</span> 且 <span class="math inline">\((s,d,c)\rightarrow^* (s&#39;&#39;,d&#39;&#39;,c&#39;&#39;)\)</span>，则存在 <span class="math inline">\((\bar{s},\bar{d},\bar{c})\)</span>，s.t. <span class="math inline">\((s&#39;,d&#39;,c&#39;) \rightarrow^* (\bar{s},\bar{d},\bar{c})\)</span> 且 <span class="math inline">\((s&#39;&#39;,d&#39;&#39;,c&#39;&#39;) \rightarrow^* (\bar{s},\bar{d},\bar{c})\)</span>.</p></blockquote><p>还可以定义第三种关系 <span class="math inline">\(\rightarrow&#39;\)</span>，表示 <span class="math inline">\(\rightarrow^*\)</span> 的中间序列不为空，即“至少经过一步转移”. 不过我感觉好像没什么意义…这东西破坏了自反性和 Church-Rosser 性质…</p><h2 id="指称语义">指称语义</h2><p><font color="D0104C"><strong>新的记号</strong></font></p><ul><li>状态集：<span class="math inline">\(\Sigma\)</span>；一个指称就是从状态集到“意思”集合的映射.</li><li>全函数 <span class="math inline">\(A\to B\)</span>：每个 <span class="math inline">\(a\in A\)</span> 都有像；</li><li>部分函数 <span class="math inline">\(A\rightharpoonup B\)</span>：不是每个 <span class="math inline">\(a\in A\)</span> 都有像.</li></ul><p><font color="D0104C"><strong><span class="math inline">\(\mathbf{Aexp}\)</span> 的语义</strong></font></p><p>实际上是定义了一个 <span class="math inline">\(\mathbf{Aexp}\)</span> 到其指称的映射 <span class="math inline">\(\mathcal{A}: \mathbf{Aexp}\to (\Sigma\to\mathbb{N})\)</span>. （<span class="math inline">\(\mathbf{Bexp}\)</span> 同理）</p><ul><li>数字/地址：<span class="math display">\[\mathcal{A}[[n]](\sigma)=n\qquad \mathcal{A}[[X]](\sigma)=\sigma(X)\]</span></li><li>加法：（减法和乘法同理）<span class="math display">\[\mathcal{A}[[a_1+a_2]]=\mathcal{A}[[a_1]]+\mathcal{A}[[a_2]]\]</span></li></ul><p><font color="D0104C"><strong><span class="math inline">\(\mathbf{Bexp}\)</span> 的语义</strong></font></p><ul><li>真值/地址：<span class="math display">\[\mathcal{B}[[\mathbf{true}]](\sigma)=\mathrm{T}\qquad \mathcal{B}[[\mathbf{false}]](\sigma)=\mathrm{F}\qquad \mathcal{B}[[X]](\sigma)=\sigma(X)\]</span></li><li>判断：（以 <span class="math inline">\(=\)</span> 为例，<span class="math inline">\(\leqslant\)</span> 同理）<span class="math display">\[\mathcal{B}[[a_1=a_2]]=\begin{cases}  \mathrm{T}\quad 若~\mathcal{A}[[a_1]](\sigma)=\mathcal{A}[[a_2]](\sigma)\\  \mathrm{F}\quad 若~\mathcal{A}[[a_1]](\sigma)\neq\mathcal{A}[[a_2]](\sigma)\end{cases}\]</span></li><li>逻辑运算：（<span class="math inline">\(\vee\)</span> 同理）<span class="math display">\[\mathcal{B}[[\neg b]](\sigma)=\neg\mathcal{B}[[b]](\sigma)\qquad \mathcal{B}[[b_1\wedge b_2]](\sigma)=\mathcal{B}[[b_1]](\sigma)\wedge \mathcal{B}[[b_2]](\sigma)\]</span></li></ul><p><font color="D0104C"><strong><span class="math inline">\(\mathbf{Com}\)</span> 的语义</strong></font></p><p>命令的指称是部分函数 <span class="math inline">\(\Sigma\rightharpoonup\Sigma\)</span>（因为有一些命令并不终止），因此其指称语义是 <span class="math inline">\(\mathcal{C}:\mathbf{Com}\to(\Sigma\rightharpoonup\Sigma)\)</span>.</p><ul><li>空语句/赋值：<span class="math display">\[\mathcal{C}[[\mathbf{skip}]](\sigma)=\sigma \qquad \mathcal{C}[[X:=a]](\sigma)=\sigma(n/X)\]</span></li><li>顺序：<span class="math display">\[\mathcal{C}[[c_1;~c_2]](\sigma)=\mathcal{C}[[c_2]](\mathcal{C}[[c_1]](\sigma))=(\mathcal{C}[[c_2]]\circ\mathcal{C}[[c_1]])(\sigma)\]</span></li><li>条件：<span class="math display">\[\mathcal{C}[[\mathbf{if}~b~\mathbf{then}~c_0~\mathbf{else}~c_1]](\sigma)=\begin{cases}  \mathcal{C}[[c_0]](\sigma)\quad 若~\mathcal{B}[[b]](\sigma)=\mathrm{T} \\  \mathcal{C}[[c_1]](\sigma)\quad 若~\mathcal{B}[[b]](\sigma)=\mathrm{F}\end{cases}\]</span></li><li>循环：<span class="math display">\[\begin{align*}  \mathcal{C}[[\mathbf{while}~b~\mathbf{do}~c]](\sigma)&amp;= \begin{cases}      \sigma &amp; 若~\mathcal{B}[[b]](\sigma)=\mathrm{F}\\      \mathcal{C}[[\mathbf{while}~b~\mathbf{do}~c]](\mathcal{C}[[c]](\sigma)) &amp; 若~\mathcal{B}[[b]](\sigma)=\mathrm{T}  \end{cases} \\  &amp;=\begin{cases}      \sigma &amp; 若~\mathcal{B}[[b]](\sigma)=\mathrm{F}\\      (\mathcal{C}[[\mathbf{while}~b~\mathbf{do}~c]]\circ\mathcal{C}[[c]])((\sigma)) &amp; 若~\mathcal{B}[[b]](\sigma)=\mathrm{T}  \end{cases}\end{align*}\]</span></li></ul><p><font color="D0104C"><strong><span class="math inline">\(\mathcal{C}[[\mathbf{while}~b~\mathbf{do}~c]]\)</span> 的存在性与唯一性</strong></font></p><p>定义函数： <span class="math display">\[F:(\Sigma\rightharpoonup\Sigma)\to(\Sigma\rightharpoonup\Sigma),\quad F(\varphi)(\sigma)=\begin{cases}    \sigma &amp; 若~\mathcal{B}[[b]](\sigma)=\mathrm{F} \\    (\varphi\circ\mathcal{C}[[c]])(\sigma) &amp; 若~\mathcal{B}[[b]](\sigma)=\mathrm{T}\end{cases}\]</span></p><p>则容易验证 <span class="math inline">\(\mathcal{C}[[\mathbf{while}~b~\mathbf{do}~c]]\)</span> 是 <span class="math inline">\(F\)</span> 的一个不动点. 因此 <span class="math inline">\(\mathcal{C}[[\mathbf{while}~b~\mathbf{do}~c]]\)</span> 的存在和唯一性可转化为 <span class="math inline">\(F\)</span> 不动点的存在和唯一性.</p><p>事实上，<span class="math inline">\(F\)</span> 的最小不动点存在且唯一. 这下稳了（</p><p><font color="D0104C"><strong>最小不动点的相关讨论</strong></font></p><p>首先需要定义完全偏序集：</p><blockquote><p><strong>Def. 完全偏序集</strong> （例子：离散序 <span class="math inline">\(a\sqsubseteq b\iff a=b\)</span>，平坦序 <span class="math inline">\(a\sqsubseteq b\sqsubseteq c \iff a=b~或~b=c\)</span>）</p><ul><li>复习一下偏序集：自反、传递、反对称. 偏序集记作 po.</li><li>若偏序集中的每个升链 <span class="math inline">\(d_1\sqsubseteq d_2\sqsubseteq \cdots\)</span> 都有上确界 <span class="math inline">\(\bigsqcup_{i}d_i\)</span>，则称其为一个完全偏序集，记作 cpo.</li><li>若 cpo <span class="math inline">\((P,\sqsubseteq)\)</span> 中有最小元 <span class="math inline">\(\perp\)</span>（<span class="math inline">\(\forall x\in P\)</span>，总有 <span class="math inline">\(x\sqsubseteq \perp\)</span>），则称其为带底的 cpo.</li></ul></blockquote><ul><li>可以证明：对任意集合 <span class="math inline">\(X\)</span>，给其幂集赋予包含关系 <span class="math inline">\((\mathscr{P}(x),\subseteq)\)</span> 都构成一个含底的 cpo.</li></ul><p>在 cpo 中，每个升链都有上确界，这实际上就是分析中“极限”的概念. 因此可以定义连续函数：</p><blockquote><p><strong>Def. 连续函数</strong> 设 <span class="math inline">\(D,E\)</span> 是 cpo，<span class="math inline">\(f:D\to E\)</span> 是一个函数</p><ol type="1"><li>若对 <span class="math inline">\(\forall d_1,d_2\in D\)</span>，s.t. <span class="math inline">\(d_1\sqsubseteq d_2\)</span>，总有 <span class="math inline">\(f(d_1)\sqsubseteq f(d_2)\)</span>，则称 <span class="math inline">\(f\)</span> <strong>单调</strong>（保序）；</li><li>若 <span class="math inline">\(f\)</span> 单调，且对任意升链 <span class="math inline">\(d_1\sqsubseteq d_2\sqsubseteq\cdots\)</span>，都有 <span class="math inline">\(f(\bigsqcup d_n)=\bigsqcup f(d_n)\)</span>，则称 <span class="math inline">\(f\)</span> 连续.</li></ol></blockquote><p>对于连续函数，有如下的<strong>不动点定理</strong>：</p><blockquote><p><font color="#FB966E"><strong>Thm. 不动点定理</strong></font> 设 <span class="math inline">\(D\)</span> 是一个含底的 cpo，<span class="math inline">\(f:D\to D\)</span> 连续，则 <span class="math display">\[fix(f)=\bigsqcup_n f^n(\perp)\]</span> 是 <span class="math inline">\(f\)</span> 的最小不动点. 其中 <span class="math inline">\(f^n\)</span> 表示 <span class="math inline">\(f\)</span> 作用 <span class="math inline">\(n\)</span> 次. （证明很简单，先证是不动点，再证最小即可）</p></blockquote><p>现在，我们在状态集 <span class="math inline">\(\Sigma\)</span> 中添加底元素 <span class="math inline">\(\perp\)</span>，s.t. <span class="math inline">\(\forall \sigma\)</span>，<span class="math inline">\(\perp\sqsubseteq \sigma\)</span>. 新的集合记为 <span class="math inline">\(\Sigma_\perp\)</span>.</p><blockquote><p>部分函数当然也可以得到扩充（把无定义的元素全部拉到 <span class="math inline">\(\perp\)</span> 上）而成为全函数 <span class="math inline">\(\Sigma\to\Sigma_\perp\)</span>. 并且该扩充是一一对应的.</p><ul><li>还可以得到：这样扩充得到的全函数一定是连续的.</li></ul></blockquote><p>考虑到部分函数 <span class="math inline">\(\Sigma\rightharpoonup\Sigma\)</span> 的全体被赋予包含关系后是一个含底的 cpo，一个自然的反应就是：<strong>扩充而来的全函数也构成一个含底的 cpo.</strong></p><p>事实上，这句话是正确的. <span class="math inline">\(\Sigma\to\Sigma_\perp\)</span> 上的序构造如下： <span class="math display">\[f\sqsubseteq g~当且仅当~\forall\sigma\in\Sigma,~f(\sigma)\sqsubseteq g(\sigma)\]</span></p><p><strong>到这里，就足以说明 while 循环指称语义的存在唯一性了.</strong></p><p>关于不动点，在代数上还有如下定理（这里并用不到）：</p><blockquote><p><strong>Thm. Knaster-Tarski 最小不动点定理</strong> 设 <span class="math inline">\((L,\sqsubseteq)\)</span> 是一个完备格. 令 <span class="math inline">\(f:L\to L\)</span> 是单调函数（不必连续，可以看出这里减弱了条件），则 <span class="math display">\[m=\sqcap\{x\in L: f(x)\sqsubseteq x\}\]</span> 是 <span class="math inline">\(f\)</span> 的最小不动点.</p></blockquote><p>上述定理还有一个逆定理：</p><blockquote><p><strong>Thm.</strong> 若所有保序映射 <span class="math inline">\(f:L\to L\)</span> 都有不动点，则 <span class="math inline">\(L\)</span> 是完全格.</p></blockquote><h2 id="公理语义">公理语义</h2><ul><li>前面的操作语义和指称语义已经对语义有了很详细的描述.</li><li>公理语义给出了一套逻辑系统，并证明了其正确性.</li><li>这套系统可以被用于自动化推演证明，叫做 Hoare Logic.</li></ul><p><font color="D0104C"><strong>断言语言 <span class="math inline">\(\mathbf{Assn}\)</span></strong></font></p><p>在算术表达式 <span class="math inline">\(\mathbf{Aexp}\)</span> 中添加整型变量 <span class="math inline">\(\mathbf{IntVar}\)</span> 类型的元素（常用 <span class="math inline">\(i\)</span> 表示），扩充而为 <span class="math inline">\(\mathbf{Aexpv}\)</span>：</p><ul><li><span class="math inline">\(\mathbf{Aexpv}~a::=x~|~i~|~n~|~a_1+a_2~|~a_1-a_2~|~a_1\times a_2\)</span></li></ul><blockquote><p>既然有变量，那么就需要有“解释”，记为函数 <span class="math inline">\(I:\mathbf{IntVar}\to\mathbb{N}\)</span>. 这个东西在语义中用得到.</p></blockquote><p>断言（Assertions）就是一些可以判断真假的东西（可视为 <span class="math inline">\(\mathbf{Bexp}\)</span> 的扩展）：</p><ul><li><span class="math inline">\(\mathbf{Assn}~P::=\mathbf{true}~|~\mathbf{false}~|~a_1&lt;a_2~|~P_1\wedge P_2~|~P_1\vee P_2~|~P_1\Rightarrow P_2~|~\neg P~|~\forall i.~P~|~\exists i.~P\)</span></li></ul><blockquote><p>由于断言中有变量和量词的出现，因此也有类似数理逻辑中“自由”与“约束”的概念，不多赘述.</p></blockquote><p><font color="D0104C"><strong><span class="math inline">\(\mathbf{Assn}\)</span> 的语义：指称语义</strong></font></p><ul><li><span class="math inline">\(\mathbf{Aexpv}\)</span> 的语义：记为 <span class="math inline">\(\mathcal{A}v[[a]]\)</span>…基本直接套用 <span class="math inline">\(\mathbf{Aexp}\)</span> 的指称语义. 关于变量的语义如下：<span class="math display">\[\mathcal{A}v[[i]]I\sigma=I(i)\]</span></li><li><span class="math inline">\(\mathbf{Assn}\)</span> 的真假：基本与一阶逻辑的东西一样. 用 <span class="math inline">\(\sigma\vDash_I A\)</span> 表示 <span class="math inline">\(A\)</span> 在 <span class="math inline">\(I\)</span> 中被 <span class="math inline">\(\sigma\in\Sigma\)</span> 满足.<ul><li>例 1：<span class="math inline">\(\sigma\vDash_I \mathbf{true}\)</span>, <span class="math inline">\(\sigma\not\vDash_I\mathbf{false}\)</span>;</li><li>例 2：<span class="math inline">\(\sigma\vDash_I a_1=a_2\)</span> 当且仅当 <span class="math inline">\(\mathcal{A}v[[a_1]]I\sigma=\mathcal{A}v[[a_2]]I\sigma\)</span>;</li><li>例 3：<span class="math inline">\(\sigma\vDash_I A\wedge B\)</span> 当且仅当 <span class="math inline">\(\sigma\vDash_I A\)</span> 且 <span class="math inline">\(\sigma\vDash_I B\)</span>.</li></ul></li></ul><blockquote><p><strong>Prop</strong> 给定 <span class="math inline">\(b\in\mathbf{Bexp}\)</span> 和状态 <span class="math inline">\(\sigma\in\Sigma\)</span>，则对任意解释 <span class="math inline">\(I\)</span>，有<span class="math display">\[\mathcal{A}[[b]]\sigma=\mathbf{true}~当且仅当~\sigma\vDash_I b\]</span></p></blockquote><p><font color="D0104C"><strong>Hoare 公式（Hoare triple）</strong></font></p><p>Hoare 公式（三元组）一般的形式为 <span class="math inline">\(\{P\}~c~\{Q\}\)</span>：</p><ul><li><span class="math inline">\(P,Q\in\mathbf{Assn}\)</span> 是断言（描述系统的状态？）；</li><li><span class="math inline">\(c\in\mathbf{Com}\)</span> 是指令.</li></ul><blockquote><p><span class="math inline">\(\{P\}~c~\{Q\}\)</span> 的意思是：若 <span class="math inline">\(P\)</span> 成立，则执行完 <span class="math inline">\(c\)</span> 后，<span class="math inline">\(Q\)</span> 将成立.</p></blockquote><p><font color="D0104C"><strong>Hoare Rules</strong></font></p><p>一共有六条规则：</p><p><span class="math display">\[\begin{align*}    \mathrm{Skip}~\frac{}{\{B\} ~\mathbf{skip}~ \{B\}} &amp;\quad \mathrm{Assign}~\frac{}{\{B[a/X]\} ~X::=a~ \{B\}}\\    \mathrm{If}~\frac{\{A\wedge b\}~c_0~\{B\}\quad \{A\wedge\neg b\}~c_1~\{B\}}{\{A\}~\mathbf{if}~b~\mathbf{then}~c_0~\mathbf{else}~c_1~\{B\}} &amp;\quad     \mathrm{Sequence}~\frac{ \{P\}~c_1~\{R\} \quad \{R\}~c_2~\{Q\} }{ \{P\}~c_1;;c_2~\{Q\} } \\    \mathrm{While}~\frac{ \{P\wedge b\}~c~\{P\} }{ \{P\}~\mathbf{while}~b~\mathbf{do}~c~\{P\wedge\neg b\} }&amp;\quad    \mathrm{Consequence}~\frac{ \vDash(P\Rightarrow P&#39;)\quad \{P&#39;\}~c~\{Q&#39;\}\quad \vDash(Q&#39;\Rightarrow Q) }{ \{P\}~c~\{Q\} }\end{align*}\]</span></p><blockquote><p>while 循环始终是这些命令中最复杂的. 这里的 <span class="math inline">\(P\)</span> 叫做<strong>循环不变量</strong>，在公理语义的讨论中有着很重要的地位.</p></blockquote><ul><li><font color="884C3A"><strong>Hoare rules 建立了一套推理系统，进一步可以验证它是可靠的（<u>它推出的结果在语义上都没毛病</u>）.</strong></font></li><li>Hoare rules 之间的推理符号用 <span class="math inline">\(\vdash\)</span>.</li></ul><p><font color="D0104C"><strong>Hoare 规则的可靠性</strong></font></p><blockquote><p><strong>Def. 可满足性</strong> <span class="math inline">\(\sigma\)</span> 在 <span class="math inline">\(I\)</span> 中满足 <span class="math inline">\(\{A\}~c~\{B\}\)</span> 当且仅当：若 <span class="math inline">\(\sigma\vDash_I A\)</span>，则 <span class="math inline">\(\mathcal{C}[[c]]\sigma\vDash_I B\)</span>. 记作 <span class="math inline">\(\sigma\vDash_I \{A\}~c~\{B\}\)</span>.</p></blockquote><blockquote><p><strong>Def. 永真性</strong> 若 <span class="math inline">\(\forall \sigma\)</span>，<span class="math inline">\(\forall I\)</span>，都有 <span class="math inline">\(\sigma\vDash_I \{A\}~c~\{B\}\)</span>，则称其是永真的，记作 <span class="math inline">\(\vDash \{A\}~c~\{B\}\)</span>.</p></blockquote><blockquote><p><font color="#FB966E"><strong>Thm. 可靠性</strong></font> Hoare 规则推理出来的东西都是永真的. i.e. 若 <span class="math inline">\(\vdash \{A\}~c~\{B\}\)</span>，则 <span class="math inline">\(\vDash \{A\}~c~\{B\}\)</span>.</p></blockquote><p>可靠性的证明需要以下两个引理：</p><ol type="1"><li>赋值和语义符号 <span class="math inline">\([[ ]]\)</span> 的交换</li></ol><blockquote><p><strong>Lem.</strong> 设 <span class="math inline">\(a,a&#39;\in\mathbf{Aexpv}\)</span>，<span class="math inline">\(X\in\mathbf{Loc}\)</span>，则对 <span class="math inline">\(\forall I\)</span>，<span class="math inline">\(\forall \sigma\in\Sigma\)</span>，有 <span class="math display">\[\mathcal{A} v[[a[[a^{\prime} / X]] I \sigma=\mathcal{A} v[[a]] I(\sigma[[\mathcal{A} v[[a^{\prime}]] / X]])\]</span></p></blockquote><ol type="1"><li>赋值和 <span class="math inline">\(\vDash\)</span> 符号的交换</li></ol><blockquote><p><strong>Lem.</strong> 设 <span class="math inline">\(I\)</span> 是一个解释，<span class="math inline">\(B\in\mathbf{Assn}\)</span>，<span class="math inline">\(a\in\mathbf{Aexpv}\)</span>，<span class="math inline">\(X\in\mathbf{Loc}\)</span>，则对 <span class="math inline">\(\forall \sigma\in\Sigma\)</span>，有 <span class="math display">\[\sigma \vDash_{I} B[a / X] ~~\mathrm{iff}~~ \sigma[\mathcal{A}[[a]] \sigma / X] \vDash_{I} B\]</span></p></blockquote><p>引理的证明和定理的证明都不算太困难（while 循环最为困难），不详细描述了…</p><p><font color="D0104C"><strong>Hoare 规则的完备性</strong></font></p><p>完备性是指：一个系统能够把所有“正确”的东西都推出来. 这个“正确性”这里有两种解读：</p><ol type="1"><li>绝对：<span class="math inline">\(\{A\}~c~\{B\}\)</span> 真的正确（比如 <span class="math inline">\(\{x=1\}~\mathbf{skip}~\{x=1\}\)</span>）.</li><li>相对：在断言的逻辑（一阶逻辑）中能证明 <span class="math inline">\(\vDash\{A\}~c~\{B\}\)</span>.</li></ol><ul><li>如果按照上述 1. 的定义，<strong>则由 Godel 不完备定理可知，Hoare 规则是不完备的.</strong></li></ul><p>那么，不完备性从何而来呢？（一方面可考虑 <span class="math inline">\(\vDash B\)</span> iff <span class="math inline">\(\{\mathbf{true}\}~\mathbf{skip}~\{B\}\)</span>，另一方面可考虑 <span class="math inline">\(\{\mathbf{true}\}~c~\{\mathbf{false}\}\)</span>）</p><blockquote><p>实际上，是从 Consequence rule <span class="math inline">\(\frac{ \vDash(P\Rightarrow P&#39;)\quad \{P&#39;\}~c~\{Q&#39;\}\quad \vDash(Q&#39;\Rightarrow Q) }{ \{P\}~c~\{Q\} }\)</span> 中的蕴含（<span class="math inline">\(\Rightarrow\)</span>）符号来的.</p></blockquote><p>结合 Godel 定理考虑同样可知，Hoare 规则的不完备性应该至少有一部分来自于断言（类似一阶逻辑）的不完备性.</p><p>那么，Hoare 规则比断言更加不完备吗？</p><p>答案是否定的. 我们称，<strong>Hoare 具有相对完备性.</strong></p><blockquote><p><font color="#FB966E"><strong>Thm. 相对完备性</strong></font> Hoare 规则是相对完备的，i.e. 若 <span class="math inline">\(\vDash \{A\}~c~\{B\}\)</span>，则 <span class="math inline">\(\vdash \{A\}~c~\{B\}\)</span>.</p></blockquote><ul><li>其证明用到了最弱前置条件与可表达性.</li></ul><p>先来定义<strong>最弱前置条件</strong>（Weakest Liberal Preconditions），断言 <span class="math inline">\(B\)</span> 相对于指令 <span class="math inline">\(c\)</span> 的最弱前置条件为：</p><p><span class="math display">\[wp^{I}[c, B]=\{\sigma \in \Sigma_{\perp}~|~\mathcal{C}[[c]] \sigma \vDash^{I} B\}\]</span></p><p>关于上述定义的一点解释：</p><ul><li>“前置条件”听起来像是一个断言，但是其实是一个状态的集合.<ul><li>集合 <span class="math inline">\(S\)</span> 是断言 <span class="math inline">\(B\)</span> 相对于指令 <span class="math inline">\(c\)</span> 的前置条件意味着对 <span class="math inline">\(S\)</span> 中的每个状态执行完 <span class="math inline">\(c\)</span> 后，<span class="math inline">\(B\)</span> 都将成立；</li><li>最弱前置条件的“最弱”是把上述集合缩到最小，i.e. <span class="math inline">\(wp^{I}[c, B]\)</span> 是最小的“前置条件”集合.</li></ul></li></ul><p>有了这个定义，<strong>可表达性就非常好理解了</strong>：</p><blockquote><p><strong>Def. 可表达性</strong> <span class="math inline">\(\mathbf{Assn}\)</span> 是可表达的，i.e. 对 <span class="math inline">\(\forall c,B\)</span>，总存在断言 <span class="math inline">\(A\)</span>，s.t. <span class="math inline">\(wp^I[c,B]=A^I\)</span> 在 <span class="math inline">\(\forall I\)</span> 下成立.</p><ul><li>其中 <span class="math inline">\(A^I\)</span> 表示在 <span class="math inline">\(I\)</span> 下能够使得 <span class="math inline">\(A\)</span> 成立的状态集.</li></ul></blockquote><p>事实上，上述定义相当直观：最弱前置条件是一个状态集，我们非常难以把它想象成一个“条件”. 但可表达性给出了一个断言 <span class="math inline">\(A\)</span>，使得断言成立的状态恰好就是这些状态，所以这个最弱前置条件就被断言 <span class="math inline">\(A\)</span> 所“表达”了.</p><p>所有命令的最弱前置条件如下：</p><p><span class="math display">\[\begin{align*}wp[\mathbf{skip}, B] &amp;= B \\wp[X:=a, B] &amp;= B[a/X] \\wp[(c_1;~c_2), B] &amp;= wp[c_1, wp[c_2,B]] \\wp[\mathbf{if}~b~\mathbf{then}~c_0~\mathbf{else}~c_1,B] &amp;= (b\Rightarrow wp[c_1,B])\wedge (\neg b\Rightarrow wp[c_2,B]) \\wp[\mathbf{while}~b~\mathbf{do}~c, B] &amp;= \bigwedge_i F_i(B) \\其中~ F_0(B)=\mathbf{true},&amp;~F_{i+1}(B)=(\neg b\Rightarrow B)\wedge (b\Rightarrow wp[c, F_i(B)]).\end{align*}\]</span></p><p>然后我们可以得到如下的两条引理：</p><blockquote><p><strong>Lem. 1</strong> <span class="math inline">\(\forall c\in\mathbf{Com}\)</span>，<span class="math inline">\(Q\in\mathbf{Assn}\)</span>，有<span class="math display">\[\vDash\{wp[c,Q]\}~c~\{Q\}~且~\forall R\in\mathbf{Assn}.~\vDash \{R\}~c~\{Q\}~意味着~(R\Rightarrow wp[c,Q])\]</span></p></blockquote><blockquote><p><strong>Lem. 2</strong> <span class="math inline">\(\forall c\in\mathbf{Com}\)</span>，<span class="math inline">\(Q\in\mathbf{Assn}\)</span>，有 <span class="math inline">\(\vdash \{wp[c,Q]\}~c~\{Q\}\)</span>.</p></blockquote><p>有了这两条，即可证明相对完备性. 其大致思路是：</p><ul><li>对任意命令 <span class="math inline">\(c\)</span>，断言 <span class="math inline">\(P\)</span> 和 <span class="math inline">\(Q\)</span>，s.t. <span class="math inline">\(\vDash \{P\}~c~\{Q\}\)</span>；</li><li>由 Lem 1，有 <span class="math inline">\(\vDash P\Rightarrow wp[c,Q]\)</span>；</li><li>由 Lem 2，有 <span class="math inline">\(\vdash \{wp[c,Q]\}~c~\{Q\}\)</span>；</li><li>由 Consequence rule，可知 <span class="math inline">\(\vdash \{P\}~c~\{Q\}\)</span>.</li></ul><blockquote><p>这里略去了很多细节，具体细节参见 Winskel 的书.</p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 计算机 </tag>
            
            <tag> 北大 </tag>
            
            <tag> 数理逻辑 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>魔方杂记</title>
      <link href="/2020/03/24/Cube/"/>
      <content type="html"><![CDATA[<blockquote><p>疫情影响不能出门，在家又玩起了魔方…接触魔方已有很多年，玩过十几种不同的魔方了，把一些东西记录下来，给自己看. （被迫学习了一波 <code>canvas</code> + <code>js</code> 画图…）</p></blockquote><ul><li>符号说明</li><li>233 魔方还原方法（网上的相关资源不多，且质量不高）</li><li>5 阶魔方的棱</li><li>三阶魔方奇奇怪怪的姿势（×）</li></ul><a id="more"></a><h2 id="描述魔方转动的记号singmaster-notation">描述魔方转动的记号——Singmaster Notation</h2><p>简单来说，就是用符号来表示魔方的转动.</p><blockquote><p>现行的符号体系图解参见 <a href="http://www.mf100.org/base/about.php" target="_blank" rel="noopener">http://www.mf100.org/base/about.php</a></p></blockquote><p>比起那种平平无奇（×）的定义，我更想递归描述一下（什么毛病？）</p><p>那么我要开始了…（×）</p><p>先定义一下字符集：</p><ul><li>字母——表示旋转<ol type="1"><li><strong>单面操作</strong>：<code>U D L R F B</code>，分别表示上下左右前后面（单面）顺时针旋转90°；</li><li><strong>双面操作</strong>：<code>u d l r f b</code>，分别表示上下左右前后面（双面）顺时针旋转90°，i.e. 单面+中间层一起转；</li><li><strong>中层操作</strong>：<code>E M S</code>（<del>不是特快专递</del>）：<ol type="1"><li><code>E</code>：<code>U</code> 和 <code>D</code> 的夹层做 <code>D</code> 方向的旋转；</li><li><code>M</code>：<code>L</code> 和 <code>R</code> 的夹层做 <code>L</code> 方向的旋转；</li><li><code>S</code>：<code>F</code> 和 <code>B</code> 的夹层做 <code>F</code> 方向的旋转；</li></ol></li><li><strong>整体操作</strong>：<code>x y z</code>，分别表示魔方整体向着 <code>R U F</code> 方向旋转90°；</li></ol></li><li>逆向符号——逆操作，可以视为 <span class="math inline">\(a^{-1}\)</span>.<ul><li><code>'</code>，可以加在所有字母后面，使得旋转方向变为逆时针.</li><li>例如：<code>U'</code> 表示顶面逆时针旋转90°.</li></ul></li><li>括号——编组<ul><li>表示将括号内的字符串编为一组. 不加括号时，单个字母（包括其后的 <code>'</code>）自成一组.</li></ul></li><li>数字——表示重复执行次数（幂次）<ul><li><span class="math inline">\(\forall n\in N_+\)</span>，可以跟在单个字母（包括其后的 <code>'</code>）后，或完整的组之后，表示重复执行 <span class="math inline">\(n\)</span> 次.<ul><li>例如：<code>U2</code> 表示顶面旋转180°.</li></ul></li></ul></li></ul><p>现在，我们可以说，公式就是由下面几条所定义的东西：</p><ol type="1"><li>空语句 <code>e</code> 是公式，表示什么都不做；</li><li>若 <code>A</code> 是公式，<code>n</code> 是数字，则 <code>(A)</code> 以及 <code>(A)n</code> 是公式；</li><li>若 <code>A</code> 是公式，<code>c</code> 是字母，则 <code>Ac</code>、<code>cA</code>、<code>Ac'</code>、<code>c'A</code> 是公式；</li></ol><p>公式应当是可以化简的：</p><ol type="1"><li>设 <code>c</code> 是字母，则相邻的 <code>cc'</code> 以及 <code>c'c</code> 可以消去；</li><li>若括号中只有单个字母，则该括号可以扔掉（废话；</li><li>以上步骤可以反复进行，直到没有任何可以消去的东西，那么这个公式应该就是最简的了（吧？）</li></ol><blockquote><p>上述内容既没有经过查证，也没有经过严格的复核…如有疏漏之处还请指正（</p></blockquote><h2 id="魔方还原">233 魔方还原</h2><blockquote><p><strong>还原方法</strong>：底层十字（很简单）<span class="math inline">\(\to\)</span>底层角块<span class="math inline">\(\to\)</span>顶层角块<span class="math inline">\(\to\)</span>顶层棱块.</p></blockquote><p>233 魔方相比三阶魔方，有一些特殊之处：</p><ul><li>侧面的棱只能转 180 度，不能转 90 度. （<code>L</code> <code>R</code> <code>F</code> <code>B</code> 都必须连做两次）.</li><li>底面还原好后，顶面也一定还原好了.<ul><li>事实上，233 魔方只有位置的变化，总变化数为 <span class="math inline">\(7!\times 8!\times 2=406425600\)</span>.</li></ul></li></ul><blockquote><p>据说可以视为三阶魔方去掉中间层，进而以三阶魔方的 <code>F2L</code> 以及 <code>PLL</code> 稍作改动来还原… 奈何本人才疏学浅，尝试几次却不得要领.</p></blockquote><p>底层十字很好做，因此从底层角块开始…</p><h3 id="底层角块">底层角块</h3><p>我们只需要解决下图中的情形：</p><p><img src="/img/blog-graph/233Cube-1L-Corner.png" alt="第一层角块"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解决方法：R2U R2U&apos; R2</span><br></pre></td></tr></table></figure><ul><li>注意：该方法能够完整保留底层所有其他块的位置不动，但不能保证顶层的其余块不动.</li></ul><h3 id="顶层角块">顶层角块</h3><p>我们只需要实现“交换相邻角块”的操作即可（暂时不管上层棱块）. 事实上，我们可以解决下图所示的情形（交换一组相邻角块以及一组相对的棱块）：</p><p><img src="/img/blog-graph/233Cube-2L-Corner.png" alt="第二层角块"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解决方法：R2U R2U&apos; R2  F2U&apos; F2U F2U&apos;</span><br></pre></td></tr></table></figure><ul><li>注意，上述操作的前一半与还原底层角块时的操作完全一样，因此前一半实际上将图中的 <code>红-白-绿</code> 块放到了底面.</li></ul><h3 id="顶层棱块">顶层棱块</h3><p>顶层棱块需要两种操作：<code>1. 交换相对的棱块</code>，<code>2. 交换相邻的棱块</code>.</p><table><tr><td><img src="/img/blog-graph/233Cube-2L-Edge1.png" alt="第二层相对棱块"></td><td><img src="/img/blog-graph/233Cube-2L-Edge2.png" alt="第二层相邻棱块"></td></tr><tr><th>相对棱块交换示意图</th><th>相邻棱块交换示意图</th></tr></table><p>对于相对棱块的情形，直接做三次 <code>R2U2</code> 即可.</p><ul><li>上述操作能够完美保证其他所有块的位置和朝向均不发生变化. 因此可利用该操作还原相邻棱块的情形.</li></ul><p>事实上，对于相邻棱块，先做 <code>R2 D B2</code>，即可将右边的棱块（图中第二层右边的黄色棱块）转移到背面，此时就变成了相对的情形，按照相对棱块的办法复原，再还原即可.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解决方法：</span><br><span class="line">    相对棱块：R2U2 R2U2 R2U2，简记为 (R2U2)×3</span><br><span class="line">    相邻棱块：(R2 D B2) (R2U2)×3 (B2 D&apos; R2)</span><br></pre></td></tr></table></figure><h3 id="其他操作">其他操作</h3><blockquote><p>可以做的一些其他操作.</p></blockquote><h4 id="两层同时交换相邻的棱块和角块">两层同时交换相邻的棱块和角块</h4><p>解决如下情形：</p><p><img src="/img/blog-graph/233Cube-Other1.png" alt="其他操作-1"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解决方法：R2U&apos;R2U DR2D&apos;R2</span><br></pre></td></tr></table></figure><h4 id="同时调整第二层的三个棱块">同时调整第二层的三个棱块</h4><p>解决如下两种情形：</p><table><tr><td><img src="/img/blog-graph/233Cube-2L-Edge3.png" alt="顺时针轮换"></td><td><img src="/img/blog-graph/233Cube-2L-Edge4.png" alt="逆时针轮换"></td></tr><tr><th>棱块顺时针轮换示意图</th><th>棱块逆时针轮换示意图</th></tr></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解决方法：</span><br><span class="line">    顺时针：RURU&apos;R F LU&apos;LUL F（图 1）</span><br><span class="line">    逆时针：LU&apos;LUL F RURU&apos;R F（图 2）</span><br></pre></td></tr></table></figure><h3 id="参考资料">参考资料</h3><ol type="1"><li>http://affairs.ymhs.tyc.edu.tw/reheart/RC/th/3x3x2.htm</li></ol><blockquote><p>此外，还有一种类似于三阶魔方“缺角层先法”的还原思路，参考 <a href="http://www.soongsky.com/cube/solve233/" target="_blank" rel="noopener">http://www.soongsky.com/cube/solve233/</a></p></blockquote><h2 id="五阶魔方的棱">五阶魔方的棱</h2><h3 id="翻棱">翻棱</h3><p>常规的拼棱方法是把两侧的棱块逐个（按照正确的方向）拼到最中间的棱块上. 事实上，只需要如下的一个公式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUR&apos; FR&apos;F&apos;R</span><br></pre></td></tr></table></figure><ul><li>该公式的效果是把 <code>R</code> 面和 <code>F</code> 面交叉的棱翻转过来，具体可以在三阶魔方上验证.</li></ul><h3 id="最后一组棱">最后一组棱</h3><p>最后一组棱可能会出现位置对但方向不对的情况，如下图所示：</p><p><img src="/img/blog-graph/5Cube-Edge1.png" alt="五阶魔方的最后一组棱"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解决方法：r2 B2 U2 l U2 r&apos; U2 r U2 F2 r F2 l&apos; B2 r2</span><br></pre></td></tr></table></figure><ul><li>上述操作同时也会将图中 <code>蓝-黄</code> 和 <code>绿-黄</code> 位置的两组棱以及角块互换，其他块保持不变.<ul><li>不过好像并没有什么实质作用…</li><li>比较有用的说法是：上述操作不会破坏其他已经拼好的棱</li></ul></li></ul><h3 id="拼棱法">84 拼棱法</h3><h2 id="三阶魔方的各种玩法">三阶魔方的各种玩法</h2><p>先贴一个关于解法之间的比较：</p><blockquote><p>知乎 为什么很多人都采取层先法？<a href="https://www.zhihu.com/question/59164976" target="_blank" rel="noopener">https://www.zhihu.com/question/59164976</a></p></blockquote><h3 id="层先">层先</h3><p>相关资源特别多：</p><ul><li>一个从第一层开始教学的教程：<ul><li><a href="https://debug.fanzheng.org/post/how-to-solve-a-rubik-cube-with-layer-method.html" target="_blank" rel="noopener">https://debug.fanzheng.org/post/how-to-solve-a-rubik-cube-with-layer-method.html</a></li><li>此教程详细但有些部分略显赘余</li></ul></li><li>一个简洁但内容足够充分的教程：<ul><li><a href="https://cube3x3.com/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%AD%94%E6%96%B9/" target="_blank" rel="noopener">https://cube3x3.com/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%AD%94%E6%96%B9/</a></li></ul></li></ul><blockquote><p>但是，层先法有着不同的路数..</p></blockquote><h4 id="我最初接触的层先法">我最初接触的层先法</h4><p>笔者从初中（大约11年或者12年）开始接触魔方. 好像是在太原某超市买了一个10元上下的魔方（品牌好像是永俊？），对着说明书研究了一个中午搞会了还原方法…那本说明书很短但很清晰，算是我的启蒙导师吧…因此，凭借自己（应该比较靠谱）的回忆，在这里描述一下这个还原方法：</p><table><tr><th>底面做十字</th><th>复原底面角块</th><th>复原中层棱块</th><th>顶面做十字</th><th>复原顶面角块</th><th>复原顶层棱块</th></tr><tr><td><img src="/img/blog-graph/3Cube-Cross.png"></td><td><img src="/img/blog-graph/3Cube-F1L.png"></td><td><img src="/img/blog-graph/3Cube-F2L.png"></td><td><img src="/img/blog-graph/3Cube-LLCross.png"></td><td><img src="/img/blog-graph/3Cube-LLEdge.png"></td><td><img src="/img/blog-graph/3Cube-Init.png"></td></tr></table><p>具体用到的公式及简略说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">第一层就不多bb了...</span><br><span class="line"></span><br><span class="line">第二层：</span><br><span class="line">    若某个棱块不在自己的位置上，那么它要一定在顶层，因此只需将其下移至第二层. </span><br><span class="line">    具体地，考虑以下两种情况</span><br><span class="line">        - RU交界棱块 → RF交界处：U R U&apos;R&apos;+ U&apos;F&apos;U F</span><br><span class="line">        - FU交界棱块 → RF交界处：U&apos;F&apos;U F + U R U&apos;R&apos;</span><br><span class="line">    ** 容易看出上述两个公式就是换了一下顺序...</span><br><span class="line"></span><br><span class="line">顶层棱块朝向：</span><br><span class="line">    前两层完成后顶面棱块只有四种可能情况(+表示与中心块同色，·表示异色)，我们的目标是4（十字）：</span><br><span class="line">        1. ···   2. ·+·   3. ·+·   4. ·+·</span><br><span class="line">           ·+·      ·+·      ++·      +++</span><br><span class="line">           ···      ·+·      ···      ·+·</span><br><span class="line">    以下公式会使顶面棱块按照 1-&gt;2-&gt;3-&gt;4-&gt;2... 的循环变化.</span><br><span class="line">        - R&apos; U&apos; F U F R</span><br><span class="line"></span><br><span class="line">顶层角块位置：</span><br><span class="line">    以下公式会使顶层除BLU交界角块外的其余三个角块的位置产生轮换.</span><br><span class="line">    OO1  如左边所示：</span><br><span class="line">    OOO  顺时针轮换：1-&gt;2-&gt;3-&gt;1</span><br><span class="line">    3O2  逆时针轮换：1-&gt;3-&gt;2-&gt;1</span><br><span class="line">        - 逆时针：F B&apos; U&apos;B U F&apos;U&apos;B&apos;U B</span><br><span class="line">        - 顺时针：L R&apos; U L&apos;U&apos;R U L U&apos;L&apos;</span><br><span class="line">    ** 上述公式不会改变棱块位置，但会改变角块朝向.</span><br><span class="line"></span><br><span class="line">顶层角块朝向：</span><br><span class="line">    以下公式会使顶层三个角块向相同方向旋转.</span><br><span class="line">        - 除BLU角块外，其他角块逆时针旋转：R&apos;U&apos;R U&apos;R&apos;U2 R U2</span><br><span class="line">        - 除BRU角块外，其他角块顺时针旋转：L U L&apos;U L U2 L&apos;U2</span><br><span class="line">    ** 上述公式不会改变角块位置，但会改变棱块位置.</span><br><span class="line"></span><br><span class="line">顶层棱块位置：</span><br><span class="line">    以下公式会使顶层除BU交界棱块外的其余三个棱块的位置产生轮换.</span><br><span class="line">    OOO  如左边所示：</span><br><span class="line">    3O1  顺时针轮换：1-&gt;2-&gt;3-&gt;1</span><br><span class="line">    O2O  逆时针轮换：1-&gt;3-&gt;2-&gt;1</span><br><span class="line">        - 逆时针：L&apos;U&apos;L U&apos;L&apos;U2 L U + L U L&apos;U L U2 L&apos;U&apos;</span><br><span class="line">        - 顺时针：R U R&apos;U R U2 R&apos;U&apos;+ R&apos;U&apos;R U&apos;R&apos;U2 R U </span><br><span class="line">    ** 稍后会看到，这两条公式的前半段是交换一对相邻的棱块，但会破坏角块朝向.</span><br><span class="line">    ** 很容易看出，后半段是还原角块朝向（收拾烂摊子...</span><br></pre></td></tr></table></figure><p>很容易发现上述公式有一些可以简化的部分…随意列出几条：</p><ol type="1"><li>做顶面十字时，可能需要连续操作 2 或 3 次 <code>R' U' F U F R</code>，此时相邻的 <code>R</code> 和 <code>R'</code> 可以抵消.</li><li><p>调整顶层棱块位置时（以顺时针为例）：我们需要做的是 <code>R U R'U R U2 R'U'+ R'U'R U'R'U2 R U</code>. <strong>其中</strong>，“+” 前的最后一个 <code>U'</code> 是在调整顶层的角度，使得可以不转动魔方而直接套用角块朝向公式. <strong>但实际上这一步是多余的</strong>，因而在角块的方向还原（<code>R'U'R U'R'U2 R</code>）后，我们需要做额外的一步 <code>U</code> 来还原顶层角度. 我们可以旋转整个魔方，来简化这个操作. 简化后的公式为： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">逆时针：L&apos;U&apos;L U&apos;L&apos;U2 L + y + L U L&apos;U L U2 L&apos;</span><br><span class="line">顺时针：R U R&apos;U R U2 R&apos;+ y&apos;+ R&apos;U&apos;R U&apos;R&apos;U2 R</span><br></pre></td></tr></table></figure></p></li><li><p>仍然是调整顶层棱块位置时，对于以下情况需要做两次公式. 但可以有一个替代的方案，步数大约是原先的一半： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">考虑以下情形——相邻棱块两两互换. 按照公式有如下解法：</span><br><span class="line">    O4O    O2O    O1O  这里是做两次顺时针轮换（243）和（124）</span><br><span class="line">    1O3 -&gt; 1O4 -&gt; 4O2    解法不唯一.</span><br><span class="line">    O2O    O3O    O3O </span><br><span class="line">但是我们可以考虑如下操作：</span><br><span class="line">    - M S D S&apos; D2 M&apos;</span><br><span class="line">    ** 该操作的效果为：</span><br><span class="line">        1. 交换UF棱块与UR棱块</span><br><span class="line">        2. 交换DB棱块与DL棱块（注意，涉及到的四个棱块恰好分列LRFB四个侧面）</span><br><span class="line">        3. 底层错位90度（相当于做了一次 D）</span><br><span class="line">因此我们对上述情况：</span><br><span class="line">    1. 先做一次 MSDS&apos;D2M&apos;，复原顶层的一组相邻棱块. </span><br><span class="line">    2. 然后做一次 D&apos;，使得未被复原的棱块分列四个侧面. </span><br><span class="line">    3. 此时将魔方整个水平旋转180度（y2），再做一次 MSDS&apos;D2M&apos;，即可将棱块全部复原. </span><br><span class="line">    4. 最后再做 D&apos;，将底面角度调整好即可.</span><br><span class="line"></span><br><span class="line">综上所述，交换顶面两组相邻棱块时，可以采取下述公式，减少步数：</span><br><span class="line">    - MSDS&apos;D2M&apos; D&apos; y2 MSDS&apos;D2M&apos; D&apos;</span><br><span class="line">    ** 不过其中使用了太多的中间层操作，在速度上未必会有显著提升.</span><br><span class="line">    ** 事实上，CFOP 的 PLL 中还有更好的做法.</span><br></pre></td></tr></table></figure></p></li></ol><h4 id="网站-rubiks-cu.be">网站 rubiks-cu.be</h4><p>网站 <a href="ribuks-cu.be">rubiks-cu.be</a> 同样给出了一种还原方法. 在顶面十字做好后，后续操作与上一套做法有些不同：</p><table><tr><th>底面做十字</th><th>复原底面角块</th><th>复原中层棱块</th><th>顶面做十字</th><th>复原顶层棱块</th><th>复原顶层角块</th></tr><tr><td><img src="/img/blog-graph/3Cube-Cross.png"></td><td><img src="/img/blog-graph/3Cube-F1L.png"></td><td><img src="/img/blog-graph/3Cube-F2L.png"></td><td><img src="/img/blog-graph/3Cube-LLCross.png"></td><td><img src="/img/blog-graph/3Cube-LLEdge1.png"></td><td><img src="/img/blog-graph/3Cube-Init.png"></td></tr></table><p>这里引起我注意的主要是棱块位置的还原，以及角块的轮换：</p><ul><li>关于顶面棱块的位置，这里给出的公式是 <code>RUR'URU2R'U</code>. 与上一套做法中最后一步“轮换棱块”的公式的前一半基本相同. 该网站对此公式的说明“swap edges”，事实上相当贴切…因为这个操作的效果就是交换 <code>UF</code> 棱块与 <code>UL</code> 棱块.</li><li>关于角块的轮换，给出了一种不同的公式： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">先给出公式：U R U&apos; L&apos; U R&apos; U&apos; L</span><br><span class="line">其作用如下：（俯视图，上为F，下为B，左为L，右为R）</span><br><span class="line">    2O1    1O3   即：除FRU角块外的其余三个角块逆时针轮换.</span><br><span class="line">    OOO -&gt; OOO   </span><br><span class="line">    3OX    2OX   </span><br><span class="line">    ** 该公式能保持所有棱块不发生任何变化，但会改变顶层角块朝向</span><br><span class="line">    ** 其对顶层角块带来的朝向改变与上一套中相应公式带来的变化不同</span><br></pre></td></tr></table></figure></li></ul><p>这里对角块朝向的处理也非常有趣：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">只需要反复做 R&apos;D&apos;RD，就必定可以将FRU角块还原.（为什么？值得思考）</span><br><span class="line">    - 并且不破坏任何棱块，也不破坏其他角块的位置! </span><br><span class="line">之后，我们将其他未还原的顶层角块转到FRU位置，继续反复做R&apos;D&apos;RD即可...</span><br></pre></td></tr></table></figure><h4 id="gan-说明书">GAN 说明书</h4><blockquote><p>参考链接：<a href="https://www.gancube.com/layer-by-layer-guide-of-gancube" target="_blank" rel="noopener">https://www.gancube.com/layer-by-layer-guide-of-gancube</a></p></blockquote><p>2020年寒假期间在家突然想起了魔方，但是先前的魔方已经找不到了（大概是送给别人了），因此买了一个 GAN 的魔方，其说明书比较长，包括了层先法与 CFOP. 这里给出的层先法也是非常有 “CFOP 味道” 的一种做法：</p><table><tr><th>底面十字</th><th>底面角块</th><th>中层棱块</th><th>顶面棱块朝向</th><th>顶面角块朝向</th><th>顶面角块位置</th><th>顶面棱块位置</th></tr><tr><td><img src="/img/blog-graph/3Cube-Cross.png"></td><td><img src="/img/blog-graph/3Cube-F1L.png"></td><td><img src="/img/blog-graph/3Cube-F2L.png"></td><td><img src="/img/blog-graph/3Cube-LLCross.png"></td><td><img src="/img/blog-graph/3Cube-OLL.png"></td><td><img src="/img/blog-graph/3Cube-LLCorner.png"></td><td><img src="/img/blog-graph/3Cube-Init.png"></td></tr></table><p>前四步与先前的所有层先法都完全相同. 在还原顶面角块朝向时，使用的公式与第一套做法中的公式相同. 值得关注的主要是角块位置的还原：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这一步只用到一个公式：(R&apos;U) (L&apos;U2) (RU&apos;) (R&apos;U2) LR</span><br><span class="line">其具体作用是将LBU角块与RBU角块互换：</span><br><span class="line">1O2    2O1   ** 该操作会破坏棱块，它实际上是同时交换了角块和棱块</span><br><span class="line">OOO -&gt; OOO     1b2    2a1</span><br><span class="line">XOX    XOX     aOO -&gt; bOO  事实上这样画更为准确（第三行不受影响，所以省略了）</span><br></pre></td></tr></table></figure><p>GAN教程中的最后一步使用的是 <code>M'2 U M U2 M' U M'2</code>，不过并没有什么值得关注的地方.</p><h3 id="升级版层先法cfop">升级版层先法——CFOP</h3><p>又名 Fridrich 方法，分为 <code>Cross</code>, <code>F2L</code>, <code>OLL</code>, <code>PLL</code> 四步，所以一般叫 CFOP：</p><ul><li><code>C</code>-底层十字：<code>Cross</code>，无公式</li><li><code>F</code>-前两层：<code>F2L</code>（First 2 Layers），41 个公式</li><li><code>O</code>-顶面块朝向：<code>OLL</code>（Orientation of Last Layer），57 个公式</li><li><code>P</code>-顶面块位置：<code>PLL</code>（Permutation of Last Layer），21 个公式</li></ul><table><tr><th>底层做十字</th><th>还原前两层</th><th>还原顶面朝向</th><th>还原顶面位置</th></tr><tr><td><img src="/img/blog-graph/3Cube-Cross.png"></td><td><img src="/img/blog-graph/3Cube-F2L.png"></td><td><img src="/img/blog-graph/3Cube-OLL.png"></td><td><img src="/img/blog-graph/3Cube-Init.png"></td></tr></table><p>总公式量为 <span class="math inline">\(41+57+21=119\)</span>.</p><blockquote><p>CFOP 详见: http://www.rubik.com.cn/fridrichold.htm</p></blockquote><p>另有一篇介绍了 8 种速解方法的文章：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/57816260" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/57816260</a><ul><li>出自专栏：<a href="https://zhuanlan.zhihu.com/c_1013368685897101312" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/c_1013368685897101312</a></li></ul></li></ul><h3 id="角先">角先</h3><p>还原步骤：</p><table><tr><th>底层角块</th><th>顶层角块</th><th>中层棱块</th><th>底层棱块</th><th>顶层棱块</th></tr><tr><td><img src="/img/blog-graph/3Cube-CornerFirst1.png"></td><td><img src="/img/blog-graph/3Cube-CornerFirst2.png"></td><td><img src="/img/blog-graph/3Cube-CornerFirst3.png"></td><td><img src="/img/blog-graph/3Cube-CornerFirst4.png"></td><td><img src="/img/blog-graph/3Cube-Init.png"></td></tr></table><ol type="1"><li><p>还原所有角块 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">底层角块：很容易，无公式</span><br><span class="line">顶层角块：可以使用层先法调整顶层角块的公式</span><br></pre></td></tr></table></figure></p></li><li><p>还原中层棱块 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只有一个公式：M&apos; R U&apos; M U R&apos;</span><br></pre></td></tr></table></figure></p></li><li>还原底层棱块：很容易，琢磨一下即可（</li><li><p>还原顶层棱块朝向（EOLL）： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">翻转一组相邻棱块（FU和RU）：</span><br><span class="line">    - M U M&apos; U2 M U M&apos;</span><br><span class="line">    ** 实际上只需要这一个公式好像就够了...</span><br><span class="line"></span><br><span class="line">翻转一组相对棱块（FU和BU）：</span><br><span class="line">    - (x&apos;) M&apos; U&apos; R U M U&apos; R&apos; U (x)</span><br><span class="line"></span><br><span class="line">四个棱块同时翻转：</span><br><span class="line">    - M&apos; U2 M U2 M&apos; U M U2 M&apos; U2 M</span><br></pre></td></tr></table></figure></p></li><li><p>还原顶层棱块位置（EPLL）：同层先法.</p></li></ol><p>参考 <a href="https://www.speedsolving.com/wiki/index.php/Corners_First" target="_blank" rel="noopener">https://www.speedsolving.com/wiki/index.php/Corners_First</a></p><h3 id="棱先">棱先</h3><blockquote><p>棱先法已经基本被抛弃了…</p></blockquote><table><tr><th>顶层十字</th><th>中层棱块</th><th>底层棱块</th><th>复原角块</th></tr><tr><td><img src="/img/blog-graph/3Cube-EdgeFirst-1.png"></td><td><img src="/img/blog-graph/3Cube-EdgeFirst-2.png"></td><td><img src="/img/blog-graph/3Cube-EdgeFirst-3.png"></td><td><img src="/img/blog-graph/3Cube-Init.png"></td></tr></table><ul><li>1990s Rubiks.com solution：<a href="https://web.archive.org/web/20020208140757/http://www.rubiks.com:80/cubesolution_new.html" target="_blank" rel="noopener">https://web.archive.org/web/20020208140757/http://www.rubiks.com:80/cubesolution_new.html</a><ul><li>古老的解法……属于棱先法</li><li>棱先法还有多种变化，参考 <a href="https://www.speedsolving.com/wiki/index.php/Edges_First" target="_blank" rel="noopener">https://www.speedsolving.com/wiki/index.php/Edges_First</a></li></ul></li><li>一个中文的资料：<a href="http://roburchou.lofter.com/post/1d235558_686872c" target="_blank" rel="noopener">http://roburchou.lofter.com/post/1d235558_686872c</a></li></ul><h3 id="桥式roux-method">桥式（Roux method）</h3><p>常用于最小步还原的一种还原方法，参见 <a href="https://www.speedsolving.com/wiki/index.php/Roux_method" target="_blank" rel="noopener">https://www.speedsolving.com/wiki/index.php/Roux_method</a></p><h3 id="其他方法">其他方法</h3><ul><li>缺角层先法：http://www.soongsky.com/cube/solve/</li><li>Columns First Methods：https://www.speedsolving.com/wiki/index.php/Columns_First_Methods</li></ul><h2 id="魔方资源整理">魔方资源整理</h2><p>直接搜的话太过零散了…做个简单整理（</p><ul><li>速解相关：<a href="https://www.speedsolving.com/wiki/index.php/Main_Page" target="_blank" rel="noopener">https://www.speedsolving.com/wiki/index.php/Main_Page</a></li><li>五魔方相关：<a href="http://www.mf100.org/megaminx/wumo.php" target="_blank" rel="noopener">http://www.mf100.org/megaminx/wumo.php</a><ul><li>二阶五魔方只需要顶层的角块公式，其余自己摸索就很容易做出.</li></ul></li><li>sq-1 魔方相关：<a href="http://www.mf100.org/sq1/index.htm" target="_blank" rel="noopener">http://www.mf100.org/sq1/index.htm</a></li><li>最小步数还原：<a href="http://fmcsolves.cubing.net/fmc_tutorial_ENG.odt" target="_blank" rel="noopener">http://fmcsolves.cubing.net/fmc_tutorial_ENG.odt</a><ul><li>中文版：<a href="https://cuberl.gitbooks.io/fmccn/content/" target="_blank" rel="noopener">https://cuberl.gitbooks.io/fmccn/content/</a></li></ul></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 魔方 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Windows 命令行的一些使用技巧</title>
      <link href="/2020/03/11/Some-Cmd-skills-for-Windows/"/>
      <content type="html"><![CDATA[<p>常用系统还是windows，在使用过程中记录一些实用的技巧.</p><a id="more"></a><ul><li>批量给文件加前缀</li></ul><blockquote><p>下述代码会给当前目录下的所有 <code>.jpg</code> 文件加一个 <code>图像_</code> 的前缀.</p></blockquote><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> /f "delims=-" %i <span class="keyword">in</span> ('<span class="built_in">dir</span> *.jpg /b') <span class="keyword">do</span> <span class="built_in">move</span> %i 图像_%i</span><br></pre></td></tr></table></figure><ul><li>卸载 Windows 10 自带的 Groove 音乐</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">首先运行：Get-AppxPackage -AllUsers &gt; a.txt 如此即可将所有应用打在 a.txt 中.</span><br><span class="line"></span><br><span class="line">打开 a.txt，找到 ZuneMusic 一项，例如我这里的长这个样子：</span><br><span class="line">    Name                   : Microsoft.ZuneMusic</span><br><span class="line">    Publisher              : CN=Microsoft Corporation....</span><br><span class="line">    Architecture           : X64</span><br><span class="line">    ResourceId             : </span><br><span class="line">    Version                : <span class="number">10.20022</span>.<span class="number">11011.0</span></span><br><span class="line">    PackageFullName        : Microsoft.ZuneMusic_10.<span class="number">20022.11011</span>.<span class="number">0</span>_x64__8wekyb3d8bbwe</span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">找到其中的 PackageFullName 一项，这里是 Microsoft.ZuneMusic_10.<span class="number">20022.11011</span>.<span class="number">0</span>_x64__8wekyb3d8bbwe</span><br><span class="line">接下来运行 Remove-AppxPackage Microsoft.ZuneMusic_10.<span class="number">20022.11011</span>.<span class="number">0</span>_x64__8wekyb3d8bbwe 即可</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cmd </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论文笔记[14]——Private Pareto Optimal Exchange</title>
      <link href="/2020/03/08/Paper-reading-14-Private-pareto-optimal-exchange/"/>
      <content type="html"><![CDATA[<p>Justin Hsu 在其 STOC 2014 的工作中表明了，在 dp，甚至是放宽条件后的 Joint-dp 之下，都无法保证得到一个渐进 Pareto 最优的分配（在所有分配参与者都是理性的情况下）. 因此，在此工作中使用了比 Joint-dp 更为宽松的 Marginal-dp，并在此条件下找到了渐进 Pareto 最优的分配.</p><ul><li><font color="red">注意，本文中的市场是一个以物易物（barter）的市场.</font></li></ul><blockquote><p>Sampath Kannan, et al. Private pareto optimal exchange. ACM Transactions on Economics and Computation (TEAC), 2018.</p></blockquote><a id="more"></a><h2 id="model">MODEL</h2><ul><li><span class="math inline">\(k\)</span> 种类型的物品，类型集合记为 <span class="math inline">\(\mathcal{G}=\{g_1,\ldots,g_k\}\)</span>. <span class="math inline">\(n\)</span> 个 agent，记为 <span class="math inline">\(N\)</span>；<ul><li>初始状态下，每个人都有每个物品恰好一个；</li><li>每个人都对所有物品有一个偏好，记为 <span class="math inline">\(\succ_i\)</span>；</li></ul></li><li>记 <span class="math inline">\(N_j=\{i: g_i=j\}\)</span>，<span class="math inline">\(n_i=|N_j|\)</span>，用以表示把物品 <span class="math inline">\(j\in\mathcal{G}\)</span> 带入市场的 agent.<ul><li>由于每个人每种物品只带一个，故 <span class="math inline">\(\sum_{j\in\mathcal{G}} n_j=n\)</span></li></ul></li></ul><blockquote><p><strong>定义 2.3 (IR)</strong> 一个分配 <span class="math inline">\(\pi\)</span> 若满足 <span class="math inline">\(\pi(i)\succeq_i g_i,~\forall i\in N\)</span>，则称其是 Individual Rational（IR）的.</p></blockquote><blockquote><p><strong>定义 2.4 (<span class="math inline">\(\alpha\)</span>-PO)</strong> 一个分配 <span class="math inline">\(\pi\)</span>，若对其他任何分配 <span class="math inline">\(\pi&#39;\)</span>，若存在 <span class="math inline">\(S\subset N\)</span>，s.t. <span class="math inline">\(|S|&gt;\alpha n\)</span> 且 <span class="math inline">\(\pi&#39;(i)\succ_i \pi(i)\)</span>，<span class="math inline">\(\forall i\in S\)</span>，则必定存在一些 <span class="math inline">\(j\in N\backslash S\)</span>，s.t. <span class="math inline">\(\pi(j)\succ_j \pi&#39;(j)\)</span>，则称 <span class="math inline">\(\pi\)</span> 是 <span class="math inline">\(\alpha\)</span>-Pareto Optimal（PO）的.</p></blockquote><ul><li>换言之, 一个分配是 <span class="math inline">\(\alpha-PO\)</span> 的，如果严格提升 <span class="math inline">\(\alpha\)</span> 比例的 agent 的收益，会严格损害至少一个 agent 的利益.</li></ul><blockquote><p><strong>定义 2.5（Joint dp）</strong> 机制 <span class="math inline">\(M:\mathcal{X}^n\to O^n\)</span> 满足 <span class="math inline">\((\epsilon,\delta)\)</span>-joint dp，如果 <span class="math inline">\(\forall i\in[n]\)</span>，以及 <span class="math inline">\(x_i,x_i&#39;\in\mathcal{X}\)</span>，<span class="math inline">\(\mathbf{x}_{-i}\in\mathcal{X}^{n-1}\)</span>，以及 <span class="math inline">\(\forall B_{-i}\subseteq O^{n-1}\)</span>，总有： <span class="math display">\[\left.\mathbb{P}\left(M\left(\mathbf{x}_{-i}, x_{i}\right)_{-i} \in B_{-i}\right) \leq e^{\epsilon} \mathbb{P}\left(M\left(\mathbf{x}_{-i}, x_{i}^{\prime}\right)\right)_{-i} \in B_{-i}\right)+\delta.\]</span></p></blockquote><p>本文提出了一个比联合差分隐私更宽松的隐私：边缘差分隐私：</p><blockquote><p><strong>定义 2.6 （Marginal dp）</strong> 机制 <span class="math inline">\(M:\mathcal{X}^n\to O^n\)</span> 满足 <span class="math inline">\((\epsilon,\delta)\)</span>-marginal dp，如果 <span class="math inline">\(\forall i\neq j\)</span>，<span class="math inline">\(\forall \mathbf{x}_{-i}\in\mathcal{X}^{n-1}\)</span>，<span class="math inline">\(\forall x_i,x_i&#39;\in\mathcal{X}\)</span>，以及 <span class="math inline">\(\forall B\subset O\)</span>，总有： <span class="math display">\[\mathbb{P}\left(M\left(\mathbf{x}_{-i}, x_{i}\right)_{j} \in B\right) \leq e^{\epsilon} \mathbb{P}\left(M\left(\mathbf{x}_{-i}, x_{i}^{\prime}\right)_{j} \in B\right)+\delta.\]</span></p></blockquote><h2 id="lower-bounds">LOWER BOUNDS</h2><ol type="1"><li>在 Joint-dp 下，无法同时满足 IR 和 渐进PO.</li><li>在 Marginal-dp 下，所有 IR 且 <span class="math inline">\(\alpha\)</span>-PO 的分配都需要满足 <span class="math inline">\(\alpha=\Omega(k/n)\)</span>. 其中 <span class="math inline">\(k\)</span> 表示物品种类数.</li></ol><h3 id="在-joint-dp-下的不可能结果">在 Joint-dp 下的不可能结果</h3><p>不可能结果是基于如下断言来证明的：</p><blockquote><p><strong>CLAIM 3.1</strong> 不存在 <span class="math inline">\((\epsilon,\delta)\)</span>-dp 机制 <span class="math inline">\(M:\{0,1\}\to \{0,1\}\)</span>，s.t. <span class="math inline">\(\mathbb{P}(M(b)=b)&gt;\frac{e^\epsilon+\delta}{e^\epsilon+1}\)</span>，<span class="math inline">\(b=0,1\)</span>.</p></blockquote><ul><li>利用 dp 的定义即可证明.</li></ul><p>在 exchange markets 中，设 <span class="math inline">\(\mathcal{X}=\mathcal{G}\times\mathcal{T}\)</span>，其中 <span class="math inline">\(\mathcal{G}\)</span> 是物品的类型，<span class="math inline">\(\mathcal{T}\)</span> 是 <span class="math inline">\(\mathcal{G}\)</span> 上的线性序.</p><ul><li>下面的定理说明了不能同时保证隐私性、IR、和 <span class="math inline">\(o(1)\)</span>-PO.</li></ul><blockquote><p><strong>定理 3.2</strong> 对 <span class="math inline">\(\forall \epsilon,\delta,\beta&gt;0\)</span>，若有一个机制 <span class="math inline">\(M_J:\mathcal{X}^n\to\mathcal{G}^n\)</span> 满足 <span class="math inline">\((\epsilon,\delta)\)</span>-Joint dp，满足 IR，且有至少 <span class="math inline">\(1-\beta\)</span> 的概率满足 <span class="math inline">\(\alpha\)</span>-PO，则： <span class="math display">\[\alpha \geq 1-\frac{e^{\epsilon}+\delta}{(1-\beta)\left(e^{\epsilon}+1\right)}.\]</span></p></blockquote><ul><li><strong>证明</strong>：利用 Claim 3.1 进行归约. 若存在满足条件且 <span class="math inline">\(\alpha&gt;...\)</span> 的机制，则可以构造出与 Claim 3.1 矛盾的 <span class="math inline">\(M:\{0,1\}\to\{0,1\}\)</span>.</li></ul><blockquote><p><strong>定理 3.3</strong> 对 <span class="math inline">\(\forall \epsilon,\delta,\beta&gt;0\)</span>，若有一个机制 <span class="math inline">\(M_S:\mathcal{X}^n\to\mathcal{G}^n\)</span> 满足 <span class="math inline">\((\epsilon,\delta)\)</span>-Marginal dp，满足 IR，且有至少 <span class="math inline">\(1-\beta\)</span> 的概率满足 <span class="math inline">\(\alpha\)</span>-PO，则： <span class="math display">\[\alpha \geq \frac{k(1-\beta)}{n}\left(1-\frac{e^{\epsilon}+\delta}{e^{\epsilon}+1}\right).\]</span></p></blockquote><ul><li><strong>证明思路与 3.2 类似</strong>.</li></ul><h2 id="private-top-trading-cyclettc">PRIVATE TOP TRADING CYCLE（TTC）</h2><blockquote><p>本节主要提出了一个算法 PTTC，能够在 marginal-dp 下得到 IR 且 <span class="math inline">\(\alpha\)</span>-PO 的分配.</p></blockquote><p>首先，什么是 TTC？</p><ul><li>TTC 是一种 exchange market 的分配机制. 具体算法如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">初始状态：n 个人 1,...,n，每个人有一个物品 a_1,...,a_n. </span><br><span class="line">初始状态下 a_i 在 i 手中，且可被分配的物品池为所有物品.</span><br><span class="line"></span><br><span class="line">1. 从某个人 i 出发，找到他在当前物品池中最喜欢的物品 a_j;</span><br><span class="line">2. 找到 a_j 的主人，当然是 j;</span><br><span class="line">3. 重复进行步骤 1,2 直至成环;</span><br><span class="line">4. 若 i -&gt; j -&gt; ... -&gt; i 构成一个环，则给环上的所有人分配他们最喜欢的物品;</span><br><span class="line">5. 并把这些物品从物品池中删除;</span><br><span class="line">6. 若物品池非空，继续进行上述步骤，直到物品池空.</span><br></pre></td></tr></table></figure><p>接下来是 PTTC：</p><ul><li>输入是一个 Exchange market：<span class="math inline">\(\mathbf{x}=(g_i,\succ)_{i=1}^n\)</span></li><li>考虑有向完全图 <span class="math inline">\(G=(V,A)\)</span><ul><li>结点 <span class="math inline">\(u\in V\)</span> 代表一个 <span class="math inline">\(\mathcal{G}\)</span> 中的物品. <span class="math inline">\(\forall e=(u,v)\in A\)</span>。</li><li>定义 <span class="math inline">\(P_{(u,v)}\)</span> 为拥有物品 <span class="math inline">\(u\)</span>，但最喜欢 <span class="math inline">\(v\)</span> 的人所构成的集合，i.e. <span class="math inline">\(P_{(u,v)}=\{i\in N: g_i=u~且~v\succeq_i g,~\forall g\in V\}\)</span></li></ul></li><li>弧的权重(Arc weight)：<span class="math inline">\(w_e=|P_e|\)</span>，<span class="math inline">\(\forall e\in A\)</span>.</li><li>令 <span class="math inline">\(N_u\)</span> 表示拥有物品 <span class="math inline">\(u\)</span> 的人构成的集合. 易有 <span class="math inline">\(N=\bigcup_{u\in V} N_u\)</span>.</li></ul><p>其具体步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">step 1. 计算 arc-weights，并且加噪音（保护隐私）;</span><br><span class="line">step 2. 把在每条边上权重都足够大的环清除掉，这一步确定哪些物品需要被交易（dp）;</span><br><span class="line">step 3. 执行交易（只能满足 marginal-dp）;</span><br><span class="line">step 4. 把交易涉及的物品从物品池中删去. 有必要的话，返回 step 1.</span><br></pre></td></tr></table></figure><p>具体分析：</p><p><strong>Step 1</strong>：给 arc-weight 加入参数为 <span class="math inline">\(1/\epsilon&#39;\)</span> 的 Laplace 噪声 <span class="math inline">\(Z_e\)</span>，其中： <span class="math display">\[\epsilon^{\prime}=\frac{\epsilon \log \left(k^{3} / \beta\right)}{2 \sqrt{8}\left(\log \left(k^{3} / \beta\right) \sqrt{k \log \left(1 / \delta_{1}\right)}+k \sqrt{k \log \left(1 / \delta_{2}\right)}\right)}.\]</span></p><p><strong>Step 2</strong>：若存在环 <span class="math inline">\(C\)</span>，其中的边都满足 <span class="math inline">\(\lfloor\hat{w}_e\rfloor&gt;0\)</span>，则令 <span class="math inline">\(\hat{W}=\min_{e\in C}\{\lfloor\hat{w}_e\rfloor\}\)</span> 为 <span class="math inline">\(C\)</span> 的权重. 若无环，则到 <strong>Step 4</strong>.</p><p><strong>Step 3</strong>：若 <strong>Step 2</strong> 中得到了权重为 <span class="math inline">\(\hat{W}\)</span> 的环 <span class="math inline">\(C\)</span>，则 <span class="math inline">\(\forall e\in C\)</span>，都从 <span class="math inline">\(P_e\)</span> 中选取 <span class="math inline">\(\hat{W}\)</span> 个 agent，分别沿着边 <span class="math inline">\(e\)</span> 进行交易，称这些 agent 为 satisfied agents，记为 <span class="math inline">\(S_e\)</span>.</p><p><strong>Step 4</strong>：若 <strong>Step 2</strong> 中没有满足条件的环，则必定存在结点 <span class="math inline">\(v\)</span>，s.t. <span class="math inline">\(\hat{n}_v=\sum\limits_{e:e=(v,z),z\in V}\hat{w}_e&lt;k\)</span></p><p><strong>Step 5</strong> 若我们分配了超量的物品，或者我们选择进行交易的人超过了想要交易的人的数量，则取消这些物品的交易，并把这些人初始拥有的物品还给他们.</p><p>原文 Appendix 中的伪代码如下：</p><center><img src="/img/blog-graph/Private Pareto optimal exchange-PTTC.png" width="600" alt="A pseudo-code for PTTC"></center><p>以下为本文的核心结果之一：</p><blockquote><p><strong>定理 4.1</strong> 对 <span class="math inline">\(\epsilon,\delta_1,\delta_2,\beta&gt;0\)</span>，PTTC 提供 <span class="math inline">\((\epsilon,\delta_1+\delta_2+\beta)\)</span>-marginal dp 保护，输出的结果为 IR，同时有 <span class="math inline">\(1-\beta\)</span> 的概率输出 <span class="math inline">\(\alpha\)</span>-PO 的结果，其中： <span class="math display">\[\alpha=O\left(\frac{k^{3}}{\epsilon n} \cdot\left(\sqrt{k \log \left(1 / \delta_{1}\right)} \log \left(k^{3} / \beta\right)+k \sqrt{k \log \left(1 / \delta_{2}\right)}\right)\right).\]</span></p></blockquote><h3 id="效率的证明po-and-ir">效率的证明（PO and IR）</h3><blockquote><p><strong>引理 4.2</strong> PTTC 输出的结果是 IR 的.</p></blockquote><blockquote><p><strong>定理 4.6</strong> 对 <span class="math inline">\(\epsilon,\delta_1,\delta_2,\beta&gt;0\)</span>，PTTC 以 <span class="math inline">\(1-\beta\)</span> 的概率输出 <span class="math inline">\(\alpha\)</span>-PO 的分配，其中 <span class="math display">\[\alpha=\tilde{O}\left( \frac{k^{9/2}}{\epsilon n} \right).\]</span> 因此，PTTC 是渐进 PO 的.</p></blockquote><h3 id="隐私性分析">隐私性分析</h3><p>首先是一个引理，它展示了证明 marginal-dp 的一个途径：</p><blockquote><p><strong>引理 4.11</strong> 令 <span class="math inline">\(M^1:\mathcal{X}\to O\)</span> 为 <span class="math inline">\((\epsilon_1,\delta_1)\)</span>-dp 的，<span class="math inline">\(M_j^2:\mathcal{X}^{n-1}\times\mathcal{X}\times O\to R\)</span>，<span class="math inline">\(j=1,\ldots,n\)</span> 对其第一个变量为 <span class="math inline">\((\epsilon_2,\delta_2)\)</span>-dp 的，则 <span class="math inline">\(M:\mathcal{X}^n\to R^n\)</span> 是 <span class="math inline">\((\epsilon_1+\epsilon_2,\delta_1+\delta_2)\)</span>-marginal dp 的. 其中： <span class="math display">\[M(\mathbf{x})=\left(M_{j}^{2}\left(\mathbf{x}_{-j}, x_{j}, M^{1}(\mathbf{x})\right)\right)_{j=1}^{n}.\]</span></p></blockquote><blockquote><p><strong>定理 4.14</strong> 对 <span class="math inline">\(\epsilon,\delta_1,\delta_2,\beta&gt;0\)</span>，PTTC: <span class="math inline">\(\mathcal{X}^n\to\mathcal{G}^n\)</span> 提供 <span class="math inline">\((\epsilon,\delta_1+\delta_2+\beta)\)</span>-marginal dp.</p></blockquote><h2 id="allowing-a-small-supply-of-goods-to-be-injected">ALLOWING A SMALL SUPPLY OF GOODS TO BE INJECTED</h2><p>抛开隐私性的限制，也不使用 TTC 算法，我们可以通过解如下问题来获得 IR 且 PO 的 exchange： <span class="math display">\[\begin{aligned}&amp;\max _{z}~~\sum_{i \in[n]} \sum_{ j \in \mathcal{G}} r_{i j} z_{i j}\\&amp;\text { s.t. } \quad \sum_{j \in \mathcal{G}} z_{i j}=n_{j} \quad \forall i \in[n]\\&amp;\qquad~~~ \forall j \in \mathcal{G} \text { s.t. } g_{i}&gt;_{i} j \quad z_{i, j}=0 \quad \forall i \in[n] \\&amp;\qquad~~~ \sum_{i \in[n]} z_{i j}=1 \quad \forall j \in G \\&amp;\qquad~~~ z_{i j} \in\{0,1\}\end{aligned}\]</span> 其中：</p><ul><li>若 <span class="math inline">\(j\succeq_i g_i\)</span> 且 <span class="math inline">\(j\)</span> 是 <span class="math inline">\(i\)</span> 的第 <span class="math inline">\(r\)</span> 选择，则 <span class="math inline">\(r_{ij}=k-r+1\)</span>.</li><li>若 <span class="math inline">\(g_i\succ_i j\)</span>，则 <span class="math inline">\(w_{ij}=0\)</span>.</li></ul><blockquote><p><strong>定理 5.1</strong> 上述约束问题的解是 IR 且 PO 的.</p><blockquote><p><strong>证明：</strong> 由第二个约束条件，每个人都不会选择比自己初始拥有的物品辣鸡的物品来交换，因此是 IR 的. 另一方面，如果上述规划问题的一个解存在 Pareto 改进，将破坏该规划问题的最优性，因此是 PO 的.</p></blockquote></blockquote><p>接下来作者改进了 Justin Hsu 在 2014 年的工作，获得了渐进PO，IR 且满足 Joint-dp 的分配，但需要允许我们注入一些额外的物品.</p><blockquote><p><strong>定理 5.3</strong> 在 exchange markets 中，存在满足 <span class="math inline">\((\epsilon, \delta)\)</span> Joint-dp 的分配机制，使得导出的分配至少有 <span class="math inline">\(1-\beta\)</span> 的概率满足 <span class="math inline">\(\alpha\)</span>-PO 且总是 IR 的, 但可能需要 <span class="math inline">\(\Lambda\)</span> 个额外的物品，以使得每个人都至少得到一个物品，其中： <span class="math display">\[\alpha=O\left(\frac{k^{2} \log ^{3 / 2}(n k / \beta) \log ^{1 / 2}(n / \delta)}{\sqrt{n} \epsilon}\right) \quad \text { and } \quad \Lambda=O\left(\frac{k \sqrt{n} \log ^{3 / 2}(n k / \beta) \log ^{1 / 2}(n / \delta)}{\epsilon}\right)\]</span></p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 北大 </tag>
            
            <tag> 社会计算 </tag>
            
            <tag> 论文笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论文笔记[13]——Mechanism design via differential privacy</title>
      <link href="/2020/03/01/Paper-reading-13-Mechanism-design-via-differential-privacy/"/>
      <content type="html"><![CDATA[<blockquote><p>Frank McSherry, Kunal Talwar. Mechanism design via differential privacy. FOCS 2007.</p></blockquote>Paper Outline：<center><img src="/img/blog-graph/Mechanism design via dp-outline.png" width="400"></center><a id="more"></a><h2 id="something-about-dp">Something about dp</h2><ul><li>Approximate Truthfulness</li></ul><blockquote><p><strong>引理 3.</strong> 对 <span class="math inline">\(\forall\)</span> 满足<span class="math inline">\(\epsilon\)</span>-dp 的机制 $，以及定义在其作用域上的非负函数 <span class="math inline">\(g\)</span>. 对 <span class="math inline">\(\forall D_1,D_2\)</span> 的输入, s.t. <span class="math inline">\(|D_1\triangle D_2|=1\)</span>，均有： <span class="math display">\[E\left[g\left(\mathcal{M}\left(D_{1}\right)\right)\right] \leq \exp (\epsilon) \times E\left[g\left(\mathcal{M}\left(D_{2}\right)\right)\right]\]</span></p></blockquote><ul><li>Collusion Resistance</li></ul><blockquote><p><strong>推论 4.</strong> 对任意 <span class="math inline">\(\epsilon\)</span>-dp 的机制 <span class="math inline">\(\mathcal{M}\)</span> 以及定义在其作用域上的非负函数 <span class="math inline">\(g\)</span>，对 <span class="math inline">\(\forall D_1,D_2\)</span>，s.t. <span class="math inline">\(|D_1\triangle D_2|\leqslant t\)</span>，总有： <span class="math display">\[E\left[g\left(\mathcal{M}\left(D_{1}\right)\right)\right] \leq \exp (\epsilon t) \times E\left[g\left(\mathcal{M}\left(D_{2}\right)\right)\right]\]</span></p></blockquote><ul><li>Composability</li></ul><blockquote><p>就是 dp 的结合方法，串行进程 <span class="math inline">\(\epsilon\)</span> 相加.</p></blockquote><h2 id="a-general-dp-mechanism">A General dp Mechanism</h2><ul><li>domain: <span class="math inline">\(\mathcal{D}\)</span>，range: <span class="math inline">\(\mathcal{R}\)</span></li><li>query function：<span class="math inline">\(q:\mathcal{D}^n\times \mathcal{R}\to\mathbb{R}\)</span>，是对 <code>(input, output)</code> 二元组的估值，<span class="math inline">\(q\)</span> 越大，二者越匹配.</li></ul><p>给定 <span class="math inline">\(d\in\mathcal{D}^n\)</span>，我们希望给出一个机制，其输出为 <span class="math inline">\(r\in\mathcal{R}\)</span>，s.t. <span class="math inline">\(q(d,r)\)</span> 最大.</p><blockquote><p><strong>定义</strong> 对于 <span class="math inline">\(\forall q:\mathcal{D}^n\times\mathcal{R}\to\mathbb{R}\)</span>，以及 <span class="math inline">\(\mathcal{R}\)</span> 上的一个测度，定义： <span class="math display">\[\mathcal{E}_{q}^{\epsilon}(d):=~\text{Choose}~r~\text{with probability proportional to}~\exp (\epsilon q(d, r)) \times \mu(r)\]</span></p></blockquote><h3 id="隐私性">隐私性</h3><blockquote><p><strong>定理 6.</strong> <span class="math inline">\(\mathcal{E}^\epsilon_q\)</span> 提供 <span class="math inline">\((2\epsilon\triangle q)\)</span>-dp 保护.</p></blockquote><h3 id="准确性">准确性</h3><ul><li>令 <span class="math inline">\(\mu(A)\)</span> 为 <span class="math inline">\(A\subseteq\mathcal{R}\)</span> 的测度，且 <span class="math inline">\(\mu(\mathcal{R})=1\)</span>；</li><li>令 <span class="math inline">\(p(A)\)</span> 为 <span class="math inline">\(\mathcal{E}_q^\epsilon(d)\)</span> 所定义的测度（同样也进行正则化）；</li><li>令 <span class="math inline">\(OPT=\max_r q(d,r)\)</span>.</li></ul><blockquote><p><strong>引理 7.</strong> 令 <span class="math inline">\(S_t\{r: q(d,r)&gt;OPT-t\}\)</span>，则 <span class="math inline">\(p(\bar{S}_{2t})\)</span> 至多为 <span class="math inline">\(\exp(\epsilon t)/\mu(S_t)\)</span>.</p></blockquote><p>进一步，有如下的结果：</p><blockquote><p><strong>定理 8.</strong> 若 <span class="math inline">\(t\)</span> 满足 <span class="math inline">\(t \geq\)</span> <span class="math inline">\(\ln \left(O P T / t \mu\left(S_{t}\right)\right) / \epsilon,\)</span> 则有 <span class="math inline">\(E\left[q\left(d, \mathcal{E}_{q}^{\epsilon}(d)\right)\right] \geq O P T-3 t\)</span></p></blockquote><h2 id="applications-to-pricing-and-auctions">Applications to Pricing and Auctions</h2><p>本节将 gneral mechanism 应用于无限供给拍卖. 本节所有的机制都是 single price，且 envy-free 的.</p><hr><p>考虑一个物品无限量供给的拍卖会：</p><ul><li>每个参与者都有一个需求函数 <span class="math inline">\(b_i:[0,1]\to\mathbb{R}^+\)</span>，表示在定价为 <span class="math inline">\(p\in[0,1]\)</span> 时该参与者对物品的需求量；<ul><li>为符合常理，每一个 <span class="math inline">\(b_i\)</span> 都是不增的，且 <span class="math inline">\(\forall i,p\)</span>，<span class="math inline">\(pb_i(p)\leqslant 1\)</span>；</li></ul></li><li>对 <span class="math inline">\(\forall\)</span> 价格 <span class="math inline">\(p\)</span>，我们可以卖掉 <span class="math inline">\(\sum_i b_i(p)\)</span> 件商品，取总收益为 <span class="math inline">\(q(b,p)=p\sum_i b_i(p)\)</span>.</li></ul><blockquote><p><strong>定理 9.</strong> 取 <span class="math inline">\(q(b, p)=p \sum_{i} b_{i}(p),\)</span> 则 <span class="math inline">\(\mathcal{E}_{q}^{\epsilon}\)</span> 满足 <span class="math inline">\(2 \epsilon\)</span>-dp, 且期望收益至少为 <span class="math inline">\(O P T-3 \ln \left(e+\epsilon^{2} O P T m\right) / \epsilon,\)</span>，其中 <span class="math inline">\(m\)</span> 为 <span class="math inline">\(OPT\)</span> 情形下卖掉的商品数.</p></blockquote><hr><p>General mechanism 还可以推广到 attribute auctions.</p><blockquote><p>所谓 attribute auction，是指在拍卖的基础上考虑竞拍者的属性，将市场进行细分，为不同的人提供不同的价格，以获得更高预期收入的一种拍卖方式.</p></blockquote><ul><li>用 <span class="math inline">\(OPT_k\)</span> 表示分割为 <span class="math inline">\(k\)</span> 部分的市场的最大收入；</li><li>用 <span class="math inline">\(SEG_k\)</span> 表示 <span class="math inline">\(n\)</span> 个竞拍者进入 <span class="math inline">\(k\)</span> 个市场时被允许划分的部分数；<ul><li>有结果表明 <span class="math inline">\(SEG_k\leqslant n^{kVC}\)</span>.</li></ul></li></ul><blockquote><p><strong>定理 10.</strong> 令 <span class="math inline">\(q\)</span> 为将市场分割为 <span class="math inline">\(k\)</span> 个部分的收益函数, 则 <span class="math inline">\(\mathcal{E}_{q}^{\epsilon}\)</span> 的预期收益至少为 <span class="math display">\[O P T_{k}-3(\ln (e+\left.\left.\epsilon^{k+1} O P T_{k} S E G_{k} m^{k}\right)\right) / \epsilon.\]</span></p></blockquote><p>以下是一个看不懂的结果…</p><center><img src="/img/blog-graph/Mechanism design via dp-th 11.png" width="400"></center><hr><p>考虑一个约束定价问题：</p><blockquote><p>这是多参数问题的一个特例，即竞拍人对 <span class="math inline">\(k\)</span> 种不同的物品中的每一种都有一个出价，并且拍卖只能以固定价格出售最多一种物品.</p></blockquote><ul><li>每个 <span class="math inline">\(i\)</span> 对物品 <span class="math inline">\(j\in[k]\)</span> 有一个需求函数 <span class="math inline">\(b_i^j:[0,1]\to\mathbb{R}^+\)</span>；<ul><li>须对 <span class="math inline">\(\forall i,j,p\)</span> 确保 <span class="math inline">\(pb_i^j(p)\leqslant 1\)</span>.</li></ul></li><li><span class="math inline">\(\mathcal{R}=[k]\times\mathbb{R}\)</span>；</li><li>对物品 <span class="math inline">\(j\)</span>，价格为 <span class="math inline">\(p\)</span>，可以卖掉 <span class="math inline">\(\sum_i b_i^j(p)\)</span> 件，得到 <span class="math inline">\(q(b,(j,p))=p\sum_i b_i^j(p)\)</span> 的收入.</li></ul><blockquote><p><strong>定理 12.</strong> 令 <span class="math inline">\(q(b,(j, p))=p \sum_{i} b_{i}^{j}(p), \mathcal{E}_{q}^{\epsilon}\)</span> 满足 <span class="math inline">\(2\epsilon\)</span>-dp, 且预期收益至少为 <span class="math inline">\(O P T-3 \ln \left(e+\epsilon^{2} O P T k m\right) / \epsilon,\)</span> 其中 <span class="math inline">\(m\)</span> 为 <span class="math inline">\(OPT\)</span> 情形下卖掉的商品数.</p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 北大 </tag>
            
            <tag> 社会计算 </tag>
            
            <tag> 论文笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论文笔记[12]——Private Matchings and Allocations</title>
      <link href="/2020/01/20/Paper-reading-12-Private-Matchings-and-Allocations/"/>
      <content type="html"><![CDATA[<blockquote><p>Justin Hsu, et al. Private matchings and allocations. SIAM Journal on Computing, 2016.</p></blockquote><blockquote><p>Justin Hsu, Zhiyi Huang, Aaron Roth, Tim Roughgarden, and Zhiwei Steven Wu. Private matchings and allocations. STOC 2014.</p></blockquote><ul><li>Differential Privacy &amp; Resource Allocation</li></ul><a id="more"></a><h2 id="文章概要">文章概要</h2><ul><li><span class="math inline">\(k\)</span> goods：<span class="math inline">\(j\in \{1,\ldots,k\}\)</span>，<span class="math inline">\(n\)</span> buyers：<span class="math inline">\(i\in \{1,\ldots,n\}\)</span>;<ul><li>Each <span class="math inline">\(i\)</span> has a value <span class="math inline">\(v_{ij}\in[0,1]\)</span> for each good <span class="math inline">\(j\)</span>.</li></ul></li></ul><blockquote><p><strong>Our goal</strong> 找到 buyer-good 匹配 <span class="math inline">\(\mu\)</span>，s.t. 最大化社会总福利 <span class="math inline">\(SW=\sum\limits_{i=1}^nv_{i,\mu(i)}\)</span>.</p></blockquote><ul><li>隐私性问题：<strong>values 是敏感信息，会涉及隐私.</strong></li></ul><p>因此，需要一个不会泄露 values 的匹配机制.</p><h3 id="dp在此问题上的局限性">DP在此问题上的局限性</h3><blockquote><p>It is not hard to see that this goal is impossible under the standard notion of differential privacy.</p></blockquote><p>作者认为，DP 要求分配方案（输出）对 <span class="math inline">\(v_{ij}\)</span> （输入）不敏感，但这是不可能的..</p><ul><li>解决方法：使用 Kearns 等在 2014 年提出的联合差分隐私（Joint DP）</li></ul><h3 id="思路将-market-clearing-prices-与-dp-结合">思路：将 Market Clearing prices 与 DP 结合</h3><ul><li>使用 Walrasian equilibrium prices：<ul><li>在 Joint DP 的要求下计算 Walrasian equilibrium prices.</li><li>Kelso 和 Crawford 在 1982 的经典分析：用递增价格拍卖来计算 Walrasian…</li></ul></li></ul><h2 id="基础知识">基础知识</h2><ul><li>物品集 <span class="math inline">\(G\)</span>，以及 agent 集合 <span class="math inline">\([n]\)</span>：<ul><li>每个 agent <span class="math inline">\(i\in[n]\)</span> 都有一个估值函数 <span class="math inline">\(v_i:2^G\to [0,1]\)</span>；</li><li>一个可行的分配是一列集合 <span class="math inline">\(S_1,\ldots,s_n\subseteq G\)</span>，s.t. <span class="math inline">\(S_i\cap S_j=\varnothing\)</span>，<span class="math inline">\(\forall i\neq j\)</span>.</li><li>上述分配的社会总福利为 <span class="math inline">\(\sum\limits_{i=1}^n v_i(S_i)\)</span>.<ul><li>最大社会总福利 <span class="math inline">\(OPT=\max\limits_{S_1,\ldots,S_n}\sum\limits_{i=1}^n v_i(S_i)\)</span>.</li></ul></li></ul></li></ul><p>我们考虑一个比较简单的估值函数：一个人只要一个物品.(unit demand valuation)</p><ul><li>但本文的结果对于 gross substitute valuation 也同样成立(简言之，就是物品 <span class="math inline">\(i\)</span> 涨价会使得其他物品更受欢迎，参见 <a href="https://en.wikipedia.org/wiki/Gross_substitutes" target="_blank" rel="noopener">wiki: Gross substitutes</a>).</li></ul><h3 id="形式化描述">形式化描述</h3><ul><li>价格向量 <span class="math inline">\(\{p_g\}_{g\in G}\)</span>，物品集 <span class="math inline">\(S\)</span> 对参与者 <span class="math inline">\(i\)</span> 的效用为 <span class="math inline">\(u_i(S,p)=v_i(S)-\sum\limits_{j\in S}p_j\)</span>.<ul><li>若定价 <span class="math inline">\(p\)</span> 和 <span class="math inline">\(p&#39;\)</span> 满足 <span class="math inline">\(p_g\leqslant p&#39;_g\)</span>，<span class="math inline">\(\forall g\in G\)</span>，则记为 <span class="math inline">\(p \preceq p^{\prime}\)</span>.</li><li>在定价 <span class="math inline">\(p\)</span> 下，参与者 <span class="math inline">\(i\in[n]\)</span> 最想要的物品集为 <span class="math inline">\(\omega(p)=\arg \max\limits _{S \subseteq G} u_{i}(S, p)\)</span>.</li></ul></li></ul><blockquote><p><strong>Def</strong> 现有估值函数 <span class="math inline">\(v_i: 2^G\to [0,1]\)</span>，如果对于定价向量 <span class="math inline">\(p\preceq p&#39;\)</span> 以及 <span class="math inline">\(\forall S\in\omega(p)\)</span>，若 <span class="math inline">\(S&#39;\subseteq S\)</span> 满足 <span class="math inline">\(p&#39;_g=p_g\)</span>，<span class="math inline">\(\forall g\in S&#39;\)</span>，则存在 <span class="math inline">\(S^*\in\omega(p)\)</span>，s.t. <span class="math inline">\(S&#39;\subset S^*\)</span>，则称 <span class="math inline">\(v_i\)</span> 满足 gross substitutes.</p></blockquote><ul><li><font color="red">这个定义很别扭…我没懂</font></li><li><p>本文的工作还是只考虑了一人一个物品的情况.</p></li><li>设共有 <span class="math inline">\(k\)</span> 种物品，代表元为 <span class="math inline">\(g_1,\ldots,g_k\in G\)</span><ul><li>若所有人都认为两个物品 <span class="math inline">\(g_1,g_2\in G\)</span> 等值，则这两个物品就被认为是相同的.</li></ul></li></ul><h3 id="差分隐私">差分隐私</h3><blockquote><p><strong>Def of DP</strong> 若算法 <span class="math inline">\(\mathcal{M}: C^{n} \rightarrow \mathcal{R}\)</span> 满足 <span class="math inline">\(\forall D,D&#39;\in C^n\)</span>，s.t. <span class="math inline">\(|D\triangle D&#39;|=1\)</span>，以及 <span class="math inline">\(\forall S\subseteq \mathcal{R}\)</span>，总有<span class="math display">\[\operatorname{Pr}[\mathcal{M}(D) \in S] \leq e^{\epsilon} \operatorname{Pr}\left[\mathcal{M}\left(D^{\prime}\right) \in S\right]+\delta\]</span>则称 <span class="math inline">\(\mathcal{M}\)</span> 是 <span class="math inline">\((\epsilon,\delta)\)</span>-差分隐私的. 若 <span class="math inline">\(\delta=0\)</span>，则称为 <span class="math inline">\(\epsilon\)</span>-差分隐私.</p></blockquote><ul><li>由于在资源分配问题中，输出结果是 <span class="math inline">\(n\)</span> 元集列，因而 <span class="math inline">\(\mathcal{M}\)</span> 的陪域为 <span class="math inline">\((2^G)^n\)</span>.</li></ul><blockquote><p><strong>Joint DP</strong> 若算法 <span class="math inline">\(\mathcal{M}: C^n\to (2^G)^n\)</span> 满足：对 <span class="math inline">\(\forall i\)</span> 以及 <span class="math inline">\(i\)</span>-neighbors <span class="math inline">\(D,D&#39;\in C^n\)</span>，以及 <span class="math inline">\(S\subseteq (2^G)^n\)</span>，总有： <span class="math display">\[\operatorname{Pr}\left[\mathcal{M}(D)_{-i} \in S\right] \leq e^{\epsilon} \operatorname{Pr}\left[\mathcal{M}\left(D^{\prime}\right)_{-i} \in S\right]+\delta\]</span> 则称其满足 <span class="math inline">\((\epsilon,\delta)\)</span>-联合差分隐私.</p></blockquote><h3 id="dp-counter">DP Counter</h3><ul><li>一个二进制串 <span class="math inline">\(\sigma=(\sigma_1,\ldots,\sigma_T)\in\{0,1\}^T\)</span>，计数器 <span class="math inline">\(\mathcal{M}\)</span> 给出了 <span class="math inline">\(c_\sigma(t)=\sum\limits_{i=1}^t \sigma_i\)</span> 的一个近似.</li></ul><blockquote><p><strong>计数器的 <span class="math inline">\(\alpha,\beta\)</span>-有效性</strong> 若 <span class="math inline">\(\forall t\in [T]\)</span>，<span class="math inline">\(\operatorname{Pr}[|\mathcal{M}(\sigma)(t)-c_\sigma(t)|\leqslant\alpha]\geqslant 1-\beta\)</span>，则称 <span class="math inline">\(\mathcal{M}\)</span> 是 <span class="math inline">\((\alpha,\beta)\)</span>-有效的.</p></blockquote><blockquote><p><strong>定理</strong> Chen 等在2011 年提出的计数器 <span class="math inline">\(\mathbf{Counter}(\epsilon,T)\)</span> 对于01串的每一位，是 <span class="math inline">\(\epsilon\)</span>-差分隐私的，且是 <span class="math inline">\((\alpha,\beta)\)</span>-有效的，其中 <span class="math display">\[\alpha=\frac{2 \sqrt{2}}{\epsilon} \ln (2 / \beta) \log (T)^{5 / 2}.\]</span></p></blockquote><h3 id="隐私化的最大匹配">隐私化的最大匹配</h3><ul><li><span class="math inline">\(n\)</span> 个人，<span class="math inline">\(k\)</span> 种物品，每种 <span class="math inline">\(s\)</span> 个. 估值函数 <span class="math inline">\(v_{ij}\in[0,1]\)</span></li><li>定价向量 <span class="math inline">\(p\in[0,1]^k\)</span>，分配方案 <span class="math inline">\(\mu: [n]\to[k]\cup\{\perp\}\)</span><ul><li><span class="math inline">\(\perp\)</span> 的解释：未匹配到物品的人被统一匹配到一个虚拟物品，记作 <span class="math inline">\(\perp\)</span>.</li></ul></li></ul><blockquote><p><strong>Def</strong> 给定定价向量 <span class="math inline">\(p\in[0,1]^k\)</span> 以及从人到物的匹配 <span class="math inline">\(\mu:[n]\to[k]\cup\{\perp\}\)</span>，若 <span class="math inline">\(\mu\)</span> 满足：</p><ul><li>至少 <span class="math inline">\((1-\rho)\)</span> 比例的人匹配到的物品是 <span class="math inline">\(\alpha\)</span>-最优的； - 即对至少 <span class="math inline">\((1-\rho)\)</span> 比例的 <span class="math inline">\(i\)</span> 而言，有 <span class="math inline">\(v_{i \mu(i)}-p_{\mu(i)} \geq v_{i j}-p_{j}-\alpha\)</span>，<span class="math inline">\(\forall j\)</span>.</li><li>每种物品被分配的量不能超过总供应量；</li><li>每种供不应求的物品(over-demanded)都会被抢光，除非其供应量不超过 <span class="math inline">\(\beta\)</span>. - 原文：each over-demanded good clears except for at most β supply.</li></ul><p>则称其是一个 <span class="math inline">\((\alpha,\beta,\rho)\)</span>-近似匹配.</p></blockquote><h4 id="算法描述pmatch-algorithm">算法描述：PMatch Algorithm</h4><blockquote><p>修改版的延迟认可(deferred acceptance)算法 [Kelso and Crawford 1982]</p></blockquote><hr><p><strong>Propose Function</strong></p><ul><li>同时进行 <span class="math inline">\(k\)</span> 场竞价选举，每场代表一种物品.<ul><li>任意时刻，每种物品的 proposal price 为 <span class="math inline">\(p_j\)</span>.</li></ul></li><li>给所有参与者规定一个（大家都知道的）顺序，依次访问每一个人.<ul><li>给访问到的未被匹配到物品的参与者分配一个对他而言效用最大的物品.</li></ul></li></ul><hr><p><strong>Bid Function</strong></p><blockquote><p>很想吐槽一下。。。文章写得不像人话…</p></blockquote><ul><li>对每类物品来说：申请与某类物品匹配的前 <span class="math inline">\(s\)</span> 名暂时获得该类物品<ul><li>对某物品而言，若某个人比其当前持有者出价更高，则该物品将易主.</li><li>对每个物品的出价每次上涨固定值 <span class="math inline">\(\alpha\)</span>.</li></ul></li></ul><center><img src="/img/blog-graph/private-matchings-and-allocations-PMatch.png" width="500"" alt="Algorithm PMatch"></center><blockquote><p><font size="4" color="F596AA"><strong>隐私性分析</strong></font> 当某个人改变自己的valuation时，数据对其他人而言服从Joint DP.<br>  这篇文章使用的是所谓“广告牌模型”（Billboard Model）<br><strong>广告牌模型</strong> 若某些信息被广播了，那么这些信息必须是DP的.<br><strong>广告牌引理</strong> 设 <span class="math inline">\(\mathcal{M}:\mathcal{D}\to\mathcal{R}\)</span> 是 <span class="math inline">\((\epsilon,\delta)\)</span>-DP 的. 考虑函数族 <span class="math inline">\(f_i:\mathcal{D}_i\times\mathcal{R}\to\mathcal{R}&#39;\)</span>，其中 <span class="math inline">\(\mathcal{D}_i\)</span> 是与 <span class="math inline">\(i\)</span> 相关的数据集，则 <span class="math inline">\(\{f_i(\Pi_iD,\mathcal{M}(D))\}\)</span> 是 <span class="math inline">\((\epsilon,\delta)\)</span>-Joint DP 的，其中 <span class="math inline">\(\Pi_i\)</span> 表示向 <span class="math inline">\(i\)</span> 数据集的投影.</p></blockquote><p>借助上述引理，我们可以得到：</p><blockquote><p><strong>定理 2</strong> PMatch<span class="math inline">\((\alpha,\beta,\epsilon)\)</span> 满足 <span class="math inline">\(\epsilon\)</span>-联合差分隐私.</p></blockquote><blockquote><p><font size="4" color="F596AA"><strong>有效性分析</strong></font> 事实上PMatch算法会在以下三个方面损失有效性：</p><ol type="1"><li>可能有 <span class="math inline">\(\rho\)</span> 比例的人在算法结束时仍处于未匹配状态；</li><li>被匹配了物品的人也未必得到了自己最想要的的物品；</li><li>整个拍卖过程会分出一部分物品来应对 Counters 中的噪音可能带来的过量分配. 而这些物品有可能会卖不出去.</li></ol></blockquote><p>事实上，有如下定理成立：</p><blockquote><p><strong>定理 3</strong> 设 <span class="math inline">\(\alpha&gt;0\)</span>，<span class="math inline">\(\mu\)</span> 是由 <span class="math inline">\(\mathbf{PMatch}(\frac{\alpha}{3},\frac{\alpha}{3},\epsilon)\)</span> 导出的分配，令 <span class="math inline">\(OPT\)</span> 是最大匹配，若满足： <span class="math display">\[s \geq \frac{16 E^{\prime}+4}{\alpha}=O\left(\frac{1}{\alpha^{3} \varepsilon} \cdot \operatorname{polylog}\left(n, k, \frac{1}{\alpha}, \frac{1}{\gamma}\right)\right)\]</span> 且 <span class="math inline">\(n&gt;s\)</span>，则 <span class="math inline">\(\mu\)</span> 的 social welfare 至少为 <span class="math inline">\(OPT-\alpha n\)</span> 的概率不会低于 <span class="math inline">\(1-\gamma\)</span>. 其中 <span class="math display">\[E^{\prime}=\frac{288 \sqrt{2}}{\alpha^{2} \varepsilon}\left(\log \left(\frac{72 n}{\alpha^{2}}\right)\right)^{5 / 2} \log \left(\frac{4 k}{\gamma}\right).\]</span></p></blockquote><h2 id="推广">推广</h2><p>正如前文所述，算法 PMatch 可以推广为算法 PAlloc，应用于 Gross Substitute Valuations 情形.</p><center><img src="/img/blog-graph/Algo-PAlloc.png" width="500" alt="Private Algorithm: PAlloc"></center><p>作者同样给出了如下定理：</p><blockquote><p><strong>定理 4</strong> <span class="math inline">\(\mathbf{PAlloc}(\alpha,\rho,\epsilon)\)</span> 满足 <span class="math inline">\(\epsilon\)</span>-联合DP.</p></blockquote><hr><p>本文还有很多其他结果，暂时还没有理清…</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 北大 </tag>
            
            <tag> 社会计算 </tag>
            
            <tag> 论文笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京大学群表示论试题</title>
      <link href="/2020/01/07/%E5%8C%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E7%BE%A4%E8%A1%A8%E7%A4%BA%E8%AE%BA%E8%AF%95%E9%A2%98/"/>
      <content type="html"><![CDATA[<ul><li>2019 - 2020 学年 秋季学期 研究生课程 群表示论 王立中老师</li></ul><a id="more"></a><h2 id="学年秋-群表示论-王立中老师">19-20学年秋 群表示论 王立中老师</h2><blockquote><p>前 6 题每题 15 分，第 7 题 10 分..这里没有记下第 7 题…（学得太差…Orz）</p></blockquote><ol type="1"><li>证明有限群 <span class="math inline">\(G\)</span> 的不可约复表示只有有限多个，且其特征标线性无关.（所有不可约表示都在正则表示中出现，因而只有有限多，线性无关用正交关系证明）</li><li>设 <span class="math inline">\(K\)</span> 是特征为 <span class="math inline">\(p&gt;0\)</span> 的域，<span class="math inline">\(G\)</span> 是有限群，证明 <span class="math inline">\(K[G]\)</span> 半单当且仅当 <span class="math inline">\(p\)</span> 不整除 <span class="math inline">\(G\)</span> 的阶.（Serre 习题 6.1，互素推半单同 Serre 书 Thm 1 的证明，半单推互素用反证法）</li><li>设 <span class="math inline">\(K\)</span> 是一个有限域，<span class="math inline">\(H\)</span> 是 <span class="math inline">\(\mathrm{SL}_n(K)\)</span> 中所有上三角矩阵所构成的子群. 设有乘法群同态 <span class="math inline">\(\omega: K^*\to\mathbb{C}^*\)</span>，且 <span class="math inline">\(\omega^2\neq 1\)</span>. 则 <span class="math inline">\(H\)</span> 有 <span class="math inline">\(1\)</span> 级表示：<span class="math display">\[\chi_\omega\left(\begin{bmatrix} a &amp; b \\ 0 &amp; d \\ \end{bmatrix}\right)=\omega(a).\]</span>证明 <span class="math inline">\(\chi_\omega\)</span> 的诱导表示不可约.（Serre 习题 7.4，用 Mackey 判定）</li><li>设 <span class="math inline">\(X\)</span> 是 <span class="math inline">\(G\)</span> 的子群族，考虑映射：<span class="math display">\[\mathbb{C}\otimes\operatorname{Ind}:\mathbb{C}\otimes \bigoplus\limits_{H\in X}R(H)\to \mathbb{C}\otimes R(G)\]</span> <span class="math display">\[\mathbb{C}\otimes\operatorname{Res}:\mathbb{C}\otimes R(G)\to \mathbb{C}\otimes \bigoplus\limits_{H\in X}R(H)\]</span>证明：<ol type="1"><li><span class="math inline">\(\mathbb{C}\otimes \operatorname{Ind}\)</span> 的像是环 <span class="math inline">\(\mathbb{C}\otimes R(G)\)</span> 的理想；（用 <span class="math inline">\(\operatorname{Ind}(\varphi\cdot\operatorname{Res}\psi) = \operatorname{Ind}\varphi\cdot \psi\)</span>）</li><li>证明 <span class="math inline">\(\mathbb{C}\otimes\operatorname{Ind}\)</span> 是满射当且仅当 <span class="math inline">\(\mathbb{C}\otimes\operatorname{Res}\)</span> 是单射.</li></ol></li><li>求二面体群 <span class="math inline">\(D_{10}\)</span> 的特征标表，并求其在域 <span class="math inline">\(\mathbb{Q}(\sqrt{2})\)</span> 上所有表示的 Schur 指数.（特征标表见 Serre 书 chp 5，Schur 指标是 <span class="math inline">\(1\)</span>，参见 Serre 习题 12.1）</li><li>证明：<ol type="1"><li>有限群 <span class="math inline">\(G\)</span> 的所有特征标都可以写为单项特征标的整系数线性组合；（特征标 <span class="math inline">\(\to\)</span> 初等子群 <span class="math inline">\(\to\)</span> 单项特征标）</li><li>证明交错群 <span class="math inline">\(A_5\)</span> 至少有一个特征标不能写为单项特征标的正实系数线性组合.（Serre 习题 10.5）</li></ol></li><li>还有一个题，但敝人才疏学浅…并不会做…也没有记下是什么题.</li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 抽象代数 </tag>
            
            <tag> 表示论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法期末复习小记</title>
      <link href="/2019/12/30/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E5%B0%8F%E8%AE%B0/"/>
      <content type="html"><![CDATA[<p>很久不写题，手法生疏.. 做个简短记录吧，或是卡的比较久的题，或是手生忘记怎么写的题.</p><ul><li>Dynamic Median：堆</li><li>Ultra-QuickSort：线段树+离散化/树状数组+离散化/归并</li><li>重要逆序对：归并/线段树+离散化/树状数组+离散化</li></ul><a id="more"></a><h2 id="dynamic-median">Dynamic Median</h2><blockquote><p><a href="http://algorithm.openjudge.cn/19exfinalsim/C" target="_blank" rel="noopener">http://algorithm.openjudge.cn/19exfinalsim/C</a></p></blockquote><p>不算困难的题目… 用对顶堆解决：建一个最大堆 <code>max_heap</code> 和一个最小堆 <code>min_heap</code>，保持：</p><ol type="1"><li><code>max_heap</code> 的堆顶始终小于等于 <code>min_heap</code> 的堆顶；</li><li>两个堆的元素个数差不超过 <span class="math inline">\(1\)</span>. 事实上，保持 <code>max_heap</code> 元素更多，且比 <code>min_heap</code> 多不超过 <span class="math inline">\(1\)</span> 个元素即可.</li></ol><p>写完之后先 TLE 一发，稍作优化之后便是 RE + WA…？？？经过多次修改尝试（炸OJ）之后，发现是 <code>unsigned int</code> 的问题…负数的情况会和 <code>int</code> 有所不同…</p><p>简单总结一下：<code>priority_queue</code> 的 <code>size()</code> 方法返回值是 <code>unsigned int</code>，所以不要乱做减法…</p><p>贴一份 AC 代码吧…</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; min_heap;</span><br><span class="line">        <span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; max_heap;</span><br><span class="line">        <span class="keyword">int</span> N;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">        <span class="keyword">while</span> (N--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> op[<span class="number">5</span>];</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, op);</span><br><span class="line">            <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">'I'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">                <span class="keyword">if</span> (max_heap.empty())</span><br><span class="line">                    max_heap.push(x);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (x &lt; max_heap.top())</span><br><span class="line">                        max_heap.push(x);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        min_heap.push(x);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 之前写的是 max_heap.size() - min_heap.size() &gt;= 2</span></span><br><span class="line">                <span class="comment">// 因此在把 if 改成 while 后会反复执行非常多次... 提交结果会是 MLE.</span></span><br><span class="line">                <span class="comment">// 但正常情况下，这里的 if 改成 while 是没有任何问题的.</span></span><br><span class="line">                <span class="keyword">if</span> (max_heap.size() &gt;= min_heap.size() + <span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    min_heap.push(max_heap.top());</span><br><span class="line">                    max_heap.pop();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (max_heap.size() &lt; min_heap.size())</span><br><span class="line">                &#123;</span><br><span class="line">                    max_heap.push(min_heap.top());</span><br><span class="line">                    min_heap.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">'D'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                max_heap.pop();</span><br><span class="line">                <span class="keyword">if</span> (max_heap.size() &lt; min_heap.size())</span><br><span class="line">                &#123;</span><br><span class="line">                    max_heap.push(min_heap.top());</span><br><span class="line">                    min_heap.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">'Q'</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, max_heap.top());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ultra-quicksort">Ultra-QuickSort</h2><blockquote><p><a href="http://bailian.openjudge.cn/practice/2299/" target="_blank" rel="noopener">http://bailian.openjudge.cn/practice/2299/</a></p></blockquote><p>求逆序…数字范围很大，因此需要离散化. 因为结果可能爆 <code>int</code> 而 WA 很多发…（当然，也有树状数组的做法，以及归并的做法）</p><h3 id="线段树做法">线段树做法</h3><p>严格来说这份代码采取的思路并不能算作真正的离散化. 这里的做法是对每个 <span class="math inline">\(a_i\)</span>，把下标 <span class="math inline">\(i\)</span> 与值 <span class="math inline">\(a_i\)</span> 都存下来，存到 <span class="math inline">\((val,idx)\)</span> 这样结构的二元组中，那么初始状况下，所有二元组是按照 <span class="math inline">\(idx\)</span> 排序的，我们需要求 <span class="math inline">\(val\)</span> 序列的逆序数. 这等价于将 <span class="math inline">\(val\)</span> 排序后，求 <span class="math inline">\(idx\)</span> 序列的逆序数. 而 <span class="math inline">\(idx\)</span> 的取值范围就是 <span class="math inline">\([1,n]\)</span>，因此只需要开规模为 <span class="math inline">\(n\)</span> 的线段树即可.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> root 1, n, 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[rt] = sum[rt &lt;&lt; <span class="number">1</span>] + sum[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[rt] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[rt]++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= m) update(x, lson);</span><br><span class="line">    <span class="keyword">else</span> update(x, rson);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt, <span class="keyword">int</span> ll, <span class="keyword">int</span> rr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ll &lt;= l &amp;&amp; rr &gt;= r) <span class="keyword">return</span> sum[rt];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ll &lt;= m) ret += query(lson, ll, rr);</span><br><span class="line">    <span class="keyword">if</span> (rr &gt; m) ret += query(rson, ll, rr);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line">        v.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            v.push_back(make_pair(x, i));</span><br><span class="line">        &#125;</span><br><span class="line">        stable_sort(v.begin(), v.end());</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            update(v[i].second, <span class="number">1</span>, maxn, <span class="number">1</span>);</span><br><span class="line">            res += query(<span class="number">1</span>, maxn, <span class="number">1</span>, v[i].second + <span class="number">1</span>, maxn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序做法">归并排序做法</h3><p>一个很标准的用归并求逆序的做法…</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500005</span>;</span><br><span class="line"><span class="keyword">int</span> n, x[maxn], f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Merge_Sort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r - l == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = Merge_Sort(l, m, a, b) + Merge_Sort(m, r, a, b);</span><br><span class="line">    <span class="keyword">int</span> p = l, q = m, c = l;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; m || q &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (q &gt;= r || (p &lt; m &amp;&amp; a[p] &lt;= a[q]))</span><br><span class="line">            b[c++] = a[p++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans += m - p;</span><br><span class="line">            b[c++] = a[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; i++)</span><br><span class="line">        a[i] = b[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Merge_Sort(<span class="number">0</span>, n, x, f));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重要逆序对">重要逆序对</h2><blockquote><p><a href="http://algorithm.openjudge.cn/201919191919/18xlyB/" target="_blank" rel="noopener">http://algorithm.openjudge.cn/201919191919/18xlyB/</a></p></blockquote><h3 id="归并做法">归并做法</h3><p>一直不会的归并排序…学♂习一下..</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[maxn], b[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Binary_Search</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[l] &gt; val) ret = l;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[m] &gt; val)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = m;</span><br><span class="line">            r = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> l = m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = l, j = m + <span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt; r - l + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; m) b[cnt++] = a[j++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; r) b[cnt++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i] &gt; a[j])</span><br><span class="line">        &#123;</span><br><span class="line">            res += m - Binary_Search(i, m, <span class="number">2</span> * a[j]) + <span class="number">1</span>;</span><br><span class="line">            b[cnt++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> b[cnt++] = a[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cnt; k++)</span><br><span class="line">        a[l + k] = b[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_Sort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    Merge_Sort(l, m);</span><br><span class="line">    Merge_Sort(m + <span class="number">1</span>, r);</span><br><span class="line">    merge(l, m, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        Merge_Sort(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线段树做法-1">线段树做法</h3><p>夏令营和算法期末考试都写挂的题…（都写的是线段树，但甚至没有过样例Orz）一定要用线段树写过…</p><p>一开始妄想直接从 Ultra-Quicksort 的代码改，但 val 序列的重要逆序很难转换为 idx 序列的逆序（也可能是我没想到）. 因此转而考虑将序列 <span class="math inline">\(a_1,\ldots,a_n\)</span> 直接离散化，依次将其插入线段树，对每个 <span class="math inline">\(i\)</span> 都查询比 <span class="math inline">\(2a_i\)</span> 大的个数，并存到答案中.</p><p>但是这样会出问题：<span class="math inline">\(2a_i\)</span> 可能超过原先 <span class="math inline">\(a\)</span> 的取值范围，从而导致一些问题. 解决办法很简单，倒序插入，然后查询小于 <span class="math inline">\(a_i/2\)</span> 的数即可. 随后因为 <span class="math inline">\(a_i/2\)</span> 可能不是整数的情况费了一番功夫…然后才成功 AC…</p><p>果然是菜…</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> root 1, maxn, 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">400005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> origional_a[maxn], a[maxn], uniqued_a[maxn], half_a[maxn];</span><br><span class="line"><span class="keyword">int</span> sum[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[rt] = sum[rt &lt;&lt; <span class="number">1</span>] + sum[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[rt] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[rt]++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= m) update(x, lson);</span><br><span class="line">    <span class="keyword">else</span> update(x, rson);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt, <span class="keyword">int</span> ll, <span class="keyword">int</span> rr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ll &lt;= l &amp;&amp; rr &gt;= r) <span class="keyword">return</span> sum[rt];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ll &lt;= m) ret += query(lson, ll, rr);</span><br><span class="line">    <span class="keyword">if</span> (rr &gt; m) ret += query(rson, ll, rr);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;origional_a[i]);</span><br><span class="line">            origional_a[i] *= <span class="number">2</span>; <span class="comment">// 保证除以2还是整数</span></span><br><span class="line">            a[i] = origional_a[i];</span><br><span class="line">            uniqued_a[i] = origional_a[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(uniqued_a + <span class="number">1</span>, uniqued_a + <span class="number">1</span> + n);</span><br><span class="line">        <span class="keyword">int</span> sz = unique(uniqued_a + <span class="number">1</span>, uniqued_a + <span class="number">1</span> + n) - uniqued_a - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i] = lower_bound(uniqued_a + <span class="number">1</span>, uniqued_a + sz + <span class="number">1</span>, origional_a[i]) - uniqued_a;</span><br><span class="line">            a[i] *= <span class="number">2</span>; <span class="comment">// 变成整数</span></span><br><span class="line">            half_a[i] = lower_bound(uniqued_a + <span class="number">1</span>, uniqued_a + sz + <span class="number">1</span>, origional_a[i] / <span class="number">2</span>) - uniqued_a;</span><br><span class="line">            half_a[i] = <span class="number">2</span> * half_a[i] - <span class="number">1</span>; <span class="comment">// 保证顺序</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            update(a[i], root);</span><br><span class="line">            res += query(root, <span class="number">1</span>, half_a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 计算机 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 北大 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论文笔记[11]——Gibbard-Satterthwaite 定理</title>
      <link href="/2019/12/04/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-11-%E2%80%94%E2%80%94Gibbard-Satterthwaite-%E5%AE%9A%E7%90%86/"/>
      <content type="html"><![CDATA[<blockquote><p>文章：Svensson L G, Reffgen A. The proof of the Gibbard–Satterthwaite theorem revisited[J]. Journal of Mathematical Economics, 2014, 55: 11-14.</p></blockquote><blockquote><p><strong>Gibbard-Satterthwaite 定理</strong>：对于至少有 <span class="math inline">\(3\)</span> 个候选人的投票，若它是 中立 且 strategy-proof 的，则它一定是一个 dictatorial.</p></blockquote><a id="more"></a><h2 id="the-voting-model">The voting model</h2><ul><li><span class="math inline">\(N=\{1,\ldots,1\}\)</span> voter；</li><li><span class="math inline">\(A=\{a_1,\ldots,a_m\}\)</span> 候选人；</li><li>偏好 <span class="math inline">\(P\)</span>：<span class="math inline">\(A\)</span> 上的序. 序 <span class="math inline">\(P\)</span> 的第 <span class="math inline">\(k\)</span> 位用 <span class="math inline">\(r_k(P)\)</span> 表示.<ul><li><span class="math inline">\(A\)</span> 上的所有偏好用 <span class="math inline">\(\Sigma\)</span> 表示. i.e. profile <span class="math inline">\((P_1,\ldots,P_n)\in\Sigma^n\)</span>.</li><li><span class="math inline">\(P_{-i}\)</span>：<span class="math inline">\(P\)</span> 的序列中抠掉 voter <span class="math inline">\(i\)</span>，<span class="math inline">\(P_{-\{i,j\}}\)</span> 同理.</li></ul></li></ul><p>一个投票规则是映射 <span class="math inline">\(f:\Sigma^n\to A\)</span>.</p><blockquote><p><strong>Def. 1 (strategy-proof)</strong><br><strong>Def. 2 (dictatorial)</strong><br><strong>Def. 3 (neutral)</strong></p></blockquote><blockquote><p><strong>Gibbard-Satterwaite theorem</strong> 候选人至少三个，若投票机制 <span class="math inline">\(f\)</span> 是满射，则 <span class="math inline">\(f\)</span> 是 strategy-proof 的 <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(f\)</span> 是 dictatorial.</p></blockquote><h2 id="two-basic-properties-of-strategy-proof-rules">Two basic properties of strategy-proof rules</h2><blockquote><p><strong>Lemma 1 （单调性）</strong> 设 <span class="math inline">\(f\)</span> 是 strategy-proof rule. 若 <span class="math inline">\(f(P_1,\ldots,P_n)=a\)</span> 且对 <span class="math inline">\((P_1&#39;,\ldots,P_n&#39;)\in\Sigma^n\)</span> 有 <span class="math inline">\(a P_i x\Rightarrow a P_i&#39; x\)</span>，<span class="math inline">\(\forall i\in N, \forall x\in A\)</span>，则 <span class="math inline">\(f(P_1&#39;,\ldots,P_n&#39;)=a\)</span>.</p><ul><li>总结一下：只要大家在谎报偏好时，都没有降低 <span class="math inline">\(a\)</span> 的位次，那么结果就仍然会是 <span class="math inline">\(a\)</span>.</li></ul></blockquote><blockquote><p><strong>Lemma 2 （Pareto 最优）</strong> 设 <span class="math inline">\(f\)</span> 是 strategy-proof 的满射. 若 <span class="math inline">\((P_1,\ldots,P_n)\in\Sigma^n\)</span> 对 <span class="math inline">\(\forall i\in N\)</span> 都满足 <span class="math inline">\(aP_ib\)</span>，则 <span class="math inline">\(f(P_1,\ldots,P_n)\neq b\)</span>.</p></blockquote><h2 id="一种归纳证明">一种归纳证明</h2><blockquote><p><strong>先来一个例子：</strong> <span class="math inline">\(N=\{1,2\}\)</span>，<span class="math inline">\(A=\{a,b,c\}\)</span>，<span class="math inline">\(P=(P_1,P_2)\)</span>. 我们需要在 <span class="math inline">\(N\)</span> 中找一个 dictator.</p></blockquote><p>考虑 <span class="math inline">\(P_1=(a,b,c), P_2=(b,a,c), P_2&#39;=(b,c,a)\)</span>：不妨设 <span class="math inline">\(f(P_1,P_2)=a\)</span>.</p><ul><li>由 Pareto 最优性，<span class="math inline">\(f(P_1,P_2)\neq c\)</span>. 考虑到 <span class="math inline">\(a,b\)</span> 的对称性，不妨设 <span class="math inline">\(f(P_1,P_2)=a\)</span>.</li><li>由 Pareto 最优性，<span class="math inline">\(P_1\)</span> 和 <span class="math inline">\(P_2&#39;\)</span> 中，<span class="math inline">\(b\)</span> 都比 <span class="math inline">\(c\)</span> 好，故 <span class="math inline">\(f(P_1,P_2&#39;)\neq c\)</span>.</li><li>由 strategy-proof 可知 <span class="math inline">\(f(P_1,P_2&#39;)\neq b\)</span>.</li></ul><p>换言之，<span class="math inline">\(f(P_1,P_2&#39;)\)</span> 只能是 <span class="math inline">\(a\)</span>. 这实际上是在说，<span class="math inline">\(1\)</span> 是 dictator.</p><p>我们现在来证明，每个候选人都存在一个 dictator.</p><p><strong>先考虑 <span class="math inline">\(n=2\)</span> 情形.</strong>，我们来证明如下定理：</p><blockquote><p><strong>Th. 1.</strong> 设 <span class="math inline">\(N=\{1,2\}\)</span>，且 <span class="math inline">\(|A|\geqslant 3\)</span>，则 strategy-proof 的满射都是 dictatorial.</p><p><strong>Proof.</strong> 取 <span class="math inline">\(a,b\in A\)</span>，构造 <span class="math inline">\((\bar{P_1},\bar{P_2})\in \Sigma^2\)</span>，s.t. 其第一位和第二位分别是 <span class="math inline">\(ab\)</span> 和 <span class="math inline">\(ba\)</span>. 不妨设 <span class="math inline">\(f(\bar{P_1},\bar{P_2})=a\)</span>. 然后证明无论 <span class="math inline">\(2\)</span> 怎么改偏好，都不会改变最终结果.</p></blockquote><p>以下引理对于归纳至关重要：</p><blockquote><p><strong>Lemma 3.</strong> 令 <span class="math inline">\(f: \Sigma^n\to A\)</span> 是满射，且是 strategy-proof 的. 对于 <span class="math inline">\(i,j\in N\)</span>，定义 <span class="math inline">\(f_{i,j}\)</span>： <span class="math display">\[f_{i,j}: \Sigma^{n-1}\to A, ~~~(P_i,P_{-\{i,j\}})\mapsto f(P_i,P_i,P_{-\{i,j\}}).\]</span> 则 <span class="math inline">\(f_{i,j}\)</span> 也是满射，并且也是 strategy-proof 的.</p><p><strong>Proof.</strong> 满射比较容易证明，可直接由 <span class="math inline">\(f\)</span> 是满射得到. 对于 strategy-proof 性质，首先我们考虑除 <span class="math inline">\(i,j\)</span> 外的其他 voter. 如果存在一个非 <span class="math inline">\(i,j\)</span> 的 voter 能够操纵投票结果，这将与 <span class="math inline">\(f\)</span> 的 strategy-proof 性质矛盾. 换言之，只有 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 有可能能够操纵投票结果. 我们再对 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 进行讨论即可.</p></blockquote><blockquote><p><strong>Th. 2</strong> 若候选人的个数至少是 <span class="math inline">\(3\)</span>，则 strategy-proof 的满射 <span class="math inline">\(f\)</span> 一定是 dictatorial.</p><p><strong>Proof.</strong> 现在只需要考虑 <span class="math inline">\(n\geqslant 3\)</span> 的情况了，设 <span class="math inline">\(&lt;n\)</span> 的情形全部成立，下证 <span class="math inline">\(n\)</span> 的情形成立.<br>考虑 <span class="math inline">\(n\)</span> 情形下的 <span class="math inline">\(f\)</span>，则其诱导的 <span class="math inline">\(f_{i,j}\)</span> 都是 strategy-proof 的满射，因而都是 dictatorial. 则有且仅有以下两种情况：</p><ul><li>对于一些 <span class="math inline">\(f_{i,j}\)</span>，dictator 是某个 <span class="math inline">\(k\in N\backslash\{a,b\}\)</span>，则可证明（用 lemma 1 的单调性） <span class="math inline">\(k\)</span> 同样是 <span class="math inline">\(f\)</span> 的 dictator.</li><li>对 <span class="math inline">\(\forall f_{i,j}\)</span>，<span class="math inline">\(i\)</span> 是 dictator，可以证明这种情况是不可能的.</li></ul></blockquote><h2 id="中立情形下的直接证明">中立情形下的直接证明</h2><p>两个前提：(1) 中立，(2) <span class="math inline">\(m\geqslant n\)</span>. （Excuse me？？投票人比候选人还少？？）</p><blockquote><p><strong>Theorem 3.</strong> 至少 <span class="math inline">\(3\)</span> 个候选人，且 <span class="math inline">\(m\geqslant n\)</span>. 则 neutral + strategy-proof <span class="math inline">\(\Rightarrow\)</span> dictatorial.</p><p><strong>Proof.</strong> 令 <span class="math inline">\(P\in\Sigma\)</span>，s.t. <span class="math inline">\(r_k(P)=a_k\)</span>，取 <span class="math inline">\(A\)</span> 上的置换 <span class="math inline">\(\pi\)</span>：<span class="math inline">\(\pi(a_k)=\begin{cases} a_{k+1}, &amp; 1\geqslant k\geqslant n - 1\\ a_1, &amp; k=n\\ a_k, &amp; k&gt;n \end{cases}\)</span>，考虑 profile <span class="math inline">\(\left(P, \pi P, \pi^{2} P, \ldots, \pi^{n-1} P\right) \in\Sigma^n\)</span>，这时前 <span class="math inline">\(n\)</span> 个候选人的标号恰好完全轮换了一次. 这时 <span class="math inline">\(a_n\)</span> 及下标更小的 <span class="math inline">\(a_i\)</span> 要比下标更大的 <span class="math inline">\(a_j\)</span> Pareto 占优（<font color="red">为什么？</font>），因此由<font color="blue">(1) neutral <span class="math inline">\(\Rightarrow\)</span> surjective; (2) Lemma 2. </font>可得 <span class="math inline">\(f\left(P, \pi P, \ldots, \pi^{n-1} P\right)=a_{i}\)</span>，其中 <span class="math inline">\(i\leqslant n\)</span>，那么不妨设它就是 <span class="math inline">\(a_1\)</span>.<br>现在，取 profile <span class="math inline">\(\left(P_{1}^{\prime}, \ldots, P_{n}^{\prime}\right) \in \Sigma^{n}\)</span>，s.t. 在这个 profile 中，只有<span class="math inline">\(1\)</span> 把 <span class="math inline">\(a_1\)</span> 排第一，<span class="math inline">\(a_n\)</span> 排第二；其他人都把 <span class="math inline">\(a_n\)</span> 排第一，<span class="math inline">\(a_1\)</span> 排第二. 那么，相比 <span class="math inline">\((P,\pi P,\ldots)\)</span> 那个 profile，<span class="math inline">\(a_1\)</span> 的地位没有下降，故 <span class="math inline">\(f(P_1&#39;,\ldots,P_n&#39;)=a_1\)</span>.<br>现在来定义一列 profile：</p><ol type="1"><li><span class="math inline">\(\left(P_{1}^{1}, \ldots, P_{n}^{1}\right)=\left(P_{1}^{\prime}, \ldots, P_{n}^{\prime}\right)\)</span>；</li><li>当 <span class="math inline">\(j\geqslant 2\)</span> 时，对 <span class="math inline">\(i\neq j\)</span>，取 <span class="math inline">\(P_i^j=P_i^{j-1}\)</span>；对 <span class="math inline">\(i=j\)</span>，取 <span class="math inline">\(r_1(P_i^i)=a_n\)</span>，<span class="math inline">\(r_m(P_i^i)=a_1\)</span>.</li></ol><p>由 Pareto 最优性，<span class="math inline">\(f\left(P_{1}^{j}, \ldots, P_{n}^{j}\right) \in\left\{a_{1}, a_{n}\right\}\)</span>，而 strategy-proof 要求这个结果不能是 <span class="math inline">\(a_n\)</span>. 那就只能是 <span class="math inline">\(a_1\)</span> 了！进一步，在 <span class="math inline">\((P_1^n,\ldots,P_n^n)\)</span> 中，除了 <span class="math inline">\(1\)</span> 把 <span class="math inline">\(a_1\)</span> 放在第一位之外，其他人都把 <span class="math inline">\(a_1\)</span> 放到了最后. 但尽管如此，选举的获胜者仍然是 <span class="math inline">\(a_1\)</span>. 单调性告诉我们，这里没有别的原因，只能说 <span class="math inline">\(a_1\)</span> 真的强. 换言之，voter <span class="math inline">\(1\)</span> 是一个 dictator.</p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 北大 </tag>
            
            <tag> 社会计算 </tag>
            
            <tag> 论文笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论文笔记[10]——Voting, the Symmetric Group, and Representation Theory</title>
      <link href="/2019/11/21/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-10-%E2%80%94%E2%80%94Voting-the-Symmetric-Group-and-Representation-Theory/"/>
      <content type="html"><![CDATA[<ul><li>用杨表和 tabloid 来描述偏好和选票；</li><li>将计票过程是为模同态，进而应用 Schur 引理等表示论的内容来研究投票过程.</li></ul><a id="more"></a><h2 id="基础知识">基础知识</h2><h3 id="整数划分与-tabloid">整数划分与 tabloid</h3><ul><li>称 <span class="math inline">\(\lambda=(\lambda_1,\ldots,\lambda_m)\)</span>，s.t. <span class="math inline">\(\sum\limits_{i=1}^m \lambda_i=n\)</span> 为 <span class="math inline">\(n\)</span> 的一个分解(composition)，若该序列是递减的，则称为一个划分(partition)；</li><li>给定 <span class="math inline">\(n\)</span> 的划分 <span class="math inline">\(\lambda\)</span>，考虑 <span class="math inline">\(n\)</span> 个方块的一个图表，第 <span class="math inline">\(i\)</span> 行有 <span class="math inline">\(\lambda_i\)</span> 个格子，这样的图表称为形状为 <span class="math inline">\(\lambda\)</span> 的杨表；<ul><li>现给出杨表的一个等价关系：每行的元素集合相等，则两个杨表等价，容易验证这是一个等价关系；</li><li>杨表在该等价关系下的一个等价类叫做一个（形状为 <span class="math inline">\(\lambda\)</span> 的） tabloid.</li></ul></li><li>形状为 <span class="math inline">\(\lambda\)</span> 的全体 tabloid 记为 <span class="math inline">\(X^\lambda\)</span>；</li><li><span class="math inline">\(X^\lambda\)</span> 上所有函数 <span class="math inline">\(f: X^\lambda\to\mathbb{Q}\)</span> 记作 <span class="math inline">\(M^\lambda\)</span>.<ul><li><span class="math inline">\(X^\lambda\)</span> 中所有元的示性函数构成 <span class="math inline">\(M^\lambda\)</span> 的一组基，进而有 <span class="math inline">\(\dim M^\lambda=|X^\lambda|\)</span>.</li></ul></li></ul><h3 id="与投票建立联系">与投票建立联系</h3><ul><li>偏好与 tabloid：<span class="math inline">\(i\succ j\iff i\)</span> 在 <span class="math inline">\(j\)</span> 的上层；<span class="math inline">\(i\sim j\iff i\)</span> 与 <span class="math inline">\(j\)</span> 在同一层.<ul><li>换言之，一个序就是一个 tabloid.</li></ul></li><li>进一步，给定 <span class="math inline">\(\lambda\)</span> 之后，一个 profile 就是一个 <span class="math inline">\(p\in M^\lambda\)</span>.</li><li></li><li>偏序与全序的转化：<ul><li>偏序 <span class="math inline">\(\to\)</span> 全序：同一行的权重均分；</li><li>转化的映射：<span class="math inline">\(\iota: M^\lambda\to M^{(1,\ldots,1)}\)</span>.</li></ul></li></ul><h3 id="对称群-s_n-的作用">对称群 <span class="math inline">\(S_n\)</span> 的作用</h3><p><span class="math inline">\(S_n\)</span> 在 <span class="math inline">\(X^\lambda\)</span> 上有自然的左乘作用. 可通过定义 <span class="math inline">\((\sigma p)(x)=p(\sigma^{-1}x)\)</span> 将该作用提升到 <span class="math inline">\(M^\lambda\)</span> 上. 进一步可扩展为 <span class="math inline">\(\mathbb{Q}S_n\)</span> 的作用.</p><p>这说明什么？？？这意味着什么？？？意味着 <span class="math inline">\(M^\lambda\)</span> 是 <span class="math inline">\(\mathbb{Q}S_n\)</span>-模.</p><p>从现在开始，主要讨论全序（<span class="math inline">\(\lambda=(1,\ldots,1)\)</span>）情形.</p><h2 id="对投票过程的分析">对投票过程的分析</h2><h3 id="投票模同态">投票？模同态！</h3><p>这里主要讨论的是位置投票(positional voting) 以及孔多塞投票 (Condorcet voting)</p><h4 id="位置投票制">位置投票制</h4><p>核心：权重向量 <span class="math inline">\(w=[w_1,\ldots,w_n]^T\)</span>.</p><ul><li>计票：映射 <span class="math inline">\(T_w: M^{(1,\ldots,1)}\to M^{(1,n-1)}\)</span>.<ul><li>这个映射的线性性很好验证.</li></ul></li></ul><p>位置投票的中立性告诉我们 <span class="math inline">\(\forall \sigma\in S_n\)</span>，总有 <span class="math inline">\(T_w(\sigma p)=\sigma T_w(p)\)</span>.</p><p>这意味着什么？？？意味着 <span class="math inline">\(T_w\)</span> 与群运算相容. 换言之，<span class="math inline">\(T_w\)</span> 是模同构！</p><h4 id="孔多塞投票">孔多塞投票</h4><p>定义这里不多赘述. 其核心是拉两个元素出来配对比较. 因而其计票过程是一个配对映射 <span class="math inline">\(P: M^{(1,\ldots,1)}\to M^{(1,1,n-2)}\)</span>（同样可以验证其线性性）</p><p>类似地，<span class="math inline">\(P\)</span> 也是模同态.</p><hr><p>那这样，我们用群表示的<del>芝士</del>知识来分析分析吧.</p><p>首先，<span class="math inline">\(\mathbb{Q}\)</span> 是一个特征为 <span class="math inline">\(0\)</span> 的域，因此我们可以做什么？可以用 Maschke 定理. 即所有的 <span class="math inline">\(M^\lambda\)</span> 都是半单的，即可以分解为 <span class="math inline">\(\mathbb{Q}S_n\)</span> 单模的直和. - 这里在GTM 203里有经典的结果：specht module. 这个结果正是利用整数拆分来做的.</p><p>那我们就把 <span class="math inline">\(M^\lambda\)</span> 拆成不可约模的直和，然后呢？</p><p>然后可以用 Schur 引理啊！这样我们就可以知道哪些选票是有用的，哪些是无用的了. 进一步还可以得到一些其他的结果.</p><p>值得一提的是，这些结果与 Saari 先前的一些结果能够相互印证.</p><h2 id="部分序情形approval-voting">部分序情形：Approval voting</h2><p>这一部分讨论给全序加断点后的故事，即 <span class="math inline">\(\lambda=(1,\ldots,1,n-k)\)</span>.</p><h2 id="borda-count-的特殊性">Borda count 的特殊性</h2><hr><p>总的来说，我觉得这篇文章没有真正落实作者的豪言壮语…“重建了一些 voting paradox”…嗯？没找着…</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 北大 </tag>
            
            <tag> 社会计算 </tag>
            
            <tag> 论文笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论文笔记[9]——Strategy-proof allocation of indivisible goods</title>
      <link href="/2019/10/23/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-9-%E2%80%94%E2%80%94Strategy-proof-allocation-of-indivisible-goods/"/>
      <content type="html"><![CDATA[<blockquote><p>文章：Svensson L G. Strategy-proof allocation of indivisible goods[J]. Social Choice and Welfare, 1999, 16(4): 557-567.<br>其实是夏老师 <em>Allocating Indivisible Items in Categorized Domains</em> 一文的单类型版本.</p></blockquote><p>主要结果：strategyproof, nonbossy 且中立的分配机制 <span class="math inline">\(f\)</span> 一定是 serial dictatorial.</p><a id="more"></a><blockquote><p><strong>Lemma 1</strong> 设 <span class="math inline">\(f\)</span> 是 strategyproof 且 nonbossy 的，若 <span class="math inline">\(u,v\in\mathscr{U}\)</span> 满足：<span class="math inline">\(\forall i\in N,\forall x\in A\)</span>，<span class="math inline">\(u_i(x)\leqslant u_i(f_i(u)) \Rightarrow v_i(x)\leqslant v_i(f_i(u))\)</span>，则 <span class="math inline">\(f(v)=f(u)\)</span>.</p></blockquote><ul><li>换言之：<span class="math inline">\(v\)</span> 只要没有扩大 <span class="math inline">\(u\)</span> 中优于 <span class="math inline">\(f_i(u)\)</span> 的集合，就不会改变分配结果.</li><li>证明：先证 <span class="math inline">\(f(v_i, u_{-i})=f(u)\)</span>，再取 <span class="math inline">\(u^{p}=(v_1,\ldots,v_{p-1},u_p,\ldots u_n)\)</span> 进行证明.</li></ul><blockquote><p><strong>Lemma 2</strong> 设 <span class="math inline">\(f\)</span> strategyproof, nonbossy 且中立的机制，profile <span class="math inline">\(u\)</span> 中所有人的偏好都相同，则其分配结果是 Pareto 最优的.</p></blockquote><ul><li>证明：反证法，假设不是 Pareto efficient，则存在一个 <span class="math inline">\(a\in A-\{f_i(u): i\in N\}\)</span>，s.t. …</li></ul><blockquote><p><strong>Thm 1</strong> strategyproof, nonbossy 且中立的分配机制 <span class="math inline">\(f\)</span> 一定是 serially dictatorial.</p></blockquote><ul><li>同时，也容易验证 serially dictatorial 满足上述三条性质.</li></ul><p>值得注意的是，在 Thm 1 中，nonbossy 是必须的，否则 <span class="math inline">\(f\)</span> 未必是 serially dictatorial. - 若将其去掉，文中给出了反例； - 若将其替换为 pareto consistency，文中也给出反例.</p><blockquote><p><strong>Lemma 3</strong> 对 <span class="math inline">\(\forall u\in\mathscr{U}\)</span>，恰好存在一个 core allocation <span class="math inline">\(\varphi\)</span>. 同时存在一个与之相对应的 <span class="math inline">\(N\)</span> 的划分 <span class="math inline">\(\{N_j\}_{j=1}^r,~r\leqslant n\)</span>，s.t. <span class="math display">\[A_j=\varphi(N_j)对 \forall 1\leqslant j\leqslant r 是\text{cycle}，且若 i\in N_j，则 u_i(\varphi(i))\geqslant u_i(a),~\forall a\in A-\bigcup\limits_{k=1}^{j-1}A_k.\]</span></p></blockquote><blockquote><p><strong>Thm. 2</strong> 一个 strategyproof，individually rational 且 pareto consistent 的机制 <span class="math inline">\(f\)</span> 是一个 core mechanism.</p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 北大 </tag>
            
            <tag> 社会计算 </tag>
            
            <tag> 论文笔记 </tag>
            
            <tag> 经济学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Something about 四色猜想</title>
      <link href="/2019/10/21/%E5%9B%9B%E8%89%B2%E7%8C%9C%E6%83%B3/"/>
      <content type="html"><![CDATA[<p>许进老师《现代图论》课中所讲授的四色猜想的相关内容.</p><a id="more"></a><h2 id="基础知识">基础知识</h2><center>这里只讨论有限平面图，且无自环、重边.</center><p>一些相关概念介绍如下（图的定义、Euler公式、Kuratowski定理等不再赘述）：</p><blockquote><p><strong>图的染色（着色）</strong> 给图的顶点赋权（一般为整数，当然，不是整数也可以强行调整为整数…），相邻顶点不同权.</p></blockquote><blockquote><p><strong>四色猜想</strong> 任意平面图都是可以 <span class="math inline">\(4\)</span>-染色的.</p></blockquote><blockquote><p><strong>导出子图</strong> 设有图 <span class="math inline">\(G=(V,E)\)</span>，及其顶点集的子集 <span class="math inline">\(V&#39;\subset V\)</span>，记 <span class="math inline">\(E&#39;=\{(u,v)\in E:u,v\in W\}\)</span>，则称 <span class="math inline">\(G&#39;(V&#39;)=(V&#39;,E&#39;)\)</span> 为 <span class="math inline">\(V&#39;\)</span> 的导出子图.</p></blockquote><ul><li>随便举个例子吧：<span class="math inline">\(K_n\)</span> 的任意 <span class="math inline">\(m\)</span> 元子集的导出子图都是 <span class="math inline">\(K_m\)</span>. （当然，<span class="math inline">\(m\leqslant n\)</span> …）</li></ul><blockquote><p><strong>极大平面图</strong> 顾名思义，就是边已经多到极限的平面图，以至于再加一条边，它就不是平面图了.</p></blockquote><ul><li>极大平面图又称三角剖分图，其每个面都是三角（二维单形就是三角，课上许老师没有提单形的故事，但其实单形剖分是在任何维度存在的）；</li><li>任何一个图都可以通过不断加边而变成一个极大平面图。</li></ul><h3 id="符号说明">符号说明</h3><ul><li><span class="math inline">\(n\)</span>：点数；</li><li><span class="math inline">\(m\)</span>：边数；</li><li><span class="math inline">\(\delta\)</span>：图中顶点的最小度数.</li></ul><blockquote><p><strong>关键术语：</strong></p><ul><li><strong>Kempe 链</strong>：只含两种颜色的链.</li><li><strong>Kempe 变换</strong>：一种通过换色来减少颜色的技巧.</li></ul></blockquote><h2 id="kempe-的证明思路">Kempe 的证明思路</h2><p>用数学归纳法：</p><ul><li>容易验证 <span class="math inline">\(n\leqslant 5\)</span> 时，所有的极大平面图都可以被 <span class="math inline">\(4\)</span>-染色.</li><li>设 <span class="math inline">\(n\leqslant p\)</span> 时，所有 <span class="math inline">\(n\)</span> 个顶点的极大平面图都可以被 <span class="math inline">\(4\)</span>-染色，考虑 <span class="math inline">\(p+1\)</span> 的情. 由 Euler 公式可知，对于极大平面图，有 <span class="math inline">\(3\leqslant \delta\leqslant 5\)</span>，故分三种情况讨论：<ul><li><span class="math inline">\(\delta=3\)</span>： <img src="/img/blog-graph/delta=3.png" alt="delta=3情形" width="300"> 由于 <span class="math inline">\(\delta=3\)</span>，故必定会存在一个 <span class="math inline">\(3\)</span> 度顶点，即有图中所示的结构. 记 <span class="math inline">\(G&#39;=G-D\)</span>，则 <span class="math inline">\(|G&#39;|=p\)</span>，因而可以被 <span class="math inline">\(4\)</span>-染色. 而 <span class="math inline">\(D\)</span> 相邻的 <span class="math inline">\(A,B,C\)</span> 点也至多占掉三种颜色，故此时的图 <span class="math inline">\(G\)</span> 是可以被 <span class="math inline">\(4\)</span>-染色的.</li><li><span class="math inline">\(\delta=4\)</span>： <img src="/img/blog-graph/delta=4.png" alt="delta=4情形" width="300"> 同上，会存在一个图示的结构，记 <span class="math inline">\(G&#39;=G-E\)</span>，则 <span class="math inline">\(G&#39;\)</span> 有一个 <span class="math inline">\(4\)</span>-染色. 若 <span class="math inline">\(A,B,C,D\)</span> 只用了至多 <span class="math inline">\(3\)</span> 种颜色，则可以完全沿用上述方法. 因此只讨论 <span class="math inline">\(A,B,C,D\)</span> 分别用了颜色 <span class="math inline">\(1,2,3,4\)</span> 的情形. 此时采用的办法被称为 <strong>Kempe 变换</strong>：<br>考虑 <span class="math inline">\(G&#39;\)</span> 中，颜色 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(3\)</span> 的导出子图 <span class="math inline">\(G&#39;[1,3]\)</span>：<ul><li>若 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(C\)</span> 不在 <span class="math inline">\(G&#39;[1,3]\)</span> 的同一个连通分支内，则可以将其中一者（不妨设是 <span class="math inline">\(A\)</span>）所在的连通分支上的 <span class="math inline">\(1\)</span> 与 <span class="math inline">\(3\)</span> 全部交换，该种转换不会产生颜色的冲突. 转换完毕后，<span class="math inline">\(A\)</span> 与 <span class="math inline">\(C\)</span> 将变为同色，即 <span class="math inline">\(A,B,C,D\)</span> 只占三种颜色；</li><li>若 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(C\)</span> 在 <span class="math inline">\(G&#39;[1,3]\)</span> 的同一连通分支内，则必定存在一条连接 <span class="math inline">\(A\)</span> 与 <span class="math inline">\(C\)</span> 的 <span class="math inline">\(1-3-1-3-\cdots\)</span> 路径（这样的路径称为 Kempe 链）. 此时考虑 <span class="math inline">\(G&#39;[2,4]\)</span>，则 <span class="math inline">\(B\)</span> 和 <span class="math inline">\(D\)</span> 一定不在 <span class="math inline">\(G&#39;[2,4]\)</span> 的同一连通分支内（有点像 Jordan 闭曲线定理的那种感觉，<span class="math inline">\(B\)</span> 和 <span class="math inline">\(D\)</span> 一个在内一个在外），即可以对 <span class="math inline">\(G&#39;[2,4]\)</span> 做变换，此时也可转换为 <span class="math inline">\(A,B,C,D\)</span> 只占三种颜色的情形.</li></ul></li><li><span class="math inline">\(\delta=5\)</span>： <img src="/img/blog-graph/delta=5.png" alt="delta=5情形" width="300"> 同样会存在一个图示的结构，记 <span class="math inline">\(G&#39;=G-F\)</span>，则 <span class="math inline">\(G&#39;\)</span> 存在一个 <span class="math inline">\(4\)</span>-染色. 若 <span class="math inline">\(A,B,C,D,E\)</span> 只用了至多 <span class="math inline">\(3\)</span> 种颜色，则很容易给出该种情形的一个 <span class="math inline">\(4\)</span>-染色. 当 <span class="math inline">\(A,B,C,D,E\)</span> 恰好用了 <span class="math inline">\(4\)</span> 种颜色时，必定有且仅有两个顶点同色，不失一般性，设 <span class="math inline">\(f(A)=1,f(B)=f(E)=2,f(C)=3,f(D)=4\)</span>. 此时考虑 <span class="math inline">\(G&#39;[1,3]\)</span> 和 <span class="math inline">\(G&#39;[1,4]\)</span>：<ul><li>若 <span class="math inline">\(A,C\)</span> 和 <span class="math inline">\(A,D\)</span> 至少有一对在相应的导出子图上不连通，则可以直接采取换色的方式消灭掉颜色 <span class="math inline">\(1\)</span>，此时在 <span class="math inline">\(G\)</span> 中给 <span class="math inline">\(F\)</span> 染颜色 <span class="math inline">\(1\)</span> 即可.</li><li>若 <span class="math inline">\(A,C\)</span> 和 <span class="math inline">\(A,D\)</span> 在相应的导出子图上都连通，则在 <span class="math inline">\(G&#39;\)</span> 中存在一条连接 <span class="math inline">\(A,C\)</span> 的 <span class="math inline">\(1-3-1-3\cdots\)</span> 链和一条连接 <span class="math inline">\(A,D\)</span> 的 <span class="math inline">\(2-4-2-4\cdots\)</span> 链，分别将 <span class="math inline">\(B\)</span> 与 <span class="math inline">\(E\)</span> 包围. 故类似 <span class="math inline">\(\delta=4\)</span> 的情况，不难发现此时不存在 <span class="math inline">\(E\to C\)</span> 和 <span class="math inline">\(B\to C\)</span> 的 Kempe 链，因而进行两次换色，即可将颜色 <span class="math inline">\(2\)</span> 消除. 进一步给 <span class="math inline">\(F\)</span> 染颜色 <span class="math inline">\(4\)</span> 即可得到 <span class="math inline">\(G\)</span> 的 <span class="math inline">\(4\)</span>-染色.</li></ul></li></ul></li></ul><p>听起来很简单，不是吗？但很遗憾这个证法是错误的. 错误的关键就在于：虽然图中有一条 <span class="math inline">\(A\to C\)</span> 和一条 <span class="math inline">\(A\to D\)</span> 的 Kempe 链，但这两条链可能在处 <span class="math inline">\(A\)</span> 点之外的其他地方也有交点，这可能会导致我们在后面消除颜色 <span class="math inline">\(2\)</span> 的换色过程中失败.</p><p>听起来好绕啊！那就详细说说…</p><p>当 <span class="math inline">\(\delta=5\)</span>，且 <span class="math inline">\(|f\{A,B,C,D,E\}|=4\)</span>，且 <span class="math inline">\(A,C\)</span> 在 <span class="math inline">\(G&#39;[1,3]\)</span> 中连通，<span class="math inline">\(A,D\)</span> 在 <span class="math inline">\(G&#39;[1,4]\)</span> 中连通时，我们需要进行两次换色：</p><ol type="1"><li>在 <span class="math inline">\(G&#39;[2,3]\)</span> 中，将 <span class="math inline">\(E\)</span> 所在的连通分支中的所有 <span class="math inline">\(2\)</span> 和 <span class="math inline">\(3\)</span> 对换，即可将 <span class="math inline">\(E\)</span> 换为颜色 <span class="math inline">\(3\)</span>.</li><li>在 <span class="math inline">\(G&#39;[2,4]\)</span> 中，将 <span class="math inline">\(B\)</span> 所在的连通分支中的所有 <span class="math inline">\(2\)</span> 和 <span class="math inline">\(4\)</span> 对换，即可将 <span class="math inline">\(B\)</span> 换为颜色 <span class="math inline">\(4\)</span>.</li></ol><p>两次换色后，<span class="math inline">\(A,B,C,D,E\)</span> 的颜色分别为 <span class="math inline">\(1,4,3,4,3\)</span>，成功减少了一种颜色！</p><p>那么，问题出在哪里呢？</p><p>就是上述过程中，第一次换色完全可能影响到第二次换色.</p><p>试想，如果第一次换色使得 <span class="math inline">\(B\)</span> 和 <span class="math inline">\(D\)</span> 在 <span class="math inline">\(G&#39;[2,4]\)</span> 中连通了怎么办？第二次换色就无法进行了！！那我们构造 <span class="math inline">\(G\)</span> 的 <span class="math inline">\(4\)</span>-染色的计划就失败了（</p><p>那么，什么情况会导致第二次换色失败呢？</p><p>我们要让第一次和第二次换色产生关系. 因此我们努力让它们换色的前提产生关系. 那就是说，我们要让 <span class="math inline">\(A\to C\)</span> 的 Kempe 链与 <span class="math inline">\(A\to D\)</span> 的 Kempe 链在 <span class="math inline">\(A\)</span> 以外的一点相交，这样两次换色就可以互相干扰了.</p><p>事实上，Heawood 给出的反例正是应用了这个思路. 其具体的反例如下图所示：</p><p><img src="/img/blog-graph/Heawood4ColorGraph.gif" alt="Heawood 的反例" width="300"></p><hr><p>虽然 Kempe 没有成功证明四色定理，但 Kempe 的工作仍然是非常有意义的，在其做法的基础上稍加改动，即可证明比四色定理稍弱的五色定理. 后来 Appel–Haken 对 Kempe 变换失效的不可约情形进行了研究，并利用计算机给出了证明.</p><h2 id="对-kempe-工作的进一步思考">对 Kempe 工作的进一步思考</h2><p>既然两条 Kempe 链相交会导致 Kempe 变换失效，那么我们就需要寻找不相交的 Kempe 链.</p><blockquote><p><strong>Mr. Xu 的猜想！</strong> 对于 <span class="math inline">\(\delta=5\)</span> 的情形，对任意一个 <span class="math inline">\(5\)</span> 度顶点 <span class="math inline">\(v_0\)</span>（<span class="math inline">\(N(v_0)=\{v_1,v_2,v_3,v_4,v_5\}\)</span>），都存在 <span class="math inline">\(G&#39;\)</span> 的一种染色方案 <span class="math inline">\(f\)</span>，s.t. 存在 <span class="math inline">\(v_1\to v_3\)</span> 和 <span class="math inline">\(v_1\to v_4\)</span> 两条 Kempe 链，且这两条链仅在 <span class="math inline">\(v_1\)</span> 相交.</p></blockquote><p>若能证明这个猜想，那当然能修复 Kempe 的证明.（不过我8太看好…</p><ul><li>貌似 Heawood 的图中，中心的 <span class="math inline">\(5\)</span> 度顶点就根本不行…</li><li>我始终觉得这个猜想只需要存在性就行了（存在一个 <span class="math inline">\(5\)</span> 度顶点…），但 Mr. Xu 课上说的的确是任意… 迷惑…</li></ul>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 计算机 </tag>
            
            <tag> 北大 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019算法分析和复杂性理论课程作业</title>
      <link href="/2019/10/16/2019%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%92%8C%E5%A4%8D%E6%9D%82%E6%80%A7%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"/>
      <content type="html"><![CDATA[<p>没来由地…突然很想记录一下…</p><blockquote><p>第一次上机作业（09.09 - 09.23）：<a href="http://algorithm.openjudge.cn/hw201901/" target="_blank" rel="noopener">http://algorithm.openjudge.cn/hw201901/</a><br>第二次上机作业（10.14 - 10.28）：<a href="http://algorithm.openjudge.cn/hw201902/" target="_blank" rel="noopener">http://algorithm.openjudge.cn/hw201902/</a><br>第三次上机作业（10.28 - 11.18）：<a href="http://algorithm.openjudge.cn/hw201903/" target="_blank" rel="noopener">http://algorithm.openjudge.cn/hw201903/</a><br>第四次上机作业（11.18 - 12.16）：<a href="http://algorithm.openjudge.cn/201904/" target="_blank" rel="noopener">http://algorithm.openjudge.cn/201904/</a></p></blockquote><a id="more"></a><h2 id="第一次上机作业代码">第一次上机作业代码</h2><h3 id="a.-石头剪刀布模拟">A. 石头剪刀布：模拟</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, na, nb;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;na, &amp;nb);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; na; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nb; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">    int awin(0), bwin(0), draw(0);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i % na] == <span class="number">0</span> &amp;&amp; b[i % nb] == <span class="number">0</span>) draw++;</span><br><span class="line">        <span class="keyword">if</span>(a[i % na] == <span class="number">0</span> &amp;&amp; b[i % nb] == <span class="number">2</span>) awin++;</span><br><span class="line">        <span class="keyword">if</span>(a[i % na] == <span class="number">0</span> &amp;&amp; b[i % nb] == <span class="number">5</span>) bwin++;</span><br><span class="line">        <span class="keyword">if</span>(a[i % na] == <span class="number">2</span> &amp;&amp; b[i % nb] == <span class="number">0</span>) bwin++;</span><br><span class="line">        <span class="keyword">if</span>(a[i % na] == <span class="number">2</span> &amp;&amp; b[i % nb] == <span class="number">2</span>) draw++;</span><br><span class="line">        <span class="keyword">if</span>(a[i % na] == <span class="number">2</span> &amp;&amp; b[i % nb] == <span class="number">5</span>) awin++;</span><br><span class="line">        <span class="keyword">if</span>(a[i % na] == <span class="number">5</span> &amp;&amp; b[i % nb] == <span class="number">0</span>) awin++;</span><br><span class="line">        <span class="keyword">if</span>(a[i % na] == <span class="number">5</span> &amp;&amp; b[i % nb] == <span class="number">2</span>) bwin++;</span><br><span class="line">        <span class="keyword">if</span>(a[i % na] == <span class="number">5</span> &amp;&amp; b[i % nb] == <span class="number">5</span>) draw++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(awin &gt; bwin) <span class="built_in">printf</span>(<span class="string">"A\n"</span>);</span><br><span class="line">    <span class="keyword">if</span>(bwin &gt; awin) <span class="built_in">printf</span>(<span class="string">"B\n"</span>);</span><br><span class="line">    <span class="keyword">if</span>(awin == bwin) <span class="built_in">printf</span>(<span class="string">"draw\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="b-汉诺塔问题hanoi递归">B: 汉诺塔问题(Hanoi)：递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b, <span class="keyword">char</span> c, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d:%c-&gt;%c\n"</span>, n, a, c);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        solve(a, c, b, n - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d:%c-&gt;%c\n"</span>, n, a, c);</span><br><span class="line">        solve(b, a, c, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i]);</span><br><span class="line">    solve(s[<span class="number">0</span>][<span class="number">0</span>], s[<span class="number">1</span>][<span class="number">0</span>], s[<span class="number">2</span>][<span class="number">0</span>], n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="c-二维数组右上左下遍历模拟">C: 二维数组右上左下遍历：模拟</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> row, col;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; row - <span class="number">1</span> || y &gt; col - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;row, &amp;col);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; col; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> c = y;</span><br><span class="line">        <span class="keyword">while</span>(judge(r, c))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[r++][c--]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt; row; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> r = x;</span><br><span class="line">        <span class="keyword">int</span> c = col<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(judge(r, c))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[r++][c--]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个做法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; n - <span class="number">1</span> || y &gt; m - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> state = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(state)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[r][c]);</span><br><span class="line">        <span class="keyword">if</span>(judge(r + <span class="number">1</span>, c - <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            r = r + <span class="number">1</span>;</span><br><span class="line">            c = c - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(judge(<span class="number">0</span>, r + c + <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = r;</span><br><span class="line">                r = <span class="number">0</span>;</span><br><span class="line">                c = tmp + c + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(judge(r + c + <span class="number">2</span> - m, m - <span class="number">1</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    r = r + c + <span class="number">2</span> - m;</span><br><span class="line">                    c = m - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> state = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="d-由中根序列和后根序列重建二叉树递归">D: 由中根序列和后根序列重建二叉树：递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; node;</span><br><span class="line"><span class="keyword">int</span> tree[<span class="number">65536</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt, <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[idx] = node[rt];</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pos, lson, rson;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (pos = l; pos &lt;= r; pos++)</span><br><span class="line">        <span class="keyword">if</span> (node[pos] == node[rt])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pos &gt; l)</span><br><span class="line">    &#123;</span><br><span class="line">        lson = rt - r + pos - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>, node[lson]);</span><br><span class="line">        solve(l, pos - <span class="number">1</span>, lson, idx &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pos &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        rson = rt - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>, node[rson]);</span><br><span class="line">        solve(pos + <span class="number">1</span>, r, rson, (idx &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x) != EOF)</span><br><span class="line">        node.push_back(x);</span><br><span class="line">    <span class="keyword">int</span> n = node.size();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, node[n - <span class="number">1</span>]);</span><br><span class="line">    solve(<span class="number">0</span>, (n &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="e-文本二叉树先建树然后遍历关键是建树">E: 文本二叉树：先建树/然后遍历/关键是建树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; &gt; v;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">v.clear();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++)</span><br><span class="line">g[i].clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">g[u].push_back(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> dep = v[i].first;</span><br><span class="line"><span class="keyword">char</span> key = v[i].second;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line"><span class="keyword">if</span>(g[j].size() &lt; <span class="number">2</span> &amp;&amp; v[j].first == dep - <span class="number">1</span> &amp;&amp; v[j].second != <span class="string">'*'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                addedge(j, i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(v[s].second == <span class="string">'*'</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, v[s].second);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[s].size(); i++)</span><br><span class="line">        PreOrder((g[s][i]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(v[s].second == <span class="string">'*'</span>) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(g[s].size() &gt; <span class="number">0</span>)</span><br><span class="line">InOrder(g[s][<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, v[s].second);</span><br><span class="line"><span class="keyword">if</span>(g[s].size() &gt; <span class="number">1</span>)</span><br><span class="line">InOrder(g[s][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(v[s].second == <span class="string">'*'</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[s].size(); i++)</span><br><span class="line">PostOrder(g[s][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, v[s].second);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">v.push_back(make_pair(<span class="number">0</span>, s[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s) != EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'0'</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">v.push_back(make_pair(len - <span class="number">1</span>, s[len - <span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = v.size();</span><br><span class="line">build(n);</span><br><span class="line"></span><br><span class="line">PreOrder(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">PostOrder(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">InOrder(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">if</span>(t) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更“正统”的做法是这样…用二叉树的方法来做二叉树的题…故称正统</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name;</span><br><span class="line">    node *lson, *rson;</span><br><span class="line">    <span class="keyword">int</span> len, cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node *<span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;node *&gt; stk;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line"></span><br><span class="line">    node *root = <span class="keyword">new</span> node;</span><br><span class="line">    root-&gt;name = s[<span class="number">0</span>];</span><br><span class="line">    root-&gt;lson = <span class="literal">NULL</span>;</span><br><span class="line">    root-&gt;rson = <span class="literal">NULL</span>;</span><br><span class="line">    root-&gt;len = <span class="number">0</span>;</span><br><span class="line">    root-&gt;cnt = <span class="number">0</span>;</span><br><span class="line">    stk.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'0'</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line"></span><br><span class="line">        node *new_Node = <span class="keyword">new</span> node;</span><br><span class="line">        new_Node-&gt;name = s[len - <span class="number">1</span>];</span><br><span class="line">        new_Node-&gt;lson = <span class="literal">NULL</span>;</span><br><span class="line">        new_Node-&gt;rson = <span class="literal">NULL</span>;</span><br><span class="line">        new_Node-&gt;len = len - <span class="number">1</span>;</span><br><span class="line">        new_Node-&gt;cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        node *r = stk.top();</span><br><span class="line">        <span class="keyword">while</span> (new_Node-&gt;len - r-&gt;len != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stk.pop();</span><br><span class="line">            r = stk.top();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (new_Node-&gt;name == <span class="string">'*'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            r-&gt;cnt++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;cnt == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            r-&gt;lson = new_Node;</span><br><span class="line">            r-&gt;cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (r-&gt;cnt == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            r-&gt;rson = new_Node;</span><br><span class="line">            r-&gt;cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;cnt == <span class="number">2</span>)</span><br><span class="line">            stk.pop();</span><br><span class="line">        stk.push(new_Node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, root-&gt;name);</span><br><span class="line">    PreOrder(root-&gt;lson);</span><br><span class="line">    PreOrder(root-&gt;rson);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    InOrder(root-&gt;lson);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, root-&gt;name);</span><br><span class="line">    InOrder(root-&gt;rson);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    PostOrder(root-&gt;lson);</span><br><span class="line">    PostOrder(root-&gt;rson);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, root-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        node *root = build();</span><br><span class="line"></span><br><span class="line">        PreOrder(root);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        PostOrder(root);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        InOrder(root);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="f-棋盘问题dfs-计数">F: 棋盘问题：DFS 计数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> mp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> n, k, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(mp, <span class="literal">false</span>, <span class="keyword">sizeof</span>(mp));</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y &gt;= k)</span><br><span class="line">    &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; mp[i][j] == <span class="string">'#'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                vis[j] = <span class="literal">true</span>;</span><br><span class="line">                dfs(i + <span class="number">1</span> , y + <span class="number">1</span>);</span><br><span class="line">                vis[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">-1</span> &amp;&amp; k == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, mp[i]);</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二次上机作业代码">第二次上机作业代码</h2><h3 id="a-仙岛求药最最-naive-的-bfs-搜索">A: 仙岛求药：最最 naive 的 BFS 搜索</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> mp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> step[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(step, <span class="number">-1</span>, <span class="keyword">sizeof</span>(step));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= n || y &gt;= m)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mp[x][y] == <span class="string">'#'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span> &amp;&amp; n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, mp[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sx, sy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">                <span class="keyword">if</span> (mp[i][j] == <span class="string">'@'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    sx = i;</span><br><span class="line">                    sy = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">        Q.push(make_pair(sx, sy));</span><br><span class="line">        step[sx][sy] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> state = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!Q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> xx = Q.front().first;</span><br><span class="line">            <span class="keyword">int</span> yy = Q.front().second;</span><br><span class="line">            <span class="keyword">if</span> (mp[xx][yy] == <span class="string">'*'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                state = <span class="literal">true</span>;</span><br><span class="line">                ans = step[xx][yy];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmpx = xx + dx[i];</span><br><span class="line">                <span class="keyword">int</span> tmpy = yy + dy[i];</span><br><span class="line">                <span class="keyword">if</span> (judge(tmpx, tmpy) &amp;&amp; step[tmpx][tmpy] == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Q.push(make_pair(tmpx, tmpy));</span><br><span class="line">                    step[tmpx][tmpy] = step[xx][yy] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Q.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!state)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="b-butterfly染色判断二分图">B: Butterfly：染色判断二分图</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, color[maxn];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; g[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(color, <span class="number">0</span>, <span class="keyword">sizeof</span>(color));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        g[i].clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g[u].push_back(make_pair(v, w));</span><br><span class="line">    g[v].push_back(make_pair(u, w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sz = g[u].size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = g[u][i].first;</span><br><span class="line">        <span class="keyword">int</span> w = g[u][i].second;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span>) <span class="comment">// same color</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (color[v] == -c)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (color[v] == <span class="number">0</span> &amp;&amp; !dfs(v, c))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">1</span>) <span class="comment">// diff color</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (color[v] == c)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (color[v] == <span class="number">0</span> &amp;&amp; !dfs(v, -c))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">while</span> (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b, color;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;color);</span><br><span class="line">            addedge(a, b, color);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dfs(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="c-区间合并for-一遍判断是否有不相交">C: 区间合并：<code>For</code> 一遍判断是否有不相交</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; x[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inter</span><span class="params">(<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; x, <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x.first &lt; y.first &amp;&amp; x.second &lt; y.first)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (y.first &lt; x.first &amp;&amp; y.second &lt; x.first)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Union(<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; x, <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> make_pair(min(x.first, y.first), max(x.second, y.second));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x[i].first, &amp;x[i].second);</span><br><span class="line"></span><br><span class="line">    sort(x, x + n);</span><br><span class="line">    <span class="keyword">bool</span> state = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (inter(x[<span class="number">0</span>], x[i]))</span><br><span class="line">            x[<span class="number">0</span>] = Union(x[<span class="number">0</span>], x[i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            state = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, x[<span class="number">0</span>].first, x[<span class="number">0</span>].second);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"no\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="d-radar-installation贪心">D: Radar Installation：贪心</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, d;</span><br><span class="line"><span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p[maxn];</span><br><span class="line"><span class="built_in">std</span>::pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; r[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>)<span class="built_in">sqrt</span>((<span class="keyword">double</span>)(d * d - x * x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cas</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;d) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> state = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;p[i].first, &amp;p[i].second);</span><br><span class="line">            <span class="keyword">if</span> (p[i].second &gt; d)</span><br><span class="line">                state = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (state)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                r[i].first = p[i].first - dis(p[i].second);</span><br><span class="line">                r[i].second = p[i].first + dis(p[i].second);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sort(r, r + n);</span><br><span class="line">            int res(0), p(0);</span><br><span class="line">            <span class="keyword">while</span> (p &lt; n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">double</span> rx = r[p].second;</span><br><span class="line">                p++;</span><br><span class="line">                <span class="keyword">while</span> (p &lt; n &amp;&amp; (<span class="keyword">double</span>)(r[p].first) &lt;= rx)</span><br><span class="line">                &#123;</span><br><span class="line">                    rx = min(rx, r[p].second);</span><br><span class="line">                    p++;</span><br><span class="line">                &#125;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>, ++cas, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="built_in">printf</span>(<span class="string">"Case %d: -1\n"</span>, ++cas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="e-the-unique-mst判断-mst-唯一性求次小并与之比较即可">E: The Unique MST：判断 mst 唯一性/求次小并与之比较即可</h3><p>Kruskal 求出 mst 并存起来，枚举 mst 中的边，将其删掉并在剩余图中求 mst，这些 mst 中最小者即为次小生成树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mst;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    Edge() &#123;&#125;</span><br><span class="line">    Edge(<span class="keyword">int</span> _u, <span class="keyword">int</span> _v, <span class="keyword">int</span> _w) : u(_u), v(_v), w(_w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; e;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e.push_back(Edge(u, v, w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(fa[x] != x)</span><br><span class="line">        x = fa[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e.clear();</span><br><span class="line">    mst.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    sort(e.begin(), e.end(), cmp);</span><br><span class="line">    int cnt(0), ans(0);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = e[i].u;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">int</span> w = e[i].w;</span><br><span class="line">        <span class="keyword">int</span> t1 = Find(u);</span><br><span class="line">        <span class="keyword">int</span> t2 = Find(v);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t1 != t2)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += w;</span><br><span class="line">            fa[t1] = t2;</span><br><span class="line">            cnt++;</span><br><span class="line">            mst.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt == n - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fuckyou</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> skip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    int cnt(0), ans(0);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == skip)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> u = e[i].u;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">int</span> w = e[i].w;</span><br><span class="line">        <span class="keyword">int</span> t1 = Find(u);</span><br><span class="line">        <span class="keyword">int</span> t2 = Find(v);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t1 != t2)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += w;</span><br><span class="line">            fa[t1] = t2;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt == n - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b, c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">            addedge(a, b, c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> x = Kruskal(n), y = inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mst.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = fuckyou(n, mst[i]);</span><br><span class="line">            <span class="keyword">if</span> (tmp != <span class="number">-1</span> &amp;&amp; tmp &lt; y) y = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x == y)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Not Unique!\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="f-sorting-it-all-out拓扑排序并判断排序是否唯一">F: Sorting It All Out：拓扑排序并判断排序是否唯一</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], indeg[maxn], in[maxn];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g[u].push_back(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++)</span><br><span class="line">        g[i].clear();</span><br><span class="line">    <span class="built_in">memset</span>(indeg, <span class="number">0</span>, <span class="keyword">sizeof</span>(indeg));</span><br><span class="line">    ans.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toposort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans.clear();</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ret_state</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        in[i] = indeg[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span>(in[i] == <span class="number">0</span>) Q.push(i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Q.size() &gt; <span class="number">1</span>) ret_state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> u = Q.front();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[u].size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = g[u][i];</span><br><span class="line">            <span class="keyword">if</span>(--in[v] == <span class="number">0</span>) Q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans.push_back(u);</span><br><span class="line">        Q.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ans.size() &lt; n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret_state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        init();</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">state</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> step = <span class="number">1</span>; step &lt;= m; step++)</span><br><span class="line">        &#123;   </span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span> s[<span class="number">5</span>];</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">            <span class="keyword">if</span>(state != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> u = s[<span class="number">0</span>] - <span class="string">'A'</span>;</span><br><span class="line">            <span class="keyword">int</span> v = s[<span class="number">2</span>] - <span class="string">'A'</span>;</span><br><span class="line">            <span class="comment">// u &lt; v ====&gt; Edge u -&gt; v</span></span><br><span class="line">            addedge(u, v);</span><br><span class="line">            indeg[v]++;</span><br><span class="line"></span><br><span class="line">            state = toposort();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(state == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Sorted sequence determined after %d relations: "</span>, step);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%c"</span>, <span class="string">'A'</span> + ans[i]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">".\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(state == <span class="number">-1</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Inconsistency found after %d relations.\n"</span>, step);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(state == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Sorted sequence cannot be determined.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三次上机作业代码">第三次上机作业代码</h2><h3 id="a-求逆序对数线段树">A: 求逆序对数：线段树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">20000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[rt] = sum[rt &lt;&lt; <span class="number">1</span>] + sum[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[rt]++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= m) update(p, lson);</span><br><span class="line">    <span class="keyword">else</span> update(p, rson);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> ll, <span class="keyword">int</span> rr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ll &lt;= l &amp;&amp; rr &gt;= r) <span class="keyword">return</span> sum[rt];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ll &lt;= m) ret += query(ll, rr, lson);</span><br><span class="line">    <span class="keyword">if</span>(rr &gt; m) ret += query(ll, rr, rson);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line">        v.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            v.push_back(make_pair(x, i));</span><br><span class="line">        &#125;</span><br><span class="line">        stable_sort(v.begin(), v.end());</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            update(v[i].second, <span class="number">1</span>, maxn, <span class="number">1</span>);</span><br><span class="line">            res += query(v[i].second + <span class="number">1</span>, maxn, <span class="number">1</span>, maxn, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="b-raid暴力求解最近点对">B: Raid：暴力求解最近点对</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125; p[maxn], q[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">d</span><span class="params">(Point a, Point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;q[i].x, &amp;q[i].y);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1e15</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                res = min(res, d(p[i], q[j]));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.3f\n"</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="c-公共子序列lcs-动态规划">C: 公共子序列：LCS 动态规划</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">205</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s1[maxn], s2[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn], n1, n2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++)</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>])</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s %s"</span>, s1, s2) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        n1 = <span class="built_in">strlen</span>(s1), n2 = <span class="built_in">strlen</span>(s2);</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[n1][n2]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="d-股票买卖动态规划">D: 股票买卖：动态规划</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, a[maxn];</span><br><span class="line"><span class="keyword">int</span> dp1[maxn], dp2[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp1, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp1));</span><br><span class="line">        <span class="built_in">memset</span>(dp2, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp2));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> head = a[<span class="number">0</span>],  tail = a[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp1[i] = max(dp1[i - <span class="number">1</span>], a[i] - head);</span><br><span class="line">            head = min(head, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp2[j] = max(dp2[j + <span class="number">1</span>], tail - a[j]);</span><br><span class="line">            tail = max(tail, a[j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            res = max(res, dp1[i] + dp2[i + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="e-最大子矩阵动态规划">E: 最大子矩阵：动态规划</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn], sum[maxn], dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; r++)</span><br><span class="line">            sum[r] = a[r][i];</span><br><span class="line">        dp[<span class="number">0</span>] = sum[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt; m; r++)</span><br><span class="line">            dp[r] = max(dp[r - <span class="number">1</span>] + sum[r], sum[r]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; r++)</span><br><span class="line">            res = max(res, dp[r]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; r++)</span><br><span class="line">                sum[r] += a[r][j];</span><br><span class="line">            dp[<span class="number">0</span>] = sum[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt; m; r++)</span><br><span class="line">                dp[r] = max(dp[r - <span class="number">1</span>] + sum[r], sum[r]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; r++)</span><br><span class="line">                res = max(res, dp[r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)        </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, solve(n, n));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="f-multiplication-puzzle类似背包">F: Multiplication Puzzle：类似背包</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn], dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; j + i; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j][j + i] == <span class="number">0</span>)</span><br><span class="line">                    dp[j][j + i] = dp[j][k] + dp[k][j + i] + a[j] * a[k] * a[j + i];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[j][j + i] = min(dp[j][j + i], dp[j][k] + dp[k][j + i] + a[j] * a[k] * a[j + i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[<span class="number">0</span>][n<span class="number">-1</span>]);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第四次上机作业代码">第四次上机作业代码</h2><h3 id="a-currency-exchangebellmanford-判断负环">A: Currency Exchange：BellmanFord 判断负环</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">double</span> r, c;</span><br><span class="line">    Edge()&#123;&#125;</span><br><span class="line">    Edge(<span class="keyword">int</span> _a, <span class="keyword">int</span> _b, <span class="keyword">double</span> _r, <span class="keyword">double</span> _c): a(_a), b(_b), r(_r), c(_c) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, beg;</span><br><span class="line"><span class="keyword">double</span> s, d[maxn];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; e;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    d[beg] = s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> state = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; e.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[e[j].b] &lt; (d[e[j].a] - e[j].c) * e[j].r)</span><br><span class="line">            &#123;</span><br><span class="line">                d[e[j].b] = (d[e[j].a] - e[j].c) * e[j].r;</span><br><span class="line">                state = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!state) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; e.size(); k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[e[k].b] &lt; (d[e[k].a] - e[k].c) * e[k].r)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d%d%lf"</span>, &amp;n, &amp;m, &amp;beg, &amp;s) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        e.clear();</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b;</span><br><span class="line">            <span class="keyword">double</span> R_ab, R_ba, C_ab, C_ba;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%lf%lf%lf%lf"</span>, &amp;a, &amp;b, &amp;R_ab, &amp;C_ab, &amp;R_ba, &amp;C_ba);</span><br><span class="line">            e.push_back(Edge(a, b, R_ab, C_ab));</span><br><span class="line">            e.push_back(Edge(b, a, R_ba, C_ba));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bellman_ford()) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="b-shopping-offers动态规划">B: Shopping Offers：动态规划</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> idx[<span class="number">6</span>], cnt[<span class="number">6</span>], price[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> b, s;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">6</span>][<span class="number">6</span>][<span class="number">6</span>][<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> special_combine[maxn][<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> special_price[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;idx[i], &amp;cnt[i], &amp;price[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tmp; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">6</span>; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (idx[k] == a)</span><br><span class="line">                &#123;</span><br><span class="line">                    special_combine[i][k] = b;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;special_price[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cnt[<span class="number">0</span>]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= cnt[<span class="number">1</span>]; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= cnt[<span class="number">2</span>]; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= cnt[<span class="number">3</span>]; x++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt;= cnt[<span class="number">4</span>]; y++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> FinalPrice = inf;</span><br><span class="line">                        <span class="keyword">int</span> TempPrice = inf;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> si = <span class="number">0</span>; si &lt; s; si++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (i &gt;= special_combine[si][<span class="number">0</span>] &amp;&amp; j &gt;= special_combine[si][<span class="number">1</span>] &amp;&amp; k &gt;= special_combine[si][<span class="number">2</span>] &amp;&amp; x &gt;= special_combine[si][<span class="number">3</span>] &amp;&amp; y &gt;= special_combine[si][<span class="number">4</span>])</span><br><span class="line">                            &#123;</span><br><span class="line">                                TempPrice = dp[i - special_combine[si][<span class="number">0</span>]][j - special_combine[si][<span class="number">1</span>]][k - special_combine[si][<span class="number">2</span>]][x - special_combine[si][<span class="number">3</span>]][y - special_combine[si][<span class="number">4</span>]] + special_price[si];</span><br><span class="line">                                FinalPrice = min(FinalPrice, TempPrice);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (FinalPrice != inf)</span><br><span class="line">                        &#123;</span><br><span class="line">                            dp[i][j][k][x][y] = FinalPrice;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            dp[i][j][k][x][y] = i * price[<span class="number">0</span>] + j * price[<span class="number">1</span>] + k * price[<span class="number">2</span>] + x * price[<span class="number">3</span>] + y * price[<span class="number">4</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[cnt[<span class="number">0</span>]][cnt[<span class="number">1</span>]][cnt[<span class="number">2</span>]][cnt[<span class="number">3</span>]][cnt[<span class="number">4</span>]]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="c-the-perfect-stall二分图最大匹配">C: The Perfect Stall：二分图最大匹配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> <span class="built_in">map</span>[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> col[maxn][maxn], row[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> linker[maxn], head[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt, n, m;</span><br><span class="line"><span class="keyword">int</span> R, C;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Edge edge[maxn * maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">memset</span>(col, <span class="number">0</span>, <span class="keyword">sizeof</span>(col));</span><br><span class="line">    <span class="built_in">memset</span>(row, <span class="number">0</span>, <span class="keyword">sizeof</span>(row));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u]; ~i; i=edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!vis[v])</span><br><span class="line">        &#123;</span><br><span class="line">            vis[v] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(linker[v] == <span class="number">-1</span> || dfs(linker[v]))</span><br><span class="line">            &#123;</span><br><span class="line">                linker[v] = u;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hungary</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(linker, <span class="number">-1</span>, <span class="keyword">sizeof</span>(linker));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=R; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">if</span>(dfs(i)) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; R &gt;&gt; C)</span><br><span class="line">    &#123;   </span><br><span class="line">        Init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= R; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> s;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> a;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">                add(i, a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; hungary() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="d-drainage-ditches最小割">D: Drainage Ditches：最小割</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">205</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> fl[maxn][maxn], dis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxn; i++)</span><br><span class="line">        dis[i] = <span class="number">-1</span>;</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.push(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = Q.front(); Q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(fl[k][i]&gt;<span class="number">0</span> &amp;&amp;dis[i]&lt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[i] = dis[k] + <span class="number">1</span>;</span><br><span class="line">                Q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis[m] &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> q, <span class="keyword">int</span> mx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q == m) <span class="keyword">return</span> mx;</span><br><span class="line">    <span class="keyword">int</span> i, a;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fl[q][i]&gt;<span class="number">0</span> &amp;&amp; dis[i] == dis[q] + <span class="number">1</span> &amp;&amp; (a = dfs(i, min(fl[q][i], mx))) )</span><br><span class="line">        &#123;</span><br><span class="line">            fl[i][q] += a;</span><br><span class="line">            fl[q][i] -= a;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(fl, <span class="number">0</span>, <span class="keyword">sizeof</span>(fl));</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v, d;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;d);</span><br><span class="line">            fl[u][v] += d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, tmp;</span><br><span class="line">        <span class="keyword">while</span>(bfs())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(tmp = dfs(<span class="number">1</span>, inf))</span><br><span class="line">                ans += tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="e-dual-core-cpu最小割">E: Dual Core CPU：最小割</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">20005</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2000005</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn], cur[maxn], d[maxn], st[maxm], s, e, no, n; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, flow, nxt; </span><br><span class="line">    point()&#123;&#125;; </span><br><span class="line">    point(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> w):u(x), v(y), nxt(z), flow(w)&#123;&#125;; </span><br><span class="line">&#125; p[maxm]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p[no] = point(x, y, head[x], z);  </span><br><span class="line">    head[x] = no++; </span><br><span class="line">    p[no] = point(y, x, head[y], <span class="number">0</span>);  </span><br><span class="line">    head[y] = no++; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)); </span><br><span class="line">    no = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, x, y;</span><br><span class="line">    <span class="built_in">queue</span> &lt; <span class="keyword">int</span>&gt;q;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span>(d)); </span><br><span class="line">    d[s] = <span class="number">0</span>;  </span><br><span class="line">    q.push(s); </span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.front();     </span><br><span class="line">        q.pop(); </span><br><span class="line">        <span class="keyword">for</span>(i = head[x]; i != <span class="number">-1</span>; i = p[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i].flow &amp;&amp; d[y = p[i].v] &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                d[y] = d[x] + <span class="number">1</span>; </span><br><span class="line">                <span class="keyword">if</span>(y == e)    </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">                q.push(y); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, loc, top, x = s, nowflow, maxflow = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>(bfs())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = s; i &lt;= e; i++)   </span><br><span class="line">            cur[i] = head[i]; </span><br><span class="line">        top = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x == e)</span><br><span class="line">            &#123;</span><br><span class="line">                nowflow = INF; </span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; top; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(nowflow &gt; p[st[i]].flow)</span><br><span class="line">                    &#123;</span><br><span class="line">                        nowflow = p[st[i]].flow; </span><br><span class="line">                        loc = i; </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; top; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    p[st[i]].flow -= nowflow; </span><br><span class="line">                    p[st[i]^<span class="number">1</span>].flow += nowflow; </span><br><span class="line">                &#125;</span><br><span class="line">                maxflow += nowflow; </span><br><span class="line">                top = loc;     </span><br><span class="line">                x = p[st[top]].u; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(i = cur[x]; i != <span class="number">-1</span>; i = p[i].nxt)</span><br><span class="line">                <span class="keyword">if</span>(p[i].flow&amp;&amp;d[p[i].v] == d[x] + <span class="number">1</span>) </span><br><span class="line">                    <span class="keyword">break</span>; </span><br><span class="line">            cur[x] = i; </span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                st[top++] = i; </span><br><span class="line">                x = p[i].v; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!top)    </span><br><span class="line">                    <span class="keyword">break</span>; </span><br><span class="line">                d[x] = <span class="number">-1</span>; </span><br><span class="line">                x = p[st[--top]].u; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxflow; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, M;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;M) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        init(); </span><br><span class="line">        s = <span class="number">0</span>; </span><br><span class="line">        e = N + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ai, bi; </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;ai, &amp;bi); </span><br><span class="line">            add(s, i, ai); </span><br><span class="line">            add(i, e, bi); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(M--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b, c; </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c); </span><br><span class="line">            add(a, b, c); </span><br><span class="line">            add(b, a, c); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dinic()); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="f-pigs最大流">F: PIGS：最大流</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxp = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n, T, cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> h[maxn], q[maxn], last[maxn], cur[maxn];</span><br><span class="line"><span class="keyword">int</span> pig[maxp];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[maxn];</span><br><span class="line"><span class="keyword">int</span> L[maxp];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt, v, to;</span><br><span class="line">&#125; e[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt].to = v;</span><br><span class="line">    e[cnt].nxt = last[u];</span><br><span class="line">    last[u] = cnt;</span><br><span class="line">    e[cnt].v = w;</span><br><span class="line">    e[++cnt].to = u;</span><br><span class="line">    e[cnt].nxt = last[v];</span><br><span class="line">    last[v] = cnt;</span><br><span class="line">    e[cnt].v = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>, tail = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    q[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    h[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q[head];</span><br><span class="line">        head++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = last[now]; i; i = e[i].nxt)</span><br><span class="line">            <span class="keyword">if</span> (e[i].v &amp;&amp; h[e[i].to] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                h[e[i].to] = h[now] + <span class="number">1</span>;</span><br><span class="line">                q[tail++] = e[i].to;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h[T] != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == T)</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    <span class="keyword">int</span> w, used = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> (h[e[i].to] == h[x] + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            w = dfs(e[i].to, min(f - used, e[i].v));</span><br><span class="line">            e[i].v -= w;</span><br><span class="line">            e[i ^ <span class="number">1</span>].v += w;</span><br><span class="line">            <span class="keyword">if</span> (e[i].v)</span><br><span class="line">                cur[x] = i;</span><br><span class="line">            used += w;</span><br><span class="line">            <span class="keyword">if</span> (used == f)</span><br><span class="line">                <span class="keyword">return</span> f;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (!used)</span><br><span class="line">        h[x] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (bfs())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= T; i++)</span><br><span class="line">            cur[i] = last[i];</span><br><span class="line">        tmp += dfs(<span class="number">0</span>, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    T = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; pig[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        <span class="keyword">while</span> (x--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> y;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; y;</span><br><span class="line">            a[i].push_back(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> z;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; z;</span><br><span class="line">        addedge(i, T, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i].size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = a[i][j];</span><br><span class="line">            <span class="keyword">if</span> (!L[v])</span><br><span class="line">            &#123;</span><br><span class="line">                L[v] = i;</span><br><span class="line">                addedge(<span class="number">0</span>, i, pig[v]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                addedge(L[v], i, inf);</span><br><span class="line">                L[v] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dinic());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 计算机 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 北大 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>群表示论龟速学习</title>
      <link href="/2019/10/06/%E7%BE%A4%E8%A1%A8%E7%A4%BA%E8%AE%BA%E9%BE%9F%E9%80%9F%E5%AD%A6%E4%B9%A0/"/>
      <content type="html"><![CDATA[<p>感觉自己远离抽象代数太久了…很僵硬…<br>内容主要是 GTM 42：Serre 所著的《Linear Representations of Finite Groups》. 也参考了一些丘维声先生的《群表示论》.</p><a id="more"></a><h2 id="第一章-线性表示概论">第一章 线性表示概论</h2><blockquote><p><strong>Def.</strong> 同态 <span class="math inline">\(\rho: G\to GL(V)\)</span> 称为 <span class="math inline">\(G\)</span> 在 <span class="math inline">\(V\)</span> 内的一个<strong>线性表示</strong>.</p><p>等价定义：</p><ul><li>空间 <span class="math inline">\(V\)</span> 是群代数 <span class="math inline">\(K[G]\)</span> 的左模（左-<span class="math inline">\(K[G]\)</span> 模）.</li></ul></blockquote><ul><li>顾名思义，就是用一个 <span class="math inline">\(GL(V)\)</span> 中的矩阵来表示 <span class="math inline">\(G\)</span> 中的一个元素，而且 <span class="math inline">\(GL(V)\)</span> 中的运算也完全能刻画 <span class="math inline">\(G\)</span> 中的运算.</li><li>例子：degree 为 <span class="math inline">\(1\)</span> 的表示，正则表示，置换表示…</li></ul><center>我们只考虑 <span class="math inline">\(V\)</span> 是有限维的情形.</center><center>我们一般设 <span class="math inline">\(V\)</span> 是 <span class="math inline">\(\mathbb{C}\)</span> 上的空间.</center><blockquote><p><strong>表示与群代数的模</strong>：<span class="math inline">\(G\)</span> 的表示 <span class="math inline">\((\varphi,V)\)</span> <span class="math inline">\(\overset{\varphi^*(\sum a_g g)=\sum a_g\varphi(g)}{\Longleftrightarrow}\)</span> <span class="math inline">\(K[G]\)</span> 的表示 <span class="math inline">\((\varphi^*,V)\)</span> <span class="math inline">\(\Longleftrightarrow\)</span> <span class="math inline">\(V\)</span> 是左 <span class="math inline">\(K[G]\)</span>-模.</p></blockquote><blockquote><p><strong>范畴上的表示</strong> 更一般地，设 <span class="math inline">\(\mathscr{U}\)</span> 是一个范畴，取 <span class="math inline">\(\forall A\in \mathscr{U}\)</span>，则同态 <span class="math inline">\(\rho: G\to Aut(A)\)</span> 是一个 <span class="math inline">\(G\)</span> 的表示.</p></blockquote><blockquote><p><strong>表示的同态</strong>：设有表示 <span class="math inline">\((\rho, V)\)</span> 和 <span class="math inline">\((\rho&#39;, W)\)</span>，若同态 <span class="math inline">\(f: V\to W\)</span> 满足 <span class="math inline">\(\rho_s\circ f = f\circ \rho_s&#39;\)</span>（即图表 <span class="math inline">\(\begin{matrix} V &amp; \overset{\rho_s}{\longrightarrow} &amp; V \\ f \downarrow &amp; &amp; \downarrow f \\ W &amp; \overset{\rho_s&#39;}{\longrightarrow} &amp; W \\ \end{matrix}\)</span>交换），则称 <span class="math inline">\(f\)</span> 为二者之间的同态. 若 <span class="math inline">\(f\)</span> 为 <span class="math inline">\(V\to W\)</span> 的同构，则 <span class="math inline">\(f\)</span> 也是表示之间的同构.</p></blockquote><blockquote><p><strong>子表示</strong>：若 <span class="math inline">\(W\leqslant V\)</span> 的子空间且在 <span class="math inline">\(G\)</span> 下不变，则 <span class="math inline">\(\rho\)</span> 在 <span class="math inline">\(W\)</span> 上的限制被 <span class="math inline">\(\rho |_W\)</span> 称为子表示. 当然，子表示 <span class="math inline">\(\iff\)</span> 子模.</p></blockquote><blockquote><p><strong>表示的运算</strong></p><ul><li><strong>直和</strong>：<span class="math inline">\(V\oplus W\)</span>，基本上是空间做直和；</li><li><strong>张量积</strong>：<span class="math inline">\(V\otimes W\)</span>，基本上是空间做张量积。<ul><li>有自然同构：<span class="math inline">\(End(W)\otimes End(V)\cong End(W\otimes V)\)</span>.</li></ul></li></ul></blockquote><blockquote><p><strong>对偶表示</strong>：<span class="math inline">\(\langle \rho_s x,\rho_s&#39;x&#39;\rangle = \langle x,x&#39;\rangle\)</span></p></blockquote><blockquote><p><strong>Maschke 定理</strong> 每个表示都是不可约表示的直和. （每个表示都是半单代数）</p></blockquote><blockquote><p><strong><span class="math inline">\(Sym^2\)</span> 和 <span class="math inline">\(Alt^2\)</span></strong>：令 <span class="math inline">\(\theta\)</span> 是 <span class="math inline">\(V\otimes V\)</span> 的自同构，s.t. <span class="math inline">\(\theta(e_i\cdot e_j)=e_j\cdot e_i\)</span>. 定义</p><ul><li><span class="math inline">\(Sym^2(V)=\{z: \theta(z)=z\}=\{e_i\otimes e_j + e_j\otimes e_i\}\)</span>，<span class="math inline">\(\dim = \frac{n(n+1)}{2}\)</span>;</li><li><span class="math inline">\(Alt^2(V)=\{z: \theta(z)=-z\}=\{e_i\otimes e_j - e_j\otimes e_i\}\)</span>，<span class="math inline">\(\dim = \frac{n(n-1)}{2}\)</span>.</li></ul><p>显然有 <span class="math inline">\(Alt^2\cap Sym^2=\{0\}\)</span>，因此结合维数，我们有 <span class="math inline">\(V\otimes V=Sym^2(V)\oplus Alt^2(V)\)</span>.</p></blockquote><h2 id="第二章-特征标理论">第二章 特征标理论</h2><blockquote><p><strong>Def.</strong> 设有表示 <span class="math inline">\(\rho: G\to GL(V),~s\mapsto \rho_s\)</span>，令 <span class="math inline">\(\chi_\rho: G\to \mathbb{C},~s\mapsto tr(\rho_s)\)</span>，称为 <span class="math inline">\(\rho\)</span> 的特征标.</p></blockquote><ul><li><span class="math inline">\(\chi_\rho(1)=tr(\rho(1))=\dim(V)=degree(\rho)\)</span>;</li><li><span class="math inline">\(\chi_\rho(s^{-1})=\lambda_1^*+\cdots+\lambda_n^*=(\lambda_1+\cdots+\lambda_n)^*=\chi_\rho^*(s)\)</span>;</li><li><span class="math inline">\(\forall s,t\)</span>，总有 <span class="math inline">\(\chi(st)=\chi(ts)\)</span>（trace 的交换性）.</li></ul><blockquote><p><strong>类函数</strong>：在共轭类上取值相等的函数. （特征标就是一种类函数）</p></blockquote><ul><li>类函数全体构成线性空间，维数即为共轭类的数量.</li></ul><p>特征标的运算性质：</p><ul><li>直和：<span class="math inline">\(\chi_{\rho_1\oplus \rho_2}=\chi_{\rho_1}+\chi_{\rho_2}\)</span>.</li><li>张量积：<span class="math inline">\(\chi_{\rho_1\otimes \rho_2}=\chi_{\rho_1}\times \chi_{\rho_2}\)</span>.</li><li>Sym 与 Alt：<span class="math inline">\(\chi_{Sym^2}=\frac{1}{2}\chi_\rho^2+\frac{1}{2}\chi_{\rho^2}\)</span>，<span class="math inline">\(\chi_{Alt^2}=\frac{1}{2}\chi_\rho^2-\frac{1}{2}\chi_{\rho^2}\)</span>.</li></ul><blockquote><p><strong>Schur 引理</strong> 不可约表示间的非平凡同态是同构.</p></blockquote><blockquote><p><strong>特征标的内积</strong>：<span class="math inline">\(\langle \varphi, \psi\rangle=\frac{1}{|G|}\sum\limits_{s\in G} \varphi(s)\psi(s)^*\)</span>.</p></blockquote><center>懒，不想细改，有时内积写作 <span class="math inline">\(\langle\cdot, \cdot\rangle\)</span>，有时写作 <span class="math inline">\((\cdot|\cdot)\)</span>… 应不致混淆吧…</center><blockquote><p><strong>特征标的正交</strong>：</p><ul><li>对于不可约指标，<span class="math inline">\(\langle \chi,\chi \rangle = 1\)</span>;</li><li>对不同构的不可约表示 <span class="math inline">\(\rho_1,\rho_2\)</span>，设其特征标为 <span class="math inline">\(\chi_1,\chi_2\)</span>，则 <span class="math inline">\(\langle \chi_1,\chi_2 \rangle = 0\)</span>.</li></ul></blockquote><blockquote><p><strong>不可约分解的重数</strong>：设 <span class="math inline">\(\rho: G\to GL(V)\)</span> 的特征标为 <span class="math inline">\(\varphi\)</span>，且有不可约分解 <span class="math inline">\(V=\bigoplus\limits_{i=1}^k W_i\)</span>，则其中与 <span class="math inline">\(W\)</span>（特征标设为 <span class="math inline">\(\chi\)</span>）同构的个数为 <span class="math inline">\(\langle \varphi,\chi \rangle\)</span>.</p></blockquote><ul><li>由此立刻可得：两个表示同构当且仅当具有相同的特征标.</li></ul><blockquote><p><strong>正则表示的特征标</strong>：<span class="math inline">\(r_G(s)=\begin{cases} |G|~ &amp; s = 1 \\ 0~ &amp; s\neq 1 \end{cases}\Rightarrow 不可约表示 ~W_i~ 在正则表示中的重数为其~degree~ \chi_i(1)\)</span>.</p></blockquote><ul><li>立即得到：<span class="math inline">\(r_G(s)=\sum \chi_i(1)\chi_i(s)\)</span>，于是有：<ul><li><span class="math inline">\(\sum\limits \chi_i^2(1)=|G|\)</span>;</li><li>若 <span class="math inline">\(s\neq 1\)</span>，则 <span class="math inline">\(\sum \chi_i(1)\chi_i(s)=0\)</span>.</li></ul></li></ul><h3 id="不可约表示的个数">不可约表示的个数</h3><blockquote><p><strong>Prop.</strong> <span class="math inline">\(f\)</span> 是类函数，<span class="math inline">\((\rho, V)\)</span> 是 <span class="math inline">\(G\)</span> 的一个线性表示，特征标为 <span class="math inline">\(\chi\)</span>. 若 <span class="math inline">\(V\)</span> 是不可约表示，则 <span class="math inline">\(\rho_f = \sum\limits_{t\in G}f(t)\rho_t\)</span> 是一个常数变换： <span class="math display">\[\lambda = \frac{1}{\chi(1)}\sum\limits_{t\in G} f(t)\chi(t)=\frac{|G|}{\chi(1)}\langle f, \chi^*\rangle.\]</span></p><p><strong>简略证明</strong> 计算 <span class="math inline">\(\rho_s^{-1}\rho_f\rho_s\)</span> 可知其与 <span class="math inline">\(\rho_f\)</span> 相等，即 <span class="math inline">\(\rho_f\)</span> 是 <span class="math inline">\(V\)</span> 的自同态，因而为同构. 然后计算 <span class="math inline">\(tr(\rho_f)\)</span> 即可求得系数.</p></blockquote><center>记 <span class="math inline">\(G\)</span> 上所有类函数构成的空间为 <span class="math inline">\(H\)</span>，则不可约特征标 <span class="math inline">\(\chi_1,\ldots,\chi_h\in H\)</span>.</center><blockquote><p><strong>Thm.</strong> 不可约特征标 <span class="math inline">\(\chi_1,\ldots,\chi_h\)</span> 构成 <span class="math inline">\(H\)</span> 的一组规范正交基. （只需证明每个与 <span class="math inline">\(\chi_i^*\)</span> 正交的元素都是 <span class="math inline">\(0\)</span>）</p></blockquote><ul><li>进一步容易得到如下定理：</li></ul><blockquote><p><strong>Thm.</strong> <span class="math inline">\(G\)</span> 的不可约表示个数等于 <span class="math inline">\(G\)</span> 的共轭类个数. <span class="math inline">\(s\)</span> 的共轭类元素个数 <span class="math inline">\(c(s)\)</span>.</p></blockquote><p>还有如下推论：</p><ul><li><span class="math inline">\(\sum\limits_{i=1}^h \chi_i(s)^*\chi_i(s)=\frac{|G|}{c(s)}\)</span>.</li><li>若 <span class="math inline">\(t\)</span> 与 <span class="math inline">\(s\)</span> 不共轭，则 <span class="math inline">\(\sum\limits_{i=1}^h \chi_i(s)^*\chi_i(t)=0\)</span>.</li></ul><blockquote><p><strong>典范分解</strong>：将不可约分解中同构的项合并所得到的分解 <span class="math inline">\(V=\bigoplus\limits_{i=1}^h V_i\)</span>. <strong>典范分解是唯一的.</strong> 该分解可以由如下投影确定： <span class="math display">\[p_{i}=\frac{\chi_{i}(1)}{|G|} \sum_{t \in G} \chi_{i}(t)^{*} \rho_{t}.\]</span></p><p><strong>简略说明</strong>：由上面的 Prop 可知，<span class="math inline">\(p_i\)</span> 在某个不可约表示 <span class="math inline">\(W\)</span> 上的限制是常数 <span class="math inline">\(\frac{\chi_i(1)}{\chi_W(1)}\langle \chi_i,\chi_W \rangle\)</span>，这个常数在 <span class="math inline">\(\chi_W=\chi_i\)</span> 时是 <span class="math inline">\(1\)</span>，否则是 <span class="math inline">\(0\)</span>，因此 <span class="math inline">\(p_i\)</span> 就是 <span class="math inline">\(V\to V_i\)</span> 的射影.</p></blockquote><blockquote><p><strong>显分解</strong>：将典范分解的组分 <span class="math inline">\(V_i\)</span> 分解为若干 <span class="math inline">\(W_i\)</span> 的直和. <font color="red">这里没有完全搞懂…</font></p></blockquote><h2 id="第三章-子群群的直积诱导表示">第三章 子群、群的直积、诱导表示</h2><blockquote><p><strong>Abel 群的表示</strong>：<span class="math inline">\(G\)</span> 是 Abel 群当且仅当其所有不可约表示的 degree 都为 <span class="math inline">\(1\)</span>.</p></blockquote><blockquote><p><strong>群的直积</strong>：<span class="math inline">\(G_1\times G_2\)</span> 中的乘法为 <span class="math inline">\((s_1,s_2)(t_1,t_2)=(s_1t_1,s_2t_2)\)</span>.</p><ul><li>直积的表示：张量积 —— <span class="math inline">\((\rho_1\otimes \rho_2)(s_1,s_2)=\rho_1(s_1)\otimes \rho_2(s_2)\)</span>. 这是一个 <span class="math inline">\(G_1\times G_2\to GL(V_1\otimes V_2)\)</span> 的同态.</li></ul></blockquote><blockquote><p><strong>不可约性在乘积上的传递</strong>：</p><ol type="1"><li>若 <span class="math inline">\(\rho_i\)</span> 是 <span class="math inline">\(G_i\)</span> 的不可约表示，则 <span class="math inline">\(\rho_1\otimes \rho_2\)</span> 是 <span class="math inline">\(G_1\times G_2\)</span> 的不可约表示；</li><li>进一步，<span class="math inline">\(G_1\times G_2\)</span> 的所有不可约表示都来自上述渠道.</li></ol></blockquote><h3 id="诱导表示">诱导表示</h3><ul><li>给出 <span class="math inline">\(G\)</span> 的一个表示 <span class="math inline">\(\rho: G\to GL(V)\)</span>，将其限制在 <span class="math inline">\(G\)</span> 的子群 <span class="math inline">\(H\)</span> 上，可得到一个 <span class="math inline">\(H\)</span> 在 <span class="math inline">\(V\)</span> 上的表示 <span class="math inline">\(\rho |_H\)</span>.</li><li>考虑 <span class="math inline">\(W\leqslant V\)</span>，且在 <span class="math inline">\(\rho_t,~t\in H\)</span> 下稳定，则有 <span class="math inline">\(\rho|_H\)</span> 的子表示 <span class="math inline">\(\theta: H\to GL(W)\)</span>.</li></ul><p>故 <span class="math inline">\(\forall s\in G\)</span>，<span class="math inline">\(\rho_s W\)</span> 只取决于 <span class="math inline">\(s\)</span> 所在的 <span class="math inline">\(H\)</span> 的左陪集 <span class="math inline">\(sH\)</span>.<span class="math inline">\(\Longrightarrow\)</span> 所有 <span class="math inline">\(\sigma\in G/H\)</span> 都对应一个 <span class="math inline">\(V\)</span> 的子空间 <span class="math inline">\(W_\sigma=\rho_s W\)</span>，其中 <span class="math inline">\(s\in \sigma\)</span>.</p><p>这样，我们就可以定义 <span class="math inline">\(V\)</span> 的子表示 <span class="math inline">\(\sum\limits_{\sigma\in G/H} W_\sigma\)</span>.</p><p>进一步，有下面的定义</p><blockquote><p><strong>诱导表示</strong>：若 <span class="math inline">\(V=\bigoplus\limits_{\sigma\in G/H} W_\sigma\)</span> 则称 <span class="math inline">\((\rho, V)\)</span> 是由 <span class="math inline">\((W,\theta)\)</span> 诱导的.</p></blockquote><ul><li>若 <span class="math inline">\(R\)</span> 是 <span class="math inline">\(G/H\)</span> 的一个代表系，则 <span class="math inline">\(V=\bigoplus\limits_{r\in R}\rho_rW\)</span>，故 <span class="math inline">\(\dim(V)=\sum\limits_{r\in R}\dim(\rho_rW)=[G:H]\dim(W)\)</span>.</li><li>例：<span class="math inline">\(V\)</span> 是 <span class="math inline">\(G\)</span> 的正则表示，则其由 <span class="math inline">\(H\leqslant G\)</span> 在 <span class="math inline">\(W\leqslant V\)</span> 内的正则表示诱导.</li><li>若 <span class="math inline">\(\rho_i\)</span> 是由 <span class="math inline">\(\theta_i\)</span> 诱导的（<span class="math inline">\(i=1,2\)</span>）， 则 <span class="math inline">\(\rho_1\oplus \rho_2\)</span> 可由 <span class="math inline">\(\theta_1\oplus\theta_2\)</span> 诱导.</li><li>若 <span class="math inline">\(\rho\)</span> 由 <span class="math inline">\(\theta\)</span> 诱导，则 <span class="math inline">\(\rho\otimes\rho&#39;\)</span> 可由 <span class="math inline">\(\theta\otimes \rho&#39;|_H\)</span> 诱导.</li></ul><h4 id="存在性和唯一性">存在性和唯一性</h4><blockquote><p><strong>Thm.</strong> 设 <span class="math inline">\((W,\theta)\)</span> 是 <span class="math inline">\(H\leqslant G\)</span> 的一个表示，则<strong>存在</strong> <span class="math inline">\(G\)</span> 的表示 <span class="math inline">\((V,\rho)\)</span>，s.t. <span class="math inline">\(\rho\)</span> 是由 <span class="math inline">\(\theta\)</span> 诱导的. 进一步，这个 <span class="math inline">\(\rho\)</span> 在同构意义下<strong>唯一</strong>.</p></blockquote><h4 id="诱导表示的特征标">诱导表示的特征标</h4><blockquote><p><strong>诱导表示的特征标</strong> 设 <span class="math inline">\(R\)</span> 是 <span class="math inline">\(G/H\)</span> 的一个代表系，则 <span class="math display">\[\chi_\rho(u)=\sum\limits_{r\in R\atop r^{-1}ur\in H}\chi_\theta(r^{-1}ur)=\frac{1}{|H|} \sum_{s \in G \atop s^{-1} u s \in H} \chi_{\theta}\left(s^{-1} u s\right).\]</span></p></blockquote><h2 id="第六章-群代数">第六章 群代数</h2><blockquote><p><strong>Prop.</strong> 如果 <span class="math inline">\(ch K=0\)</span>，则 <span class="math inline">\(K[G]\)</span> 是半单代数.</p></blockquote><blockquote><p><strong>一个练习</strong> 设 <span class="math inline">\(ch K&gt;0\)</span>，则 <span class="math inline">\(K[G]\)</span> 半单 <span class="math inline">\(\iff\)</span> <span class="math inline">\(p \nmid |G|\)</span>.</p></blockquote><center><font color="red">后面我们基本认为 <span class="math inline">\(K=\mathbb{C}\)</span>.</font></center><blockquote><p><strong><span class="math inline">\(\mathbb{C}[G]\)</span> 的分解</strong> 令 <span class="math inline">\(\rho_i: G\to GL(W_i), 1\leqslant i\leqslant h\)</span> 是 <span class="math inline">\(G\)</span> 同构意义下所有的不可约表示，记 <span class="math inline">\(n_i=\dim (W_i)\)</span>，则可将 <span class="math inline">\(\rho_i\)</span> 扩展为代数同态： <span class="math display">\[\tilde{\rho}: \mathbf{C}[G] \rightarrow \prod_{i=1}^{h} \operatorname{End}\left(W_{i}\right) \cong \prod_{i=1}^{h} M_{n_{i}}(\mathbf{C}).\]</span> <strong>事实上，<span class="math inline">\(\tilde{\rho}\)</span> 是一个同构</strong>. 考虑它的中心： <span class="math display">\[Z(\mathbb{C}[G])\cong Z(M_{n_1}(\mathbb{C})\oplus\cdots\oplus M_{n_h}(\mathbb{C})) \cong \mathbb{C}\oplus\cdots\oplus\mathbb{C}.\]</span> 即：<span class="math inline">\(Z(\mathbb{C}[G])\cong CF(G)\)</span>.</p></blockquote><blockquote><p><strong>代数整数</strong> <span class="math inline">\(\mathbb{C}\)</span> 上整系数多项式的根.<br>下列命题等价：</p><ol type="1"><li><span class="math inline">\(x\)</span> 在 <span class="math inline">\(\mathbb{Z}\)</span> 上是整的；</li><li><span class="math inline">\(R\)</span> 中由 <span class="math inline">\(x\)</span> 生成的子环 <span class="math inline">\(\mathbb{Z}[x]\)</span> 作为一个 <span class="math inline">\(\mathbb{Z}\)</span>-模是有限生成的；</li><li>存在一个 <span class="math inline">\(R\)</span> 的有限生成 <span class="math inline">\(\mathbb{Z}\)</span>-模，它包含 <span class="math inline">\(\mathbb{Z}[x]\)</span>.</li></ol></blockquote><blockquote><p><strong>特征标与代数整数</strong> 有限群表示的特征标是代数整数.<br><strong>Prop.</strong> 令 <span class="math inline">\(u=\sum u(s)s\in Z(\mathbb{C}[G])\)</span>，且 <span class="math inline">\(u(s)\)</span> 都是代数整数，则 <span class="math inline">\(u\)</span> 在 <span class="math inline">\(\mathbb{Z}\)</span> 上也是整的.<br><strong>Prop.</strong> 设 <span class="math inline">\(C\)</span> 是 <span class="math inline">\(G\)</span> 的中心，则 <span class="math inline">\(G\)</span> 的不可约表示维数整除 <span class="math inline">\([G:C]\)</span>.</p></blockquote><h2 id="第七章-诱导表示与-mackey-分解">第七章 诱导表示与 Mackey 分解</h2><ul><li><span class="math inline">\(H\)</span> 是 <span class="math inline">\(G\)</span> 的子群，<span class="math inline">\(R\)</span> 是 <span class="math inline">\(H\)</span> 的左陪集代表系.</li><li><span class="math inline">\(V\)</span> 是一个 <span class="math inline">\(\mathbb{C}[G]\)</span>-模，<span class="math inline">\(W\)</span> 是 <span class="math inline">\(V\)</span> 的一个子模.</li></ul><p>诱导表示的定义是 <span class="math inline">\(V=\bigoplus\limits_{s\in R} sW\)</span>，这实际上是在说 <span class="math inline">\(V\)</span> 这个表示是不依赖于代表系 <span class="math inline">\(R\)</span> 选取的. 一个等价的表述是：<br>令 <span class="math inline">\(W&#39;=\mathbb{C}[G]\otimes_{\mathbb{C}[H]} W\)</span> 是由 <span class="math inline">\(W\)</span> 通过 <span class="math inline">\(\mathbb{C}[H]\)</span> 到 <span class="math inline">\(\mathbb{C}[G]\)</span> 的标量扩张而得到的 <span class="math inline">\(\mathbb{C}[G]\)</span>-模，则单射 <span class="math inline">\(W\to V\)</span> 可以线性地开拓为一个 <span class="math inline">\(\mathbb{C}[G]\)</span>-同态 <span class="math inline">\(W&#39;\to V\)</span>. 进一步，有</p><blockquote><p><strong>Prop.</strong> <span class="math inline">\(V\)</span> 是由 <span class="math inline">\(W\)</span> 所诱导的，当且仅当同态 <span class="math inline">\(i:\mathbb{C}[G]\otimes_{\mathbb{C}[H]}W\to V\)</span> 是一个同构.</p></blockquote><ul><li>以下将 <span class="math inline">\(W\)</span> 所诱导的 <span class="math inline">\(G\)</span> 的表示记作 <span class="math inline">\({\rm Ind}_H^G (W)\)</span> 或者 <span class="math inline">\({\rm Ind}(W)\)</span>. （其实感觉 <span class="math inline">\(W^G\)</span> 更好…</li></ul><h3 id="诱导特征标">诱导特征标</h3><p>下面这个特征标叫做诱导特征标，即 <span class="math inline">\(\operatorname{Ind}_H^G (W)\)</span> 的特征标： <span class="math display">\[\mu^G(g)=\sum\limits_{i=1}^t \hat{\mu}(g_i^{-1}gg_i),~~~~其中~\hat{\mu}(x)=\begin{cases}    \mu(x),&amp; y\in H\\    0, &amp; y\notin H\end{cases}.\]</span></p><p>关于诱导特征标，有如下定理成立：</p><blockquote><p><strong>Frobenius 互反律</strong> 设 <span class="math inline">\(G\)</span> 是有限群，<span class="math inline">\(H&lt;G\)</span>. 设 <span class="math inline">\(\mu\)</span> 是 <span class="math inline">\(H\)</span> 的复特征标，<span class="math inline">\(\chi\)</span> 是 <span class="math inline">\(G\)</span> 的复特征标，则 <span class="math display">\[\langle\mu^G ,\chi\rangle_G=\langle\mu,\chi|H\rangle_H\]</span></p><ul><li>换言之：设 <span class="math inline">\(\psi\)</span> 是 <span class="math inline">\(H\)</span> 的不可约复表示，<span class="math inline">\(\varphi\)</span> 是 <span class="math inline">\(G\)</span> 的不可约复表示，则 <span class="math inline">\(\varphi\)</span> 在 <span class="math inline">\(\psi^G\)</span> 中的重数等于 <span class="math inline">\(\psi\)</span> 在 <span class="math inline">\(\varphi|H\)</span> 中的重数.</li></ul></blockquote><h2 id="部分习题简略解答">部分习题简略解答</h2><p>以下是一些习题的解答…其中包括了几个wlz老师课上留的思考题</p><script src="/js/pdfobject.js"></script><style>    /* Only resize the element if PDF is embedded */    .pdfobject-container {        width: 800px;        height: 900px;    }</style><center><div id="my-container"></div></center><script>    PDFObject.embed("/pdf/Solution_to_Serre_gtm42.pdf", "#my-container");</script>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 北大 </tag>
            
            <tag> 抽象代数 </tag>
            
            <tag> 表示论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论文笔记[8]——Allocating Indivisible Items in Categorized Domains</title>
      <link href="/2019/09/21/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-8-%E2%80%94%E2%80%94Allocating-Indivisible-Items-in-Categorized-Domains/"/>
      <content type="html"><![CDATA[<blockquote><p>文章：Allocating Indivisible Items in Categorized Domains</p></blockquote><a id="more"></a><ul><li><strong>CDAP</strong> (categorized domain allocation problem)：多个类别的不可分物品被分配给若干 agent，每个 agent 在每一类中至少获得一个物品。<ul><li>本文讨论的是常见的情形：一个 agent 只获取每一类的一个物品</li></ul></li><li><strong>CSAM</strong> (categorial sequential allocation mechanism)：serial dictatorship 的推广，将分配拆分成多个轮次，每轮每个候选人从指定类别中选取一个 bundle。<ul><li>Serial dictatorship 的刻画：三个公理化特征<ul><li>Strategyproofness;</li><li>Non-bossiness;</li><li>Category-wise neutrality.</li></ul></li></ul></li></ul><p>分配问题的相关研究所面临的三大障碍：</p><ul><li><strong>偏好瓶颈</strong>（Preference bottleneck）：当物品个数较多时，bundle 的偏好情况将以指数级别增长；</li><li><strong>计算瓶颈</strong>（Computational bottleneck）：即便能够使用某种偏好语言简洁地表达他们的偏好，计算“最优”分配通常也是困难的；</li><li><strong>Agent 的策略</strong>（Threats of agents’ strategic behavior）：agent 可能谎报偏好，以获得更好的 bundle。这可能导致社会效率低下的分配。</li></ul><h2 id="主要工作">主要工作</h2><ol type="1"><li>关于 Basic CDAP：每个类别中的物品数量都等于 agent 数量。<ul><li>首先用三条公理化特征来描述 serial dictatorship：<ul><li><strong>Strategyproofness</strong>：不能通过谎报偏好来获取更大好处；</li><li><strong>Non-bossiness</strong>：不能在不改变自己偏好的情况下改变其他 agent 的分配；</li><li><strong>Category-wise neutrality</strong>：类别标记不改变分配结果；</li></ul></li><li>上述三条特征可以帮我们克服“Agent 的策略”带来的影响。</li></ul></li><li>为克服偏好和计算瓶颈，并且防止 serial dictatorship，定义 CSAM<ul><li>CSAM 是一类间接机制，前文描述过其过程。</li></ul></li><li>两种 myopic agent 下 CSAM 最坏情况下的效率：<ul><li><strong>Optimistic agent</strong>：总是选择当前可选的最优 bundle 中的物品；</li><li><strong>Pessimistic agent</strong>：总是选择最坏情形下的最优项目。</li></ul></li></ol><h2 id="categorized-domain-allocation-problems">Categorized Domain Allocation Problems</h2><blockquote><p><strong>Def 1.</strong> 一个 categorized domain 由 <span class="math inline">\(p\geqslant 1\)</span> 个不可分的物品类构成，用 <span class="math inline">\(\{D_1,\ldots,D_p\}\)</span>。在一个 <strong>CDAP</strong> 中，物品被分配给 <span class="math inline">\(n\)</span> 个 agent，每个 agent 至少获取每类中的一个物品。</p><ul><li>对于一个 basic categorized domain，<span class="math inline">\(\forall i\)</span>，<span class="math inline">\(|D_i|=n\)</span>，<span class="math inline">\(\mathfrak{D}=D_1\times\cdots\times D_p\)</span>，agent 的偏好为 <span class="math inline">\(\mathfrak{D}\)</span> 上的一个序。</li><li>在 basic CDAP 中，每个 agent 在每一类中恰好得到一个物品。</li></ul></blockquote><ul><li>我们研究的主要对象是 non-sharable items，即每个物品只能分配给一个 agent；</li><li><span class="math inline">\(\mathfrak{D}\)</span> 中的元素被称为一个 bundle；</li><li>对 <span class="math inline">\(\forall j\in \{1,2,\ldots,n\}\)</span>，令 <span class="math inline">\(R_j\)</span> 表示一个 <span class="math inline">\(\mathfrak{D}\)</span> 上的序；<ul><li>用 <span class="math inline">\(P=(R_1,\ldots,R_n)\)</span> 表示所有 agent 的偏好构成的 profile.</li></ul></li><li>分配 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(\{1,2,\ldots,n\}\to \mathfrak{D}\)</span> 的一个映射，s.t. <span class="math display">\[\bigcup\limits_{j=1}^nA(j)_i=D_i\]</span></li><li>一个分配机制是一个函数，输入为 profile，输出为一个分配<ul><li>用 <span class="math inline">\(f^j(P)\)</span> 表示机制 <span class="math inline">\(f\)</span> 在 profile <span class="math inline">\(P\)</span> 下分配给 agent <span class="math inline">\(j\)</span> 的 bundle.</li></ul></li></ul><h3 id="三条公理化性质">三条公理化性质</h3><h4 id="strategyproofness">Strategyproofness</h4><blockquote><p>对于 <span class="math inline">\(\forall\)</span> profile <span class="math inline">\(P\)</span>，<span class="math inline">\(\forall\)</span> agent <span class="math inline">\(j\)</span>，以及 <span class="math inline">\(\mathfrak{D}\)</span> 上的序 <span class="math inline">\(R_j&#39;\)</span>，都有： <span class="math display">\[f^j(P)\succ_{R_j} f^j(R_j&#39;,R_{-j}).\]</span></p></blockquote><h4 id="non-bossiness">Non-bossiness</h4><ul><li><span class="math inline">\(f\)</span> 满足 non-bossiness 当且仅当 agent 中不存在黑社会；<ul><li>黑社会：通过谎报自己的偏好来改变他人的分配结果，但不改变自己的分配结果。</li></ul></li></ul><blockquote><p>对于 <span class="math inline">\(\forall\)</span> profile <span class="math inline">\(P\)</span>，<span class="math inline">\(\forall\)</span> agent <span class="math inline">\(j\)</span>，以及 <span class="math inline">\(\mathfrak{D}\)</span> 上的序 <span class="math inline">\(R_j&#39;\)</span>，都有： <span class="math display">\[[f^j(P)=f^j(R_j&#39;,R_{-j})]\Rightarrow [f(P)=f(R_j&#39;,R_{-j})].\]</span></p></blockquote><h4 id="category-wise-neutrality">Category-wise neutrality</h4><blockquote><p>对 <span class="math inline">\(\forall P\)</span>，<span class="math inline">\(\forall i\)</span>，取置换 <span class="math inline">\(\sigma\in S_n\)</span>，将其作用在 <span class="math inline">\(D_i\)</span> 上不改变分配结果，即总有： <span class="math display">\[f(\sigma(P))=\sigma(f(P)).\]</span></p></blockquote><hr><p><strong>Serial dictatorship</strong> 由一个 <span class="math inline">\(\{1,2,\ldots,n\}\)</span> 上的序 <span class="math inline">\(\mathcal{K}\)</span> 来表达，所有 agent 按照 <span class="math inline">\(\mathcal{K}\)</span> 所规定的顺序选取物品，每次都选择当前所能选取的物品中，他所认为优先级最高的物品。</p><hr><h2 id="serial-dictatorship-的公理化特征">Serial dictatorship 的公理化特征</h2><blockquote><p><strong>Th 1.</strong> 对于任意满足 <span class="math inline">\(p\geqslant 2\)</span>，<span class="math inline">\(n\geqslant 2\)</span> 的 basic CDAP，一个分配机制是 strategyproof, non-bossy, 且 category-wise neutral 的，<strong>当且仅当</strong>它是 serial dictatorship. 进一步，这三条公理是刻画 serial dictatorship 的最低要求。</p></blockquote><hr><ul><li>以下引理表明，对于任何 strategyproof 且 non-bossy 的机制 <span class="math inline">\(f\)</span>，以及任意 profile <span class="math inline">\(P\)</span>。若某些 agent <span class="math inline">\(j\)</span> 谎报了偏好，但未扩大比 <span class="math inline">\(f^j(P)\)</span> 顺位更高的 bundle 集合，则分配结果不会改变。</li></ul><blockquote><p><strong>Lemma 1.</strong> 令 <span class="math inline">\(f\)</span> 为一个 <span class="math inline">\(p\geqslant 2\)</span> 的 basic categorized domain 上的一个 strategyproof 且 non-bossy 的分配机制。对任意 profile <span class="math inline">\(P,P&#39;\)</span>，若 <span class="math inline">\(\forall j\leqslant n\)</span>，总有： <span class="math display">\[\{\vec{d}\in\mathfrak{D}: \vec{d}\succ_{R_j&#39;} f^j(P)\}\subseteq \{ \vec{d}\in\mathfrak{D}:\vec{d}\succ_{R_j} f^j(P) \}\]</span> 则 <span class="math inline">\(f(P)=f(P&#39;)\)</span>.</p></blockquote><hr><blockquote><p>对于一个 <span class="math inline">\(\mathfrak{D}\)</span> 上的序 <span class="math inline">\(R\)</span>以及 bundle <span class="math inline">\(\vec{d}\in\mathfrak{D}\)</span>，若序 <span class="math inline">\(R&#39;\)</span> 相比 <span class="math inline">\(R\)</span> 只提升了 <span class="math inline">\(\vec{d}\)</span> 的位置，而不改变其他 bundle 的相对位置，则称 <span class="math inline">\(R&#39;\)</span> 为 <span class="math inline">\(\vec{d}\)</span> 在 <span class="math inline">\(R\)</span> 上的一个 <strong>pushup</strong>.</p></blockquote><ul><li>以下引理表明，对于任意 strategyproof 且 non-bossy 的机制 <span class="math inline">\(f\)</span>, 若某个 agent 在谎报偏好时，报告的偏好是 <span class="math inline">\(\vec{d}\)</span> 的 pushup，则只会导致以下两种结果之一：<ul><li>其他 agent 获得的东西都不改变；</li><li>该 agent 获得 <span class="math inline">\(\vec{d}\)</span>.</li></ul></li></ul><blockquote><p><strong>Lemma 2.</strong> 令 <span class="math inline">\(f\)</span> 是一个 <span class="math inline">\(p\geqslant 2\)</span> 的 basic categorized domain 上的 strategyproof，non-bossy 的分配机制，则对任意 profile <span class="math inline">\(P\)</span>，<span class="math inline">\(\forall j\leqslant n\)</span>，以及 <span class="math inline">\(\forall \vec{d}\)</span> 和 <span class="math inline">\(\vec{d}\)</span> 在 <span class="math inline">\(R_j\)</span> 上的一个 pushup，只有以下两种结果之一会发生：</p><ol type="1"><li><span class="math inline">\(f(R_j&#39;,R_{-j})=f(R)\)</span> （什么都没变）;</li><li><span class="math inline">\(f^j(R_j&#39;,R_{-j})=\vec{d}\)</span> （agent <span class="math inline">\(j\)</span> 得到了 <span class="math inline">\(\vec{d}\)</span>）.</li></ol></blockquote><hr><blockquote><p><strong>Lemma 3.</strong> 对任意 <span class="math inline">\(p\geqslant 2\)</span> 的 basic categorized domain，所有 strategyproof，non-bossy，category-wise neutral 的分配机制都是帕累托最优的。</p></blockquote><hr><ul><li>以下引理表明，对任意 strategyproof 且 non-bossy 的机制 <span class="math inline">\(f\)</span>, 以及任意 profile <span class="math inline">\(P\)</span> 中的一对 agent <span class="math inline">\(j_1\)</span>，<span class="math inline">\(j_2\)</span>，不存在这样的 bundle <span class="math inline">\(\vec{c}\)</span>：它由 <span class="math inline">\(j_1\)</span>，<span class="math inline">\(j_2\)</span> 在 <span class="math inline">\(f\)</span> 下得到的物品构成，同时 <span class="math inline">\(j_1\)</span> 和 <span class="math inline">\(j_2\)</span> 都更喜欢 <span class="math inline">\(\vec{c}\)</span>.</li></ul><blockquote><p><strong>Lemma 4.</strong> 令 <span class="math inline">\(f\)</span> 是一个 <span class="math inline">\(p\geqslant 2\)</span>，<span class="math inline">\(n\geqslant 2\)</span> 的 basic categorized domain 上的 strategyproof，non-bossy 的分配机制。<span class="math inline">\(\forall\)</span> profile <span class="math inline">\(P\)</span> 以及 <span class="math inline">\(\forall j_1\neq j_2\leqslant n\)</span>，令 <span class="math inline">\(\vec{a}=f^{j_1}(P)\)</span>，<span class="math inline">\(\vec{b}=f^{j_2}(P)\)</span>，则： <span class="math display">\[不存在  \vec{c}\in(a_1,b_1)\times\{a_2,b_2\}\times\cdots\times\{a_p,b_p\} ，s.t.~~\vec{c}\succ_{R_{j_1}} \vec{a}~~且~~\vec{c}\succ_{R_{j_2}} \vec{b}\]</span> 其中 <span class="math inline">\(a_i\)</span> 是 <span class="math inline">\(\vec{a}\)</span> 的第 <span class="math inline">\(i\)</span> 位的物品。</p></blockquote><blockquote><p><strong>Proof.</strong> <strong>用反证法：</strong>假设对某个 profile <span class="math inline">\(P\)</span>，存在这样的 <span class="math inline">\(j_1\)</span>，<span class="math inline">\(j_2\)</span>，和 <span class="math inline">\(c\)</span>. 设 <span class="math inline">\(\vec{d}\)</span> 表示 <span class="math inline">\(\vec{c}\)</span> 在 <span class="math inline">\(\vec{a}\cup\vec{b}\)</span> 中的补集，则 <span class="math inline">\(\forall i\)</span>，都有 <span class="math inline">\(\{a_i,b_i\}=\{c_i,d_i\}\)</span>. 我们按照如下步骤构造反例：</p><ol type="1"><li>令 <span class="math inline">\(\hat{R}_{j_1}=[\vec{c}\succ\vec{a}\succ\vec{d}\succ\vec{b}\succ 其他]\)</span>，<span class="math inline">\(\hat{R}_{j_2}=[\vec{c}\succ\vec{b}\succ\vec{a}\succ\vec{d}\succ 其他]\)</span>，其余 <span class="math inline">\(j\)</span> 满足 <span class="math inline">\(\hat{R}_j=[f^j(P)\succ 其他]\)</span>. 则由 Lemma 1，有 <span class="math inline">\(f(\hat{P})=f(P)\)</span>.</li><li>令 <span class="math inline">\(\bar{R}_{j_2}=[\vec{c}\succ\vec{a}\succ\vec{b}\succ\vec{d}\succ 其他]\)</span>，由于 <span class="math inline">\(\bar{R}_{j_2}\)</span> 为 <span class="math inline">\(\vec{a}\)</span> 在 <span class="math inline">\(\hat{R}_{j_2}\)</span> 上的 pushup，故由 Lemma 2，<span class="math inline">\(f^{j_2}(\bar{R}_{j_2},\hat{R}_{-j_2})\)</span> 为 <span class="math inline">\(\vec{a}\)</span> 或 <span class="math inline">\(\vec{b}\)</span>. 可由帕累托最优性（Lemma 3）得知不可能是 <span class="math inline">\(\vec{a}\)</span>，故只能有 <span class="math inline">\(f^{j_2}(\bar{R}_{j_2},\hat{R}_{-j_2})=\vec{b}=f^{j_2}(\hat{P})\)</span>. 故由 non-bossiness，可得 <span class="math inline">\(f(\bar{R}_{j_2},\hat{R}_{-j_2})=f(\hat{P})=f(P)\)</span>.</li><li>令 <span class="math inline">\(\bar{R}_{j_1}=[\vec{c}\succ\vec{b}\succ\vec{a}\succ\vec{d}\succ 其他]\)</span>，与 2 类似可得 <span class="math inline">\(f(\bar{R}_{j_1},\bar{R}_{j_2},\hat{R}_{-\{j_1,j_2\}})=f(P)\)</span>.</li><li>令 <span class="math inline">\(\mathring{R}_{j_2}=[\vec{c}\succ\vec{a}\succ\vec{d}\succ\vec{b}\succ 其他]\)</span>，由 Lemma 1 可得 <span class="math inline">\(f(\bar{R}_{j_1},\mathring{R}_{j_2},\hat{R}_{-\{j_1,j_2\}})\)</span> 中，<span class="math inline">\(j_1\)</span> 获得 <span class="math inline">\(\vec{b}\)</span>，<span class="math inline">\(j_2\)</span> 获得 <span class="math inline">\(\vec{a}\)</span>，其余 <span class="math inline">\(j\)</span> 所得与 <span class="math inline">\(f(P)\)</span> 相同.</li><li>令 <span class="math inline">\(\mathring{R}_{j_1}=[\vec{c}\succ\vec{a}\succ\vec{b}\succ\vec{d}\succ 其他]\)</span>，与 2 类似可得 <span class="math inline">\(f(\mathring{R}_{j_1},\mathring{R}_{j_2},\hat{R}_{-\{j_1,j_2\}})=f(\bar{R}_{j_1},\mathring{R}_{j_2},\hat{R}_{-\{j_1,j_2\}})\)</span>.</li><li>由于 <span class="math inline">\(\mathring{R}_{j_1}\)</span> 是 <span class="math inline">\(\vec{b}\)</span> 在 <span class="math inline">\(\hat{R}_{j_1}\)</span> 上的一个 pushup，故由 Lemma 1，可得 <span class="math inline">\(f(\mathring{R}_{j_1},\bar{R}_{j_2},\hat{R}_{-\{j_1,j_2\}})=f(\hat{R}_{j_1},\bar{R}_{j_2},\hat{R}_{-\{j_1,j_2\}})\)</span>. 式子的右端便是 2 中的 profile.</li></ol><p>由 5 和 6 得到的结果，若 agent 们的偏好为 <span class="math inline">\(\mathring{R}_{j_1}\)</span> 和 <span class="math inline">\(\bar{R}_{j_2}\)</span>，则 <span class="math inline">\(j_2\)</span> 可通过将自己的偏好谎报为 <span class="math inline">\(\mathring{R}_{j_2}\)</span> 以获取更大利益。这与 strategyproof 矛盾。Lemma 4 得证。</p></blockquote><p><img src="/img/blog-graph/Allocating Indivisible Items in Categorized Domains - The 6 steps.png" alt="证明 Lemma 4 的 6 步"></p><hr><ul><li>容易验证 serial dictatorship 是 strategyproof，non-bossy，且 category-wise neutral 的，接下来我们证明满足以上三条的性质只有 serial dictatorship.</li></ul><p>令 <span class="math inline">\(R^*\)</span> 是 <span class="math inline">\(\mathfrak{D}\)</span> 上满足以下几条的序：</p><ol type="1"><li><span class="math inline">\((1,\ldots,1)\succ (2,\ldots,2)\succ\cdots\succ (n,\ldots,n)\)</span>;</li><li><span class="math inline">\(\forall j&lt;n\)</span>，<span class="math inline">\((j,\ldots,j)\)</span> 与 <span class="math inline">\((j+1,\ldots,j+1)\)</span> 之间的 bundle 都满足以下两条（记为 <span class="math inline">\(B_j\)</span>）：<ol type="1"><li>至少有一维是 <span class="math inline">\(j\)</span>；</li><li>所有维度的值都在 <span class="math inline">\(\{j,j+1,\ldots,n\}\)</span> 中.</li></ol></li><li><span class="math inline">\(\forall j\)</span> 以及 <span class="math inline">\(\forall \vec{d},\vec{e}\in B_j\)</span>，若 <span class="math inline">\(\vec{d}\)</span> 中 <span class="math inline">\(j\)</span> 的数量严格多余 <span class="math inline">\(\vec{e}\)</span>，则 <span class="math inline">\(\vec{d}\succ\vec{e}\)</span>.</li></ol><p>Thenextclaimstatesthatf agreeswithaserialdictatorship on the profile (R ∗ ,…,R ∗ ) where all agents have the same preferences R ∗ that we have just defined. We will later show that f agrees with the same serial dictatorship on all profiles.</p><blockquote><p><strong>Claim 1.</strong> 令 <span class="math inline">\(P^*=(R^*,\ldots,R^*)\)</span>，则对 <span class="math inline">\(\forall l\leqslant n\)</span>，存在 <span class="math inline">\(j_l\leqslant n\)</span>，s.t. <span class="math inline">\(f^{j_1}(P)=(l,\ldots,l)\)</span>.</p></blockquote><hr><blockquote><p>事实上，这个定理是比较负面的一个结果。因为它意味着同时满足三条的分配机制并不好，因此我们需要舍弃其中至少一条。其中 non-bossy 是比较不自然的。</p></blockquote><h2 id="categorial-sequencial-allocation-mechanisms-csam">Categorial Sequencial Allocation Mechanisms (CSAM)</h2><p>给定 <span class="math inline">\(\{1,\ldots,n\}\times\{1,\ldots,p\}\)</span> 上的序 <span class="math inline">\(\mathcal{O}\)</span>，由 <span class="math inline">\(\mathcal{O}\)</span> 生成的 <strong>CSAM</strong> <span class="math inline">\(f_\mathcal{O}\)</span> 的过程分为 <span class="math inline">\(np\)</span> 个步骤：</p><ul><li>在第 <span class="math inline">\(t\)</span> 步中，设 <span class="math inline">\(\mathcal{O}\)</span> 的第 <span class="math inline">\(t\)</span> 顺位为 <span class="math inline">\((j,i)\)</span>.</li><li>Agent <span class="math inline">\(j\)</span> 被称为第 <span class="math inline">\(t\)</span> 步中的 active agent，他将选择（可选择的）物品 <span class="math inline">\(d_{j,i}\in D_i\)</span>；</li><li>将 <span class="math inline">\(d_{j,i}\)</span> 广播给所有的 agent.</li></ul><p><img src="/img/blog-graph/Allocating Indivisible Items in Categorized Domains -  CSAM protocol.png" alt="Protocol of CSAM"></p><p>后面是一些效率的问题，先略过。</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 北大 </tag>
            
            <tag> 社会计算 </tag>
            
            <tag> 论文笔记 </tag>
            
            <tag> 经济学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>表示论在投票理论中的应用</title>
      <link href="/2019/07/26/%E8%A1%A8%E7%A4%BA%E8%AE%BA%E5%9C%A8%E6%8A%95%E7%A5%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <content type="html"><![CDATA[<p>似乎主要是 Donald G. Saari 和 Zajj Daugherty 等人的工作…</p><blockquote><p>大致思路：用 tabloid 来描述投票中的对象，然后将过程中的状态空间视为 <span class="math inline">\(\mathbb{Q}S_n\)</span>-模，然后将其分解为不可约模的直和，并分析在投票过程中真正起作用的成分。</p></blockquote><a id="more"></a><p>太懒了…直接把曹老师作报告用的 Slides 放上来吧…</p><script src="/js/pdfobject.js"></script><style>    /* Only resize the element if PDF is embedded */    .pdfobject-container {        width: 800px;        height: 900px;    }</style><center><div id="my-container"></div></center><script>    PDFObject.embed("/pdf/BNU20190907.pdf", "#my-container");</script><h2 id="参考文献">参考文献</h2><ol type="1"><li>Barcelo, H., Bernstein, M., Bockting-Conrad, S., Mcnicholas, E., Nyman, K., Viel, S. (2018). Algebraic voting theory and representations of <span class="math inline">\(S_m ≀ S_n\)</span> . arXiv:1807.03743v1 [math.CO] 6 Jul 2018.</li><li>Crisman, K. D., Orrison, M. E. (2017). Representation theory of the symmetric group in voting theory and game theory. Algebraic and Geometric Methods in Discrete Mathematics, 685, 97.</li><li>Daugherty, Z., Eustis, A. K., Minton, G., Orrison, M. E. (2009).</li><li>Voting, the symmetric group, and representation theory. The American Mathematical Monthly, 116(8), 667-687.</li><li>Saari, D. G. (1999). Explaining all three-alternative voting outcomes. Journal of Economic Theory, 87(2), 313-355.</li><li>Saari, D. G. (2000). Mathematical structure of voting paradoxes. Economic Theory, 15(1), 1-53; 55-102</li></ol><!-- > **Def. 1** 群 $G$ 的一个 `表示` 是指一个同态：$$\mathfrak{X}:G\to GL(V)$$其中 $V$ 是 $F$ 上的 $d$ 维向量空间。> **Def. 2** 称一个表示 $\mathfrak{X}:G\to GL(V)$ 是 `可约` 的，当且仅当 $V=\{0\}$ 或存在 $V$ 的子空间 $W$，s.t. $0\neq W\neq V$，且 $w\mathfrak{X}(g)\in W$，$\forall w\in W,g\in G$（此时称 $W$ 是 `G-不变` 的）。否则 $\mathfrak{X}$ 不可约。- 可约的等价条件是：存在 $V$ 的一组基，s.t. $\mathfrak{X}(g)$ 有矩阵形式 $$\begin{bmatrix}    \mathfrak{X}_W(g) & 0 \\    * & \mathfrak{X}_{V/W}(g) \\\end{bmatrix}$$ 此时，$\mathfrak{X}_W(g)$ 和 $\mathfrak{X}_{V/W}(g)$ 分别是 $W$ 和 $V/W$ 上的表示。- 在等价的意义下，$G$ 的不可约 $F$-表示只有有限个；> **Def. 3** 两个表示 $\mathfrak{X}:G\to GL(V)$ 和 $\mathfrak{Y}:G\to GL(W)$ 是等价的，当且仅当以下图表对 $\forall g\in G$ 交换：$$\begin{matrix}    V & \overset{\mathfrak{X}(g)}{\longrightarrow} & V \\    \alpha\downarrow & & \downarrow\alpha \\    W & \overset{\mathfrak{Y}(g)}{\longrightarrow} & W \\\end{matrix}$$（若给 $V$ 和 $W$ 选取恰当的基，则 $\mathfrak{X}(g)$ 和 $\mathfrak{Y}(g)$ 是相似的）> **Def. 4** 设 $\mathfrak{X}:G\to GL(V)$ 是 $G$ 的一个 $F$-表示，则 $\mathfrak{X}$ 的`特征`为映射> $$\chi_\mathfrak{X}:G\to F,~~~g\mapsto Trace(\mathfrak{X}(g)).$$- 等价的表示有相同的特征；- 若 $\mathfrak{X}$ 不可约，则称 $\chi_\mathfrak{X}$ 为一个不可约特征；- $G$ 的不可约特征也只有有限个；（易得）- 若 $V$ 的子空间 $W$ 是 $G$-不变的，则 $\chi_\mathfrak{X}=\chi_{\mathfrak{X}_W}+\chi_{\mathfrak{X}_{V/W}}$；<font color="red">这条很显然</font>- 每个特征都可以拆分成不可约特征的和；- 两个不可约表示等价，当且仅当其特征相等；- 若 $ch(F)=0$，则两个不可约表示等价，当且仅当其特征相等。<center>从现在开始，令 $F=\mathbb{C}$。</center>- 记 $G$ 的所有 $\mathbb{C}$-特征为 $Irr(G)=\{\chi_1,\cdots,\chi_k\}$；- 令 $g_1,\cdots,g_k$ 为 $G$ 共轭类的代表元；> **Def. 5** 方阵 $[\chi_i(g_j)]_{1\leqslant i,j\leqslant k}$ 称为 $G$ 的`特征表`（ordinary character table）。## 表示论与自动机> 文章：The Automata that Define Representations of Monomial Algebras### 表示论基础- 假设 $Q$ 是一个有限有向图，顶点集记为 $Q_0$，有向边集记为 $Q_1$，允许自环和重边；- 对于任一条边 $a\in Q$，记 $a$ 的起点和终点分别为 $s(a)$ 和 $t(a)$；- 一列有向边 $a_1,\cdots,a_m$ 构成 $Q$ 中的一条有向路径 $p$，其中对 $i=1,\cdots,m-1$ 均有 $t(a_i)=s(a_{i+1})$，则 $p$ 有起点 $s(p)=s(a_1)$ 和终点 $t(p)=t(a_m)$，以及长度 $m$；- 两条路径 $p$ 和 $q$ 能连接的充要条件是 $t(p)=s(q)$，否则称 $pq=0$；- 记 $a^{-1}$ 为 $a$ 的逆边，进一步可定义路径的逆：$p^{-1}=a_m^{-1}\cdots a_1^{-1}$，其起点和终点与 $p$ 相反；> 现有有向图 $Q$ 和代数闭域 $k$，以 $Q$ 中所有路径为基所扩张出的 $k$-向量空间定义为 `路径代数` $kQ$，$Q$ 被称为 $kQ$（及其商空间）的 `Gabriel quiver`，其中的有向边称为“箭”。> 设 $P$ 是一个路径集合，其中的路径长度均为 $2$。我们定义**monomial algebra**（monomial algebra）$kQ/\langle P\rangle$。- 路径代数 $kQ$ 也是一个monomial algebra，取 $P$ 为空即可。> **Def. Path Algebra** $k$ 是一个代数闭域，$Q$ 是一个箭图。$Q$ 中的所有路径张成的 $k$-代数称为一个path algebra，记作 $kQ$。> **Def. Monomial Algebra** $P$ 是一个 $Q$ 中的路径集，其中的路径长度至少为 $2$，则 $kQ/\langle P\rangle$ 是一个monomial algebra。> **Def. String Algebra** 若一个monomial algebra $A=kQ/\langle P\rangle$ 满足：> > 1. $\forall x\in Q_0$，至多存在两个箭头 $a,b\in Q_1$，s.t. $s(a)=s(b)=x$；> 2. $\forall x\in Q_0$，至多存在两个箭头 $a,b\in Q_1$，s.t. $t(a)=t(b)=x$；> 3. $\forall b\in Q_1$，至多存在一个箭头 $a\in Q_1$，s.t. $t(a)=s(b)$ 且 $ab\notin \langle P\rangle$;> 4. $\forall b\in Q_1$，至多存在一个箭头 $c\in Q_1$，s.t. $s(c)=t(b)$ 且 $bc\notin \langle P\rangle$；> > 则称 $A$ 为一个string algebra。该情形下 $kQ/\langle P\rangle$ 的任一个不可分解的模都是string module或band module。<center><font color="red">string module和band module将在下文中定义</font></center>### 串模和带模考虑monomial algebra $A=kQ/\langle P\rangle$。- 称 $Q_1\cup Q_1^{-1}$ 中的元素为 **letter**；    - $Q_1$ 中的元素称为 **direct letter**；    - $Q_1^{-1}$ 中的元素称为 **inverse letter**。> **Def. String** 长度为 $n$ 的字符序列 $\mathbf{u}=u_n\cdots u_1$ 如果满足：> > 1. $\forall 1\leqslant i<n$，有 $t(u_i)=s(u_{i+1})$；（能连上）> 2. $\forall 1\leqslant i<n$，有 $u_i\neq u_{i+1}^{-1}$；（无回溯）> 3. $\forall 1\leqslant i<i+k\leqslant n$，$u_{i+k}\cdots u_i$ 及其逆均不在 $\langle P\rangle$ 中。（子串和子串的逆不在 $\langle P\rangle$ 中）> > 则称之为一个**string**。- 简单来说，string就是“能连得上”且“不能化简”的边序列。- 若一个长度不小于 $1$ 的string $b$ 满足 $s(b)=t(b)$，则称之为一个cycle；    - 若不存在string $u$，s.t. $b$ 是 $u$ 重复 $m$ 次得到的，则称 $b$ 是一个primitive cyclic string；> **Def. Band** 若一个 primitive cyclic string $b=b_n\cdots b_1$ 满足 $b^m\neq 0$，$\forall m\geqslant 1$ 且 $b_1$ 是一个inverse letter，$b_n$ 是一个direct letter，则称 $b$ 是一个**band**。- 对于一个monomial algebra $A$：    - 每个string都定义了 $A$ 的一个不可分解的表示；    - 每个band都定义了一族参数化的表示；    - 不等价的串和带以及不同的参数都会导致所对应的表示不等价。更准确地，给定串 $s=x_1\cdots x_n$，长度 $n\geqslant 1$，其中 $x_i$ 是 $Q$ 中的边或 $Q$ 中边的逆。我们定义 $A$ 的 $n+1$ 维不可分解表示，基为 $e_1,\cdots,e_{n+1}$，对 $Q$ 的每个箭头 $a$，若 $x_i=a$，则 $e_i^a=e_i+1$；若 $x_{i-1}=a^{-1}$，则 $e_i^a=e_{i-1}$；其余情况 $e_i^a=0$。当 $s$ 同时还是一个band的时候，对于任意非零的 $v\in k$，以及任意整数 $m\geqslant 1$，我们可用如下方法将参数化的表示扩展到 $mn$ 维。对于 $\forall i=1,\cdots,n$，我们都定义 $k$ 上的 $m$ 维向量空间 $E_i$，并取一组基。设 $I_m$ 是 $m$ 阶单位阵，$J_{vm}$ 表示特征值为 $v$ 的 $m$ 阶Jordan块。则对于 $Q$ 中的任意箭头 $a$，考虑所有指标 $n$ 的模，若 $x_i=a$，则令 $a$ 为 $E_i\to E_{i+1}$ 的映射；若 $x_{i-1}=a^{-1}$，则令 $a$ 为 $E_i\to E_{i-1}$ 的映射；其余情况 $a$ 为 $E_i$ 上的平凡映射。若 $a$ 在 $E_i$ 上是非平凡的，则关于选定的基，该映射通常是由单位阵 $I_m$ 定义的，除去以下两种情况：若 $x_1=a$，则 $a=J_{vm}:E_1\to E_2$；若 $x_1=a^{-1}$，则 $a=J_{vm}:E_2\to E_1$。### 自动机- 有限状态自动机 $G$：    - 有一些状态，用集合 $V$ 表示        - 初始态，记作$v_0$；        - 其余的状态分为接受态（accept）和拒绝状态（reject）；- 自动机的输入：    - 可以接受一个序列 $x_1,\cdots,x_n$ 或一个有限集 $X$ 作为输入；    - 从 $x_1$ 开始，每次读取一个字符；    - 自动机 $G$ 接收第一个输入字符时的状态一定是初始态 $v_0$        - 随后根据当前状态和输入的字符决定下一个状态；    - $G$ 可接受一个字符串，是指当字符串读取完毕后，自动机处于接受态；    - 用 $\epsilon$ 表示空串；<font color="red">$\epsilon$ 是否可接受显然取决于 $v_0$ 是否是接受态</font>- 一个自动机显然可以用一个有限图表示（允许自环和重边）    - 顶点集：自动机的状态集；    - 有向边集：状态之间的转移，可用 $X$ 中的元素标记。        - 字符串对应有向路径；- 一个字符串可以被自动机识别，当且仅当其对应的路径是连接 $v_0$ 与某一接受态结点的路径；- 如果任一可接受序列的任意前缀都是可接受的，那么我们将所有非可接受的结点都删除，我们可以得到一个更精确（更小的，原文用 more compact）的表示。    - 在这个更小的表示下，一个可接受的字符串就是图中的一条有向路径；- minimal automaton $G_{min}$ 这里没看懂- 一个序列的集合被称为是正则（regular）的，当且仅当它们能被一个有限状态自动机接受。### 描述自动机<center>从现在开始，假设代数 $kQ/\langle P\rangle$ 是有限维的，并且 $P$ 是有限的</center>>在此情况下，$Q_1\cup Q_1^{-1}$ 中元素构成的序列 $x_1\cdots x_n$ 是一个string，当：>>1. $\forall i$，$t(x_i)=s(x_{i+1})$；（废话）>2. $\forall i$，$x_{i+1}\neq x_i^{-1}$；（废话）>3. 在 $P$ 中没有长度不超过 $N$ 的subword。（什么鬼？）>>因此string构成的集合是 $k$-testable 的，其中 $k=\max\{2,N\}$。故下述自动机 $G$ 可以识别 $kA/\langle P\rangle$ 中的string。我们使用上文所述的“更精确的图表示”来进行说明。- 初始态：$v_0$；- 其他状态用 $(x,w)$ 表示：    - $x\in Q_1\cup Q_1^{-1}$；    - $w$ 是一个 $Q_1$（若 $x\in Q_1$）或 $Q_1^{-1}$（若 $x\in Q_1^{-1}$）上的长度不超过 $N$ 的序列（可能是空的）。- 对 $\forall y\in Q_1\cup Q_1^{-1}$，存在一条从 $s_0$ 出发的边，若存在一条 $P\cup P^{-1}$ 中从 $y$ 起始的边，则该条边的终点是 $(y,y)$，否则该条边的终点为 $(y,\epsilon)$。- 更一般地，从 $(x,w)$ 出发，若 $x$ 的终点不是 $y$ 的起点，或 $y$ 是 $x$ 的逆，或 $wy$ 是 $P\cup P^{-1}$ 中的道路，则不存在标记为 $y$ 的边；    - 否则        - 若 $x,y$ 之一在 $Q_1$ 中，另一者在 $Q_1^{-1}$ 中，则存在一条从 $(x,w)$ 到 $(y,y)$ 的边，标记为 $y$；        - 若 $x,y$ 同在 $Q_1$ 或 $Q_1^{-1}$ 中，则存在一条从 $(x,w)$ 到 $(y,w')$ 的边没标记为 $y$，其中 $w'$ 是 $wy$ 中满足“是 $P\cup P^{-1}$ 中至少一条路径的前缀”的最长后缀。- 上述自动机可能不是最小的，但可以最小化；### 在String自动机中寻找Band令 $A=kQ/\langle P\rangle$ 是一个monomial algebra，$G$ 是任意一个能识别其中语句的有限状态自动机。我们不需要 $G$ 是最小的，但我们假设该自动机没有任何不可达状态，也没有任何dead end状态（不能到达任何接受态的结点）。按照定义，一个 $Q_1\cup Q_1^{-1}$ 上的序列是一个string，当且仅当它可以从 $G$ 的初始态结点走出去。由于任何string的子列都是string，故任意 $Q_1\cup Q_1^{-1}$ 上被标记了任意 $G$ 中有向路径的序列都是string，不管这条路径的起点是哪里。若 $v$ 是 $G$ 的一个状态，则：1. $v=v_0$；2. $v$ 是一个不引出任何边的状态;3. $v$ 即有边进入，也有边离开> **Prop. 5.1** $Q_1\cup Q_1^{-1}$ 上的序列是一个band，当且仅当它在 $G$ 中标记了一个回路。- 注意一个band可以标记多个回路。> **Prop. 5.2** $S$ 中有有限多个band，当且仅当 $G$ 中有一对相交的回路。在此情况下，存在常数 $C>1$，s.t. 对于 $n$ 的有限个值，长度为 $n$ 的band的个数多于 $C^n$。## 投票理论和博弈论中对称群的表示> 文章：Representation theory of the symmetric group in voting theory and game theory### 背景介绍<center>$n\in \mathbb{N}^+$</center>- $n$ 的一个 **composition** 是指序列 $\lambda=(\lambda_1,\cdots,\lambda_m)$，s.t. $\sum\limits_{i=1}^m=n$，其中 $\lambda_i\in\mathbb{N}^+$；    - 若 $\lambda_1\geqslant\cdots\geqslant\lambda_m$，则称 $\lambda$ 是 $n$ 的一个 **partition**；    - 对于一个 composition $\lambda$，将其降序排序即可得到一个 partition，记作 $\bar{\lambda}$。- 杨氏的乱七八糟东西：设 $\lambda$ 是 $n$ 的一个 composition；    - 杨氏图像 Young diagram(of shape $\lambda$)：共 $m$ 行，每行 $\lambda_i$ 个方块；    - 杨氏矩阵 Young tableau(of shape $\lambda$)：将 $1,\cdots,n$ 不重不漏地填入样式图像中所得到的数字表；        - 杨氏矩阵的等价关系：若两个杨氏矩阵每行的数字集都相同，则称两个杨氏矩阵等价；    - Tabloid(of shape $\lambda$)：形状为 $\lambda$ 的一个杨氏矩阵的一个等价类。- 假设 $\lambda$ 是 $n$ 的一个composition：    - $X^\lambda$：形状为 $\lambda$ 的 tabloid 的集合；    - $M^\lambda$：$X^\lambda$ 上定义的实值函数构成的向量空间。        - 对于 $x\in X^\lambda$，$f_x$ 表示 $x$ 的示性函数，即 $f_x(y)=\begin{cases}            1, & y=x \\            0, & y\neq x \\        \end{cases}$.        - $M^\lambda$ 上的内积 $\langle\cdot,\cdot\rangle$定义如下：$$\langle f,g\rangle=\sum\limits_{x\in X^\lambda} f(x)g(x),~~~\forall f,g\in M^\lambda.$$- 我们主要关注以下几种 composition：    - $\lambda=(1,\cdots,1)$；        - 形状为 $\lambda$ 的 tabloid 恰好对应于 $(1,\cdots,n)$ 的全排列；    - $\lambda=(k,n-k)$；        - 形状为 $\lambda$ 的 tabloid 恰好对应于 $(1,\cdots,n)$ 的所有 $k$ 元子集；    - $\lambda=(n)$；        - 他的 tabloid 没什么好说的...    - 一个投票规则可以视为一个 $M^{(1,\cdots,1)}$ 到 $M^{(1,n-1)}$ 的线性变换。对于投票而言，我们希望候选人的编号不影响投票，我们将用群作用来描述这种性质。（这种性质被称为 neutral）- 考虑置换群 $S_n$ 在 $X^\lambda$ 上的左乘作用，$\sigma\cdot x$ 表示对 $x$ 的每行都进行 $\sigma$ 的变换。- 将该作用延拓到 $M^\lambda$ 上，有：$$(\sigma\cdot f)(x)=f(\sigma^{-1}\cdot x),~~~其中~\sigma\in S_n,f\in M^\lambda,x\in X^\lambda.$$    - 换言之，$M^\lambda$ 可以视为群代数 $\mathbb{R}S^n$ 上的一个模。        - 群代数是一个域 $K$ 和一个群 $G$ 构成的代数结构，其中的元素是 $G$ 中的元素加上 $K$ 中的系数所构成的线性组合$\sum\limits_{g\in G,a_g\in K}a_g\cdot g$，乘法和加法都很自然。（参见 <a href="http://mathworld.wolfram.com/GroupAlgebra.html">Wolfram Mathworld：Group Algebra</a>）- 现在我们考虑 neutral 的投票规则：    - 一个 neutral 的线性变换 $T: M^{(1,\cdots,1)}\to M^{(1,n-1)}$，即 $T$ 是一个 $\mathbb{R}S_n$-模同态。- 不可约的 $\mathbb{R}S_n$-模由 $n$ 的 partition 确定，我们用 $S^\mu$ 代表对应于 $\mu$ 的不可约模。    - 这些 $S^\mu$ 就是specht module...（我不太知道这到底是啥）- 若 $\lambda$ 是 $n$ 的一个partition，则 $M^\lambda$ 与 一些specht modules的直和同构：$$M^\lambda\cong\bigoplus_\mu \kappa_{\mu\lambda} S^{\mu}$$其中 $\kappa_{\mu\lambda}$ 是 Kostka 数（具体参见wiki），记录每个module在 $M^\lambda$ 中的重数。    - $$M^{(1,\cdots,1)}\cong \bigoplus_\mu (\dim S^\mu)S^\mu.$$    - 若 $1<k\leqslant n/2$（即 $(n-k,k)$ 是 $n$ 的一个partition），则：$$M^{(k,n-k)}\cong M^{(n-k,k)}\cong S^{(n)}\oplus S^{(n-1,1)}\oplus S^{(n-2,2)}\oplus\cdots\oplus S^{(n-k,k)}.$$    - $$M^{(n)}\cong S^{(n)}.$$- $M^{(1,n-1)}$ 是两个不可约模的直和：    - $U_0$：$M^{(1,n-1)}$ 中所有的常函数（与 $S^{(n)}$ 同构）：$$U_0=\{f\in M^{(1,n-1)}~|~f(x)=f(y),~\forall x,y\in X^{(1,n-1)}\}$$    - $U_1$：在 $X^{(1,n-1)}$ 上函数值之和为 $0$ 的函数（与 $S^{(1,n-1)}$ 同构）：$$U_1=\{f\in M^{(1,n-1)}~|~\sum\limits_{x\in X^{(1,n-1)}} f(x)=0\}$$- 若 $f\in M^{(1,n-1)}$，则可将其分解为 $\hat{f}\in U_1$ 和 $f-\hat{f}\in U_0$ 两部分。- 进一步，注意到 $S_n$ 在 $X^\lambda$ 上的作用是传递的。换言之，给定 $x,y\in X^\lambda$，$\exists\sigma\in S_n$，s.t. $\sigma\cdot x=y$。因此，有 $\sigma\cdot f_x=f_y$。于是定义在 $M^\lambda$ 上的每个模同态都是由示性函数 $f_x$ 决定的。- 用 $x_0$ 表示 $X^\lambda$ 中按照字典序填数字的 tabloid（从上到下，从左到右）。- 设 $\lambda$ 是 $n$ 的 composition，$T$ 是 $M^\lambda$ 上的模同态，则 $M^\lambda$ 可做如下直和分解：$$M^\lambda=\ker T\oplus (\ker T)^\perp$$称 $(\ker T)^\perp$ 为 $T$ 的 **effective space**，记作 $E(T)$。    - 看起来 $E(T)$ 应该和 ${\rm Im}~T$ 同构？### voting theory- $n$ 个候选人：$\{1,2,\cdots,n\}$；- 每个投票人都用 $X^{(1,\cdots,1)}$ 中的一个 tabloid 表示；    - 第一行表示最喜欢的，第二行表示第二喜欢的...以此类推- 取 $\textbf{p}\in M^{(1,\cdots,1)}$，s.t. $\textbf{p}(x)$ 表示选择了 tabloid $x$ 的人数；- 实向量 $\mathbf{w}=[w_1,\cdots,w_n]^T$，s.t. $w_1\geqslant\cdots\geqslant w_n$，称为 weight vector。    - 对 $\forall x\in X^{(1,\cdots,1)}$，若候选人 $i$ 在 $x$ 的第 $j$ 行，则他可以得到 $\textbf{p}(x)w_j$ 的分数。计算该候选人的总得分需要对 $x\in X^{(1,\cdots,1)}$ 求和。    - 最后分数最高的候选人获胜；    - 这种算法称为 **positional voting**。         - 当 $\mathbf{w}=[1,0,\cdots,0]^T$ 时，该投票即为一般的多数原则，称为 **Plurality**；        - 当 $\mathbf{w}=[1,\cdots,1,0]^T$ 时，称为 **anti-plurality**；        - 当 $\mathbf{w}=[n-1,n-2,\cdots,1,0]^T$ 时，称为 **Borda count**；- 如此构造一个 $\mathbf{w}^{(i)}\in M^{(1,\cdots,1)}$：若候选人在 tabloid $x$ 的第 $j$ 行，则 $\mathbf{w}^{(i)}(x)=w_j$。     - 则候选人 $i$ 的总得分为 $$\sum_{x\in X^{(1,\cdots,1)}}\textbf{p}(x)\mathbf{w}^{(i)}(x)=\langle p,\mathbf{w}^{(i)}\rangle$$- 进一步，我们可以利用 $X^{(1,n-1)}$ 中的 tabloid 来标记所有的候选人：令 $y\in X^{(1,n-1)}$ 标记处在其第一行的候选人（第一行只有一个）。记 $\mathbf{c}_i\in M^{(1,n-1)}$ 为标记了候选人 $i$ 的 tabloid 的示性函数，则我们按照如下方法可以得到一个模同态：    - 令：$$T_\mathbf{w}(\mathbf{f})=\langle \mathbf { f } , \mathbf { w } ^ { ( 1 ) } \rangle \mathbf { c } _ { 1 } + \cdots + \langle \mathbf { f } , \mathbf { w } ^ { ( n ) } \rangle \mathbf { c } _ { n }$$在 $T_{\mathbf{w}}(p)$ 中 $\mathbf{c}_i$ 的系数即为候选人 $i$ 所得的分数。<center>从现在开始，将 $w_{1} \mathbf{c}_{1}+\cdots+w_{n} \mathbf{c}_{n} \in M^{(1, n-1)}$ 也记作 $\mathbf{w}$。</center>- 若 $x_{0} \in X^{(1, \ldots, 1)}$ 是 $i$ 号候选人恰好处于第 $i$ 行的 tabloid，$\tilde{\textbf{f}}\in\mathbb{R}S_n$ 被定义为 $\tilde{\textbf{f}}(\sigma)=\textbf{f}(\sigma\cdot x_0)$，则有：$$\begin{aligned} T_{\mathbf{w}}(\mathbf{f}) &=\sum_{\sigma \in S_{n}} \mathbf{f}\left(\sigma \cdot x_{0}\right)\left(w_{1} \mathbf{c}_{\sigma(1)}+\cdots+w_{n} \mathbf{c}_{\sigma(n)}\right) \\ &=\sum_{\sigma \in S_{n}} \widetilde{\textbf{f}}(\sigma)(\sigma \cdot \mathbf{w}) \\ &=\widetilde{\mathbf{f}} \cdot \mathbf{w} \end{aligned}$$    - 换言之，$T_{\mathbf{w}}(\mathbf{f})$ 可以被视为群代数中的元素 $\tilde{\textbf{f}}\in\mathbb{R}S_n$ 作用在函数 $\mathbf{w} \in M^{(1, n-1)}$ 上。> **Th. 1.** 设 $n\geqslant 2$，且 $\mathbf{w}_{1}, \ldots, \mathbf{w}_{k} \in U_{1} \subset M^{(1, n-1)}$ 是一个线性无关向量组。若 $\mathbf{r}_{1}, \dots, \mathbf{r}_{k} \in U_{1}$，则存在无穷多个函数 $\mathbf{f} \in M^{(1, \ldots, 1)}$，s.t. $T_{\mathbf{w}_{i}}(\mathbf{f})=\mathbf{r}_{i}$，$\forall i\in [1,k]\cup\mathbb{Z}$。- 若 $\mathbf{w}=\mathbf{1}_{\mathbf{w}}+\hat{\mathbf{w}}$，其中 $1_{\mathrm{w}} \in U_{0}$，$\widehat{\mathrm{w}} \in U_{1}$，则 $T_{\mathbf{w}}(\mathbf{f})=\widetilde{\mathbf{f}} \cdot \mathbf{w}=\widetilde{\mathbf{f}} \cdot \mathbf{1}_{\mathbf{w}}+\widetilde{\mathbf{f}} \cdot \widehat{\mathbf{w}}$；    - 因此，$T_{\mathbf{w}}$ 决定的候选人顺序只和 $\hat{\mathbf{w}}$ 相关。> **Def. weight vector 的等价** 若 $\exists\alpha,\alpha'\in\mathbb{R}$，s.t. $\alpha>0$ 且 $\mathbf{w}^{\prime}=\alpha \mathbf{w}+\alpha^{\prime} \mathbf{1}$，则称 $\mathbf{w}$ 和 $\mathbf{w}'$ 等价，记作 $\mathbf{w}\sim\mathbf{w}'$。- 两个 weight vector 等价意味着在相同条件下导出相同的排序。> **Th. 2.** 设 $\mathbf{w}, \mathbf{w}^{\prime} \in M^{(1, n-1)}$ 为 weight vector。则 $T_{\mathbf{w}}(\mathbf{p})$ 和 $T_{\mathbf{w}^{\prime}}(\mathbf{p})$ 内部的次序是一样的，$\forall \mathbf{p}\in M^{(1,\cdots,1)}$，**当且仅当** $\mathbf{w} \sim \mathbf{w}^{\prime}$。- 换言之，若 $\mathbf{w}$ 和 $\mathbf{w}'$ 不等价，则它们导出的排序有可能不同。- 若 $\mathbf{w}$ 与 $\mathbf{w}'$ 不等价，则 $T_\mathbf{w}$ 和 $T_{\mathbf{w}'}$ 会非常不同：    - 若 $\mathbf{w}\in U_1$ 非零，则 $E(T_\mathbf{w})\cong S^{(n-1,1)}$，即 $E(T_\mathbf{w})$ 是 $M^{(1,\cdots,1)}$ 的不可约子模，因此我们可以得到如下结论：> **Th. 3.** 设 $\mathbf{w}, \mathbf{w}^{\prime} \in U_{1} \subset M^{(1, n-1)}$ 为非零向量，则 $E(T_{\mathbf{w}})=E(T_{\mathbf{w}^{\prime}})$ **当且仅当** $\mathbf{w} \sim \mathbf{w}^{\prime}$。**进一步**，若 $E(T_{\mathbf{w}})\neq E(T_{\mathbf{w}^{\prime}})$，则 $E(T_{\mathbf{w}})\cap E(T_{\mathbf{w}^{\prime}})=\{0\}$。- 除 positional voting 外，还存在其他的投票规则；    - 例如：simple ranking scoring function (SRSF)，给定一个 $M^{(1,\cdots,1)}$ 中的 profile，我们据此来给<font color="red">候选人的序</font>而不是<font color="blue">单个候选人</font>打分，最后找出评分最高的序；        - 例如：令 $x_0\in M^{(1,\cdots,1)}$ 是一个 tabloid（即候选人的一个序），s.t. 候选人 $i$ 在第 $i$ 行。取定函数 $\mathbf{z} \in M^{(1, \ldots, 1)}$，并定义$$T_{\mathbf{z}} : M^{(1, \ldots, 1)} \rightarrow M^{(1, \ldots, 1)},~~~T_{\mathbf{z}}(\mathbf{f})=\sum_{\sigma \in S_{n}} \mathbf{f}\left(\sigma \cdot x_{0}\right)(\sigma \cdot \mathbf{z})=\widetilde{\mathbf{f}} \cdot \mathbf{z}.$$此时的 winning ranking 就是一个 tabloid $x\in M^{(1,\cdots,1)}$，s.t. $T_{\mathrm{z}}(\mathbf{p})(x) \geq T_{\mathbf{z}}(\mathbf{p})(y),~\forall y \in M^{(1, \ldots, 1)}$。<center>上述过程中的关键就是 $\mathbf{z}$ 的选取</center>- 我们用“度量”来定义：    - 设 $d : X^{(1, \ldots, 1)} \times X^{(1, \ldots, 1)}$ 为一个最大值为 $d_\max$ 的度量；    - 我们定义 $\mathbf{z}(x)=d_{\max }-d\left(x, x_{0}\right)$；        - 此时一个 winning ranking 即为集合中离 $x_0$ 的最近者。    - $X^{(1,\cdots,1)}$ 上一个常用的度量是 Kendall tau distance：两个排列对应位置上不同元素的个数（`for i in [1, n]; if a[i] != b[i] then cnt++;`)> **Th. 4.** 对于 $n\geqslant 3$ 个候选人，Borda count 一定会**严格**将 <font color="red">Kemeny rule 排在最前面的人</font> 排在 <font color="blue">Kemeny rule 排在最后面的人</font> 前面。反过来，Kemeny rule 也会如此对待 Borda count 的首位两位候选人。然而，除 Borda count 之外的其他任何 positional voting method 都与 Kemeny rule 没有什么关系。$$\begin{aligned} \mathcal{G}_{1} &=U_{0}^{1} \oplus U_{1}^{1} \\ \mathcal{G}_{2} &=U_{0}^{2} \oplus U_{1}^{2} \oplus U_{2}^{2} \\ \mathcal{G}_{3} &=U_{0}^{3} \oplus U_{1}^{3} \oplus U_{2}^{3} \oplus U_{3}^{3} \\ & \vdots \\ \mathcal{G}_{\lfloor n / 2\rfloor} &=U_{0}^{\lfloor n / 2\rfloor} \oplus U_{1}^{\lfloor n / 2\rfloor} \oplus U_{2}^{\lfloor n / 2\rfloor} \oplus \cdots \oplus U_{\lfloor n / 2\rfloor}^{\lfloor n / 2\rfloor} \\ & \vdots \\ \mathcal{G}_{n-2} &=U_{0}^{n-1} \oplus U_{1}^{n-1} \\ \mathcal{G}_{n} &=U_{0}^{n} \end{aligned}$$$$\mathcal{G}=\left(\stackrel{\lfloor n / 2\rfloor}{\bigoplus} \bigoplus_{j=0}^{k} U_{j}^{k}\right) \bigoplus\left(\bigoplus_{k>\lfloor n / 2\rfloor} \bigoplus_{j=0}^{n-k} U_{j}^{k}\right)$$ -->]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 计算机 </tag>
            
            <tag> 北大 </tag>
            
            <tag> 抽象代数 </tag>
            
            <tag> 表示论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论文笔记[7]——Privacy Analysis on Microblogging Online Social Networks: A Survey</title>
      <link href="/2019/07/08/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-7-%E2%80%94%E2%80%94Privacy-Analysis-on-Microblogging-Online-Social-Networks-A-Survey/"/>
      <content type="html"><![CDATA[<blockquote><p>文章：Oukemeni S, Rifà-Pous H, Puig J M M. Privacy Analysis on Microblogging Online Social Networks: A Survey[J]. ACM Computing Surveys (CSUR), 2019, 52(3): 60.</p></blockquote><blockquote><p>社交网络的隐私性调研</p></blockquote><a id="more"></a><h2 id="社交网络及其隐私性定义">社交网络及其隐私性定义</h2><h3 id="什么是社交网络osn">什么是社交网络（OSN）？</h3><p>社交网络（Online Social Network）（以下简称OSN）是为用户提供以下服务的网络应用：</p><ul><li>可创建半公开（原文用 semi-public）的档案；</li><li>可以加好友（creat connections）；</li><li>可以在系统中发布一些动态，并且可以查看一些其他用户发布的动态；</li></ul><h3 id="osn的隐私性">OSN的隐私性</h3><h4 id="微观user-related-threats">微观：user-related threats</h4><p>用户的恐慌：</p><ul><li>用户自己会发布一些敏感信息；</li><li>对手可以从不同用户的数据中挖掘一些隐藏的关系，也可以的从不同OSN中获取更多信息；</li></ul><h4 id="宏观system-provider-related-threats">宏观：system provider-related threats</h4><p>数据库的恐慌：</p><ul><li>OSN们收集了比他们所需要的更多的敏感信息；</li><li>OSN中的数据用户无法彻底删除；</li></ul><h3 id="隐私保护">隐私保护</h3><ul><li>匿名化 Anonymization：去除可以直接识别用户的敏感信息或添加一些随机扰动；</li><li>去中心化 Decentralization：分散架构，避免数据及其使用权过于集中；</li><li>加密 Encryption：保护用户数据；</li><li>信息安全 Information security：维持数据的保密性、完整性和有效性；</li><li>Fine-grained隐私与访问控制：没懂QAQ，大概是要让用户享受服务的同时隐私不被泄露？</li><li>用户意识与行为变化 User awarness and hange of behavior：提高用户意识…听着像废话？</li></ul><h3 id="osn相关的隐私法律法规">OSN相关的隐私法律法规</h3><p>然后第一句话就是：Currently, there are no specific privacy regulations or laws for OSNs…</p><p>对于隐私性，有以下几种规则：</p><ul><li>Organization of Economic Cooperation and Development(OECD)</li><li>General Data Protection Regulation(GDPR)</li><li>Personal Information Protection and Electronic Document Act(PIPEDA)</li><li>Information System Audit and Control Association(ISACA)</li><li>ISO/IEC 29100:2011</li></ul><h2 id="评价隐私的指标">评价隐私的指标</h2><ul><li>六种保护隐私的方面</li></ul><table><thead><tr class="header"><th>1. 匿名</th><th>2. 去中心化</th><th>3. 加密</th><th>4. 信息安全</th><th>5. Fine-grained隐私与访问控制</th><th>6. 用户意识与行为变化</th></tr></thead><tbody></tbody></table><ul><li>OSN在此方面的七个特征</li></ul><table><thead><tr class="header"><th>1. 提供的服务</th><th>2. 架构</th><th>3. 存储与应答技术</th><th>4. 加密机制与秘钥管理</th><th>5. 安全目的</th><th>6. 隐私目的</th><th>7. 功能 Functionalities</th></tr></thead><tbody></tbody></table><h3 id="提供的服务种类">提供的服务种类</h3><h3 id="架构">架构</h3><ol type="1"><li>中心化架构；</li><li>非中心化架构；</li><li>混合架构；</li></ol><h3 id="存储与应答技术">存储与应答技术</h3><ol type="1"><li>中心服务器+单一权限；</li><li>联邦服务器？(federated servers)+多重权限；</li><li>非中心化架构；</li><li>混合架构；</li></ol><h3 id="加密机制与秘钥管理">加密机制与秘钥管理</h3><ol type="1"><li>对称加密；</li><li>非对称加密：公钥+私钥；</li></ol><h3 id="安全目的">安全目的</h3><ol type="1"><li>可获取性：确保数据是可访问、可获取的；</li><li>完整性：保证数据的可靠性，避免未被授权的更改；</li><li>创建用户档案：用户在系统中能注册；</li><li>用户身份验证：入口的权限认证；</li></ol><h3 id="访问控制与隐私目的">访问控制与隐私目的</h3><ol type="1"><li>档案是否默认可见；</li><li>是否可以更改档案的可见性；</li><li>动态是否默认可见；</li><li>是否可以更改动态的可见性；</li><li>系统管理员的访问权限：系统管理员是否能任意获取用户数据；</li><li>存储控制：用户是否能够控制数据的存储；</li></ol><h3 id="功能-functionalities">功能 Functionalities</h3><ol type="1"><li>档案管理：创建和管理用户档案；</li><li>好友关系：添加/删除好友；</li><li>动态和私信：发布动态和私信；</li><li>搜索功能：搜索用户、状态、评论等；<font color="red">可能会泄露用户的偏好信息</font></li><li>评论与回复功能：<font color="red">可能会泄露用户的Social graph</font>；</li><li>提到其他用户：<span class="citation" data-cites="其他用户的功能">@其他用户的功能</span>；<font color="red">泄露social graph</font></li><li>关注话题/设置兴趣：<font color="red">泄露用户的偏好信息</font></li></ol><h2 id="osn-现况">OSN 现况</h2><p>文中将OSN分为实际存在的和不存在的两种：</p><center><img src="/img/blog-graph/Privacy Analysis on Microblogging Online Social Networks A Survey - OSNs.png" alt="文中提到的社交网络"></center><p>文中对这些社交网络一一进行了评述，此处不展开。</p><h2 id="osns-之间的比较与评估">OSNs 之间的比较与评估</h2><h3 id="服务种类架构存储技术">服务种类、架构、存储技术</h3><center><img src="/img/blog-graph/Privacy Analysis on Microblogging Online Social Networks A Survey - service.png" width="600" alt="Service provided, architecture, and storage"></center><h3 id="安全目的-security-goals">安全目的 Security goals</h3><center><img src="/img/blog-graph/Privacy Analysis on Microblogging Online Social Networks A Survey - security goals.png" width="600" alt="Security goals"></center><h3 id="功能-functionalities-1">功能 Functionalities</h3><center><img src="/img/blog-graph/Privacy Analysis on Microblogging Online Social Networks A Survey - functionalities.png" width="600" alt="Functionalities"></center><h3 id="隐私状况-privacy-violation">隐私状况 Privacy Violation</h3><center><img src="/img/blog-graph/Privacy Analysis on Microblogging Online Social Networks A Survey - privacy violation.png" width="600" alt="真实存在的OSN的隐私状况"></center><center><img src="/img/blog-graph/Privacy Analysis on Microblogging Online Social Networks A Survey - privacy violation 2.png" width="600" alt="Non Deployed OSNs"></center><h3 id="comarison-of-systems">Comarison of Systems</h3><blockquote><p>下图对所有上文提到的OSN的功能、风险以及隐私保护三方面进行了比较。</p></blockquote><center><img src="/img/blog-graph/Privacy Analysis on Microblogging Online Social Networks A Survey - comparison graph.png" width="600" alt=""></center>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 计算机 </tag>
            
            <tag> 北大 </tag>
            
            <tag> 社会计算 </tag>
            
            <tag> 论文笔记 </tag>
            
            <tag> 经济学 </tag>
            
            <tag> 隐私 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论文笔记[6]——Fair assignment of indivisible objects under ordinal preferences</title>
      <link href="/2019/06/04/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-6-%E2%80%94%E2%80%94Fair-assignment-of-indivisible-objects-under-ordinal-preferences/"/>
      <content type="html"><![CDATA[<blockquote><p>文章：Aziz H , Gaspers S , Mackenzie S , et al. Fair assignment of indivisible objects under ordinal preferences[J]. Artificial Intelligence, 2015, 227:71-92.</p></blockquote><blockquote><p>离散物品，公平分配</p></blockquote><a id="more"></a><p><img src="/img/blog-graph/Fair assignment of indivisible objects under ordinal preferences-主要结果.png" alt="主要结果"></p><h2 id="基础知识">基础知识</h2><ul><li>Assignment problem 是一个三元组 <span class="math inline">\((N,O,\succeq)\)</span>：<ul><li><span class="math inline">\(N=\{1,2,\cdots,n\}\)</span>：参与者；</li><li><span class="math inline">\(O=\{o_1,\cdots,o_m\}\)</span>：待分配物品（离散物品）；</li><li><span class="math inline">\(\succeq=\{\succeq_1,\cdots,\succeq_n\}\)</span>：人对物品的偏好（单物品偏好，Ordinal preference）；</li></ul></li><li>考虑到偏好可能是非严格的，因此将所有被选手 <span class="math inline">\(i\)</span> 视为等值的物品记为一个等价类；<ul><li>选手 <span class="math inline">\(i\)</span> 的等价类共有 <span class="math inline">\(k_i\)</span> 个；</li><li>按照顺序为 <span class="math inline">\(E_i^1,\cdots,E_i^{k_i}\)</span>；</li><li>若某个 <span class="math inline">\(E_i^j\)</span> 只包含一个物品 <span class="math inline">\(o\)</span>，则我们在表示该等价类时，不区分 <span class="math inline">\(o\)</span> 与 <span class="math inline">\(\{o\}\)</span> 的区别；</li><li>若所有 <span class="math inline">\(E_i^j\)</span> 都只包含一个物品，则此时的偏好是 <code>严格</code> 的。</li></ul></li><li>设有 <span class="math inline">\(O&#39;\subseteq O\)</span>，定义如下两个记号：<ul><li><span class="math inline">\(\max_{\succeq_i}(O&#39;)=\{o\in O&#39;:o\succeq_i o&#39;, \forall o&#39;\in O&#39;\}\)</span>；</li><li><span class="math inline">\(\min_{\succeq_i}(O&#39;)=\{o\in O&#39;:o&#39;\succeq_i o, \forall o&#39;\in O&#39;\}\)</span>；</li></ul></li><li>一个<strong>分数分配</strong>（fractional assignment）<span class="math inline">\(p\)</span> 是指一个 <span class="math inline">\((n\times m)\)</span> 双随机矩阵 <span class="math inline">\([p(i)(o_j)]\)</span>；<ul><li>实际上就是 Bogomolnaia 和 Moulin 所著 “A New Solution to the Random Assignment Problem” 一文中的随机性分配（random assignment），参见 <a href="/2018/04/05/论文笔记-1-——A%20New%20Solution%20to%20the%20Random%20Assignment%20Problem/">论文笔记[1]——随机分配问题的PS算法和依次有效性</a> 一文；<ul><li>本文中对此的理解与 “New solution” 一文不同，没有以概率的眼光看待 <span class="math inline">\(p(i)(o_j)\)</span>，而是认为 <span class="math inline">\(i\)</span> 得到了 <span class="math inline">\(o_j\)</span> 的一部分。两种思路其实是等价的；</li></ul></li><li>一个分数分配是 <code>离散</code> 的（discrete），如果所有的 <span class="math inline">\(p(i)(o_j)\)</span> 不是 <span class="math inline">\(1\)</span> 就是 <span class="math inline">\(0\)</span>。</li><li><strong>平均分配</strong>（uniform assignment）是指 “每个人，都得到每个物品的 <span class="math inline">\(1/n\)</span>” 的一个分数分配；</li></ul></li></ul><hr><ul><li>随机占优（stochastic dominance）的定义如下：</li></ul><blockquote><p><strong>Def 1.（随机占优）</strong> 参考 <a href="/2018/04/05/论文笔记-1-——A%20New%20Solution%20to%20the%20Random%20Assignment%20Problem/">论文笔记[1]——随机分配问题的PS算法和依次有效性</a> 一文中随机占优关系的定义。 这里记为 <span class="math inline">\(p(i)\succeq_i^{SD} q(i)\)</span>。</p></blockquote><ul><li><code>严格随机占优</code> 就是指 <span class="math inline">\(p(i)\)</span> 随机占优于 <span class="math inline">\(q(i)\)</span>，但反之不然；</li><li>所有与偏好 <span class="math inline">\(\succeq_i\)</span> 相容的效用函数构成的集合记为 <span class="math inline">\(\mathcal{U}(\succeq_i)\)</span>。</li></ul><blockquote><p><strong>Def 2.（无嫉妒）</strong> 若对 <span class="math inline">\(\forall i\)</span>，都有 <span class="math display">\[u_i(p(i))\geqslant u_i(p(j)),~\forall j\in N\]</span> 则称 <span class="math inline">\(p\)</span> 是<strong>无嫉妒</strong>的。（基本上都是这个定义吧）</p></blockquote><blockquote><p><strong>Def 3.（Proportional）</strong> 若 <span class="math inline">\(\forall i\)</span>，都有 <span class="math display">\[u_i(p(i))\geqslant u_i(O)/n\]</span> 则称 <span class="math inline">\(p\)</span> 是 <strong>Proportional</strong> 的。（可以将其翻译为“按比例满足”）</p></blockquote><ul><li>每个单物品偏好都可以进行 <code>合理</code> （responsive）扩张，在 <span class="math inline">\(O\)</span> 的幂集上得到一个 <code>合理</code> 的偏好，记为 <span class="math inline">\(\succeq^{RS}_i\)</span>。<ul><li><code>合理性</code> 的定义参见 <a href="/2019/03/10/论文笔记-3-——Computing-a-small-agreeable-set-of-indivisible-items/">论文笔记[3]——可接受集的定义与计算</a> 一文中的 <strong>Def 3</strong>。</li></ul></li></ul><hr><p>现在给出如下定理：</p><blockquote><p><strong>Th 1.（随机占优的等价命题）</strong> 对于 <code>离散</code> 的分配 <span class="math inline">\(p\)</span> 和 <span class="math inline">\(q\)</span>，下列命题等价：</p><ol type="1"><li><span class="math inline">\(p(i)\succeq_i^{SD} q(i)\)</span>；</li><li><span class="math inline">\(\forall u_i\in \mathcal{U}(\succeq_i)\)</span>，有 <span class="math inline">\(u(p(i))\geqslant u_i(q_i))\)</span>；</li><li><span class="math inline">\(p(i)\succeq_i^{RS} q(i)\)</span>；</li></ol><blockquote><p><strong>Proof.</strong> 首先，1 <span class="math inline">\(\iff\)</span> 2 是显然的；</p><p>接下来我们证明 3 <span class="math inline">\(\Rightarrow\)</span> 2：由于 <span class="math inline">\(p(i)\succeq_i^{RS} q(i)\)</span>，故可以建立一个从 <span class="math inline">\(q(i)\)</span> 到 <span class="math inline">\(p(i)\)</span> 的单射，且 <span class="math inline">\(p(i)\)</span> 中的物品比 <span class="math inline">\(q(i)\)</span> 中的对应物品更受 <span class="math inline">\(i\)</span> 的喜爱（即效用值更大）。因此 2 成立。</p><p>最后我们证明 1 <span class="math inline">\(\Rightarrow\)</span> 3：假设 <span class="math inline">\(p(i)\not\succeq_i^{RS} q(i)\)</span>。<font color="red">以 <span class="math inline">\(V=q(i)\cup p(i)\)</span> 为结点构造二分图 <span class="math inline">\(G(V,E)\)</span>，其中 <span class="math inline">\(\{o,o&#39;\}\in E\)</span> 当且仅当 <span class="math inline">\(o\in q(i)\)</span>，<span class="math inline">\(o&#39;\in p(i)\)</span>，且 <span class="math inline">\(o&#39;\succeq_i o\)</span>。</font>由于 <span class="math inline">\(p(i)\not\succeq_i^{RS} q(i)\)</span>，故 <span class="math inline">\(G\)</span> 不存在填满 <span class="math inline">\(q(i)\)</span> 的匹配，因而不存在完美匹配。由 Hall 定理，可得结论。</p></blockquote></blockquote><hr><h2 id="公平性定义框架">公平性定义框架</h2><h3 id="proportional">Proportional</h3><h4 id="弱-sd-proportional"><code>弱 SD-proportional</code></h4><blockquote><p>没有人更 SD-喜欢 <code>平均分配</code>，即 <span class="math inline">\(\lnot[(1/n,,cdots,1/n)\succ_i^{SD} p(i)]\)</span>，<span class="math inline">\(\forall i\in N\)</span>；</p></blockquote><h4 id="可能-proportional"><code>可能 proportional</code></h4><blockquote><p>对每个人，都存在效用函数，使得在该效用下这个分配是 <code>proportional</code> 的，即 <span class="math inline">\(\forall i\in N\)</span>，<span class="math inline">\(\exists u_i\in\mathcal{U}(\succeq_i)\)</span>，s.t. <span class="math inline">\(u_i(p(i))\geqslant u_i(O)/n\)</span>；</p></blockquote><h4 id="sd-proportional"><code>SD proportional</code></h4><blockquote><p>每个人相比起 <code>平均分配</code>，都更喜欢 <span class="math inline">\(p\)</span>，即 <span class="math inline">\(p(i)\succeq_i^{SD} (1/n,\cdots,1/n)\)</span>，<span class="math inline">\(\forall i\in N\)</span>；</p></blockquote><h4 id="必然-proportional"><code>必然 proportional</code></h4><blockquote><p>对每个人来说，只要是与偏好相容的效用函数，效用都不低于 <code>平均分配</code>，即 <span class="math inline">\(\forall i\in N\)</span>，<span class="math inline">\(\forall u_i\in\mathcal{U}(\succeq_i)\)</span>，总有 <span class="math inline">\(u_i(p(i))\geqslant u_i(O)/n\)</span>；</p></blockquote><h3 id="无嫉妒">无嫉妒</h3><h4 id="弱-sd-无嫉妒"><code>弱 SD-无嫉妒</code></h4><blockquote><p>每个人都不 SD-严格喜欢其他人所得的物品，即 <span class="math inline">\(\lnot[p(j)\succ_i^{SD} p(i)]\)</span>，<span class="math inline">\(\forall i\in N\)</span>；</p></blockquote><h4 id="可能-sd-无嫉妒"><code>可能 SD-无嫉妒</code></h4><blockquote><p>对每个人，都存在与其偏好相容的效用函数，使得在该函数下，这个分配是无嫉妒的，即 <span class="math inline">\(\forall i\in N\)</span>，<span class="math inline">\(\exists u_i\in\mathcal{U}(\succeq_i)\)</span>，s.t. <span class="math inline">\(u_i(p(i))\geqslant u_i(p(j))\)</span>，<span class="math inline">\(\forall j\in N\)</span>。</p></blockquote><h4 id="可能完全无嫉妒"><code>可能完全无嫉妒</code></h4><blockquote><p>对每个人 <span class="math inline">\(i\)</span>，都存在一个集合的弱序（weak order），使得该弱序与 <span class="math inline">\(i\)</span> 的偏好的某个 responsive 扩展相容，且在该弱序下，<span class="math inline">\(i\)</span> 认为自己得到的东西优于其他人。</p></blockquote><ul><li>（虽然一眼看不懂是啥，但是后面好像证明了这玩意儿和 <code>弱 SD-无嫉妒</code> 等价…</li></ul><h4 id="sd-无嫉妒"><code>SD-无嫉妒</code></h4><blockquote><p>每个人都不会 SD-更喜欢其他人得到的东西，即 <span class="math inline">\(\forall i\in N\)</span>，总有 <span class="math inline">\(p(i)\succeq_i^{SD} p(j)\)</span>，<span class="math inline">\(\forall j\in N\)</span>；</p></blockquote><h4 id="必然无嫉妒"><code>必然无嫉妒</code></h4><blockquote><p>所有与参与者偏好相容的效用函数，都会使得该分配是无嫉妒的，即 <span class="math inline">\(\forall i,j\in N\)</span>，<span class="math inline">\(\forall u_i\in\mathcal{U}(\succeq_i)\)</span>，有 <span class="math inline">\(u_i(p(i))\geqslant u_i(p(j))\)</span>；</p></blockquote><h4 id="必然完全无嫉妒"><code>必然完全无嫉妒</code></h4><blockquote><p>对每个人 <span class="math inline">\(i\)</span>，对于任一个集合的全序（total order），只要该全序与 <span class="math inline">\(i\)</span> 的偏好的某个 responsive 扩展相容，那么在该全序下，<span class="math inline">\(i\)</span> 就会认为自己得到的东西优于其他人。</p></blockquote><ul><li>（虽然一眼看不懂是啥，但是后面好像证明了这玩意儿和 <code>SD-无嫉妒</code> 等价…</li></ul><hr><h2 id="以上定义之间的关系">以上定义之间的关系</h2><blockquote><p><strong>Th 2.（等价关系）</strong> 对于任意数量的参与者和物品，有：</p><ol type="1"><li><code>弱 SD-proportional</code> <span class="math inline">\(\iff\)</span> <code>可能 proportional</code>；</li><li><code>SD-proportional</code> <span class="math inline">\(\iff\)</span> <code>必然proportional</code>；</li><li><code>弱 SD-无嫉妒</code> <span class="math inline">\(\iff\)</span> <code>可能完全无嫉妒</code>；</li><li><code>SD-无嫉妒</code> <span class="math inline">\(\iff\)</span> <code>必然无嫉妒</code> <span class="math inline">\(\iff\)</span> <code>必然完全无嫉妒</code>。</li></ol></blockquote><blockquote><p><strong>Th 3.（强弱关系）</strong> 对于以上公平性定义，有：</p><ol type="1"><li><code>SD-无嫉妒</code> <span class="math inline">\(\Rightarrow\)</span> <code>SD-proportional</code>；</li><li><code>SD-proportional</code> <span class="math inline">\(\Rightarrow\)</span> <code>弱 SD-proportional</code>；</li><li><code>可能无嫉妒</code> <span class="math inline">\(\Rightarrow\)</span> <code>弱 SD-proportional</code>；</li><li><code>可能无嫉妒</code> <span class="math inline">\(\Rightarrow\)</span> <code>弱 SD-无嫉妒</code>。</li></ol></blockquote><p>对于两个参与者的情形，有：</p><blockquote><p><strong>Th 4.（退化情形）</strong> 只有 <span class="math inline">\(2\)</span> 个参与者时，有：</p><ol type="1"><li><code>proportional</code> <span class="math inline">\(\iff\)</span> <code>无嫉妒</code>；</li><li><code>SD-proportional</code> <span class="math inline">\(\iff\)</span> <code>SD-无嫉妒</code>；</li><li><code>可能无嫉妒</code> <span class="math inline">\(\iff\)</span> <code>弱 SD-proportional</code>；</li><li><code>可能无嫉妒</code> <span class="math inline">\(\iff\)</span> <code>弱 SD-无嫉妒</code>。</li></ol></blockquote><hr><p>可将几种定义的关系总结如下：</p><center><img src="/img/blog-graph/Fair assignment of indivisible objects under ordinal preferences：几种定义的关系.png" alt="几种定义的关系图"></center><hr><h2 id="计算复杂度">计算复杂度</h2><p>主要关心的问题：</p><ul><li>是否存在满足某一公平性条件的离散分配；<ul><li>若存在，如何得到这样的分配；</li></ul></li><li>验证给定分配方案是否满足某一公平性定义；<ul><li>这个显然很容易做…</li></ul></li></ul><blockquote><p><strong>Remark 1.</strong> 对于所有的公平性定义，都可以在 <span class="math inline">\(m\)</span> 和 <span class="math inline">\(n\)</span> 的多项式时间内验证某一给定分配方案是否满足该公平性定义。</p></blockquote><blockquote><p><strong>Remark 2.</strong> 对于常数个物品和任一种公平性定义，均可以在多项式时间内判定是否存在满足条件的离散分配方案。</p></blockquote><blockquote><p><strong>Th 5.</strong> 若 <span class="math inline">\(p\)</span> 是一个 <code>SD-proportional</code> 的分配，则 <span class="math inline">\(n~|~m\)</span>，且分配方案中一定是每个人得到 <span class="math inline">\(m/n\)</span> 个物品。</p></blockquote><blockquote><p><strong>Th 6.</strong> 可以在多项式时间内判定是否存在 <code>SD-proportional</code> 的分配，即便偏好不是严格的。（原文用 agents are allowed to express indifference between objects.）</p></blockquote><blockquote><p><strong>Th 7.</strong> 在严格的偏好下，存在 <code>弱 SD-proportional</code> 的分配，当且仅当：</p><ol type="1"><li><span class="math inline">\(m=n\)</span> 且存在一个匹配方案，使得每个人都不会得到他最不喜欢的物品；</li><li><span class="math inline">\(m&gt;n\)</span>。</li></ol><p>进一步，该过程显然是多项式时间的，这说明 <code>弱 SD-prop</code> 是可以在多项式时间内判定存在性的。</p></blockquote><blockquote><p><strong>Th 8.</strong> 可以在多项式时间内判定是否存在 <code>SD-proportional</code> 的分配，即便偏好不是严格的。（原文用 agents are allowed to express indifference between objects.）</p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 计算机 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 北大 </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 社会计算 </tag>
            
            <tag> 论文笔记 </tag>
            
            <tag> 经济学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论文笔记[5]——The undercut procedure: an algorithm for the envy-free division of indivisible items</title>
      <link href="/2019/05/25/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-5-%E2%80%94%E2%80%94The-undercut-procedure-an-algorithm-for-the-envy-free-division-of-indivisible-items/"/>
      <content type="html"><![CDATA[<blockquote><p>Brams S J, Kilgour D M, Klamler C. The undercut procedure: an algorithm for the envy-free division of indivisible items[J]. Social Choice and Welfare, 2012, 39(2-3): 615-631.</p></blockquote><blockquote><p>离散资源，无嫉妒划分</p></blockquote><a id="more"></a><h2 id="概要">概要</h2><ul><li>两位参与者 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span>，分割一整个物品集 <span class="math inline">\(X\)</span>；</li><li>二者的偏好均是 <span class="math inline">\(X\)</span> 幂集 <span class="math inline">\(\mathcal{X}\)</span> 上的全序；</li><li>文中提出UP算法，必定能得到一个 <span class="math inline">\(X\)</span> 的无嫉妒划分：<ul><li>无嫉妒的定义：每个人都觉得自己的比对方的好；</li><li>即使 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 的偏好完全相同也可以得到；</li></ul></li><li>基本思路：Undercut：<ul><li>一人提出proposal，另一人undercut。</li></ul></li></ul><h2 id="基础知识">基础知识</h2><p>记号：</p><ul><li><span class="math inline">\(i\)</span> 的单物品偏好用 <span class="math inline">\(P_i\)</span> 表示，每个 <span class="math inline">\(P_i\)</span> 都是 <code>严格</code>、 <code>完全</code> 的；</li><li><span class="math inline">\(i\)</span> 的偏好用 <span class="math inline">\(\succeq_i\)</span> 表示；</li><li><span class="math inline">\(S\)</span> 的补集用 <span class="math inline">\(-S\)</span> 表示。</li></ul><p>相关定义：</p><blockquote><p><strong>Def 1.</strong> <span class="math inline">\(\mathcal{X}\)</span> 上的偏好 <span class="math inline">\(\succeq\)</span> 称为是<strong>合理</strong>（responsive）的，若 <span class="math inline">\(\forall S\in\mathcal{X}\)</span> 和 <span class="math inline">\(\forall x\in X\)</span>，<span class="math inline">\(y\in X\backslash S\)</span>，总有：</p><ol type="1"><li><span class="math inline">\(S\succ S\backslash \{x\}\cup\{y\}\iff x~P~y\)</span>；</li><li><span class="math inline">\(S\backslash \{x\}\cup\{y\}\succ S\iff y~P~x\)</span>；</li><li><span class="math inline">\(S\succ S\backslash\{x\}\)</span>。（<strong>单调性</strong>，monotonic）</li></ol></blockquote><blockquote><p><strong>Def 2.</strong> 令 <span class="math inline">\(S,T\subseteq X\)</span>，<span class="math inline">\(S\neq T\)</span>，令 <span class="math inline">\(P\)</span> 是 <span class="math inline">\(X\)</span> 上的一个严格的序。如果：</p><ul><li>存在一个单射 <span class="math inline">\(\sigma_{T,S}: T\backslash S\to S\backslash T\)</span>，s.t. <span class="math inline">\(\forall x\in T\backslash S, \sigma_{T,S}(x)~P~x\)</span>；</li></ul><p>则称 <span class="math inline">\(T\)</span> <strong>依次劣于</strong>（ordinally less）<span class="math inline">\(S\)</span>，记作 <span class="math inline">\(T\leqslant_{OL} S\)</span>。</p></blockquote><ul><li>简言之，<span class="math inline">\(S\leqslant _{OL}T\)</span> 的意思就是存在 <span class="math inline">\(S\to T\)</span> 的一个映射，按照这种对应，<span class="math inline">\(S\)</span> 中的每个物品都不如 <span class="math inline">\(T\)</span> 中的对应物品。（是 <span class="math inline">\(S\)</span> 比 <span class="math inline">\(T\)</span> 差了很多的意思）</li></ul><blockquote><p><strong>Def 3.</strong> 参与者 <span class="math inline">\(i\)</span> 认为 <span class="math inline">\(S\subseteq X\)</span> 是<strong>至少值50%</strong> 的，如果 <span class="math inline">\(S\succeq_i -S\)</span>。</p></blockquote><blockquote><p><strong>Def 4.</strong> 集合 <span class="math inline">\(S\subseteq X\)</span> 对 <span class="math inline">\(i\)</span> 来说是一个<strong>minimal bundle</strong>，如果：</p><ol type="1"><li><span class="math inline">\(S\succeq_i -S\)</span>；</li><li><span class="math inline">\(\forall T\leqslant _{OL} S\)</span>，总有 <span class="math inline">\(-T\succeq_i T\)</span>。</li></ol></blockquote><blockquote><p><strong>Def 5.</strong> <span class="math inline">\(\forall S\subseteq X\)</span>，划分 <span class="math inline">\((S,-S)\)</span> 是<strong>无嫉妒</strong>的，如果：</p><ol type="1"><li><span class="math inline">\(S\succeq_A -S\)</span>；</li><li><span class="math inline">\(-S\succeq_B S\)</span>。</li></ol></blockquote><blockquote><p><strong>Def 6.</strong> 一个无嫉妒划分 <span class="math inline">\((S,-S)\)</span> 称为是<strong>平凡</strong>（trivial）的，如果：</p><ol type="1"><li><span class="math inline">\(S\sim_A -S\)</span>；</li><li><span class="math inline">\(S\sim_B -S\)</span>。</li></ol></blockquote><h2 id="upundercut-procedure">UP：Undercut Procedure</h2><h3 id="up算法的步骤">UP算法的步骤</h3><ol type="1"><li>初始物品堆为 <span class="math inline">\(X\)</span>，<span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 分别取当前物品堆中选取各自当前最喜欢的物品 <span class="math inline">\(x_A\)</span> 和 <span class="math inline">\(x_B\)</span>：<ul><li>若 <span class="math inline">\(x_A\neq x_B\)</span>：将 <span class="math inline">\(x_A\)</span> 分配给 <span class="math inline">\(A\)</span>，<span class="math inline">\(x_B\)</span> 分配给 <span class="math inline">\(B\)</span>；</li><li>若 <span class="math inline">\(x_A=x_B\)</span>：将该物品放入待定区，记为 <span class="math inline">\(I_c\subseteq X\)</span>；</li></ul></li><li>继续执行 1，直到所有物品都被标记为 <span class="math inline">\(A\)</span>，<span class="math inline">\(B\)</span> 或 <span class="math inline">\(I_c\)</span>；</li><li>考察 <span class="math inline">\(I_c\)</span>：<ul><li>若 <span class="math inline">\(I_c\)</span> 为空，则分配结束…（这应该是 <del>废话</del> 显然的）；</li><li>若 <span class="math inline">\(I_c\)</span> 非空，记参与者 <span class="math inline">\(i\)</span>（<span class="math inline">\(i=A,B\)</span>）在 <span class="math inline">\(I_c\)</span> 中的minimal bundle集合为 <span class="math inline">\(MB_i\)</span>，<span class="math inline">\(i\)</span> 将 <span class="math inline">\(MB_i\)</span> （私密地）提交给裁判；</li></ul></li><li>若 <span class="math inline">\(MB_A\neq MB_B\)</span>，则 <span class="math inline">\(i\)</span> 将 <span class="math inline">\(i\)</span> 将 <span class="math inline">\(MB_i\)</span> 中的偏好顺序提交给裁判。<ul><li>任取一名选手（例如是 <span class="math inline">\(A\)</span>）；</li><li>取 <span class="math inline">\(MB_A\)</span> 中排名最高的集合，记为 <span class="math inline">\(T\)</span>：<ul><li>若 <span class="math inline">\(T\notin MB_B\)</span>，则称其为一个proposal，此时称 <span class="math inline">\(A\)</span> 为一个proposer；</li><li>若 <span class="math inline">\(T\in MB_B\)</span>，则转而考虑 <span class="math inline">\(MB_B\)</span> 中排名最高的集合，判断其是否属于 MB_A$…反复进行；</li><li>由于 <span class="math inline">\(MB_A\neq MB_B\)</span>，故反复进行上述步骤一定能得到一个 <font color="blue"><span class="math inline">\(MB_A\)</span> 中的排第一，但 <span class="math inline">\(MB_B\)</span> 中不排第一</font> 或者 <font color="red"><span class="math inline">\(MB_B\)</span> 中的排第一，但 <span class="math inline">\(MB_A\)</span> 中不排第一</font> 的集合，将其作为proposal。</li></ul></li></ul></li><li>若 <span class="math inline">\(MB_A=MB_B\)</span>：<ul><li>若 <span class="math inline">\(\exists i\)</span>，<span class="math inline">\(\exists S\in MB_i\)</span>，s.t. <span class="math inline">\(-S\in MB_i\)</span>，则此时将 <span class="math inline">\(S\)</span> 做为 proposal，<span class="math inline">\(i\)</span> 为proposer；</li><li>若 <span class="math inline">\(\forall i\)</span>，<span class="math inline">\(\not\exists S\in MB_i\)</span>，s.t. <span class="math inline">\(-S\in MB_i\)</span>，则此时随意选择一个minimal bundle <span class="math inline">\(S\)</span> 做为 proposal；</li></ul></li><li>假设 <span class="math inline">\(S\)</span> 是proposal，<span class="math inline">\(A\)</span> 是proposer，则 <span class="math inline">\(B\)</span> 的undercut操作为：<ol type="1"><li><strong>（Accepting）</strong>若 <span class="math inline">\(-S\)</span> 对于 <span class="math inline">\(B\)</span> 是至少价值 50% 的，则 <span class="math inline">\(B\)</span> 可以同意 <span class="math inline">\(I_c\)</span> 的划分 <span class="math inline">\((S,-S)\)</span>；</li><li><strong>（Undercutting）</strong>在所有比 <span class="math inline">\(S\)</span> ordinally less的集合中，取 <span class="math inline">\(B\)</span> 最喜欢的集合 <span class="math inline">\(T\)</span>，重新提出划分 <span class="math inline">\((-T,T)\)</span>；</li></ol></li><li>最终得到一个划分 <span class="math inline">\((F,-F)\)</span>，将 <span class="math inline">\(F\)</span> 分配给 <span class="math inline">\(A\)</span>，<span class="math inline">\(-F\)</span> 分配给 <span class="math inline">\(B\)</span>。</li></ol><h3 id="关于up的讨论">关于UP的讨论</h3><blockquote><p><strong>Th 1.</strong> 存在一个非平凡的无嫉妒划分，当且仅当 <span class="math inline">\(MB_A\neq MB_B\)</span>。并且该情形下，UP给出的是一个无嫉妒划分。</p><blockquote><p><strong>Proof.</strong> <span class="math inline">\(\Leftarrow\)</span>：假设存在一个无嫉妒划分 <span class="math inline">\((S,-S)\)</span>，则必定存在一个参与者更喜欢 <span class="math inline">\(S\)</span>（不妨设为 <span class="math inline">\(A\)</span>），即 <span class="math inline">\(S\succ_A -S\)</span>。 - 若 <span class="math inline">\(S\notin MB_B\)</span>，则 <span class="math inline">\(MB_A\neq MB_B\)</span>，<span class="math inline">\(\Rightarrow\)</span> 得证； - 若 <span class="math inline">\(S\in MB_B\)</span>，则 <span class="math inline">\(S\succeq_B -S\)</span>，结合 <span class="math inline">\((S,-S)\)</span> 是一个无嫉妒划分，应有 <span class="math inline">\(-S\succeq_B S\)</span>，因此 <span class="math inline">\(S\sim_B -S\)</span>。现取 <span class="math inline">\(T\subset X\)</span>，s.t. 对 <span class="math inline">\(B\)</span> 而言有 <span class="math inline">\(T\leqslant_{OL} -S\)</span>（同时亦有 <span class="math inline">\(S\leqslant_{OL} -T\)</span>），则若 <span class="math inline">\(\succeq_B\)</span> 是 <code>合理</code> 的，应有 <span class="math inline">\(-T\succ_B T\)</span>，因此 <span class="math inline">\(-S\)</span> 是 <span class="math inline">\(B\)</span> 的 <code>minimal bundle</code>。即 <span class="math inline">\(-S\in MB_B\)</span>，但 <span class="math inline">\(-S\)</span> 显然不在 <span class="math inline">\(MB_A\)</span> 中，因此 <span class="math inline">\(MB_B\neq MB_A\)</span>。</p><p><span class="math inline">\(\Rightarrow\)</span>：若存在 <span class="math inline">\(S\)</span>，s.t. <span class="math inline">\(S\in MB_A\)</span> 但 <span class="math inline">\(S\notin MB_B\)</span>，则有且仅有以下两种互斥的情形：</p><ol type="1"><li><span class="math inline">\(S\succ_B -S\)</span>，此时存在一个 <span class="math inline">\(T\leqslant_{OL} S\)</span>，s.t. <span class="math inline">\(T\succeq _B -T\)</span>，即 <span class="math inline">\(T\)</span> 对 <span class="math inline">\(B\)</span> 来说 <code>至少价值50%</code>；</li><li><span class="math inline">\(-S\succ_B T\)</span>。</li></ol><p>由于以上两种情况是互斥的，因此有且仅有一个发生。然而，在以上两种中的每一种情况下，<span class="math inline">\(B\)</span> 都得到了 <code>至少价值50%</code> 的集合。同时，<span class="math inline">\(A\)</span> 也得到了 <code>至少价值50%</code> 的集合：</p><ul><li>若 <span class="math inline">\(B\)</span> 接受了 <span class="math inline">\(A\)</span> 的proposal，则 <span class="math inline">\(A\)</span> 得到了 <code>至少价值50%</code> 的集合；</li><li>若 <span class="math inline">\(B\)</span> undercut了<span class="math inline">\(A\)</span> 的proposal，则<span class="math inline">\(B\)</span> 的每一种undercut操作都会使得 <span class="math inline">\(A\)</span> 得到 <code>价值至少50%</code> 的集合。</li></ul><p>因此，此时一定能得到一个无嫉妒划分。</p></blockquote></blockquote><hr><blockquote><p><strong>Cor 1.</strong> 在待定区的划分中，一个参与者（例如是 <span class="math inline">\(A\)</span>）的 maximin 策略是给出自己所有的minimal bundle。若 <span class="math inline">\(MB_A\neq MB_B\)</span>，则 <span class="math inline">\(A\)</span> 的收益不会低于 50%，如果他的proposal是一个自己的minimal bundle。但若存在未提交的minimal bundle，或是提交了非minimal bundle 的集合，则可能导致他的收益低于 50%。</p></blockquote><!-- > **Proof.** 若 $MB_A=MB_B$，则 $A$ 的收益不会超过50%。> 若 $MB_A\neq MB_B$，则 --><blockquote><p><strong>Def 7.</strong> 称 <span class="math inline">\(\mathcal{X}\)</span> 上的偏好 <span class="math inline">\(\succeq\)</span> 满足<strong>扩展单调性</strong>，如果：</p><ul><li><span class="math inline">\(\forall S,T\in\mathcal{X}\)</span>，所有单物品偏好 <span class="math inline">\(P\)</span>，以及所有 <span class="math inline">\(x,y\in X\backslash(S\cup T)\)</span>，总有： <span class="math display">\[\begin{cases}S\succeq T \\x~P~y\end{cases}\Rightarrow S\cup\{x\}\succ T\cup\{y\}.\]</span></li></ul></blockquote><blockquote><p><strong>Prop 1.</strong> 假设参与者的偏好都是 <code>合理</code> 且 <code>扩展单调</code> 的，给定待定区的一个无嫉妒划分，则UP给出的整体划分是无嫉妒的。</p></blockquote><blockquote><p><strong>Proof.</strong> 这个命题基本上一听就是个废话。</p></blockquote><h2 id="两个参与者偏好完全相同的情形">两个参与者偏好完全相同的情形</h2><ul><li><span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 在 <span class="math inline">\(I_c\)</span> 上的单物偏好相同，均为 <span class="math inline">\(1~P~2~P\cdots P~c\)</span>；</li><li>记 <span class="math inline">\(I_c=\{1,2,\cdots,c\}\)</span>。</li></ul><blockquote><p><strong>Def 8.</strong> 集合 <span class="math inline">\(S\subseteq I_c\)</span> 称为是<strong>可行</strong>的，如果存在一个 <code>合理</code> 的偏好 <span class="math inline">\(\succeq\)</span>，s.t. <span class="math inline">\(S\succ -S\)</span>。</p></blockquote><blockquote><p><strong>Th 2.</strong> 令 <span class="math inline">\(S\subseteq I_c\)</span>，且 <span class="math inline">\(S\neq\varnothing\)</span>。则 <span class="math inline">\(S\)</span> 是 <code>可行</code> 的，当且仅当存在 <span class="math inline">\(k\leqslant c\)</span>，s.t. <span class="math inline">\(|I_k\cap S|&gt; \frac{k}{2}\)</span>。</p><blockquote><p><strong>Proof.</strong> 这个定理的样子类似于 “Computing a small agreeable set of indivisible items” 一文中的 Prop 1，证明也比较显然。</p></blockquote></blockquote><blockquote><p><strong>Cor 2.</strong> 对 <span class="math inline">\(\forall c\)</span>，<span class="math inline">\(\{1\}\)</span> 和 <span class="math inline">\(\forall S\)</span>，s.t. <span class="math inline">\(1\in S\)</span> 都是 <code>可行</code> 的。</p></blockquote><blockquote><p><strong>Cor 3.</strong> 假设 <span class="math inline">\(S\subseteq I_c\)</span> 且 <span class="math inline">\(1\notin S\)</span>。若 <span class="math inline">\(S\)</span> 是 <code>可行</code> 的，则 <span class="math inline">\((S,-S)\)</span> 和 <span class="math inline">\((-S,S)\)</span> 都可能是无嫉妒的划分。</p></blockquote><ul><li>以上两个推论都很容易理解和证明…不再赘述。</li></ul><hr><p>除此之外，还有一个很有意思的结论：</p><ul><li>用 <span class="math inline">\(f(c)\)</span> 表示待定区包含 <span class="math inline">\(c\)</span> 个物品时，<span class="math inline">\(I_c\)</span> 的无嫉妒划分方案数，则有： <span class="math display">\[f(c)=\begin{cases}  2^{c-1}-\binom{c}{(c-1)/2}, &amp; 2\not| ~c \\  2^{c-1}-\binom{c}{c/2},&amp; 2~|~c\end{cases}\]</span></li></ul><hr><h2 id="待定区大小的估计">待定区大小的估计</h2><ul><li>用 <span class="math inline">\(n\)</span> 表示物品数量，参与者 <span class="math inline">\(A\)</span> 的偏好为 <span class="math inline">\(1P_A 2P_A\cdots P_A n\)</span>，且该偏好是严格的；</li><li><p>记 <span class="math inline">\(c(n)\)</span> 为待定区中物品个数的期望。</p></li><li>若 <span class="math inline">\(n=1\)</span>，显然物品 <span class="math inline">\(1\)</span> 会被丢入待定区，因此 <span class="math inline">\(c(1)=1\)</span>；</li><li>若 <span class="math inline">\(n=2\)</span>，则 <span class="math inline">\(B\)</span> 的可能偏好有两种，每种情况的概率为 <span class="math inline">\(1/2\)</span>，因此 <span class="math inline">\(c(2)=\frac{1}{2}\cdot 0+\frac{1}{2}\cdot 2=1\)</span>。</li><li>若 <span class="math inline">\(n\geqslant 3\)</span>，则：<ul><li><span class="math inline">\(B\)</span> 最喜欢物品 <span class="math inline">\(1\)</span> 的概率为 <span class="math inline">\(\frac{1}{n}\)</span>，此时 <span class="math inline">\(1\)</span> 会被置入待定区，随后进入 <span class="math inline">\(c(n-1)\)</span> 情形；</li><li><span class="math inline">\(B\)</span> 最喜欢的不是 <span class="math inline">\(1\)</span> 的概率为 <span class="math inline">\(\frac{n-1}{n}\)</span>，此时 <span class="math inline">\(1\)</span> 会被送给 <span class="math inline">\(A\)</span>，<span class="math inline">\(B\)</span> 也会得到他最喜欢的物品，随后进入 <span class="math inline">\(c(n-2)\)</span> 情形。</li></ul></li><li><p>综上所述，在 <span class="math inline">\(n\geqslant 3\)</span> 时，有： <span class="math display">\[c(n)=\frac{1}{n}[1+c(n-1)]+\frac{n-1}{n}c(n-2).\]</span></p></li></ul><blockquote><p><strong>Lemma 1.</strong> 若 <span class="math inline">\(c(n-1)=c(n-2)=x\)</span>，则 <span class="math inline">\(c(n)=c(n+1)=x+\frac{1}{n}\)</span>。</p><blockquote><p><strong>Proof.</strong> 这个证明是不是过于简单了…</p></blockquote></blockquote><blockquote><p><strong>Th 3.</strong> 若 <span class="math inline">\(k\geqslant 1\)</span>，则 <span class="math display">\[c(2k+1)=c(2k+2)=1+\frac{1}{3}+\frac{1}{5}+\cdots+\frac{1}{2k+1}.\]</span></p><blockquote><p><strong>Proof.</strong> 这个证明也很简单（</p></blockquote></blockquote><ul><li>Th 3 表明，<span class="math inline">\(c(n)\)</span> 是发散的。</li></ul>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 计算机 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 北大 </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 社会计算 </tag>
            
            <tag> 论文笔记 </tag>
            
            <tag> 经济学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论文笔记[4]——On social envy-freeness in multi-unit markets</title>
      <link href="/2019/03/15/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-4-%E2%80%94%E2%80%94On-social-envy-freeness-in-multi-unit-markets/"/>
      <content type="html"><![CDATA[<blockquote><p>文章：Michele Flammini and Manuel Mauro and Matteo Tonelli, On social envy-freeness in multi-unit markets, Artificial Intelligence, volume 269, 2019, Pages 1-26.</p></blockquote><a id="more"></a><h2 id="准备工作">准备工作</h2><ul><li>一个多单位市场 <span class="math inline">\(\mu\)</span> 可以用一个元组 <span class="math inline">\((n, m, (v_i)_{i\in n})\)</span> 来表示：<ul><li><span class="math inline">\(N=\{1,\cdots,n\}\)</span> 是 <span class="math inline">\(n\)</span> 个买家；</li><li><span class="math inline">\(M\)</span> 是商品集合，是一组 <span class="math inline">\(m\)</span> 个<strong>相同的</strong>物品；</li><li><span class="math inline">\(v_i\)</span> 是一族函数：对于每个买家 <span class="math inline">\(i\in N\)</span>，<span class="math inline">\(v_i=(v_i(1),\cdots,v_i(m))\)</span> 是一个估价函数（或说向量）.<ul><li>其意义是给定一堆物品 <span class="math inline">\(X\subset M\)</span>，且 <span class="math inline">\(|X|=j\)</span>，则 <span class="math inline">\(i\)</span> 为了买到 <span class="math inline">\(X\)</span>，愿意付出的价值是 <span class="math inline">\(v_i(j)\)</span>.</li><li>我们假定 <span class="math inline">\(v_i(0)=0\)</span>，且 <span class="math inline">\(j\geqslant 1\)</span> 时，<span class="math inline">\(v_i(j)\geqslant 0\)</span>，<span class="math inline">\(\forall i\in N\)</span>.</li></ul></li></ul></li><li>对估价函数，有两种假定：<ul><li>single-minded（一心一意的买家）：买家仅对一定数量的物品有兴趣，即只在一个特定的size处有正值（记为 <span class="math inline">\(m_i\)</span>），其余时候都为 <span class="math inline">\(0\)</span>；</li><li>general：不受上述限制.</li></ul></li><li>定价函数（向量）是指一个 <span class="math inline">\(m\)</span> 元组 <span class="math inline">\(\overline{p}=(\overline{p}(1),\cdots,\overline{p}(m))\)</span>，s.t. <span class="math inline">\(1\leqslant j\leqslant m\)</span>，<span class="math inline">\(\overline{p}(j)\geqslant 0\)</span> 表示 <span class="math inline">\(j\)</span> 个物品的价格,<ul><li>对于商品的定价模式，也有两种假定：<ul><li>item-pricing：按照物品来定价，例如单个物品价格是 <span class="math inline">\(p\)</span>，则 <span class="math inline">\(\overline{p}(X)=|X|\cdot p\)</span>.</li><li>bundle-pricing：对一捆物品直接定价，并且该价格与物品数量不是成比例的（否则同item-pricing）.</li></ul></li></ul></li><li>消费者的效用（utility）是指：消费者对所得物品的估价 <span class="math inline">\(-\)</span> 消费者为此付出的价格. 即：<span class="math display">\[u_i(X,\overline{p})=v_i(|X|)-\overline{p}(X).\]</span></li><li>一个分配向量是指一个 <span class="math inline">\(n\)</span> 元组 <span class="math inline">\(\overline(X)=\{X_1,\cdots,X_n\}\)</span>，其中 <span class="math inline">\(X_i\subset M\)</span> 表示分配给买家 <span class="math inline">\(i\)</span> 的商品.<ul><li>称一个分配是可行的，如果：<ol type="1"><li>货物够分：<span class="math inline">\(\sum\limits_{i=1}^n |X_i|\leqslant |X|\)</span>；</li><li>买家不傻：<span class="math inline">\(u_i(X_i,\overline{p})\geqslant 0\)</span>.</li></ol></li></ul></li><li>一个市场输出 <span class="math inline">\((\overline{X},p)\)</span> 的总收益用 <span class="math inline">\(r(\overline{X},p)\)</span> 表示.</li></ul><blockquote><p><strong>Def 1.</strong> 一个市场 <span class="math inline">\(\mu\)</span> 得出的一个可行分配 <span class="math inline">\((\overline{X},\overline{p})\)</span> 在关系图 <span class="math inline">\(G(V,E)\)</span> 下是社会无嫉妒（或称稳定）的，如果 <span class="math inline">\(u_i(X_i,\overline{p})\geqslant u_i(X_j,\overline{p})\)</span>，<span class="math inline">\(\forall i\in N\)</span>，<span class="math inline">\(j\in N(i)\)</span>，其中 <span class="math inline">\(N(i)\)</span> 表示图 <span class="math inline">\(G\)</span> 中 <span class="math inline">\(i\)</span> 的所有邻居构成的集合.</p></blockquote><ul><li>该定义实际上是说，每个人相比邻居得到的，更喜欢自己得到的，那么就不会嫉妒邻居. 每个人都不嫉妒自己认识的人，那么久无嫉妒了；</li><li>当图 <span class="math inline">\(G\)</span> 是完全图时，此时的social envy-free即常义的无嫉妒.</li></ul><blockquote><p><strong>Def 2.</strong> 给定一族市场模型 <span class="math inline">\(\mathcal{M}\)</span> 和一族社会关系图 <span class="math inline">\(\mathcal{G}\)</span>，无嫉妒的代价（price of envy-free）<span class="math inline">\(c(\mathcal{M}, \mathcal{G})\)</span> 是指：不考虑无嫉妒时 <span class="math inline">\(\mathcal{M}\)</span> 中模型能达到的最大收入与考虑无嫉妒后的最大收入的比值的上确界，即： <span class="math display">\[c(\mathcal{M}, \mathcal{G})=\sup_{\mu\in\mathcal{M}, G\in\mathcal{G}}\frac{opt(\mu)}{opt(\mu,G)}.\]</span></p></blockquote><ul><li>在对分配问题进行讨论时，我们经常将其规约到 <code>MULTIPLE-CHOICE KNAPSACK</code>（多重背包问题）.<ul><li>多重背包问题 <span class="math inline">\((o,z,w,k)\)</span>：<ul><li><span class="math inline">\(O\)</span>：物品集合；</li><li><span class="math inline">\(z\)</span>：物品体积；</li><li><span class="math inline">\(w\)</span>：物品价值；</li><li><span class="math inline">\(k\)</span>：背包容量.</li></ul></li><li>我们通常这样构造：<ul><li>背包的容量为 <span class="math inline">\(k\)</span>；</li><li>考虑 <span class="math inline">\(t\)</span> 个物品类 <span class="math inline">\(\{O_1,\cdots,O_t\}\)</span>；</li><li>物品 <span class="math inline">\(o_{j,h}\)</span> 的体积和价值分别是 <span class="math inline">\(z_{j,h}\)</span> 和 <span class="math inline">\(w_{j,h}\)</span>.</li></ul></li><li>我们需要从每个物品类中恰好选取一个物品装入，使得总价值最大，且总体积不超过背包容量.</li></ul></li><li>多重背包问题已被证明是NP难的，但有FPTAS近似解法.</li></ul><h2 id="single-minded买家">single-minded买家</h2><p>按照定价模式，有两种情况，分述如下.</p><h3 id="item-pricing">Item-pricing</h3><blockquote><p><strong>Lemma 3.</strong> 对于single-minded买家，设 <span class="math inline">\(p^{opt}\)</span> 是能达到最优稳定分配 <span class="math inline">\((\overline{X}^{opt},p^{opt})\)</span> 的价格函数，且能最大化卖家的收入，则 <span class="math inline">\(p\in\mathbb{P}=\{\frac{v_i(m_i)}{m_i}|i\in N\}\)</span>.</p></blockquote><p>这个引理实际上是在说，对于single-minded情况，最优定价 <span class="math inline">\(p^{opt}\)</span> 一定是某个买家对单物品的估价.</p><blockquote><p><strong>Proof.</strong> 假设 <span class="math inline">\((\overline{X}^{opt},p^{opt})\)</span> 中的 <span class="math inline">\(p^{opt}\notin\mathbb{P}\)</span>. 取 <span class="math inline">\(p=\frac{v_i(m_i)}{m_i}\in\mathbb{P}\)</span> 为 <span class="math inline">\(\mathbb{P}\)</span> 中比 <span class="math inline">\(p^{opt}\)</span> 大的最小者，考虑 <span class="math inline">\((\overline{X}^{opt},p)\)</span>：</p><blockquote><p>由于二者的分配方案是一致的，故 <span class="math inline">\((\overline{X}^{opt},p)\)</span> 也满足可行性的两个要求（货物够分，买家不傻）. 现将价格从 <span class="math inline">\(p^{opt}\)</span> 涨至 <span class="math inline">\(p\)</span>，没有任何卖家的效用会因此变为负值. 于是 <span class="math inline">\((\overline{X}^{opt},p)\)</span> 也是social envy-free的，因为价格的上涨只会使得估值在 <span class="math inline">\(p^{opt}\)</span> 与 <span class="math inline">\(p\)</span> 之间的买家效用变为 <span class="math inline">\(0\)</span>，因此对于买家对邻居的评估没有影响，故仍然是social envy-free的.<br>但是，值得注意的是 <span class="math inline">\(p\)</span> 显然会比 <span class="math inline">\(p^{opt}\)</span> 给卖家带来严格正的收益增幅，故 <span class="math inline">\(p\)</span> 比 <span class="math inline">\(p^{opt}\)</span> 更优. This is a contradition.</p></blockquote><p>命题得证！</p></blockquote><p>尽管有了该结论，但 <code>(SINGLE, ITEM)</code> 设定下的分配问题仍然是困难的：</p><blockquote><p><strong>Th 4.</strong> <code>(SINGLE, ITEM)</code> 设定下的分配问题是NP难的.</p></blockquote><ul><li>其证明考虑从 <code>SUBSET-SUM</code> 问题进行规约.<ul><li><code>SUBSET-SUM</code> 问题：给定一个自然数集 <span class="math inline">\(A\subset\mathbb{N}\)</span> 以及一个自然数 <span class="math inline">\(k\in\mathbb{N}\)</span>，找到 <span class="math inline">\(S\subset A\)</span>，s.t. <span class="math inline">\(\sum_{a_i\in S} a_i=k\)</span>.</li><li>一个 <code>SUBSET-SUM</code> 问题通常可以被表示为 <span class="math inline">\((A=\{a_1,\cdots,a_n\},k)\)</span>.</li></ul></li></ul><blockquote><p><strong>Proof.</strong> 记 <span class="math inline">\(N=\{1,\cdots,N\}\)</span>，<span class="math inline">\(M=\{1,\cdots,M\}\)</span>，<span class="math inline">\(v_i(x)=\begin{cases} a_i, &amp; x=a_i \\ 0, &amp; x\neq a_i \end{cases}\)</span>，则：<br>考虑 <code>SUBSET-SUM</code> 中的一个 <span class="math inline">\(S\)</span>，若 <span class="math inline">\(a_i\in S\)</span>，则给买家 <span class="math inline">\(i\)</span>分配一捆大小为 <span class="math inline">\(a_i\)</span> 的商品，否则不给 <span class="math inline">\(i\)</span> 分配任何东西. 反过来，市场 <span class="math inline">\(\mu\)</span> 的每一个输出也对应了一个 <span class="math inline">\(S\)</span>.<br>由 <strong>Lemma 3</strong>，要想达到最优结果，<span class="math inline">\(\mu\)</span> 的单物品定价必定是 <span class="math inline">\(1\)</span>，此时所有买家的效用都是 <span class="math inline">\(0\)</span>，因而是稳定的.<br>因此，<span class="math inline">\(A\)</span> 存在和为 <span class="math inline">\(k\)</span> 的子集 <span class="math inline">\(S\)</span>，当且仅当 <span class="math inline">\(\mu\)</span> 在稳定前提下的最大收益是 <span class="math inline">\(k\)</span>.</p></blockquote><p>尽管问题本身是NP的，但存在好的近似算法.</p><blockquote><p><strong>Th 5.</strong> <code>(single,item)</code> 分配问题有FPTAS.</p></blockquote><p>考虑算法：</p><ul><li>对 <span class="math inline">\(\forall p\in\mathbb{P}\)</span>：<ul><li>对 <span class="math inline">\(\forall j\)</span>，定义：<ul><li><span class="math inline">\(N_j^+\)</span>：对大小为 <span class="math inline">\(j\)</span> 的商品集持严格正估价的买家数，<span class="math inline">\(n_j^+=|N_j^+|\)</span>；</li><li><span class="math inline">\(N_j^0\)</span>：对大小为 <span class="math inline">\(j\)</span> 的商品集持零估价的买家数，<span class="math inline">\(n_j^0=|N_j^0|\)</span>；</li></ul></li><li>建立如下的背包问题 <span class="math inline">\(K(\overline{O},\overline{z},\overline{w},k)\)</span>：<ul><li><span class="math inline">\(k=m\)</span>；</li><li>对每个<strong>至少有一个买家喜欢的 <span class="math inline">\(j\)</span></strong>，<span class="math inline">\(O_j=\{o_{j,0},\cdots,o_{j,n_j^0},\}\)</span> 表示 <span class="math inline">\(j\)</span> 生成的 <span class="math inline">\(n_j^0+1\)</span> 个物品；</li><li><span class="math inline">\(z_{j,h}=w_{j,h}=j\cdot (n_j^++h)\)</span>，<span class="math inline">\(\forall o_{j,h}\in O_j\)</span>.</li></ul></li><li>求解该背包问题，对得到的结果做如下处理：<ul><li>若选择了物品 <span class="math inline">\(o_{j,h}\)</span>，则给所有 <span class="math inline">\(N_j^+\)</span> 中的买家以及 <span class="math inline">\(h\)</span> 个 <span class="math inline">\(N_j^0\)</span> 中的买家每人分配 <span class="math inline">\(j\)</span> 个商品.</li></ul></li><li>得到分配方案后，即可计算收入并将其存下来.</li></ul></li><li>在所有 <span class="math inline">\(p\)</span> 中，求使得收入最大的分配方案 <span class="math inline">\((\overline{X},p)=\arg\max_p r(\overline{X}&#39;,p&#39;)\)</span>.</li></ul><p>以下对该算法进行证明：</p><blockquote><p><strong>Proof.</strong> 由 <strong>Lemma 3</strong>，对每个 <span class="math inline">\(p=\frac{v_i(m_i)}{m_i}\)</span>，<span class="math inline">\(i\in N\)</span>，我们建立一个多重背包问题 <span class="math inline">\(K(\mu\)</span>)…（具体构建方法见上述算法）<br>构建完成后，我们来证明：一个 <span class="math inline">\(K(\mu)\)</span> 的解 <span class="math inline">\(T\)</span>，对应着一个 <span class="math inline">\(\mu\)</span> 的稳定输出 <span class="math inline">\((\overline{X},p)\)</span>. 事实上，<span class="math inline">\(T\)</span> 所装载的物品不会超过背包容量，而背包容量恰好就是商品的总量. 进一步，<span class="math inline">\(\overline{X},p)\)</span> 是稳定的，因为当我们分配了一捆数量为 <span class="math inline">\(j\)</span> 商品时，只有 <span class="math inline">\(N_j^+\)</span> 里的人可能会因此产生嫉妒. 于是对于确定的 <span class="math inline">\(p\)</span>，<span class="math inline">\(K(\mu)\)</span> 的 <span class="math inline">\((1-\epsilon)\)</span>-近似解 <span class="math inline">\(T\)</span>，都对应了一个 <span class="math inline">\(\mu\)</span> 的 <span class="math inline">\((1-\epsilon)\)</span>-近似解 <span class="math inline">\((\overline{X},p)\)</span>，并且这个解是稳定的.</p></blockquote><blockquote><p><strong>Th 6.</strong> <code>(SINGLE, ITEM)</code> 问题是强NP难的.</p></blockquote><ul><li>证明考虑规约到问题 <code>DENSEST K-SUBGRAPH</code>：<ul><li>给定无向图 <span class="math inline">\(H(V,F)\)</span> 和整数 <span class="math inline">\(k\)</span>，求一个 <span class="math inline">\(S\subset V\)</span>，s.t. <span class="math inline">\(|S|\leqslant k\)</span> 且 <span class="math inline">\(S\)</span> 能最大化 <span class="math inline">\(S\)</span> 引出的边数.</li><li>一个 <code>DENSEST K-GRAPH</code> 的实例由 <span class="math inline">\((G,k)\)</span> 二元组表示.</li></ul></li></ul><blockquote><p><strong>Proof.</strong> 进行如下考虑：</p><ul><li>对市场 <span class="math inline">\(\mu\)</span>： - 对每个 <span class="math inline">\(u\in V\)</span>，将其与 <span class="math inline">\(|F|+1\)</span> 个买家对应（记为 <span class="math inline">\(N_u\)</span>）. 进一步，对每个 <span class="math inline">\(i\in N_u\)</span>，都有 <span class="math inline">\(v_i(1)=1+\epsilon\)</span>，其中 <span class="math inline">\(\epsilon=\frac{k}{|V|+1}\)</span>； - 对图 <span class="math inline">\(G\)</span> 的每条边 <span class="math inline">\(e\in F\)</span>，存在一个买家 <span class="math inline">\(i_e\)</span>，s.t. <span class="math inline">\(v_{i_e}=1\)</span>； - 再来一个买家 <span class="math inline">\(w\)</span>，s.t. <span class="math inline">\(v_w(|V|(|F|+1))=|V|(|F|+1)\)</span>； - 总共有 <span class="math inline">\(m=(|V|+k)(|F|+1)+|F|\)</span> 件商品.</li><li>对社会关系图 <span class="math inline">\(G(N,E)\)</span>： - 设 <span class="math inline">\(u\in V\)</span>，则对所有 <span class="math inline">\(i,i&#39;\in N_u\)</span>，有 <span class="math inline">\(\{i,i&#39;\}\in E\)</span>； - 对 <span class="math inline">\(\forall i\in N_u\)</span>，<span class="math inline">\(\{i,i_e\}\in E\)</span>，其中 <span class="math inline">\(e\)</span> 在 <span class="math inline">\(H\)</span> 中是由 <span class="math inline">\(u\)</span> 引出的.</li></ul><p>以下证明 <span class="math inline">\(H\)</span> 存在一个有 <span class="math inline">\(h\)</span> 条边的 <span class="math inline">\(k\)</span> 阶子图，当且仅当上述市场 <span class="math inline">\(\mu\)</span> 在 <span class="math inline">\(G\)</span> 下有一个稳定的输出 <span class="math inline">\((\overline{X},p)\)</span>，s.t. <span class="math inline">\(r(\overline{X},p)=(|V|+k)(|F|+1)+h\)</span>.</p><blockquote><p><font color="red">简单来说，就是：</font></p><p><font color="red">买家一共有 <span class="math inline">\((|V|+1)(|F|+1)\)</span> 个：</font></p><ol type="1"><li><font color="red">给 <span class="math inline">\(V\)</span> 里的每个点分别配 <span class="math inline">\(|F|+1\)</span> 个未来在 <span class="math inline">\(G\)</span> 中的邻居，记作 <span class="math inline">\(N_u\)</span>，这些邻居都只喜欢一个物品，并且效用只比 <span class="math inline">\(0\)</span> 严格大一点点；（这里共 <span class="math inline">\(|V|(|F|+1)\)</span> 个）</font></li><li><font color="red"><span class="math inline">\(H\)</span> 里的每条边，都对应一个买家，只喜欢一个物品，且效用是 <span class="math inline">\(0\)</span>；（这里共 <span class="math inline">\(|F|\)</span> 个）</font></li><li><font color="red">有一个超级买家，喜欢很多物品，但效用是 <span class="math inline">\(0\)</span>；（这里共 <span class="math inline">\(1\)</span> 个）</font></li></ol><p><font color="red">物品总量是 <span class="math inline">\((|V|+k)(|F|+1)+|F|\)</span>，小于总需求量：</font></p><ol type="1"><li><font color="red">上述第1步，共需要物品 <span class="math inline">\(|V|(|F|+1)\)</span> 个；</font></li><li><font color="red">上述第2步，共需要物品 <span class="math inline">\(|F|\)</span> 个；</font></li><li><font color="red">上述第3步，共需要物品 <span class="math inline">\(|V|(|F|+1)\)</span> 个；</font></li></ol><p><font color="red">图 <span class="math inline">\(G\)</span> 是这样规划的：</font></p><ol type="1"><li><font color="red">所有 <span class="math inline">\(N_u\)</span> 内部的点两两相连；</font></li><li><font color="red">点 <span class="math inline">\(u\)</span> 在 <span class="math inline">\(H\)</span> 中的所有邻居，在 <span class="math inline">\(G\)</span> 中都要与 <span class="math inline">\(u\)</span> 现在的所有邻居相连；</font></li></ol></blockquote><p><strong>先证 <span class="math inline">\(\Rightarrow\)</span>：</strong>假设 <span class="math inline">\(|S|=k\)</span> 且 <span class="math inline">\(S\)</span> 引出的边数为 <span class="math inline">\(h\)</span>. 考虑 <span class="math inline">\(p=1\)</span> 时的输出，得到物品的买家为 <span class="math display">\[\{w\}\cup\bigcup_{u\in S} N_u\cup\{i_e\in N:e=\{u,z\}\in F,~u,z\in S\}.\]</span> <font color="red">就是说，给：超级卖家 <span class="math inline">\(w\)</span>，<span class="math inline">\(S\)</span> 中的所有点对应的买家，以及 <span class="math inline">\(S\)</span> 内部所有边对应的卖家 分配了商品.</font><br>考虑所有 <span class="math inline">\(i_e\)</span> 中未得到物品的买家，他们所喜欢的物品对他们的效用也不过是 <span class="math inline">\(0\)</span>，所以不会产生嫉妒；其他未得到物品的买家，他们所处的 <span class="math inline">\(N_u\)</span> 中，<span class="math inline">\(u\notin S\)</span>，即他们的邻居也都没有得到东西，故他们也不会产生嫉妒. 于是 <span class="math inline">\((\overline{X},p)\)</span> 是稳定的，其总收益是 <span class="math inline">\((|V|+k)(|F|+1)+k\)</span>.</p><p><strong>再证 <span class="math inline">\(\Leftarrow\)</span>：</strong>假设存在总收益为 <span class="math inline">\((|V|+k)(|F|+1)+h\)</span> 的稳定输出 <span class="math inline">\((\overline{X},p)\)</span>，则：<br>在 <span class="math inline">\((\overline{X},p)\)</span> 中，<span class="math inline">\(p\)</span> 绝不能严格大于 <span class="math inline">\(1+\epsilon\)</span>，否则收益将为 <span class="math inline">\(0\)</span> <font color="red">（这是个废话）</font>. 事实上，如果 <span class="math inline">\(p&gt;1\)</span>，那么只有 <span class="math inline">\(N_u\)</span> 里的买家愿意购买，此时收益至多为 <span class="math display">\[(1+\epsilon)[|V|(|F|+1)]&lt;(|V|+k)(|F|+1)+h,~~其中~ \epsilon=\frac{k}{|V|+1}.\]</span> 因此，必定有 <span class="math inline">\(p\leqslant 1\)</span>. 此时，为获取 <span class="math inline">\(r(\overline{X},p)=(|V|+k)(|F|+1)+h\)</span> 的总收益，必须满足超级买家 <span class="math inline">\(w\)</span> 的购买需求. 继续进行分配，由稳定性条件，<span class="math inline">\(N_u\)</span> 只要有一个人得到了他想要的商品堆，<span class="math inline">\(N_u\)</span> 里的其他人也必须得到他们想要的. 又根据解的可行性条件（商品够 + 人不傻），我们至多分给 <span class="math inline">\(k\)</span> 个 <span class="math inline">\(N_u\)</span> 足够的商品，考虑到预期收益，我们也必须分给 <span class="math inline">\(k\)</span> 个 <span class="math inline">\(N_u\)</span> 足够的商品. 至此，还剩 <span class="math inline">\(h\)</span> 个商品，分配给 <span class="math inline">\(i_e\)</span> 中的买家.<br>此时考虑 <span class="math inline">\(S=\{u:\forall i\in N_u,|X_i|=1\}\)</span>（即所分到物品的 <span class="math inline">\(N_u\)</span> 的 <span class="math inline">\(u\)</span> 构成的集合），容易知道 <span class="math inline">\(|S|=k\)</span>. 以下只需说明 <span class="math inline">\(S\)</span> 引导的 <span class="math inline">\(H\)</span> 的子图至少有 <span class="math inline">\(h\)</span> 条边，而这正是分配了物品的 <span class="math inline">\(i_e\)</span> 的数量. 因此由一个市场也可以导出一个 <code>DENSTEST K-GRAPH</code> 的解.</p><p>由 <code>DENSTEST K-GRAPH</code> 的复杂性，命题得证.</p></blockquote><p>由以上的定理可知，分配问题的 FPTAS 是不存在的（除非已经证明 <span class="math inline">\(P=NP\)</span>）. 另一方面，我们可以找到一个较好的近似算法（一个 PTAS）.</p><ul><li>证明思路：给定了 <span class="math inline">\((\mu, G)\)</span> 和给定的价格 <span class="math inline">\(p\)</span>，<span class="math inline">\(j\leqslant m\)</span>，<span class="math inline">\(h\leqslant n\)</span>.<ul><li>假设我们可以迅速求解一个受限制的子问题：将商品每 <span class="math inline">\(j\)</span> 个捆成一捆，再在 <span class="math inline">\(G\)</span> 下分给 <span class="math inline">\(h\)</span> 个买家，且该分配在 <span class="math inline">\(G\)</span> 下稳定（如果存在）.</li><li><span class="math inline">\(J\)</span> 表示所有“至少有一个买家喜欢的物品量”构成的集合，且至多含 <span class="math inline">\(n\)</span> 个元素.</li><li>在以上假设之下我们甚至可以找到一个 FTPAS，仍然是利用多重背包 <span class="math inline">\(K(\mu, G,p)\)</span>：<ul><li>背包容量 <span class="math inline">\(k=m\)</span>；</li><li>对 <span class="math inline">\(\forall j\in J\)</span>，考虑 <span class="math inline">\(O_j=\{o_{j,h}:存在~j~个商品分给~h~个买家的在~G~下稳定的分配\}\)</span>；</li><li>物品的重量和价值：<span class="math inline">\(z_{j,h}=w_{j,h}=j\cdot h\)</span>.</li></ul></li><li>事实上，这样的一个背包的物品个数是多项式的.<ul><li>至多有 <span class="math inline">\(n\)</span> 个不同的物品类 <span class="math inline">\(O_j\)</span>；</li><li>每个物品类都至多有 <span class="math inline">\(n\)</span> 个物品.</li></ul></li><li>于是由 <strong>Lemma 3</strong>，对每个 <span class="math inline">\(p=\frac{v_i(m_i)}{m_i}\)</span> 跑一次 FPTAS，选取最大的总收益，这样就得到了一个多项式时间的 <span class="math inline">\((1-\epsilon)\)</span>-近似. 即一个 <code>(SINGLE, ITEM)</code> 的FPTAS.</li></ul></li></ul><p>然而，由 <strong>Th 6</strong>，上述思路的基本假设就是不成立的…换言之，受限制的子问题是不可能在多项式时间内解决的. 然而，以下的近似结果仍能保持：</p><blockquote><p><strong>Lemma 7.</strong> 给定一个 <code>(SINGLE, ITEM)</code> 分配问题的实例和一组固定的价格 <span class="math inline">\(p\)</span>，<span class="math inline">\(j\leqslant m\)</span>，<span class="math inline">\(h\leqslant n\)</span>，则求一个</p><ul><li>将商品 <span class="math inline">\(j\)</span> 个一捆包装起来，分给至多 <span class="math inline">\(h\)</span> 个买家的分配；</li><li>在 <span class="math inline">\(G\)</span> 下稳定；</li><li>能最大化总收益；</li></ul><p>这样的问题，存在一个 PTAS.</p></blockquote><blockquote><p><strong>Proof.</strong> 记 <span class="math inline">\(N_j^+\)</span> 和 $<span class="math inline">\(N_j^0\)</span> 分别为在价格 <span class="math inline">\(p\)</span> 下对 <span class="math inline">\(j\)</span> 持严格正效用的买家以和持零效用的买家，记 <span class="math inline">\(G_j^*\)</span> 为 <span class="math inline">\(N_j^+\)</span> 引导的子图，则对于任意 <span class="math inline">\(\mu\)</span> 的稳定（文中用了optimal）输出 <span class="math inline">\((\overline{X},p)\)</span>，<span class="math inline">\(G_j^+\)</span> 的所有连通分支中的买家要不都获得 <span class="math inline">\(j\)</span> 个商品，要不都没有得到 <span class="math inline">\(j\)</span> 个商品. （由稳定性易得）<br>取定 <span class="math inline">\(\epsilon&gt;0\)</span>，记 big 为 <span class="math inline">\(G_j^+\)</span> 的至少包含 <span class="math inline">\(\epsilon\cdot h\)</span> 个买家的连通分支（可能有多个），small 为其余的连通分支. 则，<font color="red">任意的optimal输出 <span class="math inline">\((\overline{X},o)\)</span> 至多分给 <span class="math inline">\(h\)</span> 个人</font>每人 <span class="math inline">\(j\)</span> 个商品，于是 <span class="math inline">\((\overline{X},p)\)</span> 至多给 <span class="math inline">\(O(\lfloor\frac{1}{\epsilon}\rfloor)\)</span> 个 big 连通分支分配商品. 当然，此外它还可以给一些 small 的连通分支分配商品. 再次，也可以给 <span class="math inline">\(N_j^0\)</span> 中的买家分配，但仅限通过 <span class="math inline">\(G_j^+\)</span> 与 <span class="math inline">\(G\)</span> 相连的买家. （否则可能引起嫉妒） 考虑以下步骤：</p><ul><li>给所有 big 连通块分配商品；</li><li>不停地给 small 连通块分配商品，直到无法分配. 无法分配有两种情况： - 商品不够分了： - 此时至少有 <span class="math inline">\((1-\epsilon)h\)</span> 个买家被分配了商品； - 所有small都被分配了商品： - 继续给 <span class="math inline">\(N_j^0\)</span> 中的弟兄们分配商品，直到无法继续，有以下两种情况： - 总共已经分配了 <span class="math inline">\(h\)</span> 个买家：如此便是一个optimal分配； - 所有 <span class="math inline">\(N_j^0\)</span> 中的买家都被分配了商品：我们也得到了最优的结果.</li></ul><p>综上所述，以上算法可以产出一个 <span class="math inline">\((1-\epsilon)\)</span>-近似最优结果，并且是多项式时间的.</p></blockquote><p>由以上引理，给定价格 <span class="math inline">\(p\)</span>，我们可以构造一个多重背包的近似实例 <span class="math inline">\(K_\epsilon(\mu, G, p)\)</span>，对应于 <code>MULTIPLE-CHOICE KNAPSACK</code> 实例 <span class="math inline">\(K(\mu,G,p)\)</span>：</p><ul><li>背包容量 <span class="math inline">\(k=m\)</span>；</li><li>对每个 <span class="math inline">\(j\in J\)</span>，物品类 <span class="math inline">\(O_j=\{o_{j,l}:对某个~1\leqslant h\leqslant n~运行上述PTAS，j~个一捆，买家数~l\leqslant h\}\)</span>；</li><li>体积和价值：<span class="math inline">\(w_{j,l}=z_{j,l}=j\cdot h\)</span>.</li></ul><p>显然，若 <span class="math inline">\(T=\{o_{j_1,h_1},\cdots,o_{j_t,h_t}\}\)</span> 是 <span class="math inline">\(K(\mu,G,p)\)</span> 的一个可行解，则存在一个 <span class="math inline">\(K_\epsilon(\mu,G,p)\)</span> 的可行解 <span class="math inline">\(\{o_{j_1,l_1},\cdots,o_{j_t,l_t}\}\)</span>，s.t. <span class="math inline">\((1-\epsilon)h_q\leqslant l_q\leqslant h_q\)</span>，<span class="math inline">\(\forall 1\leqslant q\leqslant t\)</span>. 因此，若用 <span class="math inline">\(opt(K)\)</span> 和 <span class="math inline">\(opt(K_\epsilon)\)</span> 分别表示 <span class="math inline">\(K\)</span> 和 <span class="math inline">\(K_\epsilon\)</span> 的最优解，我们有 <span class="math inline">\(opt(K_\epsilon)\geqslant (1-\epsilon)opt(K)\)</span>. 进一步，<span class="math inline">\(opt(K_\epsilon)\)</span> 对 <span class="math inline">\(K\)</span> 也是可行的.</p><p>进一步，有以下定理成立：</p><blockquote><p><strong>Th 8.</strong> <code>(SINGLE, ITEM)</code> 问题有 PTAS.</p></blockquote><p>考虑算法：</p><ul><li>对每个 <span class="math inline">\(p=\frac{v_i(m_i)}{m_i}\)</span>：<ul><li>计算多重背包 <span class="math inline">\(K_{\epsilon/2}(\mu,G,p)\)</span>；</li><li>记 <span class="math inline">\(T\)</span> 为 <span class="math inline">\((K_{\epsilon/2}(\mu,G,p),\epsilon/2)\)</span>； <!-- - 记 $T$ 所对应的分配为 $(\overline{X},p)$； --></li><li>对 <span class="math inline">\(\forall o_{j,l}\in T\)</span>:<ul><li><span class="math inline">\(\overline{X}\)</span> 给 <span class="math inline">\(l\)</span> 个买家每人一个大小为 <span class="math inline">\(j\)</span> 的物品堆；</li></ul></li><li>算一下收益.</li></ul></li><li>收益对所有 <span class="math inline">\(p\)</span> 取最大.</li></ul><blockquote><p><strong>Proof.</strong> 证明暂时从略Orz.</p></blockquote><h3 id="bundle-pricing">Bundle-pricing</h3><p>与item-pricing相同，bundle-pricing情形的计算也是困难的.</p><blockquote><p><strong>Th. 9</strong> <code>(SINGLE, BUNDLE)</code> 分配问题是NP难的.</p></blockquote><blockquote><strong>Proof.</strong> 与 <strong>Th 4</strong> 进行类似的规约（利用 <code>SUBSET-SUM</code>），集合 <span class="math inline">\(S\subset A\)</span> 对应于一个市场 <span class="math inline">\(\mu\)</span> 的输出：<br><center>买家 <span class="math inline">\(i\)</span> 得到大小为 <span class="math inline">\(a_i\)</span> 的一捆商品，当且仅当 <span class="math inline">\(a_i\in S\)</span>.</center>进一步，一个最优的稳定分配方案中，已分配的大小为 <span class="math inline">\(j\)</span> 的物品堆价格至少是 <span class="math inline">\(j\)</span>，否则提价到 <span class="math inline">\(j\)</span> 可继续增大收入. 于是：<br><center>存在 <code>SUBSET-SUM</code> <span class="math inline">\((A,k)\)</span> 的解，当且仅当 <span class="math inline">\(\mu\)</span> 存在收益为 <span class="math inline">\(k\)</span> 的最优稳定分配.</center></blockquote><p>不过Bundle-pricing条件下，同样有好的近似.</p><blockquote><p><strong>Th 10.</strong> <code>(SINGLE, BUNDLE)</code> 分配问题有FPTAS.</p></blockquote><blockquote><p><strong>Proof.</strong> 考虑给定的物品堆大小 <span class="math inline">\(j\leqslant m\)</span>，令 <span class="math inline">\(i_{j,1},\cdots,i_{j,n_j}\)</span> 为买家对 <span class="math inline">\(j\)</span> 的喜好程度的顺序，即 <span class="math inline">\(v_{i_{j,1}}(j)\geqslant \cdots\geqslant v_{i_{j,n_j}}(j)\)</span>.<br>对于 <span class="math inline">\(h\leqslant n_j\)</span>，取价格 <span class="math inline">\(v_{i_{j,h}}(j)\)</span>，考虑 <span class="math inline">\(h\)</span> 个大小为 <span class="math inline">\(j\)</span> 的物品堆分给上述序列的前 <span class="math inline">\(h\)</span> 位的情况，它将得到一个稳定的分配. 由于一心一意的买家只可能嫉妒和自己有相同喜好的买家，故上述过程可以对任意“至少有一个买家喜欢的bundle size”运行.<br>到这一步，就可以继续参考item情形的思路，规约到多重背包问题.</p></blockquote><p>考虑以下算法：</p><hr><ul><li>对每个 <span class="math inline">\(j\in J\)</span>，令 <span class="math inline">\(i_1,\cdots,i_{n_j}\)</span> 为 <span class="math inline">\(n_j\)</span> 个喜欢大小为 <span class="math inline">\(j\)</span> 的物品堆的买家的序，即 <span class="math inline">\(v_{i_1}(j)\geqslant\cdots\geqslant v_{i_{n_j}}(j)\)</span>.</li><li>构造如下的多重背包问题：<ul><li>背包容量 <span class="math inline">\(k=m\)</span>；</li><li>物品类 <span class="math inline">\(O_j=\{o_{j,i,h}:i\in N,h]in M\}\)</span>；<ul><li>体积 <span class="math inline">\(z_{j,i,h}=v_{j,h}(j)\cdot h\)</span>；</li><li>价值 <span class="math inline">\(w_{j,i,h}=j\cdot h\)</span>；</li></ul></li></ul></li><li>令 <span class="math inline">\(T\)</span> 为背包问题 <span class="math inline">\((K,\epsilon)\)</span> 的解；</li><li>对每个 <span class="math inline">\(o_{j,i,h}\in T\)</span>：<ul><li><span class="math inline">\(p(j)=v_{j,h}(j)\)</span>；</li><li>给 <span class="math inline">\(i_{j,1},\cdots,i_{j,h}\)</span> 每人一个大小为 <span class="math inline">\(j\)</span> 的物品堆</li></ul></li></ul><hr><ul><li>应当注意，上述算法中没有用到社会关系图 <span class="math inline">\(G\)</span> 的任何信息，即该算法在完全图下也是social envy-free的. 事实上，后文将证明，在 <code>(SINGLE, BUNDLE)</code> 设定下，social envy-free与否不影响总收益的大小.</li><li>与前文类似，可立刻得到如下推论：</li></ul><blockquote><p><strong>Cor 11.</strong> <code>(SINGLE, BUNDLE)</code> 分配问题有FPTAS.</p></blockquote><h3 id="自由处置">自由处置</h3><h4 id="什么是自由处置free-disposal">什么是自由处置（Free disposal）</h4><p>自由处置是指，不考虑代价的情况下，拿到更多的东西总不是坏事。体现在估价函数上，就是指： <span class="math display">\[v(j)\geqslant v(i),~~若~j\leqslant i.\]</span> 如果对于single-minded买家 <span class="math inline">\(i\)</span>，应有： <span class="math display">\[v_i(j)\geqslant v_i(m_i),~~若~j\geqslant m_i.\]</span></p><p>以下引理来自文献27：Revenue maximization envy-free pricing for homogeneous resources. IJCAI 2015.</p><blockquote><p><strong>Lemma 12.</strong> 给定一个pair envy-free的输出 <span class="math inline">\((X,p)\)</span>，若其不满足货物够分的条件，则可在多项式时间内找到一个pair envy-free的可行输出 <span class="math inline">\((X&#39;,p&#39;)\)</span>，s.t. <span class="math inline">\(r(X&#39;,p&#39;)\geqslant \frac{m}{2}\cdot p\)</span>.</p></blockquote><p>仍然考虑 <code>(SINGLE, ITEM)</code> 的买家，与非自由处置情形（能找到一个多项式规模的最优定价集 <span class="math inline">\(\mathbb{P}=\{\frac{v_i(m_i)}{m_i}\}\)</span>）不同，此处不能找到多项式规模的最优定价集 <span class="math inline">\(\mathbb{P}\)</span> （即至少能包含一个 <span class="math inline">\(p^{opt}\)</span>，使其能构成一个稳定的最优输出 <span class="math inline">\((X^{opt}, p^{opt})\)</span>）.</p><p>然而，考虑定价集 <span class="math inline">\(\mathbb{P}_\epsilon=\{(1+\epsilon/2)^\ell\}\)</span>，其规模对于输入规模和 <span class="math inline">\(1/\epsilon\)</span> 是多项式级别的，并且至少包含一个价格 <span class="math inline">\(p\)</span>，s.t. 对于某个 <span class="math inline">\(p^{opt}\)</span>，有 <span class="math inline">\(\frac{p^{opt}}{1+\epsilon/2}\leqslant p\leqslant p^{opt}\)</span>.</p><p>最终的算法需要对 <span class="math inline">\(\mathbb{P}_\epsilon\)</span> 中的每一个 <span class="math inline">\(p\)</span>，选择最优的分配方案.</p><p>不失一般性，设买家的最低估价为 <span class="math inline">\(1\)</span>，再令 <span class="math inline">\(v_{max}\)</span> 为最大的买家估价，给定 <span class="math inline">\(\epsilon&gt;0\)</span>，令 <span class="math inline">\(\mathbb{P}_\epsilon=\{(1+\epsilon/2)^\ell :-\log_{(1+\epsilon/2)}m\leqslant \ell\leqslant \log_{(1+\epsilon/2)}v_{max}\}\)</span>. 则 <span class="math inline">\(\mathbb{P}\)</span> 的规模大约为 <span class="math inline">\(O(\log_{(1+\epsilon/2)}m+\log_{(1+\epsilon/2)}v_{max})=O(\frac{\log v_{max}+\log m}{\epsilon})\)</span>. 又由于 <span class="math inline">\(p^{opt}\)</span> 须满足 <span class="math inline">\(\frac{1}{m}\leqslant p^{opt}\leqslant v_{max}\)</span>，故 <span class="math inline">\(\mathbb{P}\)</span> 中存在一个 <span class="math inline">\(p\)</span>，s.t. <span class="math inline">\(\frac{p^{opt}}{1+\epsilon/2}\leqslant p\leqslant p^{opt}\)</span>.</p><p>定义一个子问题：</p><ul><li>给定市场 <span class="math inline">\(\mu\)</span> 和定价 <span class="math inline">\(p\)</span>，求一个 pair envy-free 的分配方案 <span class="math inline">\((\overline{X},p)\)</span>，s.t. 该方案能最大化已分配的商品数量（无视商品总量的限制）.</li></ul><p>则整个问题将通过如下算法转化为子问题的求解：</p><hr><ul><li>记 <span class="math inline">\(\mathbb{P}_\epsilon=\{(1+\epsilon/2)^\ell :-\log_{(1+\epsilon/2)}m\leqslant \ell\leqslant \log_{(1+\epsilon/2)}v_{max}\}\)</span>；</li><li>对于每个 <span class="math inline">\(p\in\mathbb{P}_\epsilon\)</span>：<ul><li>对 <span class="math inline">\((\mu,p)\)</span> 找到一个（不考虑商品数量限制）卖掉商品最多的分配，记为 <span class="math inline">\((\overline{X}^p,p)\)</span>（子问题他lei了）；</li><li>记 <span class="math inline">\((\overline{X}^{p&#39;},p&#39;)\)</span> 为 <span class="math inline">\((\overline{X}^p,p)\)</span> 按照 <strong>Lemma 12</strong> 的方法所得到的可行解；</li><li>算一下收益；</li></ul></li><li>对所有 <span class="math inline">\(p\)</span> 算最大收益.</li></ul><hr><p>记 <span class="math inline">\((\overline{X}^{opt},p^{opt})\)</span> 是一个最优输出，<span class="math inline">\(p=(1+\epsilon/2)^{\lfloor \log_{(1+\epsilon/2)}p^{opt} \rfloor}\in\mathbb{P}_\epsilon\)</span>，s.t. <span class="math inline">\(\frac{p^{opt}}{1+\epsilon/2}\leqslant p\leqslant p^{opt}\)</span>.</p><p>由于 <span class="math inline">\(p\leqslant p^{opt}\)</span>，故在子问题中，<span class="math inline">\(p\)</span> 对应的方案能比 <span class="math inline">\(p^{opt}\)</span> 对应的方案卖掉更多（至少不会更少）的商品. 考虑 <span class="math inline">\(\overline{X}&#39;\)</span>，s.t. <span class="math inline">\(|X_i&#39;|=|X_i^{opt}|\)</span>，若 <span class="math inline">\(X_i^{opt}\neq\varnothing\)</span>，且 <font color="red"><span class="math inline">\(|X_i&#39;|\)</span> 是被 <span class="math inline">\(\overline{X}^{opt}\)</span> 分配的商品集大小中，在 <span class="math inline">\(p\)</span> 下使 <span class="math inline">\(i\)</span> 的效用最大的商品集大小？？？</font> 显然，<span class="math inline">\(\overline{X}&#39;\)</span> 在 <span class="math inline">\(p\)</span> 下是pair envy-free的，并且至少分配了和 <span class="math inline">\(\overline{X}^{opt}\)</span> 一样多的商品. 因此，对于子问题的最优解，它一定是这样的一个 <span class="math inline">\(\overline{X}^p\)</span>，s.t. <span class="math inline">\(\sum\limits_{i=1}^n |X_i^p|\geqslant \sum\limits_{i=1}^n |X_i&#39;|\leqslant \sum\limits_{i=1}^n |X_i^{opt}|\)</span>.</p><p>若 <span class="math inline">\(\sum\limits_{i=1}^n |X_i^p|&gt; m\)</span>，则 <span class="math inline">\((\overline{X}^p,p)\)</span> 分配了过多的商品，应当用 <strong>Lemma 12</strong> 来修正为 <span class="math inline">\((\overline{X}^{p&#39;},p&#39;)\)</span>.</p><p>于是，考虑到 <span class="math inline">\((\overline{X}^{p&#39;},p&#39;)\)</span> 至少分配了 <span class="math inline">\((\overline{X}^{opt},p^{opt})\)</span> 所分配商品量的一半，并且价格 <span class="math inline">\(p&#39;\geqslant p\geqslant \frac{p^{opt}}{1+\epsilon/2}\)</span>，故 <span class="math inline">\(r(\overline{X}^{p&#39;},p&#39;)\geqslant \frac{r(\overline{X}^{opt},p&#39;)}{2}\geqslant \frac{r(\overline{X}^{opt},p^{opt})}{2+\epsilon}\)</span>.</p><hr><p>至此，我们只剩下子问题的最优解需要讨论.</p><p>给定一个pair envy-free的分配方案 <span class="math inline">\((\overline{X},p)\)</span>，使其能在市场 <span class="math inline">\((\mu,p)\)</span> 下最大化商品分配数. 记 <span class="math inline">\(B_{\overline{X}}\)</span> 为 <span class="math inline">\(\overline{X}\)</span> 中出现的所有“商品捆”大小构成的集合. 由于 <span class="math inline">\(\overline{X}\)</span> 是pair envy-free 并且最优的，故对于每个对 <span class="math inline">\(B_{\overline{X}}\)</span> 中至少一个 <span class="math inline">\(j\)</span> 持非负效用的买家，我们都必须给该买家分配他认为最好（效用最高）的商品量. 因此，给定 <span class="math inline">\(B_\overline{X}\)</span>，我们可以在多项式时间内将 <span class="math inline">\(\overline{X}\)</span> 重建，换言之，子问题的解决只需确定 <span class="math inline">\(B_\overline{X}\)</span>.</p><p>注意到，给定 <span class="math inline">\(p\)</span>，每个买家 <span class="math inline">\(i\)</span>，若 <span class="math inline">\(m_i\leqslant \frac{v_i(m_i)}{p}\)</span>，则 <span class="math inline">\(i\)</span> 对所有处在区间 <span class="math inline">\([m_i, \lfloor\frac{v_i(m_i)}{p}\rfloor]\)</span> 中的“捆大小”都具有非负效用（这是句废话）. 由于一捆商品的价格会随着size增大而增大，但价值并不会，因此效用是在递减的（也是废话）. 因此，给定 <span class="math inline">\(B_\overline{X}\)</span>，（若下述集合为空，则取 <span class="math inline">\(0\)</span>） <span class="math display">\[|X_i|=\min\{t:t\in [m_i, \lfloor\frac{v_i(m_i)}{p}\rfloor]\cap B_\overline{X}\}.\]</span></p><p>由于输入可能是指数级别<font color="red">？？？为什么？</font>故我们需要搞一个包含 <span class="math inline">\(B_\overline{X}\)</span> 的多项式级别的集合 <span class="math inline">\(B_p\)</span>.</p><blockquote><p><strong>Lemma 14.</strong> 给定市场 <span class="math inline">\(\mu\)</span> 和价格 <span class="math inline">\(p\)</span>，令 <span class="math inline">\(B_p=\{\lfloor\frac{v_i(m_i)}{p}\rfloor :i\in n\}\)</span>，则 <span class="math inline">\(B_\overline{X}\subset B_p\)</span>，对所有最大化商品分配数的输出 <span class="math inline">\((\overline{X},p)\)</span>.</p></blockquote><p>证明考虑反证法，假设存在 <span class="math inline">\(j\notin B_p\)</span>，再记 <span class="math inline">\(N_i\)</span> 为所有在 <span class="math inline">\((\overline{X},p)\)</span> 中拿到 <span class="math inline">\(j\)</span> 个物品的买家. 将他们得到的商品量调整为 <span class="math inline">\(\min_{i\in N_j}\frac{v_i(m_i)}{p}\)</span> 即可. 细节略去.</p><p>最终子问题的解决办法如下:</p><hr><ul><li>令 <span class="math inline">\(B_p=\{\lfloor\frac{v_i(m_i)}{p}\rfloor:i\in N\}\)</span>；</li><li>对 <span class="math inline">\(j\in B_p\)</span>（从大到小）：<ul><li>计算一个“最大化‘收入’的分配”所分配掉的商品总数 <span class="math inline">\(x(j)\)</span>，其所分配的最小的商品集大小为 <span class="math inline">\(j\)</span>，即：<span class="math display">\[x(j)=\max\{\max_{k\in B,k&gt;j}\{x(k)+\Delta_k^j\},~j\cdot|N_j|\};\]</span></li></ul></li><li>返回最大的 <span class="math inline">\(x(j)\)</span> 所对应的分配 <span class="math inline">\((\overline{X}^j,p)\)</span>.</li></ul><hr><h2 id="general-买家">General 买家</h2><h3 id="item-pricing-1">Item-pricing</h3><ul><li>现有如下猜想：<ul><li>一个随机的 <span class="math inline">\(n\)</span> 元3-SAT问题，有 <span class="math inline">\(m=\Delta n\)</span> 条约束，该猜想断言对 <span class="math inline">\(\forall \epsilon&gt;0\)</span>，以及一个与 <span class="math inline">\(n\)</span> 无关的大常数 <span class="math inline">\(\Delta\)</span>，不存在这样的多项式时间算法，能够求解满足 <span class="math inline">\((1-\epsilon)\)</span> 比例的约束.</li></ul></li><li>一个问题被称为是 <code>R3SAT</code> 困难的，如果”该问题有多项式时间解法“能够证伪上述猜想.</li></ul><blockquote><p><strong>Def 15.</strong> <code>MES</code> 是如下的问题：</p><ul><li>给定全集 <span class="math inline">\(U\)</span> 和一个有序子集族 <span class="math inline">\(\mathcal{C}=\{S_1,\cdots,S_c\}\)</span>；</li><li>一个长度为 <span class="math inline">\(\ell\)</span> 的扩张序列(expanding sequence)<span class="math inline">\(\phi=(\phi(1)&lt;\cdots&lt;\phi(\ell))\)</span> 是一系列集合 <span class="math inline">\(S_{\phi(1)},\cdots,S_{\phi(\ell)}\)</span>，s.t. <span class="math inline">\(\forall 1\leqslant y\leqslant \ell\)</span>，<span class="math inline">\(S_{\phi(y)}\not\subseteq\bigcup\limits_{l=1}^{y-1} S_{\phi(l)}\)</span>.</li><li><code>MES</code> 的目标就是求出最长的序列(Maximum expanding sequence).</li><li><code>MES</code> 问题是一个 <code>R3SAT</code> 困难的问题.</li></ul></blockquote><blockquote><p><strong>Def 16.</strong> 称一个 <code>MES</code> 问题是 <span class="math inline">\(\kappa\)</span>-separable的，若 <span class="math inline">\(\mathcal{C}\)</span> 的序列可以被分为 <span class="math inline">\(\kappa\)</span> 个不交子列/子类 <span class="math inline">\(\mathcal{C}_1,\cdots,\mathcal{C}_\kappa\)</span>.<br>文献[21]证明了，<span class="math inline">\(\exists\epsilon&gt;0\)</span>，s.t 当 <code>MES</code> 问题是 <span class="math inline">\(f(c)\)</span>-separable的，在 <span class="math inline">\(O(f(c)^\epsilon)\)</span> 内逼近该问题也是 <code>R3SAT</code> 困难的. 其中 <span class="math inline">\(f\)</span> 满足：</p><ul><li><span class="math inline">\(f\)</span> 是不减的；</li><li><span class="math inline">\(f(a)\leqslant a\)</span> 且 <span class="math inline">\(f(a^b)\leqslant f(a)^b\)</span>，<span class="math inline">\(\forall b&gt;1\)</span>，<span class="math inline">\(a\in\mathbb{N}\)</span>.</li></ul></blockquote><blockquote><p><strong>Th 17.</strong> 对一些 <span class="math inline">\(\epsilon&gt;0\)</span> 来说，在 <span class="math inline">\(O(\log^\epsilon n)\)</span> 下逼近 <code>(GENERAL, ITEM)</code> 问题是 <code>R3SAT</code>-困难的.</p></blockquote><blockquote><p><strong>Lemma 18.</strong> 如果市场 <span class="math inline">\(\mu\)</span> 存在一个稳定的输出 <span class="math inline">\((\overline{X},p\neq 1)\)</span>，记其收益为 <span class="math inline">\(r\)</span>，则也存在一个稳定的输出 <span class="math inline">\((\overline{X}&#39;,1)\)</span>，其收益为 <span class="math inline">\(r/4\)</span>.</p></blockquote><h3 id="bundle-pricing-1">Bundle-pricing</h3><blockquote><p><strong>Th 22.</strong> <code>(GENERAL, BUNDLE)</code> 分配问题有 <span class="math inline">\(\frac{\log n}{1-\frac{1}{e}}\)</span> 近似算法.</p></blockquote><h2 id="无嫉妒的代价">无嫉妒的代价</h2><blockquote><p><strong>Th 24.</strong> <code>(SINGLE, ITEM)</code> 情形的代价是 <span class="math inline">\(2\)</span>.</p></blockquote><blockquote><p><strong>Th 25.</strong> <code>(SINGLE, BUNDLE)</code> 情形的代价是 <span class="math inline">\(1\)</span>.</p></blockquote><blockquote><p><strong>Th 26.</strong> <code>(GENERAL, ITEM)</code> 情形的代价是 <span class="math inline">\(\Theta(\log n)\)</span>.</p></blockquote><blockquote><p><strong>Th 27.</strong> <code>(GENERAL, BUNDLE)</code> 情形的代价是 <span class="math inline">\(\Theta(\log n)\)</span>.</p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 计算机 </tag>
            
            <tag> 北大 </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 社会计算 </tag>
            
            <tag> 论文笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论文笔记[3]——Computing a small agreeable set of indivisible items</title>
      <link href="/2019/03/10/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-3-%E2%80%94%E2%80%94Computing-a-small-agreeable-set-of-indivisible-items/"/>
      <content type="html"><![CDATA[<blockquote><p>文章：Pasin Manurangsi, Warut Suksompong, Computing a small agreeable set of indivisible items, Artificial Intelligence, Volume 268, 2019, Pages 96-114.</p></blockquote><p>Agreeable set – necessarily agreeable set – agreeable set 一个最坏上界（证明 and 2和3情况的构造） – 计算necessarily agreeable set – 一般情形下求最小的agreeable set – 可加效用函数下的探讨.</p><a id="more"></a><h2 id="准备工作">准备工作</h2><h3 id="记号说明">记号说明</h3><ul><li><span class="math inline">\([n]\)</span>：代理人，编号为 <span class="math inline">\(1,2,\cdots,n\)</span>；</li><li><span class="math inline">\(S=\{x_1,\cdots,x_m\}\)</span>：物品集合，<span class="math inline">\(\mathcal{S}\)</span> 表示其幂集；</li><li>偏好：每个代理人 <span class="math inline">\(i\)</span> 都被赋予了一个偏好关系 <span class="math inline">\(\succeq_i\)</span>，用以比较 <span class="math inline">\(S\)</span> 子集之间的好坏关系. 偏好关系是自反、完全、和传递的；</li><li><span class="math inline">\(\begin{bmatrix}V \\ t\end{bmatrix}\)</span> 表示集合 <span class="math inline">\(V\)</span> 的 <span class="math inline">\(t\)</span> 元子集族；</li></ul><h3 id="相关定义">相关定义</h3><blockquote><p><strong>Def 0.</strong> 分配问题是把 <span class="math inline">\(S\)</span> 分给 <span class="math inline">\(n\)</span> 个代理人的问题.</p></blockquote><blockquote><p><strong>Def 1.</strong> 单调性：<span class="math inline">\(\mathcal{S}\)</span> 上的一个偏好关系 <span class="math inline">\(\succeq\)</span> 是单调的，当且仅当 <span class="math inline">\(T\cup\{x\}\succeq T\)</span>，<span class="math inline">\(\forall T\subset S\)</span>.</p></blockquote><blockquote><p><strong>Def 2.</strong> Agreeable：<span class="math inline">\(T\subset S\)</span> 对代理人 <span class="math inline">\(i\)</span> 来说是agreeable的，当且仅当 <span class="math inline">\(T\succeq_i S\backslash T\)</span>. （越大的集合越好）</p></blockquote><ul><li>Agreeable set有时也指对所有代理人都agreeable的集合. 当偏好单调时，显然一定存在这样的集合（<span class="math inline">\(S\)</span> 就是这样的集合）；当偏好不单调时则可能不存在.</li></ul><blockquote><p><strong>Def 3.</strong> Responsive：<span class="math inline">\(\mathcal{S}\)</span> 上的偏好关系是responsive的，当且仅当：</p><ol type="1"><li><span class="math inline">\(\succeq\)</span> 是单调的；<br></li><li><span class="math inline">\((T\backslash\{y\})\cup\{x\}\succeq T\)</span>，<span class="math inline">\(\forall T\subset S\)</span>，其中 <span class="math inline">\(x\succeq y\)</span>，<span class="math inline">\(x\notin T\)</span>，<span class="math inline">\(y\in T\)</span>. （扔掉一个不好的，再拿来一个好的，情况会变好）</li></ol></blockquote><ul><li>一般来说，判断集合对代理人 <span class="math inline">\(i\)</span> 是否agreeable，需要访问其完整偏好，仅凭单物品偏好无法判断；</li><li>但只要偏好是responsive的，便可以仅通过单物品偏好来判断集合是否agreeable.</li></ul><blockquote><p><strong>Def 4.</strong> Necessarily agreeable：取定 <span class="math inline">\(\mathcal{S}\)</span> 上的一个单物品偏好 <span class="math inline">\(\succeq^{sing}\)</span>（即物品的一个排列）. 称<span class="math inline">\(T\subset S\)</span> 在 <span class="math inline">\(\succeq^{sing}\)</span> 下是necessarily agreeable的，若对与 <span class="math inline">\(\succeq^{sing}\)</span> 相容的任意偏好 <span class="math inline">\(\succeq\)</span>，都有 <span class="math inline">\(T\succeq S\backslash T\)</span>.</p></blockquote><ul><li>简单起见，若 <span class="math inline">\(T\)</span> 对代理人 <span class="math inline">\(i\)</span> 的单物品偏好是necessarily agreeable的，则称 <span class="math inline">\(T\)</span> 对 <span class="math inline">\(i\)</span> 是necessarily agreeable的.</li></ul><blockquote><p><strong>Def</strong> 效用函数：效用函数 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(\mathcal{S}\to\mathbb{R}_{\geqslant 0}\)</span> 的映射. <span class="math inline">\(f\)</span> 的大小标志着集合的好坏.</p></blockquote><ul><li>由于每个代理的偏好是自反、完全和传递的，故 <span class="math inline">\(\forall T_1,T_2\subset S\)</span>，<span class="math inline">\(T_1\succeq T2\)</span> 当且仅当 <span class="math inline">\(f(T_1)\geqslant f(T_2)\)</span>.</li><li>对于单调的偏好，<span class="math inline">\(\forall T_1\subset T_2\)</span>，总有 <span class="math inline">\(f(T_1)\leqslant f(T_2)\)</span>.</li><li>可加效用：效用函数 <span class="math inline">\(u\)</span> 称为是可加的，当且仅当 <span class="math inline">\(u(T_1\cup T_2)=u(T_1)+u(T_2)\)</span>，其中 <span class="math inline">\(T_1\cap T_2=\varnothing\)</span>.</li><li>次可加效用：<span class="math inline">\(u\)</span> 称为是次可加的，当且仅当 <span class="math inline">\(u(T_1\cup T_2)\leqslant u(T_1)+u(T_2)\)</span>，<span class="math inline">\(\forall T_1,T_2\)</span>. <font color="red"><strong>任何单调的效用函数都是次可加的.</strong></font></li></ul><h3 id="necessarily-agreeable-set">Necessarily agreeable set</h3><p>对于necessarily agreeable set，有一个重要的命题：</p><blockquote><p><strong>Prop. 1.</strong> 取定 <span class="math inline">\(\mathcal{S}\)</span> 上的单物品偏好 <span class="math inline">\(\succeq^{sing}\)</span>，不妨设为 <span class="math display">\[x_1\succeq^{sing} x_2\succeq^{sing}\cdots\succeq^{sing} x_m.\]</span> 令 <span class="math inline">\(T\subset S\)</span>，记 <span class="math inline">\(I_k=\{x_1,x_2,\cdots,x_m\}\)</span>，<span class="math inline">\(\forall k=1,\cdots,m\)</span>，则有：<br>若 <span class="math inline">\(\vert I_k\cap T \vert\geqslant k/2\)</span>，<span class="math inline">\(\forall k=1,\cdots,m\)</span>，则 <span class="math inline">\(T\)</span> 在 <span class="math inline">\(\succeq^{sing}\)</span> 下是necessarily agreeable的.<br>当偏好 <span class="math inline">\(\succeq^{sing}\)</span> 是严格的，其逆命题也成立.</p></blockquote><blockquote><p><strong>Proof.</strong> <strong>先证 <span class="math inline">\(\Rightarrow\)</span></strong>：由条件可知 <span class="math inline">\(|I_m\cap T|\geqslant m/2\)</span>，于是 <span class="math inline">\(|T|\geqslant |S\backslash T|\)</span>. 取 <span class="math inline">\(T&#39;\in\begin{bmatrix}T \\ |S\backslash T|\end{bmatrix}\)</span> 且 <span class="math inline">\(T&#39;\)</span> 是其中下标最小的.<br>由此即可在 <span class="math inline">\(T&#39;\)</span> 与 <span class="math inline">\(S\backslash T\)</span> 间定义一个保序的双射 <span class="math inline">\(f:T&#39;\to S\backslash T\)</span>，即下标最小的映射到下标最小的. 由于 <span class="math inline">\(|I_k\cap T|\geqslant k/2\)</span>，<span class="math inline">\(\forall k=1,\cdots,m\)</span>，故 <span class="math inline">\(f\)</span> 必定将 <span class="math inline">\(x_k\)</span> 映射到某个 <span class="math inline">\(l&gt;k\)</span> 的 <span class="math inline">\(x_l\)</span>. 由responsive的定义可知，任意一个与 <span class="math inline">\(\succeq^{sing}\)</span> 相容的responsive的偏好，都保持 <span class="math inline">\(T&#39;\succeq S\backslash T\)</span>. 又由于所有responsive的偏好都是单调的，故 <span class="math inline">\(T\succeq S\backslash T\)</span>，即 <span class="math inline">\(T\)</span> 在 <span class="math inline">\(\succeq^{sing}\)</span> 之下是necessarily agreeable的.<br><strong>再证 <span class="math inline">\(\Leftarrow\)</span></strong>：<strong>用反证法：假设存在 <span class="math inline">\(l\)</span>，s.t. <span class="math inline">\(|I_l\cap T|&lt;1/2\)</span>. 取一个小常数 <span class="math inline">\(\epsilon&gt;0\)</span>，假设偏好 <span class="math inline">\(\succeq\)</span> 由可加效用函数 <span class="math inline">\(u\)</span> 给出：</strong> <span class="math display">\[u(x_i)=\begin{cases}1+(l-i)\epsilon,&amp; 1\leqslant i\leqslant l;\\(m-i)\epsilon,&amp; l&lt;i\leqslant m.\end{cases}\]</span> 由于“所有由可加效用函数给出的偏好都是responsive的”，故 <span class="math inline">\(\succeq\)</span> 是responsive的. 进一步，当 <span class="math inline">\(\epsilon\)</span> 足够小时，有 <span class="math inline">\(u(S\backslash T)&gt;1/2\)</span>，同时 <span class="math inline">\(u(T)&lt;1/2\)</span>. 由于 <span class="math inline">\(\succeq\)</span> 是responsive的，且与 <span class="math inline">\(\succeq^{sing}\)</span> 相容，故有 <span class="math inline">\(S\backslash T\succ T\)</span>. 因此 <span class="math inline">\(T\)</span> 在 <span class="math inline">\(\succeq^{sing}\)</span> 下不是necessarily agreeable的. 矛盾！故逆命题得证.<br><strong>综上，原命题得证.</strong></p></blockquote><h2 id="最坏情况的上界">最坏情况的上界</h2><h3 id="普适的最坏上界">普适的最坏上界</h3><blockquote><p><strong>Th 1.</strong> 对于 <span class="math inline">\(n\)</span> 个代理人，<span class="math inline">\(m\)</span> 个物品的分配问题，存在 <span class="math inline">\(T\subseteq S\)</span>，s.t. <span class="math display">\[|T|\leqslant\min\left(\lfloor\frac{m+n}{2}\rfloor,m\right)\]</span> 且 <span class="math inline">\(T\)</span> 对所有代理人都是agreeable的. 进一步，存在特定的偏好，使得该界是紧的.</p></blockquote><p>一般情况的证明较为复杂，先给出了 <span class="math inline">\(n=2\)</span> 的情形：</p><h4 id="两个代理人的情形">两个代理人的情形</h4><blockquote><p><strong>Proof when <span class="math inline">\(n=2\)</span>.</strong> 此时上界为 <span class="math inline">\(\lfloor\frac{m+2}{2}\rfloor\)</span>. 记两个代理人的偏好分别是 <span class="math inline">\(\succeq_1\)</span> 和 <span class="math inline">\(\succeq_2\)</span>.<br><strong>当 <span class="math inline">\(m=2k+1\)</span> 为奇数时，用反证法：</strong>假设不存在<font color="red"><strong>至多</strong></font> <span class="math inline">\(k+1\)</span> 元子集对两个代理人同时保持agreeable.<br>取 <span class="math inline">\(T\subset S\)</span>，s.t. <span class="math inline">\(|T|=k\)</span>. 以下先证明一个引理：</p><blockquote><p><strong>引理</strong> 若 <span class="math inline">\(T\succ_1 S\backslash T\)</span>，则 <span class="math display">\[(T\cup\{x\})\backslash\{x&#39;\}\succ_1 ((S\backslash T)\backslash \{x\})\cup\{x&#39;\}.\]</span> <span class="math inline">\(\forall x\in S\backslash T\)</span>，<span class="math inline">\(x&#39;\in T\)</span>.</p></blockquote><blockquote><p><strong>Proof.</strong> 由单调性，有： <span class="math display">\[T\cup\{x\}\succ_1(S\backslash T)\backslash\{x\}.\]</span> 此时 <span class="math inline">\(|T\cup\{x\}|=k+1\)</span>，由于不存在 <span class="math inline">\(k+1\)</span> 元的agreeable set，故 <span class="math display">\[(S\backslash T)\backslash\{x\}\succ_2T\cup\{x\}.\]</span> 进一步，由单调性，有： <span class="math display">\[((S\backslash T)\backslash\{x\})\cup\{x&#39;\}\succ_2(T\cup\{x\})\backslash\{x&#39;\}.\]</span> 此时 <span class="math inline">\(|((S\backslash T)\backslash\{x\})\cup\{x&#39;\}|=k+1\)</span>，再由不存在 <span class="math inline">\(k+1\)</span> 元的agreeable set，有： <span class="math display">\[(T\cup\{x\})\backslash\{x&#39;\}\succ_2((S\backslash T)\backslash\{x\})\cup\{x&#39;\}.\]</span> 至此，引理得证. <font color="red"><strong>（只要 <span class="math inline">\(T\)</span> 比其补集更好，则任意与补集交换一件物品后仍然更好.）</strong></font></p></blockquote><p>继续，不失一般性，设 <span class="math inline">\(\{x_1,\cdots,x_k\}\succ_1\{x_{k+1},\cdots,x_{2k+1}\}\)</span>. 反复使用引理，可得： <span class="math display">\[\{x_{k+1},x_2,\cdots,x_k\}\succ_1\{x_1,x_{k+2},\cdots,x_{2k+1}\},\]</span> <span class="math display">\[\{x_{k+1},x_{k+2},x_3,\cdots,x_k\}\succ_1\{x_1,x_2,x_{k+3},\cdots,x_{2k+1}\},\]</span> <span class="math display">\[\cdots\cdots\]</span> <span class="math display">\[\{x_{k+1},x_{k+2},\cdots,x_{2k}\}\succ_1\{x_1,x_2,\cdots,x_k,x_{2k+1}\}.\]</span> 由单调性，<span class="math inline">\(\{x_{k+1},x_{k+2},\cdots,x_{2k+1}\}\succ_1\{x_1,x_2,\cdots,x_k\}\)</span>，与假设矛盾！<strong>奇数情形得证.</strong><br><strong>当 <span class="math inline">\(m=2k\)</span> 为偶数时，</strong>令 <span class="math inline">\(S1=S\backslash\{x_1\}\)</span>. 由奇数情形下的结果，存在 <span class="math inline">\(T\subset S&#39;\)</span>，s.t. <span class="math inline">\(|T|\leqslant k\)</span> 且 <span class="math inline">\(T\succeq_{1,2} S&#39;\backslash T\)</span>. 于是由单调性即可知，<span class="math inline">\(T\cup \{x_1\}\)</span> 即为所求的 <span class="math inline">\(k+1\)</span> 元集合.<br><strong>综上，命题得证.</strong></p></blockquote><ul><li>上述证明实际上给出了一个多项式时间的算法，可以得到一个至多 <span class="math inline">\(\lfloor\frac{m+2}{2}\rfloor\)</span> 元的agreeable set. 具体过程参见证明，不多赘述.</li></ul><h4 id="一般情形的证明">一般情形的证明</h4><p>一般情形的证明需要用到所谓Kneser猜想：</p><blockquote><p><strong>Lemma 1.</strong> (Kneser 猜想) Kneser图 <span class="math inline">\(KG_{n,k}\)</span> 的染色数为： <span class="math display">\[\chi(G)=\begin{cases}n-2k+2, &amp; n\geqslant 2k;\\1, &amp; \text{otherwise.}\end{cases}\]</span></p></blockquote><p>Kneser图的定义如下：</p><blockquote><p><strong>Def X.</strong> Kneser图：考虑 <span class="math inline">\([n]=\{1,\cdots,n\}\)</span> 的 <span class="math inline">\(k\)</span> 元子集族 <span class="math inline">\(\begin{bmatrix} [n] \\ k \end{bmatrix}\)</span>，以 <span class="math inline">\(\begin{bmatrix} [n] \\ k \end{bmatrix}\)</span> 为顶点，建立一个 <span class="math inline">\(\binom{n}{k}\)</span> 阶图，结点 <span class="math inline">\(T_1\)</span>，<span class="math inline">\(T_2\)</span> 之间有边相连，当且仅当 <span class="math inline">\(T_1\cap T_2=\varnothing\)</span>. 这样的图称为Kneser图.</p></blockquote><ul><li><span class="math inline">\(KG_{5,2}\)</span> 即是大名鼎鼎的Petersen图.<center><img src="/img/blog-graph/kneser-petersen.png" width="300" alt="Petersen Graph"></center></li><li>更多Kneser图的形状如下图所示（来源：Wolfram mathworld）<center><img src="/img/blog-graph/KneserGraphs_700.gif" alt="Kneser Graph"></center></li></ul><p>有了这个猜想，即可证明Th 1.</p><blockquote><p><strong>Proof of Th 1.</strong> 令 <span class="math inline">\(k=\lfloor\frac{m+n}{2}\rfloor\)</span>. 显然 <span class="math inline">\(k\geqslant m\)</span> 的情况是平凡的，只须取 <span class="math inline">\(S\)</span> 为agreeable set即可，故以下只讨论 <span class="math inline">\(k&lt;m\)</span> 的情形.</p><p>考虑 <span class="math inline">\(\{x_1,\cdots,x_m\}\)</span> 的 <span class="math inline">\(m-k\)</span> 元子集生成的Kneser图 <span class="math inline">\(KG_{m,m-k}\)</span>. 若存在 <span class="math inline">\(T\subset S\)</span>，s.t. <span class="math inline">\(|T|=m-k\)</span>，且 <span class="math inline">\(S\backslash T\succeq_i T\)</span>，<span class="math inline">\(\forall i\)</span>，则 <span class="math inline">\(S\backslash T\)</span> 即为所求的 <span class="math inline">\(k\)</span> 元agreeable set.<br><strong>假设不存在上述这样的 <span class="math inline">\(T\)</span>，即 <span class="math inline">\(\forall T\in\begin{bmatrix}S \\ m-k\end{bmatrix}\)</span>，都存在 <span class="math inline">\(i\)</span>，s.t. <span class="math inline">\(T\succ_i S\backslash T\)</span>.</strong> <font color="red"><strong>对图 <span class="math inline">\(KG_{m,m-k}\)</span> 染色，给结点 <span class="math inline">\(T\)</span> 染上颜色 <span class="math inline">\(i\)</span>，其中 <span class="math inline">\(T\succ_i S\backslash T\)</span>.</strong></font> 若有多个 <span class="math inline">\(i\)</span> 对应，任选其一即可.<br>由于 <span class="math inline">\(k\geqslant m/2\)</span>，故 <span class="math inline">\(m\geqslant 2(m-k)\)</span>. 由Kneser猜想（<strong>Lemma 1.</strong>），<span class="math inline">\(KG_{m,m-k}\)</span> 的染色数为： <span class="math display">\[\begin{align}\chi(KG_{m,m-k}) &amp;= m-2(m-k)+2 \\ &amp;= 2k-m-2 \\ &amp;\geqslant 2(\frac{m+n-1}{2})-m+2=n+1.\end{align}\]</span> 而上述染色过程只使用了 <span class="math inline">\(n\)</span> 种颜色，故由染色数的定义，至少存在一条边，其两端点共色. 不妨设这两个端点为 <span class="math inline">\(T_1\)</span> 和 <span class="math inline">\(T_2\)</span>. 即有，对于某个 <span class="math inline">\(i\in[n]\)</span>，<span class="math inline">\(T_1\succ_i S\backslash T_1\)</span>，<span class="math inline">\(T_2\succ_i S\backslash T_2\)</span>. 但由 <span class="math inline">\(T_1\)</span> 和 <span class="math inline">\(T_2\)</span> 之间有边相连，有 <span class="math inline">\(T_1\cap T_2=\varnothing\)</span>，故 <span class="math inline">\(T_1\subset S\backslash T_2\)</span>，<span class="math inline">\(T_2\subset S\backslash T_1\)</span>. 由单调性立得矛盾： <span class="math display">\[S\backslash T_1\succeq_i T_2\succ_i S\backslash T_2\succeq_i T_1\succ_i S\backslash T_1.\]</span> 因此必定存在上述的 <span class="math inline">\(T\)</span>，即命题得证.</p></blockquote><blockquote><p><strong>一组偏好，使得该界是紧的</strong> 分为两种情况，以下效用函数均是可加的：</p><ul><li><span class="math inline">\(n\geqslant m\)</span>，此时 <span class="math inline">\(\min(k,m)=m\)</span>. 取 <span class="math inline">\(u_i(x_j)=\begin{cases} 1, &amp; j=\min(i,m) \\ 0, &amp; j\neq\min(i,m) \end{cases}\)</span>，则对代理人 <span class="math inline">\(i\)</span> agreeable的集合必定得包含 <span class="math inline">\(x_{\min(i,m)}\)</span>，此时agreeable set必须包含所有物品，共计 <span class="math inline">\(m\)</span> 个；</li><li><span class="math inline">\(n&lt;m\)</span>，此时 <span class="math inline">\(\min(k,m)=k\)</span>. 对 <span class="math inline">\(i=1,\cdots,n-1\)</span>，取 <span class="math inline">\(u_i(x_j)=\begin{cases} 1, &amp; j=i \\ 0, &amp; j\neq i \end{cases}\)</span>；同时 <span class="math inline">\(u_n(x_j)=\begin{cases} 1, &amp; j\geqslant n \\ 0, &amp; j&lt; n \end{cases}\)</span>. 此时，一个集合若对所有代理人都是agreeable的，则必须包含 <span class="math inline">\(x_1,\cdots,x_{n-1}\)</span>，以及 <span class="math inline">\(\{x_n,\cdots,x_m\}\)</span> 的至少一半，共计 <span class="math inline">\(n-1+\lceil\frac{m-n+1}{2}\rceil=\lceil\frac{m+n-1}{2}\rceil=\lfloor\frac{m+n}{2}\rfloor\)</span>.</li></ul></blockquote><p>至此，我们已经完成了一般情形的证明，接下来文章对如何获得这样的agreeable set进行了讨论.</p><h3 id="获取最坏上界的agreeable-set">获取最坏上界的agreeable set</h3><h4 id="二人情形">二人情形</h4><p>二人情形中，我们只需知道单物品偏好即可得到对二人都necessarily agreeable的集合. 在此我们假设所有偏好是responsive的，并且可以将单物品偏好扩展为 <span class="math inline">\(\mathcal{S}\)</span> 上的偏序.</p><ul><li>算法的思路是：按 <span class="math inline">\(1\)</span> 的偏好排序，然后分组，按照 <span class="math inline">\(2\)</span> 的偏好进行选择.</li></ul><p>具体的内容由下面的定理给出：</p><blockquote><p><strong>Th 2.</strong> （两人情形）给定两个代理人在 <span class="math inline">\(S\)</span> 上的单物品偏好 <span class="math inline">\(\succeq_1^{sing}\)</span> 和 <span class="math inline">\(\succeq_2^{sing}\)</span>，存在 <span class="math inline">\(T\subset S\)</span>，s.t. <span class="math inline">\(|T|\leqslant \lfloor\frac{m+2}{2}\rfloor\)</span>，且 <span class="math inline">\(T\)</span> 对 <span class="math inline">\(\succeq_1^{sing}\)</span> 和 <span class="math inline">\(\succeq_2^{sing}\)</span> 都是necessarily agreeable的. 并且可在多项式时间内求得一个这样的 <span class="math inline">\(T\)</span>.<br>进一步，存在一组偏好，使得这个界是紧的.</p></blockquote><blockquote><p><strong>Proof.</strong> 分奇偶性来讨论：</p><ol type="1"><li>当 <span class="math inline">\(m=2k+1\)</span> 时，不妨设 <span class="math inline">\(x_1\succeq_1^{sing} x_2\succeq_1^{sing}\cdots\succeq_1^{sing}x_{2k+1}\)</span>. 此时按照如下方法进行选择：</li></ol><blockquote><ol type="1"><li><span class="math inline">\(x_1\)</span> 加入集合 <span class="math inline">\(T\)</span>；</li><li>在 <span class="math inline">\((x_2,x_3),(x_4,x_5),\cdots,(x_{2k},x_{2k+1})\)</span> 中，每一对都选取 <span class="math inline">\(2\)</span> 更喜欢的那个，加入集合 <span class="math inline">\(T\)</span>.</li></ol></blockquote><p>这样选择得到的集合 <span class="math inline">\(T\)</span> 显然对 <span class="math inline">\(\forall j=1,\cdots,m\)</span> 都满足 <span class="math inline">\(|T\cap I_j|\geqslant j/2\)</span>，因此由 <strong>Prop 1</strong> 可知 <span class="math inline">\(T\)</span> 对 <span class="math inline">\(1\)</span> 是necessarily agreeable的. 进一步，由于算法的第2步在每一对中都选择了 <span class="math inline">\(2\)</span> 更喜欢的物品，所以同样可由 <strong>Prop 1</strong> 知，<span class="math inline">\(T\)</span> 对 <span class="math inline">\(2\)</span> 是necessarily agreeable的.</p><ol start="2" type="1"><li>当 <span class="math inline">\(m=2k\)</span> 时，令 <span class="math inline">\(S&#39;=S\backslash\{x_1\}\)</span>. 则由奇数的结果可知，<span class="math inline">\(S&#39;\)</span> 中可以取出一个子集 <span class="math inline">\(T\)</span>，s.t. <span class="math inline">\(|T|=k\)</span>，且 <span class="math inline">\(T\)</span> 对两位代理人都是necessarily agreeable的. 此时只需将 <span class="math inline">\(x_1\)</span> 也添加进集合，即有 <span class="math inline">\(|T\cup\{x_1\}|=k+1=\lfloor\frac{m+2}{2}\rfloor\)</span>，且对二者都是necessarily agreeable的.</li></ol><p>综上，命题得证.</p></blockquote><blockquote><p><strong>一组偏好，使得界是紧的</strong> 先不写了，有空再补.</p></blockquote><h4 id="三人情形">三人情形</h4><p>三人情形下，无法只使用单物品偏好得到最坏上界的necessarily agreeable set. 以下是一个例子：</p><blockquote><p><strong>Ex. 1.</strong> 令 <span class="math inline">\(m=6\)</span>，三个人的单物品偏好如下：</p><ol type="1"><li><span class="math inline">\(x_1\succ_1^{sing} x_4\succ_1^{sing} x_5\succ_1^{sing} x_6\succ_1^{sing} x_2\succ_1^{sing} x_3\)</span>;</li><li><span class="math inline">\(x_2\succ_2^{sing} x_5\succ_2^{sing} x_6\succ_2^{sing} x_4\succ_2^{sing} x_3\succ_2^{sing} x_1\)</span>;</li><li><span class="math inline">\(x_3\succ_3^{sing} x_6\succ_3^{sing} x_4\succ_3^{sing} x_5\succ_3^{sing} x_1\succ_3^{sing} x_2\)</span>.</li></ol><p>若 <span class="math inline">\(T\subset S\)</span> 对三人都是necessarily agreeable的，则必须包含 <span class="math inline">\(\{x_1,x_2,x_3\}\)</span> 以及 <span class="math inline">\(\{x_4,x_5,x_6\}\)</span> 中的至少两个，这样有 <span class="math inline">\(|T|\geqslant 5\)</span>. 但是，若知道完整的偏好，由 <strong>Th 1</strong> 可知，<span class="math inline">\(|T|\leqslant 4\)</span> 即可.</p></blockquote><p>于是三人的情形不能再只使用单物品偏好，需要访问其完整偏好. 考虑到单单是读取完整偏好就已不能在多项式时间内完成，故认为存在一个偏好数据库，我们的多项式时间算法实际上是对该数据库进行多项式次数的访问，每次获取两个集合对于某个代理人的好坏关系.</p><blockquote><p><strong>Th 3.</strong> （三人情形）假设存在三个代理人，在 <span class="math inline">\(\mathcal{S}\)</span> 上的偏好分别为 <span class="math inline">\(\succeq_1\)</span>，<span class="math inline">\(\succeq_2\)</span>，<span class="math inline">\(\succeq_3\)</span>. 则存在多项式算法，在多项式时间内可以求得一个 <span class="math inline">\(T\subset S\)</span>，s.t. <span class="math inline">\(|T|\leqslant \lfloor\frac{m+3}{2}\rfloor\)</span>，且 <span class="math inline">\(T\)</span> 对三个人都是agreeable的.</p></blockquote><blockquote><p><strong>Proof</strong> 仍然分奇偶性来讨论：</p><ol type="1"><li>当 <span class="math inline">\(m=2k\)</span> 为偶数：我们的目标是找到一个大小为 <span class="math inline">\(\lfloor\frac{m+3}{2}\rfloor=k+1\)</span> 的集合 <span class="math inline">\(T\)</span>，使其对三个代理人都是agreeable的. 不妨设 <span class="math inline">\(x_{2k-1}\)</span> 是 <span class="math inline">\(1\)</span> 最喜欢的，<span class="math inline">\(x_{2k}\)</span> 是 <span class="math inline">\(2\)</span> （除 <span class="math inline">\(x_{2k-1}\)</span> 外）最喜欢的，且对于剩下的 <span class="math inline">\(2k-2\)</span> 个元素，有 <span class="math inline">\(x_1\succeq_1\cdots\succeq_1 x_{2k-2}\)</span>. <font color="red">（按 <span class="math inline">\(1\)</span> 排序）</font><br>记 <span class="math inline">\(A=\{x_1,\cdots,x_{2k-2}\}\)</span>，考虑 <span class="math inline">\((x_1,x_2),(x_3,x_4),\cdots,(x_{2k-3},x_{2k-2})\)</span>. 令 <span class="math inline">\(B\)</span> 为上述二元组中 <span class="math inline">\(2\)</span> 不喜欢的元素所构成的 <span class="math inline">\(k-1\)</span> 元集合，则由responsive可知，<span class="math inline">\(A\backslash B\succeq_2 B\)</span>.<br>现考虑一个过程：</li></ol><blockquote><p>只要 <span class="math inline">\(A\backslash B\succeq_2 B\)</span>，就取 <span class="math inline">\(B\)</span> 中的一个元素以及 <span class="math inline">\(A\backslash B\)</span> 中与其曾在同一个二元组中的元素，二者交换，形成新的 <span class="math inline">\(B\)</span> 和 <span class="math inline">\(A\backslash B\)</span>.</p></blockquote><p>在这个操作中，我们至多进行 <span class="math inline">\(k-1\)</span> 步，就一定能得到一个 <span class="math inline">\(B\succeq_2 A\backslash B\)</span> 的状态. 此时有两种情况，分述如下：</p><blockquote><ul><li>我们根本无需进行任何操作：即 <span class="math inline">\(B\sim_2 A\backslash B\)</span>，于是由单调性，可得 <span class="math inline">\((A\backslash B)\cup\{x_{2k}\}\succeq_2 B\)</span>，以及 <span class="math inline">\(B\cup\{x_{2k}\}\succeq_2 A\backslash B\)</span>.</li><li>我们进行了至少一步的操作：此时，不妨设我们的最后一步操作是将 <span class="math inline">\(x_{2i-1}\)</span> 插入 <span class="math inline">\(B\)</span>，并将 <span class="math inline">\(x_{2i}\)</span> 移出 <span class="math inline">\(B\)</span>. 令 <span class="math inline">\(C=(A\backslash B\backslash \{x_{2i}\})\cup\{x_{2i-1}\}\)</span>，<span class="math inline">\(D=(B\backslash \{x_{2i-1}\})\cup\{x_{2i}\}\)</span>，则我们有 <span class="math inline">\(C\succ_2 D\)</span>，且 <span class="math inline">\(B\succeq_2 A\backslash B\)</span>，并由单调性可得 <span class="math inline">\(C\cup\{x_{2k}\}\succeq_2 D\)</span>，且 <span class="math inline">\(B\cup\{x_{2k}\}\succeq_2 A\backslash B\)</span>. <strong>至此，我们断言 <span class="math inline">\(D\cup\{x_{2k}\}\succeq_2 C\)</span> 和 <span class="math inline">\((A\backslash B)\succeq_2 B\cup\{x_{2k}\}\)</span> 中至少有一个成立.</strong></li></ul><blockquote><p><strong>断言的正确性：</strong>事实上，若 <span class="math inline">\(C\succ_2 D\cup\{x_{2k}\}\)</span>，且 <span class="math inline">\(B\succ_2 (A\backslash B)\cup\{x_{2k}\}\)</span>，则 <span class="math display">\[C\succ_2 D\cup\{x_{2k}\}\succeq_2 B\succ_2 (A\backslash B)\cup\{x_{2k}\} \succeq_2 C.\]</span> 矛盾！于是断言成立.</p></blockquote></blockquote><p>至此，两种情况我们都在多项式时间内找到了一个集合 <span class="math inline">\(E\in \begin{bmatrix} A \\ k-1 \end{bmatrix}\)</span>，s.t. 包含 <span class="math inline">\((x_1,x_2),(x_3,x_4),\cdots,(x_{2k-3},x_{2k-2})\)</span> 每个二元组中的恰好一个元素，且满足 <span class="math display">\[E\cup \{x_{2k}\}\succeq_2 A\backslash E,~(A\backslash E)\cup\{x_{2k}\}\succeq_2 E.\]</span> <font color="red">（用 <span class="math inline">\(2\)</span> 的偏好调节平衡）</font><br>我们即可以如下选取 <span class="math inline">\(k+1\)</span> 元的agreeable set：</p><blockquote><ol type="1"><li>选取 <span class="math inline">\(x_{2k-1}\)</span> 和 <span class="math inline">\(x_{2k}\)</span>.</li><li>按照 <span class="math inline">\(3\)</span> 的喜好选择 <span class="math inline">\(E\)</span> 和 <span class="math inline">\(A\backslash E\)</span> 中较好的那个. <font color="red">（让 <span class="math inline">\(3\)</span> 来选取）</font></li></ol></blockquote><p>以下证明如此选出的集合 <span class="math inline">\(T\)</span> 对三个代理人都是agreeable的：</p><blockquote><ol type="1"><li><span class="math inline">\(\forall j=1,2,\cdots,m\)</span>，<span class="math inline">\(T\)</span> 在 <span class="math inline">\(1\)</span> 最喜欢的前 <span class="math inline">\(j\)</span> 个物品中都至少包含了 <span class="math inline">\(j/2\)</span> 个，故 <span class="math inline">\(T\)</span> 对 <span class="math inline">\(1\)</span> 来说是necessarily agreeable的；</li><li>由于 <span class="math inline">\(E\cup\{x_{2k}\}\succeq_2 A\backslash E\)</span>，<span class="math inline">\(A\backslash E\cup\{x_{2k}\}\succeq_2 E\)</span>，且 <span class="math inline">\(x_{2k-1},x_{2k}\in T\)</span>，故 <span class="math inline">\(T\)</span> 对 <span class="math inline">\(2\)</span> 是agreeable的；</li><li>由于在 <span class="math inline">\(E\)</span> 和 <span class="math inline">\(A\backslash E\)</span> 中我们选择了 <span class="math inline">\(3\)</span> 偏爱的那个，同时我们选择了剩余的所有元素（<span class="math inline">\(x_{2k-1}\)</span> 和 <span class="math inline">\(x_{2k}\)</span>），故 <span class="math inline">\(T\)</span> 对 <span class="math inline">\(3\)</span> 也是agreeable的.</li></ol></blockquote><ol start="2" type="1"><li>当 <span class="math inline">\(m=2k+1\)</span> 为奇数：此时 <span class="math inline">\(\lfloor\frac{m+3}{2}\rfloor=k+2\)</span>，于是只需考虑 <span class="math inline">\(S&#39;=S\backslash\{x_1\}\)</span>，利用偶数情形的结果求得满足条件的 <span class="math inline">\(T\subset S&#39;\)</span>，此时 <span class="math inline">\(|T|=k+1\)</span>. 于是只需取 <span class="math inline">\(T\cup \{x_1\}\)</span> 即可.</li></ol><p>综上，命题得证.</p></blockquote><h3 id="求necessarily-agreeable的集合">求necessarily agreeable的集合</h3><center>又到了我不喜欢但绕不开的估计和逼近…一大波不等式即将来袭Orz</center><ul><li>在此处的讨论中，只需访问每个代理人的单物品偏好即可.</li></ul><blockquote><p><strong>Th 4.</strong> 对任意常数个代理人，存在 <span class="math inline">\(T\in\begin{bmatrix}S\\ \frac{m}{2}+O(\log m)\end{bmatrix}\)</span>，s.t. <span class="math inline">\(T\)</span> 对所有代理人都是necessarily agreeable的. 这样的集合可在多项式时间内找出.</p></blockquote><p>要证明这个定理，需要一个引理做支持：</p><blockquote><p><strong>Lemma 2.</strong> 令 <span class="math inline">\(\sigma_1,\cdots,\sigma_n\)</span> 是集合 <span class="math inline">\(M=\{1,\cdots,m\}\)</span> 的排列. 则存在函数 <span class="math inline">\(f:M\to \{-1,1\}\)</span>，.s.t. <span class="math display">\[\left| \sum\limits_{i=p}^q f(\sigma_j(i)) \right|\leqslant 8n\log m,~~\forall 1\leqslant p\leqslant q\leqslant m~and~1\leqslant j\leqslant n.\]</span> 进一步，这样的函数可以在多项式时间内被找到.</p></blockquote><p>有了这个引理，即可证明 <strong>Th 4</strong>.</p><blockquote><p><strong>Proof to Th 4.</strong> 设代理人 <span class="math inline">\(j\)</span> 的单物品偏好为 <span class="math inline">\(x_{\sigma_j(1)}\succeq_j^{sing}x_{\sigma_j(2)}\succeq_j^{sing}\cdots\succeq_j^{sing}x_{\sigma_j(m)}\)</span>. 由 <strong>Lemma 2</strong>，我们可以在多项式时间内找到一个函数 <span class="math inline">\(f:S\to\{-1,1\}\)</span>，s.t. <span class="math display">\[\left| \sum\limits_{i=1}^q f(x_{\sigma_j(i)}) \right|\leqslant 8n\log m,~~\forall q=1,\cdots,m~and~j=1,\cdots,n.\]</span> 现按照如下方法建立一个集合：</p><blockquote><ol type="1"><li>将所有满足 <span class="math inline">\(f(x_i)=1\)</span> 的 <span class="math inline">\(x_i\)</span> 加入集合<span class="math inline">\(T\)</span>；</li><li>剩余物品中，将每个代理人偏好中的前 <span class="math inline">\(\lceil 4n\log m \rceil\)</span> 也加入集合<span class="math inline">\(T\)</span>（若某个代理人的偏好中，剩余物品已不足，则全加入集合）.</li></ol></blockquote><p>对 <span class="math inline">\(i=1,\cdots,m\)</span>，令 <span class="math inline">\(X_i\)</span> 为指示变量：<span class="math inline">\(X_i=\begin{cases}1, &amp; x_i\in T \\ -1, &amp; x_i\notin T\end{cases}\)</span>，则对任意代理人 <span class="math inline">\(j\)</span> 和 <span class="math inline">\(\forall i=1,2,\cdots,m\)</span>，有： <span class="math display">\[X_{\sigma_j(1)}+X_{\sigma_j(2)}+\cdots+X_{\sigma_j(i)}\geqslant \min\{i, -8n\log m+2\cdot\lceil 4n\log m \rceil\}\geqslant 0.\]</span> 上式意味着：<strong>前 <span class="math inline">\(i\)</span> 个物品中<font color="red">在</font> <span class="math inline">\(T\)</span> 内的个数</strong> <span class="math inline">\(-\)</span> <strong>前 <span class="math inline">\(i\)</span> 个物品中<font color="red">不在</font> <span class="math inline">\(T\)</span> 内的个数</strong> <span class="math inline">\(\geqslant 0\)</span>，即 <span class="math inline">\(\forall i\)</span>，<span class="math inline">\(|T\cap I_i|\geqslant i/2\)</span>，故由 <strong>Prop 1.</strong> 可知，<span class="math inline">\(T\)</span> 对 <span class="math inline">\(\forall j\)</span> 都是necessarily agreeable的.</p><p>进一步，集合 <span class="math inline">\(T\)</span> 的规模至多为： <span class="math display">\[\frac{m}{2}+(n+1)\cdot \lceil 4n\log m \rceil = \frac{m}{2}+O(\log m).\]</span></p><p>综上，命题得证.</p></blockquote><p>进一步，这个界是渐进紧的：</p><blockquote><p><strong>Th 5.</strong> 假设 <span class="math inline">\(m=3^k\)</span>，<span class="math inline">\(k&gt;0\)</span>，则存在三个代理人的单物品偏好，s.t. 所有对三个人都necessarily agreeable的集合都至少具有 <span class="math inline">\(\frac{m}{2}+\Omega(\log m)\)</span> 的规模.</p></blockquote><p>要证明该定理，需要一个引理.</p><blockquote><p><strong>Lemma 3.</strong> 给定 <span class="math inline">\(k\in\mathbb{R}^+\)</span>，令 <span class="math inline">\(m=3^k\)</span>，<span class="math inline">\(M=\{1,2,\cdots,m\}\)</span>. 存在三个排列 <span class="math inline">\(\sigma_1,\sigma_2,\sigma_3\)</span>，s.t. <span class="math inline">\(\forall f:M\to \{-1,1\}\)</span>，记 <span class="math inline">\(\Delta =\sum\nolimits_{i\in M} f(i)\geqslant 1\)</span>，则存在 <span class="math inline">\(1\leqslant q\leqslant m\)</span> 和 <span class="math inline">\(1\leqslant j\leqslant 3\)</span>，s.t. <span class="math display">\[\sum\limits_{i=1}^q f(\sigma_j(i))\leqslant \frac{-k+2\Delta-2}{3}.\]</span></p></blockquote><p>有了这个引理，即可证明 <strong>Th 5</strong>：</p><blockquote><p><strong>Proof to Th 5.</strong> 设 <span class="math inline">\(\sigma_1,\sigma_2,\sigma_3\)</span> 是 <span class="math inline">\(S=\{x_1,\cdots,x_m\}\)</span> 满足 <strong>Lemma 3</strong> 的三个排列，对于 <span class="math inline">\(\forall j=1,2,3\)</span>，设代理人 <span class="math inline">\(j\)</span> 的偏好是 <span class="math inline">\(x_{\sigma_j(1)}\succeq_j^{sing}x_{\sigma_j(2)}\succeq_j^{sing}\cdots\succeq_j^{sing}x_{\sigma_j(m)}\)</span>.<br>考虑 <span class="math inline">\(\forall T\subset\)</span>，s.t. <span class="math inline">\(|T|\leqslant m/2+k/4\)</span>. 以下证明 <span class="math inline">\(T\)</span> 不可能同时对三个都是necessarily agreeable的：</p><p>构造指示器函数 <span class="math inline">\(f_T:S\to\{-1,1\}\)</span>，<span class="math inline">\(f_T(x_i)=\begin{cases}1, &amp; x_i\in T \\ -1, &amp; x_i\notin T\end{cases}\)</span>，由于 <span class="math inline">\(|T|\leqslant m/2+k/4\)</span>，故 <span class="math inline">\(\Delta_T=\sum\limits_{i=1}^m f(x_i)=|T|-|S\backslash T|\leqslant k/2\)</span>.</p><blockquote><ul><li>若 <span class="math inline">\(\Delta_T&lt;0\)</span>，则 <span class="math inline">\(T\)</span> 显然不是necessarily agreeable的；</li><li>若 <span class="math inline">\(\Delta_T\geqslant 0\)</span>，由 <span class="math inline">\(T\)</span> 是奇数且 <span class="math inline">\(\Delta\in\mathbb{Z}\)</span>，可知 <span class="math inline">\(\Delta_T\geqslant 1\)</span>. 此时由 <strong>Lemma 3</strong> 可知，<span class="math inline">\(\exists 1\leqslant q\leqslant m\)</span> 和 <span class="math inline">\(1\leqslant j\leqslant 3\)</span>，s.t. <span class="math display">\[\sum\limits_{i=1}^q f_T(\sigma_j(x_i))\leqslant \frac{-k+2\Delta-2}{3}\leqslant \frac{-k+k-2}{3}&lt;0.\]</span> 即此时 <span class="math inline">\(T\)</span> 也不是necessarily agreeable的.</li></ul></blockquote><p>综上，<span class="math inline">\(T\)</span> 不是necessarily agreeable的. 又由于 <span class="math inline">\(k=\log_3 m\)</span>，故necessarily agreeable的集合至少具有 <span class="math inline">\(m/2+\Omega(\log m)\)</span> 的规模. 命题得证.</p></blockquote><h4 id="计算necessarily-agreeable-set的随机算法">计算necessarily agreeable set的随机算法</h4><p>该算法的分析和证明将用到概率论中著名的 Chernoff bound 和 Levy’s inequality：</p><blockquote><p><strong>Lemma 4.</strong> (Chernoff bound) 令 <span class="math inline">\(X_1,X_2,\cdots,X_r\)</span> 是 i.i.d. 的随机变量，都服从 <span class="math inline">\({\rm Pr}[X_i=1]={\rm Pr}[X_i=-1]=1/2\)</span> 的两点分布，记 <span class="math inline">\(X=X_1+\cdots+X_r\)</span>，则有： <span class="math display">\[{\rm Pr}[|X|\geqslant a]\leqslant \exp(-\frac{a^2}{2r}),~~\forall a\geqslant 0.\]</span></p></blockquote><blockquote><p><strong>Lemma 5.</strong> (Levy 不等式) 令 <span class="math inline">\(X_1,X_2,\cdots,X_r\)</span> 是 i.i.d. 的随机变量，都服从 <span class="math inline">\({\rm Pr}[X_i=1]={\rm Pr}[X_i=-1]=1/2\)</span> 的两点分布，记 <span class="math inline">\(Y_i=X_1+\cdots+X_i\)</span>，<span class="math inline">\(\forall i\)</span>. 则有： <span class="math display">\[{\rm Pr}\left[ \max\limits_{1\leqslant i\leqslant r}|Y_i|\geqslant x \right]\leqslant 2{\rm Pr}[|Yr|\geqslant x],~~\forall x\in\mathbb{R}.\]</span></p></blockquote><p>具体的算法由下述的 <strong>Th 6</strong> 给出：</p><blockquote><p><strong>Th 6.</strong> 假设代理人的数目是常数，取常数 <span class="math inline">\(\epsilon\in (0,1)\)</span>，<span class="math inline">\(c&gt;0\)</span>，s.t. <span class="math inline">\(\exp(-\frac{c^2}{2})\leqslant \frac{\epsilon}{2n}\)</span><font color="red">（我认为这只是个技术性的条件，用来调节平衡）</font>. 考虑下述的多项式时间算法：</p><ol type="1"><li><code>FOR</code> 每个元素，每个元素都有 <span class="math inline">\(1/2\)</span> 概率加入集合 <span class="math inline">\(T\)</span>，<span class="math inline">\(1/2\)</span> 概率不加入. 并且当前元素是否加入与其他元素无关；</li><li>对每个代理人，将剩余物品中，他们偏好的前 <span class="math inline">\(\lfloor c\sqrt{m}\rfloor\)</span> 位加入集合 <span class="math inline">\(T\)</span>.</li></ol><p>上述算法至少能以 <span class="math inline">\(1-\epsilon\)</span> 的概率求出一个规模为 <span class="math inline">\(m/2+O(\sqrt{m})\)</span> 的necessarily agreeable的集合.</p></blockquote><p><font color="red">一点粗浅的理解：</font><br><font color="red">1. 第一步借用 <strong>Lemma 4,5</strong> 构造一个集合；</font><br><font color="red">2. 第二步补一些元素，把元素个数凑够，满足 <strong>Prop 1</strong> 的要求.</font></p><blockquote><p><strong>Proof.</strong> 设 <span class="math inline">\(X_1,\cdots,X_m\)</span> 分别是 <span class="math inline">\(x_1,\cdots,x_m\)</span> 的指示变量，<span class="math inline">\(X_i=\begin{cases}1, &amp; x_i\in T\\ -1, &amp; x_i\notin T\end{cases}\)</span>，则 <span class="math inline">\(X_1,\cdots,x_m\)</span> 是 i.i.d. 的变量，且都服从 <span class="math inline">\((1/2,1/2)\)</span> 的两点分布.<br>对于 <span class="math inline">\(j=1,\cdots,m\)</span>，记代理人 <span class="math inline">\(j\)</span> 的单物品偏好为 <span class="math inline">\(x_{\sigma_j(1)}\succeq^{sing}_jx_{\sigma_j(2)}\succeq^{sing}_j\cdots \succeq^{sing}_jx_{\sigma_j(m)}\)</span>. 令 <span class="math inline">\(Y_i^j=X_{\sigma_j(1)}+\cdots+X_{\sigma_j(i)}\)</span>，<span class="math inline">\(i\in\{1,2,\cdots,n\}\)</span>. 取 <span class="math inline">\(a=c\sqrt{m}\)</span>，由 <strong>Lemma 4</strong>，有： <span class="math display">\[{\rm Pr}\left[ |Y_m^j|\geqslant c\sqrt{m} \right]\leqslant \exp(-\frac{c^2}{2}).\]</span> 又由 <strong>Lemma 5</strong>，<span class="math inline">\(X_{\sigma_j(i)}\)</span> 满足：<font color="red">（给 <span class="math inline">\(|T\cap I_i|-|T^c\cap I_i|\)</span> 估界）</font> <span class="math display">\[{\rm Pr}\left[ \max\limits_{1\leqslant i\leqslant m} |Y_i^j|\geqslant c\sqrt{m} \right]\leqslant 2\exp(-\frac{c^2}{2}).\]</span> 由于一共有 <span class="math inline">\(n\)</span> 个代理人，每个代理人都满足以上式子，故 <span class="math display">\[{\rm Pr}\left[\exists j,~\max\limits_{1\leqslant i\leqslant m} |Y_i^j| \right]\leqslant 2n\cdot c\sqrt{m}\leqslant \epsilon.\]</span> 于是，至少有 <span class="math inline">\(1-\epsilon\)</span> 的概率 <span class="math inline">\(\forall i,j\)</span>，<span class="math inline">\(Y_i^j\in [-\lfloor c\sqrt{m}\rfloor,\lfloor c\sqrt{m}\rfloor]\)</span>. 考虑到我们在算法的第二步中将所有代理人偏好的前 <span class="math inline">\(\lfloor c\sqrt{m}\rfloor\)</span> 个物品都加入了集合 <span class="math inline">\(T\)</span> 中，这使得 <span class="math inline">\(Y_i^j\geqslant\)</span>，<span class="math inline">\(\forall j\)</span>. 结合 <strong>Prop 1</strong> 可知，<span class="math inline">\(T\)</span> 对于所有代理人都是necessarily agreeable的.</p><p>由于我们在第一步至多加入了 <span class="math inline">\(m/2+c\sqrt{m}\)</span> 个物品，第二步每个代理人至多加入了 <span class="math inline">\(c\sqrt{m}\)</span>，即集合 <span class="math inline">\(T\)</span> 的规模至多是 <span class="math display">\[\frac{m}{2}+(n+1)\cdot c\sqrt{m}=\frac{m}{2}+O(\sqrt{m}).\]</span> 命题得证~</p></blockquote><h2 id="一般情形">一般情形</h2><h3 id="一般情形下的近似">一般情形下的近似</h3><p>前文讨论的全部都是一个对所有情况普适的结果，这里我们开始讨论一般的情形. 即，具体的一组偏好，如何找到规模最小的agreeable set？事实上，这个问题可能是困难的，因此这里只提供了一个近似的解.</p><p>要解决这个问题，我们首先要处理的就是偏好的问题. 对于给定的 <span class="math inline">\(S\)</span>，其子集数量是指数级别，故我们也需要指数级别的空间来存储偏好. 因而任何多项式的算法都无法读取完整的效用函数. 在这里使用value oracle model，即算法可以在确定了 <span class="math inline">\(T\subset S\)</span> 以及 <span class="math inline">\(i=1,2,\cdots,n\)</span> 的情况下，查询 <span class="math inline">\(u_i(T)\)</span> 的值.</p><p>文章给出的结果是一个多项式时间的算法，能够计算出近似比为 <span class="math inline">\(O(m/\log m)\)</span> 的近似最优解. 尽管看起来并不好（前文所述的普适上界只有 <span class="math inline">\(O(m)\)</span>，此处只优化了 <span class="math inline">\(\Omega(\log m)\)</span>），但文章认为这已是多项式时间内可达到的最好情况.</p><p>具体的算法分析由以下定理给出：</p><blockquote><p><strong>Th 7.</strong> 存在一个多项式时间的 <span class="math inline">\(O(m/\log m)\)</span> 近似算法，能在value oracle model下求出近似最小的agreeable set.</p></blockquote><blockquote><p><strong>Proof.</strong> 将 <span class="math inline">\(S\)</span> 分为 <span class="math inline">\(\lceil\log m\rceil\)</span> 组（注意是不交并），记为 <span class="math inline">\(S_1,\cdots,S_{\lceil\log m\rceil}\)</span>，每个组的大小不超过 <span class="math inline">\(\lceil m/\log m \rceil\)</span>. 对于每个 <span class="math inline">\(A\subset \{1,2,\cdots,\lceil\log m\rceil\}\)</span>，判断 <span class="math inline">\(\bigcup_{i\in A} S_i\)</span> 是否是agreeable的（与其补集比较即可）， 最后算法输出上述步骤所得到的规模最小的agreeable set. 由于算法中 <span class="math inline">\(A\)</span> 的选取只有 $ m$ 的指数，即 <span class="math inline">\(m\)</span> 的多项式种可能，于是整个算法复杂度是关于 <span class="math inline">\(m,n\)</span> 的多项式.</p><p>以下证明算法的近似比是 <span class="math inline">\(O(m/\log m)\)</span>：<br>记最小的agreeable set为 <span class="math inline">\(S^*\)</span>，其规模为 <span class="math inline">\(k\)</span>. 构造集合 <span class="math inline">\(T=\bigcup_{x\in S^*} (S_i:x\in S_i)\)</span>（把 <span class="math inline">\(S^*\)</span> 中所有元素所属的 <span class="math inline">\(S_i\)</span> 并起来），则 <span class="math inline">\(T\)</span> 是我们在算法中检查过的集合，故算法输出的集合规模一定不大于 <span class="math inline">\(T\)</span>. 由单调性，<span class="math inline">\(T\)</span> 显然是agreeable的，结合 <span class="math inline">\(|T|\leqslant k\cdot \lceil\log m\rceil\)</span>，可知算法输出的集合的规模不会超过最小集合的 <span class="math inline">\(O(m/\log m)\)</span>.</p><p>得证！</p></blockquote><blockquote><p><strong>Th 8.</strong> 对于每个常数 <span class="math inline">\(c&gt;0\)</span>，<span class="math inline">\(\exists m_0\)</span>，s.t. <span class="math inline">\(\forall m&gt;m_0\)</span>，不存在：只进行不超过 <span class="math inline">\(m^{c/8}\)</span> 次询问，却能得到规模至多是最优解 <span class="math inline">\(m/(c\log m)\)</span> 倍的agreeable set的算法. 即使只有一个代理人，也不行！</p></blockquote><blockquote><p><strong>Proof.</strong> 构造函数 <span class="math inline">\(g(T)=\begin{cases}1,&amp; |T|\geqslant \frac{m}{2};\\ 0,&amp; otherwise.\end{cases}\)</span>，进一步，定义 <span class="math inline">\(f_{T^*}(T)=\begin{cases}1, &amp; |T|\geqslant\frac{m}{2}~or~T^*\subset T， \\ 0, &amp; otherwise.\end{cases}\)</span>.<br>考虑只能进行至多 <span class="math inline">\(m^{c/8}\)</span> 次询问的算法 <span class="math inline">\(\mathcal{A}\)</span>（暂时假定 <span class="math inline">\(A\)</span> 是确定性的算法），进行如下讨论：</p><blockquote><ul><li>当 <span class="math inline">\(g\)</span> 作为效用函数：设 <span class="math inline">\(\mathcal{A}\)</span> 在运算中查询的所有集合为 <span class="math inline">\(T_1,T_2,\cdots,T_{\lfloor m^{c/8} \rfloor}\)</span>；</li><li>当 <span class="math inline">\(f_{T^*}\)</span> 作为效用函数：在 <span class="math inline">\(S\)</span> 中随机取一个含 <span class="math inline">\(\lfloor c\log m/4 \rfloor\)</span> 个元素的子集作为 <span class="math inline">\(T^*\)</span>，设 <span class="math inline">\(\mathcal{A}\)</span> 在运算中查询的所有集合为 <span class="math inline">\(T&#39;_1,T&#39;_2,\cdots,T&#39;_{\lfloor m^{c/8} \rfloor}\)</span>.</li></ul></blockquote><p>考虑任意的 <span class="math inline">\(j=1,2,\cdots,\lfloor m^{c/8} \rfloor\)</span>，若 <span class="math inline">\(T_i=T_i&#39;\)</span> 且 <span class="math inline">\(g(T_i)=f_{T^*}(T_i&#39;)\)</span>，<span class="math inline">\(\forall i=1,\cdots,j-1\)</span>，则 <span class="math inline">\(\mathcal{A}\)</span> 在两种效用函数下的计算路径是一样的，因此有 <span class="math inline">\(T_j=T_j&#39;\)</span><font color="red">（？）</font> 进一步，若目前为止，两种情况下算法的计算路径相同且 <span class="math inline">\(T_j=T_j&#39;\)</span>，我们对 <span class="math inline">\({\rm Pr}[g(T_j)\neq f_{T^*}(T_j&#39;)]\)</span> 有如下估计：</p><blockquote><p>首先，若 <span class="math inline">\(|T_j|\geqslant m/2\)</span>，则 <span class="math inline">\(g(T_j)\)</span> 显然与 <span class="math inline">\(f_{T^*}(T_j&#39;)\)</span> 相等； 若不然，有： <span class="math display">\[{\rm Pr}[g(T_j)\neq f_{T^*}(T_j&#39;)]=Pr[T^*\subset T_j].\]</span> 若 <span class="math inline">\(|T_j|&lt;|T^*|\)</span>，这个概率显然为 <span class="math inline">\(0\)</span>. 若不然，由于 <span class="math inline">\(T_j\)</span> 与 <span class="math inline">\(T^*\)</span> 无关，故有： <span class="math display">\[\begin{align} {\rm Pr}[T^*\subset T_j] &amp;= \frac{ \binom{|T_j|}{\lfloor c\log m/4 \rfloor} }{ \binom{m}{\lfloor c\log m/4 \rfloor} } \\ &amp;= \left(\frac{|T_j|}{m}\right)\left(\frac{|T_j|-1}{m-1}\right)\cdots\left(\frac{|T_j|-\lfloor c\log m/4 \rfloor+1}{m-\lfloor c\log m/4 \rfloor+1}\right) \\ &amp;\leqslant \frac{|T_j|}{m}^{\lfloor c\log m/4 \rfloor} \\ &amp;\leqslant 2^{-\lfloor c\log m/4 \rfloor} \\ &amp;\leqslant 2m^{-c/4}. \end{align}\]</span></p></blockquote><p>由 Boole 不等式（union bound），两个序列不完全相同的概率至多是 <span class="math inline">\((2m^{-c/4})\cdot m^{c/8}\)</span>，当 <span class="math inline">\(m\)</span> 较大时显然小于 <span class="math inline">\(1/2\)</span>. 进一步，当序列完全相同时，考虑算法 <span class="math inline">\(\mathcal{A}\)</span> 的输出应当是一个在效用函数 <span class="math inline">\(g\)</span> 下也agreeable的集合<font color="red">（？）</font>，而由 <span class="math inline">\(g\)</span> 定义即知这样的集合规模至少为 <span class="math inline">\(m/2\)</span>. 因此，<span class="math inline">\(\mathcal{A}\)</span> 在效用函数 <span class="math inline">\(f_{T^*}\)</span> 下所输出的集合的规模的期望也至少是 <span class="math inline">\(m/2\cdot 1/2=m/4\)</span>. 然而，在 <span class="math inline">\(f_{T^*}\)</span> 下的最优解规模只有 <span class="math inline">\(\lfloor c\log m/4 \rfloor\)</span>. 于是，<span class="math inline">\(\mathcal{A}\)</span> 的近似比要大于 <span class="math inline">\(m/(c\log m)\)</span>.<br>最后，当 <span class="math inline">\(\mathcal{A}\)</span> 是随机算法时，也可以对每依次选择的随机性和所有选择的平均值使用以上的方法，并得到类似的结果.</p></blockquote><p>事实上，即使我们要求效用函数是次模函数或次可加函数，上述结果仍然保持. 证明思路类似.</p><h3 id="可加效用函数下的情形">可加效用函数下的情形</h3><ul><li>是否存在给定大小的agreeable set是NP问题；<ul><li>当 <span class="math inline">\(n\geqslant 2\)</span> 时：是NP完全的；</li><li>当 <span class="math inline">\(n=1\)</span> 时：贪心即可…</li></ul></li><li><span class="math inline">\(n\geqslant 2\)</span> 时的证明思路：规约到问题 <code>BALANCED 2-PARTITION</code>.<ul><li><code>BALANCED 2-PARTITION</code>：给定一个多重集非负整数 <span class="math inline">\(A\)</span>，判断是否存在 <span class="math inline">\(B\subset A\)</span>，s.t. <span class="math display">\[|B|=|A\backslash B|=|A|/2,~且~\sum\limits_{x\in B} x=\sum\limits_{x\in A\backslash B}x=\frac{\sum\limits_{x\in A} x}{2}.\]</span></li></ul></li></ul><blockquote><p><strong>Lemma 6.</strong> <code>BALANCED 2-PARTITION</code> 是NP完全的.</p></blockquote><blockquote><p><strong>Proof.</strong> 从 <code>2-PARTITION</code> 进行规约. （思路：补 <span class="math inline">\(0\)</span>）</p><ul><li><code>2-PARTITION</code> 实例：考虑可重集合 <span class="math inline">\(B\)</span>，求 <span class="math inline">\(T\subset B\)</span>，s.t. <span class="math inline">\(\sum_{x\in T}x=\sum_{x\in B\backslash T} x\)</span>.<br></li><li><code>BALANCED 2-PARTITION</code> 实例：给 <span class="math inline">\(B\)</span> 补 <span class="math inline">\(|B|\)</span> 个 <span class="math inline">\(0\)</span>，构成重集 <span class="math inline">\(A\)</span>，求 <span class="math inline">\(A\)</span> 的 <code>BALANCED 2-PARTITION</code>.</li></ul><p><span class="math inline">\(\Rightarrow\)</span>：设存在 <span class="math inline">\(B\)</span> 的一个 <code>2-PARTITION</code> 解 <span class="math inline">\(T\)</span>，则给 <span class="math inline">\(T\)</span> 补上 <span class="math inline">\(|B|-|T|\)</span> 个 <span class="math inline">\(0\)</span>，构成集合 <span class="math inline">\(S\subset A\)</span>，显然 <span class="math inline">\(S\)</span> 是 <span class="math inline">\(A\)</span> 的一个 <code>BALANCED 2-PARTITION</code>.</p><p><span class="math inline">\(\Leftarrow\)</span>：同样，设存在 <span class="math inline">\(A\)</span> 的一个 <code>BALANCED 2-PARTITION</code> 解 <span class="math inline">\(S\)</span>，将 <span class="math inline">\(S\)</span> 中原本不在 <span class="math inline">\(B\)</span> 中的元素扔掉（显然都是 <span class="math inline">\(0\)</span>），得到 <span class="math inline">\(T\subset B\)</span>，则 <span class="math inline">\(T\)</span> 是 <span class="math inline">\(B\)</span> 的一个 <code>2-PARTITION</code>.</p></blockquote><blockquote><p><strong>Th 9.</strong> 设有<font color="red">两个</font>代理人，其偏好都以可加效用函数给出，则“找到一个大小恰好为 <span class="math inline">\(m/2\)</span> 的agreeable set”的问题是NP的.</p></blockquote><blockquote><p><strong>Proof</strong> 从 <code>BALANCED 2-PARTITION</code> 进行规约.</p><ul><li><code>BALANCED 2-PARTITION</code> 实例：<span class="math inline">\(A=\{a_1,\cdots,a_{|A|}\}\)</span>.</li><li>寻找agreeable set的实例：<span class="math inline">\(S=\{x_1,\cdots,x_{|A|}\}\)</span>，<span class="math inline">\(\forall i\)</span>，<span class="math inline">\(u_1(x_i)=a_i\)</span>，<span class="math inline">\(u_2(x_i)=M-a_i\)</span>，其中 <span class="math inline">\(M=\sum_{a\in A}a\)</span>.</li></ul><p><span class="math inline">\(\Rightarrow\)</span>：若存在 <span class="math inline">\(B\subset A\)</span>，s.t. <span class="math inline">\(\sum_{x\in B}x=\frac{\sum_{x\in A} x}{2}\)</span> 且 $|B|=|A|/2. 取 <span class="math inline">\(T=\{x_i:i\in B\}\)</span>，则 <span class="math inline">\(T\)</span> 是一个agreeable set（<span class="math inline">\(u_1(T)=u_1(T^c),~u_2(T)=u_2(T^c)\)</span>） 且 <span class="math inline">\(|T|=|S|/2\)</span>.</p><p><span class="math inline">\(\Leftarrow\)</span>：设存在一个规模为 <span class="math inline">\(m/2\)</span> 的agreeable set <span class="math inline">\(T\)</span>，令 <span class="math inline">\(B\)</span> 为 <span class="math inline">\(T\)</span> 中元素下标所构成的集合. 由于 <span class="math inline">\(T\)</span> 是agreeable set，故 <span class="math inline">\(\sum_{x\in T}u_i(x)\geqslant \sum_{x\in S\backslash T} u_i(x)\)</span>，<span class="math inline">\(i=1,2\)</span>. <span class="math inline">\(i=1\)</span>时，上式意味着 <span class="math inline">\(\sum_{a\in B}a\geqslant \frac{\sum_{a\in A}a}{2}\)</span>. <span class="math inline">\(i=2\)</span> 时，上式意味着 <span class="math inline">\(\sum_{a\in B}a\leqslant \frac{\sum_{a\in A}}{2}\)</span>. 又易知 <span class="math inline">\(B\)</span> 元素个数为 <span class="math inline">\(A\)</span> 的一半，故 <span class="math inline">\(B\)</span> 是 <span class="math inline">\(A\)</span> 的一个 <code>BALANCED 2-PARTIION</code>.</p></blockquote><blockquote><p><strong>Th 10.</strong> 对任意常数个代理人，其偏好都以可加效用函数给出，则存在一个伪多项式时间的算法（pseudo-polynomial time algorithm），能够求得规模最小的agreeable set.</p></blockquote><blockquote><p><strong>Proof</strong> 用动态规划来解决：</p><p>记代理人 <span class="math inline">\(i\)</span> 对所有物品的效用总和为 <span class="math inline">\(\sigma_i\)</span>，用 <span class="math inline">\(\Sigma(m&#39;,y_1,\cdots,y_n)\)</span> 表示前 <span class="math inline">\(m&#39;\)</span> 个物品 <span class="math inline">\(\{x_1,\cdots,x_{m&#39;}\}\)</span> 中，要使代理人 <span class="math inline">\(i\)</span> 的效用恰好达到 <span class="math inline">\(\y_i\)</span> 的最小所需物品数，其中 <span class="math inline">\(0\leqslant m&#39;\leqslant m\)</span>，<span class="math inline">\(0\leqslant y_i\leqslant \sigma_i\)</span>，<span class="math inline">\(\forall i\)</span>.</p><ul><li>初值： - <span class="math inline">\(\Sigma(m&#39;,y_1,\cdots,y_n)=\begin{cases} 0, &amp; m&#39;=y_1=\cdots=y_n=0 \\ \infty, &amp; Otherwise \end{cases}\)</span>；</li><li>转移： - 若 <span class="math inline">\(\forall i\)</span>，<span class="math inline">\(u_i(x_{m&#39;})\leqslant y_i\)</span>，且 <span class="math inline">\(1+\Sigma(m&#39;-1,y_1-u_1(x_{m&#39;}),\cdots,y_n-u_n(x_{m&#39;}))&lt;\Sigma(m&#39;-1,y_1,\cdots,y_n)\)</span>，则<font color="red">（选了 <span class="math inline">\(x_{m&#39;}\)</span>）</font> <span class="math display">\[\Sigma(m&#39;,y_1,\cdots,y_n)=1+\Sigma(m&#39;-1,y_1-u_1(x_{m&#39;}),\cdots,y_n-u_n(x_{m&#39;}))\]</span> - 否则，<font color="red">（不选 <span class="math inline">\(x_{m&#39;}\)</span>）</font><span class="math display">\[\Sigma(m&#39;,y_1,\cdots,y_n)=\Sigma(m&#39;-1,y_1,\cdots,y_n).\]</span></li></ul><p>最终，我们查找在 <span class="math inline">\(\sigma(...)\)</span> 中是否存在对 <span class="math inline">\(\forall i\)</span> 都有 <span class="math inline">\(y_i\geqslant \sigma_i/2\)</span> 的项，若存在多个，取值最小者即可. 算法复杂度 <span class="math inline">\(O(m\sigma_1\cdots\sigma_n)\)</span>.</p></blockquote><blockquote><p><strong>Th 11.</strong> 若代理人数量不是常数，判断是否存在规模为 <span class="math inline">\(\frac{m+1}{2}\)</span> 的agreeable set 的问题是强NP完全的. （强NP完全指不存在伪多项式时间算法，除非 <span class="math inline">\(P=NP\)</span>.）</p></blockquote><blockquote><p><strong>Proof</strong> 从 <code>3SAT</code> 进行规约.</p><ul><li><code>3SAT</code> 实例 <span class="math inline">\(\phi\)</span>：<span class="math inline">\(n&#39;\)</span> 个变量 <span class="math inline">\(y_1,\cdots,y_{n&#39;}\)</span>，<span class="math inline">\(m&#39;\)</span> 个约束 <span class="math inline">\(C_1,\cdots,C_{m&#39;}\)</span>.</li><li>判断agreeable set存在性的实例： - <span class="math inline">\(n=m&#39;+n&#39;\)</span> 个代理人，记为 <span class="math inline">\([n]=\{C_1,\cdots,C_{m&#39;},y_1,\cdots,y_{n&#39;}\}\)</span>； - <span class="math inline">\(m=2n&#39;+1\)</span> 个物品： - 只有涉及到的代理人才会喜欢的 <span class="math inline">\(\{y_i,\lnot y_i:1\leqslant i\leqslant n&#39;\}\)</span> （共 <span class="math inline">\(2n&#39;\)</span> 个）； - 人见人爱的 <span class="math inline">\(a\)</span> （<span class="math inline">\(1\)</span> 个）. - 效用函数： - <span class="math inline">\(u_{C_i}(b)=\begin{cases} 1, &amp; b=a~或~b~在~C_i~中出现\\ 0, &amp; otherwise \end{cases}\)</span> - <span class="math inline">\(u_{y_i}(b)=\begin{cases} 1, &amp; b=y_i~或~\lnot y_i~或~a \\ 0, &amp; otherwise \end{cases}\)</span></li></ul><p><span class="math inline">\(\Rightarrow\)</span>：设 <span class="math inline">\(\phi\)</span> 是可满足的，存在一个解，其中 <span class="math inline">\(y_i\)</span> 的值为 <span class="math inline">\(b_i\)</span>. 考虑集合 <span class="math inline">\(T=\{a,b_1,\cdots,b_{n&#39;}\}\)</span>. 则对于 <span class="math inline">\(\forall C_j\)</span>，<span class="math inline">\(T\)</span> 包含了 <span class="math inline">\(C_j\)</span> 所喜欢的 <span class="math inline">\(y_i\)</span> 的一半，以及 <span class="math inline">\(a\)</span>，因而对 <span class="math inline">\(C_j\)</span> 是agreeable的. 另一方面，对 <span class="math inline">\(y_j\)</span> 来说，全集的效用也只有 <span class="math inline">\(3\)</span>，而 <span class="math inline">\(u_{y_j}(T)=2\)</span>，因而也是agreeable的. 综上，<span class="math inline">\(T\)</span> 是一个规模为 <span class="math inline">\(\frac{m+1}{2}\)</span> 的agreeable set.</p><p><span class="math inline">\(\Leftarrow\)</span>：设 <span class="math inline">\(T\)</span> 是一个 <span class="math inline">\(\frac{m+1}{2}\)</span> 元agreeable set. 则 <span class="math inline">\(a\in T\)</span>，若不然，可用 <span class="math inline">\(a\)</span> 替换其中任一元素，集合仍是agreeable的.<br>由于 <span class="math inline">\(T\)</span> 对 <span class="math inline">\(\forall y_i\)</span> 是agreeable的，故对每个 <span class="math inline">\(i\)</span>，<span class="math inline">\(T\)</span> 至少包含 <span class="math inline">\(y_i\)</span> 和 <span class="math inline">\(\lnot y_i\)</span> 中至少一者，又由于 <span class="math inline">\(T\)</span> 只有 <span class="math inline">\(n&#39;+1\)</span> 元，故只能对每个 <span class="math inline">\(i\)</span> 恰好包含一者，记为 <span class="math inline">\(b_i\)</span>. 现令 <span class="math inline">\(b_i\)</span> 全为真.<br>又由于 <span class="math inline">\(T\)</span> 对 <span class="math inline">\(\forall C_j\)</span> 是agreeable的，且 <span class="math inline">\(C_j\)</span> 至少涉及到两个 <span class="math inline">\(y_i\)</span>，这两个 <span class="math inline">\(y_i\)</span> 至少有一个被设置为真，因此 <span class="math inline">\(\phi\)</span> 被满足.</p></blockquote><p>至此，求最小的agreeable set已经是一个NP问题，因此一个很自然的想法就是求近似解：</p><blockquote><p><strong>Lemma 7.</strong> 对任意常数 <span class="math inline">\(\epsilon&gt;0\)</span>，存在一个从 任意<code>3-SAT</code>条件 <span class="math inline">\(\phi\)</span> 到一个 <code>SET-COVER</code>问题 的多项式时间规约 <span class="math inline">\((U,\mathcal{C}\)</span>，以及一个关于 <span class="math inline">\(|U|\)</span> 的多项式函数 <span class="math inline">\(f(U)\)</span>，s.t.</p><ul><li>(完全性) 若 <span class="math inline">\(\phi\)</span> 是可满足的，则 <span class="math inline">\((U,\mathcal{C})\)</span> 的最佳值至多为 <span class="math inline">\(f(U)\)</span>；</li><li>(稳定性) 若 <span class="math inline">\(\phi\)</span> 是不可满足的，则 <span class="math inline">\((U,\mathcal{C}\)</span> 的最佳值至少为 <span class="math inline">\(((1-\epsilon)\ln|U|)f(U)\)</span>.</li></ul></blockquote><blockquote><p><strong>Th 12.</strong> 对任意常数 <span class="math inline">\(\delta&gt;0\)</span>，寻找一个规模不大于最优解 <span class="math inline">\((1-\delta)\ln n\)</span> 倍的agreeable set 的问题 是NP完全的.</p></blockquote><blockquote><p><strong>Th 13.</strong> 在偏好函数是可加函数的情形下，求规模不大于最优解 <span class="math inline">\(O(\log n)\)</span> 倍的agreeable set是存在多项式时间解法的.</p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 计算机 </tag>
            
            <tag> 北大 </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 社会计算 </tag>
            
            <tag> 论文笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>来自雁栖湖的最大流问题</title>
      <link href="/2019/01/14/%E6%9D%A5%E8%87%AA%E9%9B%81%E6%A0%96%E6%B9%96%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98/"/>
      <content type="html"><![CDATA[<blockquote><p><span class="math inline">\(n\times n\)</span> 的棋盘，有一些障碍物，在没有障碍物的格子上最多放多少个国际象棋的马，使之两两不攻击？</p></blockquote><a id="more"></a><p>一个和卜凡约饭的中午，突然接到春哥求助这个题.</p><p>卜凡瞟了一眼，想都没想，淡定开口：“爆搜.”</p><p>一看数据立刻傻了眼：<span class="math inline">\(200\times 200\)</span>，爆搜必定 <code>TLE</code>… 场面一度十分尴尬（</p><p>饭后看手机，发现春哥补刀：有人说是最大独立集，我没搞懂.</p><p>于是立刻想明白了…然而春哥自己没有写过.</p><p>吃完晚饭突然感到手痒，于是上手写了一发，测过样例直接自信提交，70分！（太菜了吧）</p><p><img src="/img/blog-graph/knight_70.png" alt="70分！菜鸡！"></p><p>前七个点 <code>AC</code> 了，后三个点竟然是 <code>RE</code>？</p><p>想来想去没有别的地方可能 <code>RE</code> 了，开大边数，直接100分 <code>AC</code> 了.</p><p><img src="/img/blog-graph/knight_100.png" alt="终于AC..."></p><blockquote><p>所以，容我bb一下这道题…</p></blockquote><h2 id="题面">题面</h2><h3 id="description">Description</h3><p>Given a <span class="math inline">\(N\times N\)</span> chessboard. There are <span class="math inline">\(M\)</span> obstacles in the chessboard and the position of <span class="math inline">\(i\)</span>-th obstacle is <span class="math inline">\((X_i,Y_i)\)</span>. You are asked to find the maximum number of knights which can be placed in the chessboard at the same time, satisfied that,</p><ol type="1"><li>No two knights can attack each other.</li><li>Knights can’t be placed in obstacle.</li><li>There can be at most one knight in a grid.</li></ol><p>(A Knight in chess can attack 8 positions, as shown in following figure)</p><p><img src="/img/blog-graph/knight_chess.png" alt="国际象棋中的马 走法示意图"></p><h3 id="input">Input</h3><p>Input is given from Standard Imput in the following format:</p><p><span class="math inline">\(N~M\\ X_1~Y_1\\ X_2~Y_2\\ \cdots\\ X_M~Y_M\)</span></p><h3 id="output">Output</h3><p>Print the maximum number of knights.</p><h3 id="sample-input-1">Sample Input 1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 1</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure><h3 id="sample-output-1">Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p>Test 1: exactly same as sample input 1<br>Test 2-4: <span class="math inline">\(1\leqslant N\leqslant 4\)</span><br>Test 5-6: <span class="math inline">\(1\leqslant N\leqslant 6\)</span><br>Test 7-10: <span class="math inline">\(1\leqslant N\leqslant 200\)</span><br>For all tests, <span class="math inline">\(0\leqslant M\leqslant N^2-1\)</span>, <span class="math inline">\(1\leqslant X_i\leqslant N\)</span>, <span class="math inline">\(1\leqslant Y_i\leqslant N\)</span>.</p><h2 id="思路">思路</h2><p>一般来说棋盘上“马”的走法用横纵坐标分别来表示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">-2</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[] = &#123;<span class="number">2</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure><p>考虑格子的<strong>纵坐标之和</strong>：马每跳一次，其奇偶性会改变. 用更“组合”的方式说，给棋盘黑白染色后，马每次跳跃的起点和终点格子颜色一定是不同的.</p><p>于是考虑按照如下方法建图：</p><center>所有<strong>没有障碍物</strong>的格子视为结点，若马可以从格子 <span class="math inline">\(a\)</span> 跳到格子 <span class="math inline">\(b\)</span>，则 <span class="math inline">\(a,b\)</span> 之间存在一条双向边.</center><p>现将所有黑格（<span class="math inline">\(x+y\)</span> 为偶数）视为一个集合 <span class="math inline">\(X\)</span>，所有白格（<span class="math inline">\(x+y\)</span> 为奇数）视为一个集合，则所有的跳跃都发生在 <span class="math inline">\(X,Y\)</span> 之间，不会发生在 <span class="math inline">\(X,Y\)</span> 各自的内部，于是这个图是一个二分图.</p><p>现在问题所求的是“<strong>最多能放多少个马</strong>”，即该图<strong>最大独立集</strong>的大小. 对于二分图，我们有</p><p><span class="math display">\[|最大独立集|=总点数-最大匹配数\]</span></p><p>所以只需求其最大匹配. 一般来说有利用匈牙利算法直接求解和利用最大流求解两种方法.</p><ul><li>直接用匈牙利算法求解.</li><li>最大流方法：（我觉得我不应该说这么详细）<ol type="1"><li><span class="math inline">\(X\)</span> 左侧增加一个源点 <span class="math inline">\(S\)</span>，向 <span class="math inline">\(X\)</span> 中每一点都连入容量为 <span class="math inline">\(1\)</span> 的边；</li><li><span class="math inline">\(Y\)</span> 右侧增加一个汇点 <span class="math inline">\(T\)</span>，<span class="math inline">\(Y\)</span> 中每一点都向其连入容量为 <span class="math inline">\(1\)</span> 的边；</li><li><span class="math inline">\(X,Y\)</span> 之间的边容量也为 <span class="math inline">\(1\)</span>（无穷大应该也是有道理的，毕竟源点最多出来 <span class="math inline">\(1\)</span>）；</li><li>跑一遍最大流（比如dinic），结果即为最大匹配.</li></ol></li></ul><h2 id="代码">代码</h2><p>第一次因为错误估计了边的数量而 <code>RE</code> 了后三个点，只得70分…后来实在想不到 <code>RE</code> 的点，就开大了很多边数，直接就 <code>AC</code> 了… 细想一下，确实是低估了边数.</p><p><img src="\img\blog-graph\knight_result.png" alt="提交结果"></p><p><strong>这里简单说一下正确的边数估计：</strong></p><p>棋盘边长是 <span class="math inline">\(N\)</span>，所以点数大约是 <span class="math inline">\(N^2\)</span> 级别，考虑到每个点最多 <span class="math inline">\(8\)</span> 条边，所以总边数绝不超过 <span class="math inline">\(8N^2\)</span>.</p><p>带入 <span class="math inline">\(N\leqslant 200\)</span>，边数至多是 <span class="math inline">\(8\times 200\times 200=3.2\times 10^5\)</span>. 开 <code>maxm = 4e5</code> 就足够了.</p><p>最后，因为这是最大流的题目，所以只用了最大流，其实匈牙利算法更短.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">205</span>; <span class="comment">// 注意点数其实是 maxn^2 级别</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e6</span>; <span class="comment">// 所以这里一定要足够大，4e5就够</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">-2</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[] = &#123;<span class="number">-2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, tot, Source, Dest;</span><br><span class="line"><span class="keyword">int</span> dist[maxm], head[maxm];</span><br><span class="line"><span class="keyword">bool</span> obstacle[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt, capa;</span><br><span class="line">    Edge() &#123;&#125;</span><br><span class="line">    Edge(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c): to(a), nxt(b), capa(c) &#123;&#125;</span><br><span class="line">&#125; e[maxm];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> capa)</span>                     </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[tot] = Edge(v, head[u], capa); head[u] = tot++;</span><br><span class="line">    e[tot] = Edge(u, head[v], <span class="number">0</span>);    head[v] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.push(Source);</span><br><span class="line">    dist[Source] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i != <span class="number">-1</span>; i = e[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> y = e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (e[i].capa &amp;&amp; dist[y] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[y] = dist[x] + <span class="number">1</span>;</span><br><span class="line">                Q.push(y);</span><br><span class="line">                <span class="keyword">if</span> (y == Dest)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> <span class="built_in">exp</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == Dest || !<span class="built_in">exp</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">exp</span>;</span><br><span class="line">    int ret(0), tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i != <span class="number">-1</span>; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (dist[x] + <span class="number">1</span> == dist[y] &amp;&amp; e[i].capa)</span><br><span class="line">        &#123;</span><br><span class="line">            ret += (tmp = dfs(y, min(<span class="built_in">exp</span> - ret, e[i].capa)));</span><br><span class="line">            e[i].capa -= tmp;</span><br><span class="line">            e[i ^ <span class="number">1</span>].capa += tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ret) dist[x] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ret</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (bfs())</span><br><span class="line">        ret += dfs(Source, inf); </span><br><span class="line">    <span class="keyword">return</span> ret;             </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上全部是模板</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Source = s;</span><br><span class="line">    Dest = t;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// 判定(x, y) 格子是否可以放马</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">1</span> || x &gt; n) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// x 不能越界</span></span><br><span class="line">    <span class="keyword">if</span>(y &lt; <span class="number">1</span> || y &gt; n) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// y 不能越界</span></span><br><span class="line">    <span class="keyword">return</span> !obstacle[x][y]; <span class="comment">// 不能有障碍物</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// 二维变一维</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * n + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m; <span class="comment">// 懒，用了cin cout</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y; <span class="comment">// 还是懒...</span></span><br><span class="line">        obstacle[x][y] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init(<span class="number">0</span>, n * n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= n; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacle[x][y]) <span class="keyword">continue</span>; </span><br><span class="line">            <span class="keyword">if</span> ((x + y) &amp; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                addedge(Source, f(x, y), <span class="number">1</span>); </span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> _ = <span class="number">0</span>; _ &lt; <span class="number">8</span>; _++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> xx = x + dx[_];</span><br><span class="line">                    <span class="keyword">int</span> yy = y + dy[_];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (judge(xx, yy))</span><br><span class="line">                        addedge(f(x, y), f(xx, yy), <span class="number">1</span>); <span class="comment">// 边权为inf亲测也没问题</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123; </span><br><span class="line">                addedge(f(x, y), Dest, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, n * n - m - dinic()); <span class="comment">// 输出不懒了！</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>差分隐私[1]——初窥门径</title>
      <link href="/2018/10/29/%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81-1-%E2%80%94%E2%80%94%E5%88%9D%E7%AA%A5%E9%97%A8%E5%BE%84/"/>
      <content type="html"><![CDATA[<blockquote><p>暑假以来一直在读一本书《Differential Privacy and Applications》<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>，做一点简单的记录.</p></blockquote><a id="more"></a><h2 id="何为差分隐私">何为差分隐私</h2><h3 id="乱谈隐私">乱谈隐私</h3><blockquote><p>真·乱谈… 如有错误之处请留言指正，Orz.</p></blockquote><p>什么是隐私呢？我们通常把某一特定个体的一些个人信息称为是隐私，比方说我代数做了几个题，泛函考了多少分，大学挂了几门课，最喜欢听哪个老师讲课等等… 那么在以上信息不能直接查询到，并且我们也不透露这些信息的前提下，我们的上述隐私是否会泄露？</p><p>答案是会.</p><p>为了说明这些隐私是如何丢掉的，我们就先来谈谈查询的问题. 查询一般是针对某一数据库的，比方说学校的教务网就是一个很好的例子. 那么，数据库如何从最简单的方面来保护隐私呢？一般有发布数据集和提供查询两种场合，分述如下.</p><h4 id="数据集的匿名化">数据集的匿名化</h4><table border="1"><tr><th>姓名</th><th>学号</th><th>数学分析</th><th>高等代数</th><th>微分几何</th><th>泛函分析</th></tr><tr><td>郭犇</td><td>201401</td><td>100</td><td>100</td><td>100</td><td>100</td></tr><tr><td>丁丁</td><td>201402</td><td>100</td><td>90</td><td>90</td><td>100</td></tr><tr><td>小兔子</td><td>201403</td><td>90</td><td>90</td><td>90</td><td>90</td></tr><tr><td>数分哥</td><td>201404</td><td>100</td><td>90</td><td>90</td><td>90</td></tr><tr><td>代数哥</td><td>201405</td><td>90</td><td>100</td><td>90</td><td>90</td></tr><tr><td>几何哥</td><td>201406</td><td>90</td><td>90</td><td>100</td><td>90</td></tr><tr><td>泛函哥</td><td>201407</td><td>90</td><td>90</td><td>90</td><td>100</td></tr><tr><td>LZC</td><td>201408</td><td>90</td><td>90</td><td>0</td><td>90</td></tr><caption>成绩数据示例</caption></table><p>我们都知道数据库中，有“主键”的概念，它能唯一地标识数据库中的某一条记录（比如学号）. 那么保护隐私最直接的办法，就是在给人看数据的时候，将具有标识功能的属性全部删掉，比如在成绩单中将姓名学号删掉，只留下成绩，即得到如下的表格.</p><table border="1"><tr><th>序号</th><th>数学分析</th><th>高等代数</th><th>微分几何</th><th>泛函分析</th></tr><tr><th>1</th><td>100</td><td>100</td><td>100</td><td>100</td></tr><tr><th>2</th><td>100</td><td>90</td><td>90</td><td>100</td></tr><tr><th>3</th><td>90</td><td>90</td><td>90</td><td>90</td></tr><tr><th>4</th><td>100</td><td>90</td><td>90</td><td>90</td></tr><tr><th>5</th><td>90</td><td>100</td><td>90</td><td>90</td></tr><tr><th>6</th><td>90</td><td>90</td><td>100</td><td>90</td></tr><tr><th>7</th><td>90</td><td>90</td><td>90</td><td>100</td></tr><tr><th>8</th><td>90</td><td>90</td><td>0</td><td>90</td></tr><caption>去掉姓名学号的成绩单</caption></table><p>如果攻击者本人什么都不知道，那么这帮人的隐私就算是得到了保护——攻击者无法得知某一学生（如“丁丁”）的具体成绩信息.</p><p>但隐私保护显然不能建立在如此侥幸的情形之上. 比如某一攻击者已知郭犇数分，代数和微分几何都考了100分，想知道他的泛函成绩，那么就可以从表中轻松获取该信息，因为表中只有郭犇一个人在这三门课都拿到100分. 又如某一攻击者已知LZC挂了一科，同样可以查询到关于LZC的更多隐私信息. 但这样的保护机制也不能说是毫无作用——它成功保护了“小兔子”的所有成绩信息：即便你知道小兔子的三科成绩，也无法确定她的第四科成绩.</p><p>那么如何改进这种匿名化方法呢？答案就是时下颇为流行的k-匿名算法.</p><p>k-匿名算法将一些属性概化，以保证：<strong>任一条数据库中的记录，任取其一属性，在库中都有k条记录的该属性值与其相同.</strong> 比如我们要保护LZC的泛函分析成绩，那么我们将7号和8号的微分几何成绩凑成一个元组，统一写为[0-90]，攻击者即无法分辨二者的区别.</p><p>以上的匿名化过程看起来很美好，但k-匿名算法仍有缺陷，可能会遭受同质化攻击和背景知识攻击的挑战，所以需要更多的隐私化处理，不再详谈.</p><h4 id="查询中的差分攻击与差分隐私">查询中的差分攻击与差分隐私</h4><p>我们现在抛掉匿名性的问题，考虑数据库的查询问题. 此时我们不会把整个数据集暴露给攻击者，而是给攻击者提供一些查询的机会. 在查询的同时，保护单条记录的敏感属性值（比如在此处设定为保护“泛函”的成绩隐私）.</p><p>如果我们的数据库管理员总是说实话，那么我们必须拒绝单条记录的查询. 比如，你不能询问“丁丁的泛函成绩是多少”，因为我们要保护的正是泛函的成绩.</p><p>那么，阻止单条记录的查询是否就能很好地保护隐私？答案是不能. 这种攻击的手法就称为<strong>差分攻击</strong>.</p><p>攻击者想知道LZC的泛函成绩，于是进行了两步查询：</p><ol type="1"><li>求1-8所有人的泛函成绩之和. <code>SUM(1, 8)</code>.</li><li>求1-7所有人的泛函成绩之和. <code>SUM(1, 7)</code>.</li></ol><p>然后做差，就得到了LZC的泛函成绩. <code>SUM(1, 8) - SUM(1, 7)</code>.</p><p>隐私泄露了！这种局面当然不是我们希望看到的，于是我们需要一些机制来抵御这种“差分攻击”.</p><p>差分攻击的核心做法就是找两个只差一条记录的数据集，分别做查询，再比较结果的差异，来获取两个集合所相差的记录的敏感信息. 所以我们最直接的想法也就是，通过随机化的查询（即管理员不能总说实话），使得攻击者无法区分只差一条记录的两个集合. 这便是<strong>差分隐私</strong>.</p><h3 id="差分隐私的数学框架">差分隐私的数学框架</h3><blockquote><p><strong>DEFINITION</strong> 差分隐私：若机制 <span class="math inline">\(M\)</span> 对于任一输出集合 <span class="math inline">\(S\)</span> 和任意邻近集 <span class="math inline">\(D,D&#39;\)</span> 总有： <span class="math display">\[Pr[M(D)\in S] \leqslant e^{\varepsilon}\cdot Pr[M(D&#39;)\in S] + \delta\]</span> 则称 <span class="math inline">\(M\)</span> 满足 <span class="math inline">\((\varepsilon,\delta)\)</span>-(近似)差分隐私. 当 <span class="math inline">\(\delta=0\)</span> 时，称为 <span class="math inline">\(\varepsilon\)</span>-差分隐私. 其中 <span class="math inline">\(\varepsilon\)</span> 称为隐私预算.</p></blockquote><ul><li>记号说明：<ul><li>数据集：数据全体记作 <span class="math inline">\(\mathscr{X}\)</span>，其子集 <span class="math inline">\(D\subset\mathscr{X}\)</span> 称为数据集.</li><li>邻近集：只相差一条记录的一对数据集. 即 <span class="math inline">\(|D\triangle D&#39;|=1\)</span>.</li><li>查询：映射 <span class="math inline">\(f:D\to\mathbb{R}\)</span>. 全体查询记作 <span class="math inline">\(F\)</span>.<ul><li>查询的敏感度：<ul><li>局部敏感度：<span class="math inline">\(\Delta f_{LS}=\max\limits_{D&#39;}\Vert f(D)-f(D&#39;)\Vert_1\)</span>.</li><li>全局敏感度：<span class="math inline">\(\Delta f_{LS}=\max\limits_{D,D&#39;}\Vert f(D)-f(D&#39;)\Vert_1\)</span>.</li></ul></li><li>容易看出，局部敏感度会与数据分布有很强的关联，但全局敏感度一般较大. 故在需要使用局部敏感度时，常采用局部敏感度的平滑上界.</li></ul></li></ul></li></ul><h2 id="如何实现差分隐私">如何实现差分隐私</h2><p>差分隐私是通过随机化的方式来干扰正常的查询，或是对数据集做一些处理. 那么最常规的干扰查询/处理数据的手法，就是加噪音.</p><p>一般情况下，数据库的查询可分为两类：数值查询和非数值查询.</p><ol type="1"><li>数值查询：小兔子的微分几何考了多少分？</li><li>非数值查询：LZC分最高的是哪一门课？</li></ol><p>应对这两种查询，分别有Laplace机制和指数机制.</p><h3 id="laplace机制">Laplace机制</h3><blockquote><p><strong>Laplace分布</strong>：这里只考虑均值为 <span class="math inline">\(0\)</span> 的Laplace分布. 尺度参数为 <span class="math inline">\(b\)</span> 的Laplace分布记为 <span class="math inline">\(Lap(b)\)</span>，其密度函数为： <span class="math display">\[p(x) = \frac{1}{2b}\exp(-\frac{|x|}{b}).\]</span></p></blockquote><p>Laplace机制就是给查询结果添加服从Laplace分布的噪声，即： <span class="math display">\[M(D) = f(D)+\xi\]</span> 若 <span class="math inline">\(\xi\sim Lap(\frac{\Delta f}{\varepsilon})\)</span>，则该算法可提供 <span class="math inline">\(\varepsilon\)</span>-差分隐私保护.</p><blockquote><p>从过程即可知道，Laplace机制只适合数值查询.</p></blockquote><h3 id="指数机制">指数机制</h3><p>对于非数值查询，需要用指数机制来干扰. 具体的办法是（以查询LZC分最高的课程为例）：</p><ol type="1"><li>先给所有可能的答案一个打分，称为效用函数 <span class="math inline">\(q\)</span>，<span class="math inline">\(q\)</span> 越大表示这个答案越接近真实答案.<ul><li>此处可能的答案为：数学分析、高等代数、微分几何、泛函分析.</li><li>此处的效用可以用成绩表示：90，90，0，90.</li></ul></li><li>给所有可能答案分别分配一个概率，规则为： <span class="math display">\[Pr[\text{return }\phi] \propto \exp(\frac{\varepsilon q(D,\varphi)}{2\Delta q}).\]</span></li></ol><p>此时算法提供 <span class="math inline">\(\varepsilon\)</span>-差分隐私保护.</p><p>网上关于指数机制有非常多的例子，不多赘述.</p><h3 id="可用性评估">可用性评估</h3><p>给数据加噪声必定会降低数据的可用性，对可用性的评估一般有以下几种：</p><ol type="1"><li>直接看噪声大小：噪声 <span class="math inline">\(\downarrow\)</span>，可用性 <span class="math inline">\(\uparrow\)</span>.</li><li>对误差进行度量：单次查询误差为 <span class="math inline">\(\Vert f(D)-\hat{f}(D)\Vert\)</span>. （<span class="math inline">\(\hat{f}\)</span> 表示加了噪音的 <span class="math inline">\(f\)</span>.）</li><li><span class="math inline">\((\alpha,\beta)\)</span>-可用性：当 <span class="math inline">\(F\)</span> 满足 <span class="math display">\[Pr[\max\limits_{f\in F}|f(D)-\hat{f}(D)| \leqslant \alpha] &gt; 1-\beta\]</span> 称 <span class="math inline">\(D\)</span> 是 <span class="math inline">\((\alpha,\beta)\)</span>-可用的.</li></ol><h2 id="数据发布">数据发布</h2><p>数据发布所指的，就是数据库中的数据对于外界访问的支持. 一般有两种情形：</p><ol type="1"><li>交互式发布：一问一答.</li><li>非交互式发布：问完再答/发布处理过的数据集.</li></ol><h3 id="交互式数据发布">交互式数据发布</h3><p>给定预算 <span class="math inline">\(\varepsilon\)</span>，然后进行一问一答，直至预算耗尽.</p><ul><li>Laplace机制<ul><li>能回答问题的数较少，与数据库大小成次线性关系.</li><li>时间复杂度低，算法简单.</li></ul></li><li>K-norm：将查询结果转为高维多面体研究<ul><li>能回答指数级别的问题.</li><li>时间复杂度高.</li></ul></li><li>中位数：将查询分为难易两类，简单问题的结果可由难问题的答案确定.<ul><li>困难的查询大约只有 <span class="math inline">\(O(\log |F|\log|\mathscr{X}|)\)</span> 个，故能回答指数级别个问题.</li><li>时间复杂度高，样本复杂度也很高.</li></ul></li><li>PMW，IDC：将数据集视为直方图进行迭代查询<ul><li>能回答指数级别的问题.</li><li>只能处理计数类查询.</li></ul></li></ul><h4 id="基于直方图的数据发布">基于直方图的数据发布</h4><blockquote><p>将数据集 <span class="math inline">\(D\)</span> 视为 <span class="math inline">\(\mathscr{X}\)</span> 上的直方图 <span class="math inline">\(x\in N^{|\mathscr{X}|}\)</span>，其中 <span class="math inline">\(N\)</span> 为所有可能的属性值组合.</p></blockquote><p>主要手段：</p><ul><li>Laplace机制：每次查询都给涉及到的所有格子添加噪声.<ul><li>格子较多会累积大量噪声</li></ul></li><li>将格子分为若干区域，区域内部取平均，再给每个区域分别添加噪声，减少添加噪声的次数. （分区可借助kd-tree）</li></ul><p>会面临一致性的问题：可能不能维持原先的大小关系.</p><h4 id="流数据的差分隐私">流数据的差分隐私</h4><p>流数据是用一个0-1串来表示的数据，每一位代表一个时间节点，0表示这个时刻没有事情发生，1表示这个时刻有事情发生. 这里输出的数据主要是某一段的1的个数，于是有两种隐私的级别：</p><ul><li>用户层面（user-level）：将与单个用户相关的所有事件隐藏起来.</li><li>事件层面（event-level）：将单个事件隐藏起来.</li></ul><p>由于用户层面的隐私会导致查询的敏感度过高，故一般只考虑事件层面的隐私. 在预算一定的前提下尽可能提高任一时间节点 <span class="math inline">\(t_k\)</span> 的前缀 <span class="math inline">\(D(t_k)\)</span> 中的事件计数 <span class="math inline">\(\hat{\iota}(t_k)\)</span> 的精确度. 主要手段如下：</p><ul><li>Laplace机制：给每个时间步都添加噪声.<ul><li>噪声过大</li></ul></li><li>分割数据集：p-sum机制.</li><li>迭代</li></ul><h4 id="图数据的差分隐私">图数据的差分隐私</h4><ul><li>边的差分隐私：将边藏起来<ul><li>主要解决的问题：与子图相关的问题.</li><li>参考：Nissim K, Raskhodnikova S. Smooth sensitivity and sampling in private data analysis.</li></ul></li><li>点的差分隐私：将点藏起来<ul><li>参考： J. Blocki, A. Blum, A. Datta, and O. Sheffet. Differentially private data analysis of social networks via restricted sensitivity.</li></ul></li></ul><h3 id="非交互式数据发布">非交互式数据发布</h3><p>非交互式的数据发布要比交互式的更困难，因为需要考虑多个问题之间的联系. 发布处理后的数据集则更为困难，在隐私预算固定的情况下，常常需要加入巨量的噪声来保证安全性.</p><h4 id="批查询">批查询</h4><blockquote><p>批查询：给出多个查询，然后一并回答.</p></blockquote><ul><li>面对的挑战：查询之间的相关性会导致敏感度升高，进而导致噪声过大.</li><li>处理的手段：一般是对查询做一些变换，或是一些迭代的方法.</li></ul><h4 id="列联表">列联表</h4><blockquote><p>列联表：对数据集按照属性分类时列出的频数表. <strong>注意和直方图并不太一样，一个是列频数，一个是列属性.</strong></p></blockquote><ul><li>最直接的Laplace机制<ul><li>直接向每个格子添加Laplace噪声，再求边缘频数</li><li>缺点：噪声过大</li></ul></li><li>改进的Laplace机制<ul><li>先求边缘频数，再向边缘频数添加Laplace噪声，减少噪声添加次数</li><li>缺点：不能维持一致性</li></ul></li><li>Fourier变换：<ul><li>先进行Fourier变换，再添加噪声</li><li>由于Fourier变换后的每一个系数都对应一个满足一致性的列联表，故不会破坏一致性，同时还能减小噪声.</li></ul></li></ul><h4 id="匿名化数据集发布">匿名化数据集发布</h4><center><strong>这是一种发布处理过的数据集的非交互式数据发布方法.</strong></center><blockquote><p>在最初的“乱谈隐私”中提到了匿名化数据集的方法，由于最终发布的数据集中的一些记录，会包含有与原数据集完全相同的部分属性信息，故可能会泄露用户的隐私.<br>所以我们需要将传统的匿名化方法进行处理，使其满足差分隐私的要求.</p></blockquote><ul><li>根据差分隐私的串行组合性质，我们知道如果算法的每一步都能够满足差分隐私的要求，则整个算法也能够提供差分隐私保护.</li><li>于是我们只需要将传统的匿名化方法的每一步都变得满足差分隐私要求.</li><li>DiffGen算法. 不详细解释.</li></ul><h4 id="差分隐私pac学习">差分隐私PAC学习</h4><center><strong>这也是一种发布处理过的数据集的非交互式数据发布方法.</strong></center><blockquote><p>PAC学习：设有 <span class="math inline">\(\mathscr{X}\)</span> 上的概念类 <span class="math inline">\(\mathscr{C}\)</span> 上的算法 <span class="math inline">\(\mathscr{A}\)</span>，使用假设空间 <span class="math inline">\(H\)</span>. 若 <span class="math inline">\(\mathscr{A}\)</span> 对所有概念 <span class="math inline">\(c\in\mathscr{C}\)</span> 和所有 <span class="math inline">\(\mathscr{X}\)</span> 上的分布 <span class="math inline">\(D\)</span>，给定 <span class="math inline">\(D\)</span> 中 <span class="math inline">\(n\)</span> 个 i.i.d. 样本作为输入，算法 <span class="math inline">\(\mathscr{A}\)</span> 输出假设 <span class="math inline">\(h\in H\)</span>，s.t. <span class="math display">\[Pr[error_D (c,h)\leqslant\alpha]\geqslant 1 − \beta.\]</span> 则称算法 <span class="math inline">\(\mathscr{A}\)</span> 是一个 <span class="math inline">\(\mathscr{X}\)</span> 上概念类 <span class="math inline">\(\mathscr{C}\)</span> 上的 PAC 学习算法.</p></blockquote><ul><li>如果一个概念类别在无隐私保护要求和多项式样本复杂度下是可学习的，那么在差分隐私保护条件下就是可学习的.</li><li>差分隐私PAC学习的效率比较低下，且只适用于离散情形.</li></ul><h2 id="隐私性算法">隐私性算法</h2><blockquote><p>传统的数据挖掘/数据分析算法都有可能泄露用户隐私，若我们将其每一个步骤都视为一次查询，然后改进之使其满足差分隐私要求，则整个算法也可满足差分隐私要求.</p></blockquote><h3 id="laplace与指数机制的直接应用sulq与pinq接口">Laplace与指数机制的直接应用：SuLQ与PINQ接口</h3><blockquote><p>提供接口来满足数据挖掘和分析的需求.</p></blockquote><ul><li>SuLQ 框架：以 SuLQ 原语为基本单元，设计隐私化的复杂算法.<ul><li>SuLQ 原语：单属性布尔查询 → 连续值.</li></ul></li><li>PINQ 框架：在数值询问使用 Laplace，选择操作使用指数机制.<ul><li>Partition：对数据集进行分割 ⇒ 可利用并行组合提高预算利用率.</li></ul></li></ul><blockquote><p>以上接口不考虑算法的目标和性能，故分析效果可能不理想.</p></blockquote><p><strong>适用情形：监督学习，无监督学习，频繁项集挖掘.</strong></p><h4 id="监督学习决策树">监督学习：决策树</h4><ul><li>SuLQ-based ID3：在计算信息增益时，加入噪声.<ul><li>缺点：噪声过大，可用性很差.</li></ul></li><li>SuLQ-based ID3-PINQ 改进：利用 Partition.<ul><li>利用 Partition 减少不必要的预算损耗.</li><li>但由于每次查询都需要提供预算来进行计数，故分配的预算仍然较少，无法显著减少噪声.</li></ul></li><li>DiffID3：利用指数机制，一次运算评估所有属性.<ul><li>指数机制的优越性：决策树分裂一次只需要一次运算.</li><li>提高了单次查询分配的预算，有效提高精确度.</li></ul></li></ul><h4 id="无监督学习聚类">无监督学习：聚类</h4><blockquote><p>以k-means为例，计算每个元素到质心的距离可能会泄露隐私.</p></blockquote><ul><li>SuLQ k-means：发布质心和元素数量的估计值<ul><li>缺点：查询质心的敏感度为聚类的最大直径，噪声过大.</li></ul></li><li>有更好的框架，此处不再详谈.</li></ul><h4 id="频繁项集挖掘">频繁项集挖掘</h4><blockquote><p>频繁项集定义不清楚的自觉面壁…</p></blockquote><p>基于截断支持度的 FIM 算法：求长度为 <span class="math inline">\(l\)</span> 的前 <span class="math inline">\(k\)</span> 频繁项集.</p><ol type="1"><li>预处理：挖掘到所有 <span class="math inline">\(l\)</span>-项集，计算其截断支持度.</li><li>求前 k 频繁项集.<ul><li>Laplace-FIM：为每个截断支持度添加噪声，再取前 <span class="math inline">\(k\)</span> 个项集.</li><li>指数 FIM：以截断支持度为效用函数用指数机制选出 <span class="math inline">\(k\)</span> 个项集.</li></ul></li><li>输出：上一步得到的项集，以及加噪声后的真实支持度.</li></ol><h3 id="完全访问差分隐私与机器学习">完全访问：差分隐私与机器学习</h3><blockquote><p>用原始数据集来做机器学习显然有可能会泄露用户的隐私，所以我们要在传统的机器学习算法上进行改进，使其满足差分隐私的要求.</p></blockquote><p>一般有两种实现方法：在输出时加噪声，以及在损失函数上加噪声.</p><hr><p>更多复杂的内容不再详谈. <strong>作者水平有限且落笔仓促，如有错误之处，恳请指正.</strong></p><section class="footnotes"><hr><ol><li id="fn1"><p>Zhu, T., Li, G., Zhou, W., &amp; Yu, P. S. (2017). Differential Privacy and Applications. （其实这本书很难看…）<br>&gt; 空口无凭…请看这个句子：In addition, for a dataset with size n, the Laplace mechanism can only answer, at most, sub-linear in n number of queries to a certain level of accuracy.<br>&gt; 小子不才，初次看到这句话是暑假，10月份才明白其意思… Orz.<a href="#fnref1" class="footnote-back">↩</a></p></li></ol></section>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 计算机 </tag>
            
            <tag> 差分隐私 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VSCode配置：插件与设置</title>
      <link href="/2018/10/28/vscode%E9%85%8D%E7%BD%AE%EF%BC%9A%E6%8F%92%E4%BB%B6%E4%B8%8E%E8%AE%BE%E7%BD%AE/"/>
      <content type="html"><![CDATA[<ol type="1"><li>主要是写给自己看的…方便自己什么时候搞出什么意外来重新配置.</li><li>其次是在网上翻vscode插件，都是关于前端开发者的…太气了吧，我不干前端，我就想写写我这样的人所需要的插件.</li></ol><a id="more"></a><h2 id="插件选择">插件选择</h2><h3 id="编程语言支持">编程语言支持</h3><ul><li>C/C++</li><li>Language Support for Java(TM) by Red Hat</li><li>Python</li><li>LaTeX Workshop<ul><li>强大的 <span class="math inline">\(\LaTeX\)</span> 插件，需要配置.</li></ul></li><li>Markdown All in One<ul><li>自称写markdown用这一个插件就够了.</li><li>可以在markdown里面显示数学公式（感觉效果不是很好，有些公式渲染不出来）</li></ul></li></ul><h3 id="提高效率的插件">提高效率的插件</h3><ul><li>Sublime Text Keymap and Settings Importer<ul><li>在VSCode里使用Sublime快捷键，对Sublime老用户很有用（是我转战vscode的重要原因）</li></ul></li><li>Bracket Pair Colorizer<ul><li>给成对匹配的括号着色，非常实用</li></ul></li><li>Code Runner<ul><li>跑代码的插件</li></ul></li><li>TODO Highlight<ul><li>在注释中加 <code>TODO</code> 或者 <code>FIXME</code> 会被高亮显示，做标记方便.</li></ul></li></ul><h3 id="提升颜值的插件">提升颜值的插件</h3><ul><li>Chinese (Simplified) Language Pack for Visual Studio Code<ul><li>汉化包</li></ul></li><li>VSCode Great Icons<ul><li>一套比较好看的文件图标</li></ul></li><li>Output Colorizer<ul><li>给输出着色的插件</li></ul></li></ul><h2 id="cc环境搭建">C/C++环境搭建</h2><h3 id="安装mingw-w64">安装MinGW-w64</h3><blockquote><p>官网：<a href="https://mingw-w64.org/" class="uri" target="_blank" rel="noopener">https://mingw-w64.org/</a> 可在SourceForge下载.</p></blockquote><p>下载完毕后安装，其中的Settings解释如下：</p><ul><li>Version：版本…不废话了</li><li>Architecture：系统架构<ul><li><code>i686</code>:32位</li><li><code>x86_64</code>:64位</li></ul></li><li>Threads：接口协议<ul><li><code>posix</code>：除了windows的系统，都服从posix协议</li><li><code>win32</code>：当然windows得选这个..</li></ul></li><li>Exception：异常处理(按照教程，若架构选择了 <code>i686</code>，则此处应选择 <code>dwarf</code>)<ul><li><code>seh</code>：不太懂是什么..根据我看的教程选了这个，好像性能更好.</li><li><code>sjlj</code>：同样不太懂…</li></ul></li><li>Build revision：不知道是啥…乱选的.</li></ul><p>然后啪啪啪啪一路顺下就安装好了.</p><h3 id="环境变量">环境变量</h3><ol type="1"><li>在 <code>Path</code> 中添加 <code>\mingw64\bin</code> 的地址.<ul><li>在命令行运行 <code>gcc -v</code> 可验证是否成功.</li></ul></li><li>有一些教程里面会添加一些其他的看起来很骚的环境变量…感觉…是不是没啥用？</li></ol><h3 id="vscode配置">VSCode配置</h3><blockquote><p><a href="https://code.visualstudio.com/docs/languages/cpp" class="uri" target="_blank" rel="noopener">https://code.visualstudio.com/docs/languages/cpp</a></p></blockquote><p>忽然发现好像很简单…装好 <code>Code Runner</code> 插件，配置中勾选 <code>Run In Terminal</code> 和 <code>Save File Before Run</code> 两项即可运行..</p><blockquote><p>VSCode的默认快捷键是 <code>Ctrl</code>+<code>Alt</code>+<code>n</code>.</p></blockquote><h2 id="latex环境搭建">LaTeX环境搭建</h2><h3 id="安装texlive和sumatrapdf">安装TeXLive和SumatraPDF</h3><p>不多废话…</p><h3 id="环境变量-1">环境变量</h3><ol type="1"><li>将TexLive安装目录加入<code>Path</code>.</li><li>将SumatraPDF目录加入<code>Path</code>. 终端输入 <code>sumatrapdf</code> 即可验证.</li></ol><h3 id="vscode配置-1">VSCode配置</h3><blockquote><p>首先肯定要安装LaTeX Workshop… 参考：<a href="http://www.latexstudio.net/archives/12260.html" class="uri" target="_blank" rel="noopener">http://www.latexstudio.net/archives/12260.html</a></p></blockquote><h4 id="在tools中添加xelatex和bibtex">在<code>tools</code>中添加<code>xelatex</code>和<code>bibtex</code></h4><p>在 <code>settings.json</code> 中添加如下字段：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">"latex-workshop.latex.tools": [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"xelatex"</span>,</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"xelatex"</span>,</span><br><span class="line">        <span class="attr">"args"</span>: [</span><br><span class="line">          <span class="string">"-synctex=1"</span>,</span><br><span class="line">          <span class="string">"-interaction=nonstopmode"</span>,</span><br><span class="line">          <span class="string">"-file-line-error"</span>,</span><br><span class="line">          <span class="string">"%DOC%"</span></span><br><span class="line">        ]</span><br><span class="line">        &#125;,</span><br><span class="line">&#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"pdflatex"</span>,</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"pdflatex"</span>,</span><br><span class="line">        <span class="attr">"args"</span>: [</span><br><span class="line">          <span class="string">"-synctex=1"</span>,</span><br><span class="line">          <span class="string">"-interaction=nonstopmode"</span>,</span><br><span class="line">          <span class="string">"-file-line-error"</span>,</span><br><span class="line">          <span class="string">"%DOC%"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"bibtex"</span>,</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"bibtex"</span>,</span><br><span class="line">        <span class="attr">"args"</span>: [</span><br><span class="line">          <span class="string">"%DOCFILE%"</span></span><br><span class="line">    ]</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><h4 id="在recipe中添加xelatex与bibtex的组合">在<code>recipe</code>中添加<code>xelatex</code>与<code>bibtex</code>的组合</h4><p>在 <code>settings.json</code> 中添加如下字段：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">"latex-workshop.latex.recipes": [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"name"</span>: <span class="string">"PDFLaTeX"</span>,</span><br><span class="line">          <span class="attr">"tools"</span>: [</span><br><span class="line">            <span class="string">"pdflatex"</span></span><br><span class="line">          ]</span><br><span class="line">      &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"name"</span>: <span class="string">"XeLaTeX"</span>,</span><br><span class="line">          <span class="attr">"tools"</span>: [</span><br><span class="line">            <span class="string">"xelatex"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"name"</span>: <span class="string">"latexmk"</span>,</span><br><span class="line">          <span class="attr">"tools"</span>: [</span><br><span class="line">            <span class="string">"latexmk"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"name"</span>: <span class="string">"BibTeX"</span>,</span><br><span class="line">          <span class="attr">"tools"</span>: [</span><br><span class="line">            <span class="string">"bibtex"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"name"</span>: <span class="string">"pdflatex -&gt; bibtex -&gt; pdflatex*2"</span>,</span><br><span class="line">          <span class="attr">"tools"</span>: [</span><br><span class="line">            <span class="string">"pdflatex"</span>,</span><br><span class="line">            <span class="string">"bibtex"</span>,</span><br><span class="line">            <span class="string">"pdflatex"</span>,</span><br><span class="line">            <span class="string">"pdflatex"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"name"</span>: <span class="string">"xelatex -&gt; bibtex -&gt; xelatex*2"</span>,</span><br><span class="line">          <span class="attr">"tools"</span>: [</span><br><span class="line">            <span class="string">"xelatex"</span>,</span><br><span class="line">            <span class="string">"bibtex"</span>,</span><br><span class="line">            <span class="string">"xelatex"</span>,</span><br><span class="line">            <span class="string">"xelatex"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure><h4 id="sumatrapdf配置">SumatraPDF配置</h4><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/38178015" class="uri" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/38178015</a></p></blockquote><ul><li><p>预览设置：在 <code>settings.json</code> 添加如下字段： <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">"latex-workshop.view.pdf.viewer": "external",</span><br><span class="line"></span><br><span class="line">"latex-workshop.view.pdf.external.command": &#123;</span><br><span class="line">    "command": "SumatraPDF.exe的完整路径",</span><br><span class="line">    "args": [</span><br><span class="line">        <span class="string">"%PDF%"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p></li><li><p>正向搜索：在 <code>settings.json</code> 添加如下字段：（没有成功。。。） <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">"latex-workshop.view.pdf.external.synctex": &#123;</span><br><span class="line">    "command": "SumatraPDF.exe的完整路径",</span><br><span class="line">    "args": [</span><br><span class="line">        "-forward-search",</span><br><span class="line">        "%TEX%",</span><br><span class="line">        "%LINE%",</span><br><span class="line">        <span class="string">"%PDF%"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p></li><li><p>反向搜索：在SumatraPDF的 <code>设置-&gt;选项</code> 中，在最下面填入：（双击即可反向搜索） <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Code.exe的完整路径 -g &quot;%f:%l&quot;</span><br></pre></td></tr></table></figure></p></li></ul><h2 id="参考资料">参考资料</h2><ol type="1"><li>https://code.visualstudio.com/docs/languages/cpp</li><li>https://zhuanlan.zhihu.com/p/38178015</li></ol>]]></content>
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件配置 </tag>
            
            <tag> Visual Studio Code </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>调教Hexo[5]——Hexo网站迁移中一些遗漏的问题</title>
      <link href="/2018/10/27/Hexo%E7%BD%91%E7%AB%99%E8%BF%81%E7%A7%BB%E4%B8%AD%E4%B8%80%E4%BA%9B%E9%81%97%E6%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <content type="html"><![CDATA[<ul><li>笔记本屏幕坏掉了…正式宣告我本学期开学前后在修南桥芯片上花的将近300几乎打了水漂…</li><li>一怒之下搞了个新笔记本，原先的笔记本放在寝室当主机用吧…</li></ul><blockquote><p>于是问题来了，我又双叒叕得迁移一次网站，然后又双叒叕遇到一系列问题. 在此记录，权当之前《迁移》一文的补充.</p></blockquote><a id="more"></a><h2 id="环境配置与文件同步">环境配置与文件同步</h2><p>感觉不需要多废话…我使用了坚果云来进行同步.</p><h2 id="换行符lf与crlf之争">换行符：LF与CRLF之争</h2><p>将文件迁移好之后，如果贸然 <code>hexo g, d</code> 二连，在部署时会有如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">warning: LF will be replaced by CRLF in ..... </span><br><span class="line">The file will have its origional line endings in your working directory.</span><br></pre></td></tr></table></figure><h3 id="解决方案">解决方案</h3><p>只需要运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>再运行 <code>hexo d</code> 即可.</p><h2 id="github-ssh-key的完整配置">github ssh key的完整配置</h2><p>首先肯定是要创建 ssh key：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure><p>需要输入的地方全都直接回车确认，会在 <code>/.ssh</code> 目录下生成两个文件 <code>id_rsa</code> 和 <code>id_rsa.pub</code>，然后在github上把 <code>id_rsa.pub</code> 添加到ssh key即可.</p><blockquote><p>我做完这些之后就直接开始运行 <code>g</code> 和 <code>d</code>，然而有如下报错： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error: ssh: connect to host github.com port 22: Connection timed out</span><br><span class="line">fatal: Could not read from remote repository.</span><br></pre></td></tr></table></figure></p></blockquote><p>在网上查了一会儿，感觉那些方法看起来都不太适合我的情况. 于是上github的ssh key页面看了一眼，发现github认为我还没有使用过这个key… 此时我想到，这是否是因为我没有验证ssh key… 于是验证了一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line"></span><br><span class="line">&gt; The authenticity of host &apos;github.com (192.30.253.112)&apos; can&apos;t be established.</span><br><span class="line">RSA key fingerprint is SHA256:xxxxxxxxxxxxxxxxxx.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure><p>看到这个信息我有点迷。。。不过还是输了 <code>yes</code>…，随后得到如下提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; Warning: permanently added &apos;github.com,192.30.253.112&apos; (RSA) to the list of known hosts.</span><br><span class="line">Hi lzcwr! You&apos;ve successfully authenticated, but Github does not provide shell access.</span><br></pre></td></tr></table></figure><p>此时再运行 <code>hexo d</code> 就不再报错了.</p>]]></content>
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 计算机 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>调教Hexo[4]——记一次费劲的改版...</title>
      <link href="/2018/10/04/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%94%B9%E7%89%88/"/>
      <content type="html"><![CDATA[<blockquote><p>其实大概是因为我太笨Orz… 又双叒叕是一篇没有营养的文章.</p></blockquote><p>很早就发现之前用的 <code>yelee</code> 主题中的 <code>git</code> 图标不能用了，前几日又发现无序列表的符号也挂掉了？？ 这可不能忍… 然而我又不想花时间折腾主题本身，加上搜索功能一直没有配好的积怨，决定干脆换一个主题.</p><p>这个 <code>NexT</code> 主题好像看起来不错！就是它了！</p><p>随后就是很多问题…佛了.</p><blockquote><p>所以在这里把一些（能想起来的）问题简单记一下。</p></blockquote><a id="more"></a><h2 id="tags和categories页面无法正常显示的问题">Tags和Categories页面无法正常显示的问题</h2><p>在最初更换主题后，<code>tags</code> 和 <code>categories</code> 页面只有一个光秃秃的标题，下面的链接全部消失了… 我以为是页面没有生成好的问题，于是先运行 <code>hexo clean</code> 再运行 <code>hexo g</code>，然后重新 <code>hexo s</code>.</p><p>然而并没有什么效果！吓尿的我赶紧 <del>重试了n发</del> Google了一下，大概是搜索姿势问题，这个问题不太容易准确描述… 费了一通劲，终于查明白了：只需要在这两个页面中分别加入一句话就可以了.</p><p>完整的构建过程如下（只以 <code>tags</code> 为例，<code>categories</code> 同理）：</p><ul><li><p>先在终端中键入 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure></p></li><li><p>然后在 <code>/source</code> 目录下会生成一个 <code>/tags</code> 子目录，内含一个 <code>index.md</code> 文件，其初始内容为： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">date:</span> <span class="string">yyyy-mm-dd</span> <span class="attr">hh:mm:ss</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></p></li><li><p>只需添加一行 <code>type: tags</code> 即可. 即改为： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">date:</span> <span class="string">yyyy-mm-dd</span> <span class="attr">hh:mm:ss</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></p></li></ul><p>如此操作后，<code>tags</code> 页面即可正常显示. <code>categories</code> 页面也是同理.</p><h2 id="mathjax显示问题">Mathjax显示问题</h2><blockquote><p>这个问题我认为是 <code>NexT</code> 主题的锅.</p></blockquote><p>像我这样的一个网站，<code>mathjax</code> 的重要性不言而喻… 没有 <code>mathjax</code> 我这个网站简直可以直接关掉了. 于是这是我刚换了主题就立刻着手配置的东西.</p><p>在 <code>NexT</code> 主题的配置文件 <code>_config.yml</code> 中关于 <code>mathjax</code> 的内容如下： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Third Party Services Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MathJax Support</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  per_page:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  cdn:</span> <span class="string">//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML</span></span><br></pre></td></tr></table></figure></p><p>按照其文档所描述，只需将 <code>enable: false</code> 改为 <code>enable: true</code> 即可. 然而我照做后，发现文档中的 <code>mathjax</code> 公式只能短暂地正常显示几秒，就会变成一堆不知道是什么的小方块…</p><p>看到这个情况以后我很慌张… 冷静了一会儿之后开始思考这个问题的成因… 最初没有想到是 <code>NexT</code> 主题的问题，感觉可能性比较大的也就是这么几个：</p><ul><li>是 <code>Google Chrome</code> 浏览器的问题，辣鸡 <code>Chrome</code> 无法正常显示 <code>mathjax</code> 公式.<ul><li>检查方案：换个浏览器打开 <code>localhost:4000</code> 试试；</li><li>检查结果：其他浏览器显示的也是一堆小方块…GG！</li></ul></li><li>既然不是 <code>Chrome</code> 的锅，那就是我配错了！<ul><li>检查方案：找找其他用了 <code>NexT</code> 主题的网站，看看是否有同样问题；</li><li>检查结果：找这个有 <code>LaTeX</code> 公式的 <code>NexT</code> 网站就费了老鼻子劲… 然后发现也是一堆小方块… GG again！</li></ul></li><li>和卜凡大神讨论了一下，可能是 <code>mathjax</code> 被墙了？<ul><li>检查方案：墙个屁啊…可能么？链接都能打开怎么可能是墙了… one more GG！</li></ul></li></ul><p>三个我认为比较可能的问题都不存在… 这让我陷入了短暂的蒙蔽… 回过神来以后，我感到我对于我最初做的假设“主题本身没有错”产生了一丝怀疑，联想到 <code>yelee</code> 主题仍然能正常显示 <code>LaTeX</code> 公式，我查了一发 <code>mathjax</code> 的配置方法，然后发现 <code>cdn</code> 和这里的不一样…</p><p>于是我在某篇文章中加了另一个 <code>cdn</code>，这篇文章便能正确加载 <code>mathjax</code> 了… 我简直佛了，于是进行了如下修改，<code>mathjax</code> 即能正确加载. <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MathJax Support</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  per_page:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  cdn:</span> <span class="string">//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span></span><br></pre></td></tr></table></figure></p><h2 id="动画特效canvas-nest配置">动画特效canvas-nest配置</h2><p>文档中提供的方法为：在配置文件中将 <code>canvas_nest</code> 一项改为 <code>true</code> ，我照做了，然而并没有什么效果.</p><p>单页的配置方法很简单：在文章中加入以下字段即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/lib/canvas-nest/canvas-nest.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>若想在所有页面均启用该特效，则须修改 <code>_layout.swig</code> 文件：</p><ul><li><p>在<code>_layout.swig</code> 的 <code>body</code> 中添加如下字段： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.canvas_nest %&#125;</span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"/lib/canvas-nest/canvas-nest.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>然后依次运行 <code>hexo clean</code>, <code>hexo g</code> 和 <code>hexo s</code> / <code>hexo d</code> 即可看到特效.</p></li></ul><h2 id="搜索功能的配置">搜索功能的配置</h2><p>按照文档中的方法进行操作即可成功配置，治好了我多时没有在 <code>yelee</code> 中配好搜索功能的心病…</p><p><strong>注意：</strong>不需要在 <code>_config.yml</code> 中添加 <code>search</code> 项，否则侧栏中将会出现两个“搜索”.</p><h2 id="评论功能的配置">评论功能的配置</h2><h3 id="gitment">Gitment</h3><p>之前的版本配置了多说评论，然而不久多说就GG了，加上 <code>disqus</code> 疑似被墙… 之后一直没有再弄评论. 既然改版了，顺手配了一个 <code>gitment</code> 评论，如有错误欢迎批评.</p><p>配置很简单：</p><ul><li><p>在 <a href="https://github.com/settings/developers" class="uri" target="_blank" rel="noopener">https://github.com/settings/developers</a> 申请一个 application, 按照如下内容填写申请即可： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Application</span> <span class="string">name：Gitment</span></span><br><span class="line"><span class="string">Homepage</span> <span class="string">URL：https://网站地址/</span></span><br><span class="line"><span class="string">Application</span> <span class="string">description：Blog</span> <span class="string">comment</span> <span class="string">system</span></span><br><span class="line"><span class="string">Authorization</span> <span class="string">callback</span> <span class="string">URL：https://网站地址/</span></span><br></pre></td></tr></table></figure></p></li><li>然后在 <code>github</code> 新建一个仓库用来存评论，比如叫做 <code>gitment-comments</code>.</li><li><p>在主题配置文件 <code>_config.yml</code> 中填写 <code>gitment</code> 相关内容即可完成配置. <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gitment:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  mint:</span> <span class="literal">true</span> <span class="comment"># RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway</span></span><br><span class="line"><span class="attr">  count:</span> <span class="literal">true</span> <span class="comment"># Show comments count in post meta area</span></span><br><span class="line"><span class="attr">  lazy:</span> <span class="literal">false</span> <span class="comment"># Comments lazy loading with a button</span></span><br><span class="line"><span class="attr">  cleanly:</span> <span class="literal">false</span> <span class="comment"># Hide 'Powered by ...' on footer, and more</span></span><br><span class="line"><span class="attr">  language:</span> <span class="string">zh-Hans</span> <span class="comment"># Force language, or auto switch by theme</span></span><br><span class="line"><span class="attr">  github_user:</span> <span class="string">lzcwr</span> <span class="comment"># MUST HAVE, Your Github ID</span></span><br><span class="line"><span class="attr">  github_repo:</span> <span class="string">gitment-comments</span> <span class="comment"># MUST HAVE, The repo you use to store Gitment comments</span></span><br><span class="line"><span class="attr">  client_id:</span> <span class="string">在申请好application的页面中有</span> <span class="comment"># MUST HAVE, Github client id for the Gitment</span></span><br><span class="line"><span class="attr">  client_secret:</span> <span class="string">在申请好application的页面中有</span> <span class="comment"># EITHER this or proxy_gateway, Github access secret token for the Gitment</span></span><br><span class="line"><span class="attr">  proxy_gateway:</span> <span class="comment"># Address of api proxy, See: https://github.com/aimingoo/intersect</span></span><br><span class="line"><span class="attr">  redirect_protocol:</span> <span class="comment"># Protocol of redirect_uri with force_redirect_protocol when mint enabled</span></span><br></pre></td></tr></table></figure></p></li></ul><h4 id="又双叒叕失败了">又双叒叕失败了！</h4><p>正当我满心欢喜意为自己配好了 <code>Gitment</code> 的时候，突然感到事情太顺利了（？）于是决定测试一下评论. <code>hexo d</code> 部署完毕以后，我在本文的后面尝试了一下用 <code>github</code> 账号登录.</p><p>然而！报错了！报错信息为 <code>[object ProgressEvent]</code>.</p><p>我赶紧去 <code>gitment</code> 的 <code>issue</code> （参见<a href="https://github.com/imsun/gitment/issues/170" class="uri" target="_blank" rel="noopener">https://github.com/imsun/gitment/issues/170</a>） 里翻了一下，果然很多人有这样的问题…</p><p>大致阅读了一下，原因应该是 <code>gitment</code> 作者自己的网站的证书到期了，而 <code>gitment</code> 需要以此为接口，故会报错… 按照里面的一些方法进行了修改，但是似乎没有什么效果…</p><p>怎么办！换吧…</p><h3 id="gitalk">Gitalk</h3><p>换什么呢… 开始自闭… 对哦！然想起来 <a href="https://njuwfang.github.io/" target="_blank" rel="noopener">望望同学的博客</a> 里面用的好像是 <code>github issues</code> 评论！</p><p>赶紧去翻翻是不是 <code>gitment</code>… 噢，原来是 <code>gitalk</code>… OK！就是它了！</p><h4 id="配置方法">配置方法</h4><blockquote><p>附一个 <code>gitalk</code> 的官方demo：<a href="https://gitalk.github.io/" class="uri" target="_blank" rel="noopener">https://gitalk.github.io/</a><br>官方 <code>github</code> 仓库：<a href="https://github.com/gitalk/gitalk" class="uri" target="_blank" rel="noopener">https://github.com/gitalk/gitalk</a></p></blockquote><p><code>NexT</code> 主题中并没有集成 <code>gitalk</code> 功能，需要自己手动添加.</p><ul><li>首先肯定还是要在 <code>github</code> 上申请一个 application，具体步骤见上.</li><li>其次肯定还是要在 <code>github</code> 上建立一个 repository，具体步骤不多啰嗦.</li><li><p>在 <code>/layout/_third-party/comments/</code> 目录下新建 <code>gitalk.swig</code> 文件，内容如下： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> page.comments &amp;&amp; theme.gitalk.enable %&#125;</span><br><span class="line">    &lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"https://unpkg.com/gitalk/dist/gitalk.css"</span>&gt;</span><br><span class="line">    &lt;script src=<span class="string">"https://unpkg.com/gitalk/dist/gitalk.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="keyword">var</span> gitalk = <span class="keyword">new</span> Gitalk(&#123;</span><br><span class="line">          clientID: <span class="string">'&#123;&#123; theme.gitalk.ClientID &#125;&#125;'</span>,</span><br><span class="line">          clientSecret: <span class="string">'&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;'</span>,</span><br><span class="line">          repo: <span class="string">'&#123;&#123; theme.gitalk.repo &#125;&#125;'</span>,</span><br><span class="line">          owner: <span class="string">'&#123;&#123; theme.gitalk.owner &#125;&#125;'</span>,</span><br><span class="line">          admin: [<span class="string">'&#123;&#123; theme.gitalk.adminUser &#125;&#125;'</span>],</span><br><span class="line">          id: location.pathname,</span><br><span class="line">          distractionFreeMode: <span class="string">'&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;'</span></span><br><span class="line">        &#125;)</span><br><span class="line">        gitalk.render(<span class="string">'gitalk-container'</span>)           </span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure></p></li><li><p>修改 <code>/layout/_partials/comments.swig</code>，在最后一个 <code>elseif</code> 后添加如下字段： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% elseif theme.gitalk.enable %&#125;</span><br><span class="line"> &lt;div id=<span class="string">"gitalk-container"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><ul><li>添加后的 <code>comments.swig</code> 应如下所示： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  &#123;% elseif theme.gitment.enable %&#125;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"comments"</span> id=<span class="string">"comments"</span>&gt;</span><br><span class="line">      &#123;% <span class="keyword">if</span> theme.gitment.lazy %&#125;</span><br><span class="line">        &lt;div onclick=<span class="string">"showGitment()"</span> id=<span class="string">"gitment-display-button"</span>&gt;&#123;&#123; __(<span class="string">'gitmentbutton'</span>) &#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div id="gitment-container" style="display:none"&gt;&lt;/</span>div&gt;</span><br><span class="line">      &#123;% <span class="keyword">else</span> %&#125;</span><br><span class="line">        &lt;div id=<span class="string">"gitment-container"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      &#123;% endif %&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  &#123;% elseif theme.valine.appid and theme.valine.appkey %&#125;</span></span><br><span class="line"><span class="regexp">    &lt;div class="comments" id="comments"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  </span><br><span class="line">  &#123;% elseif theme.gitalk.enable %&#125;</span><br><span class="line">    &lt;div id=<span class="string">"gitalk-container"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>修改 <code>/layout/_third-party/comments/index.swig</code>，在其末尾添加如下字段： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include <span class="string">'gitalk.swig'</span> %&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>设置 <code>gitalk</code> 的样式，参考<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>： 在 <code>/source/css/_common/components/third-party/</code> 目录下新建 <code>gitalk.styl</code> 文件，内容如下： <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.gt-header</span> <span class="selector-tag">a</span>, <span class="selector-class">.gt-comments</span> <span class="selector-tag">a</span>, <span class="selector-class">.gt-popup</span> <span class="selector-tag">a</span></span><br><span class="line">  <span class="selector-tag">border-bottom</span>: <span class="selector-tag">none</span>;</span><br><span class="line"><span class="selector-class">.gt-container</span> <span class="selector-class">.gt-popup</span> <span class="selector-class">.gt-action</span><span class="selector-class">.is--active</span><span class="selector-pseudo">:before</span></span><br><span class="line">  <span class="selector-tag">top</span>: 0<span class="selector-class">.7em</span>;</span><br></pre></td></tr></table></figure></p></li><li><p>修改 <code>/source/css/_common/components/third-party/third-party.styl</code> 文件，在末尾添加如下字段： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">"gitalk"</span>;</span><br></pre></td></tr></table></figure></p></li><li><p>最后在主题配置文件 <code>_config.yml</code> 中添加如下项： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gitalk:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  owner:</span> <span class="string">你的github帐号</span>  <span class="comment"># lzcwr  </span></span><br><span class="line"><span class="attr">  repo:</span> <span class="string">存放评论的仓库名称</span>   <span class="comment"># Gitalk-comments</span></span><br><span class="line"><span class="attr">  ClientID:</span> <span class="string">在申请好application的页面中有</span></span><br><span class="line"><span class="attr">  ClientSecret:</span> <span class="string">在申请好application的页面中有</span></span><br><span class="line"><span class="attr">  adminUser:</span> <span class="string">你的github帐号</span> <span class="comment"># 可初始化评论的账户</span></span><br><span class="line"><span class="attr">  distractionFreeMode:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p></li></ul><p>完整无误地完成上述步骤后，在本地即可看到 <code>gitalk</code> 的按钮. 但本地不能用，必须要 <code>hexo d</code> 部署完毕后才能使用.</p><blockquote><p>你以为这样就完了吗？那可未必…</p></blockquote><h4 id="error-validation-failed-解决方案">Error: Validation Failed 解决方案</h4><blockquote><p>参考了：<a href="https://priesttomb.github.io/%E6%97%A5%E5%B8%B8/2018/02/12/%E5%A4%84%E7%90%86Gitalk%E4%B8%AD%E7%94%B1%E4%BA%8E%E6%96%87%E7%AB%A0URL%E8%BF%87%E9%95%BF%E5%AF%BC%E8%87%B4%E7%9A%84Validation-Failed(422)/" target="_blank" rel="noopener">处理Gitalk中由于文章URL过长导致的Validation-Failed(422)</a></p></blockquote><p>部署完毕后我试了一下，又gg了！又双叒叕翻了一下 <code>issues</code>，发现是文章 <code>URL</code> 过长导致的（坏习惯，用中文做标题Orz… 中文会被编码成很长的串…）. <code>gitalk</code> 支持的长度只有50，难道我要一个一个改标题么？不能忍… 于是 <code>google</code> 了一大通，最终受到上述文章启发，决定用其 <code>md5</code> 码代替文章标题.</p><p>注意到前文所添加的 <code>gitalk.swig</code> 文件中的段落： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> gitalk = <span class="keyword">new</span> Gitalk(&#123;</span><br><span class="line">        clientID: <span class="string">'&#123;&#123; theme.gitalk.ClientID &#125;&#125;'</span>,</span><br><span class="line">        clientSecret: <span class="string">'&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;'</span>,</span><br><span class="line">        repo: <span class="string">'&#123;&#123; theme.gitalk.repo &#125;&#125;'</span>,</span><br><span class="line">        owner: <span class="string">'&#123;&#123; theme.gitalk.owner &#125;&#125;'</span>,</span><br><span class="line">        admin: [<span class="string">'&#123;&#123; theme.gitalk.adminUser &#125;&#125;'</span>],</span><br><span class="line">        id: location.pathname,</span><br><span class="line">        distractionFreeMode: <span class="string">'&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    gitalk.render(<span class="string">'gitalk-container'</span>)           </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><p><code>var gitalk</code> 中有一项为： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id: location.pathname,</span><br></pre></td></tr></table></figure></p><p>这里正是索引的地方，我们只需要添加一个 <code>md5</code> 的函数，然后将其改为 <code>md5(...)</code> 即可.</p><p>我用的是 <a href="https://github.com/blueimp/JavaScript-MD5/blob/master/js/md5.min.js" class="uri" target="_blank" rel="noopener">https://github.com/blueimp/JavaScript-MD5/blob/master/js/md5.min.js</a>，更改完毕之后的 <code>gitalk.swig</code> 文件如下： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> page.comments &amp;&amp; theme.gitalk.enable %&#125;</span><br><span class="line">    &lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"https://unpkg.com/gitalk/dist/gitalk.css"</span>&gt;</span><br><span class="line">    &lt;script src=<span class="string">"/js/md5.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script src=<span class="string">"https://unpkg.com/gitalk/dist/gitalk.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="keyword">var</span> gitalk = <span class="keyword">new</span> Gitalk(&#123;</span><br><span class="line">          clientID: <span class="string">'&#123;&#123; theme.gitalk.ClientID &#125;&#125;'</span>,</span><br><span class="line">          clientSecret: <span class="string">'&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;'</span>,</span><br><span class="line">          repo: <span class="string">'&#123;&#123; theme.gitalk.repo &#125;&#125;'</span>,</span><br><span class="line">          owner: <span class="string">'&#123;&#123; theme.gitalk.owner &#125;&#125;'</span>,</span><br><span class="line">          admin: [<span class="string">'&#123;&#123; theme.gitalk.adminUser &#125;&#125;'</span>],</span><br><span class="line">          id: md5(location.pathname),</span><br><span class="line">          distractionFreeMode: <span class="string">'&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;'</span></span><br><span class="line">        &#125;)</span><br><span class="line">        gitalk.render(<span class="string">'gitalk-container'</span>)           </span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure></p><p>这样好像就彻底搞好了？<del>我这乌鸦嘴可还行==</del></p><h4 id="关闭评论的页面">关闭评论的页面</h4><p>在需要关闭评论的页面加一句 <code>comments: false</code> 即可.</p><h2 id="pdf插件配置">PDF插件配置</h2><blockquote><p>不多说了，参见 <a href="https://pdfobject.com/" class="uri" target="_blank" rel="noopener">https://pdfobject.com/</a><br>官方 <code>github</code> 仓库：<a href="https://github.com/pipwerks/PDFObject" class="uri" target="_blank" rel="noopener">https://github.com/pipwerks/PDFObject</a></p></blockquote><section class="footnotes"><hr><ol><li id="fn1"><p><a href="https://asdfv1929.github.io/2018/01/20/gitalk/" class="uri" target="_blank" rel="noopener">https://asdfv1929.github.io/2018/01/20/gitalk/</a><a href="#fnref1" class="footnote-back">↩</a></p></li></ol></section>]]></content>
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 计算机 </tag>
            
            <tag> Hexo </tag>
            
            <tag> Mathjax </tag>
            
            <tag> Gitalk </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python学习[1]——时间序列分析</title>
      <link href="/2018/09/26/Python%E5%AD%A6%E4%B9%A0-1-%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%88%86%E6%9E%90/"/>
      <content type="html"><![CDATA[<ul><li>做了一个数据预测的东西, 对这方面的内容过于生疏, 顺手简单学习了一波Orz…</li><li><code>tsa</code> 的官方文档：<a href="http://www.statsmodels.org/dev/tsa.html" class="uri" target="_blank" rel="noopener">http://www.statsmodels.org/dev/tsa.html</a></li></ul><blockquote><p>面向乱搞的程序设计？</p></blockquote><a id="more"></a><h2 id="序列的分析">序列的分析</h2><h3 id="序列的平稳性">序列的平稳性</h3><p>如果时间序列 <span class="math inline">\(x_t\)</span> 在某一常数附近波动并且范围不大，方差和均值为常数，且延迟 <span class="math inline">\(k\)</span> 期的子自协方差和自相关系数是相等的，则称 <span class="math inline">\(x_t\)</span> 是平稳序列. <a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p><p>自协方差和自相关系数的定义如下：</p><ul><li>自协方差：<span class="math inline">\(\gamma(t,s) = \mathbb{E}[(x_t-\mu_t)(x_s-\mu_s)]\)</span></li><li>自相关系数：<span class="math inline">\(\rho(t,s) = \frac{cov(x_t, x_s)}{\sigma_t\sigma_s}\)</span></li></ul><h4 id="平稳序列的判定平稳性检验">平稳序列的判定：平稳性检验</h4><p>一般有以下两种方法：</p><ol type="1"><li>时序图检验：根据平稳序列的均值和方差都为常数的性质，平稳时间序列的时序图应当显示该序列始终在一个常数附近随机波动，且波动范围有限；</li><li>自相关检验：平稳时间序列具有短期相关性，故平稳时间序列通常只有近期的项才对当前值的影响较为明显。随着间隔 <span class="math inline">\(k\)</span> 的增大，平稳序列的自相关系数会不断衰减至 <span class="math inline">\(0\)</span>，而非平稳序列的衰减较慢。</li></ol><h3 id="白噪声序列">白噪声序列</h3><ul><li>白噪声序列指的是纯随机序列，序列的各项之间毫无关系，从中无法获取任何有用的信息。</li></ul><h4 id="白噪声序列的判定纯随机性检验">白噪声序列的判定：纯随机性检验</h4><p>纯随机序列满足 <span class="math inline">\(\gamma(k) = 0\)</span>，其样本自相关系数很接近零，并且在零附近随机扰动。一般构造 <span class="math inline">\(Q\)</span> 统计量和 <span class="math inline">\(LB\)</span> 统计量来进行检验.</p><ul><li>在 <code>Python</code> 中可以使用 <code>acorr_ljungbox</code> 方法来检验.</li><li>直接 <code>print(acorr_ljungbox(ts, lags = 1))</code>.</li></ul><h2 id="常用的模型原理">常用的模型原理</h2><p>时间序列趋势主要受到总体趋势 <span class="math inline">\(T\)</span>、季节性因素 <span class="math inline">\(S\)</span>、周期性波动 <span class="math inline">\(C\)</span> 和随机扰动 <span class="math inline">\(\varepsilon\)</span> 的影响，一般来说有加法和乘法两种模型。</p><ol type="1"><li>加法模型(additive model): <span class="math inline">\(x_t = T_t+S_t+C_t+\varepsilon_t\)</span>;</li><li>乘法模型(multiplicative model): <span class="math inline">\(x_t = T_t\times S_t\times C_t\times\varepsilon_t\)</span>.</li></ol><p>在作分析时，常常采用的是AR-MA模型：</p><ol type="1"><li>AR模型 <span class="math inline">\(AR(p)\)</span>：每一项都与前 <span class="math inline">\(p\)</span> 项线性相关, 与随机扰动项无关. <span class="math display">\[x_t=\varphi_0 + \varphi_1 x_{t-1}+\varphi_2 x_{t-2}+\cdots+\varphi_p x_{t-p}+\varepsilon_t = \varphi_0+ \sum\limits_{k=1}^p \varphi_k x_{t-k}+\varepsilon_t\]</span> 其中随机扰动项 <span class="math inline">\(\varepsilon_t\)</span> 为均值为 <span class="math inline">\(0\)</span> 的白噪声序列. 均值方差均为常数，ACF拖尾，PACF <span class="math inline">\(q\)</span> 阶截尾.</li><li>MA模型 <span class="math inline">\(MA(q)\)</span>：每一项都与前 <span class="math inline">\(q\)</span> 项的随机扰动线性相关, 与真实值无关. <span class="math display">\[x_t = \mu + \varepsilon_t-\theta_1 \varepsilon_{t-1}-\theta_2\varepsilon_{t-2}-\cdots-\theta_q \varepsilon_{t-q} = \mu + \varepsilon_t - \sum\limits_{k=1}^q \theta_k\varepsilon_{t-k}\]</span> 其中随机扰动项 <span class="math inline">\(\varepsilon_t\)</span> 为均值为 <span class="math inline">\(0\)</span> 的白噪声序列，<span class="math inline">\(\mu\)</span> 为序列均值. 均值方差为常数，ACF为 <span class="math inline">\(q\)</span> 阶截尾，PACF拖尾.</li><li>ARMA模型 <span class="math inline">\(ARMA(p,q)\)</span>：每一项都与前 <span class="math inline">\(p\)</span> 项线性相关, 同时与前 <span class="math inline">\(q\)</span> 项的随机扰动有关. <span class="math display">\[\begin{align}x_t &amp;= \varphi_0 + \varphi_1 x_{t-1}+\varphi_2 x_{t-2}+\cdots+\varphi_p x_{t-p} + \varepsilon_t-\theta_1 \varepsilon_{t-1}-\theta_2\varepsilon_{t-2}-\cdots-\theta_q \varepsilon_{t-q} \\&amp;= \varphi_0 + \sum\limits_{i=1}^p \varphi_i x_{t-i} + \varepsilon_t - \sum\limits_{j=1}^q \theta_j\varepsilon_{t-j}\end{align}\]</span> 其中随机扰动项 <span class="math inline">\(\varepsilon_t\)</span> 为均值为 <span class="math inline">\(0\)</span> 的白噪声序列，<span class="math inline">\(\mu\)</span> 为序列均值. 均值方差为常数，ACF为 <span class="math inline">\(q\)</span> 阶截尾，PACF <span class="math inline">\(p\)</span> 阶截尾.</li></ol><blockquote><p>容易看出AR模型和MA模型分别是ARMA在 <span class="math inline">\(p=0\)</span> 和 <span class="math inline">\(q=0\)</span> 时的特例.</p></blockquote><p>一般在分析时分析的多是平稳序列，可以考虑用ARMA模型。有一些序列本身不是平稳序列，但做一阶差分之后成为平稳序列，这种序列被称为差分平稳序列，可以使用ARIMA模型进行拟合.</p><h2 id="python中的amra模型">Python中的AMRA模型</h2><h3 id="导入库">导入库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> statsmodels.graphics.tsaplots <span class="keyword">import</span> plot_acf <span class="comment"># 自相关图</span></span><br><span class="line"><span class="keyword">from</span> statsmodels.graphics.tsaplots <span class="keyword">import</span> plot_pacf <span class="comment"># 偏自相关图</span></span><br><span class="line"><span class="keyword">from</span> statsmodels.stats.diagnostic <span class="keyword">import</span> acorr_ljungbox <span class="comment"># 白噪声检验</span></span><br><span class="line"><span class="keyword">from</span> statsmodels.tsa.stattools <span class="keyword">import</span> adfuller <span class="comment"># 平稳性检测</span></span><br><span class="line"><span class="keyword">from</span> statsmodels.tsa.seasonal <span class="keyword">import</span> seasonal_decompose <span class="comment"># 季节性分解</span></span><br><span class="line"><span class="keyword">from</span> statsmodels.tsa.arima_model <span class="keyword">import</span> ARMA</span><br><span class="line"><span class="keyword">from</span> statsmodels.tsa.arima_model <span class="keyword">import</span> ARIMA</span><br></pre></td></tr></table></figure><h3 id="乱码问题处理">乱码问题处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'SimHei'</span>] <span class="comment"># 显示中文标签</span></span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="keyword">False</span> <span class="comment"># 显示负号</span></span><br></pre></td></tr></table></figure><h3 id="数据读取与处理">数据读取与处理</h3><p>按照我的习惯会将日期一列命名为 <code>date</code>.</p><h4 id="数据读取">数据读取</h4><p>一般数据的格式为 <code>XLS</code> 或者 <code>CSV</code>.</p><ol type="1"><li><p>数据为CSV格式 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">'文件地址'</span>, encoding = <span class="string">'utf-8'</span>, index_col = <span class="string">'date'</span>)</span><br></pre></td></tr></table></figure></p></li><li><p>数据为XLS格式 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_excel(<span class="string">'文件地址'</span>, encoding = <span class="string">'utf-8'</span>, index_col = <span class="string">'data'</span>)</span><br></pre></td></tr></table></figure></p></li></ol><p>若数据为数据库形式(如 <code>MySQL</code>), 则可以直接用 <code>SQL</code> 语句从数据库中提取.</p><h4 id="数据格式的处理">数据格式的处理</h4><p>以上读取数据的函数只会将读入的数据保存为 <code>DataFrame</code> 对象，但我们做预测所需要的数据类型是 <code>Series</code>，故需要将其转换为该格式，并将 <code>date</code> 指定为索引.<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.index = pd.to_datetime(df.index)  <span class="comment"># 指定 date 为索引</span></span><br><span class="line">ts = df[<span class="string">'x'</span>]  <span class="comment"># 生成Series对象</span></span><br></pre></td></tr></table></figure><blockquote><center><font color="red"><strong>注意此处数据文件中的日期必须为日期格式. </strong></font>如 (yyyy/mm/dd) 是合法的，但 “20080808” 就是不合法的，必须进行处理.<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a></center></blockquote><p>如此得到的 <code>ts</code> 即为一个可用的时间序列，不仅可以用类似于 <code>2014-1-1</code> 的字符串进行访问，也可以用时间对象 <code>datetime(2014, 1, 1)</code> 进行访问. 即以下两种访问方式都是可行的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ts[<span class="string">'2014-1-1'</span>]</span><br><span class="line">ts[datetime(<span class="number">2014</span>, <span class="number">1</span>, <span class="number">1</span>)]</span><br><span class="line">ts[<span class="string">'2014-1-1'</span> : <span class="string">'2014-5-1'</span>] <span class="comment"># 切片操作. 注意此处的切片为闭区间, 端点都包括.</span></span><br></pre></td></tr></table></figure><blockquote><p>关于 <code>Series</code> 的更多内容参见 https://blog.csdn.net/zutsoft/article/details/51482573</p></blockquote><h3 id="数据的趋势分析">数据的趋势分析</h3><h4 id="平稳性检验">平稳性检验</h4><p>可以进行 <code>ADF</code> 检验. 弱鸡还不理解其原理…暂且放在这里. 直接 <code>print(adfuller(ts))</code> ，输出有一大串. 第一个值比后面带百分号的都小说明比较平稳.</p><h4 id="平稳性处理季节性分解">平稳性处理：季节性分解</h4><blockquote><p>为了使序列更平稳，在做计算时经常对其取对数: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ts_log = np.log(ts)</span><br></pre></td></tr></table></figure></p></blockquote><p>若原始数据有很强的周期性，则可以考虑对其进行季节性的分解，即将元素数据分离为总体趋势，季节性趋势以及残差三部分.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">decomposition = seasonal_decompose(ts_log, model=<span class="string">"additive"</span>)</span><br><span class="line">trend = decomposition.trend</span><br><span class="line">seasonal = decomposition.seasonal</span><br><span class="line">residual = decomposition.resid</span><br></pre></td></tr></table></figure><p>将三种因素分离后，即可分别做预测，再相加. <code>statsmodels</code> 中还提供了乘法模型，只需将上述代码中的 <code>additive</code> 改为 <code>multiplicative</code> 即可.</p><h3 id="模型识别">模型识别</h3><p>只需要对所要拟合的数据集绘制其 ACF(自相关) 与 PACF(偏自相关) 图，观察其截尾与拖尾性质即可确定模型阶数.<br>相关图的绘制代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plot_acf(ts_log).show()</span><br><span class="line">plot.pacf(ts_log).show()</span><br></pre></td></tr></table></figure><p>例如最终识别为 <span class="math inline">\(p=q=1\)</span>，则预测模型为 <span class="math inline">\(ARMA(1,1)\)</span>，实现代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = ARMA(ts_log, order = (<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">result = model.fit(disp = <span class="number">-1</span>, method = <span class="string">'css'</span>)</span><br></pre></td></tr></table></figure><p>随后用以下代码即可预测：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">predict = result.predict(begin, end) <span class="comment"># begin 和 end 表示所需预测的起点与终点</span></span><br><span class="line">predict = np.exp(predict) <span class="comment"># 若之前取了对数 or 做了差分, 预测之后应还原</span></span><br></pre></td></tr></table></figure><h2 id="python中的arima模型">Python中的ARIMA模型</h2><p>没有什么卵用的模型… 多了个参数表示差分的阶数. 手动差分效果应当完全没差.</p><section class="footnotes"><hr><ol><li id="fn1"><p>参见 https://zhuanlan.zhihu.com/p/35128342<a href="#fnref1" class="footnote-back">↩</a></p></li><li id="fn2"><p>python时间序列分析: https://www.cnblogs.com/foley/p/5582358.html<a href="#fnref2" class="footnote-back">↩</a></p></li><li id="fn3"><p>将 “yyyymmdd” 转换为 “yyyy/mm/dd” 的方法很简单，以下给出 <code>C++</code> 代码： <figure class="highlight c++"><figcaption><span>date_format.cpp 处理日期格式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c - <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>); <span class="comment">// 输入到文件里, 方便使用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s; <span class="comment">// 输入格式为 yyyymmdd 字符串</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">1000</span> * f(s[<span class="number">0</span>]) + <span class="number">100</span> * f(s[<span class="number">1</span>]) + <span class="number">10</span> * f(s[<span class="number">2</span>]) + f(s[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">10</span> * f(s[<span class="number">4</span>]) + f(s[<span class="number">5</span>]);</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">10</span> * f(s[<span class="number">6</span>]) + f(s[<span class="number">7</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d/%d/%d\n"</span>, y, m, d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a href="#fnref3" class="footnote-back">↩</a></p></li></ol></section>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 计算机 </tag>
            
            <tag> 统计学 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Windows下用Shell——Cmder配置</title>
      <link href="/2018/09/23/Cmder%E9%85%8D%E7%BD%AE/"/>
      <content type="html"><![CDATA[<p>平时免不了会用到windows下的命令行, 但是 <code>cmd</code> 使用体验非常差… 后来开始用 <code>PowerShell</code>, 比起 <code>cmd</code> 来说确实有了一些改善, 但是仍然不是很友好Orz. 再后来发现了 <code>Cmder</code>, 对 <code>Shell</code> 的支持更为友好, 界面也很美观, 于是就彻底放弃了 <code>PowerShell</code>…</p><blockquote><p>这里记录一下 <code>Cmder</code> 的配置, 主要是给自己看的.</p><ul><li>中文支持</li><li>环境变量添加</li><li>右键菜单配置</li><li>提示符修改</li></ul></blockquote><a id="more"></a><h2 id="中文支持">中文支持</h2><p>在 <code>Settings -&gt; Startup -&gt; Environment</code> 里面加如下的语句即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set LANG=zh_CN.UTF8</span><br></pre></td></tr></table></figure><h2 id="环境变量添加">环境变量添加</h2><p>将 <code>Cmder</code> 的安装目录添加到 <code>PATH</code> 中. 例如我的安装目录是 <code>D:\Cmder</code>, 直接将其添加到 <code>PATH</code> 的开头即可.</p><p>成功添加环境变量后, 在 <code>Win+R</code> 调出的“运行”窗口中键入 <code>Cmder</code> 即可直接在用户目录下打开 <code>Cmder</code>.</p><h2 id="右键菜单配置">右键菜单配置</h2><p>添加好环境变量后, 在 <code>cmd</code> 或 <code>PowerShell</code> 中运行如下语句即可.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cmder.exe /REGISTER ALL</span><br></pre></td></tr></table></figure><p>成功后在任意文件夹空白处右击鼠标, 即可在快捷菜单中找到 <code>Cmder Here</code>, 即在该目录下运行 <code>Cmder</code>.</p><h2 id="提示符修改">提示符修改</h2><blockquote><p>这个在网上查了很多东西都不能直接用, 需要自己多尝试.</p></blockquote><p><code>Cmder</code> 的默认输出提示符是 <span class="math inline">\(\lambda\)</span>, 多少看着有点别扭, 按照 <code>Linux</code> 的习惯可以将其改为美元符号 <span class="math inline">\(\$\)</span>.<br>网上的教程大多是修改 <code>/vendor</code> 目录下的 <code>init.bat</code>, <code>clink.lua</code> 或 <code>profile.ps1</code> 来达到修改提示符的目的, 但是具体方法大多是不可行的.<br>我目前所使用的版本可以通过修改 <code>clink.lua</code> 来实现, 具体做法是将该文件第43行的 <code>local lambda = &quot;λ&quot;</code> 修改为 <code>local lambda = &quot;$&quot;</code> 即可…</p><p>观众用完之后（如果无效）, 不能骂我== 因为我…根本没有头发（<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p><h2 id="linux命令速查表">Linux命令速查表</h2><p>顺手放一个表在这里方便查阅..<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a></p><script src="/js/pdfobject.js"></script><style>    /* Only resize the element if PDF is embedded */    .pdfobject-container {        width: 800px;        height: 900px;    }</style><center><div id="my-container"></div></center><script>    PDFObject.embed("https://i.linuxtoy.org/files/pdf/fwunixref.pdf", "#my-container");</script><section class="footnotes"><hr><ol><li id="fn1"><p>该梗的出处见《【成龙】我的洗发液》: <a href="https://www.bilibili.com/video/av2023391" class="uri" target="_blank" rel="noopener">https://www.bilibili.com/video/av2023391</a><a href="#fnref1" class="footnote-back">↩</a></p></li><li id="fn2"><p>转载自 <a href="https://linuxtoy.org/archives/unix-linux-command-cheat-sheet.html" class="uri" target="_blank" rel="noopener">https://linuxtoy.org/archives/unix-linux-command-cheat-sheet.html</a><a href="#fnref2" class="footnote-back">↩</a></p></li></ol></section>]]></content>
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件配置 </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>组合数学[1]——球放入盒子的方案数</title>
      <link href="/2018/09/17/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E2%80%94%E2%80%94%E7%90%83%E6%94%BE%E5%85%A5%E7%9B%92%E5%AD%90%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/"/>
      <content type="html"><![CDATA[<p>近日观室友做面试题有感, 恰好遇到了球装盒子的问题, 顺手整理一波.</p><blockquote><p><span class="math inline">\(n\)</span> 个球放入 <span class="math inline">\(m\)</span> 个盒子, 共有多少种不同的方案?</p></blockquote><table><thead><tr class="header"><th style="text-align: center;">球</th><th style="text-align: center;">盒</th><th style="text-align: center;">允许空</th><th style="text-align: center;">方案数</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">不同</td><td style="text-align: center;">不同</td><td style="text-align: center;">是</td><td style="text-align: center;"><span class="math inline">\(m^n\)</span></td></tr><tr class="even"><td style="text-align: center;">不同</td><td style="text-align: center;">不同</td><td style="text-align: center;">否</td><td style="text-align: center;"><span class="math inline">\(m!\cdot S(n,m)\)</span></td></tr><tr class="odd"><td style="text-align: center;">不同</td><td style="text-align: center;">相同</td><td style="text-align: center;">是</td><td style="text-align: center;"><span class="math inline">\(\sum\limits_{k=0}^m S(n,k)\)</span></td></tr><tr class="even"><td style="text-align: center;">不同</td><td style="text-align: center;">相同</td><td style="text-align: center;">否</td><td style="text-align: center;"><span class="math inline">\(S(n,m)\)</span></td></tr><tr class="odd"><td style="text-align: center;">相同</td><td style="text-align: center;">不同</td><td style="text-align: center;">是</td><td style="text-align: center;"><span class="math inline">\(\binom{n+m-1}{m-1}\)</span></td></tr><tr class="even"><td style="text-align: center;">相同</td><td style="text-align: center;">不同</td><td style="text-align: center;">否</td><td style="text-align: center;"><span class="math inline">\(\binom{n-1}{m-1}\)</span></td></tr><tr class="odd"><td style="text-align: center;">相同</td><td style="text-align: center;">相同</td><td style="text-align: center;">是</td><td style="text-align: center;"><span class="math inline">\(dp(n,m)\)</span></td></tr><tr class="even"><td style="text-align: center;">相同</td><td style="text-align: center;">相同</td><td style="text-align: center;">否</td><td style="text-align: center;"><span class="math inline">\(dp(n-m,m)\)</span></td></tr></tbody></table><a id="more"></a><h2 id="球不同">球不同</h2><h3 id="盒子不同">盒子不同</h3><h4 id="不允许有空盒子">不允许有空盒子</h4><p>可以先视盒子为相同, 方案数为 <span class="math inline">\(S(n,m)\)</span>（参见下文）, 再考虑盒子的全排列.</p><blockquote><p><span class="math inline">\(n\)</span> 个不同的球放入 <span class="math inline">\(m\)</span> 个不同的盒子, 盒子不允许为空, 方案数为 <span class="math inline">\(m!\cdot S(n,m)\)</span>.</p></blockquote><h4 id="允许有空盒子">允许有空盒子</h4><p>最简单的情况没有之一:</p><blockquote><p><span class="math inline">\(n\)</span> 个不同的球放入 <span class="math inline">\(m\)</span> 个不同的盒子, 盒子允许为空, 方案数为 <span class="math inline">\(m^n\)</span>.</p></blockquote><h3 id="盒子相同">盒子相同</h3><h4 id="不允许有空盒子-1">不允许有空盒子</h4><blockquote><p><span class="math inline">\(n\)</span> 个不同的球放入 <span class="math inline">\(m\)</span> 个相同的盒子, 盒子不允许为空, 方案数为第二类Stirling数 <span class="math inline">\(S(n,m)\)</span>.</p></blockquote><p><strong>简略证明:</strong> 对于第 <span class="math inline">\(n\)</span> 个球, 有且仅有如下两种情况:</p><ol type="1"><li><strong>前 <span class="math inline">\(n-1\)</span> 个球的放法已经保证了 <span class="math inline">\(m\)</span> 个盒子都不空:</strong> 此时只需将 <span class="math inline">\(n\)</span> 号球随意放即可, 方案数为 <span class="math inline">\(mS(n-1,m)\)</span>;</li><li><strong>前 <span class="math inline">\(n-1\)</span> 个球放好后有且仅有一个盒子是空的:</strong> 此时必须将 <span class="math inline">\(n\)</span> 号球放入空盒中, 方案数为 <span class="math inline">\(S(n-1,m-1)\)</span>.</li></ol><p>于是, 此时的方案数递推式为 <span class="math display">\[S(n,m)=mS(n-1,m)+S(n-1,m-1)\]</span> 初值为:</p><ul><li><span class="math inline">\(S(0,m)=1\)</span>. (没球的方案只有一种)</li><li><span class="math inline">\(S(n,1)=1\)</span>. (一个盒子的方案只有一种)</li></ul><p>一段计算该种方案数的代码如下（递归版本）:</p><figure class="highlight c++"><figcaption><span>球不同, 盒相同, 不许空</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; m) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 球比盒子还少, 无法满足盒子非空</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span> || m == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 没球 or 一个盒子</span></span><br><span class="line">    <span class="keyword">return</span> m * dp(n - <span class="number">1</span>, m) + dp(n - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="允许有空盒子-1">允许有空盒子</h4><blockquote><p><span class="math inline">\(n\)</span> 个不同的球放入 <span class="math inline">\(m\)</span> 个相同的盒子, 盒子允许为空, 方案数为 <span class="math inline">\(\sum\limits_{k=0}^m S(n,k)\)</span>.</p></blockquote><p>只需要枚举非空箱子的个数, 然后按照上一种情况的方法来计算, 求和即可. 在计算时最好先预处理出 <span class="math inline">\(S(n,m)\)</span> 的值.</p><h2 id="球相同">球相同</h2><h3 id="盒子不同-1">盒子不同</h3><h4 id="不允许有空盒子-2">不允许有空盒子</h4><blockquote><p><span class="math inline">\(n\)</span> 个相同的球放入 <span class="math inline">\(m\)</span> 个不同的盒子, 盒子不允许为空, 方案数为 <span class="math inline">\(\binom{n-1}{m-1}\)</span>.</p></blockquote><p><strong>简略证明:</strong> 将 <span class="math inline">\(n\)</span> 球装入 <span class="math inline">\(m\)</span> 个盒子, 相当于插 <span class="math inline">\(m-1\)</span> 个板. 由于不允许为空, 故在 <span class="math inline">\(n-1\)</span> 个空中选出 <span class="math inline">\(m-1\)</span> 个插板即可.</p><h4 id="允许有空盒子-2">允许有空盒子</h4><blockquote><p><span class="math inline">\(n\)</span> 个相同的球放入 <span class="math inline">\(m\)</span> 个不同的盒子, 盒子允许为空, 方案数为 <span class="math inline">\(\binom{n+m-1}{m-1}\)</span>.</p></blockquote><p><strong>简略证明:</strong> <span class="math inline">\(n\)</span> 个球放完之后, 在每个盒子中都加一个球, 此时一定无空箱. 这说明此时的方案数不多于 <span class="math inline">\(n+m\)</span> 个相同的球放入 <span class="math inline">\(m\)</span> 个不同盒子的方案数. 反过来也可证明另一边的不等式, 于是此时的方案数就是<span class="math inline">\(n+m\)</span> 个相同的球放入 <span class="math inline">\(m\)</span> 个不同盒子的方案数.</p><h3 id="盒子相同-1">盒子相同</h3><h4 id="不允许有空盒子-3">不允许有空盒子</h4><blockquote><p><span class="math inline">\(n\)</span> 个相同的球放入 <span class="math inline">\(m\)</span> 个相同的盒子, 盒子不允许为空, 方案数为 <span class="math inline">\(dp(n-m,m)\)</span>.</p></blockquote><p>其中 <span class="math inline">\(dp(n,m)\)</span> 为下一种情况的方案数.</p><h4 id="允许有空盒子-3">允许有空盒子</h4><blockquote><p><span class="math inline">\(n\)</span> 个相同的球放入 <span class="math inline">\(m\)</span> 个相同的盒子, 盒子允许为空, 方案数为 <span class="math inline">\(dp(n,m)\)</span>.</p></blockquote><p><strong>计算思路:</strong>: 在放置 <span class="math inline">\(n\)</span> 个球的时候, 有且仅有如下两种策略:</p><ol type="1"><li><strong>给每个盒子放一个球:</strong> 还剩下 <span class="math inline">\(n-m\)</span> 个球, 故此时的方案数为 <span class="math inline">\(dp(n-m,m)\)</span>;</li><li><strong>至少一个盒子不放球:</strong> 可以扔掉一个空盒子, 故此时的方案数为 <span class="math inline">\(dp(n,m-1)\)</span>.</li></ol><p>于是此种情况的递推式为: <span class="math display">\[dp(n,m)=dp(n-m,m)+dp(n,m-1)\]</span> 边界值为:</p><ul><li><span class="math inline">\(S(0,m)=1\)</span>. (没球的方案只有一种)</li><li><span class="math inline">\(S(n,1)=1\)</span>. (一个盒子的方案只有一种)</li></ul><p>上述推导过程中我们做了 <span class="math inline">\(n\geqslant m\)</span>, 即“球不少于盒子”的假设. 当该假设不成立时, <span class="math inline">\(n\)</span> 个苹果至多放满 <span class="math inline">\(n\)</span> 个盘子, 故此时方案数实际上为 <span class="math inline">\(dp(n,n)\)</span>.</p><p>一段计算该情况方案数的代码如下（递归版本）:</p><figure class="highlight c++"><figcaption><span>球相同, 盒相同, 允许空 </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(m &lt; n) <span class="keyword">return</span> dp(m, m);</span><br><span class="line">    <span class="keyword">return</span> dp(m, n - <span class="number">1</span>) + dp(m - n, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018毕业季留念</title>
      <link href="/2018/07/30/2018%E6%AF%95%E4%B8%9A%E5%AD%A3%E7%95%99%E5%BF%B5/"/>
      <content type="html"><![CDATA[<blockquote><p>毕业季前后忙着夏令营和期末等各种事情, 来不及整理照片. 最近终于有空, 稍做整理. 没有进行什么排版, 都是高清大图（</p></blockquote><ul><li>本来想用JS搞一些bling-bling的特效, 但是搞了一个小时宣告失败… 我耐心很有限[手动再见]</li><li><strong><code>时间仓促, 很多朋友们没有来得及合影.. 小小的抱歉一下, 我没有忘记大家Orz</code>.</strong></li></ul><a id="more"></a><h2 id="野鸡115">野鸡115</h2><blockquote><p>第一个要讲的当然就是野鸡115, 一群野鸡的四年.</p></blockquote><h3 id="野鸡115的摆拍">野鸡115的摆拍</h3><h4 id="展板前">展板前</h4><blockquote><p>是时候欣赏大家的蹲♂姿了. 骚犇以绝对优势胜出.</p></blockquote><ul><li>第一张郭犇在蜜汁抓♂胸？<center><img src="/img/2018-biyezhao/3.jpg?imageMogr2/auto-orient" width="600" alt="毕业快乐展板-1"></center></li><li>第二张我看起来非常像是闭眼了. 虽然放大会发现没有完全闭上.<center><img src="/img/2018-biyezhao/4.jpg?imageMogr2/auto-orient" width="600" alt="毕业快乐展板-2"></center></li><li>第三张我和郭犇正常了, 可丁丁已经睡着了.<center><img src="/img/2018-biyezhao/5.jpg?imageMogr2/auto-orient" width="600" alt="毕业快乐展板-3"></center></li></ul><h4 id="电子楼">电子楼</h4><blockquote><p>大家都是信科走出来的, 当然要和电子楼来两张.</p></blockquote><center><img src="/img/2018-biyezhao/6.jpg?imageMogr2/auto-orient" width="600" alt="电子楼门前-1"></center><center><img src="/img/2018-biyezhao/8.jpg?imageMogr2/auto-orient" width="600" alt="电子楼门前-2"></center><h4 id="主楼和校训碑">主楼和校训碑</h4><blockquote><p>算是师大的两个标志性建筑物.</p></blockquote><center><img src="/img/2018-biyezhao/10.jpg?imageMogr2/auto-orient" width="600" alt="主楼前"></center><center><img src="/img/2018-biyezhao/12.jpg?imageMogr2/auto-orient" width="600" alt="校训碑, 没有猫哥Orz"></center><h4 id="科技楼前">科技楼前</h4><center><img src="/img/2018-biyezhao/2.jpg?imageMogr2/auto-orient" width="600" alt="寝室在科技楼前"></center><h3 id="散伙前的最后一张">散伙前的最后一张</h3><blockquote><p>郭犇惺忪的睡眼是此张照片的最大看点.</p></blockquote><center><img src="/img/2018-biyezhao/1.jpg?imageMogr2/auto-orient" width="600" alt="各位临走时115的最后一张合影, 可惜猫哥不在."></center><h3 id="野鸡115与乱入的兄弟们">野鸡115与乱入的兄弟们</h3><h4 id="乱入的朱彦丞">乱入的朱彦丞</h4><blockquote><p>无孔不入（ 其实最开头的一张也有他.</p></blockquote><ul><li>电子楼<center><img src="/img/2018-biyezhao/7.jpg?imageMogr2/auto-orient" width="600" alt="电子楼+朱彦丞-1"></center><center><img src="/img/2018-biyezhao/9.jpg?imageMogr2/auto-orient" width="600" alt="电子楼门前+朱彦丞-2"></center></li><li>主楼<center><img src="/img/2018-biyezhao/11.jpg?imageMogr2/auto-orient" width="600" alt="主楼前+朱彦丞"></center></li></ul><h4 id="乱入的小boo">乱入的小boo</h4><ul><li>里面仍然有朱神, Orz.<center><img src="/img/2018-biyezhao/13.jpg?imageMogr2/auto-orient" width="600" alt="校训碑+小boo+朱彦丞"></center></li></ul><h2 id="与117的合影">与117的合影</h2><h3 id="乱入117寝室合照">乱入117寝室合照</h3><center><img src="/img/2018-biyezhao/14.jpg?imageMogr2/auto-orient" width="600" alt="与117寝室的合影"></center><h3 id="与泽坤丁丁合影">与泽坤+丁丁合影</h3><blockquote><p>事实上这是第一波合影. 感谢摄影师邱哥.</p></blockquote><h4 id="三人合影">三人合影</h4><blockquote><p>全部都是在教九小花园拍的. 丁丁是115最胖, 石锤了.</p></blockquote><center><img src="/img/2018-biyezhao/15.jpg?imageMogr2/auto-orient" width="600" alt="与泽坤+丁丁的合影-1"></center><center><img src="/img/2018-biyezhao/16.jpg?imageMogr2/auto-orient" width="600" alt="与泽坤+丁丁的合影-2"></center><center><img src="/img/2018-biyezhao/17.jpg?imageMogr2/auto-orient" width="600" alt="与泽坤+丁丁的合影-3"></center><center><img src="/img/2018-biyezhao/18.jpg?imageMogr2/auto-orient" width="600" alt="与泽坤+丁丁的合影-4"></center><center><img src="/img/2018-biyezhao/19.jpg?imageMogr2/auto-orient" width="600" alt="与泽坤+丁丁的合影-5"></center><h4 id="与泽坤单独合影">与泽坤单独合影</h4><blockquote><p>容易看出, 仍然是在教九小花园.</p></blockquote><center><img src="/img/2018-biyezhao/20.jpg?imageMogr2/auto-orient" width="600" alt="与泽坤的合影"></center><h2 id="信科男篮黄金一代">14信科男篮黄金一代</h2><blockquote><p>轮到我装逼了! 四年三座奖杯, 两进总决赛. 照片比较多, 分类比较细.</p></blockquote><h3 id="单人照">单人照</h3><blockquote><p>抱着奖杯装逼的时刻, 四年仅此一回.</p></blockquote><h4 id="侯彦丞">侯彦丞</h4><center><img src="/img/2018-biyezhao/31.jpg?imageMogr2/auto-orient" width="600" alt="侯彦丞"></center><h4 id="贾鑫">贾鑫</h4><center><img src="/img/2018-biyezhao/32.jpg?imageMogr2/auto-orient" width="600" alt="贾鑫"></center><h4 id="李喆琛">李喆琛</h4><center><img src="/img/2018-biyezhao/33.jpg?imageMogr2/auto-orient" width="600" alt="李喆琛"></center><h4 id="王唯">王唯</h4><center><img src="/img/2018-biyezhao/34.jpg?imageMogr2/auto-orient" width="600" alt="王唯"></center><h4 id="王伟程">王伟程</h4><center><img src="/img/2018-biyezhao/35.jpg?imageMogr2/auto-orient" width="600" alt="王伟程"></center><h3 id="邱季端北合影">邱季端北合影</h3><blockquote><p>这里必须恭喜一下lzc同学C位出道.</p></blockquote><h4 id="带奖杯版本">带奖杯版本</h4><ul><li>唯神和鑫神有点gay（<center><img src="/img/2018-biyezhao/36.jpg?imageMogr2/auto-orient" width="600" alt="信科14黄金一代在邱季端的合影-1"></center></li><li>果然分开就没那么gay了.<center><img src="/img/2018-biyezhao/37.jpg?imageMogr2/auto-orient" width="600" alt="信科14黄金一代在邱季端的合影-2"></center></li></ul><h4 id="无奖杯版本">无奖杯版本</h4><ul><li>唯神又和王队有点gay!<center><img src="/img/2018-biyezhao/40.JPG?imageMogr2/auto-orient" width="600" alt="信科14黄金一代在邱季端的合影-3"></center></li><li>分开之后果然没那么gay了.<center><img src="/img/2018-biyezhao/41.JPG?imageMogr2/auto-orient" width="600" alt="信科14黄金一代在邱季端的合影-4"></center></li><li>鑫神-唯神-王队! 唯神选择了和鑫神gay.<center><img src="/img/2018-biyezhao/42.JPG?imageMogr2/auto-orient" width="600" alt="信科14黄金一代在邱季端的合影-5"></center></li></ul><h3 id="在篮球场的合影">在篮球场的合影</h3><h4 id="站版本">站版本</h4><ul><li>分的比较开, 显得略有零散.<center><img src="/img/2018-biyezhao/43.JPG?imageMogr2/auto-orient" width="600" alt="信科14黄金一代在篮球场的合影-1"></center></li><li>站成一团果然紧凑多了. 重要的是这次一点也不gay?<center><img src="/img/2018-biyezhao/44.JPG?imageMogr2/auto-orient" width="600" alt="信科14黄金一代在篮球场的合影-2"></center></li></ul><h4 id="坐版本">坐版本</h4><blockquote><p>有点……喜感?</p></blockquote><ul><li>大家一起抬头看狂, 侯老大不禁感叹: 篮筐像大海一样广阔.<center><img src="/img/2018-biyezhao/45.JPG?imageMogr2/auto-orient" width="600" alt="信科14黄金一代在篮球场的合影-1 坐着有点奇怪"></center></li><li>大家都转过来了, 好像有一丢丢不对称?<center><img src="/img/2018-biyezhao/47.JPG?imageMogr2/auto-orient" width="600" alt="信科14黄金一代在篮球场的合影-2 转过来有点逗"></center></li><li>大家忽然又转过去了? 诶, 等等我…<center><img src="/img/2018-biyezhao/46.JPG?imageMogr2/auto-orient" width="600" alt="信科14黄金一代在篮球场的合影-3 只有我一个人转过来就更加蠢.."></center></li></ul><h3 id="与师弟们的合影">与师弟们的合影</h3><blockquote><p>这是将荣誉和使命交给师弟们（严肃点不许笑）</p></blockquote><ul><li>恭喜李家和小同学C位出道.<center><img src="/img/2018-biyezhao/38.jpg?imageMogr2/auto-orient" width="600" alt="信科14黄金一代+17师弟在邱季端的合影-1"></center></li><li>这个角度有点刁, 后排都被挡了一半脸.<center><img src="/img/2018-biyezhao/39.jpg?imageMogr2/auto-orient" width="600" alt="信科14黄金一代+17师弟在邱季端的合影-2"></center></li></ul><h2 id="各种旧相识">各种旧相识</h2><h3 id="年同校的妹子">16年同校的妹子</h3><blockquote><p>小学 + 初中 + 高中 + 大学 = 16年同校. Orz. 可惜研究生不能继续同校了_(:з」∠)_</p></blockquote><ul><li>第一张很正常对吧.<center><img src="/img/2018-biyezhao/24.jpg?imageMogr2/auto-orient" width="600" alt="赵元鼎-1"></center></li><li>但是好像难逃两张照片必有一张表情蠢的魔咒?<center><img src="/img/2018-biyezhao/23.jpg?imageMogr2/auto-orient" width="600" alt="赵元鼎-2"></center></li></ul><h3 id="师大唯一高中同班同学">师大唯一高中同班同学</h3><blockquote><p>这个身高在我们寝室也是准前三水平 —— 大概就是吓坏我室友的水平.</p></blockquote><ul><li>感谢路人赠送的蜜汁气球.<center><img src="/img/2018-biyezhao/21.jpg?imageMogr2/auto-orient" width="600" alt="郭嘉宝-1"></center></li><li>我这个表情好像有点蠢.<center><img src="/img/2018-biyezhao/22.jpg?imageMogr2/auto-orient" width="600" alt="郭嘉宝-2"></center></li></ul><h3 id="小学课外班相识的鸡哥">小学课外班相识的鸡哥</h3><blockquote><p>按次序应当是师大第二个和我认识的人. 妹子也是高中同学Orz<br>（同志, 你听说过学霸情侣么? ）</p></blockquote><center><img src="/img/2018-biyezhao/27.jpg?imageMogr2/auto-orient" width="600" alt="与鸡哥的合影"></center><center><img src="/img/2018-biyezhao/28.jpg?imageMogr2/auto-orient" width="600" alt="与鸡哥+铭轩的合影"></center><h3 id="乒乓球师兄">“乒乓球师兄”</h3><blockquote><p>在师兄离校前夕和丁丁约到了师兄打球, 幸运地碰到了屈老师. Orz.</p></blockquote><ul><li>师兄的身高是我和丁丁的等差中项.<center><img src="/img/2018-biyezhao/25.jpg?imageMogr2/auto-orient" width="600" alt="与丁丁+张玉潇师兄的合影"></center></li><li>希望我像屈老师这个年龄也能身体这么好Orz.<center><img src="/img/2018-biyezhao/26.jpg?imageMogr2/auto-orient" width="600" alt="与丁丁+屈国峰老师的合影"></center></li></ul><h3 id="牛b的想爷">牛b的想爷</h3><blockquote><p>想爷太强了, 只有Orz.</p></blockquote><center><img src="/img/2018-biyezhao/29.jpg?imageMogr2/auto-orient" width="600" alt="与想爷的合影"></center><h3 id="一起打铁的兄弟">一起打铁的兄弟</h3><blockquote><p>四年前一起打铁, 四年后一起合影. Orz一下优秀的前队友们.</p></blockquote><center><img src="/img/2018-biyezhao/30.jpg?imageMogr2/auto-orient" width="600" alt="新生队：许宏旭+曾耀辉+李喆琛"></center>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 毕业 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>保研二三事</title>
      <link href="/2018/07/28/%E4%BF%9D%E7%A0%94%E5%A4%8F%E4%BB%A4%E8%90%A5%E4%BA%8C%E4%B8%89%E4%BA%8B/"/>
      <content type="html"><![CDATA[<p>只是随便写写3月份以来的各种经历. 按时间顺序是北大数科, 软件所, 北大信科.</p><a id="more"></a><h2 id="第一站北大数科">第一站：北大数科</h2><blockquote><p>只是大概谈一下过程吧.</p></blockquote><h3 id="接到通知">接到通知</h3><ul><li>按照飞机童鞋的说法, 考试时间应在4月10日前后, 但实际上的考试时间是在3.31, 略有意外. 经查, 去年的考试时间好像是4.8.</li><li>通知链接: <a href="http://www.math.pku.edu.cn/zygg/68832.htm" target="_blank" rel="noopener">直博生摸底考试通知</a></li></ul><h3 id="初审及考试">初审及考试</h3><h4 id="初审">初审</h4><ul><li>3.23前后接到初审通过的短信, 北大的考试在师大设有考点.</li><li>在北大官网也出了通知: <a href="http://www.math.pku.edu.cn/zygg/68833.htm" target="_blank" rel="noopener">直博生摸底考试初审结果通知</a></li><li>初审要求感觉非常松, 有广撒网的意思.</li></ul><h4 id="考试">考试</h4><ul><li>考试时间是一上午, 北大派老师来监考, 之后会介绍北大的大概情况.</li><li>3.31 正式考试, 满分200分, 数分代数几何各占100, 70, 30.</li><li>我几何学的非常差, 尽管几何题看起来不是很难, 我仍然没有做出来. 并且对题目没有印象了.</li><li>数分题目思路清奇, 当然题目也很清奇…<ul><li>将一个五元店视作一个超市物品到 <span class="math inline">\(\mathbb{R}\)</span> 的函数, 该函数是否可微?</li><li>构造一个夹在 <span class="math inline">\(|x|\)</span> 与 <span class="math inline">\(|x|+1\)</span> 之间的严格下凸函数. 并证明.</li><li>好像有一个类似函数方程/微分方程的东西, 记不起来了.</li><li>题目不能全部记起Orz.</li></ul></li><li>代数题目总共有三道, 其中有30分很简单.<ul><li>30分超级简单的题目, 是一些求子空间交并和维数的题目, 其实就是矩阵瞎搞搞.</li><li>一个分块矩阵的题目, 很好玩, 可是不会做Orz.</li><li>还有一个记不得了.</li></ul></li></ul><h4 id="结果">结果</h4><ul><li>考完感觉一般般, 通过概率应该不大, 但还是和之前联系的xbc老师见了一面.</li><li>夏老师做的是符号计算, 具体来说是可满足性问题SAT/SMT. 夏老师最后表示我的背景适合学习他的方向, 若此次考试未能通过, 9月份可以继续联系.</li><li>我仔细了解了SAT/SMT问题以及夏老师所提及的Z3求解工具, 其实是很有意思的问题, 但是考试未能通过, 我也不可能把未来押到9月份, 故没有继续联系.</li><li>考试结果应该是一个月内就除了, 我只考了60+, 未能通过Orz. 太菜了. 当然就没有后续了.</li></ul><blockquote><p><strong>非常感谢复习期间飞机童鞋(张骏达)给我的一些帮助.</strong></p></blockquote><blockquote><p><strong>非常感谢xbc老师给我等菜鸡一个机会.</strong> 其实在北大信科夏令营之后仍然联系过, 在此不多讨论.</p></blockquote><blockquote><p>自此开始联系其他老师, 主要是yms老师和cyz老师.</p></blockquote><h3 id="后续的其他尝试">后续的其他尝试</h3><ul><li>按照时间顺序, 是cyz老师-&gt;yms老师.</li><li>我联系老师主要是看方向, 能看懂的话也可以找一篇论文看? 时间仓促, 我没怎么看懂二位的论文…</li><li>要想清楚找老师时要说些什么, 邮件和简历里面捡好听的写. 可以写专业课平均分90+, 但是公选课得61分什么的别写.</li><li>要有自信, 老师看不上自己的话别气馁(</li></ul><h4 id="cyz老师社会计算">cyz老师：社会计算</h4><ul><li>曹老师以前是师大数科的博士, 聊起来气氛大概也比较轻松愉快.</li><li>和老师聊天的内容不外乎几条:<ul><li>个人情况, 无须多讲.</li><li>老师情况, 也无须多讲.</li><li>方向细节, 曹老师有几个方向, 其中我兴趣高一点的是社会计算.</li><li>后续操作, 在曹老师的建议下, 开始参加曹老师的讨论班.</li></ul></li></ul><h4 id="yms老师量子计算">yms老师：量子计算</h4><ul><li>我最初联系yms老师是在清华网站上找的, 应老师回信中表示欢迎到软件所的办公室聊一聊.</li><li>最初以为应老师仍然在做逻辑等方向, 但应老师表示现在只做量子计算.</li><li>应老师本人非常随和, 我聊得还挺愉快的? (就是不知道应老师愉快不愉快Orz毕竟我太菜).</li><li>最后应老师表示虽然你成绩差, 但是你这个背景还算合适, 并且我也不是非常看重排名的老师, 所以你可以试试. 最后给了我两本书看.</li><li>接下来一段时间没有太多联系, 主要是在看应老师的书.<ul><li>最初看 Nielsen 的书, 结果有点看不进去, 可能是废话有点多.</li><li>之后开始读应老师自己写的 Foundations… 一书, 比较精炼, 有数学教材的味道. 从此就开始读这本书.</li></ul></li><li>对量子计算有一个大概了解后, 再次与应老师联系, 应老师表示做做习题发给他看.</li><li>大概做了第二章的大部分习题之后, 到了夏令营报名时间. 再次见到应老师就是夏令营了.</li></ul><h2 id="第二站科学院软件所">第二站：科学院软件所</h2><blockquote><p>按时间顺序, 这是我的第一个夏令营.</p></blockquote><h3 id="准备材料">准备材料</h3><ul><li>根据在官网上挂出的<a href="http://www.iscas.ac.cn/yjsjy2016/zsxx2016/201804/t20180428_5004800.html" target="_blank" rel="noopener">通知</a>, 需要准备如下材料:<ol type="1"><li>夏令营申请表, <font color="red">须签字</font>;</li><li>成绩单 + 排名证明; 这个吐槽一下, 学院开的貌似是所有成绩都算的那个排名.</li><li>英语水平证明材料; 四六级/TOEFL/IELTS/GRE 等.</li><li>论文/获奖证书等; 社会工作奖这样没有说服力的东西可以不要.</li><li>推免申请表, <font color="red">须签字</font>;</li></ol></li><li>同时须在其申请系统中报名, 详见具体通知.</li><li>其他几点:<ul><li>材料不需要寄送, 只需要在开营的时候带着就可以了.</li><li>成绩单在主楼可以打印.</li><li>需要盖章的地方找学院盖章即可, 我不记得软件所有没有要盖章的地方了.</li></ul></li></ul><h3 id="面试-笔试-只有一道题的考核.">面试? 笔试? 只有一道题的考核.</h3><ul><li>夏令营一共五天, 具体安排如下:<ul><li>D1: 白天报到, 晚上开营+班会. 班会按照姓氏拼音分组, 与师兄师姐交流夏令营相关的问题, 时长大约2h.</li><li>D2: 一个很长的报告+整整一下午的方向介绍, 晚上有鸟巢游览, 没有去.</li><li>D3: 上午仍然是实验室方向介绍, 下午组织考核. 中午吃完饭直接去找应老师, 下午三点就结束了. 也不知道应老师感觉如何.</li><li>D4: 按照安排应是一天考试, 但国重全看老师, 应老师表示不用过来. 自我介绍的slides其实白做了哈哈.</li><li>D5: 体检+退卡. 中午和郭犇吃饭, 偶遇应老师, 应老师给一篇文章读.</li></ul></li><li>在开营的前一两天, 国重的xmj老师电话联系我, 当时在图书馆的我有点emmm 受宠若惊.<ul><li>聊了一下方向, 表示了招收我的意向.</li><li>夏老师做的也是理论计算机, 似乎是复杂性理论和一些组合相关的东西. 曾经也是我非常想学的东西Orz.</li><li>夏老师非常热情, 问我是否联系过老师之类的问题, 我表示联系了yms老师, 场面一度有点尴尬…</li><li>我肥肠感谢夏老师的欣赏Orz. 了解了一下夏老师的研究, 非常佩服夏老师的学术水平.</li></ul></li><li>简单谈一下考核的事情:<ul><li>整体的考核流程应该是 D3下午笔试/机试 + D4全天继续考核, 包括面试.</li><li>国重的考核全听老师的意思, 比方说yms老师只考了我一个题目, 大概2-3h就结束了. D4我完全不用去, 自我介绍slides完全白做了.</li><li>好像应老师在与不在完全不是两种考核方式… 听说去年是四个数学题+一个算法题, 主要包括代数数分和概率论. 还有包括英文自我介绍在内的N对1面试.</li><li>今年应老师亲自面试我, 出了一个拓扑题目(敲黑板划重点, 拓扑! 我也很意外.) 证明Kuratowski十四集定理, 并在 <span class="math inline">\(\mathbb{E}^1\)</span> 中构造一个能生成14个集合的例子. 这是一个很有意思的题目, 据说在凯莱《一般拓扑学》中有此题目, 我没有读过该书.</li><li>考核之后应老师给我发了一封邮件, 然而我没有及时查看Orz… 最后一日在软件所用卡里剩下的钱请郭犇在软件所吃饭, 吃饭时偶遇应老师, 向我提及了邮件的事情, 表示让我发成绩单, 并且读一读论文, 有空时给他讲.</li><li>然而因为16-18日就是北大夏令营, 故论文只读了一小部分, 很惭愧…</li></ul></li><li>夏令营期间去自动化所找郭犇蹭饭, 偶然抓拍到nb的郭犇Orz. 话不多说, 先Orz为敬.<center><img src="/img/blog-graph/软件所夏令营-郭犇.jpg" width="400"></center></li></ul><h3 id="关于结果">关于结果</h3><ul><li>听说, 除国重外的实验室, 不会立刻知道结果.</li><li>国重应该全看老师, 但我最终没有全部完成yms老师的考核流程, 所以不太清楚.</li><li>软件所研究生部会给国重老师一个提供自己优秀营员名单的截止日期, 国重的老师须在截止日期之前提交自己的优秀营员名单.</li><li>软件所有一个人性化的双向选择机制, 优秀营员公布后不会直接分派名额. 应充分考虑和尝试后, 再决定是否最终来软件所. 故软件所会给优秀营员长约一个月的缓冲时间, 来尝试其他夏令营 &amp; 做最终决定.</li></ul><blockquote><p><strong>非常感谢yms老师给我的机会以及xmj老师对我的赏识, 虽然我最后浪费掉了这个机会Orz. 希望自己有朝一日能成为yms老师这样的大家.</strong></p></blockquote><blockquote><p><strong><font color="blue">非常感谢应老师的学生方望老哥</font>, 非常感谢. 非常感谢. 在我读应老师的书时给予了我非常大量, 真的是非常大量的帮助. 在下感激不尽.</strong></p></blockquote><blockquote><p><strong>同时也非常感谢国重的李页霆师兄在夏令营期间的照顾. 非常感谢.</strong></p></blockquote><h2 id="第三站北大信科">第三站：北大信科</h2><blockquote><p>按时间顺序, 这是我的最后一个夏令营. 当然 总共就俩.</p></blockquote><h3 id="准备材料-等待初审">准备材料 + 等待初审</h3><ul><li>北大在4月底挂出了夏令营的<a href="http://eecs.pku.edu.cn/personnel/YJS/RecruitStudents/6805.shtml" target="_blank" rel="noopener">通知</a>, 原定6.30出入营名单, 但种种原因导致推迟到了7.5前后. <em>(附: <a href="http://eecs.pku.edu.cn/personnel/YJS/RecruitStudents/6979.shtml" target="_blank" rel="noopener">北大信科参营通知</a>)</em></li><li>主要谈谈申请流程.<ul><li>首先是在网上填写申请材料.</li><li>按照通知, 还应准备如下材料:<ol type="1"><li>申请表, <font color="red">应该是要签字盖章</font>;</li><li>个人陈述, <font color="red">应该也要签字</font>;</li><li>推荐信, 博士需要找三个副教授以上的老师签推荐信, 我分别找了冯速, 何青, 以及李俊峰老师(此处按年龄排序哈哈哈), <font color="Red">需要骑缝处签字</font>;</li><li>成绩单 + 排名证明;</li><li>英语水平证明材料; 四六级/TOEFL/IELTS/GRE 等.</li><li>论文/获奖证书等. 社会工作奖这样没有说服力的东西可以不要.</li></ol></li><li><strong>所有材料需在指定日期前自己送/邮寄至北大.</strong></li></ul></li></ul><h3 id="机试-面试">机试 + 面试</h3><ul><li>夏令营时间是7.16-7.18, 活动大致安排如下:<ul><li>D1: 上午报到+下午讲座, 实验室方向介绍. 晚上机试热身赛, 各种IDE非常齐全, OpenJudge环境也相当不错.</li><li>D2: 上午讲座+下午座谈会. 上午讲座翘掉了, 座谈会就是和老师聊天. 理论和软工在一起, 满屋子全是软工. 晚上机试, 打得非常崩, 前几天敲了很多题但手还是很生&amp;复习方向有误…</li><li>D3: 按照安排上午8.30开始面试, 事实上理论组下午1.30开始. 和信安+图形学一起, 三个方向加起来才十个人… 面试发挥还凑合, 题目大都答得上来, 但是似乎老师们觉得我成绩一般… 虽然好像确实如此… 但我从不质疑自己的能力, 尽管机试打得非常崩. 晚些时候, 大概吃晚饭时, 最终得到了曹老师的口头承诺, 准备参加曹老师联系的暑期课程.</li></ul></li><li>北大的活动安排十分紧凑. 这里还是主要说说考核.<ul><li>机试热身赛据说是去年的题目, 不算难吧.. 随便写了写. 主要是测环境嘛.</li><li>OpenJudge环境很好, 比poj.org强百倍.<ul><li>支持 <code>#include &lt;bits/stdc++.h&gt;</code>;</li><li>支持 <code>C++11</code>;</li><li>没试过, 应该也支持 <code>rope</code> 吧?</li></ul></li><li>本地编译器非常齐全.<ul><li>按照习惯 我仍然用了 <code>Sublime</code>+命令行. 但是命令行好像有时会有一种奇怪的问题, 连接不上输入的接口.</li><li><code>Code::Blocks</code>, <code>Dec-C++</code> 好像都有. 正式赛用的是codeblocks.</li><li>总之环境很好, 各种环境不背锅. 完全是自己太菜.</li></ul></li><li>正式赛题目我觉得选的一般, 区分度不太好.<ul><li>长时间不摸键盘, 两个水题半个多小时才过, 并且还挂了几次.</li><li>一道线段树/树状数组求逆序, 按理来说是裸题, 可是怎么也写不上来… 完全没想过会考这种东西??? 打比赛的时候哥也是经常写线段树的人, 现在太菜了Orz</li><li>一道带权并查集, GGGGGGG. 复习的时候完全没想过会考带权的???</li><li>以上四个是中文题… 本菜鸡就这样, 中文题卡全场…</li><li>英文题几乎都没有细读, 看出来好像有一个搜索, 然而没怎么搞…</li><li>赛前主要是在补动态规划的内容… 没想到中文题一个也没有??? 太难过了. 复习方向完全偏离, 很难受.</li><li>打得实在太崩, 细节不想多谈.</li></ul></li><li>最后谈一下面试:<ul><li>一般是自己所报方向的老师主面, 我是比较幸运, 是曹老师主面.</li><li>不清楚自我介绍环节是否必须, 反正我没有自我介绍..</li><li>开头是念一段英文的论文, 并翻译. 文段不是很长, 生词也不会多, 就是典型的论文.</li><li>然后就聊一些专业课的内容.</li><li>之后是学习的一些情况, 在此期间被一些老师嫌弃成绩差Orz. 其实是很多公共课成绩差(</li><li>最后一个老师问了一个算法题, 比较简单.</li><li><strong>其实面试略有尴尬的原因, 就是机试打得太菜. 如果机试多过题, 面试会非常有底气.</strong></li></ul></li></ul></li><li>最终算是涉险过关. 开始参加xlr老师的暑期课程. 非常巧, xlr老师和cyz老师以前都是yms老师的学生.</li></ul><h3 id="关于结果-1">关于结果</h3><ul><li>今年出结果非常快, 面试当晚就有很多人得到了结果. 如果提前联系过老师, 可以直接询问.</li><li>官网挂通知是夏令营结束后的第二天 (周三面试完毕, 周五晚上挂通知).</li><li>由于今年硕士名额大幅减少, 很多方向竞争非常激烈.</li></ul><blockquote><p><strong>两波夏令营期间蹭了几顿饭, 感谢郭犇某天中午的收留. 非常感谢. 上课期间也蹭了几顿饭, 感谢曹老师的学生王海滨老哥以及郭晓熙老哥. 同样非常感谢.</strong></p></blockquote><blockquote><p><strong>也要感谢冯速, 何青, 李俊峰三位老师给我签推荐信.</strong></p></blockquote><blockquote><p><strong>当然也要感谢曹老师和夏老师. 课程非常有趣, 收获良多.</strong></p></blockquote><h2 id="夏令营事后">夏令营事后</h2><ul><li>北大官网出<a href="http://eecs.pku.edu.cn/personnel/YJS/RecruitStudents/7004.shtml" target="_blank" rel="noopener">优秀营员名单</a>后, 自然是与xbc老师, yms老师, 以及xmj老师发邮件联系, 告知三位老师自己大致定了北大信科的事情. 三位老师都很友好, 我非常感激三位老师的认可. 其实加上曹老师, 四位老师的方向我都很喜欢, 但已经定了曹老师这里, 不可得兼.</li><li>当然, 更要感谢曹老师的认可了Orz… 希望自己能真正做出自己的成果.</li></ul><h2 id="尾声">尾声</h2><p>2018.9.28 最终在学信网上填写了个人信息并进行了报名和确认. 保研之路终于算是走完了.</p><center><img src="/img/blog-graph/待录取通知.png" width="600"></center>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 计算机 </tag>
            
            <tag> 北大 </tag>
            
            <tag> 软件所 </tag>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>点估计——最大似然估计、最大后验概率估计和贝叶斯估计</title>
      <link href="/2018/07/26/%E7%82%B9%E4%BC%B0%E8%AE%A1%E2%80%94%E2%80%94%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1%E3%80%81%E6%9C%80%E5%A4%A7%E5%90%8E%E9%AA%8C%E4%BC%B0%E8%AE%A1%E5%92%8C%E8%B4%9D%E5%8F%B6%E6%96%AF%E4%BC%B0%E8%AE%A1/"/>
      <content type="html"><![CDATA[<p>在北大听xlr老师的《经济与计算》课程时有一个小问题没有搞明白, 课后花了一些时间, 算是复习了之前数理统计学的MLE, 顺便研究了一下MAP和Bayes估计.</p><blockquote><p>一枚硬币，掷14次，有10次正面向上. 请估计接下来两次都出现正面向上的概率. (如下图所示)</p></blockquote><center><img src="http://olgwnj89q.bkt.clouddn.com/xia_problem.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/quality/75%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="老师的slides截图"></center><a id="more"></a><h2 id="简短分析">简短分析</h2><ul><li>一些显而易见的信息：<ul><li><strong>参数</strong>: 题目中只有一个参数, 那就是单次实验中正面向上的概率 <span class="math inline">\(\theta\)</span>, 这个 <span class="math inline">\(\theta\)</span> 实际上是由硬币本身决定的.</li><li><strong>参数空间</strong>: 显然 <span class="math inline">\(\Theta=[0,1]\)</span>.</li><li><strong>样本空间</strong>: 显然 <span class="math inline">\(n\)</span> 次试验的样本空间为 <span class="math inline">\(\{H,T\}^n\)</span>, <span class="math inline">\(H\)</span> for head, <span class="math inline">\(T\)</span> for tail.</li></ul></li><li>题目所需要估计的值并不是 <span class="math inline">\(\theta\)</span> 的值, 而是 <span class="math inline">\(\theta^2\)</span> 的值. <strong><font color="red">请注意 <span class="math inline">\(\hat{\theta}^2\)</span> 未必会与 <span class="math inline">\(\hat{\theta^2}\)</span> 相等.</font></strong></li></ul><h2 id="最大似然估计">最大似然估计</h2><h3 id="题目的做法">题目的做法</h3><p>似然函数为: <span class="math display">\[L(\theta)=\mathbb{P}(D|p)=\binom{14}{4}\theta^{10}(1-\theta)^4.\]</span> 求其取最大值时 <span class="math inline">\(\theta\)</span> 的取值: <span class="math display">\[\theta_{MLE}=\arg\max_\theta\{L(\theta)\}=\frac{5}{7}.\]</span> 与老师slides中的结果相吻合.</p><h3 id="一般情形">一般情形</h3><p>一般情况下, 选取的样本 <span class="math inline">\(x_1,\cdots,x_n\)</span> 都是i.i.d.样本, 于是似然函数只需要将其密度函数乘起来: <span class="math display">\[L(x_1,\cdots,x_n|\theta)=\prod_{i=1}^nf(x_i|\theta)\]</span> 然后求 <span class="math inline">\(\theta\)</span>, s.t. <span class="math inline">\(L(x_1,\cdots,x_n|\theta)\)</span> 取最大即可, 一般只需解方程 <span class="math display">\[\frac{\partial L}{\partial \theta}=0\]</span> 有些情况下求对数似然函数 <span class="math inline">\(l(x_1,\cdots,x_n|\theta)=\ln L(x_1,\cdots,x_n|\theta)\)</span> 的最大值计算起来更方便, 如正态分布.<br>维基百科上有详细讨论, 此处略去细节.</p><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1" target="_blank" rel="noopener">维基百科：最大似然估计</a><br><a href="https://en.wikipedia.org/wiki/Maximum_likelihood_estimation" target="_blank" rel="noopener">Wiki: Maximum likelihood estimation</a></p></blockquote><h2 id="最大后验概率估计">最大后验概率估计</h2><h3 id="题目的做法-1">题目的做法</h3><ul><li>此处假设的先验分布是 <span class="math inline">\(\theta\sim U(0,1)\)</span>.<ul><li>分布函数CDF: <span class="math inline">\(F(x)=x\)</span>;</li><li>密度函数PDF: <span class="math inline">\(f(x)=1\)</span>.</li></ul></li></ul><p>由Bayes公式, 可得后验概率为：<span class="math display">\[\begin{align}\mathbb{P}(\theta|D)&amp;=\frac{\mathbb{P}(D|\theta)\mathbb{P}(\theta)}{\mathbb{P}(D)} \\&amp;= \frac{\binom{14}{4}\theta^{10}(1-\theta)^4\cdot f(\theta)}{\int_0^1\binom{14}{4}\theta^{10}(1-\theta)^4{\rm d}F(\theta)} \\&amp;= \frac{\theta^{10}(1-\theta)^4}{\int_0^1\theta^{10}(1-\theta)^4}.\end{align}\]</span> 最大化这个概率, 可得MAP对 <span class="math inline">\(\theta\)</span> 的估计值为: <span class="math display">\[\begin{align}\theta_{MAP}&amp;=\arg\max_\theta\{\mathbb{P}(\theta|D)\}\\&amp;=\arg\max_\theta\{\theta^{10}(1-\theta)^4\}\\&amp;=\frac{5}{7}\end{align}.\]</span></p><p>实际上MAP的结果在 <span class="math inline">\(\theta\sim U(0,1)\)</span> 时与MLE没有任何区别.</p><h3 id="一般情形-1">一般情形</h3><ul><li>已知先验分布, 及其CDF <span class="math inline">\(F(x)\)</span> 和PDF <span class="math inline">\(f(x)\)</span>.</li><li>在做实验得到数据 <span class="math inline">\(D\)</span> 后, 利用MAP估计 <span class="math inline">\(\theta\)</span> 的值.</li></ul><p>由Bayes公式有: <span class="math display">\[\mathbb{P}(\theta|D)=\frac{\mathbb{P}(D|\theta)\mathbb{P}(\theta)}{\mathbb{P}(D)}\]</span> 逐项计算等号右边各项:</p><ul><li><span class="math inline">\(\mathbb{P}(D|\theta)\)</span> 为: 单次实验结果为 <span class="math inline">\(H\)</span> 的概率, 直接用概率论/组合数学/统计学知识计算即可.</li><li><span class="math inline">\(\mathbb{P}(\theta)\)</span> 为: <span class="math inline">\(\theta\)</span> 的先验概率, 即先验分布的PDF <span class="math inline">\(f(\theta)\)</span>.</li><li><span class="math inline">\(\mathbb{P}(D)\)</span> 为: 样本空间中出现 <span class="math inline">\(D\)</span> 的总概率, 等于后验概率 <span class="math inline">\(\mathbb{P}(D|\theta)\)</span> 对 <span class="math inline">\(\theta\)</span> 的分布积分, 即 <span class="math display">\[\mathbb{P}(D)=\int_\theta \mathbb{P}(D|\theta)~{\rm d}F(\theta)\]</span></li></ul><p>简单整理一下, 可得: <span class="math display">\[\mathbb{P}(\theta|D)=\frac{\mathbb{P}(D|\theta)f(\theta)}{\int_\theta \mathbb{P}(D|\theta)~{\rm d}F(\theta)}\]</span> 事实上, <span class="math inline">\(\theta\)</span> 对于 <span class="math inline">\(D\)</span> 的后验分布其实就是 <span class="math inline">\(\theta\)</span> 对 <span class="math inline">\(D\)</span> 的条件分布.<br>得到上式之后, 求使得该式最大的 <span class="math inline">\(\theta\)</span> 即可. 由于分母是一个常数, 故: <span class="math display">\[\theta_{MAP}=\arg\max_\theta\{\mathbb{P}(D|\theta)f(\theta)\}.\]</span> 容易看出, 当 <span class="math inline">\(\theta\sim U(0,1)\)</span> 时, 因 <span class="math inline">\(f(\theta)=1\)</span> 有 <span class="math inline">\(\theta_{MAP}=\theta_{MLE}\)</span>. 但一般情况下二者并不相等.</p><h2 id="贝叶斯估计">贝叶斯估计</h2><h3 id="题目的做法-2">题目的做法</h3><ul><li>此处假设的先验分布是 <span class="math inline">\(\theta\sim U(0,1)\)</span>.<ul><li>分布函数CDF: <span class="math inline">\(F(x)=x\)</span>;</li><li>密度函数PDF: <span class="math inline">\(f(x)=1\)</span>.</li></ul></li></ul><p>由Bayes公式, 可得后验概率为：<span class="math display">\[\begin{align}\mathbb{P}(\theta|D)&amp;=\frac{\mathbb{P}(D|\theta)\mathbb{P}(\theta)}{\mathbb{P}(D)} \\&amp;= \frac{\binom{14}{4}\theta^{10}(1-\theta)^4\cdot f(\theta)}{\int_0^1\binom{14}{4}\theta^{10}(1-\theta)^4{\rm d}F(\theta)} \\&amp;= \frac{\theta^{10}(1-\theta)^4}{\int_0^1\theta^{10}(1-\theta)^4}.\end{align}\]</span> <span class="math inline">\(\theta\)</span> 的Bayes估计值即为后验概率的期望: <span class="math display">\[\begin{align}\hat{\theta}=\mathbb{E}(\theta|D)&amp;= \int_0^1\theta~\mathbb{P}(\theta|D){\rm d}\theta \\&amp;= \int_0^1\frac{\theta^{11}(1-\theta)^4{\rm d}\theta}{\int_0^1\theta^{10}(1-\theta)^4}=\frac{11}{16}.\end{align}\]</span> 题目中要求估计两次正面向上, 就是要估计 <span class="math inline">\(\theta^2\)</span>: <span class="math display">\[\begin{align}\hat{\theta^2}=\mathbb{E}(\theta|D)&amp;= \int_0^1\theta^2~\mathbb{P}(\theta|D){\rm d}\theta \\&amp;= \int_0^1\frac{\theta^{13}(1-\theta)^4{\rm d}\theta}{\int_0^1\theta^{10}(1-\theta)^4} \\ &amp;= \frac{33}{68}\approx 0.485.\end{align}\]</span> 这个答案恰好和老师的slides中给出的答案相符. 同时也作为一个例子说明了 <span class="math inline">\(\hat{\theta^2}\neq\hat{\theta}^2\)</span>.</p><h3 id="一般情形-2">一般情形</h3><ul><li>已知先验分布, 及其CDF <span class="math inline">\(F(x)\)</span> 和PDF <span class="math inline">\(f(x)\)</span>.</li><li>在做实验得到数据 <span class="math inline">\(D\)</span> 后, 利用Bayes估计来估计 <span class="math inline">\(\theta\)</span> 的值.</li></ul><p>Bayes估计的估计值实际上是参数 <span class="math inline">\(\theta\)</span> 关于试验数据 <span class="math inline">\(D\)</span> 的条件期望: <span class="math display">\[\hat{\theta}=\mathbb{E}(\theta|D)\]</span> 条件分布的密度函数与MAP中得到的相同: <span class="math display">\[\mathbb{P}(\theta|D)=\frac{\mathbb{P}(D|\theta)f(\theta)}{\int_\theta \mathbb{P}(D|\theta)~{\rm d}F(\theta)}\]</span> 得到上式之后, 积分求期望即可. 即: <span class="math display">\[\begin{align}\hat{\theta}&amp;=\mathbb{E}(\theta|D) \\&amp;= \int_\theta \mathbb{P}(D|\theta)\theta{\rm d}\theta \\&amp;= \frac{\int_\theta \mathbb{P}(D|\theta)f(\theta)\theta~{\rm d}\theta}{\int_\theta \mathbb{P}(D|\theta)~{\rm d}F(\theta)}.\end{align}\]</span></p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 北大 </tag>
            
            <tag> 概率论 </tag>
            
            <tag> 统计学 </tag>
            
            <tag> 经济学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法拾遗[5]——Java大数</title>
      <link href="/2018/07/17/%E7%AE%97%E6%B3%95%E6%8B%BE%E9%81%97-5-%E2%80%94%E2%80%94Java%E5%A4%A7%E6%95%B0/"/>
      <content type="html"><![CDATA[<p>比较重要的几条是:</p><ul><li><code>add, subtract, multiply, divide, mod, remainder</code> 加减乘除取模取余<font color="red">—注意取模中 <span class="math inline">\(b\)</span> 必须为正!</font></li><li><code>a.compareTo(b)</code> <span class="math inline">\(a=b\)</span> 返回 <span class="math inline">\(0\)</span>, 否则返回 <span class="math inline">\(a&gt;b\)</span> 的值.</li><li><code>a.toString(b)</code> 将 <span class="math inline">\(a\)</span> 转换为 <span class="math inline">\(b\)</span> 进制字符串.</li></ul><p>另外注意 <code>Scanner</code> 的写法:</p><ul><li>输入接口: <code>Scanner cin = new Scanner(System.in);</code></li><li>EOF写法: <code>while(cin.hasNext()) {}</code></li><li>输入:<code>BigInteger a = cin.nextBigInteger();</code></li></ul><p>以及变量的声明(注意 <code>new</code>):</p><ul><li>单个变量: <code>BigInteger a = new BigInteger(&quot;0&quot;);</code></li><li>声明数组: <code>BigInteger a[] = new BigInteger[size];</code></li><li>静态方法: <code>BigInteger a = BigInteger.valueOf(x);</code></li></ul><a id="more"></a><p>完整版本如下:</p><blockquote><p>来源: https://blog.csdn.net/qq644262163/article/details/53116713</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;  </span><br><span class="line"><span class="keyword">import</span> java.math.*;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读到EOF</span></span><br><span class="line">        <span class="keyword">while</span>(cin.hasNext())&#123;&#125;</span><br><span class="line">        <span class="comment">// 读入BigInteger</span></span><br><span class="line">        BigInteger a = cin.nextBigInteger();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 赋值</span></span><br><span class="line">        <span class="comment">// 将十进制字符串转化为BigInteger</span></span><br><span class="line">        <span class="comment">// public BigInteger(String val)</span></span><br><span class="line">        BigInteger a = <span class="keyword">new</span> BigInteger(<span class="string">"3"</span>);</span><br><span class="line">        <span class="comment">// 将radix进制的字符串转化为BigInteger</span></span><br><span class="line">        <span class="comment">// public BigInteger(String val, int radix)</span></span><br><span class="line">        BigInteger a = <span class="keyword">new</span> BigInteger(<span class="string">"3"</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 将整数赋给BigInteger</span></span><br><span class="line">        BigInteger a = BigInteger.valueOf(<span class="number">100</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 常量</span></span><br><span class="line">        a = BigInteger.ZERO;</span><br><span class="line">        a = BigInteger.ONE;</span><br><span class="line">        a = BigInteger.TEN;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 值等于val的值</span></span><br><span class="line">        <span class="comment">// public static BigInteger valueOf(long val)</span></span><br><span class="line">        BigInteger.valueOf(<span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        a.add(b);</span><br><span class="line">        a.subtract(b);</span><br><span class="line">        a.multiply(b);</span><br><span class="line">        a.divide(b);</span><br><span class="line">        <span class="comment">// 取模a%b b需大于0 5mod3=2 -5mod3=1</span></span><br><span class="line">        a.mod(b);</span><br><span class="line">        <span class="comment">// 求余 5rem3=2 -5rem3=-2 5rem-3=2 -5rem-3=-2</span></span><br><span class="line">        <span class="comment">// public BigInteger remainder(BigInteger val)</span></span><br><span class="line">        a.remainder(b);</span><br><span class="line">        <span class="comment">// [0]为a/b [1]为a%b</span></span><br><span class="line">        <span class="comment">// public BigInteger[] divideAndRemainder(BigInteger val)</span></span><br><span class="line">        a.divideAndRemainder(b);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// a==b?</span></span><br><span class="line">        <span class="comment">// public boolean equals(Object x)</span></span><br><span class="line">        a.equals(b);</span><br><span class="line">        <span class="comment">// a的正负 正为1 0为0 负为-1</span></span><br><span class="line">        <span class="comment">// public int signum()</span></span><br><span class="line">        a.signum();</span><br><span class="line">        <span class="comment">// 绝对值|a|</span></span><br><span class="line">        <span class="comment">// public BigInteger abs()</span></span><br><span class="line">        a.abs();</span><br><span class="line">        <span class="comment">// 比较a&gt;b返回1 a==b返回0 a&lt;b返回-1</span></span><br><span class="line">        <span class="comment">// public BigInteger andNot(BigInteger val)</span></span><br><span class="line">        a.compareTo(b);</span><br><span class="line">        <span class="comment">// 相反数-a</span></span><br><span class="line">        <span class="comment">// public BigInteger negate()</span></span><br><span class="line">        a.negate();</span><br><span class="line">        <span class="comment">// max(a,b)</span></span><br><span class="line">        <span class="comment">// public BigInteger max(BigInteger val)</span></span><br><span class="line">        a.max(b);</span><br><span class="line">        <span class="comment">// min(a,b)</span></span><br><span class="line">        <span class="comment">// public BigInteger min(BigInteger val)</span></span><br><span class="line">        a.min(b);</span><br><span class="line">        <span class="comment">// 乘方</span></span><br><span class="line">        <span class="comment">// public BigInteger pow(int exponent)</span></span><br><span class="line">        a.pow(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// a模b的逆元</span></span><br><span class="line">        <span class="comment">// public BigInteger modInverse(BigInteger m)</span></span><br><span class="line">        a.modInverse(b);</span><br><span class="line">        <span class="comment">// 乘方取模 a^b%c</span></span><br><span class="line">        <span class="comment">// public BigInteger modPow(BigInteger exponent,BigInteger m)</span></span><br><span class="line">        a.modPow(b, c);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 位运算</span></span><br><span class="line">        <span class="comment">// ~a</span></span><br><span class="line">        <span class="comment">// public BigInteger not()</span></span><br><span class="line">        a.not();</span><br><span class="line">        <span class="comment">// a^b</span></span><br><span class="line">        <span class="comment">// public BigInteger xor(BigInteger val)</span></span><br><span class="line">        a.xor(b);</span><br><span class="line">        <span class="comment">// a|b</span></span><br><span class="line">        <span class="comment">// public BigInteger or(BigInteger val)</span></span><br><span class="line">        a.or(b);</span><br><span class="line">        <span class="comment">// a&amp;b</span></span><br><span class="line">        <span class="comment">// public BigInteger divide(BigInteger val)</span></span><br><span class="line">        a.and(b);</span><br><span class="line">        <span class="comment">// a左移n位 (a &lt;&lt; n)</span></span><br><span class="line">        <span class="comment">// public BigInteger shiftLeft(int n)</span></span><br><span class="line">        a.shiftLeft(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// a右移n位 (a &gt;&gt; n)</span></span><br><span class="line">        <span class="comment">// public BigInteger shiftRight(int n)</span></span><br><span class="line">        a.shiftRight(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// a&amp;(~b)</span></span><br><span class="line">        <span class="comment">// public BigInteger andNot(BigInteger val)</span></span><br><span class="line">        a.andNot(b);</span><br><span class="line">        <span class="comment">// 二进制形式中把第n位二进制设为0 (a &amp; ~(1&lt;&lt;n))</span></span><br><span class="line">        <span class="comment">// public BigInteger clearBit(int n)</span></span><br><span class="line">        a.clearBit(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 二进制形式中把第n位二进制设为1 (a | (1&lt;&lt;n))</span></span><br><span class="line">        <span class="comment">// public BigInteger setBit(int n)</span></span><br><span class="line">        a.setBit(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 二进制形式中第n位二进制是否为1 (a &amp; (1&lt;&lt;n)) != 0)</span></span><br><span class="line">        <span class="comment">// public boolean testBit(int n)</span></span><br><span class="line">        a.testBit(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 二进制形式中把第n位二进制翻转 (a ^ (1&lt;&lt;n))</span></span><br><span class="line">        <span class="comment">// public BigInteger flipBit(int n)</span></span><br><span class="line">        a.flipBit(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 二进制形式中最低位1后面0的个数 (a == 0? -1 : log2(a &amp; -a))</span></span><br><span class="line">        <span class="comment">// public int getLowestSetBit()</span></span><br><span class="line">        a.getLowestSetBit();</span><br><span class="line">        <span class="comment">// 二进制形式中与符号不同的位的数量 7为3 -7为2</span></span><br><span class="line">        <span class="comment">// public int bitCount()</span></span><br><span class="line">        a.bitCount();</span><br><span class="line">        <span class="comment">// 二进制形式中不包括符号位的长度</span></span><br><span class="line">        <span class="comment">// public int bitLength()</span></span><br><span class="line">        a.bitLength();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// a和b的最大公约数</span></span><br><span class="line">        <span class="comment">// public BigInteger gcd(BigInteger val)</span></span><br><span class="line">        a.gcd(b);</span><br><span class="line">        <span class="comment">// a可能为素数返回true a一定为合数返回false 素数可能性大于(1-1/(2的certainty次方))</span></span><br><span class="line">        <span class="comment">// public boolean isProbablePrime(int certainty)</span></span><br><span class="line">        a.isProbablePrime(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 大于a的可能为素数的第一个整数。</span></span><br><span class="line">        <span class="comment">// public BigInteger nextProbablePrime()</span></span><br><span class="line">        a.nextProbablePrime();</span><br><span class="line">        <span class="comment">// a的哈希码</span></span><br><span class="line">        <span class="comment">// public int hashCode()</span></span><br><span class="line">        a.hashCode();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// a的二进制补码形式</span></span><br><span class="line">        <span class="comment">// public byte[] toByteArray()</span></span><br><span class="line">        a.toByteArray();</span><br><span class="line">        <span class="comment">// a的十进制字符串形式</span></span><br><span class="line">        <span class="comment">// public String toString()</span></span><br><span class="line">        a.toString();</span><br><span class="line">        <span class="comment">// a的radix进制字符串形式</span></span><br><span class="line">        <span class="comment">// public String toString(int radix)</span></span><br><span class="line">        a.toString(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 将a转换为int</span></span><br><span class="line">        <span class="comment">// public int intValue()</span></span><br><span class="line">        a.intValue();</span><br><span class="line">        <span class="comment">// 将a转换为long</span></span><br><span class="line">        <span class="comment">// public long longValue()</span></span><br><span class="line">        a.longValue();</span><br><span class="line">        <span class="comment">// 将a转换为float</span></span><br><span class="line">        <span class="comment">// public float floatValue()</span></span><br><span class="line">        a.floatValue();</span><br><span class="line">        <span class="comment">// 将a转换为double</span></span><br><span class="line">        <span class="comment">// public double doubleValue()</span></span><br><span class="line">        a.doubleValue();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JAVA 1.8</span></span><br><span class="line">        a.byteValueExact();</span><br><span class="line">        a.intValueExact();</span><br><span class="line">        a.longValueExact();</span><br><span class="line">        a.shortValueExact();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从类 java.lang.Number 继承的方法</span></span><br><span class="line">        <span class="comment">// 将a转换为short</span></span><br><span class="line">        <span class="comment">// public short shortValue()</span></span><br><span class="line">        a.shortValue();</span><br><span class="line">        <span class="comment">// 将a转换为byte</span></span><br><span class="line">        <span class="comment">// public byte byteValue()</span></span><br><span class="line">        a.byteValue();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从类 java.lang.Object 继承的方法</span></span><br><span class="line">        <span class="comment">// public final Class&lt;?&gt; getClass()</span></span><br><span class="line">        a.getClass();</span><br><span class="line">        <span class="comment">// public final void notify()</span></span><br><span class="line">        a.notify();</span><br><span class="line">        <span class="comment">// public final void notifyAll()</span></span><br><span class="line">        a.notifyAll();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// public final void wait() throws InterruptedException</span></span><br><span class="line">            a.wait();</span><br><span class="line">            <span class="comment">// public final void wait(long timeout) throws InterruptedException</span></span><br><span class="line">            a.wait(<span class="number">10</span>);</span><br><span class="line">            <span class="comment">// public final void wait(long timeout, int nanos) throws InterruptedException</span></span><br><span class="line">            a.wait(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 保研复习 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法拾遗[4]——STL用法</title>
      <link href="/2018/07/17/%E7%AE%97%E6%B3%95%E6%8B%BE%E9%81%97-4-%E2%80%94%E2%80%94STL%E7%94%A8%E6%B3%95/"/>
      <content type="html"><![CDATA[<p>主要bb一下优先队列和字符串吧. 哦还有 <code>bitset</code>.</p><a id="more"></a><h2 id="优先队列">优先队列</h2><ul><li>定义很容易: <code>priority_queue&lt;int&gt; pq;</code></li><li>内部是一个堆.</li></ul><h3 id="基本操作">基本操作</h3><ul><li><code>pq.top()</code> 取堆顶元素; (没有 <code>front()</code> 方法!)</li><li><code>pq.push(x)</code> 插入;</li><li><code>pq.pop()</code> 删除(删除堆顶);</li><li><code>pq.empty()</code> 判断是否为空.</li></ul><h3 id="自定义优先级">自定义优先级</h3><ul><li>最大堆: <code>priority_queue&lt;int&gt; pq;</code></li><li>最小堆: <code>priority_queue&lt; int, vector&lt;int&gt;, greater&lt;int&gt; &gt; pq;</code></li><li>事实上还有自定义优先级 <code>cmp</code> 的方法(优先级最大的最先出队): <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">// a优先级较小时返回true.</span></span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, cmp&gt; pq; <span class="comment">// 此时也是最小堆</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="例题">例题</h4><ul><li>百练 4078: http://bailian.openjudge.cn/practice/4078/</li></ul><h2 id="字符串">字符串</h2><p>定义更容易: <code>string s;</code></p><h3 id="基本操作-1">基本操作</h3><ul><li><code>s.size()</code> 串长度(下标从0 开始)；</li><li><code>s.substr(a, n)</code> 构造子串, a为第一个字符的下标, n为子串字符长度;</li><li><code>s'find(it1, it2, x)</code> 在指针 <code>it1</code> 和 <code>it2</code> 中间查找字符 <code>x</code>; (<code>s.find(x)</code> 为整个 <code>s</code> 中查找 <code>x</code>)</li><li><code>s.erase(a)</code> 删除元素, a貌似是指针, 可以和 <code>find</code> 合用去除指定字符, 如 <code>s.erase(std::find(s.begin(), s.end(), ' '));</code> 去掉所有空格;</li><li><code>s.empty()</code> 判断是否为空;</li><li>支持 <code>push_back</code> 和 <code>pop_back</code>;<br></li><li>支持 <code>+</code>, <code>=</code> 和 <code>==</code> 运算.</li></ul><h3 id="遍历操作">遍历操作</h3><ul><li>可以用 <code>auto it = s.begin(); it != s.end(); it++</code> 遍历;</li><li>但我一般都用 <code>int i = 0; i &lt; s.size(); i++</code> 遍历.</li></ul><h3 id="和数字的转换">和数字的转换</h3><h4 id="字符串转数字">字符串转数字</h4><ul><li><code>stoi</code>, <code>stol</code>, <code>stoll</code>: 字符串转整数;</li><li><code>stof</code>, <code>stod</code>, <code>stold</code>: 字符串转浮点数;</li></ul><h4 id="数字转字符串">数字转字符串</h4><ul><li><code>to_string</code> 直接转成 <code>std::string</code>.</li></ul><h2 id="位向量">位向量</h2><p>定义: <code>bitset&lt;length&gt; b(value);</code></p><h3 id="基本操作-2">基本操作</h3><ul><li>支持位运算 <code>&amp;</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>等;</li><li><code>to_string()</code> 转化为字符串;</li><li><code>to_ulong()</code>, <code>to_ullong()</code> 转化为无符号整数;</li><li><code>flip(i)</code> 第i位取反, 下标从0开始. <code>flip()</code> 全部按位取反.</li></ul>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 保研复习 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法拾遗[3]——图论算法</title>
      <link href="/2018/07/16/%E7%AE%97%E6%B3%95%E6%8B%BE%E9%81%97-3-%E2%80%94%E2%80%94%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/"/>
      <content type="html"><![CDATA[<p>夏令营复习算法, 感到自己对之前学过的算法略有生疏, 写篇流水账, 权当复习.</p><ul><li>并查集</li><li>Dijkstra 算法</li><li>Floyd 算法</li><li>Kruskal 算法</li></ul><a id="more"></a><h2 id="并查集">并查集</h2><p>处理连通关系的一种手段.</p><h3 id="查询所属连通分支">查询所属连通分支</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fa[i] 表示i 所属的连通分支的代表元</span></span><br><span class="line"><span class="comment">// rnk[j] 表示j 号连通分支的结点个数, 注意这里的j 必须是所取的代表元(根结点)</span></span><br><span class="line"><span class="comment">// 使用前注意fa[] 的初始化, rnk[] 初始为1.</span></span><br><span class="line"><span class="keyword">int</span> fa[maxn], rnk[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] == <span class="number">-1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fa[x] = Find(fa[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并操作">合并操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t1 = Find(x);</span><br><span class="line">    <span class="keyword">int</span> t2 = Find(y);</span><br><span class="line">    <span class="keyword">if</span>(t1 != t2)</span><br><span class="line">    &#123;</span><br><span class="line">        fa[t1] = t2;</span><br><span class="line">        rnk[t2] += rnk[t1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dijkstra-算法">Dijkstra 算法</h2><p>单源最短路, 适用于权值非负的图.</p><h3 id="实现代码">实现代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// g 需要初始化, 下标从0 开始.</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre[maxn], d[maxn];</span><br><span class="line"><span class="keyword">int</span> g[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> g[][maxn], <span class="keyword">int</span> d[], <span class="keyword">int</span> n, <span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pre[i] = <span class="number">-1</span>;</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">        d[i] = inf;</span><br><span class="line">    &#125;</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">-1</span>, Min = inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (!vis[i] &amp;&amp; d[i] &lt; Min)</span><br><span class="line">            &#123;</span><br><span class="line">                Min = d[i];</span><br><span class="line">                k = i;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        vis[k] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (!vis[i] &amp;&amp; d[k] + g[k][i] &lt; d[i])</span><br><span class="line">            &#123;</span><br><span class="line">                d[i] = d[k] + g[k][i];</span><br><span class="line">                pre[i] = k;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hdu-2544-最短路">HDU 2544: 最短路</h3><h4 id="problem-description">Problem Description</h4><p>在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？</p><h4 id="input">Input</h4><p>输入包括多组数据。每组数据第一行是两个整数N、M（N&lt;=100，M&lt;=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1&lt;=A,B&lt;=N,1&lt;=C&lt;=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。 输入保证至少存在1条商店到赛场的路线。</p><h4 id="output">Output</h4><p>对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间</p><h4 id="sample-input">Sample Input</h4><p>2 1<br>1 2 3<br>3 3<br>1 2 5<br>2 3 5<br>3 1 2<br>0 0</p><h4 id="sample-output">Sample Output</h4><p>3<br>2</p><h4 id="大致思路">大致思路</h4><p>注意题目中下标从 1 开始.</p><h4 id="ac代码">AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre[maxn], d[maxn];</span><br><span class="line"><span class="keyword">int</span> g[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> g[][maxn], <span class="keyword">int</span> d[], <span class="keyword">int</span> n, <span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pre[i] = <span class="number">-1</span>;</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">        d[i] = inf;</span><br><span class="line">    &#125;</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">-1</span>, Min = inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (!vis[i] &amp;&amp; d[i] &lt; Min)</span><br><span class="line">            &#123;</span><br><span class="line">                Min = d[i];</span><br><span class="line">                k = i;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        vis[k] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (!vis[i] &amp;&amp; d[k] + g[k][i] &lt; d[i])</span><br><span class="line">            &#123;</span><br><span class="line">                d[i] = d[k] + g[k][i];</span><br><span class="line">                pre[i] = k;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                g[i][j] = (i == j) ? <span class="number">0</span> : inf;</span><br><span class="line">        <span class="keyword">while</span> (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v, w;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">            g[u - <span class="number">1</span>][v - <span class="number">1</span>] = g[v - <span class="number">1</span>][u - <span class="number">1</span>] = w;</span><br><span class="line">        &#125;</span><br><span class="line">        Dijkstra(g, d, n, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; d[n - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="floyd-算法">Floyd 算法</h2><p>我所知道的唯一的全源最短路. 复杂度略高, 约 <span class="math inline">\(O(n^3)\)</span>. 可以视为动态规划. 简单好写.</p><h3 id="实现代码-1">实现代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化仍然是i == j时d[i][j]为0, 其余为inf.</span></span><br><span class="line"><span class="comment">// 注意下标从0 开始, 以及k-&gt; i-&gt; j 的顺序.</span></span><br><span class="line"><span class="comment">// 想压行可以把最后的if 写成min.</span></span><br><span class="line"><span class="keyword">int</span> d[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) <span class="comment">// 一定要注意第一层是k</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (d[i][k] + d[k][j] &lt; d[i][j])</span><br><span class="line">                    d[i][j] = d[i][k] + d[k][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hdu-2544-最短路-1">HDU 2544: 最短路</h3><h4 id="problem-description-1">Problem Description</h4><p>在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？</p><h4 id="input-1">Input</h4><p>输入包括多组数据。每组数据第一行是两个整数N、M（N&lt;=100，M&lt;=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1&lt;=A,B&lt;=N,1&lt;=C&lt;=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。 输入保证至少存在1条商店到赛场的路线。</p><h4 id="output-1">Output</h4><p>对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间</p><h4 id="sample-input-1">Sample Input</h4><p>2 1<br>1 2 3<br>3 3<br>1 2 5<br>2 3 5<br>3 1 2<br>0 0</p><h4 id="sample-output-1">Sample Output</h4><p>3<br>2</p><h4 id="大致思路-1">大致思路</h4><p>还是这道裸题…除了注意题目中下标从 1 开始我都不知道还有什么可说的.</p><h4 id="ac代码-1">AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (d[i][k] + d[k][j] &lt; d[i][j])</span><br><span class="line">                    d[i][j] = d[i][k] + d[k][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> d[i][j] = inf;</span><br><span class="line">        <span class="keyword">while</span> (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b, c;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            d[a - <span class="number">1</span>][b - <span class="number">1</span>] = d[b - <span class="number">1</span>][a - <span class="number">1</span>] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        floyd(n);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; d[<span class="number">0</span>][n - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="kruskal-算法">Kruskal 算法</h2><p>所有边排序, 逐条加边, 用并查集判连通, 求最小生成树.</p><h3 id="实现代码-2">实现代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并查集初始化为-1, 不需要在main函数里单独初始化</span></span><br><span class="line"><span class="comment">// tol 需要在main里单独初始化为0</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    Edge()&#123;&#125;</span><br><span class="line">    Edge(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c): u(a), v(b), w(c)&#123;&#125;</span><br><span class="line">&#125; e[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tol; <span class="comment">// 存总边数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[tol++] = Edge(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span> <span class="comment">// 按权值排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[maxn]; <span class="comment">// 并查集</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x] == <span class="number">-1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fa[x] = Find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(fa, <span class="number">-1</span>, <span class="keyword">sizeof</span>(fa));</span><br><span class="line">    sort(e, e + tol, cmp);</span><br><span class="line">    int cnt(0), res(0);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tol; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = e[i].u;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">int</span> w = e[i].w;</span><br><span class="line">        <span class="keyword">int</span> t1 = Find(u);</span><br><span class="line">        <span class="keyword">int</span> t2 = Find(v);</span><br><span class="line">        <span class="keyword">if</span> (t1 != t2)</span><br><span class="line">        &#123;</span><br><span class="line">            fa[t1] = t2;</span><br><span class="line">            res += w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 不连通</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> res; <span class="comment">// 连通返回最小生成树权值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hdu-1863-畅通工程">HDU 1863: 畅通工程</h3><h4 id="problem-description-2">Problem Description</h4><p>省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可）。经过调查评估，得到的统计表中列出了有可能建设公路的若干条道路的成本。现请你编写程序，计算出全省畅通需要的最低成本。</p><h4 id="input-2">Input</h4><p>测试输入包含若干测试用例。每个测试用例的第1行给出评估的道路条数 N、村庄数目M ( &lt; 100 )；随后的 N 行对应村庄间道路的成本，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间道路的成本（也是正整数）。为简单起见，村庄从1到M编号。当N为0时，全部输入结束，相应的结果不要输出。</p><h4 id="output-2">Output</h4><p>对每个测试用例，在1行里输出全省畅通需要的最低成本。若统计数据不足以保证畅通，则输出“?”。</p><h4 id="sample-input-2">Sample Input</h4><p>3 3<br>1 2 1<br>1 3 2<br>2 3 4<br>1 3<br>2 3 2<br>0 100</p><h4 id="sample-output-2">Sample Output</h4><p>3<br>?</p><h4 id="大致思路-2">大致思路</h4><p>裸题, 没什么好说的, 一定要注意 <code>tol</code> 的初始化.</p><h4 id="ac代码-2">AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    Edge() &#123;&#125;</span><br><span class="line">    Edge(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c): u(a), v(b), w(c) &#123;&#125;</span><br><span class="line">&#125; e[maxn]; <span class="comment">// 一般情况下完全可以考虑用 vector 存边</span></span><br><span class="line"><span class="keyword">int</span> tol;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[tol++] = Edge(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (fa[x] != x)</span><br><span class="line">        x = fa[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">// 需要注意下标是从0还是1开始</span></span><br><span class="line">        fa[i] = i;</span><br><span class="line">    sort(e, e + tol, cmp);</span><br><span class="line">    int cnt(0), res(0);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tol; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = e[i].u;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">int</span> w = e[i].w;</span><br><span class="line">        <span class="keyword">int</span> t1 = Find(u);</span><br><span class="line">        <span class="keyword">int</span> t2 = Find(v);</span><br><span class="line">        <span class="keyword">if</span> (t1 != t2)</span><br><span class="line">        &#123;</span><br><span class="line">            fa[t1] = t2;</span><br><span class="line">            res += w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        tol = <span class="number">0</span>; <span class="comment">// 初始化!!!</span></span><br><span class="line">        <span class="keyword">while</span> (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v, w;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">            addedge(u, v, w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Kruskal(n);</span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"?\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 计算机 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 保研复习 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法拾遗[2]——数论算法</title>
      <link href="/2018/07/15/%E7%AE%97%E6%B3%95%E6%8B%BE%E9%81%97-2-%E2%80%94%E2%80%94%E6%95%B0%E8%AE%BA%E7%AE%97%E6%B3%95/"/>
      <content type="html"><![CDATA[<p>夏令营复习算法, 感到自己对之前学过的算法略有生疏, 写篇流水账, 权当复习.</p><ul><li>素数筛法</li><li>快速幂取模</li><li>扩展欧几里得/求逆元</li></ul><a id="more"></a><h2 id="素数筛法">素数筛法</h2><p>一种用已知的小素数 <span class="math inline">\(p\)</span> 来筛掉更大的合数, 最终留下素数的算法. 实践复杂度 <span class="math inline">\(O(n\log\log n)\)</span>.</p><h3 id="实现代码-1-打标记">实现代码 1: 打标记</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> notprime[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(notprime, <span class="literal">false</span>, <span class="keyword">sizeof</span>(notprime));</span><br><span class="line">    notprime[<span class="number">0</span>] = notprime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!notprime[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; maxn / i) <span class="keyword">continue</span>; <span class="comment">// 防止i * i 溢出</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i * i; j &lt; maxn; j += i)</span><br><span class="line">                notprime[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现代码-2-直接存素数">实现代码 2: 直接存素数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPrime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(prime, <span class="number">0</span>, <span class="keyword">sizeof</span>(prime));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!prime[i]) prime[++prime[<span class="number">0</span>]] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= prime[<span class="number">0</span>] &amp;&amp; prime[j] &lt;= maxn / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            prime[prime[j] * i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上也可以先打标记, 再 <code>for</code> 一遍把素数拿出来.</p><h3 id="百练-3177-判决素数个数">百练 3177: 判决素数个数</h3><p>总时间限制: 1000ms 内存限制: 65536kB</p><h4 id="描述">描述</h4><p>输入两个整数X和Y，输出两者之间的素数个数（包括X和Y）。</p><h4 id="输入">输入</h4><p>两个整数X和Y（1 &lt;= X,Y &lt;= 105）。</p><h4 id="输出">输出</h4><p>输出一个整数，表示X，Y之间的素数个数（包括X和Y）。</p><h4 id="样例输入">样例输入</h4><p>1 100</p><h4 id="样例输出">样例输出</h4><p>25</p><h4 id="大致思路">大致思路</h4><p>有个坑点… 题目没有保证 <span class="math inline">\(x\leqslant y\)</span>.. 所以需要 <code>swap</code> 一下.</p><h4 id="ac代码">AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> notprime[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(notprime, <span class="literal">false</span>, <span class="keyword">sizeof</span>(notprime));</span><br><span class="line">    notprime[<span class="number">0</span>] = notprime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!notprime[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; maxn / i) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i * i; j &lt; maxn; j += i)</span><br><span class="line">                notprime[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; y) swap(x, y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= y; i++)</span><br><span class="line">            <span class="keyword">if</span>(!notprime[i]) ans++;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展欧几里得算法">扩展欧几里得算法</h2><p>求解 <span class="math inline">\(ax+by=d\)</span> 中的 <span class="math inline">\(x, y\)</span>, 其中 <span class="math inline">\(\gcd(a, b)~|~d\)</span> 才有解.</p><h3 id="实现代码">实现代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回d = gcd(a, b); 和对应于等式ax + by = d 中的x, y</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">extend_gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">long</span> <span class="keyword">long</span> &amp;x, <span class="keyword">long</span> <span class="keyword">long</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 无最大公约数</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> d = extend_gcd(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速幂取模">快速幂取模</h2><p>在 <span class="math inline">\(O(\log n)\)</span> 时间内求 <span class="math inline">\(a^n~\%m\)</span> 的值.</p><h3 id="实现代码-1">实现代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">pow_mod</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)</span><br><span class="line">            ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求逆元">求逆元</h2><p>求 <span class="math inline">\(x\)</span>, s.t. <span class="math inline">\(ax=1~({\rm mod}~m)\)</span>.</p><h3 id="实现代码-1-利用扩展欧几里得">实现代码 1: 利用扩展欧几里得</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ax = 1 (mod n)</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">mod_reverse</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x, y;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> d = extend_gcd(a, n, x, y);</span><br><span class="line">    <span class="keyword">if</span> (d == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> (x % n + n) % n;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现代码-2-利用费马小定理">实现代码 2: 利用费马小定理</h3><p>由于模数 <span class="math inline">\(m\)</span> 一般为素数, 当 <span class="math inline">\((a,m)=1\)</span> 时, 由费马小定理有: <span class="math display">\[a^{m-1}=1~({\rm mod}~m)\Rightarrow a^{-1}=a^{m-2}.\]</span> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pow_mod(a, mod - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 计算机 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 保研复习 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法拾遗[1]——动态规划</title>
      <link href="/2018/07/14/%E7%AE%97%E6%B3%95%E6%8B%BE%E9%81%97-1-%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <content type="html"><![CDATA[<p>夏令营复习算法, 感到自己对之前学过的算法略有生疏, 写篇流水账, 权当复习.</p><ul><li>最长上升子序列</li><li>最长公共子序列</li><li>最大子段和与最大子矩阵</li><li>背包问题</li><li>合并石子/矩阵链乘</li><li>一些其他的题目</li></ul><a id="more"></a><h2 id="最长上升子序列">最长上升子序列</h2><p>简单来说, 是通过讨论原序列的当前位 <span class="math inline">\(a_i\)</span> 与子序列 <span class="math inline">\(b\)</span> 的末尾 <span class="math inline">\(b_{len-1}\)</span> 的大小关系进行递推/动态规划的一类问题. 具体思路暂不详述.</p><h3 id="实现代码">实现代码</h3><p>给定数组 <span class="math inline">\(a\)</span>, 求 <span class="math inline">\(a\)</span> 某一段 <span class="math inline">\(a[l, r]\)</span> 的LIS的代码如下:<br>不严格的情形有两处需要修改, 请仔细查看注释.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组int a[] 的下标从 0 ~ n-1, 函数可求解 [l, r] 闭区间的LIS长度.</span></span><br><span class="line"><span class="comment">// a[l, r] 的LIS存储在b[0, len-1] 中. 函数返回值为其元素个数.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lis</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    c[<span class="number">0</span>] = a[l];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; c[len]) <span class="comment">// 不严格递增情形改为&gt;=</span></span><br><span class="line">            c[++len] = a[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">// 不严格递增情形改为upper_bound()</span></span><br><span class="line">            <span class="keyword">int</span> pos = lower_bound(c, c + len, a[i]) - c;</span><br><span class="line">            c[pos] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len + <span class="number">1</span>; <span class="comment">// 下标从0 开始, 故需要+1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如需求解最长下降子序列, 一个偷懒的办法是将原数组逆序存储, 再求解其逆序的LIS.<br>同时也有 <code>lower_bound(c, c + len, a[i], greater&lt;int&gt;())</code> 的用法, 非常方便.</p><h3 id="百练-2945-拦截导弹">百练 2945: 拦截导弹</h3><p>总时间限制: 1000ms 内存限制: 65536kB</p><h4 id="描述">描述</h4><p>某国为了防御敌国的导弹袭击，开发出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭，并观测到导弹依次飞来的高度，请计算这套系统最多能拦截多少导弹。拦截来袭导弹时，必须按来袭导弹袭击的时间顺序，不允许先拦截后面的导弹，再拦截前面的导弹。</p><h4 id="输入">输入</h4><p>输入有两行，<br>第一行，输入雷达捕捉到的敌国导弹的数量k（k&lt;=25），<br>第二行，输入k个正整数，表示k枚导弹的高度，按来袭导弹的袭击时间顺序给出，以空格分隔。</p><h4 id="输出">输出</h4><p>输出只有一行，包含一个整数，表示最多能拦截多少枚导弹。</p><h4 id="样例输入">样例输入</h4><p>8<br>300 207 155 300 299 170 158 65</p><h4 id="样例输出">样例输出</h4><p>6</p><h4 id="思路">思路</h4><p>很裸, 直接做非严格最长下降子序列. 5min内不AC自觉面壁…</p><h4 id="ac代码">AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], c[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lis</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    c[<span class="number">0</span>] = a[l];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt;= c[len])</span><br><span class="line">            c[++len] = a[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = upper_bound(c, c + len, a[i], greater&lt;<span class="keyword">int</span>&gt;()) - c;</span><br><span class="line">            c[pos] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; lis(<span class="number">0</span>, n - <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="百练-2711-合唱队形">百练 2711: 合唱队形</h3><blockquote><p>题目链接: http://bailian.openjudge.cn/practice/2711/</p></blockquote><p>总时间限制: 1000ms 内存限制: 65536kB</p><h4 id="描述-1">描述</h4><p>N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学不交换位置就能排成合唱队形。 合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1, 2, …, K，他们的身高分别为T1, T2, …, TK，则他们的身高满足T1 &lt; T2 &lt; … &lt; Ti , Ti &gt; Ti+1 &gt; … &gt; TK (1 &lt;= i &lt;= K)。 你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。</p><h4 id="输入-1">输入</h4><p>输入的第一行是一个整数N（2 &lt;= N &lt;= 100），表示同学的总数。第一行有n个整数，用空格分隔，第i个整数Ti（130 &lt;= Ti &lt;= 230）是第i位同学的身高（厘米）。</p><h4 id="输出-1">输出</h4><p>输出包括一行，这一行只包含一个整数，就是最少需要几位同学出列。</p><h4 id="样例输入-1">样例输入</h4><p>8<br>186 186 150 200 160 130 197 220</p><h4 id="样例输出-1">样例输出</h4><p>4</p><h4 id="思路-1">思路</h4><p>枚举递增和递减中间分叉的位置（令其位于 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(a_{i+1}\)</span> 之间, 对 <span class="math inline">\(i\)</span> 做 <code>for</code> 循环）, 分别对两边做正序和逆序的LIS, 长度相加取最大, 最后再用 <span class="math inline">\(n\)</span> 减去即可.<br>注意一个<font color="red">特殊情况</font>, 就是前半段上升的最高点可能和后半段下降的最高点数值相等, 需要特判一下, 然后总长度-1.</p><h4 id="ac代码-1">AC代码</h4><p>特意用逆序来做的下降序列, 写的有一点丑, 不想细改了. 代码应该是没问题的.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组a[] 存储原数据, b[] 存储a 的逆序, 用两个函数分别求LIS.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], c[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lis</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    c[<span class="number">0</span>] = a[l];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; c[len])</span><br><span class="line">            c[++len] = a[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = lower_bound(c, c + len, a[i]) - c;</span><br><span class="line">            c[pos] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lis_reverse</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    c[<span class="number">0</span>] = b[l];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i] &gt; c[len])</span><br><span class="line">            c[++len] = b[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = lower_bound(c, c + len, b[i]) - c;</span><br><span class="line">            c[pos] = b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            b[i] = a[n - <span class="number">1</span> - i];</span><br><span class="line">        <span class="keyword">int</span> ans = max(lis(<span class="number">0</span>, n - <span class="number">1</span>), lis_reverse(<span class="number">0</span>, n - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = lis(<span class="number">0</span>, i);</span><br><span class="line">            <span class="keyword">int</span> tmpx = c[x - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> y = lis_reverse(<span class="number">0</span>, n - i - <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">int</span> tmpy = c[y - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(tmpx == tmpy) ans = max(ans, x + y - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> ans = max(ans, x + y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n - ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子序列">最长公共子序列</h2><h3 id="大致算法">大致算法</h3><p>记串 <span class="math inline">\(a\)</span> 和串 <span class="math inline">\(b\)</span> 的以 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 结尾的前缀分别为 <span class="math inline">\(A_i\)</span> 和 <span class="math inline">\(B_j\)</span>, 令 <span class="math inline">\(dp[i, j]\)</span> 表示 <span class="math inline">\(A_i\)</span> 与 <span class="math inline">\(B_j\)</span> 的LCS长度, 则有:</p><p><span class="math display">\[dp[i,j] = \begin{cases}0 &amp; i = 0~\text{or}~ j=0 \\dp[i-1,j-1]+1 &amp; i, j&gt;0,~a_i=b_j \\\max\{dp[i-1, j], dp[i, j-1]\} &amp; i, j&gt;0,~a_i\neq b_j\end{cases}\]</span></p><h3 id="实现代码-1">实现代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意下标, 从1 开始, 输入时也要注意.</span></span><br><span class="line"><span class="comment">// 答案为 dp[n][m].</span></span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">char</span> a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="poj-1458-common-subsequence">POJ 1458: Common Subsequence</h3><h4 id="description">Description</h4><p>A subsequence of a given sequence is the given sequence with some elements (possible none) left out. Given a sequence X = &lt; x1, x2, …, xm &gt; another sequence Z = &lt; z1, z2, …, zk &gt; is a subsequence of X if there exists a strictly increasing sequence &lt; i1, i2, …, ik &gt; of indices of X such that for all j = 1,2,…,k, xij = zj. For example, Z = &lt; a, b, f, c &gt; is a subsequence of X = &lt; a, b, c, f, b, c &gt; with index sequence &lt; 1, 2, 4, 6 &gt;. Given two sequences X and Y the problem is to find the length of the maximum-length common subsequence of X and Y.</p><h4 id="input">Input</h4><p>The program input is from the std input. Each data set in the input contains two strings representing the given sequences. The sequences are separated by any number of white spaces. The input data are correct.</p><h4 id="output">Output</h4><p>For each set of data the program prints on the standard output the length of the maximum-length common subsequence from the beginning of a separate line.</p><h4 id="sample-input">Sample Input</h4><p>abcfbc abfcab<br>programming contest<br>abcd mnp</p><h4 id="sample-output">Sample Output</h4><p>4<br>2<br>0</p><h4 id="ac代码-2">AC代码</h4><p>一定要注意输入和下标!!! <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt; // poj不支持这个头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">char</span> a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp)); <span class="comment">// 应该没必要全都初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, a + <span class="number">1</span>, b + <span class="number">1</span>) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">strlen</span>(a + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> m = <span class="built_in">strlen</span>(b + <span class="number">1</span>);</span><br><span class="line">        init(n, m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[n][m]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="最大子段和与最大子矩阵">最大子段和与最大子矩阵</h2><h3 id="最大子段和">最大子段和</h3><p>最大子段和问题：求解给定数组 <span class="math inline">\(a\)</span> 的所有子段中, 和最大的一个.<br>根据问题, 显然有如下的暴力方法:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定原数组int a[], 元素个数 n.</span></span><br><span class="line"><span class="keyword">int</span> ans = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++)</span><br><span class="line">        ans = max(ans, SUM(a[i]...a[j]));</span><br></pre></td></tr></table></figure></p><p>考虑上求和的 <span class="math inline">\(O(n)\)</span>, 该算法的复杂度为 <span class="math inline">\(O(n^3)\)</span>. 如果优化掉求和的 <span class="math inline">\(O(n)\)</span>, 可优化为 <span class="math inline">\(O(n^2)\)</span>, 具体优化不在此赘述, 毕竟优化完了也很慢…<br>如使用 <span class="math inline">\(dp[i]\)</span> 表示以第 <span class="math inline">\(i\)</span> 位结尾的最大子段和, 则可以使问题得到极大的简化: <span class="math display">\[dp[i]=\max(dp[i - 1] + a[i], a[i]),\]</span> <span class="math display">\[ans = \max\limits_{0\leqslant i\leqslant n-1}(dp[i]).\]</span> 根据该递推式很容易就可以写出如下代码: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定原数组int a[], 元素个数 n. 下标从0 开始.</span></span><br><span class="line"><span class="comment">// 中间变量int dp[], dp[i]表示以第i 位结尾的最大子段和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        dp[i] = max(dp[i - <span class="number">1</span>] + a[i], a[i]);</span><br><span class="line">    <span class="keyword">int</span> res = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        res = max(res, b[i]);</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>容易得出该算法的复杂度为 <span class="math inline">\(O(n)\)</span>. 是最快的求解算法.<br>同时不难想到, 最大子段和还有递归的求解方法, 时间复杂度为 <span class="math inline">\(O(n\log n)\)</span>, 不再赘述.</p><h3 id="最大子矩阵">最大子矩阵</h3><p>最大子段和的求解方式可直接应用于求解最大子矩阵问题:</p><ul><li>先将矩阵的行求和压缩: 对每行的第 <span class="math inline">\(i\)</span> 到第 <span class="math inline">\(j\)</span> 求和.</li><li>再对压缩后的 <span class="math inline">\(sum\)</span> 数组做最大子段和.</li><li>变换 <span class="math inline">\(i\)</span>, <span class="math inline">\(j\)</span>, 取最大值.</li></ul><p>求和数组 <span class="math inline">\(sum\)</span> 的转移方式也就是上文中暴力求最大子段和中求和时间的优化, 其实相当简单: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定原矩阵int a[][maxn], 行数m, 列数n. a[i][j] 表示第i 行第j 个, 下标从0 开始.</span></span><br><span class="line"><span class="comment">// 列和数组int sum[], sum[r] 表示第r 行的状态.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">// 枚举起点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; r++) <span class="comment">// 初始化</span></span><br><span class="line">        sum[r] = a[r][i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) <span class="comment">// 枚举终点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; r++) <span class="comment">// 更新每一行的和</span></span><br><span class="line">            sum[r] += a[r][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>显然我们只需要对每次处理好的 <span class="math inline">\(sum\)</span> 数组做最大子段和, 然后取最大值. 时间复杂度应为 <span class="math inline">\(O(n^3)\)</span>.<br>代码如下: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; n; r++)</span><br><span class="line">            sum[r] = a[r][i];</span><br><span class="line">        dp[<span class="number">0</span>] = sum[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">1</span>; r &lt; m; r++)</span><br><span class="line">            dp[r] = max(dp[r - <span class="number">1</span>] + sum[r], sum[r]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; r++)</span><br><span class="line">            res = max(res, dp[r]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; r++)</span><br><span class="line">                sum[r] += a[r][j];</span><br><span class="line">            dp[<span class="number">0</span>] = sum[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">1</span>; r &lt; m; r++)</span><br><span class="line">                dp[i] = max(dp[i - <span class="number">1</span>] + sum[i], sum[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; r++)</span><br><span class="line">                res = max(res, dp[r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>把最大子段和的函数封装一下可能会更好看, 我懒的搞…</p><h3 id="百练-2766-最大子矩阵">百练 2766: 最大子矩阵</h3><p>总时间限制: 1000ms 内存限制: 65536kB</p><h4 id="描述-2">描述</h4><p>已知矩阵的大小定义为矩阵中所有元素的和。给定一个矩阵，你的任务是找到最大的非空(大小至少是1 * 1)子矩阵。</p><p>比如，如下4 * 4的矩阵</p><p><span class="math display">\[\begin{bmatrix}0 &amp; -2 &amp; -7 &amp; 0 \\9 &amp; 2 &amp; -6 &amp; 2 \\-4 &amp; 1 &amp; -4 &amp; 1 \\-1 &amp; 8 &amp; 0 &amp; -2\end{bmatrix}\]</span></p><p>的最大子矩阵是</p><p><span class="math display">\[\begin{bmatrix}9 &amp; 2 \\-4 &amp; 1 \\-1 &amp; 8\end{bmatrix}\]</span></p><p>这个子矩阵的大小是15。</p><h4 id="输入-2">输入</h4><p>输入是一个N * N的矩阵。输入的第一行给出N (0 &lt; N &lt;= 100)。再后面的若干行中，依次（首先从左到右给出第一行的N个整数，再从左到右给出第二行的N个整数……）给出矩阵中的N2个整数，整数之间由空白字符分隔（空格或者空行）。已知矩阵中整数的范围都在[-127, 127]。</p><h4 id="输出-2">输出</h4><p>输出最大子矩阵的大小。</p><h4 id="样例输入-2">样例输入</h4><p>4<br>0 -2 -7 0 9 2 -6 2<br>-4 1 -4 1 -1</p><p>8 0 -2</p><h4 id="样例输出-2">样例输出</h4><p>15</p><h4 id="思路-2">思路</h4><p>有啥好说的么…很裸. 这题机试要是过不去的话我觉得我可以去死了..</p><h4 id="ac代码-3">AC代码</h4><p>懒, 用了 <code>cin</code>, <code>cout</code>. <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn], dp[maxn], sum[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; r++)</span><br><span class="line">            sum[r] = a[r][i];</span><br><span class="line">        dp[<span class="number">0</span>] = sum[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt; m; r++)</span><br><span class="line">            dp[r] = max(dp[r - <span class="number">1</span>] + sum[r], sum[r]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; r++)</span><br><span class="line">            res = max(res, dp[r]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; r++)</span><br><span class="line">                sum[r] += a[r][j];</span><br><span class="line">            dp[<span class="number">0</span>] = sum[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt; m; r++)</span><br><span class="line">                dp[r] = max(dp[r - <span class="number">1</span>] + sum[r], sum[r]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; r++)</span><br><span class="line">                res = max(res, dp[r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; solve(n, n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="背包相关问题">背包相关问题</h2><p>背包相关的问题的背景大都是往容量有限的背包中装一些给定的物品, 使得总价值尽可能大. 感觉机试中比较多的就是0-1背包.</p><h3 id="背包">0-1背包</h3><p>有 <span class="math inline">\(n\)</span> 件物品和一个容量为 <span class="math inline">\(V\)</span> 的背包. 放入第 <span class="math inline">\(i\)</span> 件物品耗费的费用是 <span class="math inline">\(c_i\)</span>, 得到的 价值是 <span class="math inline">\(w_i\)</span>. 求解将哪些物品装入背包可使价值总和最大.<br>实现代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// maxc 表示cost 最大值, maxn 表示n 最大值.</span></span><br><span class="line"><span class="comment">// dp[cost] 即为答案.</span></span><br><span class="line"><span class="keyword">int</span> n, cost;</span><br><span class="line"><span class="keyword">int</span> dp[maxc], c[maxn], w[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = cost; j &gt;= c[i]; j--)</span><br><span class="line">            dp[j] = max(dp[j], dp[j - c[i]] + w[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="百练-3714-点菜问题">百练 3714: 点菜问题</h3><blockquote><p>题目链接: http://bailian.openjudge.cn/practice/3714/</p></blockquote><p>总时间限制: 1000ms 内存限制: 65536kB</p><h4 id="描述-3">描述</h4><p>北大网络实验室经常有活动需要叫外买，但是每次叫外买的报销经费的总额最大为C元，有N种菜可以点 ，经过长时间的点菜，网络实验室对于每种菜i都有一个量化的评价分数（表示这个菜可口程度），为Vi，每种菜的价格为Pi, 问如何选择各种菜，使得在报销额度范围内能使点到的菜的总评价分数最大？ 注意：由于需要营养多样化，每种菜只能点一次。</p><h4 id="输入-3">输入</h4><p>输入的第一行有两个整数C（1 &lt;= C &lt;= 1000）和N（1 &lt;= N &lt;= 100），C代表总共能够报销的额度，N&gt;代表能点菜的数目。接下来的N行每行包括两个在1到100之间（包括1和100）的的整数，分别表示菜的&gt;价格和菜的评价分数。</p><h4 id="输出-3">输出</h4><p>输出只包括一行，这一行只包含一个整数，表示在报销额度范围内，所点的菜得到的最大评价分数。</p><h4 id="样例输入-3">样例输入</h4><p>90 4<br>20 25<br>30 20<br>40 50<br>10 18<br>40 2<br>25 30<br>10 8</p><h4 id="样例输出-3">样例输出</h4><p>95<br>38</p><h4 id="ac代码-4">AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxc = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, cost;</span><br><span class="line"><span class="keyword">int</span> dp[maxc], c[maxn], w[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = cost; j &gt;= c[i]; j--)</span><br><span class="line">            dp[j] = max(dp[j], dp[j - c[i]] + w[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; cost &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; c[i] &gt;&gt; w[i];</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[cost] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="百练-2773-采药">百练 2773: 采药</h3><p>总时间限制: 1000ms 内存限制: 65536kB</p><h4 id="描述-4">描述</h4><p>辰辰是个很有潜能、天资聪颖的孩子，他的梦想是称为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”</p><p>如果你是辰辰，你能完成这个任务吗？</p><h4 id="输入-4">输入</h4><p>输入的第一行有两个整数T（1 &lt;= T &lt;= 1000）和M（1 &lt;= M &lt;= 100），T代表总共能够用来采药的时间，M代表山洞里的草药的数目。接下来的M行每行包括两个在1到100之间（包括1和100）的的整数，分别表示采摘某株草药的时间和这株草药的价值。</p><h4 id="输出-4">输出</h4><p>输出只包括一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。</p><h4 id="样例输入-4">样例输入</h4><p>70 3<br>71 100<br>69 1<br>1 2</p><h4 id="样例输出-4">样例输出</h4><p>3</p><h4 id="ac代码-5">AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxc = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, cost;</span><br><span class="line"><span class="keyword">int</span> dp[maxc], weight[maxn], value[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = cost; c &gt;= weight[i]; c--)</span><br><span class="line">            dp[c] = max(dp[c], dp[c - weight[i]] + value[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; cost &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; weight[i] &gt;&gt; value[i];</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[cost] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并石子矩阵链乘">合并石子/矩阵链乘</h2><h3 id="algorithm.openjudge-合并石子">algorithm.openjudge 合并石子</h3><h4 id="描述-5">描述</h4><p>在一个操场上一排地摆放着Ｎ堆石子。现要将石子有次序地合并成一堆。规定每次只能选相邻的２堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的得分。 试设计一个程序，计算出将Ｎ堆石子合并成一堆的最小得分。</p><h4 id="输入-5">输入</h4><p>第一行为一个正整数<span class="math inline">\(N\)</span> <span class="math inline">\((2\leqslant N\leqslant 100)\)</span>； 以下Ｎ行,每行一个正整数，小于$10000，分别表示第 <span class="math inline">\(i\)</span> 堆石子的个数 <span class="math inline">\((1≤i≤N)\)</span>。 #### 输出 为一个正整数，即最小得分。 #### 样例输入 7 13 7 8 16 21 4 18 #### 样例输出 239</p><h2 id="最大上升子序列和">最大上升子序列和</h2><h3 id="牛客网-最大上升子序列和">牛客网: 最大上升子序列和</h3><blockquote><p>题目链接: https://www.nowcoder.com/practice/dcb97b18715141599b64dbdb8cdea3bd?tpId=40&amp;tqId=21409&amp;tPage=4&amp;rp=4&amp;ru=/ta/kaoyan&amp;qru=/ta/kaoyan/question-ranking</p></blockquote><h4 id="题目描述">题目描述</h4><p>一个数的序列bi，当b1 &lt; b2 &lt; … &lt; bS的时候，我们称这个序列是上升的。对于给定的一个序列(a1, a2, …,aN)，我们可以得到一些上升的子序列(ai1, ai2, …, aiK)，这里1 &lt;= i1 &lt; i2 &lt; … &lt; iK &lt;= N。比如，对于序列(1, 7, 3, 5, 9, 4, 8)，有它的一些上升子序列，如(1, 7), (3, 4, 8)等等。这些子序列中序列和最大为18，为子序列(1, 3, 5, 9)的和. 你的任务，就是对于给定的序列，求出最大上升子序列和。注意，最长的上升子序列的和不一定是最大的，比如序列(100, 1, 2, 3)的最大上升子序列和为100，而最长上升子序列为(1, 2, 3)。</p><h4 id="输入描述">输入描述</h4><p>输入包含多组测试数据。 每组测试数据由两行组成。第一行是序列的长度N (1 &lt;= N &lt;= 1000)。第二行给出序列中的N个整数，这些整数的取值范围都在0到10000（可能重复）。</p><h4 id="输出描述">输出描述</h4><p>对于每组测试数据，输出其最大上升子序列和。</p><h4 id="样例输入-5">样例输入</h4><p>7<br>1 7 3 5 9 4 8</p><h4 id="样例输出-5">样例输出</h4><p>18</p><h4 id="大致思路">大致思路</h4><p>仍然是经典的子段/子序列dp的思路, 设原数组为 <span class="math inline">\(a\)</span>, 记 <span class="math inline">\(dp[i]\)</span> 为以第 <span class="math inline">\(i\)</span> 位结尾的最大上升子序列和, 则考虑 <span class="math inline">\(i&lt;j\)</span>, 若 <span class="math inline">\(a[j] &lt; a[i]\)</span>, 则 <span class="math inline">\(a[i]\)</span> 接在以 <span class="math inline">\(a[j]\)</span> 结尾的最大和子序列后可以构成一个以 <span class="math inline">\(a[i]\)</span> 结尾的子序列, 可用该子序列的和去更新 <span class="math inline">\(dp[i]\)</span> 的值, 即: <span class="math display">\[dp[i] = \max \left( \max_{0&lt;j&lt;i\atop a[j]&lt;a[i]} ( dp[j]+a[i] ), a[i] \right).\]</span></p><h4 id="ac代码-6">AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn], dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[i])</span><br><span class="line">                dp[i] = max(dp[i], dp[j] + a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        res = max(res, dp[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; solve(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合数的递推">组合数的递推</h2><p>这是一个很蠢的东西, 勉强算作动态规划吧.. 但实际只应算作递推.</p><h3 id="原理">原理</h3><p>根本不用细说…就这一个式子, 叫做pascal公式. <span class="math display">\[\binom{n}{k}=\binom{n-1}{k}+\binom{n-1}{k-1}.\]</span></p><h3 id="实现代码-2">实现代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c[n][k] 表示n 中取k.</span></span><br><span class="line"><span class="keyword">int</span> c[<span class="number">205</span>][<span class="number">205</span>]; <span class="comment">// 这样的组合数已经大到天上了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getBinom</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">205</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; <span class="number">205</span>; j++)</span><br><span class="line">            c[j][i] = (c[j - <span class="number">1</span>][i] + c[j - <span class="number">1</span>][i - <span class="number">1</span>]) % mod;</span><br><span class="line">    &#125; <span class="comment">// 数字比较小的时候 大概30以下 可以不取模</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 计算机 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 保研复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学组合数学试卷</title>
      <link href="/2018/06/28/BNU-Combinatorics-Exam/"/>
      <content type="html"><![CDATA[<p>组合数学 期末 张秀平. <a id="more"></a></p><h2 id="试题">试题</h2><ol type="1"><li>在边长为 <span class="math inline">\(1\)</span> 的正方形中至少放入几个点, 才能保证至少有两点的距离不大于 <span class="math inline">\(\frac{1}{3}\)</span>?</li><li>化简组合恒等式 <span class="math display">\[\sum\limits_{k=0}^n \binom{\alpha+k}{p+k}\binom{p+k}{k}.\]</span></li><li>记初始排列为 <span class="math inline">\(1,2,\cdots,n\)</span>, 将其重排后为 <span class="math inline">\(a_1,\cdots,a_n\)</span>, s.t. <span class="math inline">\(a_{i+1}\neq a_i+1\)</span> <span class="math inline">\((i=1,2,\cdots,n-1)\)</span>, 令其方案数为 <span class="math inline">\(Q_n\)</span>:<ol type="1"><li>利用组合方法推导 <span class="math inline">\(Q_n\)</span> 的递推关系;</li><li>利用容斥原理推导 <span class="math inline">\(Q_n\)</span> 的递推关系.</li></ol></li><li>用延迟认可算法求下面优先矩阵的稳定完备婚姻匹配(男选女, 女选男各做一次), 并给出简单评价:</li></ol><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(a\)</span></th><th style="text-align: center;"><span class="math inline">\(b\)</span></th><th style="text-align: center;"><span class="math inline">\(c\)</span></th><th style="text-align: center;"><span class="math inline">\(d\)</span></th><th style="text-align: center;"><span class="math inline">\(e\)</span></th><th style="text-align: center;"><span class="math inline">\(f\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(A\)</span></td><td style="text-align: center;"><span class="math inline">\((1,4)\)</span></td><td style="text-align: center;"><span class="math inline">\((2,3)\)</span></td><td style="text-align: center;"><span class="math inline">\((3,6)\)</span></td><td style="text-align: center;"><span class="math inline">\((4,2)\)</span></td><td style="text-align: center;"><span class="math inline">\((5,5)\)</span></td><td style="text-align: center;"><span class="math inline">\((6,1)\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(B\)</span></td><td style="text-align: center;"><span class="math inline">\((3,1)\)</span></td><td style="text-align: center;"><span class="math inline">\((5,2)\)</span></td><td style="text-align: center;"><span class="math inline">\((6,5)\)</span></td><td style="text-align: center;"><span class="math inline">\((2,6)\)</span></td><td style="text-align: center;"><span class="math inline">\((1,3)\)</span></td><td style="text-align: center;"><span class="math inline">\((4,4)\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(C\)</span></td><td style="text-align: center;"><span class="math inline">\((5,5)\)</span></td><td style="text-align: center;"><span class="math inline">\((3,6)\)</span></td><td style="text-align: center;"><span class="math inline">\((6,1)\)</span></td><td style="text-align: center;"><span class="math inline">\((4,4)\)</span></td><td style="text-align: center;"><span class="math inline">\((2,2)\)</span></td><td style="text-align: center;"><span class="math inline">\((1,3)\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(D\)</span></td><td style="text-align: center;"><span class="math inline">\((6,6)\)</span></td><td style="text-align: center;"><span class="math inline">\((5,5)\)</span></td><td style="text-align: center;"><span class="math inline">\((4,4)\)</span></td><td style="text-align: center;"><span class="math inline">\((3,3)\)</span></td><td style="text-align: center;"><span class="math inline">\((2,1)\)</span></td><td style="text-align: center;"><span class="math inline">\((1,2)\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(E\)</span></td><td style="text-align: center;"><span class="math inline">\((1,3)\)</span></td><td style="text-align: center;"><span class="math inline">\((3,1)\)</span></td><td style="text-align: center;"><span class="math inline">\((5,2)\)</span></td><td style="text-align: center;"><span class="math inline">\((2,5)\)</span></td><td style="text-align: center;"><span class="math inline">\((4,4)\)</span></td><td style="text-align: center;"><span class="math inline">\((6,6)\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(F\)</span></td><td style="text-align: center;"><span class="math inline">\((4,2)\)</span></td><td style="text-align: center;"><span class="math inline">\((5,4)\)</span></td><td style="text-align: center;"><span class="math inline">\((6,3)\)</span></td><td style="text-align: center;"><span class="math inline">\((1,1)\)</span></td><td style="text-align: center;"><span class="math inline">\((2,6)\)</span></td><td style="text-align: center;"><span class="math inline">\((3,5)\)</span></td></tr></tbody></table><ol start="5" type="1"><li>设数列满足 <span class="math inline">\(\{f_n\}\)</span> 满足 <span class="math inline">\(f_0=1\)</span>, <span class="math inline">\(f_1=1\)</span>, <span class="math inline">\(f_n=f_{n-1}+f_{n-2}~(n\geqslant 2)\)</span>, 令 <span class="math inline">\(g_n=f_{2n}\)</span>, <span class="math inline">\(h_n=f_n^2\)</span>.<ol type="1"><li>分别求 <span class="math inline">\(f\)</span>, <span class="math inline">\(g\)</span>, <span class="math inline">\(h\)</span> 的通项公式;</li><li>求 <span class="math inline">\(g_n\)</span> 与 <span class="math inline">\(h_n\)</span> 的生成函数.</li></ol></li><li>构造一个指标为 <span class="math inline">\(1\)</span> 的 <span class="math inline">\(9\)</span> 元素 <span class="math inline">\(STS\)</span>, 判断它是否可解, 并给出理由.</li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 各种试卷 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>荒野行动回忆录</title>
      <link href="/2018/04/24/%E8%8D%92%E9%87%8E%E8%A1%8C%E5%8A%A8%E5%9B%9E%E5%BF%86%E5%BD%95/"/>
      <content type="html"><![CDATA[<blockquote><p>　　偶然在桌面的角落发现了许久没有打开的荒野行动, 随手打了一盘之后狠下心点了卸载. 游戏结束后看着空荡荡的在线好友列表, 不禁想起每天晚上十点准时吃鸡的日子.<br>　　竟有些怀念.</p></blockquote><a id="more"></a><h2 id="初识吃鸡">初识吃鸡</h2><blockquote><p>吃鸡全靠运气</p></blockquote><ul><li>最初开始玩荒野行动大致在2017.12-2018.01这段时间.</li><li>尽管以前玩过CS一类的FPS游戏, 在刚上手吃鸡时还是被打得找不着北.</li><li>第一次吃鸡是被翊坤和白傻舔空投带吃鸡的, 那时我还摸不清游戏的节奏.</li><li>慢慢摸清游戏节奏之后, 终于偶尔有了好的表现, 但大多数时间都是躺赢躺输.</li></ul><h2 id="成长之路">成长之路（×</h2><h3 id="秋田小队">秋田小队</h3><blockquote><p>这段时间可能是荒野行动在我们当中最火的时期.</p></blockquote><ul><li>时间长了, 我们渐渐形成了稳定的开黑车队: 我+贾鑫mvp+社会我丁哥+向思忆+猴子+曾邱. 因为大家开黑时都会穿游戏中的“秋田犬”时装, 故称为秋田小队.</li><li>秋田小队开黑的大部分时间是靠贾鑫mvp带飞的. 在此期间, 我从未在打出好数据的局中吃鸡. 这实际上意味着我虽然对游戏节奏有了更好的理解, 但仍然不能带队吃鸡.</li></ul><h3 id="假期开黑">假期开黑</h3><blockquote><p>终于有了自己对游戏节奏的理解.</p></blockquote><ul><li>随着时间的推移, 我找回了些许从前玩CS的感觉, 终于也能在吃鸡局中打出不俗的数据.<ul><li>正是此时有了第一次不坑的吃鸡: <img src="/img/youxi/第一次不坑吃鸡.jpg" width="600" alt="第一次不坑吃鸡"></li></ul></li><li>后来把兔子拉入了坑, 加上贾鑫mvp回家以后不能正常游戏, 秋田小队名存实亡. 此时的开黑车队变为了: 我+兔子+社会我丁哥+猴子.</li><li>从此开始了和兔子天天窝在309吃鸡的生活: 因为兔子不熟悉游戏, 打法以打野为主. 自此开发了右下角野区的“吃鸡路线”.<ul><li>第一次带兔子吃鸡: 完全是带兔子和社会我丁哥躺鸡, <del>两个人都是零输出有没有</del>. <img src="/img/youxi/第一次带兔子吃鸡.jpg" width="600" alt="第一次带兔子吃鸡"></li><li>第二次带兔子吃鸡: 这次是和猴子势力开黑吃鸡, <del>这人头都让猴子抢去了.</del> <img src="/img/youxi/第二次和兔子吃鸡.jpg" width="600" alt="第二次带兔子吃鸡"></li><li>和兔子吃5km毒的故事: 值得一提的一场比赛. 扛毒杀人，最为致命（没错，就是肉丁最看不起的圈内阴人）. 可惜一进圈就被阴Orz. <img src="/img/youxi/一场吃了5km毒.jpg" width="600" alt="一场吃了5km毒"></li></ul></li></ul><h2 id="日常吃鸡">日常吃鸡</h2><blockquote><p>这时对游戏节奏已经非常清楚, 几乎天天都能吃鸡. 以和社会我丁哥双排为主.</p></blockquote><ul><li><strong>值得纪念的是第一次带社会我丁哥双排吃鸡, 从此拉开了天天吃鸡的序幕.</strong></li></ul><p><img src="/img/youxi/第一次和社会我丁哥双排吃鸡.jpg" width="600" alt="第一次和社会我丁哥双排吃鸡"></p><p>一般吃鸡的情况有以下几种: 策略鸡, 刚枪鸡, 躺鸡. 其中以策略鸡最多.</p><h3 id="策略鸡">策略鸡</h3><blockquote><p>前期避战, 合理转移, 保存实力一波吃鸡的打法.</p></blockquote><p>经典战例如下:</p><h4 id="海上绕圈避战">海上绕圈避战</h4><ul><li>这盘装备一般, 但中期的时候, 观察到圈的特殊性, 直接找船绕了大半圈跑到无人地带, 最后决赛圈一波得手.</li></ul><p><img src="/img/youxi/开船绕大圈吃鸡.jpg" width="600" alt="海上绕圈避战"></p><h4 id="天命鸡">天命鸡</h4><ul><li>这一类很特别: 这一盘因为AI的存在, 数据看起来很像刚枪鸡. 但实际上就是在滨海镇蹲了20分钟杀了1w个AI舔了1w个空投决战圈刷在脸上刚一波成功吃鸡.</li></ul><p><img src="/img/youxi/AI-1.jpg" width="600" alt="天命鸡-1"></p><h4 id="其他策略鸡记录">其他策略鸡记录</h4><p><img src="/img/youxi/苟鸡-1.jpg" width="600" alt="策略鸡-1"> <img src="/img/youxi/苟鸡-2.jpg" width="600" alt="策略鸡-2"> <img src="/img/youxi/苟鸡-3.jpg" width="600" alt="策略鸡-3"> <img src="/img/youxi/苟鸡-4.jpg" width="600" alt="策略鸡-4"></p><h3 id="刚枪鸡">刚枪鸡</h3><blockquote><p>见人就锤, 来车就扫, 杀出一条血路吃鸡的打法.</p></blockquote><h4 id="伤害第一次破千">伤害第一次破千</h4><ul><li>这是一局值得纪念的比赛Orz. 毕竟比较菜…</li></ul><p><img src="/img/youxi/伤害第一次破千.jpg" width="600" alt="伤害第一次破千"></p><h4 id="其他刚枪鸡记录">其他刚枪鸡记录</h4><ul><li>都算是打架比较多的局.</li></ul><p><img src="/img/youxi/刚鸡-1.jpg" width="600" alt="刚枪鸡-1"> <img src="/img/youxi/刚鸡-2.jpg" width="600" alt="刚枪鸡-2"></p><h3 id="躺鸡">躺鸡</h3><blockquote><p>搜完房区, 一路无人, 莫名其妙也能吃鸡的打法.</p></blockquote><h4 id="ai鸡">AI鸡</h4><ul><li>躺鸡也有一种AI的情况, 就是杀了几个AI然后没打架就吃鸡. 看数据很容易与策略鸡混淆.</li></ul><p><img src="/img/youxi/躺鸡-1.jpg" width="600" alt="AI鸡-1"></p><h4 id="其他躺鸡记录">其他躺鸡记录</h4><ul><li>可以看得出, 都很躺.</li></ul><p><img src="/img/youxi/躺鸡-2.jpg" width="600" alt="躺鸡-2"> <img src="/img/youxi/躺鸡-3.jpg" width="600" alt="躺鸡-3"> <img src="/img/youxi/躺鸡-4.jpg" width="600" alt="躺鸡-4"></p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
            <tag> 荒野行动 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>图说农药</title>
      <link href="/2018/04/18/%E5%86%9C%E8%8D%AF%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95/"/>
      <content type="html"><![CDATA[<p>时间过得真快, 不知不觉农药已经玩了快一年了. 翻相册时无意翻到了这些图片, 决定开坑保存一下.</p><blockquote><p>只是一个无聊透顶的记录…</p></blockquote><a id="more"></a><h2 id="排位足迹">排位足迹</h2><table><tr><th>S7 赛季</th><th>S8 赛季</th><th>S9 赛季</th></tr><tr><td><img src="/img/youxi/wzry/赛季_S7.jpg" width="400" alt="赛季_S7"></td><td><img src="/img/youxi/wzry/赛季_S8.jpg" width="400" alt="赛季_S8"></td><td><img src="/img/youxi/wzry/赛季_S9.jpg" width="400" alt="赛季_S9"></td></tr><tr><th>S10 赛季</th><th>S11 赛季</th><th>S12 赛季</th></tr><tr><td><img src="/img/youxi/wzry/赛季_S10.jpg" width="400" alt="赛季_S10"></td><td><img src="/img/youxi/wzry/赛季_S11.jpg" width="400" alt="赛季_S11"></td><td><img src="/img/youxi/wzry/赛季_S12.jpg" width="400" alt="赛季_S12"></td></tr><tr><th>S13 赛季</th><th>S14 赛季</th><th>S15 赛季</th></tr><tr><td><img src="/img/youxi/wzry/赛季_S13.jpg" width="400" alt="赛季_S13"></td><td><img src="/img/youxi/wzry/赛季_S14.jpg" width="400" alt="赛季_S14"></td><td><img src="/img/youxi/wzry/赛季_S15.jpg" width="400" alt="赛季_S15"></td></tr><tr><th>S16 赛季</th><th>S17 赛季</th></tr><tr><td><img src="/img/youxi/wzry/赛季_S16.jpg" width="400" alt="赛季_S16"></td><td><img src="/img/youxi/wzry/赛季_S17.jpg" width="400" alt="赛季_S17"></td></tr></table><h2 id="一些值得纪念的事">一些值得纪念的事</h2><h3 id="琐碎的大事记">琐碎的大事记</h3><table><tr><th>第一次solo赢肉丁</th><th>第一次上王者</th><th>第一次武道会1st</th></tr><tr><td><img src="/img/youxi/wzry/solo胜丁丁.jpg" width="400" alt="solo胜丁丁"></td><td><img src="/img/youxi/wzry/王者.jpg" width="400" alt="王者"></td><td><img src="/img/youxi/wzry/武道会1st.jpg" width="400" alt="武道会1st"></td></tr><tr><th>长达40min的超级膀胱局</th><th>抽到冰冠公主</th><th>名师到达6级</th></tr><tr><td><img src="/img/youxi/wzry/超级膀胱局.jpg" width="400" alt="超级膀胱局"></td><td><img src="/img/youxi/wzry/冰冠公主.jpg" width="400" alt="冰冠公主"></td><td><img src="/img/youxi/wzry/名师6级.jpg" width="400" alt="名师6级"></td></tr><tr></tr><th>老夫子圣诞老人皮肤</th><th>老夫子圣诞老人皮肤</th><tr><td><img src="/img/youxi/wzry/老夫子皮肤.jpg" width="400" alt="老夫子皮肤"></td><td><img src="/img/youxi/wzry/圣诞老人.jpg" width="400" alt="圣诞老人"></td></tr></table><h3 id="一些五杀">一些五杀…</h3><blockquote><p>PS：有一些图可能丢了…</p></blockquote><table><tr><th>公孙离（助手截图）</th><th>马可波罗（助手截图）</th></tr><tr><td><img src="/img/youxi/wzry/五杀_公孙离五杀.jpg" width="500" alt="五杀_公孙离五杀"></td><td><img src="/img/youxi/wzry/五杀_马可波罗五杀.jpg" width="500" alt="五杀_马可波罗五杀"></td></tr><tr><th>李元芳（游戏分享）</th><th>马超（游戏分享）</th></tr><tr><td><img src="/img/youxi/wzry/五杀_李元芳五杀.jpg" width="500" alt="五杀_李元芳五杀"></td><td><img src="/img/youxi/wzry/五杀_马超五杀.jpg" width="500" alt="五杀_马超五杀"></td></tr></table><h3 id="一些高光时刻的记录">一些高光时刻的记录…</h3><table><tr><th>貂蝉带326上分：53.8% 输出</th><th>貂蝉带326上分：55.0% 输出</th><th>貂蝉战队赛：49.3% 输出</th></tr><tr><td><img src="/img/youxi/wzry/数据_貂蝉538.jpg" width="400" alt="数据_貂蝉538"></td><td><img src="/img/youxi/wzry/数据_貂蝉550.jpg" width="400" alt="数据_貂蝉550"></td><td><img src="/img/youxi/wzry/数据_貂蝉战队赛493.jpg" width="400" alt="数据_貂蝉战队赛493"></td></tr><tr><th>东皇：30.0% 输出</th><th>伽罗：48.1% 输出</th><th>干将莫邪：45.0% 输出</th></tr><tr><td><img src="/img/youxi/wzry/数据_东皇300.jpg" width="400" alt="数据_东皇300"></td><td><img src="/img/youxi/wzry/数据_伽罗481.jpg" width="400" alt="数据_伽罗481"></td><td><img src="/img/youxi/wzry/数据_干将莫邪450.jpg" width="400" alt="数据_干将莫邪450"></td></tr><tr><th>干将莫邪：46.9% 输出</th><th>后羿：50.2% 输出</th><th>橘右京：38.1% 输出</th></tr><tr><td><img src="/img/youxi/wzry/数据_干将莫邪469.jpg" width="400" alt="数据_干将莫邪469"></td><td><img src="/img/youxi/wzry/数据_后羿502.jpg" width="400" alt="数据_后羿502"></td><td><img src="/img/youxi/wzry/数据_橘右京381.jpg" width="400" alt="数据_橘右京381"></td></tr><tr><th>兰陵王：39.8% 输出</th><th>李信：42.2% 输出</th><th>鲁班大师：23.6% 输出</th></tr><tr><td><img src="/img/youxi/wzry/数据_兰陵王398.jpg" width="400" alt="数据_兰陵王398"></td><td><img src="/img/youxi/wzry/数据_李信422.jpg" width="400" alt="数据_李信422"></td><td><img src="/img/youxi/wzry/数据_鲁班大师236.jpg" width="400" alt="数据_鲁班大师236"></td></tr><tr><th>马可波罗：41.2% 输出</th><th>马可波罗：50.5% 输出</th><th>蒙犽：44.7% 输出</th></tr><tr><td><img src="/img/youxi/wzry/数据_马可波罗412.jpg" width="400" alt="数据_马可波罗412"></td><td><img src="/img/youxi/wzry/数据_马可波罗505.jpg" width="400" alt="数据_马可波罗505"></td><td><img src="/img/youxi/wzry/数据_蒙犽447.jpg" width="400" alt="数据_蒙犽447"></td></tr><tr><th>蒙犽：53.2% 输出</th><th>芈月：40.9% 输出</th><th>孙膑：30.5% 输出</th></tr><tr><td><img src="/img/youxi/wzry/数据_蒙犽532.jpg" width="400" alt="数据_蒙犽532"></td><td><img src="/img/youxi/wzry/数据_芈月409.jpg" width="400" alt="数据_芈月409"></td><td><img src="/img/youxi/wzry/数据_孙膑305.jpg" width="400" alt="数据_孙膑305"></td></tr><tr><th>孙悟空：46.0% 输出</th><th>瑶：25.0% 输出</th><th>嬴政：49.7% 输出</th></tr><tr><td><img src="/img/youxi/wzry/数据_孙悟空460.jpg" width="400" alt="数据_孙悟空460"></td><td><img src="/img/youxi/wzry/数据_瑶250.jpg" width="400" alt="数据_瑶250"></td><td><img src="/img/youxi/wzry/数据_嬴政497.jpg" width="400" alt="数据_嬴政497"></td></tr><tr><th>弈星：51.8% 输出</th><th>墨子：35.4% 输出</th><th>墨子：15.2 评分</th></tr><tr><td><img src="/img/youxi/wzry/数据_弈星518.jpg" width="400" alt="数据_弈星518"></td><td><img src="/img/youxi/wzry/数据_墨子354.jpg" width="400" alt="数据_墨子354"></td><td><img src="/img/youxi/wzry/数据_墨子15.4.jpg" alt="数据_墨子15.4"></td></tr><tr><th>云中君：15.2 评分</th><th>云中君：34.1% 输出</th><th>孙尚香：40.7% 输出</th></tr><tr><td><img src="/img/youxi/wzry/数据_云中君15.2.jpg" alt="数据_云中君15.2"></td><td><img src="/img/youxi/wzry/数据_云中君341.jpg" alt="数据_云中君341"></td><td><img src="/img/youxi/wzry/数据_孙尚香407.jpg" alt="数据_孙尚香407"></td></tr><tr><th>赵云：41.8% 输出</th></tr><tr><td><img src="/img/youxi/wzry/数据_赵云418.jpg" alt="数据_赵云418"></td></tr></table><h2 id="扯淡的训练营">扯淡的训练营</h2><blockquote><p>训练营也是需要技<del>运气</del>术的好吧(</p></blockquote><table border="0"><tr><th>轮盘方向：40.13s，击败99.92%</th><th>区域施法：40.66s，击败99.90%</th><th>穿墙移动：48.05s，击败99.99%</th></tr><tr><td><img src="/img/youxi/wzry/训练营_穿墙移动.jpg" width="400" alt="训练营_穿墙移动"></td><td><img src="/img/youxi/wzry/训练营_轮盘方向.jpg" width="400" alt="训练营_轮盘方向"></td><td><img src="/img/youxi/wzry/训练营_区域施法.jpg" width="400" alt="训练营_区域施法"></td></tr></table><h2 id="全英雄金牌计划">全英雄金牌计划</h2><blockquote><p>98 out of 99 Completed. 剩余未完成英雄：猪八戒</p></blockquote><table><tr><th>阿轲12.9分</th><th>安琪拉13.0分</th><th>白起12.3分</th><th>百里守约14.0分</th><th>百里守约14.2分</th></tr><tr><td><img src="/img/youxi/wzry/金牌_阿轲12.9.jpg" alt="金牌_阿轲12.9"></td><td><img src="/img/youxi/wzry/金牌_安琪拉13.0.jpg" alt="金牌_安琪拉13.0"></td><td><img src="/img/youxi/wzry/金牌_白起12.3.jpg" alt="金牌_白起12.3"></td><td><img src="/img/youxi/wzry/金牌_百里守约14.0.jpg" alt="金牌_百里守约14.0"></td><td><img src="/img/youxi/wzry/金牌_百里守约14.2.jpg" alt="金牌_百里守约14.2"></td></tr><tr><th>百里守约15.1分</th><th>百里玄策12.3分</th><th>扁鹊11.5分</th><th>不知火舞12.9分</th><th>蔡文姬11.5分</th></tr><tr><td><img src="/img/youxi/wzry/金牌_百里守约15.1.jpg" alt="金牌_百里守约15.1"></td><td><img src="/img/youxi/wzry/金牌_百里玄策12.3.jpg" alt="金牌_百里玄策12.3"></td><td><img src="/img/youxi/wzry/金牌_扁鹊11.5.jpg" alt="金牌_扁鹊11.5"></td><td><img src="/img/youxi/wzry/金牌_不知火舞12.9.jpg" alt="金牌_不知火舞12.9"></td><td><img src="/img/youxi/wzry/金牌_蔡文姬11.5.jpg" alt="金牌_蔡文姬11.5"></td></tr><tr><th>曹操10.8分</th><th>嫦娥11.3分</th><th>成吉思汗14.5分</th><th>程咬金14.2分</th><th>达摩12.5分</th></tr><tr><td><img src="/img/youxi/wzry/金牌_曹操10.8.jpg" alt="金牌_曹操10.8"></td><td><img src="/img/youxi/wzry/金牌_嫦娥11.3.jpg" alt="金牌_嫦娥11.3"></td><td><img src="/img/youxi/wzry/金牌_成吉思汗14.5.jpg" alt="金牌_成吉思汗14.5"></td><td><img src="/img/youxi/wzry/金牌_程咬金14.2.jpg" alt="金牌_程咬金14.2"></td><td><img src="/img/youxi/wzry/金牌_达摩12.5.jpg" alt="金牌_达摩12.5"></td></tr><tr><th>妲己12.1分</th><th>大乔13.5分</th><th>狄仁杰11.5分</th><th>典韦11.1分</th><th>貂蝉13.1分</th></tr><tr><td><img src="/img/youxi/wzry/金牌_妲己12.1.jpg" alt="金牌_妲己12.1"></td><td><img src="/img/youxi/wzry/金牌_大乔13.5.jpg" alt="金牌_大乔13.5"></td><td><img src="/img/youxi/wzry/金牌_狄仁杰11.5.jpg" alt="金牌_狄仁杰11.5"></td><td><img src="/img/youxi/wzry/金牌_典韦11.1.jpg" alt="金牌_典韦11.1"></td><td><img src="/img/youxi/wzry/金牌_貂蝉13.1.jpg" alt="金牌_貂蝉13.1"></td></tr><tr><th>东皇太一12.0分</th><th>盾山11.6分</th><th>伽罗13.0分</th><th>干将莫邪13.2分</th><th>干将莫邪14.2分</th></tr><tr><td><img src="/img/youxi/wzry/金牌_东皇太一12.0.jpg" alt="金牌_东皇太一12.0"></td><td><img src="/img/youxi/wzry/金牌_盾山11.6.jpg" alt="金牌_盾山11.6"></td><td><img src="/img/youxi/wzry/金牌_伽罗13.0.jpg" alt="金牌_伽罗13.0"></td><td><img src="/img/youxi/wzry/金牌_干将莫邪13.2.jpg" alt="金牌_干将莫邪13.2"></td><td><img src="/img/youxi/wzry/金牌_干将莫邪14.2.jpg" alt="金牌_干将莫邪14.2"></td></tr><tr><th>干将莫邪16.0分</th><th>高渐离11.9分</th><th>公孙离14.1分</th><th>宫本武藏12.6分</th><th>关羽14.1分</th></tr><tr><td><img src="/img/youxi/wzry/金牌_干将莫邪16.0.jpg" alt="金牌_干将莫邪16.0"></td><td><img src="/img/youxi/wzry/金牌_高渐离11.9.jpg" alt="金牌_高渐离11.9"></td><td><img src="/img/youxi/wzry/金牌_公孙离14.1.jpg" alt="金牌_公孙离14.1"></td><td><img src="/img/youxi/wzry/金牌_宫本武藏12.6.jpg" alt="金牌_宫本武藏12.6"></td><td><img src="/img/youxi/wzry/金牌_关羽14.1.jpg" alt="金牌_关羽14.1"></td></tr><tr><th>关羽15.3分</th><th>鬼谷子10.9分</th><th>鬼谷子11.5分</th><th>韩信14.5分</th><th>后羿14.6分</th></tr><tr><td><img src="/img/youxi/wzry/金牌_关羽15.3.jpg" alt="金牌_关羽15.3"></td><td><img src="/img/youxi/wzry/金牌_鬼谷子10.9.jpg" alt="金牌_鬼谷子10.9"></td><td><img src="/img/youxi/wzry/金牌_鬼谷子11.5.jpg" alt="金牌_鬼谷子11.5"></td><td><img src="/img/youxi/wzry/金牌_韩信14.5.jpg" alt="金牌_韩信14.5"></td><td><img src="/img/youxi/wzry/金牌_后羿14.6.jpg" alt="金牌_后羿14.6"></td></tr><tr><th>花木兰13.0分</th><th>黄忠13.4分</th><th>姜子牙11.5分</th><th>橘右京14.4分</th><th>铠13.5分</th></tr><tr><td><img src="/img/youxi/wzry/金牌_花木兰13.0.jpg" alt="金牌_花木兰13.0"></td><td><img src="/img/youxi/wzry/金牌_黄忠13.4.jpg" alt="金牌_黄忠13.4"></td><td><img src="/img/youxi/wzry/金牌_姜子牙11.5.jpg" alt="金牌_姜子牙11.5"></td><td><img src="/img/youxi/wzry/金牌_橘右京14.4.jpg" alt="金牌_橘右京14.4"></td><td><img src="/img/youxi/wzry/金牌_铠13.5.jpg" alt="金牌_铠13.5"></td></tr><tr><th>狂铁12.0分</th><th>兰陵王14.6分</th><th>兰陵王15.9分</th><th>老夫子12.3分</th><th>李白14.1分</th></tr><tr><td><img src="/img/youxi/wzry/金牌_狂铁12.0.jpg" alt="金牌_狂铁12.0"></td><td><img src="/img/youxi/wzry/金牌_兰陵王14.6.jpg" alt="金牌_兰陵王14.6"></td><td><img src="/img/youxi/wzry/金牌_兰陵王15.9.jpg" alt="金牌_兰陵王15.9"></td><td><img src="/img/youxi/wzry/金牌_老夫子12.3.jpg" alt="金牌_老夫子12.3"></td><td><img src="/img/youxi/wzry/金牌_李白14.1.jpg" alt="金牌_李白14.1"></td></tr><tr><th>李信13.7分</th><th>李元芳15.1分</th><th>廉颇10.7分</th><th>刘邦12.9分</th><th>刘备11.9分</th></tr><tr><td><img src="/img/youxi/wzry/金牌_李信13.7.jpg" alt="金牌_李信13.7"></td><td><img src="/img/youxi/wzry/金牌_李元芳15.1.jpg" alt="金牌_李元芳15.1"></td><td><img src="/img/youxi/wzry/金牌_廉颇10.7.jpg" alt="金牌_廉颇10.7"></td><td><img src="/img/youxi/wzry/金牌_刘邦12.9.jpg" alt="金牌_刘邦12.9"></td><td><img src="/img/youxi/wzry/金牌_刘备11.9.jpg" alt="金牌_刘备11.9"></td></tr><tr><th>刘禅10.9分</th><th>鲁班大师16.0分</th><th>鲁班七号13.6分</th><th>露娜11.9分</th><th>吕布12.0分</th></tr><tr><td><img src="/img/youxi/wzry/金牌_刘禅10.9.jpg" alt="金牌_刘禅10.9"></td><td><img src="/img/youxi/wzry/金牌_鲁班大师16.0.jpg" alt="金牌_鲁班大师16.0"></td><td><img src="/img/youxi/wzry/金牌_鲁班七号13.6.jpg" alt="金牌_鲁班七号13.6"></td><td><img src="/img/youxi/wzry/金牌_露娜11.9.jpg" alt="金牌_露娜11.9"></td><td><img src="/img/youxi/wzry/金牌_吕布12.0.jpg" alt="金牌_吕布12.0"></td></tr><tr><th>马超13.8分</th><th>马可波罗12.6分</th><th>马可波罗13.3分</th><th>蒙犽13.7分</th><th>梦奇12.9分</th></tr><tr><td><img src="/img/youxi/wzry/金牌_马超13.8.jpg" alt="金牌_马超13.8"></td><td><img src="/img/youxi/wzry/金牌_马可波罗12.6.jpg" alt="金牌_马可波罗12.6"></td><td><img src="/img/youxi/wzry/金牌_马可波罗13.3.jpg" alt="金牌_马可波罗13.3"></td><td><img src="/img/youxi/wzry/金牌_蒙犽13.7.jpg" alt="金牌_蒙犽13.7"></td><td><img src="/img/youxi/wzry/金牌_梦奇12.9.jpg" alt="金牌_梦奇12.9"></td></tr><tr><th>米莱狄11.4分</th><th>米莱狄12.4分</th><th>芈月14.1分</th><th>明世隐10.8分</th><th>墨子15.4分</th></tr><tr><td><img src="/img/youxi/wzry/金牌_米莱狄11.4.jpg" alt="金牌_米莱狄11.4"></td><td><img src="/img/youxi/wzry/金牌_米莱狄12.4.jpg" alt="金牌_米莱狄12.4"></td><td><img src="/img/youxi/wzry/金牌_芈月14.1.jpg" alt="金牌_芈月14.1"></td><td><img src="/img/youxi/wzry/金牌_明世隐10.8.jpg" alt="金牌_明世隐10.8"></td><td><img src="/img/youxi/wzry/金牌_墨子15.4.jpg" alt="金牌_墨子15.4"></td></tr><tr><th>哪吒11.1分</th><th>娜可露露13.0分</th><th>牛魔14.1分</th><th>女娲12.1分</th><th>盘古12.3分</th></tr><tr><td><img src="/img/youxi/wzry/金牌_哪吒11.1.jpg" alt="金牌_哪吒11.1"></td><td><img src="/img/youxi/wzry/金牌_娜可露露13.0.jpg" alt="金牌_娜可露露13.0"></td><td><img src="/img/youxi/wzry/金牌_牛魔14.1.jpg" alt="金牌_牛魔14.1"></td><td><img src="/img/youxi/wzry/金牌_女娲12.1.jpg" alt="金牌_女娲12.1"></td><td><img src="/img/youxi/wzry/金牌_盘古12.3.jpg" alt="金牌_盘古12.3"></td></tr><tr><th>裴擒虎13.5分</th><th>上官婉儿13.7分</th><th>沈梦溪11.7分</th><th>司马懿.jpg分</th><th>苏烈12.4分</th></tr><tr><td><img src="/img/youxi/wzry/金牌_裴擒虎13.5.jpg" alt="金牌_裴擒虎13.5"></td><td><img src="/img/youxi/wzry/金牌_上官婉儿13.7.jpg" alt="金牌_上官婉儿13.7"></td><td><img src="/img/youxi/wzry/金牌_沈梦溪11.7.jpg" alt="金牌_沈梦溪11.7"></td><td><img src="/img/youxi/wzry/金牌_司马懿.jpg" alt="金牌_司马懿.jpg"></td><td><img src="/img/youxi/wzry/金牌_苏烈12.4.jpg" alt="金牌_苏烈12.4"></td></tr><tr><th>孙膑13.6分</th><th>孙策10.5分</th><th>孙尚香14.3分</th><th>孙悟空14.0分</th><th>太乙真人9.3分</th></tr><tr><td><img src="/img/youxi/wzry/金牌_孙膑13.6.jpg" alt="金牌_孙膑13.6"></td><td><img src="/img/youxi/wzry/金牌_孙策10.5.jpg" alt="金牌_孙策10.5"></td><td><img src="/img/youxi/wzry/金牌_孙尚香14.3.jpg" alt="金牌_孙尚香14.3"></td><td><img src="/img/youxi/wzry/金牌_孙悟空14.0.jpg" alt="金牌_孙悟空14.0"></td><td><img src="/img/youxi/wzry/金牌_太乙真人9.3.jpg" alt="金牌_太乙真人9.3"></td></tr><tr><th>王昭君13.1分</th><th>武则天12.4分</th><th>西施13.8分</th><th>夏侯惇11.6分</th><th>项羽11.5分</th></tr><tr><td><img src="/img/youxi/wzry/金牌_王昭君13.1.jpg" alt="金牌_王昭君13.1"></td><td><img src="/img/youxi/wzry/金牌_武则天12.4.jpg" alt="金牌_武则天12.4"></td><td><img src="/img/youxi/wzry/金牌_西施13.8.jpg" alt="金牌_西施13.8"></td><td><img src="/img/youxi/wzry/金牌_夏侯惇11.6.jpg" alt="金牌_夏侯惇11.6"></td><td><img src="/img/youxi/wzry/金牌_项羽11.5.jpg" alt="金牌_项羽11.5"></td></tr><tr><th>小乔12.0分</th><th>雅典娜11.5分</th><th>亚瑟13.7分</th><th>杨戬12.9分</th><th>杨戬13.7分</th></tr><tr><td><img src="/img/youxi/wzry/金牌_小乔12.0.jpg" alt="金牌_小乔12.0"></td><td><img src="/img/youxi/wzry/金牌_雅典娜11.5.jpg" alt="金牌_雅典娜11.5"></td><td><img src="/img/youxi/wzry/金牌_亚瑟13.7.jpg" alt="金牌_亚瑟13.7"></td><td><img src="/img/youxi/wzry/金牌_杨戬12.9.jpg" alt="金牌_杨戬12.9"></td><td><img src="/img/youxi/wzry/金牌_杨戬13.7.jpg" alt="金牌_杨戬13.7"></td></tr><tr><th>杨玉环11.3分</th><th>杨玉环12.1分</th><th>瑶12.0分</th><th>曜14.9分</th><th>弈星9.2分</th></tr><tr><td><img src="/img/youxi/wzry/金牌_杨玉环11.3.jpg" alt="金牌_杨玉环11.3"></td><td><img src="/img/youxi/wzry/金牌_杨玉环12.1.jpg" alt="金牌_杨玉环12.1"></td><td><img src="/img/youxi/wzry/金牌_瑶12.0.jpg" alt="金牌_瑶12.0"></td><td><img src="/img/youxi/wzry/金牌_曜14.9.jpg" alt="金牌_曜14.9"></td><td><img src="/img/youxi/wzry/金牌_弈星9.2.jpg" alt="金牌_弈星9.2"></td></tr><tr><th>嬴政15.0分</th><th>虞姬13.9分</th><th>元歌13.0分</th><th>元歌13.6分</th><th>云中君15.2分</th></tr><tr><td><img src="/img/youxi/wzry/金牌_嬴政15.0.jpg" alt="金牌_嬴政15.0"></td><td><img src="/img/youxi/wzry/金牌_虞姬13.9.jpg" alt="金牌_虞姬13.9"></td><td><img src="/img/youxi/wzry/金牌_元歌13.0.jpg" alt="金牌_元歌13.0"></td><td><img src="/img/youxi/wzry/金牌_元歌13.6.jpg" alt="金牌_元歌13.6"></td><td><img src="/img/youxi/wzry/金牌_云中君15.2.jpg" alt="金牌_云中君15.2"></td></tr><tr><th>张飞11.9分</th><th>张良11.4分</th><th>赵云14.6分</th><th>甄姬13.2分</th><th>钟馗12.5分</th></tr><tr><td><img src="/img/youxi/wzry/金牌_张飞11.9.jpg" alt="金牌_张飞11.9"></td><td><img src="/img/youxi/wzry/金牌_张良11.4.jpg" alt="金牌_张良11.4"></td><td><img src="/img/youxi/wzry/金牌_赵云14.6.jpg" alt="金牌_赵云14.6"></td><td><img src="/img/youxi/wzry/金牌_甄姬13.2.jpg" alt="金牌_甄姬13.2"></td><td><img src="/img/youxi/wzry/金牌_钟馗12.5.jpg" alt="金牌_钟馗12.5"></td></tr><tr><th>钟无艳10.3分</th><th>钟无艳9.4分</th><th>周瑜13.1分</th><th>诸葛亮12.7分</th><th>庄周11.4分</th></tr><tr><td><img src="/img/youxi/wzry/金牌_钟无艳10.3.jpg" alt="金牌_钟无艳10.3"></td><td><img src="/img/youxi/wzry/金牌_钟无艳9.4.jpg" alt="金牌_钟无艳9.4"></td><td><img src="/img/youxi/wzry/金牌_周瑜13.1.jpg" alt="金牌_周瑜13.1"></td><td><img src="/img/youxi/wzry/金牌_诸葛亮12.7.jpg" alt="金牌_诸葛亮12.7"></td><td><img src="/img/youxi/wzry/金牌_庄周11.4.jpg" alt="金牌_庄周11.4"></td></tr><tr><th>镜13.4分</th></tr><tr><td><img src="/img/youxi/wzry/金牌_镜13.4.jpg" alt="金牌_镜13.4"></td></tr></table><h2 id="边境突围吃鸡小记录">边境突围吃鸡小记录</h2><blockquote><p>S12赛季农药开发了新模式边境突围, 玩法类似于吃鸡, 但是感觉emmmmm… 不如吃鸡有意思, 而且有点卡.<br>按照惯例, 还是进行一些琐碎且无聊的记录:</p></blockquote><h3 id="第一次吃鸡第一次带兔子吃鸡">第一次吃鸡&amp;第一次带兔子吃鸡</h3><table><tr><th>第一次吃鸡</th><th>第一次带兔子吃鸡</th></tr><tr><td><img src="/img/youxi/wzry/边境突围_第一次吃鸡.jpg" width="400" alt="第一次吃鸡"></td><td><img src="/img/youxi/wzry/边境突围_第一次带兔子吃鸡.jpg" width="400" alt="第一次带兔子吃鸡"></td></tr><tr><th>第一次吃鸡：数据</th><th>第一次带兔子吃鸡：数据</th></tr><tr><td><img src="/img/youxi/wzry/边境突围_第一次吃鸡-数据.jpg" width="400" alt="第一次吃鸡-数据"></td><td><img src="/img/youxi/wzry/边境突围_第一次带兔子吃鸡-数据.jpg" width="400" alt="第一次带兔子吃鸡-数据"></td></tr><tr><th>连跪后拉兔子吃鸡</th><th>睡不着偷偷吃把鸡</th></tr><tr><td><img src="/img/youxi/wzry/边境突围_连跪后拉兔子吃鸡.jpg" width="400" alt="连跪后拉兔子吃鸡"></td><td><img src="/img/youxi/wzry/边境突围_睡不着偷偷吃把鸡.jpg" width="400" alt="睡不着偷偷吃把鸡"></td></tr><tr><th>连跪后拉兔子吃鸡：数据</th><th>睡不着偷偷吃把鸡：数据</th></tr><tr><td><img src="/img/youxi/wzry/边境突围_连跪后拉兔子吃鸡-数据.jpg" width="400" alt="连跪后拉兔子吃鸡-数据"></td><td><img src="/img/youxi/wzry/边境突围_睡不着偷偷吃把鸡-数据.jpg" width="400" alt="睡不着偷偷吃把鸡-数据"></td></tr></table><h3 id="冲分之旅">冲分之旅</h3><blockquote><p>主玩双人模式，不过经常是一个人玩…</p></blockquote><h4 id="冲-2k-分">冲 2k 分</h4><table><tr><td><img src="/img/youxi/wzry/边境突围_冲2k分之旅.jpg" width="400" alt="冲2k分之旅"></td><td><img src="/img/youxi/wzry/边境突围_冲2k分之旅-1.jpg" width="400" alt="冲2k分之旅-1"></td><td><img src="/img/youxi/wzry/边境突围_冲上2k分.jpg" width="400" alt="冲上2k分"></td></tr></table><h4 id="冲-2400">冲 2400</h4><table><tr><td><img src="/img/youxi/wzry/边境突围_2k分第一鸡.jpg" width="400" alt="2k分第一鸡"></td><td><img src="/img/youxi/wzry/边境突围_2k分第二鸡.jpg" width="400" alt="2k分第二鸡"></td><td><img src="/img/youxi/wzry/边境突围_冲2k4.jpg" width="400" alt="冲2k4"></td><td><img src="/img/youxi/wzry/边境突围_冲上2k4.jpg" width="400" alt="冲上2k4"></td></tr></table><h4 id="难得与boo哥双排">难得与boo哥双排</h4><table><tr><td><img src="/img/youxi/wzry/边境突围_小boo第三鸡.jpg" width="400" alt="小boo第三鸡"></td><td><img src="/img/youxi/wzry/边境突围_小boo第四鸡.jpg" width="400" alt="小boo第四鸡"></td></tr></table><h3 id="助手的简洁记录">助手的简洁记录</h3><blockquote><p>助手的记录比较简洁，故后面的都采取此方式进行记录…</p></blockquote><table><tr><td><img src="/img/youxi/wzry/边境突围_助手-1.jpg" width="400" alt="助手-1"></td><td><img src="/img/youxi/wzry/边境突围_助手-2.jpg" width="400" alt="助手-2"></td><td><img src="/img/youxi/wzry/边境突围_助手-3.jpg" width="400" alt="助手-3"></td></tr><tr><td><img src="/img/youxi/wzry/边境突围_助手-4.jpg" width="400" alt="助手-4"></td><td><img src="/img/youxi/wzry/边境突围_助手-5.jpg" width="400" alt="助手-5"></td><td><img src="/img/youxi/wzry/边境突围_助手-6.jpg" width="400" alt="助手-6"></td></tr><tr><td><img src="/img/youxi/wzry/边境突围_助手-7.jpg" width="400" alt="助手-7"></td><td><img src="/img/youxi/wzry/边境突围_助手-8.jpg" width="400" alt="助手-8"></td><td><img src="/img/youxi/wzry/边境突围_助手-9.jpg" width="400" alt="助手-9"></td></tr></table>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
            <tag> 王者荣耀 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论文笔记[2]——AKS素性测试</title>
      <link href="/2018/04/15/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-2-%E2%80%94%E2%80%94PRIMES-Is-in-P/"/>
      <content type="html"><![CDATA[<blockquote><p>文章: Agrawal M, Kayal N, Saxena N. PRIMES Is in P[J]. Annals of Mathematics, 2004, 160(2):781-793.</p></blockquote><center><font size="5" face="楷体" color="#6E552F"><u>太长不看版</u></font></center><center><img src="/img/blog-graph/poly-algo.png"></center><p>文章分为正确性和复杂度两部分:</p><ul><li>正确性: 素数显然会返回 <code>PRIME</code>, 只需证返回 <code>PRIME</code> 的是素数. 返回素数的地方只有 <code>Step 2</code> 和 <code>Step 6</code>, 分别讨论之.<ul><li><code>Step 4</code>: 若 <span class="math inline">\(n\)</span> 是合数则会在 <code>Step 3</code> 中返回, 矛盾.</li><li><code>Step 6</code>: 分段考虑.<ol type="1"><li>先考虑 <code>Step 2</code> 中 <span class="math inline">\(r\)</span> 的范围, 可得 <span class="math inline">\(r\leqslant\lceil\log^5n\rceil\)</span>.</li><li>定义多项式之间的关系introspective: <span class="math inline">\([f(x)]^m=f(x^m)~({\rm mod}~x^r-1,p)\)</span>, 则该性质对 <span class="math inline">\(m\)</span> 和 <span class="math inline">\(f\)</span> 都满乘积性质.</li><li>由于在 <code>Step 5</code> 没有返回 <code>COMPOSITE</code>, 故 <span class="math inline">\(\frac{n}{p},p\)</span> 对 <span class="math inline">\(x+a\)</span> 是introspective的. 故 <span class="math inline">\(\frac{n}{p}\)</span> 与 <span class="math inline">\(p^j\)</span> 的任意乘积对 <span class="math inline">\(x+a~(0\leqslant a\leqslant l)\)</span> 的任意乘积是introspective的.</li><li>进一步, 通过建立两个群 <span class="math inline">\(G\)</span> 和 <span class="math inline">\(\mathcal{G}\)</span>, 可得到 <span class="math inline">\(|\mathcal{G}|\)</span> 的下界和一个由条件的上界. 并可最终得到 <span class="math inline">\(n=p\)</span>, 即 <span class="math inline">\(n\)</span> 是素数.</li></ol></li><li><strong>至此算法正确性得证.</strong></li></ul></li><li>复杂度: 逐步分析可知 <code>Step 5</code> 复杂度最高, 为 <span class="math inline">\(O^\sim(\log^\frac{21}{2}n)\)</span>.</li></ul><a id="more"></a><hr><center><font size="5" face="楷体" color="#6E552F"><u>以下是详细的版本</u></font></center><h2 id="记号说明和准备工作">记号说明和准备工作</h2><h3 id="记号列表">记号列表</h3><p>文中出现的记号记录如下:</p><ul><li><span class="math inline">\(P\)</span>: 图灵机在多项式时间内可以解决的问题;</li><li><span class="math inline">\(F_p\)</span> 表示阶为 <span class="math inline">\(p\)</span> 的有限域, 其中 <span class="math inline">\(p\)</span> 是素数;</li><li><span class="math inline">\(f(x)=g(x)~({\rm mod}~h(x),n)\)</span>: 表示 <span class="math inline">\(f(x)=g(x)\)</span> 在 <span class="math inline">\(\mathbb{Z}_n[x]/\langle h(x)\rangle\)</span> 中成立;</li><li><span class="math inline">\(O^\sim (t(n))\)</span>: 表示 <span class="math inline">\(O(t(n))\cdot {\rm poly}(\log t(n))\)</span>. 其中 <span class="math inline">\(\log\)</span> 表示以 <span class="math inline">\(2\)</span> 为底的对数;</li><li><span class="math inline">\(o_r(a)\)</span>: 表示 <span class="math inline">\(a\)</span> 模 <span class="math inline">\(r\)</span> 的指数. 即最小的 <span class="math inline">\(k\)</span>, s.t. <span class="math inline">\(a^k=1~({\rm mod}~r)\)</span>.</li></ul><blockquote><center>为不影响思路的连贯性, 长一点的证明细节都补在最后.</center></blockquote><h3 id="准备工作">准备工作</h3><blockquote><p><strong>LEMMA 1.</strong> 设 <span class="math inline">\(a\in\mathbb{Z}\)</span>, <span class="math inline">\(n\geqslant 2\in\mathbb{N}\)</span>, 且 <span class="math inline">\((a,n)=1\)</span>, 则 <span class="math inline">\(n\)</span> 是素数当且仅当 <span class="math display">\[(x+a)^n=x^n+a~({\rm mod~n}).\]</span> <strong>Proof.</strong> 直接讨论, 利用二项式系数的性质即可.</p></blockquote><blockquote><p><strong>PRELIMINARY 1.</strong> 若 <span class="math inline">\(h(x)\)</span> 是 <span class="math inline">\(F_p[x]\)</span> 中的 <span class="math inline">\(d\)</span> 次不可约多项式, 则 <span class="math inline">\(F_p[x]/\langle h[x]\rangle\)</span> 是阶为 <span class="math inline">\(p^d\)</span> 的有限域.<br><strong>Proof.</strong> 设 <span class="math inline">\(F(\alpha)=0\)</span>, 考虑映射 <span class="math inline">\(\varphi:~F[\alpha]\to F[x],~f(\alpha)\mapsto f(x)\)</span>, 则由环同态基本定理可得 <span class="math display">\[F(\alpha)=F[\alpha]\simeq F[x]/\langle p(x)\rangle.\]</span> 由此即可证得结论.</p></blockquote><blockquote><p><strong>PRELIMINARY 2.</strong> 对于 <span class="math inline">\(\forall a,r\in\mathbb{N}\)</span> 满足 <span class="math inline">\((a,r)=1\)</span>, 都有 <span class="math inline">\(o_r(a)~\vert~\phi(r)\)</span>.<br><strong>Proof.</strong> 若不满足上式, 与 <span class="math inline">\(o_r(a)\)</span> 的最小性矛盾.</p></blockquote><blockquote><p><strong>LEMMA 2.</strong> 令 <span class="math inline">\({\rm LCM}(n)\)</span> 表示前 <span class="math inline">\(n\)</span> 个数的lcm, 则对 <span class="math inline">\(n\geqslant 7\)</span> 有: <span class="math inline">\({\rm LCM}(n)\geqslant 2^n\)</span>.<br><strong>Proof.</strong> Nair M. On Chebyshev-type inequalities for primes[J]. American Mathematical Monthly, 1982, 89(2):126-129.</p></blockquote><h2 id="算法正确性">算法正确性</h2><p>需要证明以下两条:</p><ol type="1"><li><span class="math inline">\(n\)</span> 是素数<span class="math inline">\(\to\)</span>算法返回 <code>PRIME</code> ;</li><li>算法返回 <code>PRIME</code> <span class="math inline">\(\to\)</span><span class="math inline">\(n\)</span> 是素数.</li></ol><p>事实上第一条是显然的, 主要部分是第二条的证明.</p><h3 id="n-是素数to算法返回-prime"><span class="math inline">\(n\)</span> 是素数<span class="math inline">\(\to\)</span>算法返回 <code>PRIME</code></h3><blockquote><p><strong>LEMMA 3.</strong> 若 <span class="math inline">\(n\)</span> 是素数, 则算法返回 <code>PRIME</code>.<br><strong>Proof.</strong> 这一条其实是很显然的. 证明全是废话, 略掉.</p></blockquote><h3 id="算法返回-prime-to-n-是素数">算法返回 <code>PRIME</code> <span class="math inline">\(\to n\)</span> 是素数</h3><p>算法返回 <code>PRIME</code> 的地方只有两处, 分别为 <code>Step 4</code> 和 <code>Step 6</code>. 以下分别讨论之.</p><h4 id="step-4-返回-prime-to-n-是素数"><code>Step 4</code> 返回 <code>PRIME</code> <span class="math inline">\(\to n\)</span> 是素数</h4><p>证明很容易: 如果 <span class="math inline">\(n\)</span> 是合数且 <span class="math inline">\(n\leqslant r\)</span>, 则在<code>Step</code>3 中一定可找到 <span class="math inline">\(n\)</span> 的一个非平凡因子. 故在 <code>Step 3</code> 一定会返回 <code>COMPOSITE</code>, 矛盾! 故 <code>Step 4</code> 返回 <code>PRIME</code> <span class="math inline">\(\Rightarrow n\)</span> 是素数.</p><h4 id="step-6-返回-prime-to-n-是素数"><code>Step 6</code> 返回 <code>PRIME</code> <span class="math inline">\(\to n\)</span> 是素数</h4><p>算法的核心步骤是 <code>Step 2</code> 和 <code>Step 5</code>. 算法在 <code>Step 2</code> 中取了一个 <span class="math inline">\(r\)</span> 值, 所以我们从 <span class="math inline">\(r\)</span> 的大致取值开始考虑.</p><blockquote><p><strong>LEMMA 4.</strong> <span class="math inline">\(\exists r\leqslant\max\{3,\lceil\log^5 n\rceil\}\)</span>, s.t. <span class="math inline">\(o_r(n)&gt;\log^2n\)</span>.<br><strong>Proof.</strong> 单独讨论 <span class="math inline">\(n=2\)</span> 情况, 即可设 <span class="math inline">\(n&gt;2\)</span>, 此时可利用 <strong>LEMMA 2</strong> 进行证明.</p></blockquote><p>由于 <span class="math inline">\(o_r(n)&gt;1\)</span>, 故存在 <span class="math inline">\(n\)</span> 的素因子 <span class="math inline">\(p\)</span>, s.t. <span class="math inline">\(o_r(p)&gt;1\)</span> (否则容易得到 <span class="math inline">\(o_r(n)=1\)</span>, 矛盾). 进一步应有 <span class="math inline">\(p&gt;r\)</span>, 否则在 <code>Step 3</code> 和 <code>Step 4</code> 就已经判断了 <span class="math inline">\(n\)</span> 的素性. 又由于 <span class="math inline">\((n,r)=1\)</span>(否则在 <code>Step 3</code> 和 <code>Step 4</code> 会判定 <span class="math inline">\(n\)</span> 素性), 故 <span class="math inline">\(p,n\in\mathbb{Z}_r^*\)</span>. <span class="math inline">\(p\)</span> 和 <span class="math inline">\(r\)</span> 在后文中将被固定, 再令 <span class="math inline">\(l=\lfloor\sqrt{\phi(r)}\log n\rfloor\)</span>.</p><p>由于算法执行到了 <code>Step 6</code>, 故在 <code>Step 5</code> 没有返回 <code>COMPOSITE</code>. 即: <span class="math display">\[(x+a)^n=x^n+a~({\rm mod}~x^r-1,n)\quad\forall a,0\leqslant a\leqslant l.\]</span> 于是 <span class="math display">\[(x+a)^n=x^n+a~({\rm mod}~x^r-1,p)\quad\forall a,0\leqslant a\leqslant l.\]</span> 由以上两式可得: <span class="math display">\[(x+a)^\frac{n}{p}=x^\frac{n}{p}+a~({\rm mod}~x^r-1,p)\quad\forall a,0\leqslant a\leqslant l.\]</span> 结合 <strong>LEMMA 1</strong>, 此时的 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(\frac{n}{p}\)</span> 都满足 <strong>LEMMA 1</strong> 的条件, 将该性质定义如下:</p><blockquote><p><strong>DEFINITION 1.</strong> 对于多项式 <span class="math inline">\(f(x)\)</span> 和 <span class="math inline">\(m\in\mathbb{N}\)</span>, 称 <span class="math inline">\(m\)</span> 是instropective的, 如果 <span class="math display">\[[f(x)]^m=f(x^m)~({\rm mod}~x^r-1,p).\]</span></p></blockquote><p>很容易证明instropective有如下性质:</p><blockquote><p><strong>LEMMA 5.</strong> 若 <span class="math inline">\(m\)</span> 和 <span class="math inline">\(m&#39;\)</span> 对 <span class="math inline">\(f(x)\)</span> 都是instropective的, 则 <span class="math inline">\(m\cdot m&#39;\)</span> 对 <span class="math inline">\(f(x)\)</span> 也是instropective的.</p></blockquote><blockquote><p><strong>LEMMA 6.</strong> 若 <span class="math inline">\(m\)</span> 对 <span class="math inline">\(f(x)\)</span> 和 <span class="math inline">\(g(x)\)</span> 都是instropective的, 则 <span class="math inline">\(m\)</span> 对 <span class="math inline">\(f(x)\cdot g(x)\)</span> 也是instropective的.</p></blockquote><p>于是可以得到如下事实:</p><ul><li>由前文的三个等式可知 <span class="math inline">\(\frac{n}{p}\)</span> 和 <span class="math inline">\(p\)</span> 对 <span class="math inline">\(x+a\)</span> 是instropective的, <span class="math inline">\(\forall 0\leqslant a\leqslant l\)</span>.</li><li>进一步, 集合 <span class="math inline">\(I=\{(\frac{n}{p})^i\cdot p^j~\vert~ i,j&gt;0\}\)</span> 中的每个数对集合 <span class="math inline">\(P=\{\prod\limits_{a=0}^l(x+a)^{e_a}~\vert~ e_a\geqslant 0\}\)</span> 中的每个多项式都是introspective的.</li></ul><p>进一步可在上述集合的基础上如下定义两个群:</p><ul><li><span class="math inline">\(G\)</span>: <span class="math inline">\(I\)</span> 中所有的数模 <span class="math inline">\(r\)</span> 的余数构成一个群. 设 <span class="math inline">\(\vert G\vert=t\)</span>.<ol type="1"><li>显然 <span class="math inline">\(G\subset \mathbb{Z}_r^*\)</span>(生成元都在 <span class="math inline">\(\mathbb{Z}_r^*\)</span> 中).</li><li>由 <span class="math inline">\(o_r(n)&gt;\log^2n\)</span> 可知, <span class="math inline">\(t&gt;\log^2n\)</span>.</li></ol></li><li><span class="math inline">\(\mathcal{G}\)</span>: 由 <span class="math inline">\(x,x+1,\cdots,x+l\)</span> 在域 <span class="math inline">\(F=F_p[x]/\langle h(x)\rangle\)</span> 中生成的群.<ol type="1"><li>显然 <span class="math inline">\(\mathcal{G}\)</span> 是 <span class="math inline">\(F\)</span> 乘法群的子群.</li><li><span class="math inline">\(P\)</span> 中所有多项式在模 <span class="math inline">\(h(x)\)</span> 和 <span class="math inline">\(p\)</span> 的意义下关于乘法构成一个群.</li></ol></li></ul><p><span class="math inline">\(\vert\mathcal{G}\vert\)</span> 的范围由如下引理给出(证明细节见后文):</p><blockquote><p><strong>LEMMA 7.</strong> <strong>下界:</strong> (Hendrik Lenstra Jr.) <span class="math inline">\(\vert\mathcal{G}\vert\geqslant\binom{t+l}{t-1}\)</span>.</p></blockquote><blockquote><p><strong>LEMMA 8.</strong> <strong>上界:</strong> 若 <span class="math inline">\(n\)</span> 不是 <span class="math inline">\(p\)</span> 的方幂, 则 <span class="math inline">\(\vert\mathcal{G}\vert\leqslant n^{\sqrt{t}}\)</span>.</p></blockquote><p>进一步即可得到最终的结果:</p><blockquote><p><strong>LEMMA 9.</strong> 若算法返回 <code>PRIME</code>, 则 <span class="math inline">\(n\)</span> 是素数.<br><strong>Proof.</strong> 由 <strong>LEMMA 7</strong>, 有: <span class="math display">\[\begin{align}\vert\mathcal{G}\vert &amp;\geqslant \binom{t+l}{t-1} &amp; \\&amp;\geqslant \binom{l+1+\lfloor\sqrt{t}\log n\rfloor}{\lfloor\sqrt{t}\log n\rfloor}&amp;\quad (由于~t&gt;\sqrt{t}\log n) \\&amp;\geqslant \binom{2\lfloor\sqrt{t}\log n\rfloor+1}{\lfloor\sqrt{t}\log n\rfloor} &amp;\quad (由于~l\geqslant \lfloor\sqrt{t}\log n\rfloor) \\&amp;\geqslant 2^{\lfloor\sqrt{t}\log n\rfloor+1} &amp;\quad (由于~\lfloor\sqrt{t}\log n\rfloor&gt;\lfloor\log^2n\rfloor\geqslant 1) \\&amp;\geqslant n^{\sqrt{t}}.\end{align}\]</span> 由 <strong>LEMMA 8</strong>, 当 <span class="math inline">\(n\)</span> 不是 <span class="math inline">\(p\)</span> 的方幂时, 有<span class="math inline">\(\vert\mathcal{G}\vert\leqslant n^\sqrt{t}\)</span>. 故 <span class="math inline">\(\exists k\)</span>, s.t. <span class="math inline">\(n=p^k\)</span>. 若 <span class="math inline">\(k&gt;1\)</span>, 则在 <code>Step 1</code> 就会返回 <code>COMPOSITE</code>. 故只有 <span class="math inline">\(k=1\)</span>, 即 <span class="math inline">\(n=p\)</span>, 即 <span class="math inline">\(n\)</span> 为素数.</p></blockquote><p><strong>至此, 算法正确性已经证明完毕.</strong> 可归纳为如下定理:</p><blockquote><p><strong>THEOREM 1.</strong> 算法返回 <code>PRIME</code> 当且仅当 <span class="math inline">\(n\)</span> 是素数.</p></blockquote><h2 id="复杂度证明">复杂度证明</h2><p>首先做如下假定:</p><ul><li><span class="math inline">\(m\)</span> 位数的四则运算耗时均为 <span class="math inline">\(O^\sim(m)\)</span>;</li><li>两个系数为 <span class="math inline">\(m\)</span> 位整数的 <span class="math inline">\(d\)</span> 次多项式的四则运算耗时为 <span class="math inline">\(O^\sim(d\cdot m)\)</span>.</li><li><span class="math inline">\(n\)</span> 的位数大致为 <span class="math inline">\(O(\log n)\)</span>.</li></ul><p>对于算法的复杂度, 我们将证明如下定理:</p><blockquote><p><strong>THEOREM 2.</strong> 算法的渐进时间复杂度为 <span class="math inline">\(O^\sim(\log^{\frac{21}{2}}n)\)</span>.<br><strong>Proof.</strong> 按照算法步骤逐个讨论:<br>　　<code>Step 1</code>: 判断是否整数的幂.<br>　　　　　　时间复杂度 <span class="math inline">\(O^\sim(\log^3n)\)</span>, 参见 Mordern Computer Algebra. Cambridge Univ.;<br>　　<code>Step 2</code>: 求一个 <span class="math inline">\(r\)</span>, s.t. <span class="math inline">\(o_r(n)&gt;\log^2n\)</span>.<br>　　　　　　1. 取 <span class="math inline">\(r\)</span>, s.t. <span class="math inline">\(o_r(n)&gt;\log^2n\)</span>. 只需枚举 <span class="math inline">\(k\leqslant\log^2n\)</span>, 故至多需要 <span class="math inline">\(O(\log^2n)\)</span>.<br>　　　　　　2. 取定一个 <span class="math inline">\(r\)</span> 后, 至多进行 <span class="math inline">\(O(\log^2n)\)</span> 次模 <span class="math inline">\(r\)</span> 乘法, 开销至多 <span class="math inline">\(O^\sim(\log^2n\log r)\)</span>.<br>　　　　　　3. 由 <strong>LEMMA 4</strong>, 至多需要测试 <span class="math inline">\(O(\log^5n)\)</span> 个不同的 <span class="math inline">\(r\)</span>.<br>　　　　　　综上, <code>Step 2</code> 复杂度至多 <span class="math inline">\(O^\sim(\log^7n)\)</span>.<br>　　<code>Step 3</code>: 需要求 <span class="math inline">\(r\)</span> 次gcd.<br>　　　　　　1. 每次 gcd 的开销为 <span class="math inline">\(O(\log n)\)</span>.<br>　　　　　　2. <span class="math inline">\(r\)</span> 的开销为 <span class="math inline">\(O(\log^5n)\)</span>.<br>　　　　　　综上, <code>Step 3</code> 的复杂度为 <span class="math inline">\(O(r\log n)=O(\log^6n)\)</span>.<br>　　<code>Step 4</code>: 只需要比较 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(r\)</span> 大小.<br>　　　　　　时间复杂度 <span class="math inline">\(O(\log n)\)</span>.<br>　　<code>Step 5</code>: 验证 <span class="math inline">\(\lfloor\sqrt{\phi(r)}\log n\rfloor\)</span> 个多项式等式.<br>　　　　　　1. 每个等式次数都是 <span class="math inline">\(r\)</span>, 故单次验证的开销为 <span class="math inline">\(O^\sim(r\log^2 n)\)</span>.<br>　　　　　　2. 总复杂度为 <span class="math inline">\(O^\sim(r\sqrt{\phi(r)}\log^3n)\)</span>.<br>　　　　　　综上, <code>Step 5</code> 的复杂度为 <span class="math inline">\(O^\sim(r\sqrt{\phi(r)}\log^3n)=O^\sim(r^\frac{3}{2}\log^3n)=O^\sim(\log^\frac{21}{2}n)\)</span>.<br>　　<code>Step 6</code>: 这步啥也没干, 就返回了一个 <code>PRIME</code>.<br>　　　　　　时间复杂度 <span class="math inline">\(O(1)\)</span>.<br>　　<strong>综上, 算法的时间复杂度为 <span class="math inline">\(O(\log^\frac{21}{2}n)\)</span>.</strong></p></blockquote><p><strong>至此, 算法复杂度证明完毕.</strong></p><ul><li>貌似还有一些改进, 有点麻烦, 以后再说.</li></ul><h2 id="一些引理的证明细节">一些引理的证明细节</h2><blockquote><p><strong>LEMMA 1 Proof.</strong> <span class="math inline">\(\forall 0&lt;i&lt;n\)</span>, <span class="math inline">\(x^i\)</span> 在 <span class="math inline">\(((x+a)^n-(x^n+a))\)</span> 中的系数为 <span class="math inline">\(\binom{n}{i}a^{n-i}\)</span>.<br>- 若 <span class="math inline">\(n\)</span> 为素数, 则 <span class="math inline">\(\binom{n}{i}=0~({\rm mod~n})\)</span>, 故 <span class="math inline">\(\forall 0&lt;i&lt;n\)</span>, <span class="math inline">\(x^i\)</span> 系数均为 <span class="math inline">\(0\)</span>, 即原式成立.<br>- 若 <span class="math inline">\(n\)</span> 为合数, 取 <span class="math inline">\(q~\vert~n\)</span>, 且 <span class="math inline">\(q^k~||~n\)</span>. 则 <span class="math inline">\(q^k\)</span> 不能整除 <span class="math inline">\(\binom{n}{q}\)</span>, 且 <span class="math inline">\((q,a^{n-q})=1\)</span>. 故 <span class="math inline">\(x^q\)</span> 系数不为 <span class="math inline">\(0\)</span>. 故原式不成立.<br><strong>综上, 原式成立当且仅当 <span class="math inline">\(n\)</span> 是素数.</strong></p></blockquote><blockquote><p><strong>LEMMA 2 Proof.</strong> 考虑积分 <span class="math display">\[I(m,n)=\int_0^1 x^{m-1}(1-x)^{n-m}{\rm d}x\quad (1\leqslant m\leqslant n).\]</span> 一方面, 由 <span class="math inline">\((1-x)^{n-m}\)</span> 的展式可知 <span class="math inline">\(I(m,n)\)</span> 是分母整除 <span class="math inline">\({\rm LCM}(n)\)</span> 的有理数: <span class="math display">\[I(m,n)=\sum\limits_{0\leqslant j\leqslant n-m}(-1)^j\binom{n-m}{j}\frac{1}{m+j}\in\frac{1}{d_n}\mathbb{Z}.\]</span> 另一方面, 注意到 <span class="math inline">\(\forall 0\leqslant y\leqslant 1\)</span>, 有 <span class="math display">\[\sum\limits_{1\leqslant m\leqslant n}\binom{n-1}{m-1}y^{m-1}I(m,n)=\int_0^1(1-x+xy)^{n-1}{\rm d}x=\frac{1}{n}\sum\limits_{1\leqslant m\leqslant n}y^{m-1}.\]</span> 从而 <span class="math display">\[I(m,n)=\frac{1}{n}\binom{n-1}{m-1}=\frac{1}{m}\binom{n}{m}\quad (1\leqslant m\leqslant n).\]</span> 这说明对 <span class="math inline">\(1\leqslant m\leqslant n\)</span>, 有 <span class="math inline">\(m\binom{n}{m}~\vert~d_n\)</span>. 于是有 <span class="math display">\[\left.\left.n\binom{2n}{n}~\right|~{\rm LCM}(2n)~\right|~{\rm LCM}(2n+1)~~且~~\left.(n+1)\binom{2n+1}{n}=(2n+1)\binom{2n}{n}~\right|~{\rm LCM}(2n+1).\]</span> 由于 <span class="math inline">\((n,2n+1)=1\)</span>, 故 <span class="math display">\[\left.n(2n+1)\binom{2n}{n}~\right|~{\rm LCM}(2n+1).\]</span> 由于 <span class="math inline">\(\binom{2n}{n}\)</span> 是 <span class="math inline">\((1+x)^{2n}\)</span> 系数中最大的一项, 故 <span class="math display">\[{\rm LCM}(2n+1)\geqslant n4^n\quad (n\geqslant 1).\]</span> 从而 <span class="math display">\[{\rm LCM}(2n+1)\geqslant 2\cdot 4^n=2^{2n+1}\quad (n\geqslant 2).\]</span> 且 <span class="math display">\[{\rm LCM}(2n+2)\geqslant {\rm LCM}(2n+1)\geqslant 4^{n+1}\quad (n\geqslant 4).\]</span> 以上已经证明了对于 <span class="math inline">\(n\geqslant 9\)</span> 有 <span class="math inline">\({\rm LCM}(n)\geqslant 2^n\)</span>. 经验证 <span class="math inline">\(n=7,8\)</span> 也成立, <strong>于是原式对 <span class="math inline">\(\forall n\geqslant 7\)</span> 成立.</strong></p></blockquote><blockquote><p><strong>LEMMA 4 Proof.</strong> 当 <span class="math inline">\(n=2\)</span> 时, 取 <span class="math inline">\(r=3\)</span> 即可. 故以下假设 <span class="math inline">\(n&gt;2\)</span>, 即有 <span class="math inline">\(\lceil\log^5n\rceil&gt;10\)</span> 且 <strong>LEMMA 2</strong> 适用.<br><strong>先证存在 <span class="math inline">\(r\leqslant m\)</span>, s.t. <span class="math inline">\(r\not| N\)</span>, 其中 <span class="math display">\[N=n^{\lfloor \log m\rfloor}\cdot\prod\limits_{i=1}^{\lfloor\log^2n\rfloor}(n^i-1).\]</span></strong> 假设 <span class="math inline">\(r~\vert~N\)</span>, <span class="math inline">\(\forall 1\leqslant r\leqslant m\)</span>, 则有 <span class="math inline">\({\rm LCM}(m)\leqslant N\)</span>. 注意到 <span class="math display">\[\begin{align}N &amp;= n^{\lfloor \log m\rfloor}\cdot\prod\limits_{i=1}^{\lfloor\log^2n\rfloor}(n^i-1) \\&amp;&lt; n^{\lfloor \log m\rfloor}\cdot\prod\limits_{i=1}^{\lfloor\log^2n\rfloor}n^i \\&amp;= n^{\lfloor\log m\rfloor+1+2+\cdots+\log^2n} \\&amp;= n^{\lfloor\log m\rfloor+\frac{1}{2}[\log^2n(\log^2n+1)]} \\&amp;= n^{\lfloor\log m\rfloor+\frac{1}{2}[\log^4n+\log^2n]} \\&amp;&lt; n^{\log^4n} \\&amp;= (2^{\log n})^{\log^4n} \\&amp;= 2^{\log^5n} \leqslant 2^m.\end{align}\]</span> 故 <span class="math inline">\(N&lt;2^m\)</span>, 这与 <span class="math inline">\({\rm LCM}(m)\geqslant 2^m\)</span> 矛盾. 故集合 <span class="math inline">\(\{r~|~1\leqslant r\leqslant m,~r\not| N\}\)</span> 非空. <strong>设 <span class="math inline">\(r\)</span> 为其中的最小值.</strong><br><strong>至此我们已经找到了 <span class="math inline">\(r\leqslant m\)</span>, 以下只需证明 <span class="math inline">\(o_r(n)\)</span> 存在, 且 <span class="math inline">\(o_r(n)&gt;\log^2n\)</span>.</strong> 由于 <span class="math inline">\(o_r(n)\)</span> 存在当且仅当 <span class="math inline">\((r,n)=1\)</span>, 故只需证明 <span class="math inline">\(r\)</span> 与 <span class="math inline">\(n\)</span> 互素. 设 <span class="math inline">\(r=ab\)</span>, 其中 <span class="math inline">\(a\)</span> 由 <span class="math inline">\((n,r)\)</span> 的所有素因子组成, <span class="math inline">\(b\)</span> 由其他素因子组成, 即 <span class="math inline">\((a,b)=1\)</span>. 显然有 <span class="math inline">\((b,n)=1\)</span>.<br>注意到 <span class="math inline">\(a\)</span> 的任意素因子在 <span class="math inline">\(a\)</span> 中的最高幂次都不会超过 <span class="math inline">\(\lfloor\log m\rfloor\)</span>, 否则 <span class="math inline">\(a\leqslant r\)</span> 会超过 <span class="math inline">\(m\)</span>. 故 <span class="math inline">\(a\)</span> 的任意素因子在 <span class="math inline">\(a\)</span> 中的幂次都不超过在 <span class="math inline">\(n^{\lfloor\log m\rfloor}\)</span> 中的幂次, 故 <span class="math inline">\(a~|~n^{\lfloor\log m\rfloor}\)</span>.<br>另一方面, 有 <span class="math inline">\(b\not|n^{\lfloor \log m\rfloor}\cdot\prod\limits_{i=1}^{\lfloor\log^2n\rfloor}(n^i-1)\)</span> 且由 <span class="math inline">\((b,n)=1\)</span> 可知 <span class="math inline">\(b\not| n^{\lfloor\log m\rfloor}\)</span>. 故 <span class="math inline">\(b\not| N\)</span>. 然而由 <span class="math inline">\(r\)</span> 的定义可知, <span class="math inline">\(r\leqslant b\)</span>, 于是有 <span class="math inline">\(r=b\)</span>. 故 <span class="math inline">\((r,n)=1\)</span>, 故 <span class="math inline">\(o_r(n)\)</span> 存在.<br><strong>最后证明 <span class="math inline">\(o_r(n)&gt;\log^2n\)</span>:</strong> 假设 <span class="math inline">\(d=o_r(n)\leqslant\log^2n\)</span>, 则由定义有 <span class="math inline">\(n^d=1~({\rm mod}~r)\)</span>, 即 <span class="math inline">\(n^d-1=0~({\rm mod}~r)\)</span>, 故 <span class="math inline">\(n~|~(n^d-1)\)</span>. 即 <span class="math inline">\(r\)</span> 整除 <span class="math inline">\(N\)</span> 的一个因子 <span class="math inline">\(n^d-1\)</span>, 因而 <span class="math inline">\(r~|~N\)</span>, 矛盾! 于是有 <span class="math inline">\(o_r(n)&gt;\log^2n\)</span>.<br><strong>至此, 引理得证.</strong> <!-- 令 $r_1,\cdots,r_t$ 为所有满足 $o_{r_i}(n)\leqslant\log^2n$ 或 $r_i~\vert~n$ 的数. 则有$$r_i~\left|~\prod\limits_{i=1}^{\lfloor\log^2n\rfloor}(n^i-1)\right.<n^{\log^4n}\leqslant 2^{\log^5n}\quad \forall i.$$由 **LEMMA 2**, 有$${\rm LCM}(\lceil\log^5n\rceil)\geqslant 2^{\lceil\log^5n\rceil},$$故 $\exists s\leqslant\lceil\log^5n\rceil$, s.t. $s\notin\{r_1,\cdots,r_t\}$.  - 若 $(s,n)=1$, 则 $o_s(n)>\log^2n$, 引理得证.  - 若 $(s,n)>1$, 则由 $s\nmid n$ 且 $(s,n)\in\{r_1,\cdots,r_t\}$, 可知 $r=\frac{s}{(s,n)}\notin\{r_1,\cdots,r_t\}$. 故 $o_r(n)>\log^2n$.  **综上, 命题成立.** --></p></blockquote><blockquote><p><strong>LEMMA 7 Proof.</strong> 注意到 <span class="math inline">\(h(x)\)</span> 是 <span class="math inline">\(r\)</span> 次分圆多项式 <span class="math inline">\(Q_r(x)\)</span> 的一个因式, <span class="math inline">\(x\)</span> 为 <span class="math inline">\(F\)</span> 上的 <span class="math inline">\(r\)</span> 次本原单位根. 以下证明: <span class="math inline">\(P\)</span> 中任意两个不同的次数不超过 <span class="math inline">\(t\)</span> 的多项式在 <span class="math inline">\(\mathcal{G}\)</span> 中会对应到不同的元素.<br>设 <span class="math inline">\(f(x),g(x)\in P\)</span> 是这样的两个多项式. 假设 <span class="math inline">\(f(x)=g(x)\)</span> 在 <span class="math inline">\(F\)</span> 上成立. 取 <span class="math inline">\(m\in I\)</span>, 则在 <span class="math inline">\(F\)</span> 中有 <span class="math inline">\([f(x)]^m=[g(x)]^m\)</span>. 由于 <span class="math inline">\(m\)</span> 对 <span class="math inline">\(f\)</span> 和 <span class="math inline">\(g\)</span> 都是introspective的, 且 <span class="math inline">\(h(x)~\vert~x^r-1\)</span>, 故 <span class="math display">\[f(x^m)=g(x^m)\quad\text{in}~F.\]</span> 这说明 <span class="math inline">\(\forall m\in G\)</span>, <span class="math inline">\(x^m\)</span> 总是多项式 <span class="math inline">\(Q(y)=f(y)-g(y)\)</span> 的根. 由于 <span class="math inline">\(m\in G\subset\mathbb{Z}_r^*\)</span>, 故 <span class="math inline">\((m,r)=1\)</span>, 故每个这样的 <span class="math inline">\(x^m\)</span> 都是 <span class="math inline">\(r\)</span> 次本原单位根. 故这样得到了 <span class="math inline">\(Q(y)\)</span> 的 <span class="math inline">\(\vert G\vert=t\)</span> 个不同的根. 然而 <span class="math inline">\(Q(y)\)</span> 的次数小于 <span class="math inline">\(t\)</span>, 故根也少于 <span class="math inline">\(t\)</span> 个. 矛盾! 故在 <span class="math inline">\(F\)</span> 上有 <span class="math inline">\(f(x)\neq g(x)\)</span>.<br>注意到 <span class="math inline">\(l=\lfloor\sqrt{\phi(r)}\log n\rfloor&lt;\sqrt{r}\log n&lt;r\)</span> 且 <span class="math inline">\(p&gt;r\)</span>, 故 <span class="math inline">\(x,x+1,\cdots,x+l\)</span> 在 <span class="math inline">\(F\)</span> 中两两不等. 同时, 由 <span class="math inline">\(h(x)\)</span> 的次数大于 <span class="math inline">\(1\)</span> 可知, <span class="math inline">\(x+a\neq 0\)</span>, <span class="math inline">\(\forall 0\leqslant a\leqslant l\)</span>. 于是 <span class="math inline">\(\mathcal{G}\)</span> 中存在至少 <span class="math inline">\(l+1\)</span> 个一次多项式. <strong>故 <span class="math inline">\(\mathcal{G}\)</span> 中至少存在 <span class="math inline">\(\binom{t+l}{t-1}\)</span> 个次数小于 <span class="math inline">\(t\)</span> 的多项式.</strong></p></blockquote><blockquote><p><strong>LEMMA 8 Proof.</strong> 考虑 <span class="math inline">\(I\)</span> 的以下子集: <span class="math display">\[\hat{I}=\{(\frac{n}{p})^i\cdot p^j~\vert~0\leqslant i,j\leqslant\lfloor\sqrt{t}\rfloor\}.\]</span> 若 <span class="math inline">\(n\)</span> 不是 <span class="math inline">\(p\)</span> 的方幂, 则 <span class="math inline">\(\hat{I}\)</span> 有 <span class="math inline">\((\lfloor\sqrt{t}\rfloor+1)^2&gt;t\)</span> 个不同元素.<br>由于 <span class="math inline">\(|G|=t\)</span>, 故由抽屉原理可知 <span class="math inline">\(\hat{I}\)</span> 中至少存在 <span class="math inline">\(2\)</span> 个元素模 <span class="math inline">\(r\)</span> 同余. 令其为 <span class="math inline">\(m_1,m_2\)</span>, 不妨设 <span class="math inline">\(m_1&gt;m_2\)</span>. 则有: <span class="math display">\[x^{m_1}=x^{m_2}~({\rm mod}~x^r-1).\]</span> 令 <span class="math inline">\(f(x)\in P\)</span>, 则 <span class="math display">\[\begin{align}[f(x)]^{m_1} &amp;= f(x^{m_1})~({\rm mod}~x^r-1,p) \\&amp;= f(x^{m_2})~({\rm mod}~x^r-1,p) \\&amp;= [f(x)]^{m_2}~({\rm mod}~x^r-1,p).\end{align}\]</span> 即在 <span class="math inline">\(F\)</span> 上有 <span class="math inline">\([f(x)]^{m_1}=[f(x)]^{m_2}\)</span>. 于是 <span class="math inline">\(f(x)\in\mathcal{G}\)</span> 是多项式 <span class="math inline">\(Q&#39;(y)=y^{m_1}-y^{m_2}\)</span> 在 <span class="math inline">\(F\)</span> 中的一个根. 由于 <span class="math inline">\(f(x)\)</span> 是 <span class="math inline">\(\mathcal{G}\)</span> 中的任意一个元素, 故 <span class="math inline">\(Q&#39;(y)\)</span> 在 <span class="math inline">\(F\)</span> 中至少有 <span class="math inline">\(|\mathcal{G}|\)</span> 个不同的根. 而 <span class="math display">\[{\rm deg}~Q&#39;(y)=m_1\leqslant (\frac{n}{p}\cdot p)^{\lfloor\sqrt{t}\rfloor}.\]</span> <strong>即 <span class="math inline">\(|\mathcal{G}|\leqslant n^{\lfloor\sqrt{t}\rfloor}.\)</span></strong></p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 计算机 </tag>
            
            <tag> 北大 </tag>
            
            <tag> 抽象代数 </tag>
            
            <tag> 论文笔记 </tag>
            
            <tag> 保研 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>复变函数拾遗[2]——多值函数的解析分支</title>
      <link href="/2018/04/12/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E6%8B%BE%E9%81%97-2-%E2%80%94%E2%80%94%E5%A4%9A%E5%80%BC%E5%87%BD%E6%95%B0%E7%9A%84%E8%A7%A3%E6%9E%90%E5%88%86%E6%94%AF/"/>
      <content type="html"><![CDATA[<p>大致分为两部分:</p><ul><li>多值函数解析分支的定义;</li><li>多值函数解析分支的讨论.</li></ul><a id="more"></a><h2 id="多值函数解析分支的定义">多值函数解析分支的定义</h2><h3 id="解析分支定义">解析分支定义</h3><blockquote><p><strong>DEFINITION 1.</strong> 设 <span class="math inline">\(\Omega\)</span> 为区域, <span class="math inline">\(\mathbf{F}(z)\)</span> 为 <span class="math inline">\(\Omega\)</span> 上的多值函数, 如果 <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 解析, 且对 <span class="math inline">\(\forall z\in\Omega\)</span>, 有 <span class="math inline">\(f(z)\in\mathbf{F}(z)\)</span>, 则称 <span class="math inline">\(f\)</span> 为 <span class="math inline">\(\mathbf{F}\)</span> 在 <span class="math inline">\(\Omega\)</span> 上的解析分支.</p></blockquote><h3 id="多值函数的本质">多值函数的本质</h3><p>这里的论述可能不太严格.</p><p>考虑复数的三角式: <span class="math display">\[z=\vert z\vert e^{i~{\rm arg}~z}.\]</span> 由于 <span class="math inline">\(e^{2\pi i}=1\)</span>, 故 <span class="math inline">\(\vert z\vert e^{i~{\rm arg}~z}=\vert z\vert e^{i~({\rm arg}~z+2k\pi)}\)</span>. 即 <span class="math inline">\(z\)</span> 的辐角 <span class="math inline">\(\mathbf{Arg}~z\)</span> 是一个多值函数.<br>由于辐角函数是一个多值函数, 这就导致了多值函数的存在. 多值函数的不同解析分支实际上也对应了 <span class="math inline">\(\mathbf{Arg}~z\)</span> 的不同取值.</p><h3 id="辐角函数的连续分支">辐角函数的连续分支</h3><blockquote><p><strong>PROPOSITION 1.</strong> 设 <span class="math inline">\(\Omega\)</span> 为单连通区域, <span class="math inline">\(z_0\notin\Omega\)</span>, 则 <span class="math inline">\(\mathbf{Arg}~(z-z_0)\)</span> 在区域 <span class="math inline">\(\Omega\)</span> 上有连续分支 <span class="math inline">\({\rm arg}~(z-z_0)\)</span>, 且 <span class="math inline">\(\mathbf{Arg}~(z-z_0)\)</span> 在 <span class="math inline">\(\Omega\)</span> 上的所有连续分支如下: <span class="math display">\[\mathbf{Arg}~(z-z_0)=\{ {\rm arg}~(z-z_0)+2k\pi:k\in\mathbb{Z}\}.\]</span> 于是 <span class="math inline">\(\mathbf{Arg}~(z-z_0)\)</span> 在 <span class="math inline">\(\Omega\)</span> 内有无穷多个连续分支.</p></blockquote><h2 id="几个解析分支的例子">几个解析分支的例子</h2><h3 id="对数函数的解析分支">对数函数的解析分支</h3><blockquote><p><strong>THEOREM 1.</strong> 设 <span class="math inline">\(\Omega\)</span> 为单连通区域, <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 中解析且处处不为零, 则 <span class="math inline">\(\mathbf{Ln}~f(z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 有解析分支 <span class="math inline">\(g(z)\)</span>, s.t. <span class="math display">\[e^{g(z)}=f(z),\]</span> 且 <span class="math inline">\(\mathbf{Ln}~f(z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 上所有的解析分支都具有形式 <span class="math inline">\(g(z)+2k\pi i\)</span>, 即: <span class="math display">\[\mathbf{Ln}~f(z)=\{g(z)+2k\pi i:k\in\mathbb{Z}\}.\]</span> 即 <span class="math inline">\(\mathbf{Ln}~f(z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 有无穷多个解析分支.</p></blockquote><p><strong>简略证明:</strong><br>　　从三角式的角度考虑非常显然:<br><span class="math display">\[\begin{align}{\bf Ln}~(z) &amp;= \{\ln~(\vert z\vert e^{i~({\rm arg}~z+2k\pi)})\} \\ &amp;= \{\ln~\vert z\vert+ i({\rm arg}~z+2k\pi)\} \\ &amp;= \{\ln\vert z\vert +i~{\rm arg}~z+2k\pi i:k\in\mathbb{Z}\}.\end{align}\]</span></p><h3 id="幂函数的解析分支">幂函数的解析分支</h3><h4 id="解析函数-n-次方根的解析分支">解析函数 <span class="math inline">\(n\)</span> 次方根的解析分支</h4><blockquote><p><strong>THEOREM 2.</strong> 设 <span class="math inline">\(n\geqslant 2\in\mathbb{N}\)</span>, <span class="math inline">\(\Omega\)</span> 为单连通区域, <span class="math inline">\(z_0\notin\Omega\)</span>, <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 中解析且处处不为零, 则 <span class="math inline">\((f(z))^\frac{1}{n}\)</span> 在 <span class="math inline">\(\Omega\)</span> 上有解析分支 <span class="math inline">\(g(z)\)</span>, 其所有解析分支为 <span class="math inline">\(g(z)e^{\frac{2k\pi i}{n}}\)</span>. 即: <span class="math display">\[(f(z))^\frac{1}{n}=\{g(z)e^{\frac{2k\pi i}{n}}: k=0,1,\cdots,n-1\}.\]</span> 即 <span class="math inline">\((f(z))^\frac{1}{n}\)</span> 在 <span class="math inline">\(\Omega\)</span> 有 <span class="math inline">\(n\)</span> 个解析分支.</p></blockquote><p><strong>简略证明:</strong><br>　　从三角式的角度考虑也是非常显然的. 细节略去.</p><ul><li>解析函数 <span class="math inline">\(n\)</span> 次方根的解析分支可进一步推广为幂函数的解析分支. 懒得细写了, 以后再说.</li></ul><h4 id="幂函数的解析分支-1">幂函数的解析分支</h4><p>再说吧..</p><h2 id="三角函数">三角函数</h2><h3 id="三角函数-1">三角函数</h3><p>只讨论 <span class="math inline">\(\sin\)</span> 和 <span class="math inline">\(\cos\)</span>:</p><ol type="1"><li><span class="math inline">\(2i\sin z=e^{iz}-e^{-iz}\)</span>, <span class="math inline">\(2\cos z=e^{iz}+e^{-iz}\)</span>.</li><li><span class="math inline">\(\sin\)</span>, <span class="math inline">\(\cos\)</span> 在复平面上都是解析的. 更一般地, 所有三角函数在有意义的点都是解析的.</li><li><span class="math inline">\(\sin\)</span> 和 <span class="math inline">\(\cos\)</span> 都以 <span class="math inline">\(2\pi\)</span> 为周期.</li><li><span class="math inline">\(\sin z\)</span> 的零点为 <span class="math inline">\(z=n\pi~n\in\mathbb{Z}\)</span>.</li><li><span class="math inline">\(\cos z\)</span> 的零点为 <span class="math inline">\(z=(n+\frac{1}{2})\pi~n\in\mathbb{Z}\)</span>.</li><li>大部分实数中的结论(如导数, 三角恒等式)都仍然适用.</li></ol><h3 id="双曲函数">双曲函数</h3><p>只讨论 <span class="math inline">\(\sinh z\)</span> 和 <span class="math inline">\(\cosh\)</span>:</p><ol type="1"><li><span class="math inline">\(\sinh z=\frac{e^{z}-e^{-z}}{2}\)</span>, <span class="math inline">\(\cosh z=\frac{e^{z}+e^{-z}}{2}\)</span>;</li><li>由 <span class="math inline">\(e^{z}\)</span> 的周期性, 二者都以 <span class="math inline">\(2\pi i\)</span> 为周期.</li></ol><h3 id="反三角函数">反三角函数</h3><p>反三角函数是多值函数.</p><blockquote><p><strong>DEFINITION 2.</strong> 反三角函数定义如下:<br>　　反正弦函数: <span class="math display">\[{\bf Arcsin}~z=\{w\in\mathbb{C}:\sin w=z\};\]</span> 　　反余弦函数: <span class="math display">\[{\bf Arccos}~z=\{w\in\mathbb{C}:\cos w=z\};\]</span> 　　反正切函数: <span class="math display">\[{\bf Arctan}~z=\{w\in\mathbb{C}:\tan w=z\};\]</span></p></blockquote><p>有如下表示:</p><blockquote><p><strong>PROPOSITION 2.</strong> 反三角函数有如下表示: <span class="math display">\[\begin{align}{\bf Arcsin}~z &amp;= -i{\bf Ln}(iz+(1-z^2)^\frac{1}{2}), \\{\bf Arccos}~z &amp;= -i{\bf Ln}(z+(1-z^2)^\frac{1}{2}), \\{\bf Arctan}~z &amp;= \frac{1}{2i}{\bf Ln}~\frac{1+iz}{1-iz}.\end{align}\]</span></p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 复变函数 </tag>
            
            <tag> 保研 </tag>
            
            <tag> 保研复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>复变函数拾遗[1]——Cauchy定理与最大模原理</title>
      <link href="/2018/04/11/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E6%8B%BE%E9%81%97-1-%E2%80%94%E2%80%94Cauchy%E9%AB%98%E9%98%B6%E6%B1%82%E5%AF%BC%E5%85%AC%E5%BC%8F/"/>
      <content type="html"><![CDATA[<p>解析函数的积分与Cauchy高阶求导公式.</p><a id="more"></a><h2 id="单连通情形的cauchy定理">单连通情形的Cauchy定理</h2><h3 id="goursat定理">Goursat定理</h3><blockquote><p><strong>THEOREM 1.</strong> 设 <span class="math inline">\(\Omega\)</span> 是一个单连通区域, <span class="math inline">\(f(z)\)</span> 在其中解析, 则 <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 中有原函数且对全在 <span class="math inline">\(\Omega\)</span> 中的任意Jordan闭分段光滑曲线, 都有 <span class="math display">\[\int_Cf(z){\rm d}z=0.\]</span></p></blockquote><h3 id="cauchy高阶求导公式">Cauchy高阶求导公式</h3><blockquote><p><strong>THEOREM 2.</strong> 设 <span class="math inline">\(\Omega\)</span> 是一个<strong>单连通区域</strong>, <span class="math inline">\(C\)</span> 是全在 <span class="math inline">\(\Omega\)</span> 中的闭Jordan分段光滑曲线, <span class="math inline">\(C\)</span> 所围区域是 <span class="math inline">\(\omega\)</span>. 如果 <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 内解析, 则如下Cauchy公式 <span class="math display">\[f(z_0)=\frac{1}{2\pi i}\int_C\frac{f(z){\rm d}z}{z-z_0}\quad (z_0\in\omega).\]</span> 成立, 且对 <span class="math inline">\(\forall m\in\mathbb{Z}^+\)</span>, <span class="math inline">\(f\)</span> 的 <span class="math inline">\(m\)</span> 阶复导数 <span class="math inline">\(f^{(m)}(z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 内存在并解析, 且如下Cauchy求导公式成立 <span class="math display">\[f^{(m)}(z_0)=\frac{1}{2\pi i}\int_C\frac{f(z){\rm d}z}{(z-z_0)^{m+1}}\quad (z_0\in\omega,~m\in\mathbb{Z}^+).\]</span></p></blockquote><p><strong>简略证明:</strong><br>　　只证第一式. 设 <span class="math inline">\(z_0\in\omega\)</span>, 则 <span class="math inline">\(\exists\epsilon_0&gt;-\)</span>, s.t. <span class="math inline">\(\overline{D(z_0,\epsilon_0)}\subset\omega\)</span>, 对 <span class="math inline">\(\forall\epsilon\in(0,\epsilon_0)\)</span>, <span class="math inline">\(\exists\)</span> 有向线段 <span class="math inline">\([a,b]\in\overline{\omega}\)</span>, 其中 <span class="math inline">\(a\in\partial D(z_0\epsilon_0)\)</span>, <span class="math inline">\(b\in\partial\omega\)</span>. 假设 <span class="math inline">\(b\)</span> 为 <span class="math inline">\(C\)</span> 的起点和终点, 则 <span class="math display">\[[b\to a]\to\partial D(z_0,\epsilon_0)\to[a\to b]\to[C:b\to b]\]</span> 首尾相接构成一条分段光滑曲线.</p><p>由于 <span class="math inline">\(\frac{f(z)}{z-a}\)</span> 在 <span class="math inline">\(\Omega\backslash\{z_0\}\)</span> 解析, 故 <span class="math display">\[\int_C\frac{f(z)}{z-z_0}{\rm d}z+\int_{[a,b]}\frac{f(z)}{z-z_0}{\rm d}z+\int_{[b,a]}\frac{f(z)}{z-z_0}{\rm d}z-\int_{\partial D(z_0,\epsilon_0)}\frac{f(z)}{z-z_0}{\rm d}z=0.\]</span> 从而 <span class="math display">\[\int_C \frac{f(z)}{z-z_0}{\rm d}z=\int_{\partial D(z_0,\epsilon_0)}\frac{f(z)}{z-z_0}{\rm d}z=\int_0^{2\pi} f(z_0+\epsilon e^{i\theta})i{\rm d}\theta\to 2\pi if(z_0)~~(\epsilon\to 0).\]</span> 　　第二式可由数学归纳法证得.</p><h3 id="cauchy积分定理的推广">Cauchy积分定理的推广</h3><blockquote><p><strong>THEOREM 3.</strong> 设 <span class="math inline">\(C\)</span> 为一条Jordan闭分段光滑曲线, <span class="math inline">\(\Omega={\rm int}~C\)</span>, <span class="math inline">\(f(z)\)</span> 在闭域 <span class="math inline">\(\overline{\Omega}=\Omega\cup C\)</span> 解析, 则 <span class="math display">\[\int_C f(z){\rm d}z=0.\]</span></p></blockquote><h2 id="多连通情形的cauchy定理">多连通情形的Cauchy定理</h2><h3 id="多连通情形的cauchy定理-1">多连通情形的Cauchy定理</h3><p>多连通的情况下, 仍然有如下的Cauchy定理:</p><blockquote><p><strong>THEOREM 4.</strong> 设 <span class="math inline">\(\Omega\)</span> 是由复围线(大圈 <span class="math inline">\(C_0\)</span> 挖掉 <span class="math inline">\(n\)</span> 个不相交小圈 <span class="math inline">\(C_i\)</span>) <span class="math display">\[\partial\Omega=C_0+C_1^-+\cdots+C_n^-\]</span> 所围成的有界多连通区域, <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(\overline{\Omega}\)</span> 中解析, 则 <span class="math display">\[\int_{\partial\Omega}f(z){\rm d}z=0.\]</span></p></blockquote><h3 id="多连通情形的cauchy求导公式">多连通情形的Cauchy求导公式</h3><blockquote><p><strong>THEOREM 5.</strong> 设 <span class="math inline">\(\Omega\)</span> 是由复围线(大圈 <span class="math inline">\(C_0\)</span> 挖掉 <span class="math inline">\(n\)</span> 个不相交小圈 <span class="math inline">\(C_i\)</span>) <span class="math display">\[\partial\Omega=C_0+C_1^-+\cdots+C_n^-\]</span> 所围成的有界多连通区域, <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(\overline{\Omega}\)</span> 中解析, 则 <span class="math display">\[f^{(n)}(z)=\frac{n!}{2\pi i}\int_{\partial\Omega}\frac{f(\zeta){\rm d}\zeta}{(\zeta-z)^{n+1}}\quad (z\in\Omega,~n\in\mathbb{N}).\]</span></p></blockquote><h2 id="cauchy定理的应用">Cauchy定理的应用</h2><h3 id="解析函数均值定理">解析函数均值定理</h3><blockquote><p><strong>THEOREM 6.</strong> 若函数 <span class="math inline">\(f(z)\)</span> 在圆盘 <span class="math inline">\(\vert z-z_0\vert&lt;R\)</span> 中解析, 在闭圆盘 <span class="math inline">\(\vert z-z_0\vert\leqslant R\)</span> 连续, 则 <span class="math display">\[f(z_0)=\frac{1}{2\pi}\int_0^{2\pi} f(z_0+Re^{i\theta}){\rm d}\theta.\]</span> 即在圆心 <span class="math inline">\(z_0\)</span> 的值为圆周上的平均.</p></blockquote><p><strong>简略证明:</strong><br>　　由Cauchy公式, 有 <span class="math display">\[f(z_0)=\frac{1}{2\pi i}\int_{\partial D(z_0,r)} \frac{f(z){\rm d}z}{z-z_0}.\]</span> 其中 <span class="math inline">\(0&lt;r&lt;R\)</span>, 而 <span class="math inline">\(\partial D(z_0,r)\)</span> 的方程为 <span class="math inline">\(z=z_0+re^{i\theta},~0\leqslant\theta\leqslant\pi\)</span>, 从而 <span class="math display">\[f(z_0)=\frac{1}{2\pi i}\int_0^{2\pi}\frac{f(z_0+re^{i\theta})rie^{i\theta}{\rm d}\theta}{re^{i\theta}}.\]</span> 由于 <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(\overline{D(z_0,R)}\)</span> 一致连续, 故令 <span class="math inline">\(r\to R\)</span> 即可.</p><h3 id="推论-cauchy不等式">推论: Cauchy不等式</h3><blockquote><p><strong>THEOREM 7.</strong> 设 <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 内解析, <span class="math inline">\(a\in\Omega\)</span>, 若 <span class="math inline">\(\overline{D(a,R)}=\{z:\vert z-a\vert\leqslant R\}\subset\Omega\)</span>, 则有 <span class="math display">\[\vert f^{(n)}(a)\vert\leqslant\frac{n!M(R)}{R^n}\quad (n\in\mathbb{N}),\]</span> 其中 <span class="math display">\[M(R)=\max\{\vert f(z)\vert:\vert z-a\vert=R\}.\]</span></p></blockquote><p><strong>简略证明:</strong><br>　　由<strong>TH 2.</strong> 有: <span class="math display">\[\begin{align}\vert f^{(n)}(a)\vert &amp;= \left|\frac{n!}{2\pi i}\int_{\partial D(a,R)}\frac{f(z){\rm d}z}{(z-a)^{m+1}}\right| \\ &amp;= \left| \frac{n!}{2\pi}\int_0^{2\pi}\frac{f(a+re^{i\theta}){\rm d}\theta}{r^ne^{in\theta}} \right| \\ &amp;\leqslant \frac{n!M(R)}{R^n}. \\\end{align}\]</span></p><h4 id="liouville定理">Liouville定理</h4><blockquote><p><strong>THEOREM 8.</strong> 有界整函数必定是常函数.</p></blockquote><p><strong>简略证明:</strong><br>　　设 <span class="math inline">\(f(z)\)</span> 是有界整函数, 则 <span class="math inline">\(\exists M&gt;0\)</span>, s.t. <span class="math display">\[\vert f(z)\vert\leqslant M.\]</span> 任取 <span class="math inline">\(a\in\mathbb{C}\)</span>, 则对 <span class="math inline">\(\forall R&gt;1\)</span>, 由Cauchy不等式有: <span class="math display">\[\vert f&#39;(a)\vert\leqslant\frac{M}{R^n}.\]</span> 令 <span class="math inline">\(R\to\infty\)</span>, 则 <span class="math inline">\(f&#39;(a)=0\)</span>, 从而 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(\mathbb{C}\)</span> 中为常数.</p><h3 id="最大模原理">最大模原理</h3><blockquote><p><strong>THEOREM 9.</strong> 设函数 <span class="math inline">\(f(z)\)</span> 在有界区域 <span class="math inline">\(\Omega\)</span> 解析, 并连续到边界 <span class="math inline">\(\partial\Omega\)</span> 上. 设 <span class="math inline">\(M=\max\{\vert f(z)\vert: z\in\overline{\Omega}\}\)</span>, 则在 <span class="math inline">\(\Omega\)</span> 内有 <span class="math inline">\(\vert f(z)\vert&lt;M\)</span>, 除非 <span class="math inline">\(f(z)=Me^{i\alpha}\)</span>. 此处 <span class="math inline">\(M\)</span>, <span class="math inline">\(a\)</span> 为常数.</p></blockquote><ul><li>最大模原理实际上是说: 解析函数必定在边界取最大模.</li></ul>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 复变函数 </tag>
            
            <tag> 保研 </tag>
            
            <tag> 保研复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论文笔记[1]——随机分配问题的PS算法和依次有效性</title>
      <link href="/2018/04/05/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-1-%E2%80%94%E2%80%94A%20New%20Solution%20to%20the%20Random%20Assignment%20Problem/"/>
      <content type="html"><![CDATA[<blockquote><p>文章: Bogomolnaia A, Moulin H. A New Solution to the Random Assignment Problem[J]. Journal of Economic Theory, 2001, 100(2):295-328.</p></blockquote><ul><li><span class="math inline">\(n\)</span> 个物品被分配给 <span class="math inline">\(n\)</span> 个人的问题, 称为<strong>分配问题</strong>. 生活中此类问题常采取抽签方式解决. 在此基础上可归纳出一种RP算法.</li><li>文章对已有的RP算法进行了讨论, 并提出了一种新的分配方法, PS算法.</li></ul><a id="more"></a><h2 id="分配问题">分配问题</h2><blockquote><p><strong>分配问题</strong>: <span class="math inline">\(n\)</span> 个物品被分配给 <span class="math inline">\(n\)</span> 个人的问题, 称为分配问题.</p></blockquote><p>分配中, 每个人都对这 <span class="math inline">\(n\)</span> 个东西有一个偏好顺序. 此处假定每个人的偏好关系是严格的, 即每个人对任何两个物品都有一个严格的排序.</p><h2 id="随机优先rp算法">随机优先(RP)算法</h2><blockquote><p><strong>RP</strong> <span class="math inline">\(n\)</span> 个人随机选定一个选择的顺序, 按照顺序在 <span class="math inline">\(n\)</span> 个物品中选择.</p></blockquote><p>很容易发现RP算法有以下两点好处:</p><ul><li>RP算法看起来是比较<strong>公平</strong>的;</li><li><span title="若某个人在选择中撒了谎, 则他最终获得的一定不是他所能得到的最好选择, 故撒谎没有好处.">RP算法是<strong>无操作</strong>(Strategyproofness)的, 即大家都会选择说真话.</span></li></ul><p>但用<code>VNM效用</code>函数去分析时, RP算法存在缺陷.</p><blockquote><p><strong>VNM效用</strong> 设某人得到物品 <span class="math inline">\(x_i\)</span> 的概率为 <span class="math inline">\(P_i\)</span>, 在得到 <span class="math inline">\(x_i\)</span> 时的效用为 <span class="math inline">\(u(x_i)\)</span>, 则其VNM效用为 <span class="math display">\[U(X)=\sum_i P_i u(x_i)\]</span></p></blockquote><p>分析可知:</p><ul><li><strong>在使VNM效用最大化的意义下, RP算法并不总是最优的.</strong></li></ul><p>但RP算法具有如下两个优势:</p><ol type="1"><li>事后有效 (ex post efficient): 每次分配确定的方案都是Pareto最优的. <span title="每个人都会在选择时选当前最优的物品, 若为增大某人利益而进行了一些改变, 则至少有一个人的利益会损害. (写的有点不太像人话Orz)">即增大某人利益的同时一定会损害其他人的利益.</span></li><li>算法简单: RP算法在分配时, 每一轮只需要考虑一个人的偏好.</li></ol><h2 id="概率序列ps算法">概率序列(PS)算法</h2><p>考虑一个例子:</p><blockquote><ul><li>参与者1, 2: <span class="math inline">\(a\succ b\succ c\succ d\)</span>;<br></li><li>参与者3, 4: <span class="math inline">\(b\succ a\succ d\succ c\)</span>.</li></ul></blockquote><p>则RP算法的概率矩阵为 <span class="math inline">\(A\)</span>(每行代表一个人, 每列代表一样物品). 然而考虑 <span class="math inline">\(B\)</span> 可知, 无论效用函数的形式如何, 概率矩阵 <span class="math inline">\(B\)</span> 都比RP算法得到的结果要好. <span class="math display">\[A=\begin{bmatrix}\frac{5}{12}&amp;\frac{1}{12}&amp;\frac{5}{12}&amp;\frac{1}{12}\\ \frac{5}{12}&amp;\frac{1}{12}&amp;\frac{5}{12}&amp;\frac{1}{12}\\ \frac{1}{12}&amp;\frac{5}{12}&amp;\frac{1}{12}&amp;\frac{5}{12}\\ \frac{1}{12}&amp;\frac{5}{12}&amp;\frac{1}{12}&amp;\frac{5}{12}\\ \end{bmatrix},~B=\begin{bmatrix}\frac{1}{2}&amp;0&amp;\frac{1}{2}&amp;0\\ \frac{1}{2}&amp;0&amp;\frac{1}{2}&amp;0\\ 0&amp;\frac{1}{2}&amp;0&amp;\frac{1}{2}\\ 0&amp;\frac{1}{2}&amp;0&amp;\frac{1}{2}\\ \end{bmatrix}\]</span></p><p><span class="math inline">\(B\)</span> 矩阵的获取可从如下角度考虑:</p><p>在分配中, 将每个物品都视为一种食物, 偏好关系表示对食物的喜好. 所有的人同时开始以相同速率(不妨设为1)吃东西. 每个人都会优先吃自己最喜欢的食物. 当一样食物被吃完时, 该食物即被分配给吃该食物量最多的人.</p><h2 id="ps算法的有效性">PS算法的有效性</h2><h3 id="形式化定义">形式化定义</h3><p>设参与者的集合为 <span class="math inline">\(N\)</span>, 物品集合为 <span class="math inline">\(A\)</span>, 集合大小为 <span class="math inline">\(\vert N\vert=\vert A\vert=n\)</span>.</p><h4 id="确定性分配与随机性分配">确定性分配与随机性分配</h4><ul><li>Deterministic Assignment: <span class="math inline">\(N\to A\)</span> 的一一映射, 可用 <span class="math inline">\(n\times n\)</span> 的置换矩阵表示. 记这样的分配构成的集合为 <span class="math inline">\(\mathscr{D}\)</span>;</li><li>Random Allocation: <span class="math inline">\(A\)</span> 上的概率分布, 可用各个分量和为1的 <span class="math inline">\(n\)</span> 维向量表示. 记这样的分配构成的集合为 <span class="math inline">\(\mathscr{L}(A)\)</span>;</li><li>Random Assignment: <span class="math inline">\(\mathscr{D}\)</span> 上的概率分布, 可用一个 <span class="math inline">\(n\times n\)</span> 的双随机矩阵(Bistochastic)表示. 即: <span class="math display">\[P=[p_{ia}]_{i\in N,a\in A}~~其中~~P=\sum\limits_{\Pi\in D}\lambda_\Pi\cdot\Pi,~\lambda_\Pi\geqslant 0,~\sum_\Pi\lambda_\Pi=1\]</span>矩阵的第 <span class="math inline">\(i\)</span> 行 <span class="math inline">\(P_i\)</span> 对应第 <span class="math inline">\(i\)</span> 个人的Random Allocation. <span class="math inline">\(p_{ia}\)</span> 表示 <span class="math inline">\(i\)</span> 得到物品 <span class="math inline">\(a\)</span> 的概率. 双随机矩阵构成的集合记为 <span class="math inline">\(\mathscr{R}\)</span>.</li></ul><blockquote><p><strong>双随机矩阵</strong>可定义为: 每行每列和都为 <span class="math inline">\(1\)</span> 的矩阵. 如此可得到以下结论:<br>1. 第 <span class="math inline">\(i\)</span> 行可视为编号为 <span class="math inline">\(i\)</span> 的人对于 <span class="math inline">\(A\)</span> 中物品的效用分布;<br>2. 第 <span class="math inline">\(j\)</span> 列可视为 <span class="math inline">\(N\)</span> 中的每个人得到编号为 <span class="math inline">\(j\)</span> 的物品的可能性.</p></blockquote><h4 id="效用函数与偏好关系">效用函数与偏好关系</h4><ul><li>Preference: 每个参与者对物品都存在一个严格的偏好关系, 即对应于 <span class="math inline">\(A\)</span> 上的一个序关系 <span class="math inline">\(\succ_i\)</span>. 记所有这样的偏好关系构成的集合为 <span class="math inline">\(\mathscr{A}\)</span>;</li><li>VNM Utility: 每个参与者拿到 <span class="math inline">\(A\)</span> 中的一件物品时, 产生的效用可视作 <span class="math inline">\(A\to\mathbb{R}\)</span> 的函数, 记作 <span class="math inline">\(u_i\)</span>. 效用函数实际上是偏好程度的量化.</li></ul><blockquote><p>称效用函数 <span class="math inline">\(u_i\)</span> 和偏好关系 <span class="math inline">\(\succ_i\)</span> 是<strong>相容</strong>(compatible)的, 如果 <span class="math display">\[u_i(a)&gt;u_i(b)\iff a\succ_ib,~\forall a,b\in A.\]</span></p></blockquote><h3 id="确定性分配的有效性">确定性分配的有效性</h3><ul><li>Priority Assignment: 考虑偏好关系 <span class="math inline">\(\succ=\{\succ_i\}_{i\in N}\)</span>, 设 <span class="math inline">\(\sigma\)</span> 是 <span class="math inline">\(N\)</span> 的一个排列, 则按 <span class="math inline">\(\sigma\)</span> 的顺序进行分配即可得到一个分配方案, 即Priority Assignment. 记作 <span class="math inline">\(Prio(\sigma,\succ)\)</span>;</li></ul><center><strong>以下记 <span class="math inline">\(N\)</span> 的所有排列构成的集合为 <span class="math inline">\(\theta\)</span>.</strong></center><blockquote><p>一个Deterministic Assignment <span class="math inline">\(\Pi\)</span> 称为有效的, 如果<span class="math display">\[\exists\sigma\in\theta,~ \text{s.t.}~ \Pi=Prio(\sigma,\succ).\]</span></p></blockquote><p>关于确定性分配的有效性, 很容易得到下述引理:</p><blockquote><p><strong>LEMMA 1.</strong> 给定偏好关系 <span class="math inline">\(\succ\in\mathscr{A}^N\)</span> 和确定性分配 <span class="math inline">\(\Pi\)</span>, 则下列命题等价:<br>1. <span class="math inline">\(\Pi\)</span> 在 <span class="math inline">\(\mathscr{D}\)</span> 中是Pareto最优的;<br>2. <span class="math inline">\(\forall\)</span> 效用函数组 <span class="math inline">\(u=\{u_i\}\)</span>, <span class="math inline">\(\Pi\)</span> 在 <span class="math inline">\(\mathscr{R}\)</span> 中对 <span class="math inline">\(u\)</span> 是Pareto最优的;<br>3. <span class="math inline">\(\exists\sigma\in\theta\)</span>, s.t. <span class="math inline">\(\Pi=Prio(\sigma,\succ)\)</span>.</p></blockquote><h3 id="随机性分配的有效性">随机性分配的有效性</h3><p>首先定义事前评估有效(ex ante efficient)和事后评估有效(ex post efficient):</p><blockquote><p><strong>Definition 1.</strong> 给定随机性分配 <span class="math inline">\(P\in\mathscr{R}\)</span>, 偏好关系组 <span class="math inline">\(\succ\in\mathscr{A}^N\)</span> 和VNM效用函数组 <span class="math inline">\(u\)</span>, 则有定义:<br>1. <span class="math inline">\(P\)</span> 对 <span class="math inline">\(u\)</span> 是<strong>事前评估有效</strong>的, iff <span class="math inline">\(P\)</span> 在 <span class="math inline">\(\mathscr{R}\)</span> 中对 <span class="math inline">\(u\)</span> 是Pareto最优的;<br>2. <span class="math inline">\(P\)</span> 对 <span class="math inline">\(\succ\)</span> 是<strong>事后评估有效</strong>的, iff <span class="math inline">\(P\)</span> 可被表示为有效的deterministic assignments上的概率分布, 即 <span class="math inline">\(P\)</span> 满足<span class="math display">\[P=\sum_{\sigma\in\theta}\mu_\sigma\cdot Prio(\sigma,\succ),~~~\mu_\sigma\geqslant 0,~\sum_{\sigma\in\theta}\mu_\sigma=1.\]</span></p></blockquote><p>根据上式可知, 所有<strong>事后评估有效</strong>的分配方案存在一个<strong>中心点</strong>(natural central point). 这个中心点就是<strong>随机优先分配</strong>(Random Priority), 即 <span class="math display">\[RP(\succ)=\frac{1}{n!}\sum_{\sigma\in\theta}Prio(\sigma,\succ).\]</span></p><h4 id="随机占优关系">随机占优关系</h4><p>考虑 <span class="math inline">\(A\)</span> 上的序关系 <span class="math inline">\(\succ_i\)</span>, 假设 <span class="math inline">\(a_1\succ_ia_2\succ_i\cdots\succ_ia_n\)</span>.</p><blockquote><p>可如下定义 <span class="math inline">\(\mathscr{L}(A)\)</span> 上的一个偏序关系 <span class="math inline">\(sd(\succ_i)\)</span>: <span class="math display">\[P_i~sd(\succ_i)~Q_i\iff\left\{\sum\limits_{k=1}^tp_{ia_k}\geqslant\sum\limits_{k=1}^tq_{ia_k},~\forall t=1,\cdots,n\right\},~P_i,Q_i\in\mathscr{L}(A).\]</span> 该偏序关系称作<strong>随机占优</strong>(stochastic dominance).</p></blockquote><p>关于随机占优, 容易得到如下结论:</p><blockquote><p><span class="math inline">\(\forall P_i,Q_i\in\mathscr{L}(A)\)</span>, <span class="math inline">\(P_i~sd(\succ_i)~Q_i\)</span> iff <span class="math inline">\(\forall\)</span> 与 <span class="math inline">\(\succ_i\)</span> 相容的 <span class="math inline">\(u_i\)</span>, 总有 <span class="math display">\[u_i\cdot P_i\geqslant u_i\cdot Q_i.\]</span></p></blockquote><p>进一步可以将随机占优关系推到 <span class="math inline">\(\mathscr{R}\)</span> 上:</p><blockquote><p><strong>DEFINITION 2.</strong> 给定偏好 <span class="math inline">\(\succ\)</span>, <span class="math inline">\(P,Q\in\mathscr{R}\)</span>, 称 <span class="math inline">\(Q\)</span> 随机占优于 <span class="math inline">\(P\)</span>(<span class="math inline">\(P\)</span> is stochastically dominated by <span class="math inline">\(Q\)</span>), 如果 <span class="math display">\[Q_i~sd(\succ_i)~P_i,~\forall i~且~Q\neq P\]</span></p></blockquote><h4 id="依次有效性">依次有效性</h4><blockquote><p>给定偏好关系 <span class="math inline">\(\succ\)</span>, 称 <span class="math inline">\(P\in\mathscr{R}\)</span> 是<strong>依次有效</strong>的, 如果不存在 <span class="math inline">\(Q\in\mathscr{R}\)</span>, s.t. <span class="math inline">\(Q\)</span> 随机占优于 <span class="math inline">\(P\)</span>.</p></blockquote><p>依次有效性与事前/事后评估有如下关系:</p><blockquote><p><strong>LEMMA 2.</strong> 给定一个Random Assignment <span class="math inline">\(P\in\mathscr{R}\)</span>, 一个偏好关系 <span class="math inline">\(\succ\)</span>, 和一组与 <span class="math inline">\(\succ\)</span> 相容的效用函数 <span class="math inline">\(u\)</span>, 则有:<br>1. 若 <span class="math inline">\(P\)</span> 对 <span class="math inline">\(u\)</span> 是<strong>事前评估有效</strong>的, 则 <span class="math inline">\(P\)</span> 对 <span class="math inline">\(\succ\)</span> 是<strong>依次有效</strong>的. <em>(逆命题在 <span class="math inline">\(n=2\)</span> 时成立, <span class="math inline">\(n\geqslant 3\)</span> 时可能失效)</em>;<br>2. 若 <span class="math inline">\(P\)</span> 对 <span class="math inline">\(\succ\)</span> 是<strong>依次有效</strong>的, 则 <span class="math inline">\(P\)</span> 对 <span class="math inline">\(\succ\)</span> 是<strong>事后评估有效</strong>的. <em>(逆命题在 <span class="math inline">\(n\leqslant 3\)</span> 时成立, <span class="math inline">\(n\geqslant 4\)</span> 时可能失效)</em>.</p></blockquote><h2 id="进食算法">进食算法</h2><p>在PS算法处已经实际上介绍了进食算法:</p><blockquote><p><strong>SIMULTANEOUS EATING ALGORITHM</strong><br>　　给定偏好关系 <span class="math inline">\(\succ\)</span> 和一组函数 <span class="math inline">\(\{\omega_i(t)\}_{i\in N}\)</span>, s.t. <span class="math inline">\(\omega_i(t)\geqslant 0\)</span>, 且 <span class="math inline">\(\int_0^1\omega_i(t){\rm d}t=1\)</span>, 表示进食的速度.<br>　　所有的人按照自己的偏好关系开始进食, 并且在每个时刻, 每个参与者都吃自己当前最想吃并且有剩余的物品.</p></blockquote><h3 id="进食算法的依次有效性">进食算法的依次有效性</h3><h4 id="依次有效的条件">依次有效的条件</h4><p>在 <span class="math inline">\(\mathscr{R}\)</span> 上可如下定义一个二元关系 <span class="math inline">\(\tau\)</span>:</p><blockquote><p><strong>DEFINITION 2.</strong> 给定一个 Random Assignment <span class="math inline">\(P\in\mathscr{R}\)</span> 和偏好关系 <span class="math inline">\(\succ\)</span>, 如下定义 <span class="math inline">\(\tau\)</span>: <span class="math display">\[a\tau(P,\succ)b\iff \exists i\in N,~s.t.~a\succ_ib,~p_{ib}&gt;0.\]</span></p></blockquote><ul><li><span class="math inline">\(a\tau b\)</span> 其实表示的是: 存在一个 <span class="math inline">\(i\)</span>, 比起 <span class="math inline">\(b\)</span> 更喜欢 <span class="math inline">\(a\)</span>, 但有可能会得到 <span class="math inline">\(b\)</span>.</li></ul><p>根据二元关系 <span class="math inline">\(\tau\)</span> 可得到依次有效的等价条件:</p><blockquote><p><strong>LEMMA 3.</strong> 一个Random Assignment <span class="math inline">\(P\in\mathscr{R}\)</span> 是依次有效的, iff <span class="math inline">\(\tau(P,\succ)\)</span> 无环(acyclic).</p></blockquote><p>其证明并不困难:</p><ul><li>充分性: 假设有一个环, 沿着环转一圈即可得到一个随机占优于 <span class="math inline">\(P\)</span> 的Assignment.</li><li>必要性: 假设存在 <span class="math inline">\(Q\)</span> 随机占优于 <span class="math inline">\(P\)</span>, 则可直接得到一个 <span class="math inline">\(\tau\)</span> 的环.</li></ul><h4 id="进食算法的依次有效性-1">进食算法的依次有效性</h4><blockquote><p>进食算法是依次有效的.</p></blockquote><p>其证明也很简单, 直接利用引理 1即可.</p><p>假设进食算法不是依次有效的, 则 <span class="math inline">\(\tau\)</span> 存在环: <span class="math display">\[a_0\tau a_1\tau\cdots \tau a_k\tau a_0.\]</span> 于是按照算法, 有如下命题:</p><ul><li><span class="math inline">\(i_0\)</span> 开始吃 <span class="math inline">\(a_1\)</span> 的时候, <span class="math inline">\(a_0\)</span> 已经被吃完, 故 <span class="math inline">\(a_0\)</span> 比 <span class="math inline">\(a_1\)</span> 更早被开始吃;</li><li><span class="math inline">\(i_1\)</span> 开始吃 <span class="math inline">\(a_2\)</span> 的时候, <span class="math inline">\(a_1\)</span> 已经被吃完, 故 <span class="math inline">\(a_1\)</span> 比 <span class="math inline">\(a_2\)</span> 更早被开始吃;</li><li><span class="math inline">\(\cdots\cdots\)</span></li><li><span class="math inline">\(i_k\)</span> 开始吃 <span class="math inline">\(a_0\)</span> 的时候, <span class="math inline">\(a_k\)</span> 已经被吃完, 故 <span class="math inline">\(a_k\)</span> 比 <span class="math inline">\(a_0\)</span> 更早被开始吃.</li></ul><p>这显然是一个矛盾.</p><p>进食算法的有效性由下列定理给出:</p><blockquote><p><strong>THEOREM 1.</strong> 给定偏好关系 <span class="math inline">\(\succ\in\mathscr{A}^N\)</span>, 对于任一组进食速率函数 <span class="math inline">\(\omega=\{\omega_i\}_{i\in N}\)</span>, Random Assignment <span class="math inline">\(P_\omega(\succ)\)</span> <strong>总是依次有效的</strong>.<br>　　反过来, 对于任一个对 <span class="math inline">\(\succ\)</span> 依次有效的Random Assignment <span class="math inline">\(P\)</span>, 存在一组进食速率函数 <span class="math inline">\(\omega=\{\omega_i\}_{i\in N}\)</span>, s.t. <span class="math inline">\(P=P_\omega(\succ)\)</span>.</p></blockquote><h3 id="ps算法">PS算法</h3><p>至此我们可以严格地定义PS算法:</p><blockquote><p><strong>DEFINITION 4.</strong> 满足 <span class="math inline">\(\omega_i(t)\equiv 1,~\forall t\in[0,1],~\forall i\in N\)</span> 的进食算法即为PS算法. 记作 <span class="math inline">\(PS(\succ)\)</span>.</p></blockquote><p>PS算法有如下两条性质:</p><ol class="example" type="1"><li>PS算法是依次有效的, 由定理1即得;</li><li>PS算法是匿名的, 即对于 <span class="math inline">\(n\)</span> 个人的身份对称.</li></ol><p>关于以上的(2), 有如下引理:</p><blockquote><p><strong>LEMMA 4.</strong> 给定一组进食速率函数 <span class="math inline">\(\omega=(\omega_1,\cdots,\omega_n)\)</span>, <span class="math inline">\(P\)</span> 是由 <span class="math inline">\(\omega\)</span> 生成的分配机制(mechanism). 则 <span class="math inline">\(P\)</span> 是匿名的当且仅当 <span class="math inline">\(P\)</span> 是PS算法.</p></blockquote><h2 id="rp算法与ps算法的比较">RP算法与PS算法的比较</h2><p>略去文中的例子, 直接不加证明地给出文中的结论:</p><h3 id="无嫉妒性">无嫉妒性</h3><p>无嫉妒性(envy-free)定义如下:</p><blockquote><strong>DEFINITION 4.</strong> 称Random Assignment <span class="math inline">\(P\in\mathscr{R}\)</span> 是无嫉妒/弱无嫉妒(envy-free/weak envy-free)的, 当且仅当对 <span class="math inline">\(\forall i,j\in N\)</span>, 总有:<br><table><tr><td>无嫉妒</td><td><span class="math inline">\(P_i~sd(\succ_i)~P_j\)</span></td></tr><tr><td>弱无嫉妒</td><td><span class="math inline">\(P_j~sd(\succ_i)~P_j\Rightarrow P_i=P_j\)</span></td></tr></table></blockquote><h3 id="无操作性">无操作性</h3><p>无操作性(strategyproofness)定义如下:</p><blockquote><strong>DEFINITION 5.</strong> 称一个分配机制 <span class="math inline">\(P(\cdot)\)</span> 是无操作/弱无操作(strategyproofness/weak strategyproofness)的, 当且仅当对 <span class="math inline">\(\forall i,j\in N\)</span>, 总有:<br><table><tr><td>无操作</td><td><span class="math inline">\(P_i(\succ)~sd(\succ_i)~P_i(\succ\vert^i\succ_i^*)\)</span></td></tr><tr><td>弱无操作</td><td><span class="math inline">\(P_i(\succ\vert^i\succ_i^*)~sd(\succ_i)~P_i(\succ)\Rightarrow P_i(\succ)=P_i(\succ\vert^i\succ_i^*)\)</span></td></tr></table></blockquote><h3 id="ps与rp的比较">PS与RP的比较</h3>对任意的偏好关系 <span class="math inline">\(\succ\in\mathscr{A}^N\)</span>, PS与RP的关系如下:<br><table><tr><td></td><td><strong>无嫉妒性</strong></td><td><strong>无操作性</strong></td></tr><tr><td><strong>RP</strong></td><td>弱无嫉妒</td><td>无操作</td></tr><tr><td><strong>PS</strong></td><td>无嫉妒</td><td>弱无操作</td></tr></table>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 北大 </tag>
            
            <tag> 论文笔记 </tag>
            
            <tag> 保研 </tag>
            
            <tag> 经济学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京大学数学科学学院2018年直博生考试题目</title>
      <link href="/2018/04/01/%E5%8C%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E6%95%B0%E5%AD%A6%E7%A7%91%E5%AD%A6%E5%AD%A6%E9%99%A22018%E5%B9%B4%E7%9B%B4%E5%8D%9A%E7%94%9F%E8%80%83%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
      <content type="html"><![CDATA[<p>分为分析, 代数, 几何三部分. 满分200分.</p><a id="more"></a><h2 id="分析部分">分析部分</h2><p>四题. 共100分.</p><ol type="1"><li>(1.1) (10分) 证明隐函数 <span class="math display">\[y+\sin(xy)-x=0\]</span> 在 <span class="math inline">\(x=0\)</span> 附近可以确定一个函数关系 <span class="math inline">\(y=f(x)\)</span>.<br>(1.2) (5分) 试简单回答该函数的光滑度(不必证明).<br>(1.3) (10分) 求 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\(x=0\)</span> 处的三阶导数 <span class="math inline">\(f&#39;&#39;&#39;(0)\)</span>.<br></li><li>(2.1) (10分) 叙述积分第一中值定理并给出一个几何解释.<br>(2.2) (10分) 叙述一个函数 <span class="math inline">\(g(x)\equiv 1\)</span> 另一个函数 <span class="math inline">\(f(x)\)</span> 单调时的积分第二中值定理(三种情况), 并给出一个几何解释.<br>(2.3) (5分) 请问上问中函数 <span class="math inline">\(f(x)\)</span> 的单调性是实质性条件还是技术性条件. 如果是实质性的, 其本质是什么? 如果是技术性的, 在哪些方面提供了方便.<br></li><li>(25分) 在考虑函数 <span class="math inline">\(f(x)\)</span> 在给定区间上的Fourier级数 <span class="math display">\[\sum a_n\sin nx+b_n\cos nx\]</span> 的收敛性时, <span class="math inline">\(f(x)\)</span> 的光滑性与级数的收敛速度之间有没有一定的关系? 给出自己的理解和描述.</li><li>(4.1) (10分) 试讨论广义积分 <span class="math display">\[\int_\mathbb{R}\frac{\sin x}{x}{\rm d}x\]</span> 的收敛性.<br>(4.2) (10分) 试讨论广义重积分 <span class="math display">\[\iint_D\frac{\sin x}{x}{\rm d}x{\rm d}y,\quad D=\{\mathbb{R}\times[0,1]\}\]</span> 的敛散性.<br>(4.3) (5分) 请对上述结果做出一个你认为合理且本质的解释.</li></ol><h2 id="代数部分">代数部分</h2><p>三题, 共70分.</p><ol start="5" type="1"><li>(20分) 求集合 <span class="math display">\[\{A\in M_{7\times 7}(\mathbb{R}): A^3=0\}\]</span> 中矩阵秩的最大值.</li><li>(30分) 设 <span class="math inline">\(V\)</span> 是有限维实内积空间, <span class="math inline">\(\alpha_1,\cdots,\alpha_r,\beta_1,\cdots,\beta_r\in V\)</span>, 假设存在非零向量 <span class="math inline">\(\alpha\in V\)</span>, s.t. <span class="math display">\[\sum\limits_{i=1}^r\langle\alpha,\alpha_i\rangle\beta_i=0.\]</span>证明存在非零向量 <span class="math inline">\(\beta\in V\)</span>, s.t. <span class="math display">\[\sum\limits_{i=1}^r\langle\beta,\beta_i\rangle\alpha_i=0.\]</span></li><li>(30分) 证明对任意 <span class="math inline">\(3\times 3\)</span> 复矩阵 <span class="math inline">\(A\)</span>, 存在 <span class="math inline">\(3\times 3\)</span> 酉矩阵 <span class="math inline">\(U\)</span>, s.t. <span class="math inline">\(UAU^{-1}\)</span> 为形如 <span class="math display">\[\begin{bmatrix}*&amp;0&amp;*\\ *&amp;*&amp;0\\ *&amp;0&amp;*\\ \end{bmatrix}\]</span> 的矩阵.</li></ol><h2 id="几何部分">几何部分</h2><p>一题, 共30分</p><ol start="8" type="1"><li>(30分) 对于空间仿射坐标系中的马鞍面 <span class="math inline">\(S: z=xy\)</span>, 记 <span class="math inline">\(G\)</span> 为所有保持 <span class="math inline">\(S\)</span> 作为点集不变的空间仿射变换构成的群, 试决定空间中所有的直线 <span class="math inline">\(L\)</span>, s.t. 对于任意 <span class="math inline">\(G\)</span> 中的变换 <span class="math inline">\(g\)</span>, <span class="math inline">\(g(L)\)</span> 都与 <span class="math inline">\(L\)</span> 平行或重合.</li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 北大 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 数学分析 </tag>
            
            <tag> 线性代数 </tag>
            
            <tag> 保研 </tag>
            
            <tag> 解析几何 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京大学数学科学学院2016年直博生考试题目</title>
      <link href="/2018/04/01/%E5%8C%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E6%95%B0%E5%AD%A6%E7%A7%91%E5%AD%A6%E5%AD%A6%E9%99%A22016%E5%B9%B4%E7%9B%B4%E5%8D%9A%E7%94%9F%E8%80%83%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
      <content type="html"><![CDATA[<p>分为分析, 代数, 几何三部分. 满分200分.</p><a id="more"></a><h2 id="分析部分">分析部分</h2><ol type="1"><li>(30分, 每小题15分)<ol type="1"><li>若 <span class="math inline">\(f(x)\)</span> 在实轴可导且 <span class="math inline">\(f&#39;(x)&gt;f(x)\)</span>, <span class="math inline">\(\forall x\in\mathbb{R}\)</span>, 则 <span class="math inline">\(f\)</span> 至多有一个零点.</li><li>若 <span class="math inline">\(f(x)\)</span> 在实轴可导且 <span class="math inline">\(f&#39;&#39;(x)&gt;f(x)\)</span>, <span class="math inline">\(\forall x\in\mathbb{R}\)</span>, 则 <span class="math inline">\(f\)</span> 至多有两个零点.</li></ol></li><li>(30分) 假设 <span class="math inline">\(\phi(x,y,z)\)</span> 是原点 <span class="math inline">\(O\)</span> 某个邻域的 <span class="math inline">\(C^\infty\)</span> 函数, 且 <span class="math inline">\(\phi\)</span>, <span class="math inline">\(\phi_x\)</span>, <span class="math inline">\(\phi_y\)</span>, <span class="math inline">\(\phi_{xz}\)</span>, <span class="math inline">\(\phi_{yz}\)</span> 在原点为 <span class="math inline">\(0\)</span>, <span class="math inline">\(\phi_{xx}\)</span>, <span class="math inline">\(\phi_{yy}\)</span> 在原点为 <span class="math inline">\(1\)</span>, <span class="math inline">\(\phi_{xy}(O)=\frac{1}{2}\)</span>, <span class="math inline">\(\phi_z(O)=-\frac{1}{2}\)</span>. <span class="math inline">\(\phi(x,y,z)=0\)</span> 确定的的隐函数记为 <span class="math inline">\(z=z(x,y)\)</span> (已知 <span class="math inline">\(z(0,0)=0\)</span>). 请讨论 <span class="math inline">\(z=z(x,y)\)</span> 在 <span class="math inline">\((0,0)\)</span> 附近的极值问题.</li><li>(40分) 设 <span class="math inline">\(z=z(x,y)\)</span> 是上题中的隐函数, <span class="math inline">\(\Omega_\delta\)</span> 是 <span class="math inline">\((0,0)\)</span> 点的 <span class="math inline">\(\delta\)</span> 邻域, 当 <span class="math inline">\(\delta\)</span> 充分小时, 证明下列极限存在并求值: <span class="math display">\[\lim\limits_{t\to+\infty} t\iint_{\Omega_\delta}e^{-tz(x,y)}{\rm d}x{\rm d}y.\]</span></li></ol><h2 id="代数部分">代数部分</h2><ol start="4" type="1"><li>(20分) 设 <span class="math inline">\(A\)</span> 是一个 <span class="math inline">\(2\)</span> 阶复方阵, 考虑二阶复方阵的线性空间 <span class="math inline">\(M_2(\mathbb{C})\)</span> 上的线性变换 <span class="math display">\[\phi_A: M_2(\mathbb{C})\to M_2(\mathbb{C}),~X\mapsto AX-XA.\]</span>试确定 <span class="math inline">\(\dim({\rm Ker}(\phi_A))\)</span> 的所有可能值.</li><li>(20分) 对于有理数域 <span class="math inline">\(\mathbb{Q}\)</span> 上的两个 <span class="math inline">\(n\)</span> 阶方阵 <span class="math display">\[A=\begin{bmatrix}0&amp;1&amp;\cdots&amp;1\\ 0&amp;0&amp;\ddots&amp;\vdots\\ \vdots&amp;\ddots&amp;\ddots&amp;1\\ 0&amp;\cdots&amp;0&amp;0\\ \end{bmatrix},~B=\begin{bmatrix}0&amp;0&amp;\cdots&amp;0\\ 1&amp;0&amp;\ddots&amp;\vdots\\ \vdots&amp;\ddots&amp;\ddots&amp;0\\ 1&amp;\cdots&amp;1&amp;0\\ \end{bmatrix}\]</span>证明二者相似, 并求矩阵 <span class="math inline">\(T\)</span>, s.t. <span class="math inline">\(A=T^{-1}BT\)</span>.</li><li>(20分) <span class="math inline">\(\mathbb{R}[x]\)</span> 中有多项式 <span class="math display">\[f(x)=x^4+a_1x^3+a_2x^2+a_3x+a_4,\]</span> 试用系数 <span class="math inline">\(a_1\sim a_4\)</span> 的关系式给出 <span class="math inline">\(f(x)\)</span> 能表达成某不可约二次多项式 <span class="math inline">\(g(x)\)</span> 平方的充要条件.</li></ol><h2 id="几何部分">几何部分</h2><ol start="7" type="1"><li>(30分) 欧式平面上保定向的等距变换群的一个子群 <span class="math inline">\(G\)</span>, 其中每一个非恒同的变换 <span class="math inline">\(g\)</span> 都没有不动点, 且每一个平面上的点 <span class="math inline">\(p\)</span> 在 <span class="math inline">\(G\)</span> 作用下的轨道在平面上都没有聚点. 试证明 <span class="math inline">\(G\)</span> 可由一个或两个平移变换生成.</li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 北大 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 数学分析 </tag>
            
            <tag> 线性代数 </tag>
            
            <tag> 保研 </tag>
            
            <tag> 解析几何 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数学分析拾遗[5]——多元函数的极值</title>
      <link href="/2018/03/28/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E6%8B%BE%E9%81%97-5-%E2%80%94%E2%80%94%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%81%E5%80%BC/"/>
      <content type="html"><![CDATA[<p>多元函数的极值问题: 通常极值与条件极值</p><a id="more"></a><h2 id="通常极值">通常极值</h2><blockquote><p><strong>定理</strong> 设函数 <span class="math inline">\(f(\boldsymbol{x})=f(x_1,\cdots,x_n)\)</span> 在区域 <span class="math inline">\(D\subset\mathbb{R}^n\)</span> 内具有二阶连续偏导数, 且 <span class="math inline">\(f&#39;(\boldsymbol{x}_0)\)</span> <span class="math inline">\((\boldsymbol{x}_0\in D)\)</span>, 再设 <span class="math inline">\(f(\boldsymbol{x})\)</span> 在 <span class="math inline">\(\boldsymbol{x}_0\)</span> 处的Hessi矩阵满秩, 则<br>　　(1) 当 <span class="math inline">\(\boldsymbol{H}_f(\boldsymbol{x}_0)\)</span> 正定时, <span class="math inline">\(f(\boldsymbol{x})\)</span> 在 <span class="math inline">\(\boldsymbol{x}_0\)</span> 取极小值;<br>　　(2) 当 <span class="math inline">\(\boldsymbol{H}_f(\boldsymbol{x}_0)\)</span> 负定时, <span class="math inline">\(f(\boldsymbol{x})\)</span> 在 <span class="math inline">\(\boldsymbol{x}_0\)</span> 取极大值;<br>　　(3) 当 <span class="math inline">\(\boldsymbol{H}_f(\boldsymbol{x}_0)\)</span> 不定时, <span class="math inline">\(f(\boldsymbol{x})\)</span> 在 <span class="math inline">\(\boldsymbol{x}_0\)</span> 不是极值;</p></blockquote><ul><li>Hessi矩阵定义如下: <span class="math display">\[\boldsymbol{H}_f(\boldsymbol{x}_0)=\begin{bmatrix}\frac{\partial f(\boldsymbol{x}_0)}{\partial x_1^2} &amp; \frac{\partial f(\boldsymbol{x}_0)}{\partial x_1\partial x_2} &amp; \cdots &amp; \frac{\partial f(\boldsymbol{x}_0)}{\partial x_1\partial x_n}\\\frac{\partial f(\boldsymbol{x}_0)}{\partial x_2\partial x_1} &amp; \frac{\partial f(\boldsymbol{x}_0)}{\partial x_2^2} &amp; \cdots &amp; \frac{\partial f(\boldsymbol{x}_0)}{\partial x_2\partial x_n}\\\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\\frac{\partial f(\boldsymbol{x}_0)}{\partial x_n\partial x_1} &amp; \frac{\partial f(\boldsymbol{x}_0)}{\partial x_n\partial x_1} &amp; \cdots &amp; \frac{\partial f(\boldsymbol{x}_0)}{\partial x_n^2}\\\end{bmatrix}.\]</span></li></ul><h2 id="条件极值">条件极值</h2><blockquote><p><strong>定理</strong> 设函数 <span class="math inline">\(f(\boldsymbol{x})\)</span>, <span class="math inline">\(\boldsymbol{\varphi}(\boldsymbol{x})=(\varphi_1(\boldsymbol{x}),\cdots,\varphi_m(\boldsymbol{x}))\)</span> 在区域 <span class="math inline">\(D\subset\mathbb{R}^n~(m&lt;n)\)</span> 内具有各个连续偏导数, 再设 <span class="math inline">\(\boldsymbol{x}_0=(x_1^0,\cdots,x_n^0)\in D\)</span> 为 <span class="math inline">\(f(\boldsymbol{x})\)</span> 在约束条件 <span class="math display">\[\begin{cases}\varphi_1(\boldsymbol{x})=0,\\ \varphi_2(\boldsymbol{x})=0,\\ \cdots\cdots\\ \varphi_m(\boldsymbol{x})=0.\end{cases}\]</span> 下的极值点, 且 <span class="math inline">\(\boldsymbol{\varphi}&#39;(\boldsymbol{x}_0)\)</span> 的秩为 <span class="math inline">\(m\)</span>, 则存在常数 <span class="math inline">\(\lambda_1,\cdots,\lambda_m\in\mathbb{R}\)</span>, s.t. 在 <span class="math inline">\(\boldsymbol{x}_0\)</span> 处有如下等式成立: <span class="math display">\[\begin{cases}\frac{\partial f(\boldsymbol{x}_0)}{\partial x_i}+\sum\limits_{j=1}^m \lambda_j\frac{\partial \varphi_j(\boldsymbol{x}_0)}{\partial x_i}=0, &amp; i=1,2,\cdots,n, \\\varphi_j(\boldsymbol{x}_0)=0, &amp; j=1,2,\cdots,m.\end{cases}\]</span></p></blockquote><h3 id="lagrange乘数法">Lagrange乘数法</h3><ol type="1"><li><p>构造函数 <span class="math display">\[F(x_1,\cdots,x_n,\lambda_1,\cdots,\lambda_m)=f(\boldsymbol{x})+\sum_{j=1}^m\lambda_j\varphi_j(\boldsymbol{x}),\]</span></p></li><li><p>则 <span class="math inline">\(\boldsymbol{x}_0\)</span> 是极值点的必要条件如下: <span class="math display">\[\begin{cases}\frac{\partial F(\boldsymbol{x}_0)}{\partial x_i}=0 &amp; (i=1,2,\cdots,n),\\ \frac{\partial F(\boldsymbol{x}_0)}{\partial\lambda_j}=0 &amp; (j=1,2,\cdots,m).\\\end{cases}\]</span></p></li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 数学分析 </tag>
            
            <tag> 保研 </tag>
            
            <tag> 保研复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数学分析拾遗[4]——含参广义积分的一致收敛</title>
      <link href="/2018/03/27/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E6%8B%BE%E9%81%97-4-%E2%80%94%E2%80%94Abel%E5%88%A4%E5%88%AB%E6%B3%95%E4%B8%8EDirichlet%E5%88%A4%E5%88%AB%E6%B3%95/"/>
      <content type="html"><![CDATA[<p>含参广义积分一致收敛性的常用判断方法是M判别法, 但M判别法太强, 适用面窄. 故在被积函数取绝对值后不一致收敛时, 常用以下的两种判别法:</p><ul><li>Abel判别法;</li><li>Dirichlet判别法.</li></ul><a id="more"></a><h2 id="m判别法">M判别法</h2><blockquote><p><strong>定理</strong> 若 <span class="math inline">\(\exists M(x)\)</span>, s.t.<br>　　(1) <span class="math inline">\(\int_a^{+\infty}M(x){\rm d}x\)</span> 一致收敛.<br>　　(2) <span class="math inline">\(M\)</span> 有界, 即 <span class="math display">\[\vert f(x,y)\vert\leqslant M(x)~~~(\forall x\geqslant a,~\forall y\in I),\]</span><br>则 <span class="math inline">\(\int_a^{+\infty} f(x,y){\rm d}x\)</span> 在 <span class="math inline">\(I\)</span> <font color="red">绝对</font>一致收敛.</p></blockquote><h2 id="abel判别法">Abel判别法</h2><blockquote><p><strong>定理</strong> 若 <span class="math inline">\(\exists g,h\)</span>, s.t.<br>　　(1) <span class="math inline">\(\int_a^{+\infty} g(x,y){\rm d}x\)</span> 对 <span class="math inline">\(y\in I\)</span> <font color="blue">一致收敛</font>;<br>　　(2) <span class="math inline">\(h(x,y)\)</span> 当 <span class="math inline">\(y\)</span> 固定时, 对 <span class="math inline">\(x\)</span> 单调, 且<font color="red">一致有界</font>, 即 <span class="math inline">\(\exists M\)</span>&gt;0, s.t. <span class="math display">\[\vert h(x,y)\vert\leqslant M~~(\forall x\geqslant a, \forall  y\in I).\]</span><br>则 <span class="math inline">\(\int_a^{+\infty}f(x,y){\rm d}x\)</span> 在 <span class="math inline">\(I\)</span> 一致收敛.</p></blockquote><h2 id="dirichlet判别法">Dirichlet判别法</h2><blockquote><p><strong>定理</strong> 若 <span class="math inline">\(\exists g,h\)</span>, s.t.<br>　　(1) <span class="math inline">\(\int_a^{A} g(x,y){\rm d}x\)</span> <font color="blue">一致有界</font>, 即 <span class="math inline">\(\exists M&gt;0\)</span>, s.t. <span class="math display">\[\left|\int_a^A g(x,y){\rm d}x\right|\leqslant M~~~(\forall A\geqslant a, \forall y\in I);\]</span> 　　(2) <span class="math inline">\(h(x,y)\)</span> 当 <span class="math inline">\(y\)</span> 固定时, 对 <span class="math inline">\(x\)</span> 单调, 且当 <span class="math inline">\(x\to +\infty\)</span> 时, <font color="red"><span class="math display">\[h(x,y)\rightrightarrows0.\]</span></font><br>则 <span class="math inline">\(\int_a^{+\infty}f(x,y){\rm d}x\)</span> 在 <span class="math inline">\(I\)</span> 一致收敛.</p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 数学分析 </tag>
            
            <tag> 保研 </tag>
            
            <tag> 保研复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线性代数拾遗[2]——Jordan标准形</title>
      <link href="/2018/03/22/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%8B%BE%E9%81%97-2-%E2%80%94%E2%80%94Jordan%E6%A0%87%E5%87%86%E5%9E%8B/"/>
      <content type="html"><![CDATA[<p>Jordan标准形相关理论: <span class="math inline">\(\lambda\)</span> 矩阵, 初等因子, 不变因子.</p><blockquote><p>默认已经了解了Jordan标准形的相关定义.</p></blockquote><a id="more"></a><h2 id="jordan标准形定理">Jordan标准形定理</h2><p>Jordan标准形定理是线性代数里最深刻的结果</p><blockquote><p><strong>定理</strong> 复数域上任意一个 <span class="math inline">\(n\)</span> 阶方阵 <span class="math inline">\(A\)</span> 都相似于一个Jordan标准形. 即 <span class="math inline">\(\forall A\in\mathbb{C}^{n\times n}\)</span>, <span class="math inline">\(\exists\)</span> 可逆阵 <span class="math inline">\(P\)</span>, s.t. <span class="math display">\[P^{-1}AP=\begin{bmatrix}J_{m_1}(\lambda_1)&amp;&amp;\\ &amp;\ddots&amp;\\ &amp;&amp;J_{m_s}(\lambda_s)\end{bmatrix},\]</span> 其中 <span class="math inline">\(J_{m_t}(\lambda_t)\)</span> <span class="math inline">\((t=1,\cdots,s)\)</span> 为 <span class="math inline">\(A\)</span> 的特征<span class="math inline">\(\lambda\)</span>矩阵 <span class="math inline">\(\lambda I-A\)</span> 的初等因子 <span class="math inline">\((\lambda-\lambda_t)^{m_t}\)</span> 所对应的 <span class="math inline">\(m_t\)</span> 阶Jordan块 <span class="math display">\[\begin{bmatrix}\lambda_t&amp;1&amp;0&amp;\cdots&amp;0\\ &amp;\lambda_t&amp;1&amp;\ddots&amp;\vdots\\ &amp;&amp;\ddots&amp;\ddots&amp;0\\ &amp;&amp;&amp;\lambda_t&amp;1\\ &amp;&amp;&amp;&amp;\lambda_t\\ \end{bmatrix}_{m_t\times m_t}.\]</span></p></blockquote><blockquote><p>在不考虑Jordan块顺序的情况下, Jordan标准形是唯一的.</p></blockquote><h2 id="lambda--矩阵"><span class="math inline">\(\lambda-\)</span> 矩阵</h2><h3 id="lambda--矩阵-1"><span class="math inline">\(\lambda-\)</span> 矩阵</h3><blockquote><p><strong>定义</strong> 设 <span class="math inline">\(F\)</span> 是一个数域, <span class="math inline">\(\lambda\)</span> 是一个未定元, <span class="math inline">\(f_{ij}(\lambda)\in F[\lambda]\)</span>, <span class="math inline">\(i=1,\cdots,m\)</span>, <span class="math inline">\(j=1,\cdots,n\)</span>. 一元多项式环 <span class="math inline">\(F[\lambda]\)</span> 上的矩阵 <span class="math display">\[\begin{bmatrix}f_{11}(\lambda)&amp;f_{12}(\lambda)&amp;\cdots&amp;f_{1n}(\lambda)\\ f_{21}(\lambda)&amp;f_{22}(\lambda)&amp;\cdots&amp;f_{2n}(\lambda)\\ \vdots&amp;\vdots&amp;&amp;\vdots\\ f_{m1}(\lambda)&amp;f_{m2}(\lambda)&amp;\cdots&amp;f_{mn}(\lambda)\\ \end{bmatrix}\]</span> 是一个 <span class="math inline">\(\lambda-\)</span> 矩阵.</p></blockquote><h3 id="lambda--矩阵的初等变换"><span class="math inline">\(\lambda-\)</span> 矩阵的初等变换</h3><ol type="1"><li>交换两行/两列;</li><li>用一个非零常数乘某行/某列;</li><li>用一个多项式 <span class="math inline">\(g(\lambda)\)</span> 乘以某一行/列加到另一行/列上.</li></ol><h3 id="lambda--矩阵的等价标准形"><span class="math inline">\(\lambda-\)</span> 矩阵的等价标准形</h3><blockquote><p><strong>定理</strong> 任一个非零的 <span class="math inline">\(m\times n\)</span> 的 <span class="math inline">\(\lambda-\)</span> 矩阵 <span class="math inline">\(A(\lambda)\)</span> 都可以变换成以下形式的一个矩阵 <span class="math display">\[\begin{bmatrix}D(\lambda)_{r\times r}&amp; \\ &amp;0\\ \end{bmatrix}\]</span> 其中 <span class="math display">\[D(\lambda)_{r\times r}=\begin{bmatrix}d_1(\lambda)&amp;&amp;&amp;\\ &amp;d_2(\lambda)&amp;&amp;\\ &amp;&amp;\ddots&amp;\\ &amp;&amp;&amp;d_r(\lambda)\\ \end{bmatrix}\]</span> 其中 <span class="math inline">\(r={\rm rank}A(\lambda)\)</span>, <span class="math inline">\(d_i\)</span> 是首一多项式, 且满足 <span class="math display">\[d_i(\lambda)\vert d_{i+1}(\lambda),~i=1,2,\cdots,r-1.\]</span> 这样的矩阵被称为 <span class="math inline">\(A(\lambda)\)</span> 的<strong>等价标准形</strong>.</p></blockquote><h2 id="不变因子和初等因子">不变因子和初等因子</h2><h3 id="行列式因子">行列式因子</h3><h4 id="定义">定义</h4><blockquote><p><strong>定义</strong> 设 <span class="math inline">\(A(\lambda)\)</span> 是 <span class="math inline">\(m\times n\)</span> 的 <span class="math inline">\(\lambda-\)</span> 矩阵. 对于 <span class="math inline">\(k\leqslant \min\{m,n\}\)</span>, <span class="math inline">\(A(\lambda)\)</span> 的所有 <span class="math inline">\(k\)</span> 阶子式的首一最大公因式 <span class="math inline">\(D_k(\lambda)\)</span> 称为 <span class="math inline">\(A(\lambda)\)</span> 的 <span class="math inline">\(k\)</span> 阶行列式因子.</p></blockquote><h4 id="性质">性质</h4><ul><li>行列式因子在 <span class="math inline">\(\lambda-\)</span> 矩阵的初等变换下不变.</li><li>上条可直接推出 <span class="math inline">\(\lambda-\)</span> 矩阵的等价标准形是唯一的.</li></ul><h3 id="不变因子">不变因子</h3><h4 id="定义-1">定义</h4><blockquote><p><strong>定义</strong> <span class="math inline">\(\lambda-\)</span> 矩阵 <span class="math inline">\(A(\lambda)\)</span> 对角线的非零元素 <span class="math inline">\(d_i(\lambda)\)</span>, <span class="math inline">\((i=1,\cdots,r)\)</span> 称为 <span class="math inline">\(A(\lambda)\)</span> 的不变因子.</p></blockquote><h4 id="与行列式因子的关系">与行列式因子的关系</h4><p>不变因子与行列式因子有如下关系: <span class="math display">\[d_1(\lambda)=D_1(\lambda),d_2(\lambda)=\frac{D_2(\lambda)}{D_1(\lambda)},\cdots,d_r(\lambda)=\frac{D_r(\lambda)}{D_{r-1}(\lambda)}\]</span></p><h3 id="初等因子">初等因子</h3><blockquote><p><strong>定义</strong> 设 <span class="math inline">\(n\)</span> 阶 <span class="math inline">\(\lambda-\)</span> 矩阵 <span class="math inline">\(A(\lambda)\)</span> 的不变因子 <span class="math inline">\(d_1,\cdots,d_r\)</span> 的标准分解为 <span class="math display">\[d_1(\lambda)=p_1(\lambda)^{k_{11}}p_2(\lambda)^{k_{12}}\cdots p_s(\lambda)^{k_{1s}},\]</span> <span class="math display">\[d_2(\lambda)=p_1(\lambda)^{k_{21}}p_2(\lambda)^{k_{22}}\cdots p_s(\lambda)^{k_{2s}},\]</span> <span class="math display">\[\cdots\cdots\cdots\cdots\]</span> <span class="math display">\[d_r(\lambda)=p_1(\lambda)^{k_{r1}}p_2(\lambda)^{k_{r2}}\cdots p_s(\lambda)^{k_{rs}},\]</span> 其中 <span class="math inline">\(r={\rm rank}A(\lambda)\)</span>, <span class="math inline">\(p_i(\lambda)\)</span> 是两两不同的首一不可约多项式, 且 <span class="math display">\[0\leqslant k_{1i}\leqslant k_{2i}\leqslant \cdots\leqslant k_{ri},~i=1,2,\cdots,s.\]</span> 分解式中的 <span class="math inline">\(p_i(\lambda)\)</span> 的非零次幂, 叫做 <span class="math inline">\(A(\lambda)\)</span> 的初等因子.</p></blockquote><ul><li>当 <span class="math inline">\(F=\mathbb{C}\)</span> 时, <span class="math inline">\(p_i(\lambda)\)</span> 都是形如 <span class="math inline">\(\lambda-\lambda_i\)</span> 的一次因式.</li></ul><h2 id="jordan标准形的求法-lambda--矩阵">Jordan标准形的求法: <span class="math inline">\(\lambda-\)</span> 矩阵</h2><h3 id="lambda--矩阵法"><span class="math inline">\(\lambda-\)</span> 矩阵法</h3><p>按照以下步骤进行:</p><h4 id="求出a-的特征-lambda--矩阵">1. 求出<span class="math inline">\(A\)</span> 的特征 <span class="math inline">\(\lambda-\)</span> 矩阵</h4><p>直接求 <span class="math inline">\(\lambda I-A\)</span> 即可.</p><h4 id="求-lambda-i-a-的等价标准形">2. 求 <span class="math inline">\(\lambda I-A\)</span> 的等价标准形</h4><p>利用 <span class="math inline">\(\lambda-\)</span> 矩阵的初等变换求出 <span class="math inline">\(\lambda I-A\)</span> 的等价标准形, 记为 <span class="math display">\[\begin{bmatrix}d_1(\lambda)&amp;&amp;&amp;\\ &amp;d_2(\lambda)&amp;&amp;\\ &amp;&amp;\ddots&amp;\\ &amp;&amp;&amp;d_n(\lambda)\\ \end{bmatrix}\]</span> 则 <span class="math inline">\(d_i(\lambda)\)</span> 是 <span class="math inline">\(A\)</span> 的不变因子.</p><h4 id="根据初等因子求jordan块">3. 根据初等因子求Jordan块</h4><p>对 <span class="math inline">\(d_i(\lambda)\)</span> 进行标准分解<span class="math display">\[d_i(\lambda)=(\lambda-\lambda_{i_1})^{m_{i_1}}(\lambda-\lambda_{i_2})^{m_{i_2}}\cdots (\lambda-\lambda_{i_t})^{m_{i_t}}\]</span> 其中 <span class="math inline">\(\lambda_{i_j}\)</span> 互不相等, 则在 <span class="math inline">\(A\)</span> 的Jordan标准形中, <span class="math inline">\(d_i(\lambda)\)</span> 所对应的 <span class="math inline">\(t\)</span> 个Jordan块分别为 <span class="math display">\[J_{m_{i_1}}(\lambda_{i_1}),J_{m_{i_2}}(\lambda_{i_2}),\cdots,J_{m_{i_t}}(\lambda_{i_t}).\]</span></p><h3 id="一个例子">一个例子</h3><h4 id="题目内容">题目内容</h4><blockquote><p><strong>题目</strong> 求 <span class="math display">\[\begin{bmatrix}-1&amp;-2&amp;6\\ -1&amp;0&amp;3\\ -1&amp;-1&amp;4\\ \end{bmatrix}\]</span> 的Jordan标准形.</p></blockquote><h4 id="简略解答">简略解答</h4><p>特征 <span class="math inline">\(\lambda-\)</span> 矩阵为 <span class="math display">\[\lambda I-A=\begin{bmatrix}\lambda+1&amp;2&amp;-6\\ 1&amp;\lambda&amp;-3\\ 1&amp;1&amp;\lambda-4\\ \end{bmatrix}\]</span> 初等变换得到其等价标准形为 <span class="math display">\[\begin{bmatrix}1&amp;0&amp;0\\ 0&amp;\lambda-1&amp;0\\ 0&amp;0&amp;(\lambda-1)^2\\ \end{bmatrix}\]</span> 不变因子为 <span class="math inline">\(\lambda-1\)</span>, <span class="math inline">\((\lambda-1)^2\)</span>, 于是初等因子为 <span class="math inline">\(\lambda-1\)</span>, <span class="math inline">\((\lambda-1)^2\)</span>, 故 <span class="math inline">\(A\)</span> 有一个一阶块, 一个二阶块. 其Jordan标准形为 <span class="math display">\[\begin{bmatrix}1&amp;0&amp;0\\ 0&amp;1&amp;1\\ 0&amp;0&amp;1\\ \end{bmatrix}.\]</span></p><h2 id="jordan标准形的求法-空间分解">Jordan标准形的求法: 空间分解</h2><p>累死, 以后再写==</p><h2 id="参考资料">参考资料</h2><ol type="1"><li>王卿文. 线性代数核心思想及应用[M]. 科学出版社, 2012.</li><li>丘维声. 高等代数-第2版[M]. 高等教育出版社, 2002.</li><li>王萼芳. 高等代数教程.下册[M]. 清华大学出版社, 1997.</li><li>霍元极. 高等代数[M]. 北京师范大学出版社, 2009.</li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 线性代数 </tag>
            
            <tag> 保研 </tag>
            
            <tag> 保研复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线性代数拾遗[1]——分块矩阵</title>
      <link href="/2018/03/22/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%8B%BE%E9%81%97-1-%E2%80%94%E2%80%94%E5%88%86%E5%9D%97%E7%9F%A9%E9%98%B5/"/>
      <content type="html"><![CDATA[<p>分块矩阵的几个应用:</p><ol type="1"><li>特征多项式降阶定理(Sylvester公式);<br></li><li>秩的第一和第二降阶定理;<br></li><li>Sylvester不等式和Frobenius不等式.<br></li><li>一个例子</li></ol><a id="more"></a><h2 id="特征多项式降阶定理">特征多项式降阶定理</h2><h3 id="定理内容">定理内容</h3><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(m\times n\)</span> 矩阵, <span class="math inline">\(B\)</span> 是 <span class="math inline">\(n\times m\)</span> 矩阵, 且 <span class="math inline">\(m\geqslant n\)</span>, 则 <span class="math display">\[\vert\lambda I_m-AB\vert=\lambda^{m-n}\vert\lambda I_n-BA\vert.\]</span></p></blockquote><h3 id="简略证明">简略证明</h3><p>考虑到等式左右的行列式形式, 构造分块矩阵 <span class="math display">\[\begin{bmatrix}\lambda I_m &amp; A \\ B &amp; I_n \\ \end{bmatrix},\]</span></p><p>然后<font color="red"><strong>构造广义初等矩阵:</strong> <span class="math display">\[\begin{bmatrix}I_m &amp; -A \\ 0 &amp; I_n\\ \end{bmatrix},\begin{bmatrix}I_m &amp; -\frac{1}{\lambda}A \\ 0 &amp; I_n \\ \end{bmatrix}.\]</span></font> 则有 <span class="math display">\[\begin{bmatrix}I_m &amp; -A \\ 0 &amp; I_n\\ \end{bmatrix}\begin{bmatrix}\lambda I_m &amp; A \\ B &amp; I_n \\ \end{bmatrix}=\begin{bmatrix}\lambda I_m-AB &amp; 0 \\ B &amp; I_n \\ \end{bmatrix}\]</span> <span class="math display">\[\begin{bmatrix}\lambda I_m &amp; A \\ B &amp; I_n \\ \end{bmatrix} \begin{bmatrix}I_m &amp; -\frac{1}{\lambda}A \\ 0 &amp; I_n \\ \end{bmatrix}=\begin{bmatrix}\lambda I_m &amp; 0 \\ B &amp; I_n-\frac{1}{\lambda}BA \\ \end{bmatrix}\]</span></p><p>取行列式, 即有: <span class="math display">\[\vert \lambda I_m-AB\vert=\begin{vmatrix}\lambda I_m &amp; A \\ B &amp; I_n \\ \end{vmatrix}=\vert\lambda I_m\vert\vert I_n-\frac{1}{\lambda}BA\vert.\]</span></p><h3 id="其他形式">其他形式</h3><p>为了应用上的方便, 常写为 <span class="math display">\[\vert\lambda I_m+AB\vert=\lambda^{m-n}\vert\lambda I_n+BA\vert.\]</span></p><h2 id="秩的第一降阶定理">秩的第一降阶定理</h2><h3 id="定理内容-1">定理内容</h3><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(A\)</span> 可逆, <span class="math inline">\(\begin{bmatrix}A&amp;B\\C&amp;D\\\end{bmatrix}\)</span> 是 <span class="math inline">\(m\times n\)</span> 矩阵, 则 <span class="math display">\[r\begin{bmatrix}A&amp;B\\C&amp;D\\\end{bmatrix}=r(A)+r(D-CA^{-1}B).\]</span></p></blockquote><h3 id="简略证明-1">简略证明</h3><p><font color="red"><strong>构造广义初等矩阵:</strong> <span class="math display">\[\begin{bmatrix}I&amp;0\\ -CA^{-1}&amp;I\\ \end{bmatrix},\begin{bmatrix}I&amp;-A^{-1}B\\ 0&amp;I\\ \end{bmatrix}.\]</span></font> 则 <span class="math display">\[\begin{bmatrix}I&amp;0\\ -CA^{-1}&amp;I\\ \end{bmatrix} \begin{bmatrix}A&amp;B\\C&amp;D\\\end{bmatrix} \begin{bmatrix}I&amp;-A^{-1}B\\ 0&amp;I\\ \end{bmatrix}=\begin{bmatrix}A&amp;0\\ 0&amp;D-CA^{-1}B\\ \end{bmatrix}\]</span> 于是 <span class="math display">\[r\begin{bmatrix}A&amp;B\\C&amp;D\\\end{bmatrix}=r\begin{bmatrix}A&amp;0\\ 0&amp;D-CA^{-1}B\\ \end{bmatrix}=r(A)+r(D-CA^{-1}B).\]</span></p><h2 id="秩的第二降阶定理">秩的第二降阶定理</h2><h3 id="定理内容-2">定理内容</h3><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(A\)</span>, <span class="math inline">\(D\)</span> 分别是 <span class="math inline">\(m\)</span> 阶与 <span class="math inline">\(n\)</span> 阶可逆矩阵, <span class="math inline">\(B\)</span>, <span class="math inline">\(C\)</span> 分别是 <span class="math inline">\(m\times n\)</span> 和 <span class="math inline">\(n\times m\)</span> 矩阵, 则 <span class="math display">\[r(D-CA^{-1}B)=r(D)-r(A)+r(A-BD^{-1}C).\]</span></p></blockquote><h3 id="简略证明-2">简略证明</h3><p>思路与第一降阶定理完全相同, 略去.</p><h2 id="sylverster不等式">Sylverster不等式</h2><p><font color="red"><span class="math display">\[\min\{r(A),r(B)\}\geqslant r(AB)\geqslant r(A)+r(B)-n.\]</span></font></p><h3 id="定理内容-3">定理内容</h3><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span> 分别是 <span class="math inline">\(m\times n\)</span> 和 <span class="math inline">\(n\times l\)</span> 矩阵, 则 <span class="math display">\[r(AB)\geqslant r(A)+r(B)-n.\]</span></p></blockquote><h3 id="简略证明-3">简略证明</h3><h4 id="证法一">证法一</h4><p>由第一降阶定理, 有: <span class="math display">\[\begin{align}r(AB) &amp;= r(0+AI_n^{-1}B)=r\begin{bmatrix}I_n&amp;B\\ -A&amp;0\\ \end{bmatrix}-r(I_n) \\&amp;= r\begin{bmatrix}I_n&amp;B\\ -A&amp;0\\ \end{bmatrix}-n \\&amp;\geqslant r(A)+r(B)-n.\end{align}\]</span></p><h4 id="证法二">证法二</h4><p>构造分块矩阵: <span class="math display">\[\begin{bmatrix}A&amp;0\\ I&amp;B\\ \end{bmatrix},\]</span> 则有 <span class="math display">\[\begin{align}r(A)+r(B) &amp;\leqslant r\begin{bmatrix}A&amp;0\\ I&amp;B\\ \end{bmatrix}=r\begin{bmatrix}0&amp;-AB\\ I&amp;0\\ \end{bmatrix}\\&amp;= r(I)+r(AB).\end{align}\]</span></p><h2 id="frobenius不等式">Frobenius不等式</h2><h3 id="定理内容-4">定理内容</h3><blockquote><p><strong>定理</strong> <span class="math display">\[r(ABC)\geqslant r(AB)+r(BC)-r(B).\]</span></p></blockquote><h3 id="简略证明-4">简略证明</h3><p>考虑变换: <span class="math display">\[\begin{bmatrix}ABC&amp;0\\ 0&amp;B\\ \end{bmatrix}\to\begin{bmatrix}ABC&amp;AB\\ 0&amp;B\\ \end{bmatrix}\to\begin{bmatrix}0&amp;AB\\ -BC&amp;B\\ \end{bmatrix}\]</span> 故有: <span class="math display">\[r(ABC)+r(B)=r\begin{bmatrix}0&amp;AB\\ -BC&amp;B\\ \end{bmatrix}\geqslant r(AB)+r(BC).\]</span></p><h2 id="一个例子">一个例子</h2><h3 id="题目内容">题目内容</h3><blockquote><p>设 <span class="math inline">\(A\in F^{n\times n}\)</span>, <span class="math inline">\(f(x),g(x)\in F[x]\)</span> 且 <span class="math inline">\((f(x),g(x))=1\)</span>, 求证 <span class="math display">\[f(A)g(A)=0\iff r(f(A))+r(g(A))=n.\]</span></p></blockquote><h3 id="简略证明-5">简略证明</h3><p>由 <span class="math inline">\((f(x),g(x))=1\)</span>, 可知 <span class="math inline">\(\exists u(x),v(x)\in F[x]\)</span>, s.t. <span class="math display">\[u(x)f(x)+v(x)g(x)=1.\]</span> 故 <span class="math display">\[u(A)f(A)+v(A)g(A)=I.\]</span> 故有如下变换: <span class="math display">\[\begin{bmatrix}f(A)&amp;0\\ 0&amp;g(A)\\ \end{bmatrix}\to\begin{bmatrix}f(A)&amp;0\\ I&amp;g(A)\\ \end{bmatrix}\to\begin{bmatrix}0&amp;-f(A)g(A)\\ I&amp;0\\ \end{bmatrix}\]</span> 同时取秩, 可得 <span class="math display">\[f(A)g(A)=0\iff r(f(A))+r(g(A))=n.\]</span></p><h3 id="一个变形">一个变形</h3><blockquote><p>设 <span class="math inline">\(A\)</span> 为 <span class="math inline">\(n\)</span> 阶方阵, 则 <span class="math display">\[A^2=A\iff r(A)+r(I-A)=n.\]</span></p></blockquote><h2 id="参考资料">参考资料</h2><ol type="1"><li>王卿文. 线性代数核心思想及应用[M]. 科学出版社, 2012.</li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 线性代数 </tag>
            
            <tag> 保研 </tag>
            
            <tag> 保研复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>调教Hexo[3]——Hexo网站的傻瓜式迁移</title>
      <link href="/2018/03/20/hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/"/>
      <content type="html"><![CDATA[<blockquote><p>在网上搜索“hexo 迁移”, 得到的方案大多是在 <code>git</code> 上开辟一个仓库或者分支来存储博客的源码. 但是对于那些对 <code>git</code> 不是很熟悉的人来说, 这种方案操作难度稍大, 容易出岔子.</p></blockquote><p>本文提供了只保存主题 <code>\themes</code> 和文章 <code>\source</code> 两个文件夹, 重新配置环境的方法和细节.</p><a id="more"></a><h2 id="几句废话">几句废话</h2><p>前两天脑抽重装了一发系统, <del>再重装我就是狗</del>. 由于对 <code>git</code> 操作不够熟悉, 所以在迁移博客时出了一些小问题.</p><h2 id="出现的问题">出现的问题</h2>为了备份博客, 我在搭建之初将整个文件夹同步到了git的仓库中.<div class="github-widget" data-repo="lzcwr/My-blog-backup"></div>但一个很蠢的地方就是 <code>/theme/yelee</code> 中的内容没有被同步上来, 一直是一个空文件夹.<center><img src="http://olgwnj89q.bkt.clouddn.com/themes-yelee.png"></center><p>这个错误一直到我重装完系统后, 将该仓库clone到本地以后, 运行 <code>hexo server</code> 时才发现. 但此时已经来不及了==幸亏 <code>\source</code> 中的内容得以保留.<br>所以, 本文将提供一种重新配置网站的方案细节.</p><h2 id="配置细节">配置细节</h2><h3 id="环境配置">环境配置</h3><ol type="1"><li>安装 <code>git-for-windows</code>;</li><li>安装 <code>node.js</code>;</li><li>配置git相关信息: <code>user.name</code>, <code>user.email</code>, <code>ssh</code>.</li></ol><h3 id="hexo相关组件">hexo相关组件</h3><h4 id="hexo-deployer-git">hexo-deployer-git</h4><p>在 <code>git</code> 上部署网站需要安装该插件, 安装命令如下: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><h4 id="hexo-server">hexo-server</h4><p>在本地 <code>hexo s</code> 无法预览时需要安装该插件, 安装命令如下: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-server --save</span><br></pre></td></tr></table></figure></p><h4 id="hexo-renderer-pandoc">hexo-renderer-pandoc</h4><p>详见<a href="https://www.lizhechen.com/2017/03/08/Hexo%E4%B8%8EMathjax%E7%9A%84%E5%86%B2%E7%AA%81%E5%8F%8A%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89%E8%A7%A3%E5%86%B3/" target="_blank" rel="noopener">Hexo与Mathjax的冲突及（部分）解决</a>. 安装命令如下: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure></p><h2 id="后续操作">后续操作</h2><h3 id="文章迁移">文章迁移</h3><p>在空文件夹中运行 <code>hexo init</code>, 即可在文件夹中添加所需要的组件. 将其中的 <code>/source</code> 和 <code>/themes</code> 替换即可.</p><h3 id="搜索配置">搜索配置</h3><p>安装 <code>search</code> 插件, 在主题中配置好即可. 安装命令: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 计算机 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数学分析拾遗[3]——隐函数定理</title>
      <link href="/2018/03/18/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E6%8B%BE%E9%81%97-3-%E2%80%94%E2%80%94%E9%9A%90%E5%87%BD%E6%95%B0%E5%AE%9A%E7%90%86/"/>
      <content type="html"><![CDATA[<h2 id="单个方程的隐函数定理">单个方程的隐函数定理</h2><h3 id="二元情形">二元情形</h3><h4 id="定理内容">定理内容</h4><blockquote><p><strong>定理</strong> 设二元函数 <span class="math inline">\(F(x,y)\)</span> 在 <span class="math inline">\(U((x_0,y_0),\delta)\)</span> 内满足以下条件:<br>　　(1) <span class="math inline">\(F(x_0,y_0)=0\)</span>, <span class="math inline">\(F_y&#39;(x_0,y_0)\neq 0\)</span>;<br>　　(2) <span class="math inline">\(F(x,y)\)</span>, <span class="math inline">\(F_y&#39;(x,y)\)</span> 在 <span class="math inline">\(U((x_0,y_0),\delta)\)</span> 内连续.<br>则 <span class="math inline">\(\exists\delta_0&gt;0~(0&lt;\delta_0&lt;\delta)\)</span>, s.t. 在 <span class="math inline">\(U(x_o,\delta_0)\)</span> 内存在唯一满足下列条件的连续函数 <span class="math inline">\(f(x)\)</span>:<br>　　(a) <span class="math inline">\(y_0=f(x_0)\)</span>;<br>　　(b) <span class="math inline">\(F(x,f(x))=0\)</span>, <span class="math inline">\(\forall x\in U(x_0,\delta_0)\)</span>;<br>　　(c) 如果 <span class="math inline">\(F_x&#39;(x,y)\)</span> 在 <span class="math inline">\(U((x_0,y_0),\delta)\)</span> 内连续, 则 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\(U(x_0,\delta_0)\)</span> 存在连续导数并且有 <span class="math display">\[f&#39;(x)=-\frac{F_x&#39;(x,f(x))}{F_y&#39;(x,f(x))}.\]</span></p></blockquote><h4 id="简略证明">简略证明</h4><p>不妨设 <span class="math inline">\(F_y&#39;(x_0,y_0)&gt;0\)</span>. 由 <span class="math inline">\(F_y&#39;\)</span> 的连续性与极限的保号性, <span class="math inline">\(\exists 0&lt;\delta_1,\delta_2&lt;\delta\)</span>, s.t. <span class="math inline">\(\forall (x,y)\in U(x_0,\delta_1)\times U(y_0,\delta_2)\)</span>, 有 <span class="math display">\[F_y&#39;(x,y)&gt;0.\]</span> 特别地, 若固定 <span class="math inline">\(x=x_0\)</span>, 则 <span class="math inline">\(\forall y\in U(y_0,\delta_2)\)</span>, 有 <span class="math inline">\(F_y&#39;(x_0,y)&gt;0\)</span>. 故 <span class="math inline">\(F(x_0,y)\)</span> 在 <span class="math inline">\(U(y_0,\delta_2)\)</span> 对 <span class="math inline">\(y\)</span> 严格递增. 由于 <span class="math inline">\(F(x_0,y_0)=0\)</span>, 故 <span class="math display">\[F(x_0,y_0-\delta_2)&lt;0,~F(x_0,y_0+\delta_2)&gt;0.\]</span> 由 <span class="math inline">\(F\)</span> 的连续性, <span class="math inline">\(\exists\delta_0\in (0,\delta_1)\)</span>, s.t. <span class="math inline">\(\forall x\in U(x_0,\delta_0)\)</span>, 总有 <span class="math display">\[F(x,y_0-\delta_2)&lt;0,~F(x,y_0+\delta_2)&gt;0.\]</span> <span class="math inline">\(\forall \tilde{x}\in U(x_0,\delta_0)\)</span>, 考虑到 <span class="math inline">\(F_y&#39;(\tilde{x},y)&gt;0\)</span>, 由零点定理可知, 存在唯一的 <span class="math inline">\(\tilde{y}\in U(y_0,\delta_2)\)</span>, s.t. <span class="math display">\[F(\tilde{x},\tilde{y})=0.\]</span> 这说明了隐函数在 <span class="math inline">\(U((x_0,y_0),\delta_0)\)</span> 的存在性.<br>连续性和导数的存在性略去.</p><h3 id="多元情形">多元情形</h3><blockquote><p><strong>定理</strong> 记 <span class="math inline">\(\boldsymbol{x}=(x_1,\cdots,x_n)\)</span>, <span class="math inline">\(\boldsymbol{x}^0=(x_1^0,\cdots,x_n^0)\in\mathbb{R}^n\)</span>, 设函数 <span class="math inline">\(F(\boldsymbol{x},y)=F(x_1,\cdots,x_n,y)\)</span> 在 <span class="math inline">\(U(\boldsymbol{x}_0,\delta)\times U(y_0,\delta)~(\delta&gt;0)\)</span> 内由定义, 且满足<br>　　(1) <span class="math inline">\(F(\boldsymbol{x}_0,y_0)=0\)</span>, <span class="math inline">\(F_y&#39;(\boldsymbol{x}_0,y_0)\neq 0\)</span>;<br>　　(2) <span class="math inline">\(F(\boldsymbol{x},y)\)</span>, <span class="math inline">\(F_y&#39;(\boldsymbol{x},y)\)</span> 在 <span class="math inline">\(U((\boldsymbol{x}_0,y_0),\delta)\)</span> 内连续.<br>则 <span class="math inline">\(\exists\delta_0&gt;0~(0&lt;\delta_0&lt;\delta)\)</span>, s.t. 在 <span class="math inline">\(U(\boldsymbol{x}_o,\delta_0)\)</span> 内存在唯一满足下列条件的连续函数 <span class="math inline">\(f(\boldsymbol{x})\)</span>:<br>　　(a) <span class="math inline">\(y_0=f(\boldsymbol{x}_0)\)</span>;<br>　　(b) <span class="math inline">\(F(\boldsymbol{x},f(\boldsymbol{x}))=0\)</span>, <span class="math inline">\(\forall \boldsymbol{x}\in U(\boldsymbol{x}_0,\delta_0)\)</span>;<br>　　(c) 如果 <span class="math inline">\(F_x&#39;(\boldsymbol{x},y)\)</span> 在 <span class="math inline">\(U(\boldsymbol{x}_0,\delta)\times U(y_0,\delta)\)</span> 内连续, 则 <span class="math inline">\(f(\boldsymbol{x})\)</span> 在 <span class="math inline">\(U(\boldsymbol{x}_0,\delta_0)\)</span> 存在各个连续偏导数并且有 <span class="math display">\[\frac{\partial f(\boldsymbol{x})}{\partial x_i}=-\frac{F_{x_i}&#39;(x_1,\cdots,x_n,y)}{F_y&#39;(x_1,\cdots,x_n,y)},~\forall i=1,\cdots,n,~\forall\boldsymbol{x}\in U(\boldsymbol{x}_0,\delta).\]</span> 其中 <span class="math inline">\(y=f(\boldsymbol{x})\)</span>.</p></blockquote><h2 id="方程组的隐函数组定理">方程组的隐函数(组)定理</h2><p>待补</p><h2 id="反函数存在性定理">反函数存在性定理</h2><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\boldsymbol{y}=(y_1,\cdots,y_n)=(f_1(\boldsymbol{x}),\cdots,f_n(\boldsymbol{x}))\)</span> 是区域 <span class="math inline">\(D\subset\mathbb{R}^n\to\Omega\subset\mathbb{R}^n\)</span> 的一个 <span class="math inline">\(C^1\)</span> 映射, 且在 <span class="math inline">\(\boldsymbol{x}_0\in D\)</span> 处有 <span class="math display">\[\frac{\partial (f_1,\cdots,f_n)}{\partial (x_1,\cdots,x_n)}\Bigg|_{\boldsymbol{x}_0}\neq 0.\]</span> 记 <span class="math inline">\(\boldsymbol{y}=\boldsymbol{f}(\boldsymbol{x}_0)\)</span>, 则存在 <span class="math inline">\(\boldsymbol{x}_0\)</span> 的邻域 <span class="math inline">\(U(\boldsymbol{x}_0,\delta_0)\)</span>, s.t. <span class="math inline">\(\boldsymbol{y}=\boldsymbol{f}(\boldsymbol{x})\)</span> 是 <span class="math inline">\(U(\boldsymbol{x}_0,\delta_0)\to \boldsymbol{f}(U)\)</span> 的 <span class="math inline">\(C^1\)</span> 同胚映射. 其中 <span class="math inline">\(\boldsymbol{f}(U)\)</span> 是包含 <span class="math inline">\(\boldsymbol{y}_0\)</span> 的一个区域.</p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 数学分析 </tag>
            
            <tag> 保研 </tag>
            
            <tag> 保研复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数学分析拾遗[2]——积分的中值定理</title>
      <link href="/2018/03/13/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E6%8B%BE%E9%81%97-2-%E2%80%94%E2%80%94%E7%A7%AF%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/"/>
      <content type="html"><![CDATA[<h2 id="积分第一中值定理">积分第一中值定理</h2><h3 id="定理内容">定理内容</h3><blockquote><p><strong>积分第一中值定理</strong> 设函数 <span class="math inline">\(f(x)\in C[a,b]\)</span>, <span class="math inline">\(g(x)\in R[a,b]\)</span> <font color="red"><strong>且在 <span class="math inline">\([a,b]\)</span> 不变号</strong></font>, 则 <span class="math inline">\(\exists\xi\in[a,b]\)</span>, s.t. <span class="math display">\[\int_a^b f(x)g(x){\rm d}x=f(\xi)\int_a^b g(x){\rm d}x.\]</span></p></blockquote><h3 id="几何意义的探讨">几何意义的探讨</h3><p><span class="math inline">\(g(x)\equiv 1\)</span> 且 <span class="math inline">\(f(x)\geqslant 0\)</span> 时, 其形式变为: <span class="math display">\[\int_a^b f(x){\rm d}x=f(\xi)(b-a).\]</span> 此时几何意义是很显然的: 由 <span class="math inline">\(x=a\)</span>, <span class="math inline">\(x=b\)</span>, <span class="math inline">\(y=f(x)\)</span> 所围成的曲边梯形的面积与由 <span class="math inline">\(x=a,\)</span>, <span class="math inline">\(x=b\)</span>, <span class="math inline">\(y=f(\xi)\)</span> 围成的矩形面积相等, 如图所示:</p><center><img src="http://olgwnj89q.bkt.clouddn.com/1st%20m-v%20theorem%20of%20int.png"></center><h2 id="积分第二中值定理">积分第二中值定理</h2><h3 id="定理内容-1">定理内容</h3><blockquote><p><strong>积分第二中值定理</strong> 设函数 <span class="math inline">\(g(x)\in R[a,b]\)</span>, 有以下三种情况: (1) 若函数 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> <font color="red"><strong>单调增</strong></font>, 且对于 <span class="math inline">\(\forall x\in[a,b]\)</span>, 有 <span class="math inline">\(f(x)\geqslant 0\)</span>, 则 <span class="math inline">\(\exists\xi_1\in[a,b]\)</span>, s.t. <span class="math display">\[\int_a^b f(x)g(x){\rm d}x=f(b)\int_{\xi_1}^b g(x){\rm d}x.\]</span> (2) 若函数 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> <font color="red"><strong>单调减</strong></font>, 且对于 <span class="math inline">\(\forall x\in[a,b]\)</span>, 有 <span class="math inline">\(f(x)\geqslant 0\)</span>, 则 <span class="math inline">\(\exists\xi_2\in[a,b]\)</span>, s.t. <span class="math display">\[\int_a^b f(x)g(x){\rm d}x=f(a)\int_a^{\xi_2} g(x){\rm d}x.\]</span> (3) 若函数 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> <font color="red"><strong>单调</strong></font>, 则 <span class="math inline">\(\exists\xi\in[a,b]\)</span>, s.t. <span class="math display">\[\int_a^b f(x)g(x){\rm d}x=f(a)\int_a^\xi g(x){\rm d}x+f(b)\int_\xi^b g(x){\rm d}x.\]</span></p></blockquote><h2 id="参考文献">参考文献</h2><ol type="1"><li>伍胜建. 数学分析.第2册[M]. 北京大学出版社, 2010.</li><li>裴礼文. 数学分析中的典型问题与方法-第2版[M]. 高等教育出版社, 2006.</li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 数学分析 </tag>
            
            <tag> 保研 </tag>
            
            <tag> 保研复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数学分析拾遗[1]——一些不等式</title>
      <link href="/2018/03/13/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E6%8B%BE%E9%81%97-1-%E2%80%94%E2%80%94%E4%B8%80%E4%BA%9B%E4%B8%8D%E7%AD%89%E5%BC%8F/"/>
      <content type="html"><![CDATA[<h2 id="均值不等式">均值不等式</h2><center><font color="red"><strong>平方 <span class="math inline">\(\geqslant\)</span> 算数 <span class="math inline">\(\geqslant\)</span> 几何 <span class="math inline">\(\geqslant\)</span> 调和</strong><font></font></font></center><h3 id="定理内容">定理内容</h3><blockquote><p><strong>均值不等式</strong> <span class="math inline">\(\forall a_1,\cdots,a_n\geqslant 0\)</span>, 有 <span class="math display">\[\frac{n}{\sum\nolimits_{i=1}^n\frac{1}{a_i}}\leqslant \sqrt[n]{\prod\nolimits_{i=1}^n a_i}\leqslant \frac{\sum\nolimits_{i=1}^n a_i}{n}\leqslant \sqrt{\frac{\sum\nolimits_{i=1}^n a_i^2}{n}}.\]</span>取等号当且仅当 <span class="math inline">\(a_1=\cdots=a_n\)</span>.</p></blockquote><h3 id="简略证明">简略证明</h3><p>只证算术 <span class="math inline">\(\leqslant\)</span> 几何部分: 1. 先证对于 <span class="math inline">\(n=2^k\)</span> 成立: 由二元均值不等式可得<span class="math display">\[\begin{align}\sqrt[2^k]{a_1\cdots a_{2^k}} &amp;\leqslant \sqrt[2^{k-1}]{\frac{a_1+a_2}{2}+\frac{a_3+a_4}{2}+\cdots+\frac{a_{2^k-1}+a_{2^k}}{2}} \\&amp;\leqslant \cdots\leqslant \frac{a_1+\cdots+a_{2^k}}{2^k}.\end{align}\]</span> 2. <strong>反向归纳</strong>: 记 <span class="math inline">\(A=\frac{a_1+\cdots+a_n}{n}\)</span>, 则 <span class="math inline">\(nA=\sum a_i\)</span>. 设 <span class="math inline">\(n+1\)</span> 时不等式成立, 下证 <span class="math inline">\(n\)</span> 时成立: <span class="math display">\[\begin{align}A=\frac{nA+A}{n+1} &amp;= \frac{a_1+\cdots+a_n+A}{n+1} \\&amp;\geqslant  \sqrt[n+1]{a_1\cdots a_n A}.\end{align}\]</span> 于是 <span class="math inline">\(A^{n+1}\geqslant a_1\cdots a_nA\)</span>, 即 <span class="math display">\[A\geqslant \sqrt[n]{a_1\cdots a_n}.\]</span></p><h2 id="hölder不等式">Hölder不等式</h2><h3 id="定理内容-1">定理内容</h3><p><font color="red"><span class="math display">\[a\cdot b\leqslant \Vert a\Vert_p\cdot\Vert b\Vert_q,~\frac{1}{p}+\frac{1}{q}=1\]</span><font></font></font></p><blockquote><p><strong>Hölder不等式</strong> 设 <span class="math inline">\(a_i,b_i\geqslant 0\)</span>, <span class="math inline">\(\frac{1}{p}+\frac{1}{q}=1\)</span>, 则 (1) 当 <span class="math inline">\(p&gt;1\)</span> 时, <span class="math display">\[\sum\limits_{i=1}^n a_ib_i\leqslant (\sum\limits_{i=1}^n a_i^p)^{1/p}(\sum\limits_{i=1}^n a_i^q)^{1/q}.\]</span> (2) 当 <span class="math inline">\(p&lt;1\)</span> 时, <span class="math display">\[\sum\limits_{i=1}^n a_ib_i\geqslant (\sum\limits_{i=1}^n a_i^p)^{1/p}(\sum\limits_{i=1}^n a_i^q)^{1/q}.\]</span> 等号当且仅当 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(b_i\)</span> 成比例时取得.</p></blockquote><h3 id="简略证明-1">简略证明</h3><p>只证 (1): 当 <span class="math inline">\(p&gt;1\)</span> 时, 易有 <span class="math inline">\(q&lt;1\)</span>. 此时有 <span class="math display">\[\begin{align}\frac{a\cdot b}{\Vert a\Vert_p\cdot\Vert b\Vert_q} &amp;= \sum \left(\frac{a_i^p}{\sum a_i^p}\right)^{1/p}\left(\frac{b_i^q}{\sum b_i^q}\right)^{1/q} \\&amp;\leqslant \sum \left[\frac{1}{p}\left(\frac{a_i^p}{\sum a_i^p}\right)+\frac{1}{q}\left(\frac{b_i^q}{\sum b_i^q}\right)\right] \\&amp;= \frac{1}{p}\sum\frac{a_i^p}{\sum a_i^p}+\frac{1}{q}\sum\frac{b_i^q}{\sum b_i^q} \\&amp;= \frac{1}{p}+\frac{1}{q} =1.\end{align}\]</span></p><h2 id="minkowski不等式">Minkowski不等式</h2><h3 id="定理内容-2">定理内容</h3><p><font color="red"><span class="math display">\[\Vert a+b\Vert_p\leqslant \Vert a\Vert_p\cdot\Vert b\Vert_p\]</span><font></font></font></p><blockquote><p><strong>Minkowski不等式</strong> 对于 <span class="math inline">\(\forall r\neq 0,1\in\mathbb{R}\)</span>, 以及 <span class="math inline">\(a_i,b_i\geqslant 0\)</span>, 有 (1) 当 <span class="math inline">\(r&gt;1\)</span> 时, <span class="math display">\[(\sum\limits_{i=1}^n(a_i+b_i)^r)^{1/r}\leqslant (\sum\limits_{i=1}^n a_i^r)^{1/r}+(\sum\limits_{i=1}^n b_i^r)^{1/r}\]</span> (2) 当 <span class="math inline">\(r&lt;1\)</span> 时, <span class="math display">\[(\sum\limits_{i=1}^n(a_i+b_i)^r)^{1/r}\geqslant (\sum\limits_{i=1}^n a_i^r)^{1/r}+(\sum\limits_{i=1}^n b_i^r)^{1/r}\]</span></p></blockquote><h3 id="简略证明-2">简略证明</h3><p>只证 (1): 当 <span class="math inline">\(r&gt;1\)</span> 时, 令 <span class="math inline">\(s_i=a_i+b_i\)</span>, 则有 <span class="math display">\[\begin{align}\sum s_i^r &amp;= \sum (a_i+b_i)^r \\&amp;= \sum (a_i+b_i)(a_i+b_i)^{r-1} \\&amp;= \sum a_is_i^{r-1}+\sum b_is_i^{r-1}.\end{align}\]</span> 令 <span class="math inline">\(p=r\)</span>, <span class="math inline">\(q=\frac{r}{r-1}\)</span>, 则 <span class="math inline">\(\frac{1}{p}+\frac{1}{q}=1\)</span>, 由Hölder不等式可得: <span class="math display">\[\begin{align}\sum s_i^r &amp;\leqslant (\sum a_i^r)^{\frac{1}{r}}(\sum s_i^r)^{\frac{r-1}{r}}+(\sum b_i^r)^{\frac{1}{r}}(\sum s_i^r)^{\frac{r-1}{r}} \\&amp;= [(\sum a_i^r)^{\frac{1}{r}}+(\sum b_i^r)^{\frac{1}{r}}]\cdot (\sum s_i^r)^{1-\frac{1}{r}}.\end{align}\]</span> 两边同乘 <span class="math inline">\((\sum s_i^r)^{1-\frac{1}{r}}\)</span> 即可得到Minkowski不等式.</p><h2 id="young不等式">Young不等式</h2><h3 id="定理内容-3">定理内容</h3><blockquote><p><strong>Young不等式</strong> 设 <span class="math inline">\(f(x)\in[0,+\infty)\)</span> 单调增, <span class="math inline">\(f(0)=0\)</span>, <span class="math inline">\(a,b&gt;0\)</span>, 则 <span class="math display">\[ab\leqslant \int_0^a f(x){\rm d}x+\int_0^b f^{-1}(x){\rm d}x.\]</span> 等号当且仅当 <span class="math inline">\(f(a)=b\)</span> 时成立.</p></blockquote><h3 id="简略证明-3">简略证明</h3><p>从几何上看十分直观.</p><h2 id="参考文献">参考文献</h2><ol type="1"><li>裴礼文. 数学分析中的典型问题与方法-第2版[M]. 高等教育出版社, 2006.</li><li>伍胜建. 数学分析.第2册[M]. 北京大学出版社, 2010.</li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 数学分析 </tag>
            
            <tag> 保研 </tag>
            
            <tag> 保研复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>范畴论学习笔记</title>
      <link href="/2018/03/02/%E8%8C%83%E7%95%B4%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <content type="html"><![CDATA[<h2 id="何为范畴">何为范畴</h2><h3 id="范畴-category">范畴: category</h3><h4 id="范畴的定义">范畴的定义</h4><p>一个范畴 <span class="math inline">\(\mathscr{C}\)</span> 包含一些对象和一些箭头:</p><ol type="1"><li><strong>对象</strong>(Objects): 记作 <span class="math inline">\(A,B,C,\cdots\)</span>;</li><li><strong>箭头</strong>(Morphism): 记作 <span class="math inline">\(f,g,h,\cdots\)</span>.</li></ol><p>这些对象和箭头需要满足以下几个条件:</p><ul><li><strong>箭头有唯一的源和目标</strong>: <span class="math inline">\(\forall f\in\mathscr{C}\)</span>, <span class="math inline">\(\exists\)</span> 唯一 <span class="math inline">\({\rm src}f,{\rm tar} f\in\mathscr{C}\)</span>. 若 <span class="math inline">\({\rm scr}f = A\)</span>, <span class="math inline">\({\rm tar}f = B\)</span>, 则可以记为 <span class="math inline">\(f:A\to B\)</span>.</li><li><strong>箭头可以复合</strong>: <span class="math inline">\(\forall f,g\in\mathscr{C}\)</span>, 设 <span class="math inline">\(f:A\to B\)</span>, <span class="math inline">\(g:B\to C\)</span>, <span class="math inline">\(\exists h=g\circ f:A\to C\)</span>. 称为 “<span class="math inline">\(g\)</span> following <span class="math inline">\(f\)</span>”, 即二者的复合.</li><li><strong>每个对象必须有单位箭头</strong>: <span class="math inline">\(\forall A\in\mathscr{C}\)</span>, <span class="math inline">\(\exists {\rm id}_A:A\to A\in\mathscr{C}\)</span>.</li></ul><p>箭头还满足以下两条性质:</p><ol type="1"><li><strong><span class="math inline">\(\circ\)</span> 的结合律</strong>: <span class="math inline">\(\forall f:A\to B,~g:B\to C,~h:C\to D\)</span>, 有 <span class="math display">\[h\circ(g\circ f)=(h\circ g)\circ f.\]</span></li><li><strong><span class="math inline">\({\rm id}_A\)</span> 是 <span class="math inline">\(\circ\)</span> 运算的单位元</strong>: <span class="math inline">\(\forall f:A\to B\)</span>, 有 <span class="math display">\[f\circ {\rm id}_A=f={\rm id}_B\circ f.\]</span></li></ol><h4 id="范畴的例子">范畴的例子</h4><ul><li><strong>幺半群 Monoid</strong></li></ul><p>幺半群 <span class="math inline">\((M,\cdot)\)</span> 指不满足“所有元素可逆”的群:</p><ol type="1"><li><strong>存在单位元</strong>: <span class="math inline">\(\exists e\)</span>, s.t. <span class="math inline">\(\forall a\in M\)</span>, <span class="math inline">\(a\cdot e=a=e\cdot a\)</span>;</li><li><strong>乘法结合律</strong>: <span class="math inline">\(\forall a,b,c\in M\)</span>, <span class="math inline">\((a\cdot b)\cdot c=a\cdot (b\cdot c)\)</span>.</li></ol><p>在幺半群 <span class="math inline">\(M\)</span> 的基础上, 可定义范畴 <span class="math inline">\(\mathscr{M}\)</span> 如下:</p><ol type="1"><li><strong><span class="math inline">\(\mathscr{M}\)</span>-对象</strong>: 任取一个集合 <span class="math inline">\(S\)</span> 作为 <span class="math inline">\(\mathscr{M}\)</span> 的对象;</li><li><strong><span class="math inline">\(\mathscr{M}\)</span>-箭头</strong>: 用 <span class="math inline">\(M\)</span> 中的元素表示 <span class="math inline">\(\mathscr{M}\)</span> 上的箭头:<ol type="1"><li>箭头的复合定义为元素的乘积: <span class="math display">\[(a\circ b)_\mathscr{M}=(a\cdot b)_M;\]</span></li><li>单位箭头定义为 <span class="math inline">\(M\)</span> 的单位元: <span class="math display">\[{\rm id}_\mathscr{M}=e_M.\]</span></li></ol></li></ol><ul><li><strong>幺半范畴</strong></li></ul><p>考虑所有幺半群组成的集合, 可如下定义范畴 <span class="math inline">\(\mathscr{M}\)</span>:</p><ol type="1"><li><strong><span class="math inline">\(\mathscr{M}\)</span>-对象</strong>: 幺半群全体作为 <span class="math inline">\(\mathscr{M}\)</span> 的对象;</li><li><strong><span class="math inline">\(\mathscr{M}\)</span>-箭头</strong>: 所有的幺半群同态作为 <span class="math inline">\(\mathscr{M}\)</span> 的箭头.</li></ol><p>该范畴称为<strong>幺半范畴</strong>, 记作 <span class="math inline">\({\tt Mon}\)</span>.</p><ul><li><strong>偏序集</strong></li></ul><p>在一个集合 <span class="math inline">\(S\)</span> 上, 一个偏序 <span class="math inline">\(\leqslant\)</span> 的定义如下:</p><ol type="1"><li><strong>自反性</strong>: <span class="math inline">\(\forall x\in S\)</span>, <span class="math inline">\(x\leqslant x\)</span>;</li><li><strong>反对称性</strong>: <span class="math inline">\(x\leqslant y~\text{且}~y\leqslant x\iff x=y\)</span>;</li><li><strong>传递性</strong>: <span class="math inline">\(x\leqslant y,~y\leqslant z\Longrightarrow x\leqslant z\)</span>.</li></ol><p>集合 <span class="math inline">\(S\)</span> 定义了偏序后, 就称为一个<strong>偏序集</strong>. 在偏序集 <span class="math inline">\(S\)</span> 的基础上可以如下定义范畴 <span class="math inline">\(\mathscr{C}\)</span>:</p><ol type="1"><li><strong><span class="math inline">\(\mathscr{C}\)</span>-对象</strong>: <span class="math inline">\(S\)</span> 中的元素作为 <span class="math inline">\(\mathscr{C}\)</span> 的对象;</li><li><strong><span class="math inline">\(\mathscr{C}\)</span>-箭头</strong>: 若 <span class="math inline">\(A\leqslant B\in S\)</span>, 则存在唯一的箭头 <span class="math inline">\(f:A\to B\)</span>.</li></ol><p>容易验证这样定义的 <span class="math inline">\(\mathscr{C}\)</span> 是一个范畴.</p><ul><li><strong>偏序范畴</strong></li></ul><p>考虑所有偏序集组成的集合, 可如下定义范畴 <span class="math inline">\(\mathscr{C}\)</span>:</p><ol type="1"><li><strong><span class="math inline">\(\mathscr{C}\)</span>-对象</strong>: 偏序集全体作为 <span class="math inline">\(\mathscr{C}\)</span> 的对象;</li><li><strong><span class="math inline">\(\mathscr{C}\)</span>-箭头</strong>: 所有的保序映射作为 <span class="math inline">\(\mathscr{C}\)</span> 的箭头.</li></ol><p>如此定义的范畴, 称为<strong>偏序范畴</strong>, 记作 <span class="math inline">\({\tt Pos}\)</span>.</p><h4 id="几个特殊的范畴">几个特殊的范畴</h4><ul><li><strong>空范畴: empty category</strong></li></ul><p>没有对象也没有箭头的范畴, 称为<strong>空范畴</strong>.</p><ul><li><strong>一元范畴: <span class="math inline">\(1\)</span></strong></li></ul><p>只有一个单位对象和一个单位箭头的范畴, 记作 <span class="math inline">\(1\)</span>.</p><ul><li><strong>二元范畴: von Neumann ordinal <span class="math inline">\(2\)</span></strong></li></ul><p>集合 <span class="math inline">\(\{\varnothing,\{\varnothing\}\}\)</span> 上赋予单位箭头以及 <span class="math inline">\(\varnothing\to\{\varnothing\}\)</span> 箭头的范畴.</p><ul><li>集合范畴</li></ul><p>考虑如下范畴 <span class="math inline">\({\tt Set}\)</span>:</p><ol type="1"><li>对象: 所有集合<strong>(注意所有集合全体不是一个集合)</strong>;</li><li>箭头: 集合间的映射(原文为set-function) <span class="math inline">\(f:X\to Y\)</span>.<ol type="1"><li>单位箭头是恒等映射, 显然存在且唯一;</li><li>箭头的复合也是很自然的.</li></ol></li></ol><p>该范畴被称为集合范畴.</p><ul><li>逻辑范畴</li></ul><p>在形式语言 <span class="math inline">\(T\)</span> 中考虑如下范畴 <span class="math inline">\({\tt Proof}_T\)</span>:</p><ol type="1"><li>对象: 所有 <span class="math inline">\(T\)</span> 中的语句;</li><li>箭头: <span class="math inline">\(\forall\varphi,\psi\in T\)</span>, 存在箭头 <span class="math inline">\(\varphi\to\psi\iff\varphi\vdash\psi\)</span>.<ol type="1"><li>单位箭头是恒等映射, 显然存在且唯一;</li><li>箭头的复合根据 <span class="math inline">\(\vdash\)</span> 的定义显然.</li></ol></li></ol><p>该范畴称为 <span class="math inline">\(T\)</span> 上的逻辑范畴.</p><h4 id="一些常见范畴的定义和记号">一些常见范畴的定义和记号</h4><p>如下表所示, 整理自<a href="http://www.logicmatters.net/resources/pdfs/GentleIntro.pdf" target="_blank" rel="noopener">Category Theory: A Gentle Introductio</a>.</p><table><thead><tr class="header"><th style="text-align: center;">范畴</th><th style="text-align: center;">记号</th><th style="text-align: center;">对象</th><th style="text-align: center;">箭头</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">群范畴</td><td style="text-align: center;"><span class="math inline">\({\tt Grp}\)</span></td><td style="text-align: center;">所有的群</td><td style="text-align: center;">群同态</td></tr><tr class="even"><td style="text-align: center;">交换群范畴</td><td style="text-align: center;"><span class="math inline">\({\tt Ab}\)</span></td><td style="text-align: center;">所有的交换群</td><td style="text-align: center;">群同态</td></tr><tr class="odd"><td style="text-align: center;">环范畴</td><td style="text-align: center;"><span class="math inline">\({\tt Rng}\)</span></td><td style="text-align: center;">所有的环</td><td style="text-align: center;">环同态</td></tr><tr class="even"><td style="text-align: center;">布尔范畴</td><td style="text-align: center;"><span class="math inline">\({\tt Bool}\)</span></td><td style="text-align: center;">所有的布尔代数</td><td style="text-align: center;">结构保存映射</td></tr><tr class="odd"><td style="text-align: center;">偏序/全序范畴</td><td style="text-align: center;"><span class="math inline">\({\tt Pos/Tot}\)</span></td><td style="text-align: center;">所有的偏序/全序集</td><td style="text-align: center;">保序映射</td></tr><tr class="even"><td style="text-align: center;">拓扑/度量空间范畴</td><td style="text-align: center;"><span class="math inline">\({\tt Top/Met}\)</span></td><td style="text-align: center;">所有的拓扑/度量空间</td><td style="text-align: center;">连续映射</td></tr><tr class="odd"><td style="text-align: center;">场 <span class="math inline">\(K\)</span> 上的向量空间范畴</td><td style="text-align: center;"><span class="math inline">\({\tt Vect}_K\)</span></td><td style="text-align: center;">所有的向量空间</td><td style="text-align: center;">线性映射</td></tr><tr class="even"><td style="text-align: center;">集合/有限集范畴</td><td style="text-align: center;"><span class="math inline">\({\tt Set/FinSet}\)</span></td><td style="text-align: center;">所有的集合/有限集</td><td style="text-align: center;">集合映射 <span class="math inline">\(f:X\to Y\)</span></td></tr><tr class="odd"><td style="text-align: center;">逻辑范畴</td><td style="text-align: center;"><span class="math inline">\({\tt Proof}_T\)</span></td><td style="text-align: center;"><span class="math inline">\(T\)</span> 中的所有语句</td><td style="text-align: center;">按照逻辑推出关系 <span class="math inline">\(\vdash\)</span> 定义箭头</td></tr></tbody></table><h2 id="范畴生范畴">范畴生范畴</h2><p>从已有的一个范畴可以构建出新的范畴, 有以下的一些方法</p><h3 id="逆范畴-opposite-category">逆范畴: opposite category</h3><p>一个范畴 <span class="math inline">\(\mathscr{C}\)</span> 的逆范畴 <span class="math inline">\(\mathscr{C}^{op}\)</span> 定义如下:</p><ol type="1"><li><span class="math inline">\(\mathscr{C}^{op}\)</span>-对象: <span class="math inline">\(\mathscr{C}\)</span> 的对象;</li><li><span class="math inline">\(\mathscr{C}^{op}\)</span>-箭头: <span class="math inline">\(f:B\to A~\text{in}~\mathscr{C}^{op}\iff f:A\to B~\text{in}~\mathscr{C}\)</span><ol type="1"><li>单位箭头: <span class="math inline">\({\rm id}_A^{op}={\rm id}_A\)</span>, <span class="math inline">\(\forall A\)</span>;</li><li>复合箭头: <span class="math inline">\(f\circ^{op}g=g\circ f\)</span>.</li></ol></li></ol><p>根据定义可知:</p><ol type="1"><li>每个范畴 <span class="math inline">\(\mathscr{C}\)</span> 都存在一个对偶 <span class="math inline">\(\mathscr{C}^{op}\)</span>;</li><li>对偶的对偶就是自身: <span class="math inline">\((\mathscr{C}^{op})^{op}=\mathscr{C}\)</span>.</li></ol><h3 id="子范畴-subcategory">子范畴: subcategory</h3><p>对于一个范畴 <span class="math inline">\(\mathscr{C}\)</span>, 若 <span class="math inline">\(\exists\)</span> 范畴 <span class="math inline">\(\mathscr{S}\)</span>, s.t.</p><ol type="1"><li><span class="math inline">\(\mathscr{S}\)</span> 的对象全部都是 <span class="math inline">\(\mathscr{C}\)</span> 的(全部或部分)对象;</li><li><span class="math inline">\(\mathscr{S}\)</span> 的箭头全部都是 <span class="math inline">\(\mathscr{C}\)</span> 的(全部或部分)箭头.</li></ol><p>且满足:</p><ol type="1"><li><span class="math inline">\(\mathscr{S}\)</span> 继承 <span class="math inline">\(\mathscr{C}\)</span> 中的单位箭头;</li><li><span class="math inline">\(\mathscr{S}\)</span> 继承 <span class="math inline">\(\mathscr{C}\)</span> 的结合律.</li></ol><p>则称 <span class="math inline">\(\mathscr{S}\)</span> 是 <span class="math inline">\(\mathscr{C}\)</span> 的一个<strong>子范畴</strong>.</p><p>由定义立即得到:</p><ul><li><span class="math inline">\({\tt FinSet}\)</span> 是 <span class="math inline">\({\tt Set}\)</span> 的子范畴;</li><li><span class="math inline">\({\tt Ab}\)</span> 是 <span class="math inline">\({\tt Grp}\)</span> 的子范畴.</li></ul><p>特别地, 若对于 <span class="math inline">\(\forall\mathscr{S}\)</span> 对象 <span class="math inline">\(A,B\)</span>, <span class="math inline">\(\mathscr{S}\)</span> 中包含了 <span class="math inline">\(\mathscr{C}\)</span> 中所有的 <span class="math inline">\(A\to B\)</span> 的箭头, 则称 <span class="math inline">\(\mathscr{S}\)</span> 是 <span class="math inline">\(\mathscr{C}\)</span> 的一个<strong>满子范畴</strong>.</p><h3 id="积范畴-product-category">积范畴: product category</h3><p>设 <span class="math inline">\(\mathscr{C}\)</span> 和 <span class="math inline">\(\mathscr{D}\)</span> 是范畴, 如下定义二者的积范畴 <span class="math inline">\(\mathscr{C}\times\mathscr{D}\)</span>:</p><ol type="1"><li><span class="math inline">\(\mathscr{C}\times\mathscr{D}\)</span>-对象: <span class="math inline">\((C,D)\)</span>, 其中 <span class="math inline">\(C,D\)</span> 分别是 <span class="math inline">\(\mathscr{C},\mathscr{D}\)</span> 的对象;</li><li><span class="math inline">\(\mathscr{C}\times\mathscr{D}\)</span>-箭头: <span class="math inline">\((f,g):(C_1,D_1)\to (C_2,D_2)\iff f:C_1\to C_2~\text{in}~\mathscr{C},g:D_1\to D_2~\text{in}~\mathscr{D}\)</span><ol type="1"><li>单位箭头: <span class="math inline">\({\rm id}_{(C,D)}=({\rm id}_C,{\rm id}_D)\)</span>;</li><li>复合箭头: <span class="math inline">\((f_1,g_1)\circ (f_2,g_2)=(f_1\circ_\mathscr{C} f_2,g_1\circ_\mathscr{D} g_2)\)</span>.</li></ol></li></ol><h3 id="商范畴-quotient-category">商范畴: quotient category</h3><p>设 <span class="math inline">\(\mathscr{C}\)</span> 是一个范畴, <span class="math inline">\(\sim\)</span> 是其上的一个同余关系, 则 <span class="math inline">\(\mathscr{C}/\sim\)</span> 是一个以 <span class="math inline">\(\mathscr{C}\)</span> 对象为对象, <span class="math inline">\(\sim\)</span> 等价类为箭头的一个范畴.</p><p>例如对于拓扑范畴 <span class="math inline">\({\tt Top}\)</span>, 考虑其上的同伦关系, 所得的商空间 <span class="math inline">\({\tt Top}/\sim\)</span> 称为同伦拓扑范畴, 记作 <span class="math inline">\({\tt hTop}\)</span>.</p><h3 id="箭头范畴-arrow-category">箭头范畴: arrow category</h3><p>设 <span class="math inline">\(\mathscr{C}\)</span> 是一个范畴, 其箭头范畴 <span class="math inline">\(\mathscr{C}^\to\)</span> 定义如下:</p><ol type="1"><li><span class="math inline">\(\mathscr{C}^\to\)</span>-对象: <span class="math inline">\(\mathscr{C}\)</span> 中的箭头;</li><li><span class="math inline">\(\mathscr{C}^\to\)</span>-箭头: 对于两个 <span class="math inline">\(\mathscr{C}^\to\)</span> 对象 <span class="math inline">\(f_1, f_2\)</span>, 一个 <span class="math inline">\(\mathscr{C}^\to\)</span> 箭头 <span class="math inline">\(f_1\to f_2\)</span> 是一个使得下图交换的一个二元组 <span class="math inline">\((j,k)\)</span>:<span class="math display">\[\begin{matrix}X_1~~ &amp; \xrightarrow{j} &amp; X_2~~ \\\downarrow \tiny{f_1} &amp; &amp; \downarrow \tiny{f_2} \\Y_1~~ &amp; \xrightarrow{k} &amp; Y_2~~ \\\end{matrix}\]</span><ol type="1"><li>单位箭头: <span class="math inline">\(f:X\to Y\)</span> 的单位箭头为 <span class="math inline">\(({\rm id}_X,{\rm id}_Y)\)</span>;</li><li>复合箭头: <span class="math inline">\((j_1,k_1):f_1 \to f_2\)</span> 和 <span class="math inline">\((j_2,k_2):f_2 \to f_3\)</span> 的复合为:<span class="math display">\[(j_2\circ j_1,~k_2\circ k_1):f_1\to f_3.\]</span></li></ol></li></ol><h3 id="切片范畴-slice-category">切片范畴: slice category</h3><p>设 <span class="math inline">\(\mathscr{C}\)</span> 是一个范畴, <span class="math inline">\(I\)</span> 是 <span class="math inline">\(\mathscr{C}\)</span> 的一个对象, 则 <span class="math inline">\(\mathscr{C}\)</span> 在 <span class="math inline">\(I\)</span> 的切片范畴 <span class="math inline">\(\mathscr{C}/I\)</span> 定义如下:</p><ol type="1"><li><span class="math inline">\(\mathscr{C}/I\)</span>-对象: 二元组 <span class="math inline">\((A,f)\)</span>, 其中 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(\mathscr{C}\)</span> 的对象, <span class="math inline">\(f:A\to I\)</span> 是 <span class="math inline">\(\mathscr{C}\)</span> 的箭头;</li><li><span class="math inline">\(\mathscr{C}/I\)</span>-箭头: 箭头 <span class="math inline">\((A,f)\to (B,g)\)</span> 是在 <span class="math inline">\(\mathscr{C}\)</span> 中满足 <span class="math inline">\(g\circ j=f\)</span> 的箭头 <span class="math inline">\(j:A\to B\)</span>.<ol type="1"><li>单位箭头: 对象 <span class="math inline">\((A,f)\)</span> 的单位箭头是 <span class="math inline">\(\mathscr{C}\)</span> 的单位箭头 <span class="math inline">\({\rm id}_A\)</span>;</li><li>复合箭头: 箭头 <span class="math inline">\(j:(A,f)\to(B,g)\)</span> 和 <span class="math inline">\(k:(B,g)\to(C,h)\)</span> 的复合为 <span class="math display">\[k\circ_{\mathscr{C}/I} j:(A,f)\to(C,h)=k\circ_\mathscr{C} j:A\to C.\]</span></li></ol></li></ol><h2 id="箭头的种类">箭头的种类</h2><p>用范畴的语言来定义单射和满射.</p><h3 id="单态-monomorphism">单态: monomorphism</h3><h4 id="定义">定义</h4><blockquote><p><strong>单态</strong>: 设 <span class="math inline">\(\mathscr{C}\)</span> 是一个范畴, 其中的一个箭头 <span class="math inline">\(f:B\to C\)</span> 是一个单态<strong>当且仅当</strong>它满足左消去律. 即对于 <span class="math inline">\(\forall\)</span> 映射 <span class="math inline">\(g:A\to B,~h:A\to B\)</span>, 有<span class="math display">\[f\circ g=f\circ h\iff g=h.\]</span></p></blockquote><h4 id="例子">例子</h4><ol type="1"><li><span class="math inline">\({\tt Set}\)</span> 中的箭头是单态当且仅当其对应的映射是单射;</li><li><span class="math inline">\({\tt Grp}\)</span> 中的箭头是单态当且仅当其对应的同态是单同态;</li><li>单位箭头 <span class="math inline">\({\rm id}_A\)</span> 是单态.</li></ol><h4 id="性质">性质</h4><ol type="1"><li>如果 <span class="math inline">\(f,g\)</span> 是单态, 则 <span class="math inline">\(f\circ g\)</span> 是单态;</li><li>如果 <span class="math inline">\(f\circ g\)</span> 是单态, 则 <span class="math inline">\(g\)</span> 是单态.</li></ol><h3 id="满态-epimorphism">满态: epimorphism</h3><h4 id="定义-1">定义</h4><blockquote><p><strong>满态</strong>: 设 <span class="math inline">\(\mathscr{C}\)</span> 是一个范畴, 其中的一个箭头 <span class="math inline">\(f:B\to C\)</span> 是一个满态<strong>当且仅当</strong>它满足右消去律. 即对于 <span class="math inline">\(\forall\)</span> 映射 <span class="math inline">\(g:C\to D,~h:C\to D\)</span>, 有<span class="math display">\[g\circ f=h\circ f\iff g=h.\]</span></p></blockquote><h4 id="例子-1">例子</h4><ol type="1"><li><span class="math inline">\({\tt Set}\)</span> 中的箭头是满态当且仅当其对应的映射是满射;</li><li><span class="math inline">\({\tt Grp}\)</span> 中的箭头是满态当且仅当其对应的同态是满同态;</li><li>单位箭头 <span class="math inline">\({\rm id}_A\)</span> 是满态.</li></ol><h4 id="性质-1">性质</h4><ol type="1"><li>如果 <span class="math inline">\(f,g\)</span> 是满态, 则 <span class="math inline">\(f\circ g\)</span> 是满态;</li><li>如果 <span class="math inline">\(f\circ g\)</span> 是满态, 则 <span class="math inline">\(f\)</span> 是满态.</li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 范畴论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学拓扑学试卷</title>
      <link href="/2018/01/11/BNU-Topology-Exam/"/>
      <content type="html"><![CDATA[<h2 id="试题">试题</h2><ol type="1"><li><p>叙述 <span class="math inline">\(T_0\)</span>, <span class="math inline">\(T_1\)</span>, <span class="math inline">\(T_2\)</span> 的定义, 并分别举出 <span class="math inline">\(T_0\)</span> 但不 <span class="math inline">\(T_1\)</span>, 以及 <span class="math inline">\(T_1\)</span> 但不 <span class="math inline">\(T_2\)</span> 的空间的例子.</p></li><li><p>在 <span class="math inline">\(X\times X\)</span> 上定义映射 <span class="math inline">\(\Delta: X\rightarrow X\times X,~\Delta(x)=(x,x)\)</span>, 证明: <span class="math inline">\(X\)</span> 是Hausdorff空间当且仅当 <span class="math inline">\(\Delta(X)\)</span> 是 <span class="math inline">\(X\times X\)</span> 的闭集.</p></li><li><p>设 <span class="math inline">\(\mathcal{T}\)</span> 是 <span class="math inline">\(\mathbb{R}^1\)</span> 上的余有限拓扑, 讨论其紧性、连通性和道路连通性.</p></li><li>考虑拓扑群作用 <span class="math inline">\(\mathbb{S}^1\times B^2\to B^2,~(z,w)\mapsto zw\)</span>.<ol type="1"><li>求 <span class="math inline">\(B^2\)</span> 中一点 <span class="math inline">\(w\)</span> 的迷向群;</li><li>证明其轨道空间同构于单位闭区间 <span class="math inline">\(I\)</span>.</li></ol></li><li><p><span class="math inline">\(X\)</span> 是道路连通曲面, 证明: 连续映射 <span class="math inline">\(f: X\to T^2\)</span> 零伦当且仅当 <span class="math inline">\(f\)</span> 诱导的同态平凡.</p></li></ol><h2 id="简略解答">简略解答</h2><center><strong>有差错不负任何责任.</strong></center><ol type="1"><li>定义参见课本P19: Def 2.28. 例子参见课本 P19: Ex 1, Ex 2.<ol type="1"><li><span class="math inline">\(T_0\)</span> 但不 <span class="math inline">\(T_1\)</span>: <span class="math inline">\(X=\{0,1\}\)</span>, <span class="math inline">\(\mathcal{T}=\{\varnothing, \{0\}, X\}\)</span>;</li><li><span class="math inline">\(T_1\)</span> 但不 <span class="math inline">\(T_2\)</span>: <span class="math inline">\(\mathbb{R}^1\)</span> 上的余有限拓扑.</li></ol></li><li><p>题目参见课本 P35 习题3.2 第5题. 解答参见 <a href="http://www.lizhechen.com/2017/10/08/%E6%8B%93%E6%89%91%E5%AD%A6%E9%A2%98%E7%9B%AE/" target="_blank" rel="noopener">Zhechen: 拓扑学题目</a>.</p></li><li><p>紧致, 连通, 且道路连通. 证明略. 参见课本P47 习题3.4 第7题.</p></li><li>简略证明:<ol type="1"><li>迷向群平凡, 直接按照定义求即可;</li><li>考虑映射 <span class="math inline">\(f: B^2\to I,~re^{i\theta}\mapsto r\)</span>. 则 <span class="math inline">\(f\)</span> 是紧空间到Hausdorff空间的连续满射, 因而是商映射. 于是 <span class="math inline">\(f/\sim\cong I\)</span>. 只需要研究其轨道空间, 说明轨道空间就是 <span class="math inline">\(X/\sim\)</span> 即可.</li></ol></li><li><p>题目类似于课本 P125 习题6.2 的 1,2 题. 简略解答: 考虑复叠映射 <span class="math inline">\(P: \mathbb{E}^2\to T^2\)</span>. 若诱导的同态平凡, 则 <span class="math inline">\(\mathrm{Im}f_*\subset \mathrm{Im}p_*\)</span>, 因而 <span class="math inline">\(f\)</span> 有提升 <span class="math inline">\(\tilde{f}\)</span>. 又由于 <span class="math inline">\(\mathbb{E}^2\)</span> 是凸集, 故 <span class="math inline">\(\tilde{f}\)</span> 零伦, 故 <span class="math inline">\(f=p\circ\tilde{f}\)</span> 零伦. 反方向略.</p></li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 拓扑学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学泛函分析试题</title>
      <link href="/2018/01/11/BNU-Functional-Analysis-Exam/"/>
      <content type="html"><![CDATA[<ul><li>2017 泛函分析 期末 杨大春</li><li>2018 泛函分析 期末 杨大春</li><li>2019 泛函分析 期末 杨大春</li></ul><h2 id="期末试题">2017 期末试题</h2><center><strong>7, 8, 9 题目不保证与原文完全一致.</strong></center><ol type="1"><li><p>设 <span class="math inline">\(\mathscr{X}\)</span> 是 <span class="math inline">\(B^*\)</span> 空间, <span class="math inline">\(\mathscr{X}_0\)</span> 是 <span class="math inline">\(\mathscr{X}\)</span> 的子空间, 假定 <span class="math inline">\(\exists c\in(0,1)\)</span>, s.t. <span class="math display">\[\inf\limits_{x\in\mathscr{X}_0}\Vert y-x\Vert\leqslant c\Vert y\Vert\quad (\forall y\in\mathscr{X}).\]</span> 求证: <span class="math inline">\(\mathscr{X}_0\)</span> 在 <span class="math inline">\(\mathscr{X}\)</span> 中稠.</p></li><li><p>设 <span class="math inline">\(M\)</span> 是Hilbert空间 <span class="math inline">\(\mathscr{H}\)</span> 的子集, 求证: <span class="math display">\[(M^\perp)^\perp=\overline{\mathrm{span}M}.\]</span></p></li><li><p>设 <span class="math inline">\(\mathscr{H}\)</span> 是Hilbert空间, <span class="math inline">\(A\in\mathscr{L}(\mathscr{H})\)</span>, 且 <span class="math inline">\(\exists m&gt;0\)</span>, s.t. <span class="math display">\[\vert (Ax,x) \vert\geqslant m\Vert x\Vert^2\quad (\forall x\in\mathscr{H}).\]</span> 求证: <span class="math inline">\(\exists A^{-1}\in\mathscr{L}(\mathscr{H})\)</span>.</p></li><li>设 <span class="math inline">\(\mathscr{X}\)</span> 是复线性空间, <span class="math inline">\(p\)</span> 是 <span class="math inline">\(\mathscr{X}\)</span> 上的半模. <span class="math inline">\(\forall x_0\in\mathscr{X}\)</span>, <span class="math inline">\(p(x_0)\neq 0\)</span>. 求证: 存在 <span class="math inline">\(\mathscr{X}\)</span> 上的线性泛函 <span class="math inline">\(f\)</span> s.t.<ol type="1"><li><span class="math inline">\(f(x_0)=1\)</span>;</li><li><span class="math inline">\(\vert f(x)\vert\leqslant p(x)/p(x_0)~(\forall x\in\mathscr{X})\)</span>.</li></ol></li><li><p>设 <span class="math inline">\(\mathscr{X}\)</span> 是 <span class="math inline">\(B^*\)</span> 空间, <span class="math inline">\(E\subset\mathscr{X}\)</span> 是非空均衡闭凸集, <span class="math inline">\(\forall x\in\mathscr{X}\backslash E\)</span>. 求证: <span class="math inline">\(\exists f\in\mathscr{X}^*\)</span> 及 <span class="math inline">\(\alpha&gt;0\)</span>, s.t. <span class="math display">\[\vert f(x)\vert&lt;\alpha&lt;\vert f(x_0)\vert\quad (\forall x\in E).\]</span></p></li><li><p>求证: <span class="math inline">\(B\)</span> 空间是自反的当且仅当其共轭空间是自反的.</p></li><li><p>(不保证与原题完全一致) 设 <span class="math inline">\(\mathscr{X},\mathscr{Y}\)</span> 是Banach空间, 设 <span class="math inline">\(\mathscr{L}(\mathscr{X},\mathscr{Y})\)</span> 是连续线性算子全体, 证明: 一一映射在其中构成一个开集.</p></li><li><p>设 <span class="math inline">\(\mathscr{H}\)</span> 是Hilbert空间, <span class="math inline">\(A,B\in\mathscr{L}(\mathscr{H})\)</span>, 若对 <span class="math inline">\(\forall x,y\in\mathscr{X}\)</span>, 有 <span class="math inline">\((Ax,y)=(x,By)\)</span>, 证明: <span class="math inline">\(A\)</span> 连续.</p></li><li><p>(不保证与原题完全一致) 设 <span class="math inline">\(\mathscr{X}\)</span> 是自反空间, <span class="math inline">\(E\)</span> 是其中的闭凸集, 证明: <span class="math display">\[\exists x_0\in E,~\text{s.t.}~\Vert x_0\Vert=\inf\limits_{x\in E}\Vert x\Vert.\]</span></p></li></ol><h2 id="部分简略解答">部分简略解答</h2><center><strong>7, 8, 9 解答不保证正确性.</strong></center><ol type="1"><li><p>用 F.Riesz 引理, 参见习题1.4.13;</p></li><li><p>参见习题1.6.5;</p></li><li><p>用 Banach 逆映射定理, 参见习题2.3.3;</p></li><li><p>用复 Hahn-Banach 定理, 参见习题2.4.3;</p></li><li><p>用 Ascoli 定理, 参见习题2.4.10;</p></li><li><p>利用自然映射和共轭算子, 参见习题2.5.5;</p></li><li><p>–这是一个差不多的题目的解答<br>先证明一个引理：</p><blockquote><p><strong>LEMMA 1.</strong> <span class="math inline">\(\mathscr{X}\)</span> 是Banach空间, 设 <span class="math inline">\(A\in\mathscr{L}(\mathscr{X})\)</span> 且 <span class="math inline">\(\Vert A\Vert_{\mathscr{L}(\mathscr{X} )}&lt;1\)</span>, 则 <span class="math inline">\((I-A)^{-1}\in\mathscr{L}(\mathscr{X})\)</span> 且 <span class="math display">\[\Vert (I-A)^{-1}\Vert_{\mathscr{L}(\mathscr{X})}\leqslant \frac{1}{1-\Vert A\Vert_  {\mathscr{L}(\mathscr{X})}}.\]</span> 证明略…（</p></blockquote><p>然后仍然是证明开集的正统方法：<span class="math inline">\(\forall A\)</span>, s.t. <span class="math inline">\(A\in\mathscr{L}(\mathscr{X})\)</span> 且 <span class="math inline">\(A^{-1}\in \mathscr{L}(\mathscr{X})\)</span><font color="red">（1. 取集合里的一个元素）</font>, 取 <span class="math inline">\(\forall T\in\mathscr{L}(\mathscr{X})\)</span>, s.t. <span class="math inline">\(\Vert T-A\Vert_{\mathscr{L}(\mathscr{X})} &lt;\frac{1}{\Vert A^{-1}\Vert_{\mathscr{L}(\mathscr{X})}}\)</span><font color="red">（2. 取一个半径, 考虑以 <span class="math inline">\(A\)</span> 为心的开球）</font>, 由 <strong>LEMMA</strong>, 有： <span class="math display">\[ \begin{align} \Vert T^{-1}\Vert_{\mathscr{L}(\mathscr{X})} &amp;= \Vert (T-A+A)^{-1}\Vert_{\mathscr{L}    (\mathscr{X})} = \Vert (I+(T-A)A^{-1})^{-1}A^{-1} \Vert_{\mathscr{L}(\mathscr{X})} \\ &amp;\leqslant \Vert A^{-1}\Vert_{\mathscr{L}(\mathscr{X})}\cdot \Vert (I+(T-A)A^{-1})^{-1} \Vert_{\mathscr{L}(\mathscr{X})} \\ &amp;\leqslant \Vert A^{-1}\Vert_{\mathscr{L}(\mathscr{X})}\cdot \frac{1}{1+\Vert (T-A)A^{-1}   \Vert_{\mathscr{L}(\mathscr{X})}}\quad （由上述引理可得）\\ &amp;&lt; \infty\quad（这里实际上是在证明~T^{-1}~有界） \end{align} \]</span> 其中, <span class="math inline">\(\Vert (T-A)A^{-1}\Vert_{\mathscr{L}(\mathscr{X})}\leqslant \Vert T-A\Vert_{\mathscr {L}(\mathscr{X})}\cdot \Vert A^{-1}\Vert_{\mathscr{L}(\mathscr{X})}&lt;1\)</span>. 至此, 我们证明了 <span class="math inline">\(\forall A\in &quot;\mathscr{L}(\mathscr{X})中的连续线性算子集&quot;\)</span>, <span class="math inline">\(A\)</span> 的邻域 <span class="math inline">\(B (A,\frac{1}{\Vert A^{-1}\Vert_{\mathscr{L}(\mathscr{X})}})\subset&quot;\mathscr{L}(\mathscr{X}) 中的连续线性算子集&quot;\)</span>.<font color="red">（3. 证明 <span class="math inline">\(\forall A\)</span>, 开球都包含在集合里, Over.）</font><br>因此, <span class="math inline">\(\mathscr{L}(\mathscr{X})\)</span> 中的连续线性算子构成一个闭集.</p></li><li><p>由闭图像定理, 只需证明 <span class="math inline">\(A\)</span> 是闭算子且定义域闭. 考虑到定义域 <span class="math inline">\(\mathscr{H}\)</span> 显然闭, 只需要证明 <span class="math inline">\(A\)</span> 是闭算子. 取 <span class="math inline">\(x_n\to x\in \mathscr{H}\)</span>, 设 <span class="math inline">\(Ax_n\to z\)</span>, 则只需证 <span class="math inline">\(Ax=z\)</span>. (由闭算子的定义即可得, 参见课本P96: Def 2.3.9) <strong>一方面</strong>, 由内积的连续性, 即有 <span class="math inline">\((Ax_n,y)\to (z,y)\)</span>. 而<strong>另一方面</strong>又由条件有 <span class="math inline">\((Ax_n,y)=(x_n,By)\to (x,By)=(Ax,y)\)</span>. 于是由极限的唯一性即有 <span class="math inline">\(Ax=y\)</span>, 得证.</p></li><li><p>(瞎写的) 设 <span class="math inline">\(d=\inf\limits_{x\in E}\Vert x\Vert\)</span>, 由定义可取 <span class="math inline">\(x_n\in E\)</span>, s.t. <span class="math inline">\(d&lt;\Vert x_n\Vert&lt;d+\frac{1}{n}\)</span>. 由于自反空间中闭集是弱自列紧的, 取其收敛子列的弱极限即可.</p></li></ol><h2 id="泛函题目所以是-2018-下半年的泛函考试">2019.01泛函题目（所以是 2018 下半年的泛函考试）</h2><p>只有两个附加题, 不保证题目完全一致且没有解答.感谢李菁泽同学供题.</p><ol type="1"><li>设 <span class="math inline">\(\mathscr{X}\)</span> 是 <span class="math inline">\(B^*\)</span> 空间, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>, <span class="math inline">\(\varepsilon_n\)</span> 为一个极限为 <span class="math inline">\(0\)</span> 的序列, 且有 <span class="math display">\[f_n(x)\leqslant \varepsilon_n\Vert f_n\Vert_{\mathscr{X}^*}+C(x).\]</span> 其中 <span class="math inline">\(C(x)\)</span> 是一个函数（小李同学表示这个条件很懵B…）, 证明：<span class="math inline">\(\Vert f_n\Vert_{\mathscr{X}^*}\)</span> 一致有界.</li><li><span class="math inline">\(B^*\)</span> 空间 <span class="math inline">\(\mathscr{X}\)</span> 上有 <span class="math inline">\(n\)</span> 个半模 <span class="math inline">\(p_k(x)~k=1,\cdots,n\)</span>, 设线性泛函 <span class="math inline">\(\varphi(x)\)</span> 满足 <span class="math display">\[\vert \varphi(x)\vert\leqslant \sum\limits_{k=1}^n p_k(x),\]</span> 试证：存在线性泛函 <span class="math inline">\(\varphi_k(x),~(k=1,\cdots,n)\)</span>, s.t. <span class="math inline">\(\varphi(x)=\sum\limits_{k=1}^n\varphi_k(x)\)</span>, 且 <span class="math inline">\(\vert\varphi_k(x)\vert\leqslant p_k(x),~(k=1,\cdots,n)\)</span>.</li></ol><ul><li>感谢汪玲同学提供上述第 2 题的解答：</li></ul><center><img src="/img/blog-graph/Functional Analysis-2019.2.jpg" width="500" alt="2018年泛函附加题 2"></center><h2 id="泛函题目所以是-2019-下半年的泛函考试">2019.12.30 泛函题目（所以是 2019 下半年的泛函考试）</h2><p>依然是两个附加题, 不保证题目完全一致且没有解答. 感谢汪玲同学供题.</p><ol type="1"><li>设 <span class="math inline">\(E\)</span> 是线性空间, 映射 <span class="math inline">\(p: E\to\mathbb{R}\)</span> 满足：<ol type="1"><li><span class="math inline">\(p(x+y)\leqslant p(x)+p(y)\)</span>；</li><li>固定 <span class="math inline">\(x\in E\)</span>, 映射 <span class="math inline">\(\varphi: \mathbb{R}\to\mathbb{R},~\lambda\to p(\lambda x)\)</span> 连续；</li><li><span class="math inline">\(\forall \lambda\in\mathbb{R}\)</span>, 若 <span class="math inline">\(p(x_n)\to 0\)</span>, 则 <span class="math inline">\(p(\lambda x_n)\to 0\)</span>.</li></ol>求证：<ol type="1"><li><span class="math inline">\(p(0)=0\)</span>；</li><li><span class="math inline">\(\{\alpha_n\}\subset\mathbb{R}\)</span> 有极限且 <span class="math inline">\(p(x_n)\to 0\)</span>, 则 <span class="math inline">\(p(\alpha_n x_n)\to 0\)</span>.</li></ol></li><li>设 <span class="math inline">\(\mathscr{X},\mathscr{X}_1,\mathscr{X}_2\)</span> 是 <span class="math inline">\(B\)</span> 空间, <span class="math inline">\(T_i\)</span> 是 <span class="math inline">\(\mathscr{X}\to \mathscr{X}_i\)</span> 的闭算子, 且有：<span class="math display">\[D(T_1)\subseteq D(T_2)\]</span>求证 <span class="math inline">\(\exists C&gt;0\)</span>, s.t. <span class="math inline">\(||T_2x||_{\mathscr{X}_2}\leqslant c(||x||_{\mathscr{X}}+||T_1x||_{\mathscr{X}_1})\)</span>, <span class="math inline">\(\forall x\in D(T_1)\)</span>.</li></ol><ul><li>感谢汪玲同学提供上述第 2 题的解答:</li></ul><center><img src="/img/blog-graph/Functional Analysis-2019.12.jpg" alt="2019.12 第二题解答" width="500"></center>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 泛函分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>拓扑学复习重点</title>
      <link href="/2018/01/08/%E6%8B%93%E6%89%91%E5%AD%A6%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/"/>
      <content type="html"><![CDATA[<h2 id="点集拓扑">点集拓扑</h2><h3 id="拓扑空间">拓扑空间</h3><h4 id="拓扑空间-1">拓扑空间</h4><ul><li>拓扑: 包含全集和空集, 对任意并和有限交封闭的集类;</li><li>开集: 拓扑中包含的集合为开集.</li></ul><h4 id="几个拓扑的例子">几个拓扑的例子</h4><ol type="1"><li><p><strong>平凡拓扑</strong>: <span class="math inline">\(\{\varnothing, X\}\)</span>(最粗拓扑);</p></li><li><p><strong>离散拓扑</strong>: <span class="math inline">\(\{U: U\subset X\}\)</span>(最细拓扑);</p></li><li><p><strong>欧式拓扑</strong>: <span class="math inline">\(\{U: x\in U\Leftrightarrow B(x,\delta)\subset U\}\)</span>;</p></li><li><p><strong>余有限拓扑</strong>: <span class="math inline">\(\{U: U=\varnothing 或 U^c 是有限集\}\)</span>(类似有余可数拓扑).</p></li></ol><h3 id="邻域与开集">邻域与开集</h3><h4 id="邻域">邻域</h4><p>对于包含 <span class="math inline">\(x\)</span> 的集合 <span class="math inline">\(N\)</span>, 若存在开集 <span class="math inline">\(O\)</span>, s.t. <span class="math inline">\(x\in O\subset N\)</span>, 则称 <span class="math inline">\(N\)</span> 是 <span class="math inline">\(x\)</span> 的邻域.</p><blockquote><p><strong>命题</strong> 设 <span class="math inline">\(X\)</span> 是拓扑空间, 则 <span class="math inline">\(W\)</span> 是 <span class="math inline">\(X\)</span> 的开集当且仅当 <span class="math inline">\(W\)</span> 是其中每点的邻域.</p></blockquote><h4 id="闭集">闭集</h4><p>开集的补集称为闭集, 由此可以立刻得到:</p><ul><li>闭集对任意交和有限并封闭;</li><li>全集和空集是闭集;</li></ul><h4 id="导集">导集</h4><ul><li><strong>聚点</strong>: 若 <span class="math inline">\(p\)</span> 的任意邻域都包含 <span class="math inline">\(A-\{p\}\)</span> 中的至少一点, 则称 <span class="math inline">\(p\)</span> 为 <span class="math inline">\(A\)</span> 的聚点;</li><li><strong>导集</strong>: <span class="math inline">\(A\)</span> 的聚点全体称为 <span class="math inline">\(A\)</span> 的导集, 记作 <span class="math inline">\(A&#39;\)</span>;</li><li><strong>闭包</strong>: <span class="math inline">\(\overline{A}=A\cup A&#39;\)</span>.</li></ul><p>一个例子: <span class="math display">\[A=\{(x,\sin(\frac{\pi}{x}))~\vert~0&lt;x\leqslant 1\},\quad B=\{(0,y)~\vert~-1\leqslant y\leqslant 1\}\Rightarrow \]</span></p><p>关于闭集, 容易得到下列命题:</p><blockquote><p><strong>命题</strong> <span class="math inline">\(A\)</span> 闭 <span class="math inline">\(\iff\)</span> <span class="math inline">\(\overline{A}=A\)</span>.</p></blockquote><h4 id="拓扑基">拓扑基</h4><ul><li>拓扑基: 设 <span class="math inline">\(X\)</span> 是拓扑空间, <span class="math inline">\(\mathcal{B}\)</span> 是一组开集, s.t. <span class="math inline">\(X\)</span> 中的任意非空开集可以写成 <span class="math inline">\(\mathcal{B}\)</span> 中集合的并, 则称 <span class="math inline">\(\mathcal{B}\)</span> 为该拓扑的一组拓扑基;</li><li>拓扑基的定义等价于 <span class="math inline">\(\forall x\in X\)</span> 以及 <span class="math inline">\(x\)</span> 的开邻域 <span class="math inline">\(N\)</span>, <span class="math inline">\(\exists B\in\mathcal{B}\)</span>, s.t. <span class="math inline">\(x\in B\subset N\)</span>.</li></ul><p>关于拓扑基有如下定理:</p><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\mathcal{B}\)</span> 是集合 <span class="math inline">\(X\)</span> 的子集构成的子集类, s.t. 1. 设 <span class="math inline">\(U_1,U_2\in\mathcal{B}\)</span>, <span class="math inline">\(\forall x\in U_1\cap U_2\)</span>, <span class="math inline">\(\exists V\in \mathcal{B}\)</span>, s.t. <span class="math inline">\(x\in V\subset U_1\cap U_2;\)</span> 2. <span class="math inline">\(\mathcal{B}\)</span> 覆盖 <span class="math inline">\(X\)</span>. 则 <span class="math inline">\(\mathcal{B}\)</span> 是 <span class="math inline">\(X\)</span> 中某个拓扑的拓扑基.</p></blockquote><h4 id="子空间拓扑">子空间拓扑</h4><ul><li><strong>子空间拓扑</strong>: 子空间中的开集是全空间中开集与 <span class="math inline">\(A\)</span> 的交.</li><li>子空间中的闭集也是全空间中闭集与 <span class="math inline">\(A\)</span> 的交.</li><li>子空间中的开集也是全空间中的开集.</li></ul><h3 id="连续性">连续性</h3><h4 id="连续性-1">连续性</h4><ul><li><strong>连续性</strong>: 开集的原像是开集.</li></ul><h4 id="关于与连续性等价的几个命题">关于与连续性等价的几个命题</h4><ol type="1"><li>开集的原像是开集;</li><li>拓扑基中集合的原像是开集;</li><li>闭集的原像是闭集.</li></ol><h4 id="连续性的其他结论">连续性的其他结论</h4><ol type="1"><li>连续映射的复合映射连续;</li><li>连续映射在子空间的限制连续;</li></ol><h4 id="同胚">同胚</h4><ul><li><strong>同胚</strong>: 若连续映射 <span class="math inline">\(f: X\to Y\)</span> 是 <span class="math inline">\(1-1\)</span> 映射且 <span class="math inline">\(f^{-1}\)</span> 连续, 则称其为同胚.</li></ul><p>关于同胚有以下等价命题:</p><ol type="1"><li><span class="math inline">\(f\)</span> 是同胚;</li><li><span class="math inline">\(f\)</span> 是连续的一一映射并且是开映射;</li><li><span class="math inline">\(f\)</span> 是连续的一一映射并且是闭映射.</li></ol><h3 id="分离性">分离性</h3><h4 id="分离性-1">分离性</h4><ul><li><span class="math inline">\(T_0\)</span>: 任意一点与另一点分离;</li><li><span class="math inline">\(T_1\)</span>: 任意两点互相分离 <span class="math inline">\(\Leftrightarrow\)</span> 单点集是闭集;</li><li><span class="math inline">\(T_2\)</span>: 任意两点存在各自的开邻域不相交(Hausdorff);</li><li><span class="math inline">\(T_3\)</span>: 任意闭集与其外一点存在开邻域不相交;</li><li><span class="math inline">\(T_4\)</span>: 任意两个不相交闭集存在各自开邻域不相交.</li></ul><p>一些分离性的例子如下:</p><ol type="1"><li><p><span class="math inline">\(X=\{0,1\}\)</span>, <span class="math inline">\(\mathcal{T}=\{X,\varnothing,\{0\}\}\)</span>: 是 <span class="math inline">\(T_0\)</span> 但不是 <span class="math inline">\(T_1\)</span>;</p></li><li><p><span class="math inline">\(\mathbb{R}^1\)</span> 上的余有限拓扑是 <span class="math inline">\(T_1\)</span> 但不是 <span class="math inline">\(T_2\)</span>.</p></li></ol><p>对于Hausdorff空间还有如下命题:</p><blockquote><p><strong>命题</strong> Hausdorff空间 <span class="math inline">\(X\)</span> 是 <span class="math inline">\(T_3\)</span> 的当且仅当对于 <span class="math inline">\(\forall x\)</span> 以及 <span class="math inline">\(U_x\)</span>, <span class="math inline">\(\exists V_x\)</span>, s.t. <span class="math display">\[x\in V\subset\overline{V}\subset U.\]</span></p></blockquote><h4 id="tietze-扩张定理">Tietze 扩张定理</h4><blockquote><p><strong>Urysohn引理</strong> 设 <span class="math inline">\(X\)</span> 是Hausdorff空间, 则 <span class="math inline">\(X\)</span> 是 <span class="math inline">\(T_4\)</span> 的当且仅当对于 <span class="math inline">\(X\)</span> 内任意不相交的闭集 <span class="math inline">\(A,B\)</span>, 存在 <span class="math inline">\(X\)</span> 上的连续实函数 <span class="math inline">\(f\)</span>, s.t. <span class="math display">\[f\vert_A=1,~f\vert_B=-1,~-1 &lt; f\vert_{X-(A\cup B)} &lt; 1.\]</span></p></blockquote><p>进一步有 Tietze 扩张定理:</p><blockquote><p><strong>Tietze扩张定理</strong> 设 <span class="math inline">\(X\)</span> 是Hausdorff空间, 则 <span class="math inline">\(X\)</span> 是 <span class="math inline">\(T_4\)</span> 的当且仅当对于 <span class="math inline">\(X\)</span> 内任意闭子集 <span class="math inline">\(A\)</span> 及任意连续函数 <span class="math inline">\(f: A\to \mathbb{E}^1\)</span>, 存在连续函数 <span class="math inline">\(g: X\to \mathbb{E}^1\)</span>, s.t. <span class="math inline">\(g\vert_A=f\)</span>. 进一步, 若在 <span class="math inline">\(A\)</span> 上有 <span class="math inline">\(\vert f\vert\leqslant M\)</span>, 则可做到 <span class="math inline">\(\vert g\vert\leqslant M\)</span>.</p></blockquote><h3 id="紧致性">紧致性</h3><h4 id="紧致性-1">紧致性</h4><ul><li><strong>紧致性</strong>: 任意开覆盖含有限子覆盖.</li></ul><blockquote><p><strong>Heine-Borel定理</strong> <span class="math inline">\(\mathbb{E}^1\)</span> 上的闭区间是紧集.</p></blockquote><ul><li>紧致空间的闭子集是紧的.</li><li>Hausdorff空间中的紧集是闭集.</li><li>紧空间到Hausdorff空间的既单又满的连续映射是同胚.</li></ul><blockquote><p><strong>Bolzano-Weierstrass定理</strong> 紧空间的无穷点集必有聚点.</p></blockquote><h4 id="局部紧致">局部紧致</h4><ul><li>局部紧致: <span class="math inline">\(\forall x\in X\)</span>, 存在 <span class="math inline">\(x\)</span> 的紧致邻域.</li><li>紧致 <span class="math inline">\(\Rightarrow\)</span> 局部紧.</li></ul><h3 id="乘积空间">乘积空间</h3><h4 id="乘积拓扑">乘积拓扑</h4><ul><li>开集 <span class="math inline">\(\times\)</span> 开集 构成一组拓扑基 <span class="math inline">\(\mathcal{B}\)</span>;</li><li>乘积拓扑: <span class="math inline">\(\mathcal{B}\)</span> 决定的拓扑称为乘积拓扑.</li></ul><h4 id="自然投影">自然投影</h4><p>称映射 <span class="math display">\[p_1: X\times Y\to X,~(x,y)\to x;\]</span> <span class="math display">\[p_2: X\times Y\to X,~(x,y)\to y;\]</span> 为自然投影.</p><ul><li><span class="math inline">\(X\times Y\)</span> 的乘积拓扑是使得自然投影都连续的最粗拓扑;</li><li><span class="math inline">\(f:Z\to X\times Y\)</span> 连续 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(p_1\circ f\)</span> 和 <span class="math inline">\(p_2\circ f\)</span> 都连续;</li><li><span class="math inline">\(X\times Y\)</span> 是Hausdorff空间当且仅当 <span class="math inline">\(X\)</span>, <span class="math inline">\(Y\)</span> 都是Hausdorff空间;</li><li><span class="math inline">\(X\times Y\)</span> 紧致当且仅当<span class="math inline">\(X\)</span>, <span class="math inline">\(Y\)</span> 都紧致.</li></ul><h3 id="连通性">连通性</h3><h4 id="连通性-1">连通性</h4><p>以下命题等价:</p><ol type="1"><li><span class="math inline">\(X\)</span> 连通;</li><li><span class="math inline">\(X\)</span> 内既开又闭的子集只有 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(\varnothing\)</span>;</li><li><span class="math inline">\(X\)</span> 不能表示为两个不相交的非空开集的并;</li><li>不存在从 <span class="math inline">\(X\)</span> 到多于一点的离散拓扑空间的连续满射.</li></ol><blockquote><p><strong>命题</strong> <span class="math inline">\(\mathbb{E}^1\)</span> 的非空子集连通当且仅当它是一个区间.</p></blockquote><p>关于连通还有如下命题:</p><ul><li>连通空间的连续像连通;</li><li><span class="math inline">\(X\times Y\)</span> 连通当且仅当 <span class="math inline">\(X\)</span>, <span class="math inline">\(Y\)</span> 都连通;</li></ul><h4 id="连通分支">连通分支</h4><ul><li><strong>连通分支</strong>: 极大连通子集.</li></ul><p>有如下例子:</p><ul><li>离散拓扑空间的每一个点是一个连通分支;</li><li>有理数作为欧氏空间的子空间, 每个点是一个连通分支.</li></ul><blockquote><p><strong>中间值定理</strong> 设 <span class="math inline">\(f: X\to\mathbb{E}^1\)</span> 是一个连续函数, 若 <span class="math inline">\(f\)</span> 可以取到 <span class="math inline">\(a,b\)</span>, 则 <span class="math inline">\(f\)</span> 可以取到 <span class="math inline">\(a,b\)</span> 中间的任何值.</p></blockquote><h4 id="局部连通">局部连通</h4><ul><li>局部连通: 任意 <span class="math inline">\(x\)</span>, 任意 <span class="math inline">\(x\)</span> 的邻域 <span class="math inline">\(U\)</span>, 存在连通邻域 <span class="math inline">\(V\)</span>, s.t. <span class="math inline">\(x\in V\subset U\)</span>.</li><li>连通未必局部连通. (例子: <span class="math inline">\((x,\sin(\frac{\pi}{x}))\)</span>)</li></ul><h3 id="道路连通性">道路连通性</h3><h4 id="道路">道路</h4><ul><li><strong>道路</strong>: 连续映射 <span class="math inline">\(\alpha: I\to X\)</span>: 起点为 <span class="math inline">\(\alpha(0)\)</span>, 终点为 <span class="math inline">\(\alpha(1)\)</span>.</li><li><strong>逆道路</strong>: <span class="math inline">\(\overline{\alpha}(t)=\alpha(1-t)\)</span>.</li><li><strong>道路的乘积</strong>: 设 <span class="math inline">\(\alpha: x\to y\)</span>, <span class="math inline">\(\beta: y\to z\)</span>, 定义 <span class="math display">\[\gamma(t)=\begin{cases} \alpha(2t), &amp; 0\leqslant t\leqslant\frac{1}{2}, \\\\ s\beta(2t-1), &amp; \frac{1}{2}\leqslant t\leqslant 1, \end{cases}\]</span> 则 <span class="math inline">\(\gamma\)</span> 为 <span class="math inline">\(\alpha\)</span> 与 <span class="math inline">\(\beta\)</span> 的乘积道路.</li><li><strong>道路的连续像是道路</strong>: <span class="math inline">\(f: X\to Y\)</span> 连续, 则 <span class="math inline">\(f\circ \alpha\)</span> 是 <span class="math inline">\(Y\)</span> 中的道路.</li></ul><h4 id="道路连通">道路连通</h4><ul><li><strong>道路连通空间</strong>: 任意两点都有道路连接的空间;</li><li><strong>道路连通空间必定是连通的</strong> (反证法: 若不然, 则与 <span class="math inline">\(I\)</span> 的连通性矛盾);</li><li><strong>连通空间未必道路连通</strong>: <span class="math inline">\(\sin(x,\sin(\frac{\pi}{x}))\)</span> (证明 <span class="math inline">\((0,0)\)</span> 与 <span class="math inline">\((1,0)\)</span> 之间无道路);</li><li><strong>道路连通分支</strong>: 极大道路连通子集.</li></ul><h4 id="局部道路连通">局部道路连通</h4><ul><li>局部道路连通: 任意 <span class="math inline">\(x\)</span>, 任意 <span class="math inline">\(x\)</span> 的邻域 <span class="math inline">\(U\)</span>, 存在道路连通邻域 <span class="math inline">\(V\)</span>, s.t. <span class="math inline">\(x\in V\subset U\)</span>;</li><li>道路连通未必局部道路连通. (例子: <span class="math inline">\((\frac{1}{n},t)\cup (0,t)\cup (t,0)~t\in I\)</span>)</li><li>连通+局部道路连通 <span class="math inline">\(\Rightarrow\)</span> 道路连通.</li></ul><h3 id="商空间">商空间</h3><h4 id="商空间-1">商空间</h4><ul><li><strong>商空间</strong>: 设 <span class="math inline">\(X\)</span> 上有等价关系, 则可定义商空间 <span class="math inline">\(Y=X/\sim\)</span> (把一个等价类捏成一点);</li><li><strong>投影映射</strong>: <span class="math inline">\(\pi: X\to Y\)</span>, <span class="math inline">\(x\mapsto [x]\)</span>;</li><li><strong>商拓扑</strong>: 在商空间 <span class="math inline">\(Y\)</span> 定义拓扑: <span class="math display">\[U\subset Y 是开集 \Leftrightarrow \pi^{-1}(U) 是 X 中的开集\]</span> 则称该拓扑为 <span class="math inline">\(Y\)</span> 上的商拓扑;</li></ul><p>关于商空间, 一个重要的性质如下:</p><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(X\)</span> 是拓扑空间, <span class="math inline">\(Y\)</span> 是 <span class="math inline">\(X\)</span> 的商空间, <span class="math inline">\(Z\)</span> 是任意空间, 则: <span class="math display">\[f: Y\to Z ~连续~\Leftrightarrow~f\circ\pi: X\to Z~连续.\]</span></p></blockquote><h4 id="商空间的例子">商空间的例子</h4><p><span class="math inline">\(I^2\)</span> 上商空间的几个例子如下:</p><ol type="1"><li>平环 <span class="math inline">\(S^1\times I\)</span>: <span class="math inline">\((0,y)\sim(1,y)\)</span>;</li><li>Mobius带: <span class="math inline">\((0,y)\sim(1,1-y)\)</span>.</li><li>球面 <span class="math inline">\(\mathbb{S}^2\)</span>: <span class="math inline">\((0,y)\sim(1,y)\sim(x,0)\sim(x,1)~\forall x,y\)</span>.</li></ol><p>粘合两组对边可得环面 <span class="math inline">\(T^2\)</span> 和Klein瓶:</p><ol type="1"><li>环面 <span class="math inline">\(T^2\)</span>: <span class="math inline">\((x,0)\sim (x,1)\)</span>, <span class="math inline">\((0,y)\sim (1,y)\)</span>; (<span class="math inline">\(T^2\cong \mathbb{S}^1\times\mathbb{S}^1\)</span>)</li><li>Klein瓶: <span class="math inline">\((x,0)\sim (x,1)\)</span>, <span class="math inline">\((0,y)\sim (1,1-y)\)</span>.</li></ol><p>在 <span class="math inline">\(S^n\)</span> 上, 重要的商空间是实投影空间:</p><ol type="1"><li>实投影空间 <span class="math inline">\(\mathbb{P}^n\)</span>: <span class="math inline">\(x\sim -x\)</span>, <span class="math inline">\(\forall x\in\mathbb{S}^n\)</span>.</li></ol><h4 id="商映射">商映射</h4><p><strong>商映射</strong>: <span class="math inline">\(f\)</span> 是连续满射, 且 <span class="math inline">\(U\subset Y\)</span> 是开集 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(f^{-1}(U)\subset X\)</span> 是开集, 则称 <span class="math inline">\(f\)</span> 是商映射.</p><p>有如下命题:</p><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(f: X\to Y\)</span> 是商映射, 则 1. 映射 <span class="math inline">\(g: Y\to Z\)</span> 连续 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(g\circ f: X\to Z\)</span> 连续; 2. <span class="math inline">\(Y\cong X/\sim\)</span>.</p></blockquote><p>关于商映射的判断, 有如下两条常见的定理:</p><ol type="1"><li><strong>连续满射若同时是开映射或闭映射, 则是商映射</strong>;</li><li><strong>紧空间到Hausdorff空间的连续满射是商映射</strong>.</li></ol><h4 id="拓扑锥与双角锥">拓扑锥与双角锥</h4><ul><li>拓扑锥: <span class="math inline">\(X\times I\)</span> 上定义 <span class="math display">\[(x,1)\sim (x&#39;,1),~\forall x,x&#39;\in X;\]</span> <span class="math display">\[(x,t)\sim(x,t), ~\forall x,\forall t&lt;1.\]</span> 而成的商空间称为 <span class="math inline">\(X\)</span> 的拓扑锥, 记作 <span class="math inline">\(CX\)</span>.</li></ul><p>容易知道 <span class="math inline">\(C\mathbb{S}^{n-1}\cong B^n\)</span>.</p><ul><li>双角锥: <span class="math inline">\(X\times[-1,1]\)</span> 上定义 <span class="math display">\[(x,1)\sim(x&#39;,1),~\forall x,x&#39;\]</span> <span class="math display">\[(x,-1)\sim(x&#39;,-1),~\forall x,x&#39;\]</span> <span class="math display">\[(x,t)\sim (x,t), \text{otherwise}.\]</span></li></ul><p>容易知道 <span class="math inline">\(S\mathbb{S}^{n-1}\cong \mathbb{S}^n\)</span>.</p><h3 id="拓扑群与轨道空间">拓扑群与轨道空间</h3><h4 id="拓扑群">拓扑群</h4><ul><li><strong>拓扑群</strong>: 设 <span class="math inline">\(G\)</span> 是一个Hausdorff空间, 同时也是一个群. 若 <span class="math inline">\(G\)</span> 的乘法和求逆都连续, 则称 <span class="math inline">\(G\)</span> 为拓扑群.</li><li><strong>子群</strong>: 子空间+子群.</li><li><strong>同态</strong>: 连续+同态. (同构=同胚+同构).</li></ul><p>拓扑群的例子:</p><ol type="1"><li>四元数空间 <span class="math inline">\(\mathbb{H}=\mathbb{C}^2\)</span>;</li><li>一般线性群 <span class="math inline">\(GL(n,\mathbb{R})\subset \mathbb{E}^{n^2}\)</span>.</li><li>正交群 <span class="math inline">\(O(n)\)</span>, <span class="math inline">\(SO(n)\)</span> 和 酉群 <span class="math inline">\(U(n)\)</span>, <span class="math inline">\(SU(n)\)</span>.</li></ol><h4 id="拓扑群作用">拓扑群作用</h4><ul><li>拓扑群作用: 连续映射 <span class="math inline">\(\phi: G\times X\to X\)</span>, s.t.</li></ul><ol type="1"><li><span class="math inline">\(\phi(hg,x)=\phi(h,\phi(g,x))\)</span>, <span class="math inline">\(\forall g,h,x\)</span>;</li><li><span class="math inline">\(\phi(e,x)=x\)</span>, <span class="math inline">\(\forall x\)</span></li></ol><p>可以简写为:</p><ol type="1"><li><span class="math inline">\((hg)x=h(gx)\)</span>;</li><li><span class="math inline">\(ex=x\)</span>.</li></ol><h4 id="轨道空间">轨道空间</h4><ul><li><strong>轨道</strong>: <span class="math inline">\(O(x)=\{gx~\vert~g\in G\}\)</span>, 显然轨道相交等价于轨道重合;</li><li><strong>轨道空间</strong>: <span class="math inline">\(x\sim y: O(x)=O(y)\)</span>. 记作 <span class="math inline">\(X/G\)</span>.</li><li><strong>可迁作用</strong>: <span class="math inline">\(\forall x,y\in X\)</span>, <span class="math inline">\(\exists g\in G\)</span>, s.t. <span class="math inline">\(gx=y\)</span>;</li><li><strong>自由作用</strong>: <span class="math inline">\(\forall g\neq h\in G\)</span>, <span class="math inline">\(\forall x\in X\)</span>, <span class="math inline">\(gx\neq hx\)</span>.</li><li><strong>迷向群</strong>: <span class="math inline">\(G_x=\{g\in G~\vert~gx=x\}\subset G\)</span>.</li></ul><blockquote><p><span class="math inline">\(G\)</span> 是自由作用当且仅当每点的迷向群是平凡群.</p></blockquote><p>关于轨道空间的连通性有如下命题:</p><blockquote><p><strong>命题</strong> 设 <span class="math inline">\(G\)</span> 是拓扑群, 作用于 <span class="math inline">\(X\)</span> 上. 若 <span class="math inline">\(G\)</span> 与 <span class="math inline">\(G/X\)</span> 连通, 则 <span class="math inline">\(X\)</span> 连通. 反证法: 取开集 <span class="math inline">\(X=A\cup B\)</span>, 则 <span class="math inline">\(U=\pi(A)\cap\pi(B)\)</span> 非空, 取 <span class="math inline">\([p]\in U\)</span>, 考虑 <span class="math inline">\(O_p\)</span> 的连通性即可得结论.</p></blockquote><h2 id="代数拓扑">代数拓扑</h2><h3 id="映射与空间的同伦">映射与空间的同伦</h3><h4 id="映射的同伦">映射的同伦</h4><ul><li><strong>映射同伦</strong>: 设 <span class="math inline">\(X,Y\)</span> 是拓扑空间, <span class="math inline">\(f,g:X\to Y\)</span> 是连续映射, 则 <span class="math inline">\(f\)</span> 到 <span class="math inline">\(g\)</span> 的同伦是指连续映射 <span class="math display">\[F: X\times I\to Y,~\text{s.t.}~F(x,0)=f(x),~F(x,1)=g(x).\]</span> 此时称 <span class="math inline">\(f\)</span> 与 <span class="math inline">\(g\)</span> 同伦, 记作 <span class="math inline">\(f\underset{F}{\simeq} g\)</span>.</li><li><strong>相对子集的同伦</strong>: 若对于 <span class="math inline">\(A\subset X\)</span> 有 <span class="math display">\[F(a,t)=f(a),~\forall a\in A,t\in I,\]</span> 则称 <span class="math inline">\(f\)</span> 与 <span class="math inline">\(g\)</span> 相对于 <span class="math inline">\(A\)</span> 同伦, 记作 <span class="math inline">\(f\underset{F}{\simeq} g, rel A\)</span>.</li><li><strong>线性同伦</strong>: <span class="math inline">\(C\)</span> 是 <span class="math inline">\(\mathbb{E}^n\)</span> 中的凸集, 映射 <span class="math inline">\(f,g: X\to C\)</span> 连续, 取 <span class="math display">\[F(x,t)=(1-t)f(x)+tg(x),\]</span> 则 <span class="math inline">\(f\underset{F}{\simeq} g\)</span>.</li><li><strong>零伦</strong>: 同伦于常值映射的映射称为是零伦的. <strong><span class="math inline">\(X\)</span> 到 <span class="math inline">\(\mathbb{E}^n\)</span> 中凸集的连续映射是零伦的.</strong></li><li><strong>环路</strong>: <span class="math inline">\(\alpha: I\to X\)</span> 是一条道路, 且 <span class="math inline">\(\alpha(0)=\alpha(1)=p\)</span>, 则称 <span class="math inline">\(\alpha\)</span> 是以 <span class="math inline">\(p\)</span> 为基点的环路.</li><li><strong>保基点同伦</strong>: <span class="math inline">\(\alpha\simeq \beta,~rel\{0,1\}\)</span>.</li></ul><h4 id="空间的同伦等价">空间的同伦等价</h4><ul><li><strong>同伦等价</strong>: 存在连续映射 <span class="math display">\[f: X\to Y,\quad g:Y\to X,\]</span> s.t. <span class="math display">\[g\circ f\simeq id_X: X\to X,\quad f\circ g\simeq Y\to Y.\]</span> 则称 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 同伦等价, 记作 <span class="math inline">\(X\simeq Y\)</span>.</li></ul><p>几个例子如下:</p><ol type="1"><li><span class="math inline">\(\mathbb{E}^n-\{0\}\simeq\mathbb{S}^{n-1}\)</span>, <span class="math inline">\(f(x)=\frac{x}{\Vert x\Vert}\)</span>, <span class="math inline">\(g(x)=x\)</span>;</li><li><span class="math inline">\(CX\simeq \{p(锥顶)\}\)</span>, <span class="math inline">\(f(x)=p\)</span>, <span class="math inline">\(g(p)\)</span> 为包含映射.</li></ol><h4 id="收缩">收缩</h4><ul><li><strong>可缩空间</strong>: 与单点同伦等价的空间;</li><li><strong>收缩核</strong>: <span class="math inline">\(A\subset X\)</span>, 若存在连续映射 <span class="math inline">\(r: X\to A\)</span>, s.t. <span class="math inline">\(r\vert_A=id_A\)</span>, 则称 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(X\)</span> 的收缩核;</li><li><strong>形变收缩</strong>: <span class="math inline">\(A\subset X\)</span>, <span class="math inline">\(i: A\to X\)</span> 是包含映射, <span class="math inline">\(r\)</span> 是 <span class="math inline">\(X\)</span> 到 <span class="math inline">\(A\)</span> 的收缩. 若 <span class="math inline">\(id_X\underset{F}{\simeq} i\circ r\)</span>, 则称 <span class="math inline">\(F\)</span> 是 <span class="math inline">\(X\)</span> 到 <span class="math inline">\(A\)</span> 的形变收缩, <span class="math inline">\(A\)</span> 是 <span class="math inline">\(X\)</span> 的形变收缩核;</li><li><strong>强形变收缩</strong>: 若 <span class="math inline">\(id_X\underset{F}{\simeq} i\circ r,~rel A\)</span> 则称 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(X\)</span> 的强形变收缩核.</li></ul><blockquote><p><strong>命题</strong> <span class="math inline">\(X\)</span> 可缩 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(X\)</span> 可形变收缩到其中一点.</p></blockquote><p>几个例子: 1. <span class="math inline">\(\mathbb{S}^1\)</span> 是平环和Mobius带的强形变收缩核; 2. <span class="math inline">\(\mathbb{S}^{n-1}\)</span> 是 <span class="math inline">\(\mathbb{E}^n-\{0\}\)</span> 的强形变收缩核.</p><h3 id="基本群">基本群</h3><h4 id="基本群-1">基本群</h4><ul><li><strong>基本群</strong>: 拓扑空间上以 <span class="math inline">\(p\)</span> 点为基点的环路的保基点同伦类关于同伦类的乘积构成一个群, 称为基本群 <span class="math inline">\(\pi_1(X,p)\)</span>. &gt; <strong>道路连通空间的基本群</strong> 若 <span class="math inline">\(X\)</span> 道路连通, 则 <span class="math inline">\(\pi_1(X,p)\cong \pi_1(X,q)\)</span>, <span class="math inline">\(\forall p,q\)</span>.</li></ul><h4 id="基本群的不变性">基本群的不变性</h4><p>设 <span class="math inline">\(f: X\to Y\)</span> 连续, 且 <span class="math inline">\(f(p)=q\)</span>, 则 <span class="math inline">\(f\)</span> 可以诱导映射 <span class="math display">\[g: \pi_1(X,p)\to \pi_1(Y,q),~\langle\alpha\rangle\mapsto \langle f\circ\alpha\rangle.\]</span> 且由 <span class="math display">\[g\circ(\alpha\cdot\beta)=(f\circ\alpha)\cdot(f\circ\beta)\]</span> 可知 <span class="math inline">\(g\)</span> 是同态.</p><h4 id="乘积空间的基本群">乘积空间的基本群</h4><blockquote><p><strong>命题</strong> 若 <span class="math inline">\(X,Y\)</span> 道路连通, 则 <span class="math display">\[\pi_1(X\times Y,(x_0,y_0))\cong \pi_1(X,x_0)\times \pi_1(Y,y_0).\]</span></p></blockquote><h3 id="mathbbsn-的基本群"><span class="math inline">\(\mathbb{S}^n\)</span> 的基本群</h3><h4 id="道路提升定理">道路提升定理</h4><blockquote><p><strong>道路提升</strong> <span class="math inline">\(\alpha\)</span> 是 <span class="math inline">\(\mathbb{S}^1\)</span> 内以 <span class="math inline">\(1\)</span> 为起点的道路, 则存在 <span class="math inline">\(\mathbb{E}^1\)</span> 中唯一一条以 <span class="math inline">\(0\)</span> 为起点的道路<span class="math inline">\(\tilde{\alpha}\)</span>, s.t. <span class="math inline">\(\pi\circ\tilde{\alpha}=\alpha\)</span>.</p></blockquote><h4 id="同伦提升定理">同伦提升定理</h4><blockquote><p><strong>同伦提升</strong> <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(\beta\)</span> 是 <span class="math inline">\(\mathbb{S}^1\)</span> 中的两条道路, 且 <span class="math inline">\(\exists F:I\times I\to \mathbb{S}^1\)</span>, s.t. <span class="math inline">\(\alpha\underset{F}{\simeq}\beta\)</span>, 若 <span class="math inline">\(\alpha\)</span> 有提升, 则 <span class="math inline">\(F\)</span> 有唯一提升 <span class="math inline">\(\tilde{F}: I\times I\to\mathbb{E}^1\)</span>, s.t. <span class="math inline">\(\tilde{F}(0,0)=0\)</span>.</p></blockquote><h4 id="mathbbsn-的基本群-1"><span class="math inline">\(\mathbb{S}^n\)</span> 的基本群</h4><ol type="1"><li><span class="math inline">\(\mathbb{S}^1\)</span> 的基本群为 <span class="math inline">\(\mathbb{Z}\)</span>;</li><li><span class="math inline">\(\mathbb{S}^n~(n&gt;2)\)</span> 的基本群为平凡群.</li></ol><h4 id="基本群的应用">基本群的应用</h4><ol type="1"><li><strong>代数学基本定理</strong>: <span class="math inline">\(\mathbb{C}\)</span> 上的 <span class="math inline">\(n\)</span> 次多项式存在零点;</li><li><strong>Brouwer 不动点定理</strong>: <span class="math inline">\(\mathbb{B}^n\)</span> 具有不动点性质(任意到自身的连续映射有不动点).</li></ol><h4 id="van-kampen-定理">Van Kampen 定理</h4><blockquote><p><strong>van kampen</strong> 设 <span class="math inline">\(X\)</span> 可以写成非空开集 <span class="math inline">\(X_1\)</span>, <span class="math inline">\(X_2\)</span> 的并集且 <span class="math inline">\(X_0=X_1\cap X_2\neq\varnothing\)</span>. 设 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(X_0\)</span> 道路连通, 取 <span class="math inline">\(x_0\in X_0\)</span>, 则 <span class="math display">\[\pi_1(X,x_0)\cong\pi_1(X_1,x_0)*\pi_1(X_2,x_0)/\sim,\]</span> 其中 <span class="math inline">\(\sim\)</span> 是等价关系 <span class="math display">\[\{i_{1*}(\alpha)=i_{2*}(\alpha)~\vert~\alpha\in\pi_1(X_0,x_0)\}~(i_k~是~X_0\to X_k~的包含映射).\]</span></p></blockquote><p>两个特殊情形如下:</p><blockquote><p><strong>推论 1</strong> 若 <span class="math inline">\(X_0\)</span> 单连通, 则 <span class="math display">\[\pi_1(X,x_0)\cong\pi_1(X_1,x_0)*\pi_1(X_2,x_0).\]</span> <strong>推论 2</strong> 若 <span class="math inline">\(X_2\)</span> 单连通, 则 <span class="math display">\[\pi_1(X,x_0)\cong\pi_1(X_1,x_0)/\sim,\]</span> 其中 <span class="math inline">\(\sim\)</span> 为等价关系 <span class="math inline">\(\{i_{1*}(\alpha)=e~\vert~\alpha\in\pi_1(X_0,x_0)\}\)</span>.</p></blockquote><h4 id="闭曲面分类定理">闭曲面分类定理</h4><ul><li><strong>曲面</strong>: 第二可数的Hausdorff空间 <span class="math inline">\(S\)</span> 称为曲面当且仅当 <span class="math inline">\(\forall x\in S\)</span>, 存在 <span class="math inline">\(x\)</span> 的邻域 <span class="math inline">\(U\)</span>, s.t. <span class="math inline">\(U\)</span> 同胚于圆盘 <span class="math inline">\(D^2\)</span> 或 半圆盘<span class="math inline">\(D^2_+\)</span>;</li><li><strong>内部</strong>: 存在邻域同胚于圆盘的点称为内点, 内点的全体称为内部;</li><li><strong>边界</strong>: 存在邻域同胚于半圆盘的点称为边界点, 边界点的全体称为边界.</li><li><strong>闭曲面</strong>: 紧致无边界的曲面称为闭曲面.</li></ul><p>关于曲面还有如下结论:</p><ol type="1"><li>曲面间的同胚把内点映射到内点, 边界点映射到边界点;</li><li>同胚的曲面具有同胚的边界. (由上一条可得到)</li></ol><p>如下定义曲面的可定向性:</p><ul><li><strong>不可定向曲面</strong>: 存在一个同胚于Mobius带的子空间. (否则称为可定向的)</li></ul><blockquote><p><strong>闭曲面分类定理</strong> <span class="math inline">\(\mathbb{S}^2\)</span>, <span class="math inline">\(nT^2~(n\in\mathbb{N})\)</span>, <span class="math inline">\(m\mathbb{P}^2~(m\in \mathbb{N})\)</span> 是两两不同胚的闭曲面, 且所有的闭曲面都可以归为这三类. 进一步, 1. 可定向曲面必定同胚于 <span class="math inline">\(\mathbb{S}^2\)</span> 或 <span class="math inline">\(nT^2~(n\in\mathbb{N})\)</span>; 2. 不可定向曲面必定同胚于 <span class="math inline">\(m\mathbb{P}^2~(m\in \mathbb{N})\)</span>.</p></blockquote><h3 id="复叠空间">复叠空间</h3><h4 id="复叠空间-1">复叠空间</h4><ul><li><strong>复叠映射</strong>: 设 <span class="math inline">\(E,B\)</span> 是道路连通且局部道路连通的空间, <span class="math inline">\(p: E\to B\)</span> 是连续映射. 若对 <span class="math inline">\(\forall b\in B\)</span>, 存在 <span class="math inline">\(b\)</span> 的开邻域 <span class="math inline">\(U\)</span>, s.t. <span class="math inline">\(p^{-1}(U)\)</span> 是 <span class="math inline">\(E\)</span> 中一族两两不交的开集 <span class="math inline">\(\{V_\alpha\}\)</span> 的并集, 且 <span class="math inline">\(p\vert_{V_\alpha}: V_\alpha\to U\)</span> 是同胚, 则称 <span class="math inline">\(p\)</span> 是复叠映射.</li><li><strong>复叠空间</strong>: <span class="math inline">\((E,p)\)</span> 称为 <span class="math inline">\(B\)</span> 上的复叠空间.</li><li><strong>基本邻域</strong>: 上述定义中的 <span class="math inline">\(U\)</span> 称为基本邻域. <span class="math inline">\(U\)</span> 的逆像可以拆成若干与 <span class="math inline">\(U\)</span> 同胚的集合的不交并.</li><li><strong>纤维</strong>: <span class="math inline">\(b\in B\)</span>, 称 <span class="math inline">\(p^{-1}(b)\)</span> 为 <span class="math inline">\(b\)</span> 的纤维. 其基数称为复叠空间的重数/叶数.</li></ul><p>简单来说, 复叠映射就是把一族同胚的不交开集映射到同一开集的映射, 原空间就称为复叠空间. 如果该映射是 <span class="math inline">\(n\)</span> 对 <span class="math inline">\(1\)</span> 的, 则该空间是 <span class="math inline">\(n\)</span> 重的.</p><h4 id="复叠空间上的道路提升与同伦提升">复叠空间上的道路提升与同伦提升</h4><blockquote><p><strong>道路提升</strong> 若 <span class="math inline">\(\alpha\)</span> 是以 <span class="math inline">\(b_0\in B\)</span> 为起点的一条道路, <span class="math inline">\(e_0\in p^{-1}(b_0)\)</span>, 则存在 <span class="math inline">\(E\)</span> 内唯一一条以 <span class="math inline">\(e_0\)</span> 为起点的道路 <span class="math inline">\(\tilde{\alpha}\)</span>, s.t. <span class="math display">\[\alpha=p\circ\tilde{\alpha}.\]</span> <font color="red"> <strong>这说明 <span class="math inline">\(B\)</span> 中以 <span class="math inline">\(b_0\)</span> 为起点的道路与 <span class="math inline">\(E\)</span> 中以 <span class="math inline">\(e_0\)</span> 为起点的道路一一对应.</strong></font> <strong>同伦提升</strong> 若 <span class="math inline">\(\alpha_1,\alpha_2\)</span> 是 <span class="math inline">\(B\)</span> 内两条道路, 且 <span class="math display">\[\alpha_1\underset{F}{\simeq}\alpha_2.\]</span> 设 <span class="math inline">\(\tilde{\alpha}_1\)</span> 是 <span class="math inline">\(\alpha_1\)</span> 的提升, 且 <span class="math inline">\(\tilde{\alpha}_1(0)=e_0\in E\)</span>, 则 <span class="math inline">\(F\)</span> 有唯一提升 <span class="math display">\[\tilde{F}: I\times I\to E,~\text{s.t.}~\tilde{F}(0,0)=e_0.\]</span> <strong>推论</strong> 若 <span class="math inline">\(\alpha_1,\alpha_2\)</span> 是 <span class="math inline">\(B\)</span> 内两条道路, 且 <span class="math display">\[\alpha_1\simeq\alpha_2,~rel\{0,1\}.\]</span> 设 <span class="math inline">\(\tilde{\alpha}_i\)</span> 是 <span class="math inline">\(\alpha_i\)</span> 的提升, 且 <span class="math inline">\(\tilde{\alpha_1}(0)=\tilde{\alpha_2}(0)\)</span>, 则 <span class="math display">\[\alpha_1\simeq\alpha_2,~rel\{0,1\}.\]</span> <font color="red"><strong>这说明道路提升中产生的一一对应能够保持保端点同伦.</strong></font></p></blockquote><h4 id="复叠空间的基本群">复叠空间的基本群</h4><ul><li>复叠映射 <span class="math inline">\(p\)</span> 可诱导单同态 <span class="math inline">\(p_*: \pi_1(E,e_0)\to\pi_1(B,b_0)\)</span>, 且 <span class="math inline">\(p_*(\pi_1(E,e_0))\)</span> 在 <span class="math inline">\(\pi_1(B,b_0)\)</span> 中的指数等于 <span class="math inline">\((E,p)\)</span> 的重数.</li></ul><blockquote><p><strong>命题</strong> 集合 <span class="math inline">\(\{p_*(\pi_1(E,e))~\vert~e\in p^{-1}(b_0)\}\)</span> 是 <span class="math inline">\(\pi_1(B,b_0)\)</span> 的某个子群的共轭类. <font color="red"> <strong>这说明复叠空间 <span class="math inline">\((E,p)\)</span> 决定了 <span class="math inline">\(\pi_1(B,b_0)\)</span> 中的一个子群共轭类.</strong> </font></p></blockquote><h4 id="映射的提升">映射的提升</h4><blockquote><p><strong>映射提升的唯一性</strong> 设 <span class="math inline">\((E,p)\)</span> 是 <span class="math inline">\(B\)</span> 上的复叠空间, <span class="math inline">\(X\)</span> 连通, 映射 <span class="math inline">\(\tilde{f_i}: X\to E\)</span>, <span class="math inline">\(i=1,2\)</span> 都是 <span class="math inline">\(f: X\to B\)</span> 的提升. 若 <span class="math display">\[\exists x_0\in X,~\text{s.t.}~\tilde{f}_1(x_0)=\tilde{f}_2(x_0),\]</span> 则 <span class="math inline">\(\tilde{f}_1=\tilde{f}_2\)</span>. <font color="red"> <strong>这说明对于 <span class="math inline">\(f(x_0)=b_0\)</span>, 满足 <span class="math inline">\(\tilde{f}(x_0)=e_0\)</span> 的提升若存在必唯一.</strong> </font></p></blockquote><p>对于提升的存在性, 有如下定理:</p><blockquote><p><strong>映射提升定理</strong> 设 <span class="math inline">\(X\)</span> 是道路连通且局部道路连通空间, <span class="math inline">\(f: X\to B\)</span> 连续, <span class="math inline">\(f(x_0)=b_0\)</span>, <span class="math inline">\(e_0\in p^{-1}(b_0)\)</span>, 则: <span class="math display">\[\exists~提升~\tilde{f},~\text{s.t.}~\tilde{f}(x_0)=e_0~\Leftrightarrow~f_*(\pi_1(X, x_0))\subset p_*(\pi_1(E,e_0)).\]</span></p></blockquote><h4 id="复叠空间的分类">复叠空间的分类</h4><ul><li><strong>复叠空间的同态</strong>: <span class="math inline">\((E_i, p_i)\)</span>, <span class="math inline">\(i=1,2\)</span> 是 <span class="math inline">\(B\)</span> 上的复叠空间, 若连续映射 <span class="math inline">\(h: E_1\to E_2\)</span> 满足 <span class="math inline">\(p_2\circ h=p_1\)</span>, 则称 <span class="math inline">\(h\)</span> 是复叠空间 <span class="math inline">\((E_1,p_1)\to (E_2,p_2)\)</span> 的同态. 当 <span class="math inline">\(h\)</span> 是同胚时, 则称 <span class="math inline">\(h\)</span> 是同构.</li></ul><blockquote><p><strong>定理</strong> <span class="math inline">\((E_1,p_1)\)</span> 与 <span class="math inline">\((E_2,p_2)\)</span> 等价 <span class="math inline">\(\Leftrightarrow\)</span> 它们决定 <span class="math inline">\(\pi_1(B,b_0)\)</span> 的同一个子群共轭类.</p></blockquote><h4 id="复叠变换">复叠变换</h4><ul><li><strong>复叠变换</strong>: <span class="math inline">\((E,p)\)</span> 上的自同构;</li><li><strong>复叠变换群</strong>: <span class="math inline">\((E,p)\)</span> 上自同构全体关于映射的复合构成一个群, 记作 <span class="math inline">\(D(E,p)\)</span>.</li></ul><h4 id="正则复叠空间">正则复叠空间</h4><p>以下命题等价:</p><ol type="1"><li><span class="math inline">\((E,p)\)</span> 是正则复叠空间;</li><li><span class="math inline">\(\forall b\in B\)</span>, <span class="math inline">\(e\in p^{-1}(b)\)</span>, <span class="math inline">\(p_*(\pi_1(E,e))\)</span> 是 <span class="math inline">\(\pi_1(B,p(e))\)</span> 的正规子群;</li><li><span class="math inline">\(\forall b\in B\)</span>, <span class="math inline">\(e,e&#39;\in p^{-1}(b)\)</span>, <span class="math inline">\(p_*(\pi_1(E,e))=p_*(\pi_1(E,e&#39;))\)</span>;</li><li><span class="math inline">\(\forall b\in B\)</span>, <span class="math inline">\(e,e&#39;\in p^{-1}(b)\)</span>, <span class="math inline">\(\exists h\in D(E,p)\)</span>, s.t. <span class="math inline">\(h(e)=e&#39;\)</span>.</li></ol><h4 id="万有复叠空间">万有复叠空间</h4><ul><li><strong>万有复叠空间</strong>: 单连通的复叠空间.(显然正则)</li></ul><blockquote><p><strong>命题</strong> 设 <span class="math inline">\(p:E\to B\)</span> 是复叠空间, <span class="math inline">\(p&#39;: E&#39;\to B\)</span> 是万有复叠空间, 则有复叠映射 <span class="math inline">\(\tilde{p}: E&#39;\to E\)</span>, s.t. <span class="math inline">\(p&#39;=p\circ\tilde{p}\)</span>.</p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 拓扑学 </tag>
            
            <tag> 期末复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数理统计复习重点</title>
      <link href="/2018/01/06/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/"/>
      <content type="html"><![CDATA[<h2 id="基本概念">基本概念</h2><h3 id="chi2-分布"><span class="math inline">\(\chi^2\)</span> 分布</h3><h4 id="定义">定义</h4><p>设 <span class="math inline">\(X_1,\cdots,X_n\)</span> 为来自 <span class="math inline">\(N(0,1)\)</span> 的iid样本, 则称随机变量</p><p><span class="math display">\[\xi=\sum\limits_{i=1}^nX_i^2\]</span></p><p>所服从的分布为自由度为 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(\chi^2\)</span> 分布, 记为 <span class="math inline">\(\xi\sim\chi^2(n)\)</span>.</p><h4 id="性质">性质</h4><ol type="1"><li><p><span class="math inline">\(E\xi=n\)</span>, <span class="math inline">\({\rm Var}~\xi=2n\)</span>;</p></li><li><p>设 <span class="math inline">\(\xi\sim\chi^2(m)\)</span>, <span class="math inline">\(\eta\sim\chi^2(n)\)</span>, 且二者独立, 则 <span class="math inline">\(\xi+\eta\sim\chi^2(m+n)\)</span>;</p></li><li><p><font color="red"><span class="math inline">\((n-1)S_n^2/\sigma^2\sim\chi^2(n-1)\)</span></font>.</p></li></ol><h3 id="t-分布"><span class="math inline">\(t\)</span> 分布</h3><h4 id="定义-1">定义</h4><p>设 <span class="math inline">\(\xi\sim N(0,1)\)</span>, <span class="math inline">\(\eta\sim\chi^2(n)\)</span>, 且 <span class="math inline">\(\xi\)</span>, <span class="math inline">\(\eta\)</span> 相互独立, 则称随机变量</p><p><span class="math display">\[T=\frac{\xi}{\sqrt{\eta/n}}\]</span></p><p>服从自由度为 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(t\)</span> 分布, 记为 <span class="math inline">\(T\sim t(n)\)</span>.</p><h4 id="性质-1">性质</h4><ol type="1"><li><p>设 <span class="math inline">\(\xi\sim t(n)\)</span>, <span class="math inline">\(n&gt;2\)</span>, 则 <span class="math inline">\(E\xi=0\)</span>, <span class="math inline">\({\rm Var}~\xi=\frac{n}{n-2}\)</span>;</p></li><li><p><span class="math inline">\(t(1)\)</span> 分布为Cauchy分布, 期望不存在;</p></li><li><p><font color="red"> <span class="math inline">\(\frac{\sqrt{n}(\overline{X}-\mu)}{S}\sim t(n-1)\)</span> </font>;</p></li></ol><h3 id="f-分布"><span class="math inline">\(F\)</span> 分布</h3><h4 id="定义-2">定义</h4><p>设 <span class="math inline">\(\xi,\eta\)</span> 是自由度分别为 <span class="math inline">\(m,n\)</span> 的独立的 <span class="math inline">\(\chi^2\)</span> 随机变量, 则称随机变量</p><p><span class="math display">\[F=\frac{\xi/m}{\eta/n}\]</span></p><p>服从自由度为 <span class="math inline">\((m,n)\)</span> 的 <span class="math inline">\(F\)</span> 分布, 记为 <span class="math inline">\(F\sim F(m,n)\)</span>.</p><h4 id="性质-2">性质</h4><ol type="1"><li><span class="math inline">\(X\sim F(m,n) \Longleftrightarrow \frac{1}{X}\sim F(n,m)\)</span>.</li></ol><h3 id="gamma-分布族"><span class="math inline">\(\Gamma\)</span> 分布族</h3><h4 id="定义-3">定义</h4><p>PDF 为 <span class="math display">\[\Gamma(x;\alpha,\lambda)=\frac{\lambda^\alpha}{\Gamma(\alpha)}x^{\alpha-1}e^{-\lambda x},\quad x&gt;0\]</span> 的分布称为 <span class="math inline">\(\Gamma\)</span> 分布, 记作 <span class="math inline">\(\Gamma(\alpha,\lambda)\)</span>.</p><h4 id="性质-3">性质</h4><ol type="1"><li><p><font color="red"><span class="math inline">\(\Gamma(\frac{n}{2},\frac{1}{2})=\chi^2(n)\)</span></font>;</p></li><li><p><font color="red"><span class="math inline">\(\Gamma(1,\lambda)=E(\lambda)\)</span>, PDF 为 <span class="math inline">\(f(x)=\lambda e^{-\lambda x},~x&gt;0\)</span></font>;</p></li><li><p><font color="red"><span class="math inline">\(\xi\sim\Gamma(\alpha_1,\lambda)\)</span>, <span class="math inline">\(\eta\sim\Gamma(\alpha_2,\lambda)\)</span>, <span class="math inline">\(\eta\)</span> 与 <span class="math inline">\(\xi\)</span> 独立 <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(\xi+\eta\sim\Gamma(\alpha_1+\alpha_2,\lambda)\)</span></font>;</p></li><li><p><font color="red"><span class="math inline">\(\xi\sim\Gamma(\alpha,\lambda)\)</span>, <span class="math inline">\(k&gt;0\in\mathbb{R}\)</span> <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(\xi/k\sim\Gamma(\alpha,k\lambda)\)</span></font>.</p></li></ol><h3 id="充分统计量">充分统计量</h3><h4 id="因子分解定理">因子分解定理</h4><blockquote><p><strong>定理</strong> 对于参数分布族 <span class="math display">\[\mathcal{F}=\{f_\theta(x):\theta\in\Theta\},\]</span> 设 <span class="math inline">\(X_1,\cdots,X_n\)</span> 是其中一组iid样本, <span class="math inline">\(T\)</span> 是一统计量, 且其样本分布 <span class="math inline">\(f_\theta\)</span> 满足 <span class="math display">\[f_\theta(x_1,\cdots,x_n)=g_\theta(T(x_1,\cdots,x_n))\cdot h(x_1,\cdots,x_n),\]</span> 其中 <span class="math inline">\(h(x)\)</span> 不依赖于 <span class="math inline">\(\theta\)</span>.</p></blockquote><h4 id="常见的充分统计量">常见的充分统计量</h4><ol type="1"><li><p>均匀分布 <span class="math inline">\(U(0,\theta)\)</span> 中 , <span class="math inline">\(X_{(n)}\)</span> 为 <span class="math inline">\(\theta\)</span> 的充分统计量;</p></li><li><p>正态分布 <span class="math inline">\(N(\mu,\sigma^2)\)</span> 中, <span class="math inline">\((\overline{X},\sum\limits_{i=1}^n (X_i-\overline{X})^2)\)</span> 为 <span class="math inline">\((\mu,\sigma^2)\)</span> 的充分统计量;</p></li><li><p>均匀分布 <span class="math inline">\(U(-\frac{1}{2}+\theta, \frac{1}{2}+\theta)\)</span> 中, <span class="math inline">\((X_{(1)},X_{(n)})\)</span> 为 <span class="math inline">\(\theta\)</span> 的充分统计量.</p></li></ol><h2 id="点估计">点估计</h2><h3 id="矩估计">矩估计</h3><h4 id="矩估计-1">矩估计</h4><p>对于样本 <span class="math inline">\(X_1,\cdots,X_n\)</span> 和 <span class="math inline">\(k\in\mathbb{N}\)</span>, 称 <span class="math display">\[a_k=\frac{1}{n}\sum\limits_{i=1}^n X_i^k,\quad m_k=\frac{1}{n}\sum\limits_{i=1}^n (X_i-\overline{X})^k\]</span> 为 <span class="math inline">\(k\)</span> 阶中心矩和 <span class="math inline">\(k\)</span> 阶原点矩.</p><p>而总体的原点矩和中心矩分别为 <span class="math display">\[\mu_k=\mathbb{E}X^k,\quad \nu_k=\mathbb{E}(X-\mu_1)^k\]</span></p><p>矩估计就是用样本矩来估计总体矩, 即令 <span class="math inline">\(a_k=\mu_k\)</span>, <span class="math inline">\(m_k=\nu_k\)</span>.</p><h4 id="几个矩估计的例子">几个矩估计的例子</h4><ol type="1"><li><p>总体均值和总体方差: <span class="math display">\[\hat{\mu}=\overline{X},\quad \hat{\sigma}^2=\frac{n-1}{n}S_n^2;\]</span></p></li><li><p>正态分布 <span class="math inline">\(U(0,\theta)\)</span> 中, <span class="math inline">\(\theta\)</span> 的矩估计为 <span class="math inline">\(\hat{\theta}=2\overline{X}\)</span>;</p></li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 概率论 </tag>
            
            <tag> 统计学 </tag>
            
            <tag> 期末复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>测度与概率复习重点</title>
      <link href="/2018/01/02/%E6%B5%8B%E5%BA%A6%E4%B8%8E%E6%A6%82%E7%8E%87%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/"/>
      <content type="html"><![CDATA[<h2 id="测度空间">测度空间</h2><h3 id="各种集类">各种集类</h3><h4 id="半集代数">半集代数</h4><ol type="1"><li><span class="math inline">\(\Omega\in\mathscr{S}\)</span>, <span class="math inline">\(\varnothing\in\mathscr{S}\)</span>;</li><li>若 <span class="math inline">\(A,B\in\mathscr{S}\)</span>, 则 <span class="math inline">\(A\cap B\in\mathscr{S}\)</span>;</li><li>若 <span class="math inline">\(A,A_1\in\mathscr{S}\)</span>, <span class="math inline">\(A_1\subset A\)</span>, 则 <span class="math inline">\(\exists A_2,\cdots,A_n\subset\mathscr{S}\)</span>, <span class="math inline">\(A_1,\cdots,A_n\)</span> 两两不交, 且 <span class="math inline">\(A=\bigcup\limits_{k=1}^nA_k\)</span>.</li></ol><h4 id="集代数">集代数</h4><ol type="1"><li><span class="math inline">\(\Omega\in\mathscr{A}\)</span>;</li><li>若 <span class="math inline">\(A,B\in\mathscr{A}\)</span>, 则 <span class="math inline">\(A\cap B, A\cup B\in\mathscr{A}\)</span>;</li><li>若 <span class="math inline">\(A\in\mathscr{A}\)</span>, 则 <span class="math inline">\(A^c\in\mathscr{A}\)</span>.</li></ol><ul><li>包含半集代数 <span class="math inline">\(\mathscr{S}\)</span> 的最小集代数为 <span class="math inline">\(\mathscr{A}(\mathscr{S})=\{\bigcup\limits_{k=1}^n A_k:A_1,\cdots,A_n\in\mathscr{S}\}\)</span>.</li></ul><h4 id="sigma-代数"><span class="math inline">\(\sigma\)</span> 代数</h4><ol type="1"><li><span class="math inline">\(\Omega\in\mathcal{F}\)</span>;</li><li>若 <span class="math inline">\(A\in\mathcal{F}\)</span>, 则 <span class="math inline">\(A^c\in\mathcal{F}\)</span>;</li><li>若 <span class="math inline">\(A_n\in\mathcal{F}~(n\in\mathbb{N})\)</span>, 则 <span class="math inline">\(\bigcup\limits_{n=1}^\infty A_n\in\mathcal{F}\)</span>.</li></ol><ul><li>任意一族 <span class="math inline">\(\sigma\)</span> 代数的交仍然是 <span class="math inline">\(\sigma\)</span> 代数;</li><li>所有包含 <span class="math inline">\(\mathcal{C}\)</span> 的 <span class="math inline">\(\sigma\)</span> 代数的交称为包含 <span class="math inline">\(\mathcal{C}\)</span> 的<strong>最小 <span class="math inline">\(\sigma\)</span> 代数</strong>, 记作 <span class="math inline">\(\sigma(\mathcal{C})\)</span>.</li></ul><h3 id="单调类定理">单调类定理</h3><h4 id="lambda-系"><span class="math inline">\(\lambda\)</span> 系</h4><ol type="1"><li><span class="math inline">\(\Omega\in\Lambda\)</span>;</li><li>对真差封闭: <span class="math inline">\(A,B\in\Lambda\)</span>, <span class="math inline">\(A\subset B\)</span>, 则 <span class="math inline">\(B\backslash A\in\Lambda\)</span>;</li><li>对不降序列的并封闭: <span class="math inline">\(\{A_n:n\in\mathbb{N}\} \subset\Lambda\)</span>, <span class="math inline">\(A_n\uparrow\)</span>, 则 <span class="math inline">\(\bigcup\limits_{n=1}^\infty A_n\in\Lambda\)</span>.</li></ol><h4 id="pi-系"><span class="math inline">\(\pi\)</span> 系</h4><ol type="1"><li>对交封闭: <span class="math inline">\(A,B\in\Lambda\)</span>, 则 <span class="math inline">\(A\cap B\in\Lambda\)</span>.</li></ol><h4 id="单调类定理-1">单调类定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\Omega\)</span> 的子集类 <span class="math inline">\(\mathcal{C}\)</span> 是 <span class="math inline">\(\pi\)</span> 系, 则 <span class="math inline">\(\Lambda(\mathcal{C})=\sigma(\mathcal{C})\)</span>.</p></blockquote><p>证明思路:</p><ol type="1"><li>令 $_A={B():AB()} $;</li><li><span class="math inline">\(\forall A\in\Lambda(\mathcal{C})\)</span>, 证明 <span class="math inline">\(\Lambda_A\)</span> 是 <span class="math inline">\(\lambda\)</span> 系;</li><li><span class="math inline">\(\forall A\in\mathcal{C}\)</span>, 证明 <span class="math inline">\(\Lambda_A=\Lambda(\mathcal{C})\)</span>;</li><li><span class="math inline">\(\forall A\in\Lambda(\mathcal{C})\)</span>, 证明 <span class="math inline">\(\Lambda_A=\Lambda(\mathcal{C})\)</span>.</li></ol><h3 id="测度的构造">测度的构造</h3><h4 id="有限可加测度">有限可加测度</h4><ul><li>可加: <span class="math inline">\(\forall A,B\in\mathcal{C}\)</span>, <span class="math inline">\(A\cup B\in\mathcal{C}\)</span>, <span class="math inline">\(A\cap B=\varnothing\)</span>, 有 <span class="math inline">\(\mu(A\cup B)=\mu(A)+\mu(B)\)</span>.</li><li>可加测度 <span class="math inline">\(\Leftrightarrow\)</span> 有限可加测度.</li></ul><h4 id="sigma-可加测度"><span class="math inline">\(\sigma\)</span> 可加测度</h4><ul><li><span class="math inline">\(\forall A_n\in\mathcal{C}\)</span>, <span class="math inline">\(n\in\mathbb{N}\)</span> 两两不交且 <span class="math inline">\(\bigcup\limits_{n=1}^\infty A_n\in\mathcal{C}\)</span>, 有 <span class="math inline">\(\mu(\bigcup\limits_{n=1}^\infty A_n)=\sum\limits_{n=1}^\infty\mu(A_n)\)</span>.</li></ul><h4 id="sigma-有限测度"><span class="math inline">\(\sigma\)</span> 有限测度</h4><p>若 <span class="math inline">\(\forall A\in\mathcal{C}\)</span>, <span class="math inline">\(\exists \{A_n:n\in\mathbb{N}\} \subset\mathcal{C}\)</span>, s.t. <span class="math inline">\(\bigcup\limits_{n=1}^\infty A_n=A\)</span> 且 <span class="math inline">\(\mu(A_n)&lt;\infty\)</span>, <span class="math inline">\(\forall n\in\mathbb{N}\)</span>, 则称其为 <span class="math inline">\(\sigma\)</span> 有限的.</p><h3 id="测度扩张定理">测度扩张定理</h3><h4 id="半集代数上的测度">半集代数上的测度</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(F\)</span> 为 <span class="math inline">\(\mathbb{R}\)</span> 上的右连续增函数, 则在半集代数 <span class="math display">\[\mathscr{S}:=\{(a,b]:-\infty\leqslant a\leqslant b\leqslant\infty\} \]</span> 上有唯一的测度 <span class="math inline">\(\mu=\mu_F\)</span>, s.t. <span class="math display">\[\mu((a,b])=F(b)-F(a),~a\leqslant b\leqslant a,b\in\mathbb{R},\]</span> 并且 <span class="math inline">\(\mu\)</span> 在有限区间上的值有限(因而 <span class="math inline">\(\sigma\)</span> 有限).</p></blockquote><h4 id="测度扩张定理-1">测度扩张定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\mu\)</span> 为 <span class="math inline">\(\Omega\)</span> 的半集代数 <span class="math inline">\(\mathscr{S}\)</span> 上的测度, 则 <span class="math inline">\(\mu\)</span> 在 <span class="math inline">\(\mathscr{S}\)</span> 生成的 <span class="math inline">\(\sigma\)</span> 代数 <span class="math inline">\(\sigma(\mathscr{S})\)</span> 上存在一个扩张. 若 <span class="math inline">\(\mu\)</span> 是 <span class="math inline">\(\sigma\)</span> 有限的, 则扩张唯一.</p></blockquote><ul><li>唯一性证明: <span class="math inline">\(\lambda-\pi\)</span> 系方法.</li></ul><h4 id="外测度">外测度</h4><ol type="1"><li><span class="math inline">\(\mu^*(\varnothing)=0\)</span>;</li><li>不降性: <span class="math inline">\(\forall A\subset B\subset\Omega\)</span>, 有 <span class="math inline">\(\mu^*(A)\leqslant \mu^*(B)\)</span>;</li><li>次 <span class="math inline">\(\sigma\)</span> 可加性: <span class="math inline">\(\forall A_n\subset\Omega\)</span>, <span class="math inline">\(n\in\mathbb{N}\)</span>, 有 <span class="math display">\[\mu^*(\bigcup\limits_{N=1}^\infty A_n)\leqslant \sum\limits_{n=1}^\infty \mu^*(A_n).\]</span></li></ol><ul><li><span class="math inline">\(\mu^*\)</span> 可测集: <span class="math inline">\(\mu^*(D)=\mu^*(A\cap D)+\mu^*(A^c\cap D)\)</span>.</li></ul><h3 id="测度空间-1">测度空间</h3><h4 id="测度空间-2">测度空间</h4><p><span class="math inline">\((\Omega,\mathcal{F},\mu)\)</span> 是测度空间当且仅当 <span class="math inline">\(\mathcal{F}\)</span> 是 <span class="math inline">\(\sigma\)</span> 代数且 <span class="math inline">\(\mu\)</span> 是 <span class="math inline">\(\Omega\)</span> 上的 <span class="math inline">\(\sigma\)</span> 可加测度.</p><ul><li>若 <span class="math inline">\(\mu(\Omega)=1\)</span> 则称为概率空间, <span class="math inline">\(\mu\)</span> 即为概率 <span class="math inline">\(\mathbb{P}\)</span>.</li></ul><h4 id="可加性的提升">可加性的提升</h4><blockquote><p><strong>定理</strong> <span class="math inline">\(\mu\)</span> 为集代数 <span class="math inline">\(\mathscr{A}\)</span> 上的<strong>可加</strong>测度, 若 <span class="math inline">\(\mu\)</span> 还满足以下条件之一:</p></blockquote><blockquote><ol type="1"><li><span class="math inline">\(\mu\)</span> 下方连续: 即对 <span class="math inline">\(\forall \{A_n\} \subset\mathscr{A}\)</span>, <span class="math inline">\(A_n\uparrow A\)</span>, 总有 <span class="math inline">\(\lim\limits_ {n\to\infty}\mu(A_n)=\mu(A)\)</span>;</li><li><span class="math inline">\(\mu\)</span> 有限且在 <span class="math inline">\(\varnothing\)</span> 上方连续: 即对 <span class="math inline">\(\forall \{A_n\} \subset\mathscr{A}\)</span>, <span class="math inline">\(A_n\downarrow\varnothing\)</span>, 都有 <span class="math inline">\(\lim\limits_{n\to\infty}\mu(A_n)=0\)</span>. 则 <span class="math inline">\(\mu\)</span> 为 <span class="math inline">\(\mathscr{A}\)</span> 上的测度(即有限可加可提升为 <span class="math inline">\(\sigma\)</span> 可加).</li></ol></blockquote><h4 id="测度的完全化">测度的完全化</h4><ul><li><strong><span class="math inline">\(\mu\)</span> 零集</strong>: 零测集的子集称为 <span class="math inline">\(\mu\)</span> 零集;</li><li><strong>完全测度</strong>: 若每一个 <span class="math inline">\(\mu\)</span> 零集都属于 <span class="math inline">\(\mathcal{F}\)</span>, 则称 <span class="math inline">\(\mu\)</span> 为完全测度, 该测度空间为完全测度空间.</li></ul><blockquote><p><strong>定理</strong> 设 <span class="math inline">\((\Omega, \mathcal{F}, \mu)\)</span> 为测度空间, 令 <span class="math display">\[\overline{\mathcal{F}}=\{A\triangle N:A\in\mathcal{F}, N 为 \mu 零集\} =\{A\cup N:A\in\mathcal{F}, N 为 \mu 零集\} \]</span> <span class="math display">\[\overline{\mu}(A\triangle N)=\mu(A),~A\in\mathcal{F},~N 为 \mu 零集合\]</span> 则 <span class="math inline">\((\Omega,\overline{\mathcal{F}},\overline{\mu})\)</span> 为一个完全测度空间, 称为原空间的完全化.</p></blockquote><h2 id="可测函数与随机变量">可测函数与随机变量</h2><h3 id="逆像">逆像</h3><h4 id="逆像与集合运算的交换">逆像与集合运算的交换</h4><p>设 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(\Omega\to E\)</span> 的映射, 则 <span class="math inline">\(f^{-1}\)</span> 有如下性质:</p><ol type="1"><li><p><span class="math inline">\(f^{-1}(E)=\Omega\)</span>, <span class="math inline">\(f^{-1}(\varnothing)=\varnothing\)</span>;</p></li><li><p><span class="math inline">\(f^{-1}(B^c)=(f^{-1}(B))^c\)</span>;</p></li><li><p><span class="math inline">\(f^{-1}(\bigcup\limits_{\gamma\in\Gamma}B_\gamma)=\bigcup\limits_{\gamma\in\Gamma}f^{-1}(B_\gamma)\)</span>;</p></li><li><p><span class="math inline">\(f^{-1}(\bigcap\limits_{\gamma\in\Gamma}B_\gamma)=\bigcap\limits_{\gamma\in\Gamma}f^{-1}(B_\gamma)\)</span>;</p></li><li><p><span class="math inline">\(f^{-1}(B_1\backslash B_2)=f^{-1}(B_1)\backslash f^{-1}(B_2)\)</span>.</p></li></ol><h4 id="逆像与集类">逆像与集类</h4><p>进一步, <span class="math inline">\(f^{-1}\)</span> 还对集类有相同的作用:</p><ol type="1"><li><p><span class="math inline">\(\mathscr{E}\)</span> 为 <span class="math inline">\(E\)</span> 的一个 <span class="math inline">\(\sigma\)</span> 代数 <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(f^{-1}(\mathscr{E})\)</span> 是 <span class="math inline">\(\Omega\)</span> 的 <span class="math inline">\(\sigma\)</span> 代数;</p></li><li><p><span class="math inline">\(\mathcal{C}\)</span> 是 <span class="math inline">\(E\)</span> 的任意非空子集类, 则 <span class="math inline">\(f^{-1}(\sigma(\mathcal{C}))=\sigma(f^{-1}(\mathcal{C}))\)</span>. (<strong>证明: <span class="math inline">\(\lambda-\pi\)</span> 系方法</strong>)</p></li></ol><h3 id="随机变量">随机变量</h3><blockquote><p><strong>定理</strong> <span class="math inline">\(X\)</span> 是 <span class="math inline">\((\Omega,\mathcal{F})\to (E,\mathscr{E})\)</span> 的可测映射的充要条件是: 存在 <span class="math inline">\(\mathscr{E}\)</span> 的一个子集类 <span class="math inline">\(\mathcal{C}\)</span>, s.t. 1. <span class="math inline">\(\sigma(\mathcal{C})=\mathscr{E}\)</span>; 2. <span class="math inline">\(\forall A\in\mathcal{C}\)</span>, <span class="math inline">\(X^{-1}(A)\in\mathcal{F}\)</span>.</p></blockquote><h4 id="可测函数的构造">可测函数的构造</h4><center><font color="red"><strong>非负简单函数→非负可测函数→可测函数</strong></font></center><h3 id="单调类定理-2">单调类定理</h3><h4 id="mathscrl-系"><span class="math inline">\(\mathscr{L}\)</span> 系</h4><p>设 <span class="math inline">\(\mathscr{L}\)</span> 是定义在 <span class="math inline">\(\Omega\)</span> 上的广义实函数类, 满足: <span class="math inline">\(f\in\mathscr{L}\Rightarrow f^+,f^-\in\mathscr{L}\)</span>. 函数族 <span class="math inline">\(L\)</span> 称为 <span class="math inline">\(\mathscr{L}\)</span>, 如果满足: 1. <span class="math inline">\(1\in L\)</span>; 2. <span class="math inline">\(L\)</span> 中有限个函数的线性组合(如果有意义)属于 <span class="math inline">\(L\)</span>; 3. 若 <span class="math inline">\(f_n\in L\)</span>, <span class="math inline">\(n\in\mathbb{N}\)</span>, <span class="math inline">\(0\leqslant f_n\uparrow f\)</span>, <span class="math inline">\(f\)</span> 有界或 <span class="math inline">\(f\in\mathscr{L}\)</span>, 则 <span class="math inline">\(f\in L\)</span>.</p><h4 id="单调类定理-3">单调类定理</h4><blockquote><p>若 <span class="math inline">\(\mathscr{L}\)</span> 系 <span class="math inline">\(L\)</span> 包含一 <span class="math inline">\(\pi\)</span> 系 <span class="math inline">\(\mathcal{C}\)</span> 中任意集合的示性函数, 则 <span class="math inline">\(L\)</span> 包含所有属于 <span class="math inline">\(\mathscr{L}\)</span> 的 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 可测函数.</p></blockquote><ul><li>证明: <span class="math inline">\(\lambda-\pi\)</span> 系方法.</li></ul><h2 id="积分与数学期望">积分与数学期望</h2><center><font color="red"><strong>非负简单函数→非负可测函数→可测函数</strong></font></center><h3 id="积分的性质">积分的性质</h3><h4 id="单调收敛">单调收敛</h4><blockquote><p><strong>定理</strong> 若 <span class="math inline">\(f_n\)</span>, <span class="math inline">\(n\in\mathbb{N}\)</span> 是<strong>非负</strong>(可举反例)可测函数列, 且 <span class="math inline">\(f_n\uparrow f\)</span>, 则 <span class="math inline">\(\lim\limits_{n\to\infty}\int f_n=\int f\)</span>.</p></blockquote><h4 id="积分的序性质">积分的序性质</h4><ol type="1"><li><p>若 <span class="math inline">\(f,g\)</span> 为实函数, <span class="math inline">\(\int f\)</span>, <span class="math inline">\(\int g\)</span> 存在, 且 <span class="math inline">\(f\geqslant g\)</span>, a.e. 则 <span class="math inline">\(\int_A f\geqslant \int_A g\)</span>, <span class="math inline">\(\forall A\in\mathcal{F}\)</span>.</p></li><li><p>若 <span class="math inline">\(\int f\)</span> 存在, 则 <span class="math inline">\(\vert\int f\vert\leqslant \int\vert f\vert\)</span>,</p></li><li><p><span class="math inline">\(f\geqslant 0\)</span>, 则 <span class="math inline">\(\int f=0\Leftrightarrow f=0\)</span>, a.e..</p></li></ol><h4 id="可积性质">可积性质</h4><p>给定可测函数 <span class="math inline">\(f,g\)</span> 有:</p><ol type="1"><li><p><span class="math inline">\(f\)</span> 可积 <span class="math inline">\(\Leftrightarrow\)</span> $f&lt;$; 当 <span class="math inline">\(f\)</span> 可积时, <span class="math inline">\(f\)</span> a.e. 有限;</p></li><li><p>若 <span class="math inline">\(\vert f\vert\leqslant g\)</span> 可积, 则 <span class="math inline">\(f\)</span> 可积;</p></li><li><p>若 <span class="math inline">\(f,g\)</span> 可积, 则 <span class="math inline">\(f+g\)</span> 可积.</p></li></ol><h3 id="期望的性质">期望的性质</h3><h4 id="独立事件类的扩张">独立事件类的扩张</h4><p>独立事件类可以由 <span class="math inline">\(\pi\)</span> 系扩张至其生成的 <span class="math inline">\(\sigma\)</span> 代数.</p><blockquote><p><strong>定理</strong> <span class="math inline">\(\mathcal{C}_k\subset\mathcal{F}\)</span> 为包含 <span class="math inline">\(\Omega\)</span> 的 <span class="math inline">\(\pi\)</span> 系, 若 <span class="math inline">\(\forall A_k\in\mathcal{C}_k\)</span>, <span class="math inline">\(k=1,\cdots,n\)</span>, 有 <span class="math display">\[\mathbb{P}(\bigcap\limits_{k=1}^n A_k)=\prod\limits_{k=1}^n \mathbb{P}(A_k),\]</span> 则上式对 <span class="math inline">\(\forall A_k\in\sigma(\mathcal{C}_k)\)</span>, <span class="math inline">\(k=1,\cdots,n\)</span> 成立.</p></blockquote><h4 id="独立随机变量">独立随机变量</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(X_1,\cdots,X_n\)</span> 为独立r.v., 且 <span class="math inline">\(\mathbb{E}X_k\)</span> 有限, 则 <span class="math display">\[\mathbb{E}(X_1\cdots X_n)=\prod\limits_{k=1}^n \mathbb{E}X_k.\]</span></p></blockquote><h3 id="l-s-积分表示">L-S 积分表示</h3><h4 id="分布测度">分布测度</h4><p>设 <span class="math inline">\(f\)</span> 是 <span class="math inline">\((\Omega,\mathcal{F},\mu)\to(E,\mathscr{E})\)</span> 的可测映射, <span class="math inline">\(\mu\)</span> 是 <span class="math inline">\(\mathcal{F}\)</span> 上的测度, 定义 <span class="math display">\[\mu_f(B)=\mu(f^{-1}(B)),\quad \forall B\in\mathscr{E},\]</span> 则 <span class="math inline">\(\mu_f\)</span> 是 <span class="math inline">\(\mathscr{E}\)</span> 上的测度, 也可记作 <span class="math inline">\(\mu_f=\mu\circ f^{-1}\)</span>.</p><h4 id="积分变换定理">积分变换定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(f\)</span> 是 <span class="math inline">\((\Omega,\mathcal{F},\mu)\to(E,\mathscr{E})\)</span> 的可测映射, <span class="math inline">\(g\)</span> 是 <span class="math inline">\((E,\mathscr{E})\)</span> 上的可测函数, 则 <span class="math display">\[\int_{f^{-1}(B)}(g\circ f){\rm d}\mu=\int_B g{\rm d}\mu_f,\quad \forall B\in\mathscr{E}.~(同时存在,~存在即相等)\]</span></p></blockquote><h4 id="积分变换">积分变换</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\mu\)</span> 是 <span class="math inline">\((\Omega,\mathcal{F})\)</span> 上的测度, <span class="math inline">\(p\)</span> 是非负 <span class="math inline">\(\mathcal{F}\)</span> 可测函数, 定义 <span class="math display">\[\nu(A)=\int_A p(w)\mu({\rm d}w),\quad A\in \mathcal{F},\]</span> 则 <span class="math inline">\(\nu\)</span> 是 <span class="math inline">\(\mathcal{F}\)</span> 上的测度, 且有 <span class="math display">\[\int_A g(w)\nu({\rm d}w)=\int_A g(w)p(w)\mu({\rm d}w).~(同时存在,~存在即相等)\]</span></p></blockquote><h3 id="积分的收敛">积分的收敛</h3><h4 id="单调收敛定理">单调收敛定理</h4><blockquote><p><strong>定理</strong> 给定 <span class="math inline">\((\Omega,\mathcal{F},\mu)\)</span>, <span class="math inline">\(g\)</span> 为实可积函数, <span class="math inline">\(f_n\)</span>, <span class="math inline">\(n\in\mathbb{N}\)</span> 是实 <span class="math inline">\(\mathcal{F}\)</span> 可测函数, 若 <span class="math inline">\(g\leqslant f_n\uparrow f\)</span>, a.e. 则 <span class="math display">\[\lim\limits_{n\to\infty}\int f_n=\int\lim\limits_{n\to\infty}f_n.\]</span></p></blockquote><h4 id="fatou引理">Fatou引理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(g,h\)</span> 是可积实函数, ${f_n:n} $ 是实可测函数列, 有 1. <span class="math inline">\(\forall n\in\mathbb{N}\)</span>, <span class="math inline">\(f_n\geqslant g\)</span>, a.e., 则 <span class="math display">\[\int\varliminf\limits_{n\to\infty} f_n\leqslant \varliminf\limits_{n\to\infty}\int f_n.\]</span> 2. <span class="math inline">\(\forall n\in\mathbb{N}\)</span>, <span class="math inline">\(f_n\leqslant h\)</span>, a.e., 则 <span class="math display">\[\int\varlimsup\limits_{n\to\infty} f_n\geqslant \varlimsup\limits_{n\to\infty}\int f_n.\]</span></p></blockquote><h4 id="控制收敛定理">控制收敛定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(g,h\)</span> 为可积实函数. 1. 若 <span class="math inline">\(f_n\)</span>, <span class="math inline">\(n\in\mathbb{N}\)</span> 为实可测函数序列, 当 <span class="math inline">\(g\leqslant f_n\leqslant h\)</span>, a.e., <span class="math inline">\(\forall n\in\mathbb{N}\)</span>, <span class="math inline">\(f_n\to f\)</span>, a.e. 时, 有 <span class="math inline">\(\int f_n\to\int f\)</span>. 2. 若 <span class="math inline">\(f_n\)</span>, <span class="math inline">\(n\in\mathbb{N}\)</span> 为实或复可测函数序列, 当 <span class="math inline">\(\vert f_n\vert\leqslant g\)</span>, a.e., <span class="math inline">\(\forall n\in\mathbb{N}\)</span>, <span class="math inline">\(f_n\to f\)</span>, a.e. 时, 有 <span class="math inline">\(\int\vert f_n-f\vert\to 0\)</span>, 因而 <span class="math inline">\(\int f_n\to\int f\)</span>.</p></blockquote><h2 id="乘积空间">乘积空间</h2><h3 id="乘积-sigma-代数">乘积 <span class="math inline">\(\sigma\)</span> 代数</h3><p>设 <span class="math inline">\((\Omega_i,\mathcal{F})\)</span>, <span class="math inline">\(i=1,2\)</span> 是可测空间, 称包含可测矩形 <span class="math display">\[\mathcal{C}=\{A_1\times A_2: A_i\in\mathcal{F}, i=1,2\} \]</span> 的最小 <span class="math inline">\(\sigma\)</span> 代数为 <span class="math inline">\(\mathcal{F}_1,\mathcal{F}_2\)</span> 的乘积 <span class="math inline">\(\sigma\)</span> 代数.</p><ul><li>可测矩形类 <span class="math inline">\(\mathcal{C}\)</span> 是一个半集代数;</li><li><span class="math inline">\(\mathscr{B}^2=\mathscr{B}\times\mathscr{B}\)</span>. (<strong>证明: <span class="math inline">\(\lambda-\pi\)</span> 系方法</strong>)</li></ul><h3 id="截集">截集</h3><h4 id="截集-1">截集</h4><p><span class="math inline">\(A\subset\Omega_1\times\Omega_2\)</span>, <span class="math inline">\(\omega_i\in\Omega_i\)</span>, <span class="math inline">\(i=1,2\)</span>, 称集合 <span class="math display">\[A_{\omega_1}=A(\omega_1)=\{\omega_2\in\Omega_2: (\omega_1,\omega_2)\in A\} ,\]</span> <span class="math display">\[A_{\omega_2}=A(\omega_2)=\{\omega_1\in\Omega_1: (\omega_1,\omega_2)\in A\} ,\]</span> 分别为 <span class="math inline">\(A\)</span> 在 <span class="math inline">\(\omega_1\)</span>, <span class="math inline">\(\omega_2\)</span> 处的截集.</p><h4 id="截集的性质">截集的性质</h4><p>截集与集合的运算可以交换:</p><ol type="1"><li><p><span class="math inline">\(A\cap B=\varnothing\Rightarrow A(\omega_i)\cap B(\omega_i)=\varnothing\)</span>;</p></li><li><p><span class="math inline">\(A\subset B\Rightarrow A(\omega_i)\subset B(\omega_i)\)</span>;</p></li><li><p><span class="math inline">\(A=\bigcup\limits_\alpha A^{(\alpha)}\Rightarrow A(\omega_i)=\bigcup\limits_\alpha A^{(\alpha)}(\omega_i)\)</span>;</p></li><li><p><span class="math inline">\(A=\bigcap\limits_\alpha A^{(\alpha)}\Rightarrow A(\omega_i)=\bigcap\limits_\alpha A^{(\alpha)}(\omega_i)\)</span>;</p></li><li><p><span class="math inline">\(C=A\backslash B\Rightarrow C(\omega_i)=A(\omega_i)\backslash B(\omega_i)\)</span>.</p></li></ol><p>对于截集的可测性有如下定理:</p><blockquote><p><strong>定理</strong> 取 <span class="math inline">\(A\in\mathcal{F}_1\times\mathcal{F}_2\)</span>, 则 <span class="math inline">\(\forall \omega_1\in\mathcal{F}_1\)</span>, 有 <span class="math inline">\(A(\omega_1)\in\mathcal{F}_2\)</span>.</p></blockquote><p><strong>证明: <span class="math inline">\(\lambda-\pi\)</span> 系方法.</strong></p><h4 id="截函数">截函数</h4><ul><li><span class="math inline">\(f_{\omega_1}=f(\omega_1,\cdot)\)</span> 称为 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(\omega_1\)</span> 的截函数;</li><li><span class="math inline">\(f_{\omega_2}=f(\cdot,\omega_2)\)</span> 称为 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(\omega_2\)</span> 的截函数;</li></ul><blockquote><p><strong>定理</strong> 任意 <span class="math inline">\(\mathcal{F}_1\times\mathcal{F}_2\)</span> 可测函数的截函数是可测的.</p></blockquote><p>关于截函数还有如下重要定理:</p><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(\mathcal{F}_1\times\mathcal{F}_2\)</span> 可测函数, <span class="math inline">\(\mu_i\)</span> 是 <span class="math inline">\(\sigma\)</span> 有限测度, 则 <span class="math display">\[f^{(2)}=\int_{\Omega_1}f(\omega_1,\cdot)\mu_1({\rm d}\omega_1)\]</span> <span class="math display">\[f^{(1)}=\int_{\Omega_2}f(\cdot,\omega_2)\mu_2({\rm d}\omega_2)\]</span> 是非负可测函数.</p></blockquote><h3 id="乘积测度">乘积测度</h3><p>设 <span class="math inline">\(\mu_i\)</span> 是 <span class="math inline">\(\sigma\)</span> 有限测度, 若令 <span class="math display">\[\mu(A)=\int_{\Omega_1}\mu_2(A(\omega_1))\mu_1({\rm d}\omega_1),~A\in\mathcal{F}_1\times\mathcal{F}_2,\]</span> 或 <span class="math display">\[\mu(A)=\int_{\Omega_2}\mu_1(A(\omega_2))\mu_2({\rm d}\omega_2),~A\in\mathcal{F}_1\times\mathcal{F}_2,\]</span> 则 <span class="math inline">\(\mu\)</span> 是 <span class="math inline">\(\mathcal{F}_1\times\mathcal{F}_2\)</span> 上唯一满足 <span class="math display">\[\mu(A_1\times A_2)=\mu_1(A_1)\mu_2(A_2),~\forall A_i\in\mathcal{F}_i\]</span> 的 <span class="math inline">\(\sigma\)</span> 有限测度.</p><h3 id="转移测度">转移测度</h3><p>映射 <span class="math inline">\(\lambda:\Omega_1\times\mathcal{F}_2\to [0,\infty]\)</span> 满足下列条件, 就称之为 <span class="math inline">\((\Omega_1,\mathcal{F}_1)\to(\Omega_2,\mathcal{F}_2)\)</span> 的转移测度: 1. <span class="math inline">\(\forall B\in\mathcal{F}_2\)</span>, <span class="math inline">\(\lambda(\cdot,B)\)</span> 是 <span class="math inline">\(\mathcal{F}_1\)</span> 可测函数; 2. <span class="math inline">\(\forall \omega\in\Omega_1\)</span>, <span class="math inline">\(\lambda(\omega,\cdot)\)</span> 是 <span class="math inline">\(\mathcal{F}_2\)</span> 上的测度.</p><p>若 <span class="math inline">\(\exists B_{kn}\in\mathcal{F}_k\)</span>, <span class="math inline">\(n\in\mathbb{N}\)</span> 两两不交, <span class="math inline">\(\Omega_k=\bigcup\limits_{n=1}^\infty B_{kn}\)</span>, <span class="math inline">\(k=1,2\)</span>, s.t. <span class="math display">\[\sup\limits_{\omega\in B_{1m}}\lambda(\omega,B_{2n})&lt;\infty,~\forall m,n\in\mathbb{N},\]</span> 则称 <span class="math inline">\(\lambda\)</span> 为 <span class="math inline">\(\sigma\)</span> 有限转移测度.</p><h3 id="fubini定理">Fubini定理</h3><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(f\)</span> 是非负 <span class="math inline">\(\mathcal{F}_1\times\mathcal{F}_2\)</span> 可测函数, 则 <span class="math display">\[\begin{align}\int_{\Omega_1\times\Omega_2}f{\rm d}(\mu_1\times\mu_2) &amp;= \int_{\Omega_1}\left(\int_{\Omega_2}f(\omega_1,\omega_2)\mu_2({\rm d}\omega_2)\right)\mu_1({\rm d}\omega_1) \\&amp;= \int_{\Omega_2}\left(\int_{\Omega_1}f(\omega_1,\omega_2)\mu_1({\rm d}\omega_1)\right)\mu_2({\rm d}\omega_2).\end{align}\]</span></p></blockquote><h4 id="fubini定理-1">Fubini定理</h4><blockquote><p><strong>Fubini</strong> 设 <span class="math inline">\(f\)</span> 是非负 <span class="math inline">\(\mathcal{F}_1\times\mathcal{F}_2\)</span> 可测函数且 <span class="math inline">\(\int f{\rm d}(\mu_1\times\mu_2)\)</span> 存在, 则 1. 积分函数存在且可测: - <span class="math inline">\(g(\omega_1)=\int_{\Omega_2}f(\omega_1,\omega_2)\mu_2({\rm d}\omega_2)\)</span> 存在且 <span class="math inline">\(\mathcal{F}_1\)</span> 可测; - <span class="math inline">\(h(\omega_2)=\int_{\Omega_1}f(\omega_1,\omega_2)\mu_1({\rm d}\omega_1)\)</span> 存在且 <span class="math inline">\(\mathcal{F}_2\)</span> 可测; 2. <span class="math inline">\(\int_{\Omega_1}g{\rm d}\mu_1\)</span>, <span class="math inline">\(\int_{\Omega_2}h{\rm d}\mu_2\)</span> 存在且 <span class="math display">\[\int_{\Omega_1\times\Omega_2}f({\rm d}\mu_1\times\mu_2)=\int_{\Omega_1}g({\rm d}\mu_1)=\int_{\Omega_2}f({\rm d}\mu_2);\]</span> 3. 若 <span class="math inline">\(f\)</span> 对 <span class="math inline">\(\mu_1\times\mu_2\)</span> 可积, 则 <span class="math inline">\(g\)</span>, <span class="math inline">\(h\)</span> 分别对 <span class="math inline">\(\mu_1\)</span>, <span class="math inline">\(\mu_2\)</span> 可积.</p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 概率论 </tag>
            
            <tag> 测度论 </tag>
            
            <tag> 期末复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>泛函——复习重点</title>
      <link href="/2017/12/24/%E6%B3%9B%E5%87%BD%E2%80%94%E2%80%94%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/"/>
      <content type="html"><![CDATA[<h2 id="度量空间">度量空间</h2><h3 id="基础知识">基础知识</h3><h4 id="压缩映像原理">压缩映像原理</h4><blockquote><p><strong>Banach</strong> 设 <span class="math inline">\((\mathscr{X},\rho)\)</span> 是一个完备度量空间, <span class="math inline">\(T\)</span> 是 <span class="math inline">\(\mathscr{X}\)</span> 到自身的一个压缩映射, 则 <span class="math inline">\(T\)</span> 在 <span class="math inline">\(\mathscr{X}\)</span> 上存在唯一的不动点.</p></blockquote><h4 id="完备化">完备化</h4><p><strong>完备化空间</strong>: 包含 <span class="math inline">\(\mathscr{X}\)</span> 的最小完备度量空间. 关于其存在性有如下定理:</p><blockquote><p><strong>定理</strong> 每个度量空间都有一个自身在其中稠的完备化空间.</p></blockquote><h4 id="有界性与列紧性">有界性与列紧性</h4><blockquote><p><strong>定理</strong> 列紧空间的任意子集都是列紧集. 进一步, 任意闭子集都是自列紧的. <strong>定理</strong> 列紧空间必定完备. 反之不成立, 如 <span class="math inline">\(\mathbb{R}\)</span>.</p></blockquote><ul><li>完全有界和列紧</li></ul><blockquote><p><strong>定理</strong> 列紧集一定完全有界, 完全有界集必定有界. <strong>定理</strong> 有穷维 <span class="math inline">\(B^*\)</span> 空间的有界集必定完全有界, 完备空间中的完全有界集必定列紧.</p></blockquote><p><span class="math inline">\(\mathscr{X}\)</span> 中的列紧集、完全有界集、有界集三者的关系如下: <font color="red"><span class="math display">\[列紧~\underset{\mathscr{X}~完备}{\rightleftarrows}~完全有界~\underset{有限维B^*}{\rightleftarrows}~有界\]</span></font></p><h4 id="一致有界和等度连续">一致有界和等度连续</h4><p><strong>一致有界</strong>: 设 <span class="math inline">\(F\subset C(M)\)</span>, 若 <span class="math inline">\(\exists M_1&gt;0\)</span>, s.t. <span class="math inline">\(\vert\varphi(x)\vert\leqslant M~(\forall x\in M,\forall \varphi\in F)\)</span>, 则称 <span class="math inline">\(F\)</span> 一致有界.</p><p><strong>等度连续</strong>: 设 <span class="math inline">\(F\subset C(M)\)</span>, 若对 <span class="math inline">\(\forall \epsilon&gt;0\)</span>, <span class="math inline">\(\exists\delta(\epsilon)&gt;0\)</span>, s.t. <span class="math inline">\(\vert\varphi(x_1)-\varphi(x_2)\vert&lt; \epsilon~(\forall x_1,x_2\in M, \rho(x_1,x_2)&lt;\delta,\forall\varphi\in F)\)</span>, 则称 <span class="math inline">\(F\)</span> 等度连续.</p><p>关于等度连续, 有如下的Arzela-Ascoli定理:</p><blockquote><p><strong>A-A</strong> <span class="math inline">\(F\subset C(M)\)</span> 列紧 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(F\)</span> 一致有界且等度连续.</p></blockquote><h3 id="准范数与frechet空间">准范数与Frechet空间</h3><h4 id="准范数">准范数</h4><p>线性空间 <span class="math inline">\(\mathscr{X}\)</span> 上的<strong>准范数</strong>定义为这个空间上的一个函数 <span class="math inline">\(\Vert\cdot\Vert:\mathscr{X}\to\mathbb{R}^1\)</span>, s.t.</p><ol type="1"><li><span class="math inline">\(\Vert x \Vert\geqslant 0\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>; <span class="math inline">\(\Vert x\Vert=0\Leftrightarrow x=\theta\)</span>;</li><li><span class="math inline">\(\Vert x+y\Vert\leqslant \Vert x\Vert+\Vert y\Vert\)</span>, <span class="math inline">\(\forall x,y\in\mathscr{X}\)</span>;</li><li><span class="math inline">\(\Vert -x\Vert=\Vert x\Vert\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>;</li><li><span class="math inline">\(\lim\limits_{\alpha_n\to 0}\Vert\alpha_n x\Vert=0\)</span>, <span class="math inline">\(\lim\limits_{\Vert x_n\Vert\to 0}\Vert\alpha x_n\Vert=0\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>, <span class="math inline">\(\forall\alpha\in\mathbb{K}\)</span>.</li></ol><h4 id="frechet空间">Frechet空间</h4><p>用准范数 <span class="math inline">\(\Vert x_n-x\Vert\to 0\)</span> 来定义极限 <span class="math inline">\(x_n\to x\)</span> 的线性空间 <span class="math inline">\(\mathscr{X}\)</span>, 称为 <span class="math inline">\(F^*\)</span> 空间. 完备的 <span class="math inline">\(F^*\)</span> 空间称为Frechet空间.</p><h3 id="范数与banach空间">范数与Banach空间</h3><h4 id="范数">范数</h4><p>线性空间 <span class="math inline">\(\mathscr{X}\)</span> 上的<strong>范数</strong> <span class="math inline">\(\Vert\cdot\Vert\)</span> 是一个非负值函数: <span class="math inline">\(\mathscr{X}\to\mathbb{R}^1\)</span>, s.t. 1. <span class="math inline">\(\Vert x\Vert\geqslant 0\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>, 且 <span class="math inline">\(\Vert x\Vert=0\Leftrightarrow x=\theta\)</span>; 2. <span class="math inline">\(\Vert x+y\Vert\leqslant \Vert x \Vert+ \Vert y\Vert\)</span>, <span class="math inline">\(\forall x,y\in\mathscr{X}\)</span>; 3. <span class="math inline">\(\Vert\alpha x\Vert=\vert\alpha\vert\Vert x\Vert\)</span>, <span class="math inline">\(\forall\alpha\in\mathbb{K}\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>.</p><h4 id="banach空间">Banach空间</h4><p>具有范数的 <span class="math inline">\(F^*\)</span> 空间称为 <span class="math inline">\(B^*\)</span> 空间, 完备的 <span class="math inline">\(B^*\)</span> 空间称为Banach空间.</p><h4 id="范数的等价">范数的等价</h4><p>范数 <span class="math inline">\(\Vert\cdot\Vert_1\)</span> 与 <span class="math inline">\(\Vert\cdot\Vert_2\)</span> 等价是指: <span class="math inline">\(\Vert x_n\Vert_1\Leftrightarrow \Vert x_n\Vert_2\)</span>, <span class="math inline">\(n\to\infty\)</span>. 即: <span class="math inline">\(\exists C_1,C_2&lt;0\)</span>, s.t. <span class="math inline">\(C_1\Vert x\Vert_1\leqslant\Vert x\Vert_2\leqslant C_2\Vert x\Vert_1\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>.</p><blockquote><p><strong>定理</strong> 有穷维 <span class="math inline">\(B^*\)</span> 空间的任意范数都等价.</p></blockquote><blockquote><p><strong>推论</strong> 相同维数的有穷维 <span class="math inline">\(B^*\)</span> 空间代数上同构, 拓扑上同胚.</p></blockquote><blockquote><p><strong>推论</strong> 有穷维 <span class="math inline">\(B^*\)</span> 空间必定完备, <font color="red"><strong>反之不成立</strong></font>.</p></blockquote><h4 id="半模">半模</h4><p>半模是 <span class="math inline">\(P:\mathscr{X}\to\mathbb{R}^1\)</span> 是线性空间 <span class="math inline">\(\mathscr{X}\)</span> 上的一个函数, s.t.</p><ol type="1"><li><span class="math inline">\(P(x)\geqslant 0\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>; <strong><font color="red">注意没有要求 <span class="math inline">\(P(x)=0\Leftrightarrow x=\theta\)</span></font></strong>;</li><li><span class="math inline">\(P(x+y)\leqslant P(x)+P(y)\)</span>, <span class="math inline">\(\forall x,y\in\mathscr{X}\)</span>;</li><li><span class="math inline">\(P(\alpha x)=\vert\alpha\vert P(x)\)</span>, <span class="math inline">\(\forall\alpha\in\mathbb{K}\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>.</li></ol><h4 id="有穷维-b-空间">有穷维 <span class="math inline">\(B^*\)</span> 空间</h4><blockquote><p><strong>定理</strong> <span class="math inline">\(B^*\)</span> 空间是有穷维的当且仅当其单位球面是列紧的.</p></blockquote><blockquote><p><strong>推论</strong> <span class="math inline">\(B^*\)</span> 空间是有穷维的当且仅当其任意有界集是列紧的.</p></blockquote><p>还有如下的Riesz引理:</p><blockquote><p><strong>Riesz 引理</strong> 如果 <span class="math inline">\(\mathscr{X}_0\)</span> 是 <span class="math inline">\(B^*\)</span> 空间 <span class="math inline">\(\mathscr{X}\)</span> 的一个真闭子空间, 那么对于 <span class="math inline">\(\forall 0&lt;\epsilon&lt;1\)</span>, <span class="math inline">\(\exists y\in\mathscr{X}\)</span>, s.t. <span class="math inline">\(\Vert y\Vert=1\)</span>, 且 <span class="math inline">\(\Vert y-x\Vert\geqslant1-\epsilon\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}_0\)</span>.</p></blockquote><h3 id="凸集与minkowski泛函">凸集与Minkowski泛函</h3><h4 id="凸集和凸包">凸集和凸包</h4><p>凸集: <span class="math inline">\(E\)</span> 是凸集 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(\lambda x+(1-\lambda)y\in E\)</span>, <span class="math inline">\(\forall x,y\in E\)</span>, <span class="math inline">\(\forall 0\leqslant\lambda\leqslant 1\)</span>.</p><p>凸包: <span class="math display">\[co(A)=\{\sum\limits_{i=1}^n\lambda_i x_i ~\vert~ \sum\limits_{i=1}^n \lambda_i=1, \lambda_i\geqslant 0, x_i\in A, i=1,2,\cdots,n, \forall n\in\mathbb{N}\}\]</span>为包含 <span class="math inline">\(A\)</span> 的最小凸集.</p><h4 id="minkowski泛函">Minkowski泛函</h4><p><span class="math inline">\(\mathscr{X}\)</span> 是线性空间, <span class="math inline">\(C\)</span> 是 <span class="math inline">\(\mathscr{X}\)</span> 上含有 <span class="math inline">\(\theta\)</span> 的凸子集, 则如下定义Minkowski泛函:</p><p><span class="math display">\[P(x)=\inf\{\lambda&gt;0 ~\vert~ \frac{x}{\lambda}\in C\},\quad \forall x\in\mathscr{X}.\]</span></p><h3 id="内积与hilbert空间">内积与Hilbert空间</h3><h4 id="共轭双线性函数">共轭双线性函数</h4><p>线性空间 <span class="math inline">\(\mathscr{X}\)</span> 上的双线性函数是指一个二元函数 <span class="math inline">\(a(\cdot,~\cdot):\mathscr{X}\times\mathscr{X}\to\mathbb{K}\)</span>, s.t.</p><ol type="1"><li><span class="math inline">\(a(a_1x_1+a_2x_2,y)=a_1a(x_1,y)+a_2a(x_2,y)\)</span>;</li><li><span class="math inline">\(a(x,b_1y_1+b_2y_2)=\overline{b_1}a(x,y_1)+\overline{b_2}a(x,y_2)\)</span>.</li></ol><h4 id="内积">内积</h4><p><span class="math inline">\(\mathscr{X}\)</span> 上的共轭双线性函数 <span class="math inline">\((\cdot,~\cdot)\)</span> 称为一个内积, 如果满足:</p><ol type="1"><li><span class="math inline">\((x,y)=\overline{(y,x)}\)</span>;</li><li><span class="math inline">\((x,x)\geqslant 0\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>, 且 <span class="math inline">\((x,x)=0\Leftrightarrow x=\theta\)</span>.</li></ol><ul><li>若去掉 <span class="math inline">\((x,x)=0\Leftrightarrow x=\theta\)</span> 的要求, 则称为<strong>半内积</strong>.</li><li>定义了内积的空间称为内积空间, 完备的内积空间称为<strong>Hilbert</strong>空间.</li></ul><h4 id="cauchy-schwarz-不等式">Cauchy-Schwarz 不等式</h4><blockquote><p><strong>C-S</strong> 设 <span class="math inline">\((\mathscr{X},(\cdot,~\cdot))\)</span> 是内积空间, 取 <span class="math inline">\(\Vert x\Vert=(x,x)^\frac{1}{2}\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>, 则有 <span class="math display">\[\vert (x,y)\vert\leqslant \Vert x\Vert\Vert y\Vert, \quad \forall x,y\in\mathscr{X}.\]</span>等号当且仅当 <span class="math inline">\(x=\lambda y\)</span> 取得.</p></blockquote><h4 id="内积空间与-b-空间">内积空间与 <span class="math inline">\(B^*\)</span> 空间</h4><ul><li>内积空间 <span class="math inline">\(\to\)</span> <span class="math inline">\(B^*\)</span> 空间</li></ul><blockquote><p>内积空间 <span class="math inline">\(\mathscr{X}\)</span> 按照 <span class="math inline">\(\Vert x\Vert=(x,x)^\frac{1}{2}\)</span> 定义范数, 是<strong>严格凸的 <span class="math inline">\(B^*\)</span> 空间</strong>, 且内积关于范数连续.</p></blockquote><ul><li><span class="math inline">\(B^*\)</span> 空间 <span class="math inline">\(\to\)</span> 内积空间</li></ul><blockquote><p>在 <span class="math inline">\(B^*\)</span> 空间 <span class="math inline">\(\mathscr{X}\)</span> 中, 为了引入内积满足上式, 范数必须满足 <span class="math display">\[\Vert x+y\Vert^2+\Vert x-y\Vert^2=2\Vert x\Vert^2+2\Vert y\Vert^2,\quad \forall x,y\in\mathscr{X}.\]</span></p></blockquote><h4 id="正交集">正交集</h4><ul><li>完备正交集: <span class="math inline">\(S\)</span> 为正交集, 且 <span class="math inline">\(S^\perp=\{\theta\}\)</span>.</li><li>Bessel 不等式</li></ul><blockquote><p><strong>Bessel</strong>设 <span class="math inline">\(\mathscr{X}\)</span> 是一个内积空间, 若 <span class="math inline">\(S=\{e_\alpha~\vert~\alpha\in A\}\)</span> 是其中的正交规范基, 那么 <span class="math inline">\(\forall x\in\mathscr{X}\)</span>, 有 <span class="math display">\[\sum\limits_{\alpha\in A}|(x,e_\alpha)|^2\leqslant \Vert x\Vert^2.\]</span> 事实上, <span class="math inline">\(\{\alpha\in A: (x,e_\alpha)\neq 0\}\)</span> 至多可数.</p></blockquote><ul><li>Parseval 等式</li></ul><blockquote><p><strong>Parseval</strong> 设 <span class="math inline">\(\mathscr{X}\)</span> 是一个Hilbert空间, <span class="math inline">\(S\)</span> 是正交规范基, 则 <span class="math display">\[S完备\Leftrightarrow \Vert x\Vert^2=\sum\limits_{\alpha\in A}|(x,e_\alpha)|^2,\quad \forall x\in\mathscr{X}.\]</span></p></blockquote><ul><li>正交分解</li></ul><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(M\)</span> 是Hilbert空间上的一个闭子空间, 则 <span class="math inline">\(\forall x\in\mathscr{X}\)</span> 存在唯一的正交分解: <span class="math display">\[x=y+z\quad (y\in M, z\in M^\perp).\]</span></p></blockquote><h2 id="线性算子与线性泛函">线性算子与线性泛函</h2><h3 id="riesz定理">Riesz定理</h3><h4 id="riesz定理-1">Riesz定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(f\)</span> 是Hilbert空间 <span class="math inline">\(\mathscr{X}\)</span> 上的一个连续线性泛函, 则存在唯一的 <span class="math inline">\(y_f\in\mathscr{X}\)</span>, s.t. <span class="math inline">\(f(x)=(x,y_f)\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>.</p></blockquote><p>该定理直接说明了: <strong><font color="red">若 <span class="math inline">\(\mathscr{X}\)</span> 是Hilbert空间, 则 <span class="math inline">\(\mathscr{X}=\mathscr{X}^*\)</span>.</font></strong></p><h3 id="开映像定理">开映像定理</h3><h4 id="baire纲定理">Baire纲定理</h4><blockquote><p><strong>Baire</strong> 完备度量空间 <span class="math inline">\((\mathscr{X},\rho)\)</span> 是第二纲集.</p></blockquote><h4 id="开映像定理-1">开映像定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\mathscr{X},\mathscr{Y}\)</span> 都是 <span class="math inline">\(B\)</span> 空间, 若 <span class="math inline">\(T\in\mathscr{L}(\mathscr{X},\mathscr{Y})\)</span> 是一个满射, 则 <span class="math inline">\(T\)</span> 是开映射.</p></blockquote><h3 id="闭图像定理">闭图像定理</h3><h4 id="bounded-linear-transform">Bounded Linear Transform</h4><blockquote><p><strong>B.I.T</strong> 设 <span class="math inline">\(T\)</span> 是 <span class="math inline">\(B^*\)</span> 空间 <span class="math inline">\(\mathscr{X}\)</span> 到 <span class="math inline">\(B\)</span> 空间 <span class="math inline">\(\mathscr{Y}\)</span> 的连续线性算子, 那么 <span class="math inline">\(T\)</span> 能唯一地延拓到 <span class="math inline">\(\overline{D(T)}\)</span> 上称为连续线性算子 <span class="math inline">\(T_1\)</span>, s.t. <span class="math inline">\(T_1\vert_{D(T)}=T\)</span>, 且 <span class="math inline">\(\Vert T_1\Vert=\Vert T\Vert\)</span>.</p></blockquote><blockquote><p><strong>命题</strong> <span class="math inline">\(T\)</span> 是闭算子 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(G_T\)</span> 按照图模 (<span class="math inline">\(\Vert x\Vert_G=\Vert x\Vert+\Vert Tx\Vert\)</span>) 是闭集.</p></blockquote><h4 id="范数等价定理">范数等价定理</h4><blockquote><p><strong>定理</strong> 设线性空间 <span class="math inline">\(\mathscr{X}\)</span> 有范数 <span class="math inline">\(\Vert\cdot\Vert_1\)</span> 和 <span class="math inline">\(\Vert\cdot\Vert_2\)</span>. 若 <span class="math inline">\(\mathscr{X}\)</span> 关于二者都构成 <span class="math inline">\(B\)</span> 空间, 且 <span class="math inline">\(\Vert\cdot\Vert_1\)</span> 比 <span class="math inline">\(\Vert\cdot\Vert_2\)</span> 强, 则二者等价.</p></blockquote><h4 id="闭图像定理-1">闭图像定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\mathscr{X},\mathscr{Y}\)</span> 是 <span class="math inline">\(B\)</span> 空间. 若 <span class="math inline">\(T\)</span> 是 <span class="math inline">\(D(T)\to\mathscr{Y}\)</span> 的闭线性算子, 且 <span class="math inline">\(D(T)\)</span> 闭, 则 <span class="math inline">\(T\)</span> 连续.</p></blockquote><h3 id="共鸣定理">共鸣定理</h3><h4 id="共鸣定理-1">共鸣定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\mathscr{X}\)</span> 是 <span class="math inline">\(B\)</span> 空间, <span class="math inline">\(\mathscr{Y}\)</span> 是 <span class="math inline">\(B^*\)</span> 空间, 如果 <span class="math inline">\(W\subset\mathscr{L}(\mathscr{X},\mathscr{Y})\)</span>, s.t. <span class="math inline">\(\sup\limits_{A\in W}\Vert Ax\Vert&lt;\infty~~(\forall x\in\mathscr{X})\)</span>, 那么存在常数 <span class="math inline">\(M\)</span>, s.t. <span class="math inline">\(\Vert A\Vert\leqslant M\)</span>, <span class="math inline">\(\forall A\in W\)</span>.</p></blockquote><p>立刻有如下推论:</p><blockquote><p><strong>推论</strong> 设 <span class="math inline">\(\mathscr{X}\)</span> 是Banach空间, <span class="math inline">\(A\subset\mathscr{X}^*\)</span>, 则 <span class="math inline">\(A\)</span> 有界 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(\forall x\in\mathscr{X}\)</span>, <span class="math inline">\(\sup\limits_{f\in A}\vert f(x)\vert&lt;\infty\)</span>.</p></blockquote><h4 id="banach-steinhaus定理">Banach-Steinhaus定理</h4><blockquote><p><strong>B-S</strong> 设 <span class="math inline">\(\mathscr{X}\)</span> 是 <span class="math inline">\(B\)</span> 空间, <span class="math inline">\(\mathscr{Y}^*\)</span> 是 <span class="math inline">\(B^*\)</span> 空间, <span class="math inline">\(M\)</span> 是 <span class="math inline">\(\mathscr{X}\)</span> 的稠子集. 取 <span class="math inline">\(A_n~(n=1,2,\cdots)\in\mathscr{L}(\mathscr{X},\mathscr{Y})\)</span>, 则 <span class="math inline">\(\lim\limits_{n\to\infty}A_n x=Ax~(\forall x)\)</span> 当且仅当: 1. <span class="math inline">\(\Vert A_n\Vert\)</span> 有界; 2. 对于 <span class="math inline">\(\forall x\in M\)</span>, 有 <span class="math inline">\(\lim\limits_{n\to\infty}A_n x=Ax\)</span>.</p></blockquote><p>该定理实际上说明了算子列的收敛性和有界性很大程度上决定于其在一个稠子集上的情况.</p><h4 id="lax-milgram定理">Lax-Milgram定理</h4><blockquote><p><strong>L-M</strong> 设 <span class="math inline">\(a(x,y)\)</span> 是Hilbert空间 <span class="math inline">\(\mathscr{X}\)</span> 上的一个共轭双线性函数, s.t. 1. <span class="math inline">\(\exists M&gt;0\)</span>, s.t. <span class="math inline">\(\vert a(x,y)\vert\leqslant M\Vert x\Vert\Vert y\Vert~~(\forall x,y\in\mathscr{X})\)</span>; 2. <span class="math inline">\(\exists\delta&gt;0\)</span>, s.t. <span class="math inline">\(\vert a(x,y)\vert\geqslant\delta\Vert x\Vert^2~~(\forall x\in\mathscr{X})\)</span>.</p></blockquote><blockquote><p>则存在唯一的有连续逆的线性算子 <span class="math inline">\(A\in\mathscr{L}(\mathscr{X},\mathscr{Y})\)</span>, s.t. <span class="math inline">\(a(x,y)=(x,Ay)\)</span>, <span class="math inline">\(\forall x,y\in\mathscr{X}\)</span>, 且 <span class="math inline">\(\Vert A^{-1}\Vert\leqslant\frac{1}{\delta^2}\)</span>.</p></blockquote><h3 id="hahn-banach定理">Hahn-Banach定理</h3><h4 id="实hahn-banach定理">实Hahn-Banach定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\mathscr{X}\)</span> 是实线性空间, <span class="math inline">\(p\)</span> 是定义在 <span class="math inline">\(\mathscr{X}\)</span> 上的次线性泛函, <span class="math inline">\(\mathscr{X}_0\)</span> 是 <span class="math inline">\(\mathscr{X}\)</span> 的实线性子空间, <span class="math inline">\(f_0\)</span> 是 <span class="math inline">\(\mathscr{X}_0\)</span> 上的实线性泛函并满足 <span class="math inline">\(f_0(x)\leqslant p(x)~(\forall x\in\mathscr{X}_0)\)</span>. 则 <span class="math inline">\(\mathscr{X}\)</span> 上存在(<strong>未必唯一</strong>)一个实线性泛函 <span class="math inline">\(f\)</span>, s.t. 1. <span class="math inline">\(f(x)\leqslant p(x)~(\forall x\in\mathscr{X})\)</span>; 2. <span class="math inline">\(f(x)=f_0(x)~(\forall x\in\mathscr{X}_0)\)</span>.</p></blockquote><h4 id="复hahn-banach定理">复Hahn-Banach定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\mathscr{X}\)</span> 是复线性空间, <span class="math inline">\(p\)</span> 是定义在 <span class="math inline">\(\mathscr{X}\)</span> 上的半模, <span class="math inline">\(\mathscr{X}_0\)</span> 是 <span class="math inline">\(\mathscr{X}\)</span> 的线性子空间, <span class="math inline">\(f_0\)</span> 是 <span class="math inline">\(\mathscr{X}_0\)</span> 上的线性泛函并满足 <span class="math inline">\(|f_0(x)|\leqslant p(x)~(\forall x\in\mathscr{X}_0)\)</span>. 则 <span class="math inline">\(\mathscr{X}\)</span> 上存在(<strong>未必唯一</strong>)一个线性泛函 <span class="math inline">\(f\)</span>, s.t. 1. <span class="math inline">\(|f(x)|\leqslant p(x)~(\forall x\in\mathscr{X})\)</span>; 2. <span class="math inline">\(f(x)=f_0(x)~(\forall x\in\mathscr{X}_0)\)</span>.</p></blockquote><h4 id="hahn-banach定理-1">Hahn-Banach定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\mathscr{X}\)</span> 是 <span class="math inline">\(B^*\)</span> 空间, <span class="math inline">\(\mathscr{X}_0\)</span> 是 <span class="math inline">\(\mathscr{X}\)</span> 的线性子空间, <span class="math inline">\(f_0\)</span> 是定义在 <span class="math inline">\(\mathscr{X}_0\)</span> 上的有界线性泛函, 则在 <span class="math inline">\(\mathscr{X}\)</span> 上存在有界线性泛函 <span class="math inline">\(f\)</span>, s.t. 1. <span class="math inline">\(f(x)=f_0(x)~(\forall x\in\mathscr{X})\)</span> (在 <span class="math inline">\(\mathscr{X}_0\)</span> 不变); 2. <span class="math inline">\(\Vert f\Vert=\Vert f_0\Vert_0\)</span> (保范).</p></blockquote><p>由此可以立刻得到推论</p><blockquote><p><strong>推论 1</strong> 在 <span class="math inline">\(B^*\)</span> 空间 <span class="math inline">\(\mathscr{X}\)</span> 上, <span class="math inline">\(\forall x_1,x_2\in\mathscr{X}\)</span>, <span class="math inline">\(\exists f\in\mathscr{X}^*\)</span>, s.t. <span class="math inline">\(f(x_1)=f(x_2)\)</span>. <strong>推论 2</strong> 设 <span class="math inline">\(\mathscr{X}\)</span> 是 <span class="math inline">\(B^*\)</span> 空间, <span class="math inline">\(\forall x_0\in\mathscr{X}\backslash\{\theta\}\)</span>, <span class="math inline">\(\exists f\in\mathscr{X}\)</span>, s.t. <span class="math inline">\(f(x_0)=\Vert x_0\Vert\)</span>, 且 <span class="math inline">\(\Vert f\Vert=1\)</span>.</p></blockquote><p>对于 <span class="math inline">\(B^*\)</span> 空间 <span class="math inline">\(\mathscr{X}\)</span> 的子空间 <span class="math inline">\(M\)</span>, 有如下结论:</p><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\mathscr{X}\)</span> 是 <span class="math inline">\(B^*\)</span> 空间, <span class="math inline">\(M\)</span> 是其线性子空间. 若 <span class="math inline">\(x_0\in\mathscr{X}\)</span>, 且 <span class="math inline">\(d:=\rho(x_0,M)&gt;0\)</span>, 则 <span class="math inline">\(\exists f\in\mathscr{X}^*\)</span>, s.t. 1. <span class="math inline">\(f(x)=0~~(\forall x\in M)\)</span>; 2. <span class="math inline">\(f(x_0)=d\)</span>; 3. <span class="math inline">\(\Vert f\Vert=1\)</span>.</p></blockquote><h4 id="hahn-banach定理的几何形式">Hahn-Banach定理的几何形式</h4><p>考虑 <span class="math inline">\(B^*\)</span> 空间 <span class="math inline">\(\mathscr{X}\)</span> 中的一个包含 <span class="math inline">\(\theta\)</span> 的真凸子集 <span class="math inline">\(E\)</span> 及 <span class="math inline">\(E\)</span> 外的一点 <span class="math inline">\(x_0\)</span>, 考虑 <span class="math inline">\(E\)</span> 的Minkowski泛函 <span class="math inline">\(p(x)\)</span>, 则 <span class="math inline">\(p\)</span> 是 <span class="math inline">\(\mathscr{X}\)</span> 上的非零连续次线性泛函.</p><p><strong>此时考虑Hahn-Banach定理的应用条件</strong>, 取子空间 <span class="math display">\[\mathscr{X}_0=\{\lambda x_0~\vert~\lambda\in\mathbb{R}^1\}\]</span> 及其上的线性泛函 <span class="math inline">\(f_0(\lambda x_0)=\lambda p(x_0)\)</span>. 则有 <span class="math inline">\(f_0(x)\leqslant p(x)\)</span>.</p><p><strong>至此, Hahn-Banach定理的条件已经全部满足</strong>. 于是存在实线性泛函 <span class="math inline">\(f\)</span>, s.t. <span class="math inline">\(f(x)\leqslant p(x)~(\forall x\in\mathscr{X})\)</span>, 且 <span class="math inline">\(f(x)=f_0(x)~(\forall x\in\mathscr{X}_0)\)</span>. 又由 <span class="math inline">\(f_0\)</span> 定义可知 <span class="math inline">\(f(x_0)\geqslant 0\)</span>, 以及 <span class="math inline">\(f(x)\leqslant 1~(\forall x\in E)\)</span>, 故 <strong><span class="math inline">\(H_f^1\)</span> 分离 <span class="math inline">\(x_0\)</span> 与 <span class="math inline">\(E\)</span></strong>.</p><p>即如下的几何形式的Hahn-Banach定理:</p><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(E\)</span> 是实 <span class="math inline">\(B^*\)</span> 空间 <span class="math inline">\(\mathscr{X}\)</span> 上以 <span class="math inline">\(\theta\)</span> 为内点的真凸子集, 又设 <span class="math inline">\(x_0\overline{\in}E\)</span>, 则必定存在一个超平面 <span class="math inline">\(H_f^r\)</span> 分离 <span class="math inline">\(x_0\)</span> 与 <span class="math inline">\(E\)</span>.</p></blockquote><p>由此可得到如下定理:</p><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(E_1\)</span> 和 <span class="math inline">\(E_2\)</span> 是 <span class="math inline">\(B^*\)</span> 空间中互不相交的非空凸集, 且 <span class="math inline">\(E_1\)</span> 有内点, 那么 <span class="math inline">\(\exists s\in\mathbb{R}^1\)</span> 以及非零线性连续泛函 <span class="math inline">\(f\)</span>, s.t. 超平面 <span class="math inline">\(H_f^s\)</span> 分离 <span class="math inline">\(E_1\)</span> 和 <span class="math inline">\(E_2\)</span>. 换言之, 存在非零连续线性泛函 <span class="math inline">\(f\)</span>, s.t. <span class="math inline">\(f(x)\leqslant s~(\forall x\in E_1)\)</span> 且 <span class="math inline">\(f(x)\geqslant s~(\forall x\in E_2)\)</span>.</p></blockquote><p>进而有如下两条定理:</p><ul><li>Ascoli定理</li></ul><blockquote><p><strong>Ascoli</strong> 设 <span class="math inline">\(E\)</span> 是实 <span class="math inline">\(B^*\)</span> 空间 <span class="math inline">\(\mathscr{X}\)</span> 中的闭凸集, 则 <span class="math inline">\(\forall x_0\in\mathscr{X}\backslash E\)</span>, <span class="math inline">\(\exists f\in\mathscr{X}^*\)</span> 及 <span class="math inline">\(a\in\mathbb{R}^1\)</span>, s.t. <span class="math inline">\(f(x)&lt;a&lt;f(x_0)\)</span>, <span class="math inline">\(\forall x\in E\)</span>.</p></blockquote><ul><li>Mazur定理</li></ul><blockquote><p><strong>Mazur</strong> 设 <span class="math inline">\(E\)</span> 是 <span class="math inline">\(B^*\)</span> 空间 <span class="math inline">\(\mathscr{X}\)</span> 上的一个有内点的闭凸集, <span class="math inline">\(F\)</span> 是 <span class="math inline">\(\mathscr{X}\)</span> 上的一个线性流形, 又设 <span class="math inline">\(E\cap F=\varnothing\)</span>, 则存在一个包含 <span class="math inline">\(F\)</span> 的闭超平面 <span class="math inline">\(L\)</span>, s.t. <span class="math inline">\(E\)</span> 在 <span class="math inline">\(L\)</span> 的一侧.</p></blockquote><h3 id="共轭空间">共轭空间</h3><ul><li>设 <span class="math inline">\(\mathscr{X}\)</span> 是一个 <span class="math inline">\(B^*\)</span> 空间, <span class="math inline">\(\mathscr{X}\)</span> 上的所有连续限行泛函全体 <span class="math inline">\(\mathscr{X}^*\)</span> 按照范数 <span class="math inline">\(\Vert f\Vert=\sup\limits_{\Vert x\Vert=1} \vert f(x)\vert\)</span> 构成一个 <span class="math inline">\(B\)</span> 空间, 称为 <span class="math inline">\(\mathscr{X}\)</span> 的共轭空间.</li></ul><blockquote><p><strong>定理</strong> 有 <span class="math inline">\((L^p[0,1])^*=L^q[0,1]\)</span>, <span class="math inline">\(\frac{1}{p}+\frac{1}{q}=1~(1\leqslant p&lt;\infty)\)</span>.</p></blockquote><p><font color="red"><strong>值得注意的是, <span class="math inline">\((L^\infty[0,1])^*\neq L^1[0,1]\)</span></strong>.</font></p><h4 id="第二共轭空间与自反空间">第二共轭空间与自反空间</h4><p><span class="math inline">\(\mathscr{X}^*\)</span> 的共轭空间 <span class="math inline">\(\mathscr{X}^{**}\)</span> 称为 <span class="math inline">\(\mathscr{X}\)</span> 的第二共轭空间.</p><p><strong>自然映射</strong>: 对于 <span class="math inline">\(\forall x\in\mathscr{X}\)</span>, 考虑 <span class="math inline">\(X(f)=f(x)~(\forall f\in\mathscr{X}^*)\)</span>, 则 <span class="math inline">\(X\)</span> 是 <span class="math inline">\(\mathscr{X}^*\)</span> 上的线性泛函, 且满足 <span class="math inline">\(\vert X(f)\vert\leqslant \Vert f\Vert\Vert x\Vert\)</span>. 因此 <span class="math inline">\(X\)</span> 是连续的, 满足 <span class="math inline">\(\Vert X\Vert \leqslant \Vert x\Vert\)</span>.</p><p>称上文中的映射 <span class="math inline">\(T:x\mapsto X\)</span> 为<strong>自然映射</strong>. 容易验证 <span class="math inline">\(T\)</span> 是一个等距嵌入, 于是有如下定理</p><blockquote><p><strong>定理</strong> <span class="math inline">\(B^*\)</span> 空间 <span class="math inline">\(\mathscr{X}\)</span> 与它的第二共轭空间 <span class="math inline">\(\mathscr{X}^{**}\)</span> 的一个子空间等距同构, 即 <span class="math inline">\(\mathscr{X}\subset\mathscr{X}^{**}\)</span>.</p></blockquote><p><strong>自反空间</strong>: 若自然映射 <span class="math inline">\(T\)</span> 是满射, 则称 <span class="math inline">\(\mathscr{X}\)</span> 是自反的. 即 <span class="math inline">\(\mathscr{X}=\mathscr{X}^{**}\)</span></p><p>关于自反空间, 有如下定理:</p><blockquote><p><strong>定理</strong> 有限维 <span class="math inline">\(B^*\)</span> 空间是自反的. 特别地, <span class="math inline">\(L^p~(1&lt;p&lt;\infty)\)</span> 是自反的.</p></blockquote><h4 id="弱收敛">弱收敛</h4><p><strong>弱收敛</strong>: 设 <span class="math inline">\(\mathscr{X}\)</span> 是一个 <span class="math inline">\(B^*\)</span> 空间, <span class="math inline">\(\{x_n\}\subset\mathscr{X}\)</span>, <span class="math inline">\(x\in\mathscr{X}\)</span>. 若对于 <span class="math inline">\(\forall f\in\mathscr{X}^*\)</span>, 均有 <span class="math inline">\(\lim\limits_{n\to\infty}f(x_n)=f(x)\)</span>, 则称 <span class="math inline">\(\{x_n\}\)</span> 弱收敛于 <span class="math inline">\(x\)</span>, 记作 <span class="math inline">\(x_n\rightharpoonup x\)</span>.</p><p>容易得到弱收敛和强收敛有如下关系:</p><ul><li>强收敛蕴含弱收敛, 反之不成立(尽管对于 <span class="math inline">\(\mathbb{R}\)</span> 成立);</li><li>当强极限存在时, 强弱收敛等价, 且极限唯一;</li><li>弱极限若存在必定唯一(利用Hahn-Banach定理可证).</li></ul><p>简单概括如下:</p><p><font color="red"><span class="math display">\[强收敛 \underset{在 \mathbb{R} 上}{\rightleftarrows}~弱收敛\quad\quad 强极限\underset{强极限存在}{\rightleftarrows}~弱极限\]</span></font></p><p>在 <span class="math inline">\(B^*\)</span> 空间上, 有如下的Mazur定理:</p><blockquote><p><strong>Mazur</strong> 设 <span class="math inline">\(\mathscr{X}\)</span> 是一个 <span class="math inline">\(B^*\)</span> 空间, 且 <span class="math inline">\(x_n\rightharpoonup x_0\)</span>(注意是弱收敛), 则 <span class="math inline">\(\forall\epsilon&gt;0\)</span>, <span class="math inline">\(\exists \lambda_i&gt;0~(i=1,2,\cdots,n)\)</span>, <span class="math inline">\(\sum\limits_{i=1}^n\lambda_i=1\)</span> s.t. <span class="math display">\[\Vert x_0-\sum\limits_{i=1}^n\lambda_i x_i\Vert\leqslant \epsilon.\]</span></p></blockquote><h4 id="弱收敛-1"><span class="math inline">\(*\)</span> 弱收敛</h4><p><strong><span class="math inline">\(*\)</span> 弱收敛</strong>: 设 <span class="math inline">\(\mathscr{X}\)</span> 是 <span class="math inline">\(B^*\)</span> 空间, <span class="math inline">\(\{f_n\}\subset\mathscr{X}^*\)</span>, <span class="math inline">\(f\in\mathscr{X}^*\)</span>. 若 <span class="math inline">\(\forall x\in\mathscr{X}\)</span>, 都有 <span class="math inline">\(\lim\limits_{n\to\infty}f_n(x)=f(x)\)</span>, 则称 <span class="math inline">\(f_n~*\)</span> 弱收敛于 <span class="math inline">\(f\)</span>, 记作 <span class="math inline">\(w^*-\lim\limits_{n\to\infty}f_n=f\)</span>.</p><p><strong><span class="math inline">\(\mathscr{X}^*\)</span> 上的弱收敛</strong>: 设 <span class="math inline">\(\{f_n\}\subset\mathscr{X}^*\)</span>, <span class="math inline">\(f\in\mathscr{X}^*\)</span>. 若对 <span class="math inline">\(\forall X\in\mathscr{X}^{**}\)</span>, 都有 <span class="math inline">\(X(f_n)\to X(f)\)</span>, 则称 <span class="math inline">\(f_n\)</span> 弱收敛于 <span class="math inline">\(f\)</span>.</p><p><strong>可以证明, <span class="math inline">\(\mathscr{X}^*\)</span> 上的弱收敛 <span class="math inline">\(\Rightarrow~*\)</span> 弱收敛.</strong> 特别地, 当 <span class="math inline">\(\mathscr{X}\)</span> 是一个自反空间时, 二者等价.</p><h4 id="弱列紧与-弱列紧性">弱列紧与 <span class="math inline">\(*\)</span> 弱列紧性</h4><p>对于 <span class="math inline">\(*\)</span> 弱列紧性, 有如下的定理:</p><blockquote><p><strong>定理</strong>: 可分的 <span class="math inline">\(B^*\)</span> 空间中的有界列必定有 <span class="math inline">\(*\)</span> 弱列紧的子列.</p></blockquote><p>进一步还有如下的定理:</p><ul><li>Banach定理:</li></ul><blockquote><p><strong>Banach</strong> 若 <span class="math inline">\(\mathscr{X}\)</span> 是 <span class="math inline">\(B^*\)</span> 空间, 则 <span class="math inline">\(\mathscr{X}\)</span> 可分 <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(\mathscr{X}^*\)</span> 可分.</p></blockquote><ul><li>Pettis定理:</li></ul><blockquote><p><strong>Pettis</strong> 自反空间 <span class="math inline">\(\mathscr{X}\)</span> 的自反空间 <span class="math inline">\(\mathscr{X}_0\)</span> 也是自反的.</p></blockquote><h2 id="附录">附录</h2><h3 id="几种范数">几种范数</h3><p><strong>范数</strong>: 正定性(<span class="math inline">\(\Vert x\Vert=0\Leftrightarrow x=\theta\)</span>)+三角不等式+齐次性.</p><ul><li>准范数: 与范数差齐次性;</li><li>半范数: 与范数差 <span class="math inline">\(\Vert x\Vert=0\Leftrightarrow x=\theta\)</span>.</li></ul><h3 id="几种收敛">几种收敛</h3><h4 id="mathscrx-的收敛"><span class="math inline">\(\mathscr{X}\)</span> 的收敛</h4><center><font color="red"><strong>强收敛 <span class="math inline">\(\Rightarrow\)</span> 弱收敛</strong></font></center><ul><li><strong>弱收敛</strong>: <span class="math inline">\(\forall f\in\mathscr{X}^*\)</span>, <span class="math inline">\(f(x_n)\to f(x)\)</span>, 记作 <span class="math inline">\(x_n\rightharpoonup x\)</span>;</li><li><strong>强收敛</strong>: <span class="math inline">\(\Vert x_n-x\Vert\to 0\)</span>, 记作 <span class="math inline">\(x_n\to x\)</span>.</li></ul><h4 id="mathscrx-的收敛-1"><span class="math inline">\(\mathscr{X}^*\)</span> 的收敛</h4><center><font color="red"><strong>一致收敛 <span class="math inline">\(\Rightarrow\)</span> 强收敛 <span class="math inline">\(\Rightarrow\)</span> 弱收敛 <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(*\)</span> 弱收敛</strong></font></center><ul><li><strong>一致收敛</strong>: <span class="math inline">\(\Vert f_n-f\Vert\to 0\)</span>, 记作 <span class="math inline">\(f_n\rightrightarrows f\)</span>;</li><li><strong>强收敛</strong>: <span class="math inline">\(\Vert (f_n-f)x\Vert\to 0~(\forall x\in\mathscr{X})\)</span>, 记作 <span class="math inline">\(f_n\to f\)</span>;</li><li><strong>弱收敛</strong>: <span class="math inline">\(X(f_n)\to X(f)~(\forall X\in\mathscr{X}^{**})\)</span>, 记作 <span class="math inline">\(f_n\rightharpoonup f\)</span>;</li><li><strong><span class="math inline">\(*\)</span>弱收敛</strong>: <span class="math inline">\(\forall x\in\mathscr{X}\)</span>, 有 <span class="math inline">\(f_n(x)\to f(x)\)</span>, 记作 <span class="math inline">\(w^*-\lim\limits_{n\to\infty}f_n=f\)</span>;</li><li><strong>以上极限若存在必唯一</strong>.</li></ul><h3 id="几种banach空间">几种Banach空间</h3><ol type="1"><li><span class="math inline">\(\mathbb{C}^n\)</span> 按照范数 <span class="math inline">\(\Vert x\Vert=(\sum\limits_{i=1}^n\vert x_i\vert^2)^{\frac{1}{2}}\)</span> 构成一个Banach空间;</li><li><span class="math inline">\(C(M)\)</span> (<span class="math inline">\(M\)</span> 是一个紧度量空间) 按照范数 <span class="math inline">\(\Vert f\Vert=\max\limits_{x\in M}\vert f(x)\vert\)</span> 构成一个Banach空间;</li><li><span class="math inline">\(L^p(\Omega,\mu)\)</span> 按照范数 <span class="math inline">\(\Vert f\Vert=\left(\int\nolimits_\Omega \vert f(x)\vert^p{\rm d}x\right)^{\frac{1}{p}}\)</span> 构成Banach空间.</li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 泛函分析 </tag>
            
            <tag> 期末复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>明月杯回忆录</title>
      <link href="/2017/12/05/%E6%98%8E%E6%9C%88%E6%9D%AF%E5%9B%9E%E5%BF%86%E5%BD%95/"/>
      <content type="html"><![CDATA[<h2 id="x00.-2014">0x00. 2014</h2><h3 id="明月杯流水账">明月杯流水账</h3><p>还记得和兄弟们第一次一起打球是军训刚回学校时。那时师大的篮球场还在装修，于是只好跑到北邮的球场。那时北邮还没有门禁，球场的人也不多，正是军训回来放松的好地方。从那以后，虽然经常与同学们一起打球，但<strong>因为抱有转专业的想法，所以没有直接加入篮球队</strong>，<del>不过后来还是被博哥拉进了球队Orz</del>。</p><p>第一次和球队的兄弟们打友谊赛也是在北邮，也是我第一次听说“二三联防”。哇，打篮球竟然还有这么多说法，原来我们之前都是瞎攻瞎防，野球玩家瑟瑟发抖Orz。这次友谊赛就像是给什么也不懂的我开启了新世界的大门，在随后的训练中也了解了许多在野球场上从未有过的战术。</p><p>明月杯如期而至，但<strong>作为菜鸟的我并未入选球队大名单</strong>。值得一提的是，大名单中仅有的两名菜鸟球员分别是擅长突破，转身华丽的明星小前侯彦丞和高中就了解联防的战术专家周月林，加上高年级的明星球员李奕、张博和欧正鑫，信科球队一路高歌猛进，取得小组出线资格进入八强。之后信科在八强碰到了老对手数科，侯彦丞一记绝杀帮助李奕师兄打破了连续三年败给数科的魔咒，同时也宣告了数科时代的结束。</p><p><strong>四强比赛前，由于苏禾师兄有事回家，队长与校会沟通后将我放进了比赛名单中。</strong>我正是在这场球中收获了明月杯的第一分，一个抢到前场篮板后的二次投篮（听说你们内线很能跳）。地遥很强，尽管我们已经全力以赴，但还是难以抵挡地遥的外线双枪，最终大比分输掉比赛，无缘邱季端。</p><p>三四名决赛的对手化学拥有实力强劲的新人王全，还在淘汰赛中战胜了在小组赛中战胜信科的环境，但信科的实力到底还是更胜一筹，经过加时赛的苦战，<strong>信科最终取得比赛胜利，拿下季军。</strong></p><p>关于14年的图片资料大多没有保存下来。。。惨。</p><h3 id="一句废话">一句废话</h3><p>客观地说，<strong>信科2014级可以称得上是信科的黄金一代。</strong></p><h2 id="x01.-2015">0x01. 2015</h2><h3 id="明月杯流水账-1">明月杯流水账</h3><h4 id="概况">概况</h4><p>第二年明月杯，李奕师兄毕业；15级新生唐聪、王梓晗等加入。<strong>此时我已经转入数学科学学院学习，但由于各种因素的影响，我最终还是选择在信科球队打球。</strong></p><p><strong>这是信科创造历史最佳战绩的一年，信科在欧哥和博哥两位大哥的带领下杀入了邱季端，这也是信科首次进入邱季端。</strong></p><h4 id="小组赛">小组赛</h4><p><strong>小组赛除了惜败给哲社外没有太大的波折。</strong></p><p>首场面对心理学院（现为心理学部），对方显然难以应付欧哥和侯彦丞的疯狂进攻，两人最后分别拿下了13分和8分的数据，信科也以29:9胜出。</p><table><tr><td><img src="/img/blog-graph/basketball-2015myb-xinli3.jpg" width="600" alt="小组赛对阵心理：赛前"></td><td><img src="/img/blog-graph/basketball-2015myb-xinli1.jpg" width="600" alt="小组赛对阵心理：防守（唐聪&欧哥）"></td><td><img src="/img/blog-graph/basketball-2015myb-xinli2.jpg" width="600" alt="小组赛对阵心理：暂停（教练赵晓睿）"></td></tr></table><p>信科遭遇的第一场失利是小组赛面对拥有mvp陈宏礼的哲社球队。由于中锋郑培凯因身体原因无法，故球队在比赛前一天晚上开了很久的会讨论如何防守陈宏礼（Orz），最后决定由我和侯彦丞采用夹击的战术来应对陈的突破。事实证明我们的策略确实生效了，陈宏礼全场仅得到9分（陈宏礼明月杯目前为止场均得分为19.8）。但我们似乎<strong>太过重视陈宏礼，导致对于其他人的防守不够严密，得分机会过多。</strong>其中，对方球员付天睿拿下了全场最高分24分，在最后几分钟的关键争夺中更是命中关键投篮，杀死比赛。最终信科以44:48失利，同时也宣告哲社预定小组第一。值得一提的是，张博和欧正鑫分别成为了信科本场的得分王（14分）和篮板王（12板），侯彦丞本场发挥不佳，24次出手仅命中2球，效率也为全队最低的-16（笑尿）。我虽然在本场中拿到了8分10板和全队最高的效率值14，但仍然存在一些问题，集中体现在不适应中锋站位，补防速度慢。赛后分析中，化院的沈芸稼师兄明确指出：“最后一球肯定是中锋的锅”，在观看录像后，也确实能够看出是我补防不及时，导致了最后时刻付天睿的进球，直接导致了比赛的失利。在比赛的最后时刻，前队长张博在一次进攻扭伤了脚踝，比赛激烈可见一斑。<strong>尽管失利总是令人失望的事，但这场失利对于我们而言并不是坏消息，甚至是将我们送进邱季端的一大助力。</strong></p><p><img src="/img/blog-graph/basketball-2015myb-zheshe1.jpg" width="600" alt="小组赛对阵哲社：暂停指导"></p><p>球队在后续的小组赛中并没有遇到任何阻力——47:19轻松击败天文，顺利晋级八强。</p><h4 id="八强">八强</h4><p>八强赛面对教育，对方的主力李尧沣面对信科的铁血防守难以延续小组赛的好状态，多次强打我方大前1号（没错就是我哈哈哈）未果，甚至吃到火锅，最终16投仅有3中，教育也只能吞下失利的苦果。而隔壁的八强赛，<strong>经管由于自己的轻敌，败给了艺传</strong>，将艺传送上了四强席位。至于另一半区，经过八进四的筛选，<strong>哲社与地遥在四强相遇</strong>。</p><table><tr><td><img src="/img/blog-graph/basketball-2015myb-jiaoyu1.jpg" width="600" alt="八强对阵教育：抢板"></td><td><img src="/img/blog-graph/basketball-2015myb-jiaoyu3.jpg" width="600" alt="八强对阵教育：暂停"></td></tr></table><h4 id="四强">四强</h4><p>四强赛中，艺传阵中战胜经管的最大功臣利啓权本场面对信科完全哑火，实力更高一筹的信科以23:11顺利拿下比赛，欧哥更是拿下11分7抢断的数据，统治攻防两端，成功带队进入邱季端。另一边的哲社……就比较惨了，被拥有双枪（朱帕尔陈星源）的地遥成功阻击。信科与地遥会师决赛。</p><table><tr><td><img src="/img/blog-graph/basketball-2015myb-yichuan1.jpg" height="600" alt="四强对阵艺传：突破"></td><td><img src="/img/blog-graph/basketball-2015myb-yichuan2.jpg" height="600" alt="四强对阵艺传：对抗"></td><td><img src="/img/blog-graph/basketball-2015myb-yichuan3.jpg" height="600" alt="四强对阵艺传：观众"></td><td><img src="/img/blog-graph/basketball-2015myb-yichuan4.jpg" height="600" alt="四强对阵艺传：合影"></td><td><img src="/img/blog-graph/basketball-2015myb-siqiang.jpeg" height="600" alt="四强对阵艺传：庆祝"></td></tr></table><h4 id="决赛">决赛</h4><p>赛前第一次体会了进邱季端的豪华服务：各种拍宣传照，（弱渣瑟瑟发抖Orz），队员们也对决赛充满信心。</p><p><img src="/img/blog-graph/basketball-2015myb-xuanchuanzhao.jpg" width="600" alt="决赛宣传照：信科（左侧）&校会（右侧）"></p><p>然而，校会宣布比赛日期时所有人都沉默了——<strong>比赛日期恰好与ACM EC-Final冲突。</strong>尽管与校会方面做了沟通，但日期仍然确定在了这一天，经过一番调整，最终的结果是<strong>首发中锋郑培凯无法参赛</strong>，同时我也没能去参加EC-Final。</p><p>比赛当天，又突发变故。首发大前（我Orz）在下午发烧。以缺少主力的阵容面对卫冕冠军地遥球队，信科球队并没有放弃，并在上半场一直保持领先。但在下半场快节奏的攻防转换中没有顶住对方的反扑，最后时刻的追分又有些慌乱，最终37:41不敌地遥。</p><p>本场比赛对我而言意义非凡。第一次在发烧的情况下打比赛，直到上场时仍然手掌冰凉，甚至手指在碰球时会感到轻微的疼痛。这也直接导致了在开场跳球时弹速不够快甚至没有跳过对方的李震（从图上看来高度是足够的，但因弹速不够，所以触球晚……md 生涯耻辱）。</p><p><img src="/img/blog-graph/basketball-2015myb-js4.jpg" width="600" alt="邱季端vs地遥：跳球"></p><p>虽然我没有跳赢，但我方后卫积极拼抢，拿到了第一攻的球权。虽然对方外线球员实力强悍，但内线非常羸弱，这使得我们可以通过冲抢前场篮板来获取更多进攻机会。经过侯彦丞、王伟程的一轮刷板-打铁，我抢到了前场篮板，随后投中了本场第一粒进球。说到这里我就不得不吹一波……这粒进球的难度还是很高的，从下图可以看出，我在投篮时上半身是正对篮筐，而仔细看脚和裤腿的遮挡关系就可以发现，下半身的方向其实和上半身是反着的（是不是做一个商空间就可以得到一条mobius band哈哈哈）。</p><p><img src="/img/blog-graph/basketball-2015myb-js1.jpg" width="600" alt="邱季端vs地遥：本场第一个进球"></p><p>前两节的大部分时间信科都保持了领先，对方的明星球员朱帕尔在高压防守之下表现不佳，屡次出手不中。信科则依靠强大的内线频频冲抢进攻篮板（尽管主力中锋缺席，但在信科弹跳比较好的中锋以及身高较高的外线面前，地遥羸弱的内线仍然难以阻挡）。经过两节的战斗，信科以16：14领先进入下半场。</p><p><img src="/img/blog-graph/basketball-2015myb-js2.jpg" width="600" alt="邱季端vs地遥：侯彦丞罚球"></p><p>到了下半场，地遥内线薄弱造成的犯规压力渐渐显露了出来，包括绝对核心陈星源在内的多名主力球员都背上了3次甚至4次的犯规，但由于命中率等各种原因，双方的比分并没有拉开，甚至地遥在陈星源命中三分之后成功以21:18取得了领先，并继续将比分优势扩大到4分。此时信科球员出现了体力问题，于是将替补球员卢浩然换上了场。<del>随后比赛就进入了转折<code>_(:з」∠)_</code></del> 也许是连续几波运动战没有得分，比分的差距被拉大，使得信科的球员比较着急：核心欧正鑫的出手有些仓促，卢浩然也在短时间内连续出现3次犯规，于是分差被进一步拉大，达到7分。最终信科以14:31落后进入第四节。（附一张拔萝卜式抢板的照片，可看出地遥羸弱的内线）</p><p><img src="/img/blog-graph/basketball-2015myb-jslb.jpg" width="600" alt="邱季端vs地遥：拔萝卜"></p><p>进入第四节，由于地遥的主力朱帕尔因犯规过多被教练换下，因而攻防能力有所下降。刚开场侯彦丞就迅速造成犯规并两罚一中，对方中锋李震拿到后场篮板后立刻被我抢断，经过一轮刷板后我命中本场第二球，将比分追至27:31。但良好的追分态势并没有持续太久。仅仅两分钟后，王伟程就在一次抢球中被吹犯规，并因满犯被罚下。信科并没有立刻因为主力的罚下而受到影响：侯彦丞造成李震犯规，使得其五犯下场。随后在地遥发起的一次快攻中，我直接将陈星源的上篮大帽扇飞（下图中的血帽陈星源，看着很刺激）并继续拿下一次抢断，接着信科在欧哥和贾鑫接连得分后，将比分扳至32:33。接下来又是几分钟的拉锯战，期间裁判将我对陈星源的一个盖帽吹为了犯规（我认为是好帽，不过也不能仅因此过多抱怨裁判），欧哥也因所剩时间不多，心态产生了波动，数次运动战都在我还没有落位时就仓促出手打铁，浪费了较多机会。比赛时间所剩无几，信科以37:39落后，此时对方球员陈小强命中了一粒两分球，形式也因此十分危急。在最后时刻的争夺中，可能是由于体力原因，数次出手机会均没有命中，侯彦丞由于抽筋，罚球也未能命中。最终信科以37:41不敌地遥，无缘冠军。</p><p><img src="/img/blog-graph/basketball-2015myb-jsgm.jpg" width="600" alt="邱季端vs地遥：血帽陈星源"></p><p>对方球员陈星源全场得到28分，展现了其强大的进攻能力，身背4次犯规仍能一直打到最后时刻也体现了对犯规的良好控制，尤其是令我印象颇为深刻的一次切球，在欧哥上篮时干净利落地将欧哥的球切掉，成功阻挡了信科的反扑，这种冷静确实是我们中的许多人所缺乏的。赛后的聚餐我由于身体原因没有参加，不知道博哥是不是又喝哭了哈哈哈。（附一张赛后合影）</p><p><img src="/img/blog-graph/basketball-2015myb-js3.jpeg" width="600" alt="邱季端vs地遥：赛后合影"></p><h3 id="几句废话">几句废话</h3><h4 id="谈数科一">谈数科（一）</h4><p>没有选择加入数科球队的原因是很复杂的，其中比较主要的是两条：</p><ol type="1"><li>和数科球队的同学，师兄都不太熟悉，但和信科这边的人已经非常熟悉；</li><li>在与数科的友谊赛中对于数科12级某师兄非常厌恶。</li></ol><p>当然其中也有信科极力挽留并且信科球队实力很强，有机会冲击更好成绩等很多因素。总之这件事情并不是巧合，现在想起来也并没有后悔，只是觉得“道不同，不相与谋”吧。<strong>数科球队的团队、氛围、文化，本身就不适合我，我又怎么可能加入数科球队呢？</strong>前些日子在与谢老师、魏老师谈话时没有详细地解释这些原因，只谈了最关键的两点，并不是不敢说我对数科球队的看法，也不是不好意思和老师谈，只是觉得没必要。<strong>学生的事情停留在学生这里就好，何必惊动老师</strong>。我不大聪明，不像一些人懂得“我不好直接和你说，我就请老师给你打电话，找你谈话，还可以把事情推给老师”。同样在数科，我怎么没有学到这些聪明的技巧呢( ‘▿’ ) <strong>很显然，在同一所大学，每个人学到的也是不一样的东西（</strong></p><p>顺带一提，在决赛前，数科某球员曾经帮助过我们训练。然而两年后的决赛，正是在他的煽动下，数科使出了盘外招将我禁赛。兄弟情谊？不存在的。其人还在双方球队代表谈判时装模作样抹了几把眼泪，之后借故离场，也许出门后就再也忍不住露出得意的微笑？或许这就是“兄弟”<sub>（此处特意用了此人最喜欢的波浪线</sub>~~）</p><h4 id="谈校会">谈校会</h4><p>对于我们而言，决赛争议颇大的一点是<strong>比赛时间的确定</strong>。事实上，不管是由于什么样的原因，信科在校学生会从来没有得到过公正的待遇（当然，只是据说）。 明月杯决赛的比赛时间是很充裕的（可选取范围的很广），信科方面关于比赛时间也与校会做过沟通。这里我不做太阴暗的猜测，但此事体现出的就是：<strong>信科在校会处没有话语权</strong>。这其中的原因可能有信科学生会的乌烟瘴气（非常乱&amp;非常烂&amp;只代表个人观点），也也可能有信科体育部的原因。但是，<strong>校会这方面的问题是一直存在的</strong>。</p><blockquote><p>记得有一场面对某大院的比赛，信科要求改时间，校会方面要求信科与对方沟通（翻译一下：对方是大院得罪不起，你们自己搞定）；另一场比赛，信科对阵某小院，对方要求改时间，对方球队在校会的要求下来找信科球队沟通（翻译一下：你们小院，校会还没有为了你们得罪信科的必要，你们自己搞定）；可还有一场比赛，是某小院对阵某大院，据说并没有经过太多流程，比赛时间就顺利调整了（翻译一下：大院就是可以为所欲为）。这便是校会一贯的办事风格。</p></blockquote><p>回到这次比赛，作为主办方，我个人认为校会有必要保障双方的权益，尽量选在双方都同意的时间。本身比赛就在周末，双方队员也很容易就能错开时间。事实上，对于信科而言，唯一不合适的时间就是12.12那一周，如果把比赛时间提前一周或推后一周，相信对方也不会因此受到很大的影响。然而，校会可能不会考虑这么多。</p><h2 id="x02.-2016">0x02. 2016</h2><h3 id="明月杯流水账-2">明月杯流水账</h3><h4 id="概况-1">概况</h4><p>12级的师兄们在这一年毕业了——博哥&amp;凯哥 OUT。另一方面，欧哥在家乡实习，也不能回学校参赛，于是信科缺少了去年的绝对核心。在实力下降的情况下，<strong>信科男篮在信科2014级的带领下小组赛保持全胜，出线后不敌数科止步八强。</strong></p><h4 id="稍微详细的版本">稍微详细的版本</h4><p>小组赛首场面对生科（大家都说其实跳球就暗示了比赛结果），信科以28：12顺利拿下首胜。</p><table><tr><td><img src="/img/blog-graph/basketball-2016myb-shengketq.jpg" width="600" alt="小组赛vs生科：跳球"></td><td><img src="/img/blog-graph/basketball-2016myb-shengkefq.jpg" width="600" alt="小组赛vs生科：罚球"></td><td><img src="/img/blog-graph/basketball-2016myb-shengkews.jpg" width="600" alt="小组赛vs生科：握手"></td><td><img src="/img/blog-graph/basketball-2016myb-shengkehy.jpg" width="600" alt="小组赛vs生科：合影"></td></tr></table><p>第二场小组赛对阵实力一般的政管，本以为能够前三节搞定对手第四节下场休息，但比赛一直到了第四节才分出胜负（17:7）。于是，很惨，又打满了全场Orz。。赛前还尝试了一次空接扣篮，<del>但是很遗憾扣飞了</del>.</p><table><tr><td><img src="/img/blog-graph/basketball-2016myb-zhengguankl.jpg" width="600" alt="小组赛vs政管：训练时尝试空接扣篮"></td><td><img src="/img/blog-graph/basketball-2016myb-zhengguantq.jpg" width="600" alt="小组赛vs政管：跳球"></td><td><img src="/img/blog-graph/basketball-2016myb-zhengguantupo.jpg" width="600" alt="小组赛vs政管：突破"></td><td><img src="/img/blog-graph/basketball-2016myb-zhengguankg1.jpg" width="600" alt="小组赛vs政管：快攻1"></td><td><img src="/img/blog-graph/basketball-2016myb-zhengguankg2.jpg" width="600" alt="小组赛vs政管：快攻2"></td></tr></table><p>第三场小组赛对阵教育，本场并没有太大压力，信科以29：15顺利拿下比赛，取得三连胜。至此，信科取得小组出线资格，只差和外文争夺小组第一的位置。（随手附一张抢篮板卡位的照片以及赛后全队的合影）</p><table><tr><td><img src="/img/blog-graph/basketball-2016myb-jiaoyukw.jpg" width="600" alt="小组赛vs教育：卡位"></td><td><img src="/img/blog-graph/basketball-2016myb-jiaoyuhy.jpg" width="600" alt="小组赛vs教育：合影"></td></tr></table><p>最后一场小组赛面对的是拥有在前三场场均20+10的新星庄子晨以及技术精湛的后卫卢明江的外文。比赛颇有悬念，但信科还是全场保持领先，并成功以32:24拿下比赛。值得一提的是，我本场手感不错，甚至命中了一记三分hhhh，但在比赛最后时刻，王伟程靠着罚球刷分成功取得了13分，超越了我（11分）…</p><p><img src="/img/blog-graph/basketball-2016myb-waiwen3f.jpg" width="500" alt="小组赛vs外文：三分"></p><p>淘汰赛面对老冤家数科，开场王梓晗命中2分后，数科球员蔡伯文立刻用一记三分还以颜色，紧接着又顶着防守命中一颗神奇的2分。至此，信科气势已经被全面压倒，赛场也进入了数科的节奏。在追分的过程中，信科的控球者王伟程和侯彦丞显得有些慌乱，也有些着急，最终信科13:21不敌数科，结束了本届明月杯之旅。</p><p><img src="/img/blog-graph/basketball-2016myb-shuke.jpg" width="500" alt="淘汰赛vs数科"></p><h3 id="几句废话-1">几句废话</h3><h4 id="谈数科二">谈数科（二）</h4><p>整个数科球队我认识的人中，我能称得上欣赏，也算得上佩服的人，就是頔哥。此处不谈頔哥刻苦练球；也不谈頔哥在明月杯的压力之下仍然考上人大统计研究生。这里只谈和我相关的事情。</p><p>在14年败给地遥之后的聚餐中，李奕师兄对（那时）想转系的席伟说“信科转到数科的不少，也有不少打球厉害的转过去了，但他们碰到我们的时候不会上场”。受此言论影响，在15年我转入数科，但仍然留在信科打球时，我也说过类似于“如果数科碰到信科，我就不上场”的话。但幸运的是，两队在15年没有碰面，我们也成功创造了历史最佳成绩。但在16年的八进四比赛上，两队碰面了。想起之前的承诺，我当然会说我不上场——信科各位球员的劝说，甚至是欧哥的长篇大论都没有让我动摇。就这样到了比赛前的两天。</p><p>让我改变想法的是頔哥。队长王伟程（应该是他，但不敢确定）给我看了与頔哥的聊天记录，依稀记得頔哥说的两句话：“石睿平和我说lzc不打，我就和他说让他打”，还有“<strong>兄弟之间，该怼就要怼</strong>”。正是頔哥的这番言论让我想清楚，比赛代表的是球队，院系的事情，不应该过多带入到比赛中来。虽然最终在场上也受了一些心态上的影响，也可能在一定程度上导致了失利，但这似乎并没有什么可说的。</p><p>然而，真正奇怪的是，石睿平直到赛前都没有来找我“让我打”，数科也没有一个认识我的球员来找我说明这件事情。我很好奇，难道是頔哥撒谎了？更为可悲的是，一年后，这件事情竟被数科的球员摆在了谈判桌上，将頔哥的意见扯到了自己头上。数科15级队长（不点名）表示：“去年也是淘汰赛，按理来说和总决赛同等重要，但我们让lzc上场了。”言下之意便是“去年是给你们面子才让lzc上场的”。我不知道，实在是不知道，他是抱着怎样的心态说出这句话的。另一边，某人一把鼻涕一把泪地说“我和信科有感情，我和欧哥有感情”，我也很难理解，这到底是怎样一个人，才能如此惺惺作态。</p><h4 id="谈信科">谈信科</h4><p>这一年的比赛，大多数都有一个共同的特点：<strong>上半场砍分，第三节崩盘</strong>。这种现象的成因我至今都搞不明白。</p><p>如果说是因为信科首发阵容强大，第一节能凭借首发的得分能力将分差拉开，那还算正常。但信科首发偏偏都很<strong>慢热</strong>。首场面对生科是慢热最好的体现。两队实力差距非常大，但在刚开局时，信科手感冰凉，前几次出手均未命中；反观生科，进入状态迅速，韩嘉伟和于翔宇里突外投，很快就拉开了4分的分差。经历了17年的比赛后，我大致明白了，慢热是由于训练强度不够大的原因。而第三节崩盘最好的体现是与政管的比赛，整场手感冰凉，第三节还险些被追平比分。其原因我至今也没有想通Orz。</p><p>信科的另一个严重的问题是<strong>缺乏气势</strong>。这一点在与数科的比赛得到了很好的体现。虽然信科命中了第一粒进球，但大哥立刻命中三分给出回应，接着又是一颗非常提士气的两分，信科顿时气势全无。。。气势是球场上很重要的一环，只是那时我们不够关注这件事。欧哥也遗憾地告别了明月杯。</p><h2 id="x03.-2017">0x03. 2017</h2><h3 id="明月杯流水账-3">明月杯流水账</h3><h4 id="概况-2">概况</h4><p>信科在这一年迎来了强大的17级：李家和、谢清宇、张蔚坪、张书楷等人的加入让球队实力有了很大提升。小组赛势如破竹，连克外文、历史、和哲社，以小组头名身份闯入八强。在淘汰赛中接连战胜地理学部和卫冕冠军经管，三年内第二次进入邱季端。</p><p>在决赛前的几天，数科使出了一些见不得光的盘外手段，将我禁赛。缺少首发内线的信科以37：44不敌数科，再次获得亚军。想必看球的各位也懂得，冠军应该是谁（手动微笑）。</p><h4 id="邱季端门票">邱季端门票</h4><blockquote><p>不太客气地讲，这一年的明月杯就是个笑话。</p></blockquote><p>首先从揭幕战数科vs物理谈起。这是一场精彩的比赛，双方的攻防都很不错，然而一些问题严重影响了这场比赛。比赛进行到最后一分钟时，物理领先6分，围观者大多觉得大局已定。这时为了追分，数科使出了自己的看家本领全场紧逼，物理对此显然准备不足，被对方多次成功防守，分差越来越小。然而，由于物理在重压之下仍然命中了一些投篮，数科始终不能扳回比分。很快，比赛时间就所剩无几，物理仍然领先3分。这时数科球员投篮造成物理犯规，哨响后，数科的9号随意地上了一颗空篮，命中。<strong>这显然是一颗不计分的球</strong>，然而，可能是因为校会的记分员不懂规则（并不敢想象更奇怪的原因），将这一球判为了有效进球。于是在数科两罚全中后，数科成功“反超”，场下观众一脸懵逼。此时比赛时间只剩几秒，物理未能继续得分，数科成功罚球“绝杀”。<em>文字直播地址：http://m.lanqiu.woaoo.net/schedule/59349.html</em></p><p>赛后，物理的同学显然对比赛结果很不服气，于是有同学在蛋蛋网上发帖，引起了非常激烈的讨论。数科石某人在其中摆出的态度再次刷新了我的认知，真是太6了Orz。有没有问题，您自己心里没数么？您有录像也可以自证清白呀，谁不知道数科的比赛每场自己都会录像。墙都不服，就服您。（此处有石某人的精选评论截图（手动微笑））<em>蛋蛋网微信推送地址：https://mp.weixin.qq.com/s/2RsB6fZ_iB8LiLsejD9TTQ</em></p><p><img src="/img/blog-graph/srp666.jpg" width="600" alt="人在zuo 天在看"></p><p>本以为校会能够认识到自己的错误，将比赛办好。但万万没想到，这只是个开始。</p><p>小组赛首场面对老对手外文。外文在17年也迎来了补强：一个又高又壮但技术一般的中锋，这无论对他们的内线防守还是篮板争抢，都是一个明显的提升，所以外界普遍认为这将是一场恶战。</p><p>但首节的战斗却出乎了所有人的意料：信科以14:0碾压了外文。这并不是因为外文首发太弱，而是外文的核心后卫卢明江并没有首发出场（原因不明），导致其羸弱的外线被抢断到心态爆炸，这也直接导致了本场外文的失利。（随手附一张李家和突破照片，此时卢明江（7号）已经上场）</p><p><img src="/img/blog-graph/basketball-2017myb-waiwendc.jpg" width="600" alt="小组赛vs外文：李家和突破"></p><p>在卢明江上场后，外文在卢与庄的配合下展开了反击。但由于外文在第一节挖的坑太大，信科几乎整场都保持了两位数的领先，最终36:25拿下首胜。李家和本场拿下22分5篮板5盖帽的豪华数据，实力carry全队。（附赛后合影）</p><p><img src="/img/blog-graph/basketball-2017myb-waiwenhy.jpg" width="600" alt="小组赛vs外文：合影"></p><p>第二场面对实力较弱的历史，全队12人均有得分进账，谢清宇小同学非常兴奋，拿下全场最高21分，信科以58:12轻松拿下第二场胜利。（附赛后合影）</p><p><img src="/img/blog-graph/basketball-2017myb-lishihy.jpg" width="600" alt="小组赛vs历史：合影"></p><p>两战全胜的信科在第三场面对哲社，与哲社争夺小组头名。信科本场又犯了慢热的老毛病，第二节刚开始不久，就落后了6分之多，但在首发球员的努力下，加强了对于对方球星陈宏礼的防守，以10:15进入下半场。（随手贴一张上篮）</p><p><img src="/img/blog-graph/basketball-2017myb-zheshetl1.jpg" width="600" alt="小组赛vs哲社：上篮"></p><p>进入下半场，信科渐渐找回了状态，陈宏礼渐渐显得独木难支，双方展开了拉锯战，以18：21进入第四节。（再随手贴一张投篮，感谢侯彦丞dalao妙传）</p><p><img src="/img/blog-graph/basketball-2017myb-zheshetl2.jpg" width="600" alt="小组赛vs哲社：投篮"></p><p>进入第四节，陈宏礼也出现了体力问题，比赛很快就彻底进入了信科的节奏。哲社在最后相当长的一段时间内，都未能得分，最终信科以29:25战胜哲社。（附赛后合影）</p><p><img src="/img/blog-graph/basketball-2017myb-zheshehy.jpg" width="600" alt="小组赛vs哲社：合影"></p><p>值得一提的是，信科在终场前两秒执行两次罚球，全部命中后，哲社落后4分。虽然比赛结果已经尘埃落定，但是抱着拼到最后一刻的心态，陈宏礼在发球后直接在后场出手，不中。<strong>此时比赛显然已经可以判定为结束，然而哲社又获得了一次两秒的最后一攻的机会</strong>，陈宏礼再次超远三分出手不中，比赛才正式结束。对此感到不满的信科教练任挪走向技术台理论，竟然被体育部部长张浩东言语辱骂。原来校会这个样子，是上梁不正下梁歪啊。</p><p>出线后的八强赛中，信科面对的是已经沦为鱼腩球队的老对手地遥。带着14,15败给地遥的旧恨，信科没有给地理任何机会，以41:14干脆利落地拿下比赛。值得一提的是，在最后一节的一次快攻机会中，我过掉了对方的防守球员，然后上空篮不进==囧（全场嘘声Orz），信科众将也被我的这一顿操作惊得目瞪口呆。不过在下一波进攻中，我面对对方的防守命中了一记干拔三分，hhh，还是这种感觉比较爽。赛后，当年地遥的小弟-如今地理的大哥：李震同志拒绝与信科握手，宽广的胸襟显露无疑，真是德艺双馨的好典范。（附赛后合影）</p><p><img src="/img/blog-graph/basketball-2017myb-diyaohy.jpg" width="600" alt="八强vs地遥： 合影"></p><p>四强赛中，面对的是实力仍然强悍的经管。上半场信科占据主动，以14:7领先。下半场经管开始发力，信科的得分势头也开始下降，体力也渐渐出现了问题。第三节马上就要结束时，信科仅有1分入账，领先优势也只剩2分。但在最后一攻中，我接球命中了一粒压哨三分，将分差又拉大到了5分，双方以18:13进入第四节。第四节信科的进攻更加惨不忍睹，正常时间内只有我在篮下的一次打板得手。但经管也没有得到太多机会（<strong>得防守者得天下？</strong>），没能直接扳平或反超比分，最终信科21:19战胜经管，三年内第二次进入邱季端的舞台。</p><p><img src="/img/blog-graph/basketball-2017myb-jingguanfq.jpg" width="600" alt="四强vs经管：李家和罚球"></p><p>谈起这次比赛，其实发挥不佳有一个很重要的因素，就是赛前对于对手战术的错误估计。赛前我们研究了经管vs文新的八强比赛录像，发现经管对于文新的闫芳齐采取了一盯四联的防守策略，成功限制了闫芳齐。于是我们推测，经管可能会在比赛中对于李家和采取同样的防守策略。接着，在赛前的训练中，特意设计了两套新的战术来应对一盯四联的防守，名字分别叫“库里”和“五道口”（笑尿）。然而。。经管在比赛中几乎全场都没有使用一盯四联的防守策略，这也一定程度上导致了进攻端的低迷。但最终还是依靠着强硬的防守赢得了比赛的胜利。</p><h4 id="再入邱季端">再入邱季端</h4><p>比赛之前当然是拍了一发宣传照。（只贴了自己的照片和合影，<del>有点丑 将就看</del>）</p><p><img src="/img/blog-graph/basketball-2017myb-xuanchuanzhao.jpg" width="600" alt="2017邱季端：宣传照"></p><p>很遗憾没能再次触摸邱季端的地板，事情的始末将在下文详细交待。最终的结果是唐聪替代我出场，缺少主力的信科仍然与对方战斗到最后一刻才分出胜负，最终37:44不敌数科。李家和发挥出色，拿下了28分15板的怪兽级数据，这也是给自己最好的生日礼物。（随手附两张图）</p><table><tr><td><img src="/img/blog-graph/basketball-2017myb-jsqiuyi1.jpg" width="600" alt="2017-邱季端赛后-1"></td><td><img src="/img/blog-graph/basketball-2017myb-jsqiuyi2.jpg" width="600" alt="2017-邱季端赛后-2"></td></tr></table><h3 id="明月杯史上最大笑话">明月杯史上最大笑话</h3><center><font color="red"><strong>靠改分赢球的队伍，靠禁赛赢球的队伍，配不上冠军奖杯。</strong></font></center><p>赛前的过程我也懒得详细再写一遍，直接掏出当时发的说说好了——事情的经过如下：</p><ol type="1"><li>信科队长在报名前未开具双方签字的证明;</li><li>按照规则需要开具该证明，但校会并未审查出;</li><li>数科在比赛前四天（划重点 马上就要开赛的时候）对参赛资格提出异议<strong>并怂恿老师给我打电话</strong>;</li><li>校会提出可以补开证明，但数科不同意签字（数科男篮 一支稳健的队伍 此条五毛）。</li></ol><p><strong>怎么说呢，球场上的人得到大家的尊重，未必是因为荣誉。</strong>想起去年赛前我提出遇到数科可以不打，頔哥直接说“让他打，兄弟该怼就要怼”的事情，如今竟是以“我们去年时候就可以不让你上场”的方式被数科提出。事实上，我毫不怀疑如果当年您们坐在頔哥的位置上，肯定不会让我上场的~（此处又用了某人最爱的波浪线）哈哈，可能有些东西是无法传承的吧。借用师大著名球星的话：“篮球本来是很纯粹的事情，但很可惜不是每个人都这样想。”</p><p>同一件事情，君子有君子的解决办法，小人也会有小人的解决办法。既然对面是小人，那我不得不防：<strong>谈判<font color="red">全程录音</font></strong>。</p><p>谈判时，数科队长表示“很尴尬，我始终是不愿意面对琛哥的”。可我想说的是，你既然已经做出了这个决定，我们也就不可能再是什么“兄弟”了，进而想到石某人虚伪的丑陋嘴脸，我更是没来由的一阵干呕：和欧哥有感情，您配么？<strong>关于球赛，类似的事情绝不是没有发生过。但是参与的人不同，结果自然也不同。</strong>据陈宏礼回忆，之前BBA的决赛，他所在的队伍与欧哥所在的队伍相遇，因为他的个人原因请求变更比赛时间，而欧哥方面<strong>同意</strong>了变更的请求。石某人既然与欧哥如此有感情，那么您的奸诈是从哪里学来的？欧哥和您可不是一路人。不过您赢了，一把鼻涕一把泪的表演，着实恶心了我一回。</p><p>接下来数科王队长的一番话更加令我无言以对了。也就是我多次提到的“去年我们就可以禁赛你，但我们没有，是因为我们有情谊”。哇，厉害厉害。正如上文所说，我从未想过这件事情能以这种刁钻的角度提出来。不知道頔哥听了这番话会作何感想，当时没有禁赛的事情，请问和您有半毛钱关系么（手动滑稽）？一路躺赢的感觉相比也很爽吧~事实上，我也丝毫不怀疑，如果当年是您处于頔哥的位置，会毫不犹豫地提出禁赛的事情。没啥特别的原因，就是觉得您比较厉害呀。</p><p><strong>事实证明了，录音非常有必要。数科男篮的无耻早已超出了我的理解范畴</strong>。谈判的最后一点时间，梓晗再也不能忍受对方的无耻，直接发飙。然而数科的石某人，直接将禁赛的原因归结到了梓晗发飙这件事情上。？？？难以想象。頔哥知道禁赛的事后表示“不知道是谁提出的禁赛，真傻逼”——頔哥不知道吧，你说的就是你的下一任队长呀。对于石某人，我的言论也就到此为止。人在zuo，天在看，祝石某人考研顺利~下半辈子都活在夺冠的美梦里（手动滑稽）。</p><blockquote><p>后来石某考研的确非常“顺利”，hhh，祝他在“跷跷板中的数学”相关研究中有所斩获哈！</p></blockquote><p>最后，我想谈谈关于老师的看法。<strong>首先需要说明，我并不对魏炜老师以及谢天老师抱有多大敌意，但落到这件事情上，我个人认为二位有拉偏架的嫌疑。</strong>最早是我与魏老师单独谈话时，魏老师已经免不了露出自己的倾向：“考虑最好的结果，数科战胜信科夺冠……”抱歉，我不觉得这是最好的结果。在我们几个还没有进入会议室时，魏老师就已经憋不住得意的笑容了，边笑边说“校会那边已经说了，五点了，他就是不能打”，但还是表示“不过再给你们一个机会，去找他们谈一谈，我作为老师不插手”。然而到了会议室以后，情况却不大相同：老师又扬了扬手机说“虽然我这里已经掌握了可以直接左右战局的信息，不过你们还是先谈一谈”。这句话表面上看着是给你们公平讨论的机会，实则提醒了数科的队员“你们已经是占优势的一方，能坐下来谈已经是给足他们面子了”。这也就注定不是一场“讲道理”的谈判。<strong>数科男篮的无耻、数科老师的倾向（我努力不把关于老师的言辞说得难听），加上校会的甩锅和信科团学的软弱，最终结果实际也在意料之中</strong>。总而言之，就这件事情而言，我不觉得魏老师、谢老师扮演了一个公平的裁决者。至于魏老师一直自我标榜的“护犊子”，护的大概也是“数科”，而不是我。<strong>如果这篇文章有幸被老师看到，恕我迟钝，没能在这件事情上体会到您对我的照顾</strong>。</p><h2 id="数科与信科">数科与信科</h2><h3 id="谈数科男篮为保荣誉不择手段的小人团伙">谈数科男篮：为保荣誉不择手段的小人团伙</h3><center><font color="red"> <strong>只针对17阵容，无关人员请勿对号入座。</strong> </font></center><p>前文提过我和数科球队“道不同，不相与谋”，<strong>长期以来，我对数科男篮一直谈不上喜欢</strong>——从12级的王晨笛到13级的郭强，再到14级的石睿平，都不是什么我喜欢的人物。<strong>但由于院系原因，加上数科也有一些相熟的同学，所以我对数科男篮这个团队还抱始终有一丝希望。甚至在17明月杯后仍觉得，数科男篮有一部分人是光明正大打球的人。</strong></p><p><strong>然而现实并不如我所想。</strong>这让我不禁想到了前几日数科吉队长对于我“庆幸留在信科男篮”做出的“我们也不是什么人都收”的精彩评论。在我决定是否加入数科球队的时候，好像数科还没你这个人吧<sub>不知道您有什么资格说这句话？这么急着说强调一下“我们”么</sub>惊讶于队长也会说出如此脑残的言论时，我也懒得多辩驳——因为我忽然想到，吉队长就是这么脑残呀：赛前的一节课后，吉队长对我说“你决赛得分你就死”。对没看错，就是死，可我想说，吉队长决赛场上得分死全家呀<sub>哎，结果就是这么巧，吉队长得分了！想到这里我不禁为吉队长大义灭亲的胆识和魄力鼓起了掌。转念一想，吉队长将来可是人民教师呀，我不禁又对祖国未来的教育事业充满了担忧，同时担心亲人的离世给吉队长带来过大的打击</sub>于是我便罢了手，没有与吉队长过多纠缠。</p><p>再联系到17年的比赛，第一场靠改分赢了物理，数科各位的辩驳不可谓不精彩：“我知道你没有证据，改分赢了也是赢了，你来咬我呀~”数科手里有录像，却不拿来自证清白。校会手里有录像，却不拿来还比赛一个公道。更厉害的是，数科男篮更是摆出了一副不要脸的泼皮姿态，石某人也搬出各种人名来颠倒黑白。那时我竟然还相信数科是清白的，错误只在记分员，真是可笑。后来的比赛中，在意识到信科很有可能碰到数科时，石某人急了。为什么急呢？因为怕呀——软蛋总是缺乏正面面对事情的勇气。于是在哲社vs信科以及经管vs信科的赛后，信科经历了所经历过的最恶毒的诅咒——什么“我在场边一遍遍祈祷……”，什么“一人得道鸡犬升天”，什么“对这个结果感到失望”。然而此等胡言乱语并不可能改变比赛结果，信科也顺利进入了决赛，心有不甘的石某人便精心策划了一手阴谋，最终摘得了这个笑话一般的冠军奖杯。赛后石某人竟然还大谈情谊：“我们的情谊是不变的”。这嘴脸与吉队长如出一辙，<strong>不愧是两届队长，连脸皮的厚度都如此相似。</strong></p><p>数科球队的各种趣事还有很多，如某自称杜兰特的软蛋赛前赛后挑衅等，此处都不再赘述。这些事情也只是说明，<strong>如今数科男篮整体的作风，不是个别几人能够形成的。在这个团队里，无耻会像病毒一样传播。因此，我很庆幸当年没有加入数科男篮</strong>，若没有这件事我恐怕也很难看清这些人的两幅面孔——当面还称兄道弟，转过身就在暗地里处处下绊。这里也不得不佩服吉队长的演技——事出之前还笑脸相迎，甚至求代码求作业，背后做起事情来却是毫不犹豫。二位队长的脸皮真乃铜墙铁壁，在下佩服~</p><p>最后，用两句话总结一下17的数科男篮，也算是对偶然看到的頔哥观点的回应：</p><ol type="1"><li>数科男篮够好么？连缺少主力的信科都不能轻松战胜，<strong>当然不够好</strong>；</li><li><strong>数科男篮有光明正大打球的人吗？抱歉我不觉得</strong>。</li></ol><h3 id="谈信科团学软弱的学生组织">谈信科团学：软弱的学生组织</h3><p>随手列几条，不过多评论信科内部事务，我也不想与信科团学有任何瓜葛。</p><ol type="1"><li>体育部部长不强硬，当然这是信科团学的一贯作风；</li><li>粉丝票优先给院会，剩余给球队，一定程度上导致了球队票源短缺；</li><li>老师也并不努力给学生争取权益，尤其是球队一事。</li></ol><h3 id="谈信科男篮不被幸运眷顾的无冕之王">谈信科男篮：不被幸运眷顾的无冕之王</h3><p>14-17四年明月杯，信科男篮四次进入八强，三次进入四强，两次问鼎邱季端。虽然两次都铩羽而归，但其实力不容置疑。两次邱季端，都在赛前生出了不同的变故，于是信科两次邱季端之旅都不是完整阵容。造化弄人，不是么？信科的两次邱季端之旅本身都有实力夺冠，但最后都只能感叹一番时运不济。<strong>OK，我便就在这里感叹一番时运不济吧~</strong></p><h2 id="后记">后记</h2><blockquote><p>2018：信科进入邱季端，负于数科，第三亚<br>2019：信科进入邱季端，负于物理，第四亚</p></blockquote><p>怎么说呢，18李家和带伤，19李家和彻底没出战（</p><p>…..</p><p>李家和还有一年机会，祝福他吧。</p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 运动 </tag>
            
            <tag> 篮球 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2016-2017学年春季学期志愿时长录入</title>
      <link href="/2017/11/17/2016-2017%E5%AD%A6%E5%B9%B4%E6%98%A5%E5%AD%A3%E5%AD%A6%E6%9C%9F%E5%BF%97%E6%84%BF%E6%97%B6%E9%95%BF%E5%BD%95%E5%85%A5/"/>
      <content type="html"><![CDATA[<h2 id="一点简单的说明">一点简单的说明</h2><h3 id="几句废话">几句废话</h3><p>抱歉给大家拖了这么久Orz. 之前也和认证部长沟通过几次, 认证可能确实因为人手不够等问题, 没有及时给各位录入时长.</p><p>认证由于人手不够, 只能给大家提供时长码, 大家自己在志愿北京录入时长码获取时长.</p><h3 id="时长码使用说明">时长码使用说明</h3><ul><li>登录<a href="www.bv2008.cn">志愿北京</a>;</li><li>在志愿北京-我的首页中, 点击自己的服务时间, 进入“我的时长”页面; <img src="http://olgwnj89q.bkt.clouddn.com/%E6%97%B6%E9%95%BF-1.png" alt="志愿北京-我的首页"></li><li>在新页面中点击“录入时长码”, 即可录入时长码. <img src="http://olgwnj89q.bkt.clouddn.com/%E6%97%B6%E9%95%BF-2.png" alt="时长码页面"></li></ul><h2 id="时长码查询">时长码查询</h2><script type="text/javascript">function search(){    var list = new Array("李萍", "谢万明昱", "王石安", "蒋雨含", "王雪琪", "杨东芳", "张巧凌", "陈心如", "冯晓科", "贺苑林", "宋研霏", "朱燕琪", "周敬天", "李奕璇", "边珍", "但晴", "贺巧", "李晓霞", "郑逸敏", "付月", "王子璇", "白月", "段婷波", "高珊", "何可人", "李金铭", "苏宁", "王松正", "文艺", "许琳旋", "周佳茜", "张恺琦", "李军逸", "孙漾", "王蔚桐", "杨航", "余跃", "曹梦宇", "查少琛", "陈林涛", "刘子辰", "马玉阁", "王伟初", "孙荣", "周泓宇")    var time = new Array(48, 48, 44, 42, 42, 42, 42, 32, 32, 42, 36, 36, 36, 34, 30, 30, 30, 30, 30, 30, 26, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 20, 18, 18, 18, 18, 18, 12, 12, 12, 12, 12, 10, 9, 3)    var code = new Array(104198280126, 104197959124, 104198444710, 104191633494, 104193443180, 104199997937, 104196008038, 104190659437, 104192963919, 104196143683, 104193955548, 104191780154, 104191422029, 104199202510, 104194994021, 104193868440, 104198971022, 104197237983, 104194009799, 104197768688, 104191560051, 104193005169, 104197725850, 104191360385, 104193523894, 104198523787, 104198383642, 104198262211, 104199021643, 104191333531, 104199998372, 104197447426, 104194687884, 104199153947, 104190342124, 104195364603, 104195467540, 104195030302, 104196284847, 104194794933, 104194622149, 104198082739, 104195705550, 104191401247, 104195020771)    var name = document.getElementById("input").value    var res = "查无此人！"    var ans = "没有查询到您的时长码QAQ"    for (id in list){        console.log(list[id], name)        if(list[id] == name)        {            res = list[id]+", 您的志愿时长为"+time[id]+"小时, 您的时长码已显示"            ans = code[id]        }    }    document.getElementById("output").value = ans    alert(res)}</script><center>请在输入框中输入您的姓名, 点击“查询”即可.</center><p>姓名: <input type="text" id="input" name="q" placeholder="请在这里输入您的姓名..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false"> <input type="button" value="查询" onclick="search()"> <br></p><p>时长码: <input type="text" id="output" name="q" placeholder="您的时长码会显示在这里..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false"></p>]]></content>
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 白鸽 </tag>
            
            <tag> 志愿 </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>泛函——有界集、完全有界集和紧集</title>
      <link href="/2017/10/25/%E6%B3%9B%E5%87%BD%E2%80%94%E2%80%94%E6%9C%89%E7%95%8C%E9%9B%86%E3%80%81%E5%AE%8C%E5%85%A8%E6%9C%89%E7%95%8C%E9%9B%86%E5%92%8C%E7%B4%A7%E9%9B%86/"/>
      <content type="html"><![CDATA[<h2 id="基础定义">基础定义</h2><p><strong>有界集</strong>: 设 <span class="math inline">\((\mathscr{X},\rho)\)</span> 为度量空间, <span class="math inline">\(A\subset\mathscr{X}\)</span>，如果 <span class="math inline">\(\exists M&lt;\infty\)</span>, s.t. <span class="math inline">\(\forall x,y\in A\)</span>, 总有 <span class="math inline">\(\rho(x,y)\leqslant M\)</span>, 则称 <span class="math inline">\(A\)</span> 为有界集.</p><p><strong>完全有界</strong>: 集合 <span class="math inline">\(M\)</span> 称为完全有界的, 如果 <span class="math inline">\(\forall\epsilon\)</span>, 存在 <span class="math inline">\(M\)</span> 的一个有穷 <span class="math inline">\(\epsilon\)</span> 网.</p><p><strong>紧集</strong>: 在拓扑空间 <span class="math inline">\(\mathscr{X}\)</span> 中, 集合 <span class="math inline">\(M\)</span> 称为紧集, 如果 <span class="math inline">\(\mathscr{X}\)</span> 中每个覆盖 <span class="math inline">\(M\)</span> 的开集族中都有有限个开集覆盖 <span class="math inline">\(M\)</span>.</p><h2 id="有界与完全有界">有界与完全有界</h2><div class="text" style=" text-align:center;"><strong>有界集与完全有界集本质上<font color="red">只差维数</font></strong>.</div><blockquote><p><strong>命题 1</strong> 在度量空间 <span class="math inline">\((\mathscr{X},\rho)\)</span> 中, 完全有界集的子集也是完全有界的.</p></blockquote><p><strong>证明</strong>: 　　设 <span class="math inline">\(M\)</span> 为 <span class="math inline">\(\mathscr{X}\)</span> 中的完全有界集, <span class="math inline">\(S\subset M\)</span>, 下证 <span class="math inline">\(S\)</span> 完全有界: 　　<span class="math inline">\(\forall\epsilon&gt;0\)</span>, 由 <span class="math inline">\(M\)</span> 的完全有界性可知, <span class="math inline">\(\exists N_0\in\mathbb{N}\)</span> 及 <span class="math inline">\(\{x_n\}_{n=1}^{N_0}\subset M\)</span>, s.t. <span class="math inline">\(S\subset M\subset\bigcup\limits_{N=1}^{N_0}B(x_n,\frac{\epsilon}{2})\)</span>. 　　令 <span class="math inline">\(I_s=\{i:B(x_i,\frac{\epsilon}{2})\cap S\neq\varnothing\}\)</span>, 显然 <span class="math inline">\(I_s\)</span> 为有限集. 进一步, 对 <span class="math inline">\(\forall i\in I_s\)</span>, 取 <span class="math inline">\(y_i\in S\cap B(x_i,\frac{\epsilon}{2})\)</span>, 易有 <span class="math inline">\(B(x_i,\frac{\epsilon}{2})\subset B(y_i,\epsilon)\)</span>. 　　由此及 <span class="math inline">\(I_s\)</span> 的定义可知 <span class="math inline">\(S\subset\bigcup\limits_{i\in I_s}B(x_i,\frac{\epsilon}{2})\subset\bigcup\limits_{i\in I_s}B(y_i,\epsilon)\)</span>, 即 <span class="math inline">\(S\)</span> 完全有界.</p><blockquote><p><strong>命题 2</strong> 在有限维 <span class="math inline">\(B^*\)</span> 空间中, 有界集 <span class="math inline">\(\Leftrightarrow\)</span> 完全有界集.</p></blockquote><p><strong>证明</strong>: 　　“<span class="math inline">\(\Leftarrow\)</span>” 是显然的, 以下证明 “<span class="math inline">\(\Rightarrow\)</span>”. 　　由于 <span class="math inline">\(\mathscr{X}\)</span> 为有限维空间, <span class="math inline">\(M\)</span> 有界, 以及<span title="B*空间是有限维的当且仅当其任意有界集列紧."> 课本P37, Col1.4.30 </span>可知 <span class="math inline">\(M\)</span> 列紧. 再由 <span title="Hausdorff: 度量空间中的列紧集一定是完全有界集.">Th1.3.7</span> 知 <span class="math inline">\(M\)</span> 完全有界. 　　综上, 有界 <span class="math inline">\(\Leftrightarrow\)</span> 完全有界.</p><h2 id="紧集与完全有界闭集">紧集与完全有界闭集</h2><div class="text" style=" text-align:center;"><strong>紧集与完全有界闭集<font color="red">只差完备性</font></strong>.</div><blockquote><p><strong>命题 3</strong> 在 <span class="math inline">\(B^*\)</span> 空间中, 紧集一定是完全有界闭集, 反之不一定成立.</p></blockquote><p><strong>证明</strong>: 　　由<span title="度量空间中的紧集等价于自列紧集.">Th1.3.11</span>, 在 <span class="math inline">\(B^*\)</span> 空间中, <span class="math inline">\(A\)</span> 为紧集当且仅当 <span class="math inline">\(A\)</span> 是自列紧集. 从而 <span class="math inline">\(A\)</span> 是闭的, 再由 <span title="Hausdorff: 度量空间中的列紧集一定是完全有界集.">Th1.3.7</span> 知 <span class="math inline">\(A\)</span> 完全有界.</p><p>　　即: 紧 <span class="math inline">\(\Rightarrow\)</span> 完全有界 <span class="math inline">\(+\)</span> 闭 在 <span class="math inline">\(B^*\)</span> 空间中成立.</p><p>　　<strong>但反之不成立, <font color="red">反例</font>如下:</strong> 　　<span class="math display">\[x_n(t)=\begin{cases}　　1, &amp;t\in [a,\frac{a+b}{2}-\frac{1}{n});\\　　n(\frac{a+b}{2}-x), &amp;t\in [\frac{a+b}{2}-\frac{1}{n},\frac{a+b}{2}+\frac{1}{n});\\　　-1, &amp;t\in [\frac{a+b}{2}+\frac{1}{n},b].　　\end{cases}\]</span> 　　<span class="math display">\[x_n(t)=\begin{cases}　　1, &amp;t\in [a,\frac{a+b}{2});\\　　0, &amp;t=\frac{a+b}{2};\\　　-1, &amp;t\in (\frac{a+b}{2},b].　　\end{cases}\]</span> 　　记 <span class="math inline">\(\mathscr{X}=(C[a,b],\Vert\cdot\Vert_{L^1})\)</span>, 并记 <span class="math inline">\(\{x_n\}_{n\in\mathbb{N}}\subset C[a,b]\)</span>, 如下构造: 　　易证 <span class="math inline">\(\{x_n\}_{n\in\mathbb{N}}\)</span> 依 <span class="math inline">\(\Vert\cdot\Vert_{L^1}\)</span> 有极限 <span class="math inline">\(x\)</span>, 且 <span class="math inline">\(x\notin C[a,b]\)</span>. 考虑到 <span class="math inline">\(x\in L^1[a,b]\)</span>, 故 <span class="math inline">\(\{x_n\}_{n\in\mathbb{N}}\)</span> 为 <span class="math inline">\(L^1[a,b]\)</span> 中的列紧集, 从而由 <span title="Hausdorff: 度量空间中的列紧集一定是完全有界集.">Th1.3.7</span>, <span class="math inline">\(\{x_n\}_{n\in\mathbb{N}}\)</span> 为 <span class="math inline">\(L^1[a,b]\)</span> 中的完全有界集. 　　故 <span class="math inline">\(\forall\epsilon&gt;0\)</span>, <span class="math inline">\(\exists N\in\mathbb{N}\)</span> 以及 <span class="math inline">\(\{f_k\}_{k=1}^N\subset L^1[a,b]\)</span>, s.t. <span class="math inline">\(\{x_n\}_{n\in\mathbb{N}}\subset\bigcup\limits_{k=1}^NB(f_k,\frac{\epsilon}{2})\)</span>. 不妨设 <span class="math inline">\(B(f_k,\frac{\epsilon}{2})\cap\{x_n\}_{n\in\mathbb{N}}\neq\varnothing\)</span>(否则去掉 <span class="math inline">\(B(f_k,\frac{\epsilon}{2})\)</span> 即可). 对 <span class="math inline">\(\forall k\in\{1,2,\cdots,N\}\)</span>, 取 <span class="math inline">\(g_k\in\{x_n\}_{n\in\mathbb{N}}\cap B(f_k,\frac{\epsilon}{2})\)</span>, 则 <span class="math inline">\(\{x_n\}_{n\in\mathbb{N}}\subset\bigcup\limits_{k=1}^NB(f_k,\frac{\epsilon}{2})\subset\bigcup\limits_{k=1}^NB(g_k,\epsilon)\)</span>. 从而 <span class="math inline">\(\{g_k\}_{k=1}^N\)</span> 为 <span class="math inline">\(\{x_n\}_{n\in\mathbb{N}}\)</span> 的有穷 <span class="math inline">\(\epsilon\)</span> 网. 故 <span class="math inline">\(\{x_n\}_{n\in\mathbb{N}}\)</span> 为 <span class="math inline">\(\mathscr{X}\)</span> 的完全有界集. 　　又由于 <span class="math inline">\(\{x_n\}_{n\in\mathbb{N}}\)</span> 在 <span class="math inline">\(\mathscr{X}\)</span> 中闭, 故 <span class="math inline">\(\{x_n\}_{n\in\mathbb{N}}\)</span> 为 <span class="math inline">\(\mathscr{X}\)</span> 中的完全有界集, 但不紧.</p><p><strong>但在完备空间: Banach空间中有更强的结论.</strong></p><blockquote><p><strong>命题 3</strong> 在Banach空间中, 紧集 <span class="math inline">\(\Leftrightarrow\)</span> 完全有界集.</p></blockquote><p><strong>证明</strong>: 　　上文中已证紧集 <span class="math inline">\(\Rightarrow\)</span> 完全有界闭集. 又由 <span class="math inline">\(B\)</span> 空间中, 完全有界集必定列紧. 从而完全有界集必定是自列紧的. 从而由 <span title="度量空间中的紧集等价于自列紧集.">Th1.3.11</span> 可知该集合必定是紧集. 综上, Banach空间中的集合是紧集, 当且仅当它是完全有界闭集.</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 泛函分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学概率测度小测题目</title>
      <link href="/2017/10/19/BNU-Measure-and-Probability-Exam/"/>
      <content type="html"><![CDATA[<ul><li>概率测度第一次小测 2017.10.19</li><li>概率测度第二次小测 2017.11.30</li></ul><a id="more"></a><h2 id="概率测度第一次小测-2017.10.19">概率测度第一次小测 2017.10.19</h2><h3 id="判断题">判断题</h3><p>正确须证明, 错误须举反例, 没有理由不得分.</p><ol type="1"><li><p><span class="math inline">\(f:\Omega\rightarrow E\)</span>, <span class="math inline">\(\forall~B\subset E\)</span>, <span class="math inline">\(f^{-1}(B^c)=(f^{-1}(B))^c\)</span>;</p></li><li><p>设 <span class="math inline">\((\Omega,\mathcal{F},\mu)\)</span> 为测度空间, 取 <span class="math inline">\(\{A_n\}_{n\in\mathbb{N}}\downarrow\subset\mathcal{F}\)</span>. s.t. <span class="math inline">\(A_n\to\varnothing\)</span>, 有 <span class="math inline">\(\lim\limits_{n\to\infty}\mu(A_n)=0\)</span>;</p></li><li><p>设 <span class="math inline">\((\Omega,\mathcal{F},\mu)\)</span> 为测度空间, 取 <span class="math inline">\(A\in\mathcal{F}\)</span>, s.t. <span class="math inline">\(\mu(A)=0\)</span>, 取 <span class="math inline">\(B\subset A\)</span>, 则有 <span class="math inline">\(\mu(B)=0\)</span>;</p></li><li><p>若 <span class="math inline">\(\Omega\)</span> 的子集类 <span class="math inline">\(\mathcal{C}\)</span> 既是 <span class="math inline">\(\lambda\)</span> 系又是 <span class="math inline">\(\pi\)</span> 系, 则 <span class="math inline">\(\mathcal{C}\)</span> 为 <span class="math inline">\(\sigma\)</span> 代数.</p></li></ol><h3 id="证明题">证明题</h3><p>叙述测度扩张定理, 并证明其中的唯一性部分.</p><h3 id="简略解答">简略解答</h3><p>同样…有差错不负任何责任.</p><h4 id="判断题-1">判断题</h4><ol type="1"><li>正确. 直接验证即可;</li><li>错误. 取 <span class="math inline">\(\mathbb{R}\)</span> 上的Lebesgue测度, <span class="math inline">\(A_n=(n,+\infty)\)</span>, 即有 <span class="math inline">\(\bigcap\limits_{n=1}^\infty A_n=\varnothing\)</span>, 但 <span class="math inline">\(\mu(A_n)=\infty\)</span>, <span class="math inline">\(\forall n\in\mathbb{N}\)</span>, 矛盾;</li><li>错误. 取 <span class="math inline">\(\Omega=\{0,1,2\}\)</span> 上的 <span class="math inline">\(\sigma\)</span> 代数 <span class="math inline">\(\mathcal{F}=\{\varnothing,\{0,1\},\{2\},\Omega\}\)</span>, 取集函数 <span class="math inline">\(\mu(\{\varnothing\})=\mu(\{0,1\})=0\)</span>, <span class="math inline">\(\mu(\{2\})=\mu(\Omega)=1\)</span>, 容易验证 <span class="math inline">\(\mu\)</span> 是一个测度. 取 <span class="math inline">\(B=\{0\}\subset A=\{0,1\}\)</span>, 则 <span class="math inline">\(B\notin\mathcal{F}\)</span>, 矛盾;</li><li>正确. 直接验证即可(由 <span class="math inline">\(\lambda\)</span> 系可直接得到 <span class="math inline">\(\Omega\)</span> 和余运算封闭, 证明对有限并运算封闭时继续构造部分和即可).</li></ol><h4 id="证明题-1">证明题</h4><p>见课本…</p><h3 id="图片版">图片版</h3><p>发卷子了==其实回忆基本没错.</p><center><img src="/img/blog-graph/Measure and probability.jpg" alt="小测试题" width="600"></center><h2 id="概率测度第二次小测-2017.11.30">概率测度第二次小测 2017.11.30</h2><h3 id="判断题-2">判断题</h3><p>正确须证明, 错误须举反例, 没有理由不得分.</p><ol type="1"><li>给定概率空间 <span class="math inline">\((\Omega, \mathcal{F}, P)\)</span>, 如果对于 <span class="math inline">\(\forall A\in\mathcal{F}\)</span>, 有 <span class="math inline">\(P(A)=0 或 1\)</span>, 则:<ol type="1"><li><span class="math inline">\(\mathcal{F}=\{\Omega,\varnothing\}\)</span>;</li><li>对于任意随机变量 <span class="math inline">\(X\in\mathcal{F}\)</span>, 有 <span class="math inline">\(X=C\)</span>, P-a.s..</li></ol></li><li>给定测度空间 <span class="math inline">\((\Omega, \mathcal{F}, \mu)\)</span>, <span class="math inline">\(f\in\mathcal{F}\)</span>. 若 <span class="math inline">\(\mu\)</span> 是 <span class="math inline">\(\sigma\)</span>-有限的, 则 <span class="math inline">\(\mu_f\)</span> 也是 <span class="math inline">\(\sigma\)</span>-有限的.</li></ol><h3 id="计算证明">计算&amp;证明</h3><ol type="1"><li><p>设 <span class="math inline">\(X_1\)</span>, <span class="math inline">\(X_2\)</span> 是独立随机变量, <span class="math inline">\(X_1\sim U[0,1]\)</span>, <span class="math inline">\(X_2\sim B(n,p)\)</span>. 试证 <span class="math inline">\(Y=X_1+X_2\)</span> 是连续型随机变量并求其密度函数.</p></li><li><p>给定测度空间 <span class="math inline">\((\Omega, \mathcal{F}, \mu)\)</span>, <span class="math inline">\(f_n\in\mathcal{F}\)</span> 可积, <span class="math inline">\(\sup\limits_n \int f_n{\rm d}\mu&lt;\infty\)</span>, 且 <span class="math inline">\(f_n\uparrow f\)</span>. 试证: <span class="math inline">\(f\)</span> 可积, 且 <span class="math inline">\(\int f_n{\rm d}\mu\to\int f{\rm d}\mu\)</span>.</p></li></ol><h3 id="简略解答-1">简略解答</h3><h4 id="判断题-3">判断题</h4><ol type="1"><li>两小问:<ol type="1"><li>错误. 取 <span class="math inline">\(A\subset\Omega\)</span>, <span class="math inline">\(\mathcal{F}=\{\varnothing, A, A^c, \Omega\}\)</span>, <span class="math inline">\(\mu( \varnothing)=\mu(A^c)=0\)</span>, <span class="math inline">\(\mu(A)=\mu(\Omega)=1\)</span>, 容易验证是一个反例.</li><li>正确. 注意正测度集存在性的证明.</li></ol></li><li>错误. 考虑 <span class="math inline">\(\mathbb{R}\)</span> 上的Lebesgue测度, <span class="math inline">\(f:\mathbb{R}\to\{1\}\)</span>, <span class="math inline">\(x\mapsto 1\)</span>. 则 <span class="math inline">\(\mu_f\)</span> 不是 <span class="math inline">\(\sigma\)</span>-有限.</li></ol><h4 id="计算证明-1">计算&amp;证明</h4><ol type="1"><li><p>课后习题.</p></li><li><p><span class="math inline">\(f_1\)</span> 可积, <span class="math inline">\(f_1\leqslant f_n\uparrow f\)</span>, 由单调收敛定理可得结论.</p></li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 概率论 </tag>
            
            <tag> 测度论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>次序统计量的联合分布</title>
      <link href="/2017/10/09/%E6%AC%A1%E5%BA%8F%E7%BB%9F%E8%AE%A1%E9%87%8F%E7%9A%84%E8%81%94%E5%90%88%E5%88%86%E5%B8%83/"/>
      <content type="html"><![CDATA[<blockquote><p>设 <span class="math inline">\(X_1,\cdots,X_n\)</span> 为来自总体 <span class="math inline">\(X\sim F\)</span> 的iid样本, 总体概率密度函数为 <span class="math inline">\(f(x)\)</span>, 则对于给定的 <span class="math inline">\(1\leqslant i\leqslant j\leqslant n\)</span>, 求统计量 <span class="math inline">\(X_{(i)}\)</span> 与 <span class="math inline">\(X_{(j)}\)</span> 的联合密度.</p></blockquote><p>首先注意到, <span class="math inline">\(X_{(1)},\cdots,X_{(n)}\)</span> 的联合密度为 <span class="math display">\[f_{(X_{(1)},\cdots,X_{(n)})}(x_1,\cdots,x_n)=n!\cdot f(x_1)\cdots f(x_n).\]</span></p><p>于是只需要求 <span class="math inline">\((X_{(i)}, X_{(j)})\)</span> 的边缘密度.</p><p>利用结果 <span class="math display">\[\idotsint\limits_{a&lt;x_1&lt;\cdots&lt;x_k&lt;b}f(x_1)\cdots f(x_k){\rm d}x_1\cdots {\rm d}x_k=\frac{1}{k!}(F(b)-F(a))^k\]</span></p><p>可得 <span class="math display">\[\begin{align}f_{(X_{(i)}, X_{(j)})}(x,y) &amp;= \idotsint\limits_{x_k\in\mathbb{R},k\neq i,j}n!\cdot f(x_1)\cdots f(x_n){\rm d}x_1\cdots{\rm d}x_{i-1}{\rm d}x_{i+1}\cdots{\rm d}x_{j-1}{\rm d}x_{j+1}{\rm d}x_n \\&amp;= n!\times\idotsint\limits_{0&lt;x_1\cdots&lt;x_{i-1}&lt;x}f(x_1)\cdots f(x_{i-1}){\rm d}x_1\cdots{\rm d}x_{i-1}\times \idotsint\limits_{x&lt;x_{i+1}&lt;\cdots&lt;x_{j-1}&lt;y}f(x_{i+1})\cdots f(x_{j-1}){\rm d}x_{i+1}\cdots{\rm d}x_{j-1}\times \idotsint\limits_{y&lt;x_{j+1}&lt;\cdots&lt;x_n&lt;+\infty}f(x_{j+1})\cdots f(x_n){\rm d}x_{j+1}{\rm d}x_n\times f(x)f(y) \\&amp;= n!\times \frac{F^{j-1}(x)}{(j-1)!}\times\frac{[F(y)-F(x)]^{k-j-1}}{(k-j-1)!}\times\frac{[1-F(y)]^{n-k}}{(n-k)!}\times f(x)f(y) \\&amp;= \frac{n!}{(j-1)!(k-j-1)!(n-k)!}F^{j-1}(x)[F(y)-F(x)]^{k-j-1}[1-F(y)]^{n-k}f(x)f(y)\end{align}\]</span></p><p>同样可以求出任意多个次序统计量的联合密度.</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 概率论 </tag>
            
            <tag> 统计学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>泛函——自然数集上的Lp范数</title>
      <link href="/2017/10/08/%E6%B3%9B%E5%87%BD%E2%80%94%E2%80%94%E8%87%AA%E7%84%B6%E6%95%B0%E9%9B%86%E4%B8%8A%E7%9A%84Lp%E8%8C%83%E6%95%B0/"/>
      <content type="html"><![CDATA[<h2 id="lpomegamu-空间"><span class="math inline">\(L^p(\Omega,\mu)\)</span> 空间</h2><p><span class="math inline">\(1\leqslant p&lt;\infty\)</span>, 设 <span class="math inline">\((\Omega,\mathscr{B},\mu)\)</span> 是一个测度空间, <span class="math inline">\(u\)</span> 是 <span class="math inline">\(\Omega\)</span> 上的可测函数且 <span class="math inline">\(|u(x)^p|\)</span> 在 <span class="math inline">\(\Omega\)</span> 可积. 则记这样 <span class="math inline">\(u\)</span> 的全体为 <span class="math inline">\(L^p(\Omega,\mu)\)</span>.</p><p>在 <span class="math inline">\(L^p(\Omega,\mu)\)</span> 中几乎处处相等的函数视为同一个函数后, <span class="math inline">\(L^p(\Omega,\mu)\)</span> 仍为线性空间. 定义 <span class="math display">\[\Vert u\Vert=\left(\int\nolimits_\Omega \vert u(x)^p\vert {\rm d}\mu\right)^\frac{1}{p}\]</span> 则 <span class="math inline">\(\Vert\cdot\Vert\)</span> 为一个范数. 事实上 <span class="math inline">\(L^p(\Omega,\mu)\)</span> 还是一个Banach空间.</p><h2 id="mathbbn-上的-lp-范数"><span class="math inline">\(\mathbb{N}\)</span> 上的 <span class="math inline">\(L^p\)</span> 范数</h2><p>以上的空间在 <span class="math inline">\(\mathbb{N}\)</span> 上的特殊情形如下:</p><p><span class="math inline">\(\Omega=\mathbb{N}, \mu(\{n\})=1~(\forall n\in\mathbb{N})\)</span>, 此时 <span class="math inline">\(L^p(\Omega,\mu)\)</span> 由满足 <span class="math inline">\(\sum\limits_{n=1}^\infty\vert u_n\vert^p&lt;\infty\)</span> 的所有序列组成, 记为 <span class="math inline">\(l^p\)</span>.</p><p>此时其范数为 <span class="math display">\[\Vert u\Vert=\left(\sum\limits_{n=1}^\infty \vert u_n\vert^p\right)^\frac{1}{p}.\]</span></p><p>对于 <span class="math inline">\(\forall N\in\mathbb{N}\)</span>, 记 <span class="math inline">\(f_N(x)=\sum\limits_{n=1}^Nu_n\chi_{\{n\}}\)</span>, 令 <span class="math inline">\(f(x)=\sum\limits_{n=1}^\infty u_n\chi_{\{n\}}\)</span>, <span class="math inline">\(x\in\mathbb{N}\)</span>.</p><p>则有 <span class="math display">\[\begin{align}\int\nolimits_\mathbb{N}\vert f_N(x)\vert^p{\rm d}\mu(x) &amp;= \int\nolimits_\mathbb{N}\sum\limits_{n=1}^Nu_n\chi_{\{n\}}{\rm d}\mu(x) \\&amp;= \sum\limits_{n=1}^N \vert u_n\vert^p\cdot\int\nolimits_\mathbb{N}\chi_{\{n\}}{\rm d}\mu(x) \\&amp;= \sum\limits_{n=1}^N \vert u_n\vert^p\end{align}\]</span></p><p>又显然, <span class="math inline">\(0\leqslant\vert f_N(x)\vert^p\leqslant \vert f_{N+1}(x)\vert^p\)</span>, 且 <span class="math inline">\(\vert f(x)\vert^p=\lim\limits_{N\to\infty}\vert f_N(x)\vert^p\)</span>. 故由非负可测函数的Levi定理有 <span class="math display">\[\begin{align}\int\nolimits_\mathbb{N}\vert f(x)\vert^p{\rm d}\mu(x) &amp;= \int\nolimits_\mathbb{N}\lim\limits_{N\to\infty}\vert f_N(x)\vert^p{\rm d}\mu(x) \\&amp;= \lim\limits_{N\to\infty}\int\nolimits_\mathbb{N}\vert f_N(x)\vert^p{\rm d}\mu(x) \\&amp;= \sum\limits_{n=1}^\infty \vert u_n\vert^p\end{align}\]</span></p><p>即有 <span class="math display">\[ \left(\sum\limits_{N=1}^\infty\vert u_n\vert^p\right)^\frac{1}{p}=\left(\int\nolimits_\mathbb{N}\vert f(x)\vert^p{\rm d}\mu(x)\right)^\frac{1}{p}. \]</span></p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 泛函分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>拓扑学题目</title>
      <link href="/2017/10/08/%E6%8B%93%E6%89%91%E5%AD%A6%E9%A2%98%E7%9B%AE/"/>
      <content type="html"><![CDATA[<h2 id="乘积空间">乘积空间</h2><h3 id="hausdorff空间与对角映射">Hausdorff空间与对角映射</h3><blockquote><p>映射 <span class="math display">\[\Delta: X\rightarrow X\times X,~\Delta(x)=(x,x)\]</span> 称为<strong>对角映射</strong>. 证明: <span class="math inline">\(X\)</span> 是Hausdorff空间当且仅当 <span class="math inline">\(\Delta(X)\)</span> 是 <span class="math inline">\(X\times X\)</span> 的闭集.</p></blockquote><p><strong>证明</strong>:</p><p><strong>充分性</strong>: <span class="math inline">\(\forall x\neq y\in X\)</span>, 有 <span class="math inline">\((x,y)\in \Delta^c\)</span>. 由 <span class="math inline">\(\Delta\)</span> 为闭集有 <span class="math inline">\(\Delta^c\)</span> 为开集. 故由乘积拓扑的定义, 存在 <span class="math inline">\(X\)</span> 的开子集 <span class="math inline">\(U,V\)</span>, s.t. <span class="math inline">\((x,y)\in U\times V\subset\Delta^c\)</span>. (<span class="math inline">\(X\)</span> 上的开集<span class="math inline">\(\times\)</span><span class="math inline">\(X\)</span>上的开集为 <span class="math inline">\(X\times X\)</span> 乘积拓扑的一组拓扑基). 于是此时, <span class="math inline">\(U,V\)</span> 是 <span class="math inline">\(x,y\)</span> 的开邻域并且易得 <span class="math inline">\(U\cap V=\varnothing\)</span>.</p><p><strong>必要性</strong>: 由于 <span class="math inline">\(X\)</span> 是Hausdorff空间, 故 <span class="math inline">\(\forall x\neq y\in X\)</span>, 存在 <span class="math inline">\(X\)</span> 的开子集 <span class="math inline">\(U,V\)</span>, s.t. <span class="math inline">\(x\in U\)</span>, <span class="math inline">\(y\in V\)</span>, 且 <span class="math inline">\(U\cap V=\varnothing\)</span>. 故 <span class="math inline">\((x,y)\in U\times V\)</span>, 又由 <span class="math inline">\(U\cap V=\varnothing\)</span>, 知 <span class="math inline">\((U\times V)\cap\Delta=\varnothing\)</span>, 即 <span class="math inline">\(U\times V\subset\Delta^c\)</span>, 故 <span class="math inline">\(U\times V\)</span> 为 <span class="math inline">\((x,y)\)</span> 在 <span class="math inline">\(\Delta^c\)</span> 中的开邻域. 故 <span class="math inline">\(\Delta^c\)</span> 为开集, 即 <span class="math inline">\(\Delta\)</span> 为闭集.</p><p><strong>综上所述</strong>, <span class="math inline">\(X\)</span> 是Hausdorff空间 <span class="math inline">\(\Longleftrightarrow\)</span> <span class="math inline">\(\Delta(X)\)</span> 是 <span class="math inline">\(X\times X\)</span> 的闭集.</p><h3 id="自然投影不一定是闭映射">自然投影不一定是闭映射</h3><blockquote><p>举例说明 <span class="math inline">\(p_1:X\times Y\to Y\)</span> 不一定是闭映射.</p></blockquote><p><strong>证明</strong>: 取 <span class="math inline">\(\mathbb{E}^2\)</span> 中的闭集 <span class="math inline">\(F=\{(x,\frac{1}{x}):x&gt;0\in\mathbb{R}\}\)</span>, 则 <span class="math inline">\(p_1(F)=\mathbb{R}^+\)</span> 为开集.</p><h2 id="连通性">连通性</h2><h3 id="mathbbe2-上的非无理点集连通"><span class="math inline">\(\mathbb{E}^2\)</span> 上的非无理点集连通</h3><blockquote><p>设 <span class="math inline">\(X=\{(r,s)\in\mathbb{E}^2\vert r\in\mathbb{Q}~或~s\in\mathbb{Q}\}\)</span>, 证明 <span class="math inline">\(X\)</span> 连通.</p></blockquote><p>有各种神奇的想法.</p><p><strong>证明1</strong>: <strong>通过道路连通性考虑</strong>. 取 <span class="math inline">\(x_1=(r_1,s_1),x_2=(r_2,s_2)\in X\)</span>, 有以下两种情况.</p><ol type="1"><li>若 <span class="math inline">\(r_1,r_2\in\mathbb{Q}\)</span>, 则存在 <span class="math inline">\(x_1\to x_2\)</span> 的道路 <span class="math inline">\((r_1,s_1)\to(r_1,r_2)\to(r_2,r_2)\to(r_2,s_2)\)</span>;</li><li>若 <span class="math inline">\(r_1,s_2\in\mathbb{Q}\)</span>, 则存在 <span class="math inline">\(x_1\to x_2\)</span> 的道路 <span class="math inline">\((r_1,s_1)\to(r_1,s_2)\to(r_2,s_2)\)</span>.</li></ol><p><strong>综上所述</strong>, <span class="math inline">\(X\)</span> 是道路连通的, 因此 <span class="math inline">\(X\)</span> 连通.</p><p><strong>证明2</strong>: <strong>反证法</strong>. 假设 <span class="math inline">\(X\)</span> 可以写成两个不相交非空开集 <span class="math inline">\(A,B\)</span> 的并. 取 <span class="math inline">\(q\in\mathbb{Q}\)</span>, 则 <span class="math inline">\(X_q=\{(x,q),(q,x)\vert x\in\mathbb{R}\}\)</span> 构成 <span class="math inline">\(X\)</span> 的连通子集. 显然有 <span class="math inline">\(X_q\subset A\)</span> 或者 <span class="math inline">\(X_q\subset B\)</span>, 否则 <span class="math inline">\(X_q\)</span> 可分成不相交的两部分 <span class="math inline">\(X_{q_A}\)</span> 和 <span class="math inline">\(X_{q_B}\)</span>, s.t. <span class="math inline">\(\overline{X_{q_A}}\cap X_{q_B}=\overline{X_{q_B}}\cap X_{q_A}=\varnothing\)</span>, 这与 <span class="math inline">\(X\)</span> 的连通性矛盾. 于是 <span class="math inline">\(\exists q_1,q_2\in\mathbb{Q}\)</span>, s.t. <span class="math inline">\(X_{q_1}\subset A\)</span>, <span class="math inline">\(X_{q_2}\subset B\)</span>. 但 <span class="math inline">\((q_1,q_2)\in X_{q_1}\cap X_{q_2}\)</span>, 与 <span class="math inline">\(A\cap B=\varnothing\)</span> 矛盾. 故 <span class="math inline">\(X\)</span> 连通.</p><p>考虑一个引理:</p><blockquote><p><strong>引理</strong> 若 <span class="math inline">\(X_0\)</span> 是 <span class="math inline">\(X\)</span> 的既开又闭子集, <span class="math inline">\(A\)</span> 是 <span class="math inline">\(X\)</span> 的连通子集, 则 <span class="math inline">\(A\cap X_0=\varnothing\)</span> 或 <span class="math inline">\(A\subset X_0\)</span>.</p></blockquote><p><strong>引理的证明</strong>: <span class="math inline">\(A\cap X_0\)</span> 是 <span class="math inline">\(A\)</span> 的既开又闭子集. 由于 <span class="math inline">\(A\)</span> 连通, 故 <span class="math inline">\(A\cap X_0=\varnothing\)</span> 或 <span class="math inline">\(A\cap X_0=A\)</span>, 即 <span class="math inline">\(A\subset X_0\)</span>.</p><p>由引理可得出以下命题（北大拓扑学讲义P63 Prop 2.23）进而可证原命题.</p><blockquote><p><strong>命题 2.23</strong> 如果 <span class="math inline">\(X\)</span> 有一个连通覆盖 <span class="math inline">\(\mathscr{U}\)</span>, 并且 <span class="math inline">\(X\)</span> 有一连通子集 <span class="math inline">\(A\)</span>, 它与 <span class="math inline">\(\mathscr{U}\)</span> 中每个成员都相交, 则 <span class="math inline">\(X\)</span> 连通.</p></blockquote><p><strong>命题的证明</strong>: 设 <span class="math inline">\(X_0\)</span> 是 <span class="math inline">\(X\)</span> 的既开又闭子集, 只需证明 <span class="math inline">\(X_0=\varnothing\)</span> 或 <span class="math inline">\(X_0=X\)</span>. 由引理, <span class="math inline">\(A\cap X_0=\varnothing\)</span> 或 <span class="math inline">\(A\subset X_0\)</span>.</p><ol type="1"><li>若 <span class="math inline">\(A\cap X_0=\varnothing\)</span>, 则 <span class="math inline">\(\forall U\in\mathscr{U}\)</span>, 由于 <span class="math inline">\(U\cap A\neq\varnothing\)</span>, 故 <span class="math inline">\(U\nsubseteq X_0\)</span>. 由引理, <span class="math inline">\(U\cap X_0=\varnothing\)</span>, 则 <span class="math inline">\(X_0=(\bigcup\limits_{U\in\mathscr{U}}U)\cap X_0=\bigcup\limits_{U\in\mathscr{U}}(U\cap X_0)=\varnothing\)</span>.</li><li>若 <span class="math inline">\(A\subset X_0\)</span>, 则 <span class="math inline">\(\forall U\in\mathscr{U}\)</span>, <span class="math inline">\(U\cap X_0\supset U\cap A\neq\varnothing\)</span>. 由引理, <span class="math inline">\(U\subset X_0\)</span>, 则 <span class="math inline">\(X=\bigcup\limits_{U\in\mathscr{U}}U\subset X_0\)</span>, 即有 <span class="math inline">\(X_0=X\)</span>.</li></ol><p><strong>综上所述</strong>, <span class="math inline">\(X\)</span> 连通.</p><p><strong>证明3</strong>: 仍然考虑 <span class="math inline">\(A_q=\{(x,y)\vert x=q~或~y=q\}\)</span>, 则 <span class="math inline">\(A_q\)</span> 连通且 <span class="math inline">\(X=\bigcup\limits_{q\in\mathbb{Q}}A_q\)</span>, 即 <span class="math inline">\(\{A_q\}_{q\in\mathbb{Q}}\)</span> 构成 <span class="math inline">\(X\)</span> 的连通覆盖, 而 <span class="math inline">\(A_q\cap A_0\neq\varnothing, \forall q\in\mathbb{Q}\)</span>, 故由命题2.23, <span class="math inline">\(X\)</span> 连通.</p><p>结合引理, 证法2也会有不同的写法, 不再赘述.</p><h3 id="mathbbr1-上左开右闭区间生成的拓扑不是-c_2-空间"><span class="math inline">\(\mathbb{R}^1\)</span> 上左开右闭区间生成的拓扑不是 <span class="math inline">\(C_2\)</span> 空间</h3><blockquote><p>设 <span class="math inline">\(\mathbb{R}^1\)</span> 的子集族 <span class="math inline">\(\mathcal{B}=\{(a,b]:a,b\in\mathbb{R}^1,a&lt;b\}\)</span>, 则 <span class="math inline">\(\mathcal{B}\)</span> 构成 <span class="math inline">\(\mathbb{R}^1\)</span> 上的一个拓扑基且该拓扑不是第二可数空间.</p></blockquote><p><strong>证明</strong>: <span class="math inline">\(\mathcal{B}\)</span> 构成拓扑基的证明是平凡的, 不再赘述. 以下证明该空间不是第二可数的. <strong>反证法.</strong> 设有可数拓扑基 <span class="math inline">\(\{\alpha_i\}\)</span>, 设 <span class="math inline">\(a_i=\sup\limits_{x\in\alpha_i}x\)</span> (<span class="math inline">\(a_i\)</span> 可取 <span class="math inline">\(\infty\)</span>), 则 <span class="math inline">\(a_i\)</span> 只有可数个, 于是 <span class="math inline">\(\exists\)</span> 无理数 <span class="math inline">\(\beta\notin\{a_i\}_{i\in\mathbb{N}}\)</span>. 由条件, 可设 <span class="math inline">\((\beta^{-1},\beta]=\bigcup\limits_{j} \alpha_j\)</span>. 于是 <span class="math inline">\(\beta=\sup\limits_{x\in\bigcup_j\alpha_j}x=\max\limits_j a_j\)</span>, 与 <span class="math inline">\(\beta\notin\{a_i\}_{i\in\mathbb{N}}\)</span> 矛盾. 于是不存在可数拓扑基, 因而不是 <span class="math inline">\(C_2\)</span> 空间.</p><h3 id="mathbbq-作为-mathbbe1-的子空间不是局部紧的"><span class="math inline">\(\mathbb{Q}\)</span> 作为 <span class="math inline">\(\mathbb{E}^1\)</span> 的子空间不是局部紧的</h3><blockquote><p>证明有理数作为 <span class="math inline">\(\mathbb{E}^1\)</span> 不是局部紧致的.</p></blockquote><p><strong>证明</strong>: 取 <span class="math inline">\(q\in \mathbb{Q}\)</span>, 只需要证明 <span class="math inline">\(q\)</span> 的任意邻域都不紧即可. 任取 <span class="math inline">\(\mathbb{Q}\)</span> 中包含 <span class="math inline">\(q\)</span> 的一个邻域, 则该邻域具有 <span class="math inline">\(U_q\cap\mathbb{Q}\)</span> 的形式, 其中 <span class="math inline">\(U_q\)</span> 是 <span class="math inline">\(q\)</span> 在 <span class="math inline">\(\mathbb{R}\)</span> 中的邻域. 故 <span class="math inline">\(U_q\)</span> 包含 <span class="math inline">\(q\)</span> 的连通分支必定具有区间 <span class="math inline">\(|a,b|\)</span> 的形式（开区间或闭区间）. 取无理数 <span class="math inline">\(\xi\in|a,b|\)</span>, 记 <span class="math inline">\(|a,b|\)</span> 中比 <span class="math inline">\(\xi\)</span> 小的有理数为 <span class="math inline">\(\{a_1,a_2\cdots\}\)</span>, 比 <span class="math inline">\(\xi\)</span> 大的有理数为 <span class="math inline">\(\{b_1,b_2,\cdots\}\)</span>, 则 <span class="math inline">\(\{\mathbb{Q}\cap|a,a_i)\}_{i\in\mathbb{N}}\cup\{\mathbb{Q}\cap(b_j,b|\}_{j\in\mathbb{N}}\)</span> 构成 <span class="math inline">\(|a,b|\)</span> 的一个开覆盖, 且没有有限子覆盖. 于是 <span class="math inline">\(|a,b|\)</span> 不紧. 命题得证.</p><h3 id="师大拓扑学p47-8.">师大《拓扑学》P47 8.</h3><blockquote><p>设拓扑空间 <span class="math inline">\(X\)</span> 可以写成两个开集 <span class="math inline">\(X_1\)</span>, <span class="math inline">\(X_2\)</span> 的并, 并且 <span class="math inline">\(X_0=X_1\cap X_2\neq\varnothing\)</span> 道路连通, 证明 <span class="math inline">\(X\)</span> 道路连通当且仅当 <span class="math inline">\(X_1\)</span> 和 <span class="math inline">\(X_2\)</span> 都道路连通.</p></blockquote><p><strong>证明</strong>: 只需要证明 <span class="math inline">\(X_1\)</span> 道路连通. 由于 <span class="math inline">\(X_1\cap X_2\)</span> 道路连通, 以下只需证明 <span class="math inline">\(\forall p\in X_1\backslash X_2\)</span>, 存在 <span class="math inline">\(p\)</span> 到 <span class="math inline">\(X_1\cap X_2\)</span> 中某点的道路. 取 <span class="math inline">\(q\in X_2\)</span>, 则由 <span class="math inline">\(X\)</span> 道路连通, 任取 <span class="math inline">\(q\in X_2\)</span>, <span class="math inline">\(X\)</span> 中存在 <span class="math inline">\(p\to q\)</span> 的一条道路 <span class="math inline">\(a\)</span>, 即 <span class="math inline">\(a:X\to I\)</span>, s.t. <span class="math inline">\(a(0)=p\)</span>, <span class="math inline">\(a(1)=q\)</span>. 则 <span class="math inline">\(a^{-1}(X_1\cap X_2)\neq\varnothing\)</span>, 否则由 <span class="math inline">\(a\)</span> 的连续性, <span class="math inline">\(a^{-1}(X_1)\)</span> 和 <span class="math inline">\(a^{-1}(X_2)\)</span> 为 <span class="math inline">\(I\)</span> 的两个非空开集且 <span class="math inline">\(a^{-1}(X_1)\cup a^{-1}(X_2)=I\)</span>, 从而与 <span class="math inline">\(I\)</span> 的连通性矛盾. 取 <span class="math inline">\(t=\inf a^{-1}(X_1)\cap a^{-1}(X_2)\)</span>, 则 <span class="math inline">\([0,t]\subset a^{-1}(X_1)\)</span>. 由 <span class="math inline">\(a^{-1}(X_1)\)</span> 是开集知 <span class="math inline">\(\exists\epsilon&gt;0\)</span>, s.t. <span class="math inline">\([t,t+\epsilon)\subset a^{-1}(X_1)\)</span>. 于是 <span class="math inline">\(\exists t_1\in[t,t+\epsilon)\)</span>, s.t. <span class="math inline">\(a(t_1)\in X_1\cap X_2\)</span>. 即存在 <span class="math inline">\(p\to t_1\)</span> 的道路, 因而 <span class="math inline">\(X_1\)</span> 道路连通.</p><h3 id="粘合拓扑与并集的子空间拓扑">粘合拓扑与并集的子空间拓扑</h3><blockquote><p>若 <span class="math inline">\(X_\alpha\)</span> 是 <span class="math inline">\(Z\)</span> 的子空间, 给 <span class="math inline">\(\bigcup\limits_\alpha X_\alpha\)</span> 以 <span class="math inline">\(Z\)</span> 的子空间拓扑. 若 <span class="math inline">\(\alpha\)</span> 个数有限, 并且每个 <span class="math inline">\(X_\alpha\)</span> 在 <span class="math inline">\(\bigcup\limits_\alpha X_\alpha\)</span> 中闭, 则 <span class="math inline">\(\bigcup\limits_\alpha X_\alpha\)</span> 的子空间拓扑与粘合拓扑一致. 若 <span class="math inline">\(\alpha\)</span> 个数无限, 则结论不一定成立.</p></blockquote><p><strong>证明1</strong>: 平凡的构造是很容易的: 考虑 <span class="math inline">\(Z=\mathbb{E}^1\)</span>, <span class="math inline">\(X_\alpha=\{\alpha\}\)</span>, <span class="math inline">\(\forall\alpha\in\mathbb{R}\)</span>, 则 <span class="math inline">\(Z=\bigcup\limits_\alpha X_\alpha\)</span>. 并集的子空间拓扑显然就是欧氏拓扑, 但粘合拓扑为 <span class="math inline">\(\mathbb{R}\)</span> 上的离散拓扑, 因而不相同.</p><p><strong>证明2</strong>: 非平凡的例子: 待补.</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 拓扑学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>单调类定理</title>
      <link href="/2017/09/21/%E5%8D%95%E8%B0%83%E7%B1%BB%E5%AE%9A%E7%90%86/"/>
      <content type="html"><![CDATA[<h2 id="基础定义">基础定义</h2><h3 id="sigma-代数"><span class="math inline">\(\sigma\)</span> 代数</h3><p>称 <span class="math inline">\(\Omega\)</span> 的子集类 <span class="math inline">\(\mathscr{F}\)</span> 为 <span class="math inline">\(\Omega\)</span> 的 <span class="math inline">\(\sigma\)</span> 代数, 如果它满足:</p><ol type="1"><li><span class="math inline">\(\Omega\in\mathcal{F}\)</span>;</li><li>若 <span class="math inline">\(A\in\mathcal{F}\)</span>, 则 <span class="math inline">\(A^c\in\mathcal{F}\)</span>;</li><li>若 <span class="math inline">\(A_n\in\mathcal{F}\)</span>, <span class="math inline">\(n\in\mathbf{N}\)</span>, 则 <span class="math inline">\(\bigcup\limits_{n=1}^\infty A_n\in\mathcal{F}\)</span>.</li></ol><h3 id="lambda-pi-系"><span class="math inline">\(\lambda-\pi\)</span> 系</h3><h4 id="pi-系"><span class="math inline">\(\pi\)</span> 系</h4><p>称 <span class="math inline">\(\Omega\)</span> 的子集类 <span class="math inline">\(\Pi\)</span> 称为 <span class="math inline">\(\pi\)</span> 系, 如果它对交运算封闭.</p><h4 id="lambda-系"><span class="math inline">\(\lambda\)</span> 系</h4><p>称 <span class="math inline">\(\Omega\)</span> 的子集类 <span class="math inline">\(\Lambda\)</span> 称为 <span class="math inline">\(\lambda\)</span> 系, 如果:</p><ol type="1"><li><span class="math inline">\(\Omega\in\Lambda\)</span>;</li><li>对真差封闭: 即 <span class="math inline">\(\forall~A,B\in\Lambda\)</span>, s.t. <span class="math inline">\(A\subset B\)</span>, 总有 <span class="math inline">\(B\backslash A\in\Lambda\)</span>;</li><li>对不降序列的并封闭: 即 <span class="math inline">\(\{A_n:n\in\mathbf{N}\}\)</span>, <span class="math inline">\(A_n\uparrow\)</span>, 则 <span class="math inline">\(\bigcup\limits_{n=1}^\infty A_n\in\Lambda\)</span>.</li></ol><h2 id="集合形式的单调类定理">集合形式的单调类定理</h2><h3 id="引理-lambdapisigma">引理: <span class="math inline">\(\lambda+\pi=\sigma\)</span></h3><blockquote><p>若 <span class="math inline">\(\Omega\)</span> 子集类 <span class="math inline">\(\mathcal{C}\)</span> 同时为 <span class="math inline">\(\lambda\)</span> 系和 <span class="math inline">\(\pi\)</span> 系, 则 <span class="math inline">\(\mathcal{C}\)</span> 为 <span class="math inline">\(\sigma\)</span> 代数.</p></blockquote><p><strong>证明</strong>: 首先, 由 <span class="math inline">\(\mathcal{C}\)</span> 为 <span class="math inline">\(\lambda\)</span> 系可知 <span class="math inline">\(\Omega\in\mathcal{C}\)</span>, 且 <span class="math inline">\(\forall~A\in\mathcal{C}\)</span>, 均有 <span class="math inline">\(A\subset\Omega\)</span>, 于是 <span class="math inline">\(A^c=\Omega\backslash A\in\mathcal{C}\)</span>. 另一方面, 取 <span class="math inline">\(A_n\in\mathcal{C}\)</span>, <span class="math inline">\(n\in\mathbf{N}\)</span> 则 <span class="math inline">\(B_n=\bigcup\limits_{n=1}^\infty A_k\)</span>, <span class="math inline">\(n\in\mathbf{N}\)</span> 是不降集列, 于是由 <span class="math inline">\(A_k^c\in\mathcal{C}\)</span> 以及 <span class="math inline">\(\mathcal{C}\)</span> 是 <span class="math inline">\(\pi\)</span> 系, 可知 <span class="math inline">\(B_n^c=\bigcap\limits_{n=1}^\infty A_k^c\in\mathcal{C}\)</span>.</p><p>于是 <span class="math inline">\(B_n\in\mathcal{C}\)</span>, 由定义知, <span class="math inline">\(\bigcup\limits_{n=1}^\infty A_n=\bigcup\limits_{n=1}^\infty B_n\in\mathcal{C}\)</span>, 于是 <span class="math inline">\(\mathcal{C}\)</span> 为 <span class="math inline">\(\sigma\)</span> 代数.</p><h3 id="单调类定理">单调类定理</h3><blockquote><p>设 <span class="math inline">\(\Omega\)</span> 的子集类 <span class="math inline">\(\mathcal{C}\)</span> 是 <span class="math inline">\(\pi\)</span> 系, <span class="math inline">\(\Lambda(\mathcal{C})\)</span> 是包含 <span class="math inline">\(\mathcal{C}\)</span> 的最小 <span class="math inline">\(\lambda\)</span> 系, 则 <span class="math inline">\(\Lambda(\mathcal{C})=\sigma(\mathcal{C})\)</span>.</p></blockquote><p><strong>证明</strong>: 由于 <span class="math inline">\(\sigma\)</span> 代数一定是 <span class="math inline">\(\lambda\)</span> 系, 故 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 为 <span class="math inline">\(\lambda\)</span> 系, 由 <span class="math inline">\(\Lambda(\mathcal{C})\)</span> 的最小性, 有 <span class="math inline">\(\sigma(\mathcal{C})\supset\Lambda(\mathcal{C})\)</span>.</p><p>于是只需要证明 <span class="math inline">\(\sigma(\mathcal{C})\subset\Lambda(\mathcal{C})\)</span>, 由 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 的最小性, 只需要证明 <span class="math inline">\(\Lambda(\mathcal{C})\)</span> 为 <span class="math inline">\(\sigma\)</span> 代数. 又由于 <span class="math inline">\(\Lambda(\mathcal{C})\)</span> 为 <span class="math inline">\(\lambda\)</span> 系, 故只需要证明 <span class="math inline">\(\Lambda(\mathcal{C})\)</span> 为一个 <span class="math inline">\(\pi\)</span> 系.</p><p>即只需证明 <span class="math inline">\(\forall~A, B\in\Lambda(\mathcal{C})\)</span>, <span class="math inline">\(A\cap B\in\Lambda(\mathcal{C})\)</span>.</p><p><strong>令 <span class="math inline">\(\Lambda_A=\{B\in\Lambda(\mathcal{C}): A\cap B\in\Lambda(\mathcal{C})\}\)</span>, 则只需证明 <span class="math inline">\(\forall~A\in\Lambda(\mathcal{C})\)</span>, 有 <span class="math inline">\(\Lambda_A=\Lambda(\mathcal{C})\)</span> 即可.</strong> 由于显然有 <span class="math inline">\(\Lambda_A\subset\Lambda(\mathcal{C})\)</span>, 故只需要证明 <span class="math inline">\(\Lambda_A\supset\Lambda(\mathcal{C})\)</span>.</p><p>考虑到 <span class="math inline">\(\Lambda(\mathcal{C})\)</span> 的最小性, 可按照如下三步证明:</p><ol type="1"><li><span class="math inline">\(\forall~A\in\Lambda(\mathcal{C})\)</span>, <span class="math inline">\(\Lambda_A\)</span> 是 <span class="math inline">\(\lambda\)</span> 系;</li><li><span class="math inline">\(\forall~A\in\mathcal{C}\)</span>, <span class="math inline">\(\Lambda_A=\Lambda(\mathcal{C})\)</span>;</li><li><span class="math inline">\(\forall~A\in\Lambda(\mathcal{C})\)</span>, <span class="math inline">\(\Lambda_A=\Lambda(\mathcal{C})\)</span>.</li></ol><p>证明第一条:</p><ol type="1"><li>由 <span class="math inline">\(\Lambda_A\)</span> 的定义, <span class="math inline">\(\Omega\in\Lambda_A\)</span>;</li><li><span class="math inline">\(\forall~B, C\in\Lambda_A\)</span>, s.t. <span class="math inline">\(B\subset C\)</span>, 则由 <span class="math inline">\(\Lambda_A\)</span> 的定义有 <span class="math inline">\(A\cap C,A\cap B\in\Lambda(\mathcal{C})\)</span>, 同时易得 <span class="math inline">\(A\cap B\subset A\cap C\)</span>. 由于 <span class="math inline">\(\Lambda(\mathcal{C})\)</span> 是 <span class="math inline">\(\lambda\)</span> 系, 故对真差封闭, 即 <span class="math inline">\(A\cap(C\backslash B)=(A\cap C)\backslash(A\cap B)\in\Lambda(\mathcal{C})\)</span>, 于是 <span class="math inline">\(C\backslash B\in\Lambda_A\)</span>;</li><li><span class="math inline">\(\forall~\{A_n\}\subset\Lambda_A\)</span>, <span class="math inline">\(A_n\uparrow\)</span>, 则 <span class="math inline">\(A\cap A_n\in\Lambda(\mathcal{C})\)</span> 且 <span class="math inline">\(A\cap A_n\uparrow\)</span>. 因此有 <span class="math inline">\(A\cap(\bigcup_{n=1}^\infty A_n)=\bigcup_{n=1}^\infty(A\cap A_n)\in\Lambda(\mathcal{C})\)</span>.</li></ol><p>于是 <span class="math inline">\(\forall~A\in\Lambda(\mathcal{C})\)</span>, <span class="math inline">\(\Lambda_A\)</span> 是 <span class="math inline">\(\lambda\)</span> 系.</p><p>证明第二条: <strong>只需要证明 <span class="math inline">\(\Lambda_A\supset\mathcal{C}\)</span>.</strong> <span class="math inline">\(\forall~B\in\mathcal{C}\)</span>, 由于 <span class="math inline">\(\mathcal{C}\)</span> 是 <span class="math inline">\(\pi\)</span> 系, 故 <span class="math inline">\(A\cap B\in\mathcal{C}\subset\Lambda(\mathcal{C})\)</span>, 于是 <span class="math inline">\(\mathcal{C}\subset\Lambda_A\)</span>.</p><p>证明第三条: 仍然只需要证明 <span class="math inline">\(\mathcal{C}\subset\Lambda_A\)</span>. <strong>即需要证明 <span class="math inline">\(\forall~B\in\mathcal{C}\)</span>, <span class="math inline">\(B\in\Lambda_A\)</span>. 由于此时 <span class="math inline">\(A\)</span> 不一定在 <span class="math inline">\(\mathcal{C}\)</span> 中, 故无法对 <span class="math inline">\(A\)</span> 使用第二条中的方法. 但由于 <span class="math inline">\(B\in\mathcal{C}\)</span>, 故可以对 <span class="math inline">\(B\)</span> 使用第二条中使用的方法, 操作如下:</strong></p><p>取 <span class="math inline">\(A\in\Lambda(\mathcal{C})\)</span>, 则 <span class="math inline">\(\forall~B\in\mathcal{C}\)</span>, 由上条可知 <span class="math inline">\(A\in\Lambda_B\)</span>, 又由 <span class="math inline">\(\Lambda_B\)</span> 的定义可知 <span class="math inline">\(A\cap B\in\Lambda(\mathcal{C})\)</span>, 于是由 <span class="math inline">\(\Lambda_A\)</span> 的定义, <span class="math inline">\(B\in\Lambda_A\)</span>, 于是 <span class="math inline">\(\mathcal{C}\subset\Lambda_A\)</span>.</p><p>综上所述, 原命题得证.</p><h2 id="lambda-pi-系方法"><span class="math inline">\(\lambda-\pi\)</span> 系方法</h2><h3 id="lambda-pi-系方法-1"><span class="math inline">\(\lambda-\pi\)</span> 系方法</h3><p>在定理的证明过程中, “要证明一些元素的集合满足性质 <span class="math inline">\(p\)</span>, 就先把满足性质 <span class="math inline">\(p\)</span> 的元素集合设出来, 再证明该集合与原集合相等” 的方法常常按照如下方法操作:</p><p>已知 <span class="math inline">\(\mathcal{C}\)</span> 中元素具有性质 <span class="math inline">\(p\)</span>, 要证明 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 中元素也具有性质 <span class="math inline">\(p\)</span>, 则可以令 <span class="math inline">\(\Lambda=\{B\subset\Omega:B\text{具有性质}p\}\)</span>, 则 <span class="math inline">\(\Lambda\supset\mathcal{C}\)</span>, 然后证明 <span class="math inline">\(\mathcal{C}\)</span> 是 <span class="math inline">\(\pi\)</span> 系, 再证明 <span class="math inline">\(\Lambda\)</span> 是 <span class="math inline">\(\lambda\)</span> 系, 即可证明 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 中元素满足性质 <span class="math inline">\(p\)</span>.</p><p>这样的方法称为 <span class="math inline">\(\lambda-\pi\)</span> 系方法.</p><h3 id="lambda-pi-系方法的应用"><span class="math inline">\(\lambda-\pi\)</span> 系方法的应用</h3><h4 id="测度扩张定理的证明">测度扩张定理的证明</h4><p>证明见《测度与概率》（严士健、刘秀芳. 北京师范大学出版社.）P66-67 部分. 不再赘述.</p><h4 id="pi-系上的有限测度"><span class="math inline">\(\pi\)</span> 系上的有限测度</h4><blockquote><p>设 <span class="math inline">\(\mu,\nu\)</span> 是可测空间 <span class="math inline">\((\Omega,\mathcal{F})\)</span> 上的两个有限测度, <span class="math inline">\(\mathcal{C}\)</span> 为 <span class="math inline">\(\pi\)</span> 系, <span class="math inline">\(\Omega\in\mathcal{C}\)</span> 且 <span class="math inline">\(\sigma(\mathcal{C})=\mathcal{F}\)</span>. 若 <span class="math inline">\(\mu, \nu\)</span> 在 <span class="math inline">\(\mathcal{C}\)</span> 上一致, 则 <span class="math inline">\(\mu,\nu\)</span> 在 <span class="math inline">\(\mathcal{F}\)</span> 上也一致.</p></blockquote><p><strong>分析</strong>: 　　<span class="math inline">\(\mathcal{C}\subset\Lambda\)</span>, 要证明 <span class="math inline">\(\sigma(\mathcal{C})\subset\Lambda\)</span>, 考虑到 <span class="math inline">\(\mathcal{C}\)</span> 为 <span class="math inline">\(\pi\)</span> 系, 显然此处适用单调类定理.</p><p><strong>证明</strong>: 　　故证明 <span class="math inline">\(\Lambda\)</span> 是 <span class="math inline">\(\lambda\)</span> 系即可. 由单调类定理即得 <span class="math inline">\(\mathcal{F}\subset\Lambda\)</span>.</p><h4 id="另一形式的单调类定理">另一形式的单调类定理</h4><blockquote><p>　<span class="math inline">\(\Omega\)</span> 的子集类 <span class="math inline">\(\mathscr{M}\)</span> 称为 <span class="math inline">\(\Omega\)</span> 的<strong>单调类</strong>, 如果它满足:</p></blockquote><blockquote><ol type="1"><li>对不降集列的并封闭: 即 <span class="math inline">\(\{A_n\}_{n\in\mathbb{N}}\uparrow\subset\mathscr{M}\)</span>, 有 <span class="math inline">\(\bigcup\limits_{n=1}^\infty A_n\in\mathscr{M}\)</span>;</li><li>对不降集列的并封闭: 即 <span class="math inline">\(\{A_n\}_{n\in\mathbb{N}}\downarrow\subset\mathscr{M}\)</span>, 有 <span class="math inline">\(\bigcap\limits_{n=1}^\infty A_n\in\mathscr{M}\)</span>; 若 <span class="math inline">\(\mathscr{A}\)</span> 为 <span class="math inline">\(\Omega\)</span> 的集代数, 记包含 <span class="math inline">\(\mathscr{A}\)</span> 的最小单调类为 <span class="math inline">\(\mathfrak{M}(\mathscr{A})\)</span>, 则 <span class="math inline">\(\mathfrak{M}(\mathscr{A})=\sigma(\mathscr{A})\)</span>. 因而包含 <span class="math inline">\(\mathscr{A}\)</span> 的单调类必定包含 <span class="math inline">\(\sigma(\mathscr{A})\)</span>.</li></ol></blockquote><p><strong>分析</strong>: 　　先证明两个命题:</p><p>　　1. 若 <span class="math inline">\(\mathscr{A}\)</span> 同时为集代数和单调类, 则 <span class="math inline">\(\mathscr{A}\)</span> 是 <span class="math inline">\(\sigma\)</span> 代数; 　　2. <span class="math inline">\(\Omega\)</span> 的任意子集类 <span class="math inline">\(\mathcal{C}\)</span> 上的最小单调类存在.</p><p>其中第2条保证了单调类的 <span class="math inline">\(\mathfrak{M}(\mathscr{A})\)</span> 存在, 进而可利用第1条进行证明:</p><p>　　显然 <span class="math inline">\(\sigma(\mathscr{A})\)</span> 是单调类, 故 <span class="math inline">\(\sigma(\mathscr{A})\supset\mathfrak{M}(\mathscr{A})\)</span>, 故只需证 <span class="math inline">\(\sigma(\mathscr{A})\subset\mathfrak{M}(\mathscr{A})\)</span>;</p><p>　　为此只需证明 <span class="math inline">\(\mathfrak{M}(\mathscr{A})\)</span> 为包含 <span class="math inline">\(\sigma(\mathscr{A})\)</span> 的<span class="math inline">\(\sigma\)</span> 代数, 由命题 2, 只需证明 <span class="math inline">\(\mathfrak{M}(\mathscr{A})\)</span> 为集代数;</p><p>　　显然有 <span class="math inline">\(\Omega\in\mathscr{A}\subset\mathfrak{M}(\mathscr{A})\)</span>, 故只需证明 <span class="math inline">\(\mathfrak{M}(\mathscr{A})\)</span> 对差运算封闭.</p><p>接下来便是 <span class="math inline">\(\lambda-\pi\)</span> 证明的标准技巧: 　　令 <span class="math inline">\(M_A=\{B:B\in\mathfrak{M}(\mathscr{A}), A-B,B-A\in\mathfrak{M}(\mathscr{A})\}\)</span>, 接下来分三步证明:</p><ol type="1"><li>证明 <span class="math inline">\(M_A\)</span> 是单调类, <span class="math inline">\(\forall A\)</span>;</li><li><span class="math inline">\(\forall A\in\mathscr{A}\)</span>, <span class="math inline">\(M_A=\mathfrak{M}(\mathscr{A})\)</span>;</li><li><span class="math inline">\(\forall A\in\mathfrak{M}(\mathscr{A})\)</span>, <span class="math inline">\(M_A=\mathfrak{M}(\mathscr{A})\)</span>.</li></ol><p>以上即为证明思路.</p><p><strong>证明</strong>: 　　先证明两个引理.</p><blockquote><p><strong>引理 1</strong> 若 <span class="math inline">\(\mathscr{A}\)</span> 为 <span class="math inline">\(\Omega\)</span> 的集代数且是单调类, 则 <span class="math inline">\(\mathscr{A}\)</span> 为 <span class="math inline">\(\sigma\)</span> 代数.</p></blockquote><p><strong>引理 1的证明</strong>: 　　只需证明对于可列并封闭: 对 <span class="math inline">\(\forall \{A_n\}_{n\in\mathbb{N}}\subset\mathscr{A}\)</span> 构造部分和集列 <span class="math inline">\(B_n=\bigcup\limits_{i=1}^n A_i\)</span> 即可.</p><blockquote><p><strong>引理 2</strong> <span class="math inline">\(\Omega\)</span> 的任意子集类 <span class="math inline">\(\mathcal{C}\)</span> 上的最小单调类存在.</p></blockquote><p><strong>引理 2的证明</strong>:</p><p>　　首先证明非空: <span class="math inline">\(\Omega\)</span> 的全体子集 <span class="math inline">\(\mathcal{C}\subset\mathscr{P}(\Omega)\)</span> 显然构成单调类, 故非空;</p><p>　　其次构造出来: 取包含 <span class="math inline">\(\mathcal{C}\)</span> 的所有单调类的交, 容易验证该集类是一个单调类.</p><p>　　综上, 包含 <span class="math inline">\(\mathcal{C}\)</span> 的最小单调类存在且为所有包含 <span class="math inline">\(\mathcal{C}\)</span> 的单调类的交.</p><p>由这两个引理即可证明定理:</p><p>　　令 <span class="math inline">\(M_A=\{B:B\in\mathfrak{M}(\mathscr{A}), A-B,B-A\in\mathfrak{M}(\mathscr{A})\}\)</span>, 只需证明 <span class="math inline">\(M_A=\mathfrak{M}(\mathscr{A})\)</span>, <span class="math inline">\(\forall A\in\mathfrak{M}(\mathscr{A})\)</span>. 接下来分三步证明:</p><ol type="1"><li>证明 <span class="math inline">\(M_A\)</span> 是单调类, <span class="math inline">\(\forall A\)</span>;</li><li><span class="math inline">\(\forall A\in\mathscr{A}\)</span>, 证明 <span class="math inline">\(M_A=\mathfrak{M}(\mathscr{A})\)</span>;</li><li><span class="math inline">\(\forall A\in\mathfrak{M}(\mathscr{A})\)</span>, 证明 <span class="math inline">\(M_A=\mathfrak{M}(\mathscr{A})\)</span>. 　　 <strong>1. 证明 <span class="math inline">\(M_A\)</span> 是单调类, <span class="math inline">\(\forall A\)</span></strong> 　　取 <span class="math inline">\(A\in\mathfrak{M}(\mathscr{A})\)</span>, <span class="math inline">\(\forall\{B_n\}_{n\in\mathbb{N}}\uparrow\subset M_A\)</span>, 由 <span class="math inline">\(\mathfrak{M}(\mathscr{A})\)</span> 的定义即有 <span class="math inline">\(A-B_n,B_n-A,B_n\in\)</span>, 同时显然有 <span class="math inline">\(B_n-A\uparrow\)</span>, <span class="math inline">\(A-B_n\downarrow\)</span>. 由于 <span class="math inline">\(\mathfrak{M}(\mathscr{A})\)</span> 是单调类, 故 <span class="math inline">\(\bigcup\limits_{n=1}^\infty B_n\in\mathfrak{M}(\mathscr{A})\)</span>.</li></ol><p>　　同时还有: <span class="math display">\[\begin{align}A-\bigcup\limits_{n=1}^\infty B_n &amp;= A\cap\left(\bigcap\limits_{n=1}^\infty B_n^c\right) \\&amp;= \bigcap_{n=1}^\infty (A\cap B_n^c) \\&amp;= \bigcap_{n=1}^\infty (A-B_n) \in\mathfrak{M}(\mathscr{A})~; \\\left(\bigcup\limits_{N=1}^\infty B_n\right)-A &amp;= \bigcup\limits_{n=1}^\infty (B_n-A)\in\mathfrak{M}(\mathscr{A})~.\end{align}\]</span> 　　于是有 <span class="math inline">\(\bigcup\limits_{n=1}^\infty B_n\in M_A\)</span>, 即 <span class="math inline">\(M_A\)</span> 对上升集列的并封闭.</p><p>　　同理可证 <span class="math inline">\(M_A\)</span> 对下降集列的交也封闭. 即 <span class="math inline">\(M_A\)</span> 是单调类.</p><p><strong>2. <span class="math inline">\(\forall A\in\mathscr{A}\)</span>, 证明 <span class="math inline">\(M_A=\mathfrak{M}(\mathscr{A})\)</span></strong></p><p>　　若 <span class="math inline">\(A\in\mathscr{A}\)</span>, 则对 <span class="math inline">\(\forall B\in\mathscr{A}\)</span>, 有 <span class="math inline">\(A-B,B-A\in\mathscr{A}\subset\mathfrak{M}(\mathscr{A})\)</span>, 由 <span class="math inline">\(M_A\)</span> 的定义知 <span class="math inline">\(B\in M_A\)</span>, 即 <span class="math inline">\(\mathfrak{M}(\mathscr{A})\subset M_A\)</span>.</p><p>　　另一方面, 由上条知 <span class="math inline">\(M_A\)</span> 为包含 <span class="math inline">\(\mathscr{A}\)</span> 的单调类, 故 <span class="math inline">\(\mathfrak{M}(\mathscr{A})\subset M_A\)</span>, 故有 <span class="math inline">\(M_A=\mathfrak{M}(\mathscr{A})\)</span>.</p><p><strong>3. <span class="math inline">\(\forall A\in\mathfrak{M}(\mathscr{A})\)</span>, 证明 <span class="math inline">\(M_A=\mathfrak{M}(\mathscr{A})\)</span></strong></p><p>　　考虑 <span class="math inline">\(B\in\mathfrak{M}(\mathscr{A})\)</span>, 则对 <span class="math inline">\(\forall A\in\mathscr{A}\)</span>, 由上条知 <span class="math inline">\(M_A=\mathfrak{M}(\mathscr{A})\)</span>, 于是 <span class="math inline">\(B\in M_A\)</span>. 进一步由 <span class="math inline">\(M_A\)</span> 的定义有 <span class="math inline">\(B-A,A-B\in\mathfrak{M}(\mathscr{A})\)</span>.</p><p>　　又由于 <span class="math inline">\(\mathscr{A}\subset\mathfrak{M}(\mathscr{A})\)</span>, 故 <span class="math inline">\(A\in\mathfrak{M}(\mathscr{A})\)</span>, 结合 <span class="math inline">\(M_B\)</span> 的定义有 <span class="math inline">\(A\in M_B\)</span>.</p><p>　　即 <span class="math inline">\(\forall A\in\mathscr{A}\)</span>, 总有 <span class="math inline">\(A\in M_B\)</span>. 于是 <span class="math inline">\(\mathscr{A}\subset M_B\)</span>. 即 <span class="math inline">\(M_B\)</span> 是包含 <span class="math inline">\(\mathscr{A}\)</span> 的单调类, 于是 <span class="math inline">\(\mathfrak{M}(\mathscr{A})\subset M_B\)</span>.</p><p>　　结合 <span class="math inline">\(M_B\subset \mathfrak{M}(\mathscr{A})\)</span>, 即有 <span class="math inline">\(M_B=\mathfrak{M}(\mathscr{A})\)</span>, <span class="math inline">\(\forall B\in\mathfrak{M}(\mathscr{A})\)</span>. 　　 <strong>综上所述,</strong> 若 <span class="math inline">\(\mathscr{A}\)</span> 为集代数, 则包含 <span class="math inline">\(\mathscr{A}\)</span> 的最小 <span class="math inline">\(\sigma\)</span> 代数与包含 <span class="math inline">\(\mathscr{A}\)</span> 的最小单调类相同.</p><h2 id="函数形式的单调类定理">函数形式的单调类定理</h2><h3 id="mathscrl-系"><span class="math inline">\(\mathscr{L}\)</span> 系</h3><p>设 <span class="math inline">\(\mathscr{L}\)</span> 是定义在 <span class="math inline">\(\Omega\)</span> 上的广义实函数类, 满足: <span class="math inline">\(f\in\mathscr{L}\Rightarrow f^+,f^-\in\mathscr{L}\)</span>. 函数族 <span class="math inline">\(L\)</span> 称为 <span class="math inline">\(\mathscr{L}\)</span> 系, 如果满足:</p><ol type="1"><li><span class="math inline">\(1\in L\)</span>;</li><li><span class="math inline">\(L\)</span> 中有限个函数的线性组合(如果有意义)属于 <span class="math inline">\(L\)</span>;</li><li>若 <span class="math inline">\(f_n\in L\)</span>, <span class="math inline">\(n\in\mathbb{N}\)</span>, <span class="math inline">\(0\leqslant f_n\uparrow f\)</span>, <span class="math inline">\(f\)</span> 有界或 <span class="math inline">\(f\in\mathscr{L}\)</span>, 则 <span class="math inline">\(f\in L\)</span>.</li></ol><h3 id="单调类定理-1">单调类定理</h3><blockquote><p>若 <span class="math inline">\(\mathscr{L}\)</span> 系 <span class="math inline">\(L\)</span> 包含一 <span class="math inline">\(\pi\)</span> 系 <span class="math inline">\(\mathcal{C}\)</span> 中任意集合的示性函数, 则 <span class="math inline">\(L\)</span> 包含所有属于 <span class="math inline">\(\mathscr{L}\)</span> 的 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 可测函数.</p></blockquote><p><strong>证明</strong>:</p><p>　　令 <span class="math inline">\(\Lambda=\{A\subset\Omega: I_A\in L\}\)</span>, 则由 <span class="math inline">\(\mathscr{L}\)</span> 系定义可知 <span class="math inline">\(\Omega\in\Lambda\)</span>, <span class="math inline">\(\Lambda\)</span> 对真差封闭并且对不降集列的并封闭, 因而 <span class="math inline">\(\Lambda\)</span> 为 <span class="math inline">\(\lambda\)</span> 系. 又由于 <span class="math inline">\(\mathcal{C}\subset\Lambda\)</span>, 且 <span class="math inline">\(\mathcal{C}\)</span> 为 <span class="math inline">\(\pi\)</span> 系, 结合集合形式的单调类定理可知 <span class="math inline">\(\sigma(\mathcal{C})\subset\Lambda\)</span>, 故 <span class="math inline">\(\{I_A: A\in\sigma(\mathcal{C})\}\subset L\)</span>. 由定义可知 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 上的任意简单函数在 <span class="math inline">\(L\)</span> 中.</p><p>　　设 <span class="math inline">\(f\)</span> 为 <span class="math inline">\(\mathscr{L}\)</span> 中非负 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 可测函数, 则存在非负不降 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 简单函数列 <span class="math inline">\(f_n\uparrow f\)</span>. 由于 <span class="math inline">\(L\)</span> 是 <span class="math inline">\(\mathscr{L}\)</span> 系, 故 <span class="math inline">\(f\in L\)</span>.</p><p>　　若 <span class="math inline">\(f\in\mathscr{L}\)</span> 且 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 可测, 则由 <span class="math inline">\(\mathscr{L}\)</span> 的定义可知 <span class="math inline">\(f^+,f^-\in\mathscr{L}\)</span> 且非负 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 可测, 于是 <span class="math inline">\(f^+,f^-\in L\)</span>, 结合 <span class="math inline">\(f=f^+-f^-\)</span> 有意义及定义可知 <span class="math inline">\(f\in L\)</span>. 定理得证.</p><h2 id="mathscrl-系方法"><span class="math inline">\(\mathscr{L}\)</span> 系方法</h2><h3 id="mathscrl-系方法-1"><span class="math inline">\(\mathscr{L}\)</span> 系方法</h3><p>要想证明某一函数族 <span class="math inline">\(F\)</span> 具有某种性质 <span class="math inline">\(p\)</span>, 为此设一个函数族 <span class="math inline">\(\mathscr{L}\)</span>, s.t. <span class="math inline">\(L=\{f: 函数 f 具有性质 p\}\)</span> 为一个 <span class="math inline">\(\mathscr{L}\)</span> 系. 再引入一个 <span class="math inline">\(\pi\)</span> 系 <span class="math inline">\(\mathcal{C}\)</span>, s.t. <span class="math inline">\(\mathscr{L}\)</span> 中的 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 可测函数类包含 <span class="math inline">\(F\)</span>.</p><p>以上两步完成之后, 由单调类定理, 只要证明 <span class="math inline">\(\forall A\in\mathcal{C}\)</span>, <span class="math inline">\(I_A\in L\)</span> 即可. 这种方法被称为 <span class="math inline">\(\mathscr{L}\)</span> 系方法.</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 概率论 </tag>
            
            <tag> 测度论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GRE阅读题目分析[4]</title>
      <link href="/2017/07/25/GRE%E9%98%85%E8%AF%BB%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%5B4%5D/"/>
      <content type="html"><![CDATA[<p>GRE 阅读的一点小小的总结.</p><a id="more"></a><h2 id="题型辨识">题型辨识</h2><h3 id="事实信息类">事实信息类</h3><h4 id="事实信息">事实信息</h4><ol type="1"><li>单纯事实信息<ul><li>The passage makes which of the following claims (about X)?</li><li>The passage claims which of the following (about X)?</li><li>The passage suggests which of the following about X?</li><li>The passage would probably agree with which of the following claims (about X)?</li><li>(According to the passage,) which of the following claims (about X) is true?</li><li>(According to the passage,) X.</li><li>Which of the following best characterizes the “X” that the author refers to?</li><li>Which of the following claims about X can be inferred from the passage?</li><li>It can be inferred from the passage that X.</li><li>It can be inferred that the author would agree with which of the following (claims about X)?</li><li>Information presented in the passage suggests which of the following about X?</li><li>Information in the passage best supports which of the following claims about X?</li><li>With which of the following claims (about X) (discussed in the passage) would the author most likely agree?</li></ul></li><li>结合逻辑的事实信息<ul><li>According to the passage, X had which of the following effects for …?</li><li>According to the passage, the primary purpose of X is to …</li><li>The passage mentions which of the following as one of the reasons X?</li><li>According to the passage, X in that …</li></ul></li><li>结合视角的事实信息<ul><li>According to the passage, S would agree that X.</li><li>According to the passage, which of the following is the most accurate statement of what S about Earth’s X?</li><li>The passage implies that S1 attributed which of the following beliefs to S2?</li><li>The author of the passage and S would most likely agree/disagree with which of the following (claims about X)?</li></ul></li></ol><h4 id="反事实信息">反事实信息</h4><ul><li>Each of the following is mentioned in the passage as X EXCEPT for the …</li></ul><h4 id="问题">问题</h4><ul><li>The passage supplies information for answering which of the following questions?</li></ul><h4 id="反问题">反问题</h4><ul><li>The passage supplies information for answering all of the folliwing questions EXCEPT:</li></ul><h4 id="加强">加强</h4><ul><li>Which of the following statements, if true, wuold provide the strongest support/most strengthen X?</li></ul><h4 id="削弱">削弱</h4><ul><li>Which of the following if true, would most call into question/pose the greatest challenge to/most tend to weaken X?</li><li>Which of the following is the most logical objection to X?</li><li>X would be most seriously undermined if which of the following were true?</li><li>Which of the following, if true, would provide the LEAST support for X?</li></ul><h4 id="假设">假设</h4><ul><li>In the highlighted portion of the passage, the S assumes that …</li><li>The claim in the highlighted sentence assumes which of the following about X?</li></ul><h4 id="态度">态度</h4><ul><li>The attitude of the author of the passage toward X can best be described as …</li><li>Which of the following best describes the author’s attitude toward X?</li></ul><h4 id="有保留的支持">有保留的支持</h4><ul><li>Qualified approval: 有让步存在.</li></ul><h3 id="信息功能类">信息功能类</h3><h4 id="信息功能">信息功能</h4><ul><li>The author mentions X most primarily/probably/most likely in order to …</li><li>By quoting X, the author of the passage most clearly succeeds in …</li><li>Which of the following best describes the function of the highlighted sentence (in the passage)?</li><li>(In the passage,) the function of the highlighted portion is to …</li><li>(In the passage,) the mention of X serves primarily to …</li><li>(In the passage,) the highlighted portion servers primarily to …</li><li>The highlighted sentence has which of the following functions in the passage?</li><li>The highlighted sentence exemplifies which of the following?</li><li>X is presented in the poassage primarily as [存疑]</li></ul><h4 id="选句子">选句子</h4><ul><li>Select the sentence that …</li><li>Click on the sentence in the passage that …</li></ul><h4 id="论证结构">论证结构</h4><ul><li>Which of the following best characterizes/describes the organization of the passage as a whole?</li></ul><h3 id="主旨">主旨</h3><ul><li>Which of the following best describes the main/central idea of the passage?</li><li>The primary purpose of the passage is to (discuss which of the following?)</li><li>The passage is primarily concerned with (doing which of the following)</li><li>The passage is structured to lead to the conclusion that …</li><li>Which of the following generalizations most directly underlies the author’s central point?</li></ul><h3 id="词汇">词汇</h3><ul><li>In the context in which it appears, “X” most nearly means …</li><li>Replacement of the word “X” with which of the following results in the least change in meaning for the passage?</li></ul><h3 id="类比">类比</h3><ul><li>Which of the following is most similar to/is most closely analogous to/most closely parallels X?</li></ul>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
            <tag> GRE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GRE填空思路分析[3]——推理的线索来源·同义线索</title>
      <link href="/2017/07/24/GRE%E5%A1%AB%E7%A9%BA%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90%5B3%5D%E2%80%94%E2%80%94%E6%8E%A8%E7%90%86%E7%9A%84%E7%BA%BF%E7%B4%A2%E6%9D%A5%E6%BA%90%C2%B7%E5%90%8C%E4%B9%89%E7%BA%BF%E7%B4%A2/"/>
      <content type="html"><![CDATA[<p>GRE 填空的一点小小的总结.</p><blockquote><p>同义重复线索一般有四种: <strong>简单重复解释、因果关系、递进关系、指代关系</strong>.</p></blockquote><a id="more"></a><h2 id="简单重复解释">简单重复解释</h2><p>尽管是“简单”重复解释, 但此类题目并不简单.</p><p>简单重复解释的标志一般有以下几种:</p><ul><li>冒号: 对相关线索的解释;</li><li>分号: 表示分号前后信息的重复;</li><li>修饰解释结构:<ul><li>……, 解释成分, (定语从句/同位语从句/分词短语);</li><li>…… n., 解释成分.</li></ul></li></ul><p>直白地说, 简单重复解释就是两部分内容一致.</p><p>例如下面一道难题:</p><blockquote><p>例: In modern times, friendship has become a ____ relationship: a form of connection in terms of which all are understood and against which all are measured.<br>A. conciliatory<br>B. mercenary<br>C. paradigmatic<br>D. contentious<br>E. supplementary</p></blockquote><p>文章在冒号前的部分指出: 现在, 友谊成为了一种 X 的关系. 冒号后则指出: 所有的东西都是通过友谊来理解和度量的. 本题的难点主要就在于冒号后句子的理解. in terms of 后面的 which 指代的是之前的 a form of connection. 同理, against 后的 which 也指的是这种特定的 connection. 由于 against 与 in terms of 中间用 and 连接, 实际上意思是类似的. 所以冒号后的整个句子意思为: 所有的(all)东西都是通过 friendship 来理解和度量的, 所以 X 应该是一个表示“标准”的词语. 故选择 C. paradigmatic 意为“典范”.</p><p>一道容易错的题目如下:</p><blockquote><p>例: Scholarly works on detective stories often begin with (i)____, suggesting that there is something vaguely wrong with adults who spend their time reading such f iction and certainly something (ii)____ those who devote energy to its analysis.</p></blockquote><table><thead><tr class="header"><th style="text-align: left;">Blank(i)</th><th style="text-align: left;">Blank(ii)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">A. chronologies</td><td style="text-align: left;">D. awry in</td></tr><tr class="even"><td style="text-align: left;">B. apologies</td><td style="text-align: left;">E. astute about</td></tr><tr class="odd"><td style="text-align: left;">C. synopses</td><td style="text-align: left;">F. courageous about</td></tr></tbody></table><p>文中虽然没有出现冒号和分号, 但在第一空后有一个 suggesting, 说明 suggesting 前后说的是同一件事.</p><ul><li>前: 关于侦探小说的研究时常以 X 开头;</li><li>后: and 前后同样应该说的是同一件事.<ul><li>前: adults 读侦探小说是错误的;</li><li>后: 在侦探小说的分析上耗费能量是 Y 的.</li></ul></li></ul><p>由 suggesting 后的句子的内部结构即可选出第二空为 D. awry in, 意为“错误”. 至此 suggesting 后的部分已经完整, 意为“读侦探小说是错误的”. 考虑第一空的答案, 只有 B. apologies 满足条件.</p><p>还有两道难题如下:</p><blockquote><p>例: The new art museum’s (i)____ building a ugurs well for that ambitious institution because it speaks of (ii)____ contemporary architecture on the part of the board of directors that may (iii)____ equal astuteness about contemporary art.</p></blockquote><table><thead><tr class="header"><th style="text-align: left;">Blank(i)</th><th style="text-align: left;">Blank(ii)</th><th style="text-align: left;">Blank(iii)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">A. nondescript</td><td style="text-align: left;">D. a discernment about</td><td style="text-align: left;">G. conceal</td></tr><tr class="even"><td style="text-align: left;">B. outstanding</td><td style="text-align: left;">E. a hostility toward</td><td style="text-align: left;">H. supplant</td></tr><tr class="odd"><td style="text-align: left;">C. outdated</td><td style="text-align: left;">F. an intoxication by</td><td style="text-align: left;">I. promise</td></tr></tbody></table><p>首先考虑第一空. 文章首先指出了博物馆的建筑具有 X 特点, 这预示着他们很有野心. 从这个很有野心出发, 可知他们的建筑也一定是具有一些很厉害的特点, 容易选出 A 选项.</p><p>文章随后开始解释原因. 整句话是一个 it speaks of … that … 的结构, 于是 that 前后说的应该是同一件事情:</p><ul><li>前: 董事会就现代建筑的 X 而言 <span class="math inline">\(\Rightarrow\)</span> 董事会对于现代建筑具有 X;</li><li>后: 可能会 Y 董事会对当代艺术同等的机智.</li></ul><p>其实本来挺明白的意思稍微翻译一下变得狗屁不通。。在 that 后边出现了一个 equal astuteness, 说明 that 之前也一定得有一个 astuteness, 于是只能在空格处, 故第二空应选 D. a discernment about. 至此 that 前的部分已经完整, 意为“董事会对现代建筑具有机智(什么垃圾东西)”. 故 that 后的部分也应表达这个方向的意思, 故 that 之后的部分意思应为“董事会对当代艺术也有着同等的机智”, 这中间的连接词便应选择 I. promise. 完整的意思便是“董事会对现代建筑所表现出的机智暗示着他们可能对当代艺术也有着同等的机智.”</p><p>与前一部分合并起来, 整句话的意思就是: <strong>新美术馆杰出的建筑预示着他们很有野心, 因为董事会对现代建筑所表现出的机智暗示着他们可能对当代艺术也有着同等的机智.</strong> MD, 真别扭.</p><blockquote><p>例: Belanger dances with an (i)____ that draws ones attention as if by seeking to (ii)____ it; through finesse and understatement, he manages to seem at once intensely present and curiously detached.</p></blockquote><table><thead><tr class="header"><th style="text-align: left;">Blank(i)</th><th style="text-align: left;">Blank(ii)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">A. undermonstrative panache</td><td style="text-align: left;">D. focus</td></tr><tr class="even"><td style="text-align: left;">B. unrestrained enthusiasm</td><td style="text-align: left;">E. overwhelm</td></tr><tr class="odd"><td style="text-align: left;">C. unattractive gawkiness</td><td style="text-align: left;">F. deflect</td></tr></tbody></table><p>文章中有分号出现, 说明前后两部分说的是同一件事:</p><ul><li>前: Belanger 的舞蹈伴随着一种 X, 通过 Y 的方式吸引着人们的注意;</li><li>后: 通过故意设计出的技巧和 understatement, 他能够非常神奇地既保持 detached, 又表现出强烈的感情.</li></ul><p>考虑前后两部分之间的对应, finesse and understatement 的对应点应是第一空 understatement 在这里的意思应是“不完全的展现”, 故对比语义可以选出 A. undemonstrative panache.</p><p>接下来考虑第二空, Belanger 为了吸引大家的关注, 用了 Y 手段. it 指代的是前文的 attention, 正常情况下, 吸引大家的关注应采取 focus 的手段. 但考虑到后文的 curiously 以及 undemonstrative panache, 这种低调的炫酷, 应该选择 focus 的反面, 即 F.</p><h2 id="因果关系">因果关系</h2><p><strong>因果关系的基本原则</strong>: 因果等价——有什么原因, 就有什么结果(因为爱, 所以爱). <strong>因果关系的重要标志</strong>:</p><ul><li>given…: 考虑到, 由于;</li><li>in that…: 因为;</li><li>so…that…: 非常…因为… .</li></ul><p>以下是两个例子:</p><blockquote><p>例: The politician’s record while in office, though (i)____, hardly accounts for her high standing three decades later–a standing all the more (ii)____ because of continuing assaults on her reputation during those years.</p></blockquote><table><thead><tr class="header"><th style="text-align: left;">Blank(i)</th><th style="text-align: left;">Blank(ii)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">A. bewildering</td><td style="text-align: left;">D. unusual</td></tr><tr class="even"><td style="text-align: left;">B. admirable</td><td style="text-align: left;">E. regrettable</td></tr><tr class="odd"><td style="text-align: left;">C. unappreciated</td><td style="text-align: left;">F. persistent</td></tr></tbody></table><p>文章的大概结构为: 这个政客在办公室里的纪录尽管非常 X, 但仍然很难对她在30年之后如此高的地位做出解释——这些年来对她持续不断的批评攻击使得这个地位更加的 Y.</p><p>破折号前边是一个转折, 前后意思应相反, 故 X 应该是“牛b”的意思, 故选择 B, 令人尊敬.</p><p>破折号后边是一个因果关系, 原因的部分指出这些年来她遭受着持续不断的攻击, 但仍然能到达了如此高的地位, 所以这应该是很不寻常的, 选择 D.</p><blockquote><p>例: The gaps in existing accounts of the playwright’s life are not (i)____, since much of the documentary evidence on which historians have relied is (ii)____.</p></blockquote><table><thead><tr class="header"><th style="text-align: left;">Blank(i)</th><th style="text-align: left;">Blank(ii)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">A. trifling</td><td style="text-align: left;">D. credible</td></tr><tr class="even"><td style="text-align: left;">B. obvious</td><td style="text-align: left;">E. extent</td></tr><tr class="odd"><td style="text-align: left;">C. implicit</td><td style="text-align: left;">F. incomplete</td></tr></tbody></table><p>文章在第一空的后边出现了 since, 意味着前后的部分存在对应关系, 故可以寻找两部分之间的对应.</p><ul><li>since 前: 对剧作家生平的解释中的 gap 并不 X;</li><li>since 后: 很多被历史学家所相信的证据都是 Y 的.</li></ul><p>两句话的结构都非常简单, 都是“A 具有特征 B”, 由此可以得到, 两个空格之间是互相关联的. 于是无法直接求解两个空格的答案, 只能逐个考虑.</p><p>第一空显然是不能选择 C 的, C 选项意为“含蓄”, 用来形容 gap 显然是不恰当的.</p><p>若第一空选择 A, 则前半句的意思为“对于剧作家生平的解释之间, 差异并不是很小的”, 也就是在说“这些解释是完全不靠谱的”, 因为彼此之间差异很大. 于是后半句也应表示“这些解释压根儿不靠谱”, 故第二空选择 F. 至此, AF 是可行的方案.</p><p>若第二空选择 B, 则前半句的意思为“对于剧作家生平的解释之间, 差异并不明显”, 后半句应选择一个“靠谱的证据”, 故选择 D 选项. 此时 BD 看起来也是很合理的一个答案…</p><p>嗯 官方给出的答案是 AF…</p><h2 id="递进关系">递进关系</h2><p><strong>递进关系的基本原则</strong>: 表示前后程度的加深或变浅. <strong>递进关系的重要标志</strong>:</p><ul><li><strong>Even</strong>: 句首让步, 句中递进;</li><li><strong>indeed</strong>: 进一步地讨论;</li><li><strong>almost, not only…but also…</strong>;</li><li><strong>not just…but downright</strong>: 不仅…更是彻底的…;</li><li><strong>at best…, at worst…</strong>: 说好听了…, 说不好听了…;</li><li><strong>at least</strong>: 至少, 表示对前面的削弱.</li></ul><p>以下是一道很长的题…:</p><blockquote><p>例: The order applies to all Federal agency whose actions may affect the status of invasive species and requires agencies to identify such actions and to the extent parcticable and permitted by law, and since invasive species severely reduce the number of native species and <strong>even</strong> (i)____ their existence, the agency has determined and made public its determination that the benefits of such actions clearly outweigh the potential harm caused by invasive species; and that all feasible <strong>and</strong> (ii)____ measures to (iii)____ risk of harm of the introduction of invasive species will be taken in conjunction with the actions.</p></blockquote><table><thead><tr class="header"><th style="text-align: left;">Blank(i)</th><th style="text-align: left;">Blank(ii)</th><th style="text-align: left;">Blank(iii)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">A. escalate</td><td style="text-align: left;">D. prudent</td><td style="text-align: left;">G. remedy</td></tr><tr class="even"><td style="text-align: left;">B. preclude</td><td style="text-align: left;">E. mawkish</td><td style="text-align: left;">H. counterbalance</td></tr><tr class="odd"><td style="text-align: left;">C. diminish</td><td style="text-align: left;">F. braggart</td><td style="text-align: left;">I. minimize</td></tr></tbody></table><p>第一空之前有一个 even, 说明 X their existence 是对 severely reduce 的程度加深, 故应选择 B, 阻碍它们的生存. 第二空与 feasible 之间用 and 连接, 说明 Y 与 feasible 方向相同, 故选择 D, 意为谨慎. 前文一直在讲物种入侵的内容, 那么这些方法必然是降低物种入侵带来的危害的, 故之坑考虑 HI 选项. 若选 H, 则意为“抵消风险”, 从根本上来将, 风险是不能抵消的, 因为风险是客观存在的一种东西, 无法被抵消, 只能被弱化. 故第三空应选择 I.</p><p>综上所述, 选择 BDI.</p><p>以下是 not just… but downright… 的一个例子:</p><blockquote><p>例: Making loans and fighting poverty are normally two of the least glamorous pursuits around, but remarkable enough put the two together, and you have an economic innovation that has become not just (i)____ but downright ____.</p></blockquote><table><thead><tr class="header"><th style="text-align: left;">Blank(i)</th><th style="text-align: left;">Blank(ii)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">A. popular</td><td style="text-align: left;">D. chic</td></tr><tr class="even"><td style="text-align: left;">B. pointless</td><td style="text-align: left;">E. unfathomable</td></tr><tr class="odd"><td style="text-align: left;">C. dangerous</td><td style="text-align: left;">F. sensible</td></tr></tbody></table><p>看到 not just… but downright… 的结构, 很容易知道 X→Y 是递进的关系, 观察选项只能选择 A(流行) 和 D(时髦).</p><h2 id="指代关系">指代关系</h2><p><strong>指代关系的基本原则</strong>:</p><ul><li>such…, this…, the former…, the equal…, the same… 这些词后提及的名词一定在前文出现过;</li><li>物主代词+空格, 则前文一定提到过.</li></ul><p>以下是一个例子:</p><blockquote><p>例: Though extremely (i)____ about his own plans, the man allowed his associates no such privacy and was constantly (ii)____ information about what they intended to do next.</p></blockquote><table><thead><tr class="header"><th style="text-align: left;">Blank(i)</th><th style="text-align: left;">Blank(ii)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">A. candid</td><td style="text-align: left;">D. soliciting</td></tr><tr class="even"><td style="text-align: left;">B. idiosyncratic</td><td style="text-align: left;">E. altering</td></tr><tr class="odd"><td style="text-align: left;">C. reticent</td><td style="text-align: left;">F. eschewing</td></tr></tbody></table><p>文章整体是一个转折的结构: 尽管他对于自己的计划非常 X, 但他却总是 Y 别人下一步的动作.</p><p>考虑到转折, 前后的意思一定是相反的, 而后半句中出现了 such privacy, 故这个 privacy 一定在前文出现过, 故只能是在空格处, 故第一空应选择表示“保护隐私”的词语, 故选择 C 沉默寡言. 考虑到转折, 后文一定是“不尊重隐私”的意思, 故选择 D 渴求, 不断打听. 整体的意思为: 尽管他对自己的计划保持沉默, 但他却不遗余力地打听其他人下一步的动作.</p><p>一道难题如下:</p><blockquote><p>例: To label Hamilton a foreigner because he was born outside what later became the United States is to assume anachornistically the existence of the nation before the fact. It is true that Hamilton ame to believe that he was a (i)____ the United States, but his (ii)____ was stemmed not from his (iii)____ but from his confrontation with American democracy which he considered to be a disease afflicting the nation.</p></blockquote><table><thead><tr class="header"><th style="text-align: left;">Blank(i)</th><th style="text-align: left;">Blank(ii)</th><th style="text-align: left;">Blank(iii)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">A. symbol of</td><td style="text-align: left;">D. alienation</td><td style="text-align: left;">G. ideology</td></tr><tr class="even"><td style="text-align: left;">B. stranger in</td><td style="text-align: left;">E. ambition</td><td style="text-align: left;">H. profession</td></tr><tr class="odd"><td style="text-align: left;">C. citizen of</td><td style="text-align: left;">F. patriotism</td><td style="text-align: left;">I. birthplace</td></tr></tbody></table><p>文章的第一句话没有设空, 意思为: 因 Hamilton 没有出生在这个后来叫做美国的地方就称 Hamilton 为外国人是不恰当的, 因为在美国建立之前就将这个地方成为美国是时代错误的. 由此我们可以得到:</p><ol type="1"><li>Hamilton 确实没有出生在美国的土地上;</li><li>不能直接称 Hamilton 为外国人.</li></ol><p>考察第一空, 整句为 It is true that… but… 的结构, 故 It is true… 的部分应是一个让步, 故这句话表达的意思应是“Hamilton 确实有些像个外国人”, 故第一空应填 B.</p><p>第二空是题目的难点. 前半句说了“尽管 Hamilton 看起来确实很奇怪”, 故后半句应回到文章的管线“Hamilton 不能因为不生在美国土地就被称为外国人”上面来. 考虑至此, 第三空的答案已经得出, 应选择 I 选项. 继续推断, 可推测出第二空应选择 D.</p><p>第二句整体的意思为: 虽然 Hamilton 在美国看起来确实很奇怪, 但他的疏离并非源于他的出生地, 而是他对于美国民主的反对.</p><p>综上所述, 本题应选择 BDI.</p><p>另一道难题也是三空题:</p><blockquote><p>例: Recent proposals for fixing the climate have taken the form of large-scale geoengineering projects such as launching mirrors into space to reflect solar radiation away from Earth, undertaking that are vastly more (i)____ than anything a nineteenth-century rainmaker could have cooked up. What is unclear, as one looks back at the history of weather modification research, is whether this resourceful ambition will be (ii)____, or if, by contrast, it serves to make the scientific community’s (iii)____ that much more devastating.</p></blockquote><table><thead><tr class="header"><th style="text-align: left;">Blank(i)</th><th style="text-align: left;">Blank(ii)</th><th style="text-align: left;">Blank(iii)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">A. effective</td><td style="text-align: left;">D. anticipate</td><td style="text-align: left;">G. avidity</td></tr><tr class="even"><td style="text-align: left;">B. enterprising</td><td style="text-align: left;">E. challenged</td><td style="text-align: left;">H. impotence</td></tr><tr class="odd"><td style="text-align: left;">C. accessible</td><td style="text-align: left;">F. productive</td><td style="text-align: left;">I. resignation</td></tr></tbody></table><p>最近“向空中发射一个镜子反射太阳辐射以改善气候”的提案是远比19世纪的 rainmaker 编造的东西更 X 的任务. 但当你回头审视人们对于修改天气的研究的时候, this resourceful ambition 是否会 Y 依然不甚清楚, 或者相反, 他会使得科学界的 Z 更加具有破坏力.</p><p>注意到文中有 this resourceful ambition… 存在指代关系, 于是 resourceful ambition 一定在前文提到过, 经过比较可以确定对应位置在第一空处. 接下来需要明确 resourceful ambition 的含义, resourceful 的意思是“能在困难中有效地处理”, 一般有两种解读, 一种是有效的(effective), 一种是有创造力的(imaginative). 对应到第一空的选项, 分别可以选择 A. 有效 和 B. 创新. 至此还没有有效的证据对此处的意思进行推定.</p><p>继续考虑第二和第三空, 第三空后的 that 此处等价于 so, 表示强调. 能使得 Z 更具有破坏力, 说明 Z 本身就具有破坏力, 故此处应填负面评价的词汇, 考察选项, 应选择 H. 此处应注意, G. avidity 不能翻译为“贪婪”, 事实上 avidity 约等于 ambition. 由 by contrast, 反推第二空应填正面评价的词, 考察选项可选出 F, 事实上 productive 也恰好就是 impotence 的反义词.</p><p>现在回头去思考第一空, 我们已经大约知道了 X = resourceful, 故第二空所在的句子意思为“这种 X 的 ambition 是否有效还不清楚”. 若第一空选择 A, 则与该句矛盾, 故第一空只能选择 B.</p><p>总结以下, 解题的思路是:</p><ol type="1"><li>this resourceful ambition… → X=resourceful → X=A/B;</li><li>Z 是有破坏力的 → Z=H;</li><li>by contrast… + 2 → Y=F → ambition是否有效还不清楚;</li><li>3 + 1 → X<span class="math inline">\(\neq\)</span>A → X=B.</li></ol><p>综上所述, 本题答案为 BFH.</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
            <tag> GRE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GRE阅读题目分析[3]</title>
      <link href="/2017/07/23/GRE%E9%98%85%E8%AF%BB%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%5B3%5D/"/>
      <content type="html"><![CDATA[<p>GRE 阅读的一点小小的总结.</p><a id="more"></a><h2 id="如何读信息">如何读信息</h2><h3 id="意群信息提取原则">意群信息提取原则</h3><p>始终默认所读的逻辑关系是成立的, 寻找概括、补充、修正关键信息次, 以验证已经确定的关系.</p><h4 id="顺-3种情况">顺: 3种情况</h4><ol type="1"><li>同义改写: =——前后完全相同;</li><li>举例: <span class="math inline">\(\in\)</span>——例子符合逻辑;</li><li>理由: 联系, 补足理由与观点之间的gap<ul><li>e.g. 万炜会成功的, 因为他很努力. (努力就会成功)</li><li>e.g. 万炜一定会成功的, 因为努力的人都成功了. (万炜一定很努力)</li></ul></li></ol><h4 id="转-质疑挑双方的异同补足反驳理由和结论之间的gap">转: 质疑——挑双方的异同/补足反驳理由和结论之间的gap</h4><ul><li>e.g. 主流观点认为万炜帅, 但其实只在学校比较帅.</li><li>e.g. 主流观点认为万炜聪明, 但他GRE挂了. (聪明人不会挂GRE)</li><li>e.g. 主流观点认为万炜聪明, 可聪明的人应该过了GRE. (万炜一定没有过GRE)</li></ul><h4 id="比-类比对比">比: 类比/对比</h4><ol type="a"><li>对比: A vs B.</li><li>类比: A <span class="math inline">\(\approx\)</span> B.</li></ol><h2 id="观点单一的文章">观点单一的文章</h2><blockquote><p>George Milner cites three primary problems with the labeling of Cahokia, the large archeological site by the Mississippi River, as a state rather than a chiefdom. First, finds at Cahokia are essentially similar to finds at other Mississippian chiefdoms, except that the amount of earth moved in building the mounds at Cahokia was greater than else where. Second, fewer people lived at Cahokia than is commonly estimated (Milner estimates that there were only a few thousand inhabitants, more common estimates are 10,000 or 20,000 inhabitants); therefore, extensive taxes, and tribute were not necessary to support them. Finally, while there is evidence of extensive earth movement, craftwork, trade, and elite at Cahokia, this does not indicate that Cahokia was politically centralized, economically specialized of aggressively expansionistic.</p></blockquote><blockquote><p>The passage implies that political centralization is a feature that<br>A. has not historically tended to emerge in centers with fewer than 20,000 inhabitants<br>B. distinguished other Mississippian chiefdoms from Cahokia<br>C. is considered characteristic of state but not of chiefdoms<br>D. often results from aggressive expansionism and sconomic specialization<br>E. has historically been necessary for extensive trade to occur</p></blockquote><p>文章开头指出, George Milner 认为, Cahokia 应该是 chiefdom, 而不是 state. 需要注意 “cite three problems” 的意思应该是负面的, 认为后面的句子是不正确的. 故 GM 应该不认同 Cah 是 state, 而认为 Cah 是 chief 的. 简记为 GM: cah=chief vs. state.</p><p>随后文章开始逐一解释 GM 的三个问题:</p><ol type="1"><li>Cah 与 chief 很相似, 除了土比较多. 把握住文章的第一句话, 考虑到本句不可能是新信息, 故GM不具备的特点应该就是 state 的特点. 于是可以建立符号对应: state: 土多;</li><li>cah 具有人少的特点, 并且不需要 tax, trade 和 tribute (记为 3t). 继续扣住文章第一句话, 本句就是在说 chief→人少, 不需要3t. 继续推理可得, state→人多, 需要3t;</li><li>尽管 cah 存在 em, cr, tr, el, 但是 cah 并不是 pe, es, ae 的. 这里出现了一个让步, 故前半句应该是对另一方的妥协, 即前半句是在说“尽管cah具有一些state的特点”, 故 em, cr, tr, el 均为 state 的特点. 同理, 后半句在说“但cah仍然是chief”. 故 chief 一定是非pe, 非es, 非ae的.</li></ol><p>总结一下, 本篇文章的结构如下:</p><p>GM: Cah=chief vs. state</p><ol type="1"><li>cah像chief　　　state土多</li><li>人少, <span class="math inline">\(\neg\)</span> 3t　　　人多, 3t</li><li><span class="math inline">\(\neg\)</span>pe, <span class="math inline">\(\neg\)</span>es, <span class="math inline">\(\neg\)</span>ae　　　em, cr, tr, el</li></ol><h2 id="存在观点冲突的文章">存在观点冲突的文章</h2><blockquote><p>Astronomers studying a certain kind of supernova (exploding star) were surprised to find the supernovas were fainter than expected. Seeking explanations, they discounted the possibility that cosmic dust might be screening out some of the light, because it would filter out blue light more than red, causing the supernovas to appear redder than they really are. Also, unless spread very smoothly throughout space, the dust would introduce large variations in the <strong>measurements</strong>. Another possibility is gravitational lensing, the bending of light rays as they skirt galaxies <em>en route</em>. Such lensing occasionally causes brightening, but most often it contributes to the dimness of distant supernovas. Calculations show, however, that this effect becomes important only for sources more distant than the supernovas studied.</p></blockquote><blockquote><ol type="1"><li>According to the passage, the astronomers rejected gravitational lensing as an explanation for their findings because<br>A. gravitational lensing can cause supernovas to appear brighter than they really are.<br>B. their calculations showed a negligible effect of gravitational lensing for light rays from distant sources.<br>C. light rays trabeling from the supernovas studied did not have to skirt galaxies.<br>D. the effect of gravitational lensing on the appearance of supernovas is unpredictable.<br>E. the supernovas studied were too near for gravitational lensing to have the observed dimming effect.</li></ol></blockquote><blockquote><ol start="2" type="1"><li>The passage implies which of the following about the measurements made by the astronomers?<br>A. There were small calculation errors in their measurements.<br>B. There were no large variations in their measurements.<br>C. Their measurements were skewed by unevenly spread cosmic dust.<br>D. Their measurements were incomplete because cosmos dust screened out some of the light.<br>E. It was possible to take more measurements of red light than of blue light.</li></ol></blockquote><p>文章开头是一个事实——supernova 比看起来要暗一些, 那么后文一定是在对这件事情进行解释. 下文指出, 宇航员们首先排除了宇宙尘埃的影响, 因为比起红光, 尘埃会过滤更多的蓝光. &lt;???&gt;这个句子很迷, 至此还没有非常有效的信息, 但是可以初步得到一个类似于“尘埃使得supernova变红并不能使之变暗”的结论. 后文的 Also, unless … 指出, 在一般情况下, 尘埃会带来很大的边数. 这个地方与问题看起来联系仍然不是非常紧密. 这里的内容读起来非常迷, 留在分析题目时继续讨论.</p><p>下文的 Another possibility is … 一句指出, 除了尘埃之外还有一种可能的原因, 就是 gravitational lensing, 简记为 GL. 但是接下来突然出现了 Such lensing occasionally causes brightening. (??? 作者在搞什么? GL 不是 supernova 变弱的原因吗? 怎么忽然又能使之变亮了?) 继续阅读后文, 发现后文存在一个 but, 即可知上文的 brighten 其实是一个让步. but 后指出, 多数情况下, GL 还是会使 supernova 变暗的.</p><p>文章到这里还没有结束. 最后一句中的 however 看起来就像一个大大的“卧槽”. 忍住骂人的冲动继续读, 大概可以了解到最后一句的意思是“尽管…, 但是计算表明 GL 只对那些比supernova更远的星星有效果.” 此处应有“卧槽”, 读了这么半天, 原来问题还是没有解决. 先提到了尘埃, 然后说尘埃被排除了. 提到GL这个高大上的东西的时候, 读者一定看到了希望, 然后…GL就被证明是错误的了.</p><p>综上所述, 这篇文章的内容可以简化为:</p><p>super faint → dust? × → GL? → contribute to dimness: √ → 适用距离太远: ×.</p><p>文章的第一题显然出题点就是最后一句, 所以该题的答案一定是“supernova 太近了, GL 适用距离太远了”. 很容易选出E选项.</p><p>第二题比较困难, 考察的就是事实与观点之间的gap. 在分析文章时, 尘埃附近的内容读起来比较迷, 原因就在于<strong>作者只提供了最终结果和做出判断的前提, 没有给出二者之间的详尽推理</strong>. 文中指出, dust 被排除在外, 言下之意就是 dust 对于 supernova 变暗没有贡献. 而下文的 Also, unless … 一句指出, 除非光线的传播非常顺畅, 否则观测一定有很大变数. 上文提到 dust 是可以阻碍光线传播的, 于是光线顺畅地传播等价于没有尘埃. 所以这句话实际上应该理解为: 除非尘埃不存在, 否则观测会存在很大的变数. 至此, 我们得到的信息是: 宇航员认为 supernova 的黯淡不是 dust 造成的, 并且若 dust 存在, 则一定会给观测带来很大的变数. 那么这两件事情之间需要补充的gap就是: 在观测中没有遇到很大的变数. 这里宇航员的推理就是一个典型的 <span class="math inline">\(p\to q, \neg q\Rightarrow \neg p\)</span> 的推理过程. 在这里, <span class="math inline">\(p\)</span> dust 的存在, <span class="math inline">\(q\)</span> 观测存在很大的变数. 已知 <span class="math inline">\(p\to q\)</span>, 宇航员一定是观测到了 <span class="math inline">\(\neg q\)</span>, 才敢断言 <span class="math inline">\(\neg p\)</span>. 于是这道题的答案应是 B.</p><p>顺带一提第二题中令人费解的事实和结论. 文章指出:</p><blockquote><p>宇航员排除了 dust 的影响, 因为 dust 会使得 supernova 变红. 并且, 除非 dust 不存在, 否则 dust 会给观测带来很大的变数.</p></blockquote><p>这里的原理是: 红光的波长比较长, 于是在传播时不容易衰减. 于是距离比较远的天体看起来也比较偏红, 因为波长短的光在长距离传播中被散射掉了. 尘埃会使得 supernova 变红, 自然也就会使得人们对于距离的观测值变大, 即给 measurement 带来 large variation. 所以, dust 的存在, 一定会给观测带来巨大的影响. 基于这些原理, 文中的宇航员才会做出如此的判断.</p><p>第二题的难度较高, 难的原因主要在于逻辑的推导. <strong>常见的一些逻辑如下</strong>:</p><ol type="1"><li>If p, q. —— <span class="math inline">\(p\to q\)</span>;</li><li>Only if p, q. —— <span class="math inline">\(\neg p\to\neg q\)</span>;</li><li>Unless p, q. —— <span class="math inline">\(\neg p\to q\)</span>.</li></ol><p>关于<strong>因果和转折中的条件的真假性</strong>, 有如下分类:</p><ul><li><strong>因果:</strong><ol type="1"><li>Because p, q. —— p 为真;</li><li>If p, q. —— p 不确定;</li><li>If p were true, q would have been true. —— p 为假.</li></ol></li><li><strong>转折:</strong><ol type="1"><li>Even though p, q. —— p 为真;</li><li>Even if p, q. —— p 不确定;</li><li>Even if p were true, q would have been true. —— p 为假.</li></ol></li></ul>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
            <tag> GRE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GRE填空思路分析[2]——推理的线索来源·反义线索</title>
      <link href="/2017/07/20/GRE%E5%A1%AB%E7%A9%BA%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90%5B2%5D%E2%80%94%E2%80%94%E6%8E%A8%E7%90%86%E7%9A%84%E7%BA%BF%E7%B4%A2%E6%9D%A5%E6%BA%90%C2%B7%E5%8F%8D%E4%B9%89%E7%BA%BF%E7%B4%A2/"/>
      <content type="html"><![CDATA[<p>GRE 填空的一点小小的总结.</p><blockquote><p>反义线索主要有对比和让步转折两种.</p></blockquote><a id="more"></a><h2 id="对比">对比</h2><h3 id="情况1-矛盾词">情况1: 矛盾词</h3><p><strong>irony, ironical, ironically.</strong></p><p><strong>paradox, paradoxical, paradoxically.</strong></p><p><strong>contradiction, contradictiony.</strong></p><p><strong>opposite, oppositior.</strong></p><p><strong>contrast, contrary.</strong></p><blockquote><p><strong>例</strong>: The concept of timelessness is paradoxical from the start, for adult consciousness is permeated by the awareness of duration.</p></blockquote><p>例句中的 timelessness 理解为“永恒的”是没有意义的, timelessness的真实含义应为“无始无终的”. 而 duration 显然是有始有终的一段时间, 故 timelessness 与 duration 形成对立.</p><p>如下面的三题:</p><blockquote><p><strong>例</strong>: Paradoxically, Robinson’s excessive denials of the worth of early works of science fiction suggest that she has become quite ____ them.<br>A. enchanted by<br>B. enamored of<br>C. skeptical of<br>D. exasperated by<br>E. offended by<br>F. reflective about</p></blockquote><p>题目很简单, 前半句抛出了对比的一半信息: Robinson 认为科幻作品没有价值. 故后半句应表示出“Robinson 认为科幻作品有价值” 的意思. 故选择 AB 选项.</p><blockquote><p><strong>例</strong>: An apparent paradox led the scientists to pursue their present line of research. They were struck by the fact that a single mathematic formula can be used to describe physical phenomena that appears to be so ____.<br>A. rudimentary (基本的, basic)<br>B. interdependent (相互依赖)<br>C. interrelated (相互关联)<br>D. complex<br>E. heterogeneous (不同)<br>F. dissimilar</p></blockquote><p>题目中有 be struck by… 的结构, 表明后面存在对比. a single formula 能够用以描述一些物理现象. 此处似乎无法直接确定选项, 于是可以将前文的single直接取反, 即可得到后面的物理现象应该是“不同的”. 故选 EF 选项.</p><blockquote><p><strong>例</strong>: From the outset, the concept of freedom of the seas from the proprietary claims of nations was challenged by a contrary notion–that of the ____ of the oceans for reasons of national security and profit.<br>A. promotion<br>B. exploration<br>C. enclosure<br>D. appropriation<br>E. conservation<br>F. surveying</p></blockquote><p>句首的 from the outset 等价于 from the beginning. 随后文章指出, 自由的概念被一个 contrary notion 所挑战, 故后面应该是说的如何不自由. 选项中可以找到 freedom 的广义反义词为 CD.</p><h3 id="情况2-强烈情感词">情况2: 强烈情感词</h3><p><strong>surprisingly, astoundingly, weird, startling, curiously (莫名其妙), remarkable (异乎寻常), be struck by.</strong></p><blockquote><p><strong>例</strong>: Thomas Painem whose political writing was often flamboyant, was in private life a <strong>surprisingly</strong> simple man: he lived in rented rooms, ate little, and wore drab clothes.</p></blockquote><p>文章中 Thomas Paine 的作品酷炫与生活简单形成了对比. 信号词就是surprisingly.</p><p>在出现对比的时候一定要理清文章的逻辑和内容, 否则可能会因此选错. 如以下的两题</p><blockquote><p><strong>例</strong>: While in many ways their personalities could not have been more different–she was ebulliend where he was glum, relaxed where he was awkward, garrulous where he was ____–they were surprisingly well suited.<br>A. solicitous (渴求的)<br>B. munificent (大方的)<br>C. irresolute (犹豫不决)<br>D. laconic (言简意赅, concise)<br>E. fastidious (小心谨慎, 一丝不苟, 挑剔苛求)<br>F. taciturn (沉默寡言)</p></blockquote><p>文章中很容易看到 surprisingly 的存在, surprisingly 后指出两人很般配, 于是可知前文应该是说两人是不般配, 甚至相对立的. 文章在空格前指出了 she was garrulous, garrulous 意为“啰嗦”, 故后文应表示“他话很少”的意思, 故选择 DF 选项.</p><blockquote><p><strong>例</strong>: Scholars have marveled over the (i)____ that Shakespeare displays in his works, noting that such broad learning is all the more remarkable given that books were relatively (ii)____ in Shakespeare’s time.</p></blockquote><table><thead><tr class="header"><th style="text-align: left;">Blank (i)</th><th style="text-align: left;">Blank (ii)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">A. meticulousness (一丝不苟, fastidious)</td><td style="text-align: left;">D. edifying (有教育意义的)</td></tr><tr class="even"><td style="text-align: left;">B. humor</td><td style="text-align: left;">E. scarce</td></tr><tr class="odd"><td style="text-align: left;">C. erudition (博学)</td><td style="text-align: left;">F.inexpensive</td></tr></tbody></table><p>文章的前半部分有一个 noting that such broad learning…, 此处的 broad learning 是新提出的, 故前文一定提到过. 浏览前文, 并没有提到相关内容, 故一定是空格处提出的. 于是(i)空应选C项. 结合marvel 和remarkable, 可知前后两部分形成了对比, 于是莎士比亚读的书应该是很少, 才能与他的博学形成对比. 故第(ii)空应填 E.</p><h3 id="情况3-其他常见对比关系">情况3: 其他常见对比关系</h3><p>其他常见对比关系:</p><ul><li>时间点前后: recently, previous, before, current, now, today, yesterday, later, future, initially, no longer;</li><li>表象和实质: in fact, in reality, ostensible(表面上的), normally;</li><li>一般对特殊;</li><li>整体对个体;</li><li>结构对比:<ul><li>不是A, 而是B: not A but B, far from A to B, less A than B;</li><li>是A, 而不是B: more A than B, A rather than B.</li></ul></li></ul><p>以下是两道比较难的题目, 都是双空题.</p><blockquote><p><strong>例</strong>: The museum’s compelling new architechural exhibition looks at eleven projects around the world that have had major (i)____ impacts despite modest budget. It is part of (ii)____ in the museum’s architecture and design department, which in the past has championed architecture’s artistic value over its real- world consequences.</p></blockquote><table><thead><tr class="header"><th style="text-align: left;">Blank(i)</th><th style="text-align: left;">Blank(ii)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">A. social</td><td style="text-align: left;">D. an emphasis on theory</td></tr><tr class="even"><td style="text-align: left;">B. aesthetic</td><td style="text-align: left;">E. a shift in philosophy</td></tr><tr class="odd"><td style="text-align: left;">C. critical</td><td style="text-align: left;">F. a rejection of programatism</td></tr></tbody></table><p>文章首句指出了博物馆的展览关注的是11座造价不高的建筑, 而 despite 表明了空格与 modest budget 之间存在对比关系, 但至此仍然无法在 ABC 中找到正确选项. 第二句中的 it 指代的应是前文提到的展览, 接下来空格附近的内容也无法确定, 但下文出现了 which, 一定会对这里的内容进行解释. 注意到 in the past 的存在表明了此处应该存在一种时间上的今昔对比, champion A over B 意为“支持 A 而不支持 B”, 即曾经不重视 real- world consequences, 故如今应当重视. 注意这里谈论的内容仍然是与展览相关, 故此处的信息一定是前文提到的, 于是第(i)空应选择 A 选项, 以表示该展览重视了 real- world consequences.</p><p>第二空附近的内容被后面 which 引导的从句所解释, 故两方面内容应该是基本等价的, 概括从句内容可知是博物馆对于 artistic value 和 real- world consequences 的态度发生了转变, 故第二空选择 E 选项. 此处的 philosophy 不表示“哲学”的意思, 而是表示一种“理念”的意思.</p><p>值得注意的是, in the past 在整个文章中的地位极其重要, 如果没有看到 in the past, 则第(i)空选择 B. aesthetic 也可以说得通, 而第二个空也会错误理解为“博物馆仍然不重视real- world consequences”, 从而错选为 F. a rejection of pragmatism, 意为“对实用主义的消极态度.”</p><blockquote><p><strong>例</strong>: Britain’s deteriorating economy after 1945 was (i)____ by policians who favored the manufacuring sector over the service sector: rather than attempting to (ii)____ the decline of manufacturing, they should have promoted service industries.</p></blockquote><table><thead><tr class="header"><th style="text-align: left;">Blank(i)</th><th style="text-align: left;">Blank(ii)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">A. mishandled</td><td style="text-align: left;">D. augment</td></tr><tr class="even"><td style="text-align: left;">B. bolstered</td><td style="text-align: left;">E. arrest</td></tr><tr class="odd"><td style="text-align: left;">C. forestalled</td><td style="text-align: left;">F. escalate</td></tr></tbody></table><p>文章在第(i)空之前的部分提到了英国恶化的经济状况, 空格后的 by politicians… 表明空格表示的是政客的一些操作. 随后文章指出了政客的想法是 favored the manufacturing sector over the service sector, 意为“把制造业看得比服务业更重要.” 至此仍然没有清晰的线索指向第(i)空的操作.</p><p>接下来出现了冒号, 则冒号后的内容方向一定是与前文一致的. 不妨设第(ii)空的内容为 X, 则冒号后的内容为, 政客本应该促进服务业的发展, 而非 X 制造业的衰落. 至此第(ii)空的线索已经明确. 政客们的操作目的应是拯救英国衰退的经济, 故 X 应表达“阻止制造业的衰退”的意思, 故应选择 E 选项. 最后的虚拟语气 they should have promoted… 是非常关键的线索. 一般来说, 虚拟语气暗含着对比: “他们本应该…”, 实际上是在表明“他们如果不这样就会很好, 但他们搞砸了.” 所以这句话实际上表明了“政客们使得英国本就不景气的经济雪上加霜.” 于是第一空应选择 A. mishandled, 意为经营不善.</p><p>综上所述, 题目应选择 AE 选项.</p><h2 id="让步转折">让步转折</h2><p>让步转折的主要标志: <strong>but, while, though, although, despite, in spite of, notwithstanding, nonetheless, nevertheless, for all, yet, unless, however, whatever, regardless of, albeit</strong>.</p><p>其中有一些注意事项:</p><ol type="1"><li>despite 是介词, 后面需要接词, 不能直接跟句子, 如果需要跟句子, 则需要 despite that… ;</li><li>notwithsatnding 可以做副词或介词, 意为“尽管”;</li><li>forall = despite;</li><li>albeit = although;</li><li>nonethless 和 nevertheless 的用法:<ul><li>若二者单独出现, 则意为“然而”;</li><li>若前文已有转折词, 则二者无意义.</li></ul></li><li>but 用法的一个特例: but…more… 表示“进一”, “更多的”.</li></ol><p>在做题时要通过各种信号词来推测空格与已知信息的正负关系, 不能忽略掉任何一个, 否则就容易理解错误. 如下面的例子:</p><blockquote><p><strong>例</strong>: Clearly the government faced a dilemma: it could hardly ____ trials, especially in the absence of irrefutable evidence, but it also would not welcome, in the midst of war, the scandal that would raise if trials were avoided.<br>A. be keen on<br>B. be inclined to<br>C. arrange<br>D. dispense with<br>E. turn its back on<br>F. credit</p></blockquote><p>开头提到了一个困境, 暗示后文是两件事情的对立. 设空格为 X, 则容易分析出 hardly X trials 与 would not welcome the scandal 是矛盾的. 考虑到 scandal 是在避免 trials 的情况下出现的, 故 scandal = <span class="math inline">\(\neg\)</span> welcome trials. 于是之前得到的结论, <span class="math inline">\(\neg\)</span> X trials =<span class="math inline">\(\neg\)</span><span class="math inline">\(\neg\)</span><span class="math inline">\(\neg\)</span> welcome trials. 故 X trials = welcome trials. 于是应选择正向的选项, 即AB.</p><p>如果在分析过程将 welcome 的宾语错当为 trials, 或漏掉转折的标志, 则有可能会错选DE.</p><p>值得一提的是, dilemma 专指的是左右两难的困境. 即 dilemma 一定是两件事情之间的纠结状态.</p><p>一个难题如下:</p><blockquote><p><strong>例</strong>: As serious as she is about the bullfight, she does not allow respect to ____ her sense of whimsy when painting it.<br>A. inspire<br>B. provoke<br>C. suppress<br>D. attack<br>E. satisfy</p></blockquote><p>题目中出现了 As 引导的半倒装句, 一般来说表示让步. 后面的 allow respect to … 也是一个比较难以分析的地方. 事实上, 此处的结构为 allow sb to …, 若理解为 allow (respect to …) … 则题目无法下手. 关系和内容明确后, 文章变为了 serious to bullfight=<span class="math inline">\(\neg\)</span> not allow to X her sense of whimsy while paint it. 即 X = <span class="math inline">\(\neg\)</span> serious. 即应选择负面的词语, 为 C 选项.</p><p><strong>关于 as, 有如下几条:</strong></p><ul><li>as 引导的半倒装句表示让步.<ul><li>Student as she is, she does not study hard.</li><li>尽管她是个学生, 她并不好好学习.</li></ul></li><li>As … as … = So … as …<ul><li>As: adv. = so;</li><li>as: conj. 正如, 就像.</li></ul></li></ul><p>再次回到题目, 文章中相对应的部分实际上是 So serious 和 respect.</p><h2 id="同主体让步转折">同主体让步转折</h2><p>同主体让步转折, 顾名思义就是主体不变的情况下进行让步和转折. 但前后不可能完全对立, 即不可能出现“他很帅, 但很丑”这样明显错误的句子. 但考虑到不完全对立, 可以有“我很丑但我很温柔”这样的句子, 这样的情形就被称为同主体让步转折. 可以总结为以下几条:</p><ul><li>形式: Although A…, A…<ul><li>前后转折主体为统一事物, 并处于同一时空范围内.</li></ul></li><li>原则<ul><li>前后两个空格不能截然相反;</li><li>前后两个空格可以是正负相对但意思无关的概念. (丑-温柔, 聪明-懒惰)</li></ul></li></ul><p>以下是一道难题:</p><blockquote><p><strong>例</strong>: His affection for his sister, though not ____, was plainly too great to permit a painless departure.<br>A. unsteady<br>B. noticeable<br>C. ambivalent<br>D. careless<br>E. unbounded</p></blockquote><p>此处的 affection 意为“爱”. 观察到文中的 though, 结合语义可得到 not X = <span class="math inline">\(\neg\)</span> great. 故 X 为正向的词语. 符合要求的有 BE 两项.</p><p>此题很容易错选B选项. B. noticeable 带入文章中意为“尽管他对姐姐的爱不是那么明显, 但仍然足够great.” 虽然情感方向正确, 但后文的plainly 意为“明显的, 显然的”, 与此处的 not noticeable 矛盾. 故综合考虑应选择 E. unbounded.</p><p>以下是另一道难题:</p><blockquote><p><strong>例</strong>: While not completely nonplussed by the unusually caustic responses from members of the audience, the speaker was nonetheless visibly ____ by their criticism.<br>A. humiliated<br>B. discomfited<br>C. deluded<br>D. disgraced<br>E. embarrassed<br>F. tantalized</p></blockquote><p>文章的大概意思为“尽管speaker还没有被完全弄得困惑, 但他显然还是被弄得 X.” 值得注意的是文章中 nonetheless 不表示转折, 意为“仍然”. 于是 X 应是负面的词, 但强烈程度不及“nonplussed”. 单纯考虑情感方向, 可以选择 AD. 羞辱 或者 BE. 不爽/尴尬. 继续考虑到强烈程度的问题, 应选择 BE.</p><p>本题的 F 选项 tantalized 意为“挑逗”. <strong>GRE中常出现的“挑逗”共有3个: tantalized &lt; allure &lt; seduce. 引诱程度依次加深</strong>. 其中 seduce 意为“色诱”.</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
            <tag> GRE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GRE填空思路分析[1]——词句推理</title>
      <link href="/2017/07/20/GRE%E5%A1%AB%E7%A9%BA%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90%5B1%5D/"/>
      <content type="html"><![CDATA[<p>GRE 填空的一点小小的总结.</p><a id="more"></a><h2 id="verbal-reasoning-的特点">Verbal Reasoning 的特点</h2><ul><li>第一个记分的语文的填空部分一定是2个单空, 3个双空, 1个三空.</li><li>建议用时: 10min填空, 20min阅读.</li><li>填空题目不考察背景知识, 所有线索均来自于题目.</li></ul><h2 id="词汇问题">词汇问题</h2><h3 id="第一类问题-词义理解有误">第一类问题: 词义理解有误:</h3><p>韦氏词典+美国传统辞典;</p><h3 id="第二类问题-望文生义">第二类问题: 望文生义:</h3><table><thead><tr class="header"><th style="text-align: left;">单词</th><th style="text-align: left;">真实含义</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">invaluable/priceless</td><td style="text-align: left;">特别值钱</td></tr><tr class="even"><td style="text-align: left;">impassive</td><td style="text-align: left;">消极冷漠</td></tr><tr class="odd"><td style="text-align: left;">impassion</td><td style="text-align: left;">热情</td></tr><tr class="even"><td style="text-align: left;">effortless</td><td style="text-align: left;">不费力的</td></tr><tr class="odd"><td style="text-align: left;">ignorance</td><td style="text-align: left;">无知</td></tr><tr class="even"><td style="text-align: left;">salient</td><td style="text-align: left;">显著的</td></tr><tr class="odd"><td style="text-align: left;">appraise</td><td style="text-align: left;">评价</td></tr><tr class="even"><td style="text-align: left;">acclaim</td><td style="text-align: left;">喝彩</td></tr><tr class="odd"><td style="text-align: left;">servered</td><td style="text-align: left;">切开</td></tr><tr class="even"><td style="text-align: left;">reserve/reverse</td><td style="text-align: left;">保留/相反</td></tr><tr class="odd"><td style="text-align: left;">guild</td><td style="text-align: left;">协会</td></tr></tbody></table><h3 id="第三类问题-熟词僻义">第三类问题: 熟词僻义:</h3><table><thead><tr class="header"><th style="text-align: left;">单词</th><th style="text-align: left;">熟词生义</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">turf</td><td style="text-align: left;">地盘</td></tr><tr class="even"><td style="text-align: left;">list</td><td style="text-align: left;">倾斜</td></tr><tr class="odd"><td style="text-align: left;">licence</td><td style="text-align: left;">自由</td></tr></tbody></table><h3 id="第四类问题-纯难词词根猜测">第四类问题: 纯难词/词根猜测</h3><p>背单词…Orz</p><h2 id="长难句理解">长难句理解</h2><h3 id="长句">长句</h3><p>三个概念:</p><ul><li>that 的作用:<ol type="1"><li>代词, 表示“那个”;</li><li>引导从句.</li></ol></li><li>同位语: 跟在名词后, 表示对其的修饰;</li><li>分词短语:<ol type="1"><li>做定语, 表示对前面名词的修饰;</li><li>做状语, 与主语用逗号隔开表示主语的状态. <strong>用逗号隔开的必定是状语, 反之可能是定语.</strong></li></ol></li></ul><blockquote><p>例: The increase in the numbers of married women employed outside the home in the twentieth century had less to do with the mechanization of housework and an increase in leisure time for these women than it did with their own economic necessity and with high marriage rates that shrank the available pool of single women workers, previously, in many cases, the only women employers would hire.</p></blockquote><p>例句中, The increase 是主语, had less to do with 是谓语, than it did with… and with 是宾语. 至此主干已经清楚, 最后的 the only women 是同位语.</p><h3 id="难句">难句</h3><blockquote><p>例: For some time now, ____ has been persumed not to exist: the cynical conviction that everybody has an angle is considered wisdom.<br>A. rationality<br>B. flexibility<br>C. diffidence<br><strong>D</strong>. disinterestedness<br>E. insincerity</p></blockquote><p>例句的最后部分 everybody has an angle is considered wisdom 的意思是“每个人都很自私.” 考虑到冒号前的not, 前后两部分意思应相反, 故选择D, 意为“无私.”</p><blockquote><p>例: The current ____ of package music under Miles Davis’ name might prompt ant reasonable person to conclude that the recording vault has been plundered bare.<br><strong>A</strong>. glut (过量)<br>B. revival (复活)<br><strong>C</strong>. hodgepodge (大杂烩)<br>D. surfeit (过量)<br>E. modicum (少量)<br>F. dearth (少量)</p></blockquote><p>例句的最后部分 the recording valut has been plundered bare 直译为“唱片金库被掠夺一空.” 此处的意思为“Miles Davis 已经江郎才尽.” 于是题目应选择 AD 选项.</p><h2 id="推理的步骤与注意事项">推理的步骤与注意事项</h2><h3 id="逻辑和语义">逻辑和语义</h3><p>逻辑的判断方法:</p><ol type="1"><li>是否有反义: 首先判断分句与分句之间是否有反义转折词;</li><li>是否有否定: 其次判断空格或抑制信息前后是否有否定;</li><li>有几个否定: 转折词汇也算作否定, 判断否定的层数;</li></ol><p>常见的否定词: <strong>no/not, less, little, anything but, few, never, hardly=barely, rarely=seldom</strong>.</p><p>语义的判断方法: 判断广义同反义.</p><p>广义同义概念:</p><ul><li>严格同义词;</li><li>感情色彩相同的词, 如: 勤奋-善良, 邪恶-懒惰;</li><li>正负方向相同的词, 如: 增高-变多;</li><li>逻辑相关词, 如: 艺术-艺术家, 科学-科学报告.</li></ul><p>广义反义概念:</p><ul><li>严格反义词;</li><li>感情色彩相反的词;</li><li>正负方向相反的词;</li><li>与极端词相对应的中性词, 如: 上升-下降, 上升-静止 均可.</li></ul><h3 id="推理的步骤">推理的步骤</h3><p>一般有以下的五步:</p><ul><li>通读题干, 明确哪一空最好做;</li><li>明确空格作用: 如表示谁的动作, 修饰的是谁的属性;</li><li>判断逻辑同反义关系;</li><li>判断空格的语义对应线索;</li><li>对空格做出预测, 选出正确选项.</li></ul><p><strong>填空的后半句一定没有新概念出现, 若有, 则一定在前半部分出现过.</strong></p><h3 id="推理的注意事项">推理的注意事项</h3><ul><li>一定要以文章的剩余信息为依据, 解题线索一定来自题目本身, 不要带入主观假设和偏见;</li><li>需要有必要的常识 common sense</li></ul><blockquote><p>例: Nature’s energy efficiency often (i)____ human technology: despite the intensity of the light fireflied produce, the amount of heat is negligible (可忽略的); only recently have humans developed chemical light-producing systems whose efficiency (ii)____ the firefly’s system.</p></blockquote><table><thead><tr class="header"><th style="text-align: left;">Blank (i)</th><th style="text-align: left;">Blank (ii)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">A. outstrips (超过)</td><td style="text-align: left;">D.rivals (与…相匹敌)</td></tr><tr class="even"><td style="text-align: left;">B. reflects</td><td style="text-align: left;">E. manipulates</td></tr><tr class="odd"><td style="text-align: left;">C. determines</td><td style="text-align: left;">F. inhibits (抑制)</td></tr></tbody></table><p>例句中首先说明了萤火虫的光很强但发热很少, 下文又提到了能量效率. 能量效率=有用能量/总能量 就是一个常识, 于是容易知道萤火虫的发光效率非常高. 而萤火虫是冒号后新出现的东西, 故一定是前文所提到的, 可知萤火虫所属的阵营是自然, 于是可以猜测下文要说的是人类的能量效率比较低. 于是本题应选择 AD 选项.</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
            <tag> GRE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GRE阅读题目分析[2]</title>
      <link href="/2017/07/16/GRE%E9%98%85%E8%AF%BB%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%5B2%5D/"/>
      <content type="html"><![CDATA[<p>GRE 阅读的一点小小的总结.</p><a id="more"></a><h2 id="文章内容">文章内容</h2><blockquote><p>　　Many scholars have argued that government investment in manufacturing in the southern United States during the Second World War spurred a regional economic boom that lasted into the postwar period. But much of this investment went to specialized plants, many of them unsuitable for postwar production. Large-scale, wartime government funding led to a massive increase in the number and scale of munitions facilities. By the war’s end, 216 munitions establishment costing more than $3.5 billion had been built, many of them located in the south. Indeed, according to one estimate, more than 70 percent of federally financed manufacturing construction capital in Alabama, Arkansas, Mississippi, and Tennessee went into munitions plants.<br>　　Even in the northern regions with strong prewar manufacturing economics, these plants were difficult to deal with once the imperative of war had been removed. In the south few industrialists had the capacity or desire to transform these factories to a peacetime function. Accordingly, at war’s end almost all of the southern munitions facilities were shut down, placed on standby, operated at a very low capacity, or converted to nonmanufacturing functions, usually storage. Although some reopened a few years later for use during the Korean War, the impact of the special plants on the South’s postwar economy was marginal at best.</p></blockquote><h2 id="结构分析">结构分析</h2><h3 id="文章开头">文章开头</h3><p>由文章的第一句中 “many scholars have argued that…” 可知该句为引用观点, 故该文章很有可能是一个质疑型的文章. 首句指出: <strong>很多学者认为, 二战期间, 政府对美国南方在工业方面的投资刺激了经济的发展, 并持续到了战后</strong>. 这一句所包含的信息量很大, 作者可以质疑很多方面, 比如, 作者可以质疑投资是否真的能刺激经济发展, 也可以质疑这种发展能否持续到战后. 所以文章的方向目前为止还不甚明朗, 需要继续阅读.</p><p>接下来出现了 but, 表示作者开始了自己的质疑. 作者指出, 这些受益的工厂有很多都是特殊的工厂, 不适合于战后的情形. 至此, 作者的态度已经比较明朗, 就是在质疑经济的发展能否持续到战后的问题. 目前为止文章的内容框架已经可以概括为:</p><blockquote><p>很多学者认为, 二战期间, 政府对美国南方在工业方面的投资刺激了经济的发展, 并持续到了战后. 但由于这些工厂的特殊性, 这种经济的发展不能持续到战后.</p></blockquote><h3 id="后文展开">后文展开</h3><p>接下来的 Large-scale… 一句, 行文的方向显然没有发生变化, 于是这句话不会与作者的观点产生冲突, 也不会产生新的信息. 本句谈到的信息为政府把钱投资给了军工厂, 那么这个信息一定是旧信息, 那么前文提到的“特殊的”工厂指的也就应该是军工厂了. 下一句 By the war’s end… 也是在谈政府为军工厂投资的事情, 仍然没有新信息出现.</p><p>随后是 Indeed 引导的句子, 可知该句话中行文的方向不发生变化, 于是其内容仍然不会脱离框架所的涉指范围. 结合语义, 可知本句仍在谈论投资对象的问题.</p><h3 id="第二段">第二段</h3><p>在第二段的开头提到了北方的情况(可以出题考为什么在此处提到北方的情况), 指出这些战后的军工厂在北方同样难以处理. 那么作者为什么要在此处提及北方的情况呢? 显然南方才是全文的重点, 整个文章都应该是围绕着南方展开的. 所以显然这个北方的情况也是服务于南方的, 实际上是在表明 “连北方的都难以处理, 更不用说南方的情况了, 一定更糟糕”. 所以此处提及北方的情况, 实际上仍然是在为作者自己得观点所服务.</p><p>接下来讨论回到了南方, 指出几乎没有人愿意处理南方的军工厂, 仍然在强调战后军工厂的副作用. 接下来的 Accordingly… 一句, 更是直接指出了, 在战后, 几乎所有的军工厂都废掉了.</p><p>在下文出现了 although 一词, 显然是一个让步. 故前半句应该是一个小小的妥协, 后半句仍然回到自己的观点. 故此处在读句子之前就完全可以猜出这句话的意思是“尽管有些军工厂还没有废掉, 但是它们也废掉了”. 至此, 整篇文章的内容已经结束.</p><h3 id="整体结构">整体结构</h3><p>文章比较长, 但最核心的其实只有两句话:</p><blockquote><p>Many scholars have argued that government investment in manufacturing in the southern United States during the Second World War spurred a regional economic boom that lasted into the postwar period. But much of this investment went to specialized plants, many of them unsuitable for postwar production. 许多学者认为经济发展能够持续至战后, 但是并不能.</p></blockquote><h2 id="问题分析">问题分析</h2><h3 id="问题一">问题一</h3><p>文章的问题是针对 Indeed, according to one estimate, more than 70 percent of federally financed manufacturing construction capital in Alabama, Arkansas, Mississippi, and Tennessee went into munitions plants 一句提出的, 该句是对上文观点的展开, 故功能应该是支持前文的观点.</p><p>事实上, 原题目如下:</p><blockquote><p>In the passage, the mention of “Alabama, Arkansas, Mississippi, and Tennessee” serves primarily to<br>　　A. suggest that some states were better than others at anticipating postwar economic needs<br>　　B. identify evidence used to support a view held by scholars mentioned at the beginning of the passage<br>　　C. suggest that federal investment in some kinds of manufacturing was excessive<br>　　D. identify the states that received the largest allocations of federal funds<br>　　<strong>E</strong>. provide information to support a point about the nature of government investment made earlier in the paragraph</p></blockquote><p>根据以上分析, 本题应选择 E.</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
            <tag> GRE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GRE阅读题目分析[1]</title>
      <link href="/2017/07/16/GRE%E9%98%85%E8%AF%BB%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%5B1%5D/"/>
      <content type="html"><![CDATA[<p>GRE 阅读的一点小小的总结.</p><a id="more"></a><h2 id="文章内容">文章内容</h2><blockquote><p>In 1755 British writer Samuel Johnson published an acerbic letter to Lord Chesterfield rebuking his patron for neglecting and declining further support. Johnson’s rejection of his patron’s belated assistance has often been identified as a key moment in the history of publishing, marking the end of the culture of patronage. However, <strong>patronage had been in decline for 50 years, yet would survive, in attenuated form, for another 50</strong>. Indeed, Johnson was in 1762 awarded a pension by the Crown — a subtle form of sponsorship, tantamount to state patronage. The importance of Johnson’s letter is not so much historical as emotional; it would become a touchstone for all who repudiated patrons and for all who embraced the laws of the marketplace.</p></blockquote><h2 id="结构分析">结构分析</h2><h3 id="文章开头">文章开头</h3><p>文章前两句指出, 有观点认为: “SJ 喷 LC 的事件标志着 patronage 的结束”. 随后文中出现 However, 由于前文是引用观点, 故 However 可能起到质疑的作用, 于是本句的核心方向应该是 “partonage 并没有结束”. 后文中又出现了一个 yet, 表明该句中存在让步, 于是前半句应是对于引用观点的妥协, 结合语义, 可理解为 “partonage 虽然在变弱”. 后半句显然与引用观点意思相反, 应为 “partonage 还没有结束”.</p><p>到这里, 文章已经抛出了一个观点, 文章的大概走势是:</p><blockquote><p>有人认为 SJ 喷 LC 的事件标志着 patronage 的结束, 但实际上, 尽管 patronage 削弱了, 却没有结束.</p></blockquote><p>按照常理, 下文应该对作者自己的观点进行展开.</p><h3 id="后文展开">后文展开</h3><p>下文首先出现的是 indeed, 考虑语义, indeed 意为“确实”, 不改变文章的观点方向, 故下文的意思仍应该是“partonage 没有结束”, 结合 “tantamount to state patronage”, 可知该句确实表明了类似的意思. 最后一句仍然是作者自己观点的展开, “not so much … as …” 指出 SJ 喷 LC 的事件, 在 emotional 方面的重要性要大于 historical 方面的重要性, 实际上也是在说这件事不能标志着 patronage 的结束.</p><h3 id="整体结构">整体结构</h3><p>总体看来, 这篇文章的核心意思就是上文提到的走势, 而核心的两句话就是:</p><blockquote><p>Johnson’s rejection of his patron’s belated assistance has often been identified as a key moment in the history of publishing, marking the end of the culture of patronage. However, patronage had been in decline for 50 years, yet would survive, in attenuated form, for another 50. 许多人认为 SJ 喷 LC 标志着 patronage 的结束, 但实际上并没有.</p></blockquote><h2 id="问题分析">问题分析</h2><h3 id="问题一">问题一</h3><p>首先从加粗句出发考虑, 涉及到的就是 however 的功能. 由以上的分析, 该句的功能为质疑前文的引用观点, 故可以如下设计正确选项:</p><ol type="1"><li>Present a view that chanllenges a understanding of Johnson’s rejection of his patron’s belated assistance.</li><li>Outline an opposing interpretation of Johnson’s rejection of his patron’s belated assistance.</li><li>Qualify the declaration that Johnson’s rejection was the end of patronage.</li><li>……</li></ol><p>事实上, 原题目如下:</p><blockquote><p>Which of the following best describes the function of the highlighted sentence in the context of the passage as a whole?<br>　　A. It points out the <del> most obvious</del> implications of Johnson’s letter to his patron<br>　　B. It suggests a <del>motivation</del> for Johnson’s rejection of Chesterfield’s patronage<br>　　<strong>C</strong>. It provides information that qualifies the assertion that Johnson’s letter sharply defined the end of a publishing era<br>　　D. It provides a possible <del>defense</del> for Chesterfield’s alleged neglect of Johnson<br>　　E. It refutes the notion that <del>patrons are found primarily among the nobility</del></p></blockquote><p>根据以上分析, 本题应选择 C.</p><h3 id="问题二">问题二</h3><p>文章的另一道题目是针对 1762 的事件 (Indeed, Johnson was in 1762 awarded a pension by the Crown — a subtle form of sponsorship, tantamount to state patronage) 提出的.</p><p>这句话是对作者自己观点的展开, 所以从功能上来就是对自己观点的加强, 很容易设计出如下的正确选项:</p><ul><li>Support that Johnson’s rejection was not the end of patronage.</li></ul><p>原题目如下:</p><blockquote><p>The author of the passage mentions Johnson’s 1762 pension award in order to<br>　　A：Reveal that Johnson remained consistent in his rebuke of Lord Chesterfield well after 1755<br>　　B：Provide evidence for a general trend in the later half of the eighteenth century of private patronage’s being replaced by state sponsorship<br>　　C：Situated the debate over the end of patronage within the wider realm of eighteenth-century economic history<br>　　D：Suggest that Johnson’s letter to Chesterfield was noticed by the crown only years after it was published<br>　　<strong>E</strong>：Emphasize that patronage still helped support Johnson’s writing after his letter to chesterfield</p></blockquote><p>根据以上分析, 本题最合适的选项应为 E 选项. 值得注意的是 C 选项中 debate 一词的使用. Debate 的存在必然是有两派对立的引用观点, 否则不足以构成 debate. 注意作者观点与引用观点的对立并不算做 debate, 因为从作者的角度出发, 自己的观点一定是正确的, 不存在争论的必要.</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
            <tag> GRE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学数学分析试卷</title>
      <link href="/2017/07/04/BNU-Mathematical-Analysis-Exam/"/>
      <content type="html"><![CDATA[<ul><li>2015秋 数学分析一 期末 唐仲伟</li><li>2016秋 数学分析三 期中 唐仲伟</li><li>2016秋 数学分析三 期末 唐仲伟</li></ul><a id="more"></a><h2 id="数学分析一-期末-唐仲伟">2015 数学分析一 期末 唐仲伟</h2><h3 id="计算题">计算题</h3><p>共40分, 每题5分.</p><ol type="1"><li><p>求极限 <span class="math inline">\(\lim\limits_{n\to\infty}\sqrt{n}(\sqrt{n+1}-\sqrt{n})\)</span>;</p></li><li><p>求极限 <span class="math inline">\(\lim\limits_{x\to\infty}\sqrt{(a+x)(b+x)}-\sqrt{(a-x)(b-x)}\)</span>;</p></li><li><p>求不定积分 <span class="math inline">\(\int e^{\sqrt{x}}dx\)</span>;</p></li><li><p>求不定积分 <span class="math inline">\(\int \frac{1}{1+x^4}dx\)</span>;</p></li><li><p>求广义积分 <span class="math inline">\(\int\nolimits_0^1 lnxdx\)</span>;</p></li><li><p>求广义积分 <span class="math inline">\(\int\nolimits_0^{+\infty}\frac{dx}{1+x^3}\)</span>;</p></li><li><p>求二重积分 <span class="math inline">\(\iint\nolimits_D [x+y]dxdy\)</span>, 其中 <span class="math inline">\(D=[0,2]\times[0,2]\)</span>, <span class="math inline">\([x+y]\)</span> 是取整函数;</p></li><li><p>设二阶偏导数连续的二元函数 <span class="math inline">\(z=f(x,y)\)</span> 满足方程 <span class="math display">\[\frac{\partial^2 f}{\partial x^2}(x,y)-\frac{\partial^2 f}{\partial y^2}(x,y)=0\]</span> 且 <span class="math inline">\(f(x,2x)=x\)</span>, <span class="math inline">\(\frac{\partial f}{\partial x}(x,y)\)</span> 当 <span class="math inline">\(y=2x\)</span> 时等于 <span class="math inline">\(x^2\)</span>. 求 <span class="math inline">\(\frac{\partial^2 f}{\partial x^2}(x,y)\)</span> 当 <span class="math inline">\(y=2x\)</span> 时的值.</p></li></ol><h3 id="证明题">证明题</h3><p>共60分, 每题10分.</p><ol type="1"><li><p>求证数列 <span class="math inline">\(x_n=(-1)^n\)</span> 当 <span class="math inline">\(n\to\infty\)</span> 时发散;</p></li><li><p>设 <span class="math inline">\(f,g\)</span> 在闭区间 <span class="math inline">\([a,b]\)</span> 连续, 证明 <span class="math display">\[\int\nolimits_a^b f(x)g(x)dx\leqslant\frac{1}{2}\left[\int\nolimits_a^bf^2(x)dx+\int\nolimits_a^bg^2(x)dx\right];\]</span></p></li><li><p>设广义积分 <span class="math inline">\(\int\nolimits_0^{+\infty}\frac{\sin^2 x}{x^2}dx\)</span> 和 <span class="math inline">\(\int\nolimits_0^{+\infty}\frac{\sin x}{x}dx\)</span> 都收敛, 证明: <span class="math display">\[\int\nolimits_0^{+\infty}\frac{\sin^2 x}{x^2}dx=\int\nolimits_0^{+\infty}\frac{\sin x}{x}dx;\]</span></p></li><li><p>设 <span class="math display">\[f(x,y)=\begin{cases} \frac{xy}{x^2+y^2}, &amp; (x,y)\neq(0,0), \\ 0, &amp; (x,y)=(0,0). \\ \end{cases}\]</span></p></li><li><p>设函数 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\(x=0\)</span> 连续, 且 <span class="math inline">\(\lim\limits_{x\to\infty}\frac{f(2x)-f(x)}{x}=a\)</span>. 求证: <span class="math inline">\(f&#39;(0)\)</span> 存在, 且 <span class="math inline">\(f&#39;(0)=a\)</span>.</p></li><li><p>设 <span class="math display">\[P_n(x)=\frac{1}{n!2^n}\frac{d^n}{dx^n}(x^2-1)^n,\]</span> 证明: <span class="math display">\[\int\nolimits_{-1}^1 P_n(x)P_m(x)dx = \begin{cases} 0, &amp; m\neq n,\\ \frac{2}{2n+1}, &amp; m=n. \\ \end{cases}\]</span></p></li></ol><h2 id="秋-数学分析三-期中-唐仲伟">2016秋 数学分析三 期中 唐仲伟</h2><h3 id="计算题-1">计算题</h3><p>共50分, 前4题每题5分, 后3题每题10分.</p><ol type="1"><li><p><span class="math inline">\(\lim\limits_{(x,y)\to(0,0)}\frac{\sin(xy)}{xy}\)</span>.</p></li><li><p><span class="math inline">\(\lim\limits_{(x,y)\to(0,0)}(x+y)\sin\frac{1}{x^2+y^2}\)</span>.</p></li><li><p><span class="math inline">\(\lim\limits_{x\to\infty}\lim\limits_{y\to\infty}\frac{xy}{x+y}\)</span>.</p></li><li><p><span class="math inline">\(\lim\limits_{(x,y)\to(+\infty,+\infty)}\left(\frac{xy}{x^2+y^2}\right)^{x^2}\)</span>.</p></li><li><p>设 <span class="math inline">\(f(x,y)=(x+y,x-y,xy)\in\mathbb{R}^3\)</span>, <span class="math inline">\(g(x,y,z)=(xyz,ze^{xy})\in\mathbb{R}^2\)</span>. 记 <span class="math inline">\(F=f\circ g\)</span>, 求 <span class="math inline">\(F\)</span> 的Frechet导数 <span class="math inline">\(F&#39;(x,y,z)\)</span>.</p></li><li><p>求 <span class="math inline">\(f(x,y)=x^3+y^3-3xy\)</span> 的普通极值.</p></li><li><p>设方程 <span class="math inline">\(y-\frac{1}{2}\sin y=x\)</span> 能确定隐函数 <span class="math inline">\(y=f(x)\)</span>, 令 <span class="math inline">\(z=e^{x+y}\)</span>, 求 <span class="math inline">\(\frac{dz}{dx}\)</span>, <span class="math inline">\(\frac{d^2z}{dx^2}\)</span>.</p></li></ol><h3 id="证明题-1">证明题</h3><p>共50分, 每题10分.</p><ol type="1"><li><p>证明: <span class="math inline">\(f(x,y)=\frac{xy}{x+y}\)</span> 在 <span class="math inline">\((x,y)=(0,0)\)</span> 处极限不存在.</p></li><li><p>设数值函数 <span class="math inline">\(f(x)\)</span> 在紧集 <span class="math inline">\(D\subset\mathbb{R}^n\)</span> 上连续, 且恒为正值, 求证: <span class="math inline">\(\exists~K&gt;0\)</span>, s.t. <span class="math inline">\(\forall~x\in D\)</span>, 有 <span class="math inline">\(f(x)&gt;K\)</span>.</p></li><li><p>证明: <span class="math display">\[f(x,y)=\begin{cases}\frac{xy}{\sqrt{x^2+y^2}}, &amp; (x,y)\neq(0,0) \\ 0, &amp; (x,y)=(0,0) \\ \end{cases}\]</span> 在 <span class="math inline">\((0,0)\)</span> 的邻域中连续且有有界的偏导数 <span class="math inline">\(f_x&#39;(x,y)\)</span> 和 <span class="math inline">\(f&#39;_y(x,y)\)</span>, 但函数在点 <span class="math inline">\((0,0)\)</span> 不可微 .</p></li><li><p>设 <span class="math inline">\(f:\mathbf{R}^n\rightarrow\mathbf{R}^n\)</span> 是开集 <span class="math inline">\(G\)</span> 上的 <span class="math inline">\(C^1\)</span> 类函数, 且 <span class="math inline">\(J_f(x_0)=0\)</span>, 记 <span class="math inline">\(y_0=f(x_0)\)</span>. 如果 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(x_0\)</span> 存在反函数 <span class="math inline">\(f^{-1}\)</span>, 求证 <span class="math inline">\(f^{-1}\)</span> 在 <span class="math inline">\(y_0\)</span> 不可微.</p></li><li><p>证明: 由方程 <span class="math display">\[y=x\varphi(x)+\psi(z)\]</span> 所定义的隐函数 <span class="math inline">\(z=z(x,y)\)</span> 满足方程 <span class="math display">\[\left(\frac{\partial z}{\partial y}\right)^2\frac{\partial^2 z}{\partial x^2}-2\frac{\partial z}{\partial x}\frac{\partial z}{\partial y}\frac{\partial^2 z}{\partial x\partial y}+\left(\frac{\partial z}{\partial x}\right)^2\frac{\partial^2 z}{\partial y^2}=0.\]</span></p></li></ol><h2 id="秋-数学分析三-期末-唐仲伟">2016秋 数学分析三 期末 唐仲伟</h2><h3 id="计算题-2">计算题</h3><p>共20分, 前四题每题5分, 后3题每题10分.</p><ol type="1"><li><p>计算二重积分 <span class="math inline">\(\iint\limits_E xydxdy\)</span>, 其中 <span class="math inline">\(E\)</span> 是四条抛物线 <span class="math display">\[y^2=px,~y^2=qx,~x^2=ay,~x^2=by\]</span> 所围成的区域, <span class="math inline">\(0&lt;p&lt;q\)</span>, <span class="math inline">\(0&lt;a&lt;b\)</span>.</p></li><li><p>计算三重积分 <span class="math inline">\(\iiint\limits_Vxyzdxdydz\)</span>, 其中 <span class="math inline">\(V\)</span> 是由曲面 <span class="math display">\[x^2+y^2+z^2=1,x\geqslant,y\geqslant0,z\geqslant0\]</span> 所围成的区域.</p></li><li><p>计算第一型曲线积分 <span class="math inline">\(\int\nolimits_C(x^2+y^2)ds\)</span>, 其中 <span class="math inline">\(C\)</span> 为曲线 <span class="math display">\[x=a(\cos t+t\sin t),y=a(\sin t-t\cos t)~(0\leqslant t \leqslant 2\pi).\]</span></p></li><li><p>计算第一型曲面积分 <span class="math inline">\(\iint\limits_S(x+y+z)dS\)</span>, 其中 <span class="math inline">\(S\)</span> 为曲面 <span class="math inline">\(x^2+y^2+z^2=a^2\)</span>, <span class="math inline">\(z\geqslant0\)</span>.</p></li><li><p>设 <span class="math inline">\(\sin z-xyz=0\)</span>, 当 <span class="math inline">\(\cos z-xy\neq0\)</span> 时, 求 <span class="math inline">\(\frac{\partial z}{\partial x}\)</span>, <span class="math inline">\(\frac{\partial^2 z}{\partial y\partial x}\)</span>.</p></li><li><p>求函数 <span class="math inline">\(f(x,y,z)=x-2y+2z\)</span> 在球面 <span class="math inline">\(x^2+y^2+z^2=1\)</span> 上的最大、最小值.</p></li><li><p>计算第二型曲线积分 <span class="math inline">\(\oint\nolimits_C e^x[(1-\cos y)dx-(y-\sin y)dy]\)</span>, 其中 <span class="math inline">\(C\)</span> 是曲线 <span class="math inline">\(y=\sin x\)</span> 介于 <span class="math inline">\([0,1]\)</span> 的一段, <span class="math inline">\(C\)</span> 的方向对应于 <span class="math inline">\(x\)</span> 增加的方向.</p></li></ol><h3 id="证明题-2">证明题</h3><p>共50分, 每题10分.</p><ol type="1"><li><p>设二元数值函数 <span class="math inline">\(f(x,y)\)</span> 在 <span class="math inline">\([a,b]\times[c,d]\)</span> 上连续, 一元数值函数序列 <span class="math inline">\(\{\phi_n(x)\}\)</span> 在 <span class="math inline">\([a,b]\)</span> 上一致收敛, 且 <span class="math inline">\(\phi_n(x)\in [c,d]\)</span>. 则 <span class="math inline">\(g_n=f(x,\phi_n(x))\)</span> 在 <span class="math inline">\([a,b]\)</span> 上一致收敛.</p></li><li><p>设数值函数 <span class="math inline">\(z=f(x,y)\)</span> 在矩形区域 <span class="math inline">\(D=[a,b]\times[c,d]\subset\mathbb{R}^2\)</span> 上偏导数有界, 求证: <span class="math inline">\(f\)</span> 在 <span class="math inline">\(D\)</span> 上一致连续.</p></li><li><p>设三重积分 <span class="math inline">\(\iiint\limits_D f(x,y,z)dxdydz\)</span> 存在, 区域 <span class="math inline">\(D\)</span> 关于 <span class="math inline">\(xOy\)</span> 平面对称, 被积函数 <span class="math inline">\(f\)</span> 关于 <span class="math inline">\(x\)</span> 是一个奇函数, 即 <span class="math inline">\(f(-x,y,z)=-f(x,y,z)\)</span>, 求证: <span class="math inline">\(\iiint\limits_D f(x,y,z)dxdydz=0\)</span>.</p></li><li><p>设 <span class="math inline">\(f\in C[0,a]\)</span>, 即 <span class="math inline">\(f\)</span> 在区间 <span class="math inline">\([0,1]\)</span> 上连续, 证明: <span class="math display">\[\int\nolimits_0^a dx_1\int\nolimits_0^{x_1}dx_2\cdots\int_0^{x_{n-1}} f(x_1)f(x_2)\cdots f(x_n)dx_n=\frac{1}{n!}\left[\int\nolimits_0^a f(x)dx\right]^n.\]</span></p></li><li><ol type="i"><li>设 <span class="math inline">\(S\)</span> 为 <span class="math inline">\(\mathbb{R}^3\)</span> 空间中分片光滑的封闭定向曲面, <span class="math inline">\(\nu_0\)</span> 为任意固定的方向, <span class="math inline">\(N\)</span> 为 <span class="math inline">\(S\)</span> 的单位外法向量, 求证 <span class="math display">\[\iint\limits_S \cos(\nu_0, N)dS=0.\]</span></li><li>证明Lebesgue引理: 设 <span class="math inline">\(\mathbb{R}^n\)</span> 中的紧集 <span class="math inline">\(D\)</span> 有一个开覆盖 <span class="math inline">\(\mathfrak{C}=\{G_\alpha\}\)</span>, 则存在正数 <span class="math inline">\(l&gt;0\)</span>, 对于 <span class="math inline">\(\forall~x\in D\)</span>, <span class="math inline">\(\exists~G_\alpha\in\mathfrak{C}\)</span>, s.t. <span class="math inline">\(x\)</span> 的球(方)邻域 <span class="math inline">\(U(x,l)\subset G_\alpha\)</span>.</li></ol></li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 数学分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学高等代数试卷</title>
      <link href="/2017/07/04/BNU-Linear-Algebra-Exam/"/>
      <content type="html"><![CDATA[<ul><li>2016 高等代数二 期中 刘玉明</li><li>2016 高等代数二 期末 刘玉明</li></ul><a id="more"></a><h2 id="高等代数二-期中-刘玉明">2016 高等代数二 期中 刘玉明</h2><p>以下各题中, 所指的向量空间都是有限的.</p><ol type="1"><li><p>假设域 <span class="math inline">\(F\)</span> 上的2维向量空间 <span class="math inline">\(V\)</span> 有一组基 <span class="math inline">\(v_1,v_2\)</span>. 设 <span class="math inline">\(\sigma:V\rightarrow V\)</span> 是一个线性变换, 且满足 <span class="math inline">\(\sigma(v_1)=0\)</span>, <span class="math inline">\(\sigma(v_2)=v_1\)</span>. 证明: 如果 <span class="math inline">\(W\)</span> 是 <span class="math inline">\(V\)</span> 的一个 <span class="math inline">\(\sigma\)</span>-不变子空间, 则或者 <span class="math inline">\(W=0\)</span>, 或者 <span class="math inline">\(W\)</span> 是由 <span class="math inline">\(v_1\)</span> 生成的1维子空间, 或者 <span class="math inline">\(W=V\)</span>.</p></li><li><p>设 <span class="math inline">\(V\)</span> 是域 <span class="math inline">\(F\)</span> 上的向量空间, <span class="math inline">\(W\)</span> 是 <span class="math inline">\(V\)</span> 的一个子空间. 证明: 存在 <span class="math inline">\(V\)</span> 的子空间 <span class="math inline">\(W&#39;\)</span>, s.t. <span class="math inline">\(V=W\oplus W&#39;\)</span>.</p></li><li><p>判断下列域 <span class="math inline">\(F\)</span> 上的 <span class="math inline">\(n\)</span> 阶方阵 <span class="math inline">\(A\)</span> 能否对角化, 并说明理由.</p><ol type="1"><li><p><span class="math inline">\(A\)</span> 满足 <span class="math inline">\(A\neq 0\)</span>, <span class="math inline">\(A^2=0\)</span>.</p></li><li><p><span class="math inline">\(A\)</span> 满足 <span class="math inline">\(A^2=A\)</span>.</p></li></ol></li><li><p>设 <span class="math inline">\(\sigma:V\rightarrow V&#39;\)</span> 是一个线性映射. 证明 <span class="math inline">\(\sigma\)</span> 诱导出向量空间的同构 <span class="math display">\[\overline{\sigma}:V/\ker\sigma \xrightarrow{\sim} {\rm Im}\sigma,\quad v+\ker\sigma\mapsto\sigma(v).\]</span></p></li><li><p>试用向量组的线性相关性理论证明线性方程组有解的判别准则.</p></li></ol><h2 id="高等代数二-期末-刘玉明">2016 高等代数二 期末 刘玉明</h2><ol type="1"><li>(20分)设 <span class="math inline">\(\alpha\)</span> 为 <span class="math inline">\(n\)</span> 维欧氏空间 <span class="math inline">\(V\)</span> 中的一个单位向量, 定义映射 <span class="math display">\[\sigma_\alpha:~V\longrightarrow V,\quad\xi\longmapsto\xi-2(\xi,\alpha)\alpha.\]</span><ol type="1"><li>证明 <span class="math inline">\(\sigma_\alpha\)</span> 为一个正交变换. 这样的正交变换称为由 <span class="math inline">\(\alpha\)</span> 定义的镜面反射.</li><li>证明: 存在 <span class="math inline">\(V\)</span> 的规范正交基, 使得 <span class="math inline">\(\sigma_\alpha\)</span> 在这组基下的矩阵为: <span class="math display">\[\begin{bmatrix}-1 &amp; &amp; &amp; \\  &amp; 1 &amp; &amp; \\    &amp; &amp; \ddots &amp; \\     &amp; &amp; &amp; 1 \\  \end{bmatrix}\]</span></li></ol></li><li><p>(10分)设 <span class="math inline">\(A\)</span> 是3阶实对称矩阵，<span class="math inline">\(A\)</span> 的特征值为0, 3, 3. 已知 <span class="math inline">\(\xi_1=(1,1,1)^T,~\xi_2=(-1,1,0)^T\)</span> 分别是属于特征值0和3的特征向量. 求属于特征值3的与 <span class="math inline">\(\xi_2\)</span> 线性无关的另一个特征向量 <span class="math inline">\(\xi_3\)</span>.</p></li><li>(20分)设3元实二次型 <span class="math display">\[q(x_1,x_2,x_3)=2x_1^2+x_2^2-4x_1x_2-4x_2x_3.\]</span><ol type="1"><li>求 <span class="math inline">\(q\)</span> 的秩和正惯性指数.</li><li>求一个正交替换，将 <span class="math inline">\(q\)</span> 化为典范形.</li></ol></li><li>(20分)设矩阵 <span class="math display">\[A=\begin{bmatrix}2 &amp; 0 &amp; 0 \\0 &amp; 2 &amp; 0 \\1 &amp; 0 &amp; 2 \\ \end{bmatrix}\]</span><ol type="1"><li>分别求 <span class="math inline">\(A\)</span> 的特征多项式和最小多项式.</li><li>矩阵 <span class="math inline">\(A\)</span> 能否对角化？如不能, 求出它的若尔当标准型.</li></ol></li><li><p>(15分)设 <span class="math inline">\(q(x_1,x_2,\cdots,x_n)=x^TAx\)</span> 是一实二次型, 其中 <span class="math inline">\(A=(a_{ij})\)</span> 是 <span class="math inline">\(n\)</span> 阶实对称矩阵. 设 <span class="math inline">\(\lambda\)</span> 与 <span class="math inline">\(\mu\)</span> 分别是 <span class="math inline">\(A\)</span> 的最大与最小特征值. 证明: 对于 <span class="math inline">\(\mathbf{R}^n\)</span> 中任一列向量 <span class="math inline">\(\alpha\)</span>, 有 <span class="math display">\[\mu|\alpha|^2\leqslant\alpha^TA\alpha\leqslant\lambda|\alpha|^2.\]</span></p></li><li><p>(15分)证明: 如果 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 都是 <span class="math inline">\(n\)</span> 阶实对称矩阵, 并且 <span class="math inline">\(A\)</span> 正定, 那么存在 <span class="math inline">\(n\)</span> 阶实可逆矩阵 <span class="math inline">\(P\)</span>, 使得 <span class="math inline">\(P^TAP\)</span> 和 <span class="math inline">\(P^TBP\)</span> 都是对角矩阵.</p></li></ol><h3 id="简略解答">简略解答</h3><ol type="1"><li>一定记得先验证它是一个线性变换, 再验证其正交性, 否则会丢掉4分.</li><li>早就不记得了, 其余全略.</li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学近世代数试卷</title>
      <link href="/2017/07/03/BNU-Abstract-Algebra-Exam/"/>
      <content type="html"><![CDATA[<ul><li>2015 期末试题 刘玉明</li><li>2016 期中试题 胡维 刘玉明</li><li>2016 期末试题 胡维 刘玉明</li></ul><a id="more"></a><h2 id="期末试题-刘玉明">2015 期末试题 刘玉明</h2><ol type="1"><li>(20分) <span class="math inline">\(\mathbb{Z}_n=\{[0],[1],\cdots,[n-1]\}\)</span> 表示模 <span class="math inline">\(n\)</span> 的剩余类加群.<ol type="1"><li>写出 <span class="math inline">\(\mathbb{Z}_4\)</span> 的加法运算表.</li><li>写出 <span class="math inline">\(\mathbb{Z}_6\)</span> 的所有子群.</li><li><span class="math inline">\(\mathbb{Z}_7\)</span> 有几个子群?</li><li><span class="math inline">\(\mathbb{Z}_{28}\)</span> 有几个 <span class="math inline">\(7\)</span> 阶元?</li></ol></li><li>(20分) <span class="math inline">\(\mathbb{Z}_n^*=\{[a]\in\mathbb{Z}_n~|~a~与~n~互素\}\)</span>.<ol type="1"><li>证明: <span class="math inline">\(\mathbb{Z}_n^*\)</span> 关于乘法 <span class="math inline">\([a][b]=[ab]\)</span> 构成一个阿贝尔群.</li><li>求 <span class="math inline">\([3]\)</span> 在 <span class="math inline">\(\mathbb{Z}_8^*\)</span> 以及 <span class="math inline">\([5]\)</span> 在 <span class="math inline">\(\mathbb{Z}_{13}^*\)</span> 中的逆元.</li></ol></li><li>(15分) 用 <span class="math inline">\(S_5\)</span> 表示 <span class="math inline">\(5\)</span> 次对称群.<ol type="1"><li><span class="math inline">\(\sigma=(12345)\)</span> 是 <span class="math inline">\(S_5\)</span> 中的几阶元?</li><li><span class="math inline">\(S_5\)</span> 中与 <span class="math inline">\(\sigma\)</span> 共轭的元素有几个?</li><li>写出循环群 <span class="math inline">\(\langle\sigma\rangle\)</span> 中的所有元素. <span class="math inline">\(\langle\sigma\rangle\)</span> 是不是 <span class="math inline">\(S_5\)</span> 的正规子群?</li></ol></li><li>(20分)<ol type="1"><li>写出整数环 <span class="math inline">\(\mathbb{Z}\)</span> 的所有极大理想.</li><li>写出模 <span class="math inline">\(18\)</span> 的剩余类环 <span class="math inline">\(\mathbb{Z}_{18}\)</span> 的所有极大理想.</li><li><span class="math inline">\(x^2+1\)</span> 是否是 <span class="math inline">\(\mathbb{Z}_3[x]\)</span> 中的不可约多项式?</li><li><span class="math inline">\(\mathbb{Z}_3[x]/\langle x^2+1\rangle\)</span> 是怎样的环?</li></ol></li><li>(15分) 用 <span class="math inline">\(R\)</span> 表示环 <span class="math inline">\(\mathbb{Z}[i]/\langle 1+3i \rangle\)</span>, 其中 <span class="math inline">\(\mathbb{Z}[i]\)</span> 表示高斯整环, 证明:<ol type="1"><li>在 <span class="math inline">\(R\)</span> 中, <span class="math inline">\([i]=[3]\)</span>, <span class="math inline">\([10]=[0]\)</span>, <span class="math inline">\([a+bi]=[a+3b]\)</span>, <span class="math inline">\(\forall a, b\in\mathbb{Z}\)</span>.</li><li><span class="math inline">\(\varphi:\mathbb{Z}\to R~(a\mapsto [a])\)</span> 是环的满同态.</li><li><span class="math inline">\(\ker\varphi=10\mathbb{Z}\)</span>. 从而 <span class="math inline">\(R=\mathbb{Z}_{10}\)</span>.</li></ol></li><li>(10分)<ol type="1"><li>设 <span class="math inline">\(E=F(\alpha)\)</span> 是域 <span class="math inline">\(F\)</span> 的单超越扩域, <span class="math inline">\(\beta\in E\backslash F\)</span>. 证明: <span class="math inline">\(\alpha\)</span> 是 <span class="math inline">\(F(\beta)\)</span> 上的代数元.</li><li>证明或否定一下命题: 设 <span class="math inline">\(E/F\)</span> 是域扩张, <span class="math inline">\(\alpha\in E\)</span>, <span class="math inline">\(m,n\in\mathbb{Z}^+\)</span>. 如果 <span class="math inline">\(\alpha\)</span> 是 <span class="math inline">\(F\)</span> 上 <span class="math inline">\(n\)</span> 次代数元, 且 <span class="math inline">\(m\)</span> 与 <span class="math inline">\(n\)</span> 互素, 那么 <span class="math inline">\(\alpha^m\)</span> 也是 <span class="math inline">\(F\)</span> 上的 <span class="math inline">\(n\)</span> 次代数元, 且 <span class="math inline">\(F(\alpha^m)=F(\alpha)\)</span>.</li></ol></li></ol><h2 id="期中试题-胡维-刘玉明">2016 期中试题 胡维 刘玉明</h2><ol type="1"><li><p>(10分) 用 <span class="math inline">\(S_4\)</span> 代表4次对称群. 按共轭类写出 <span class="math inline">\(S_4\)</span> 的全部元素.</p></li><li>(10分)<ol type="1"><li>循环群 <span class="math inline">\(\mathbb{Z}_{28}\)</span> 中的7阶元有几个?</li><li><span class="math inline">\(\mathbb{Z}_{28}\)</span> 有几个7阶子群?</li></ol></li><li>(15分) 令 <span class="math inline">\(\varphi:(\mathbb{R},+)\longrightarrow (\mathbb{C}^\times,\cdot)\)</span> 是由 <span class="math inline">\(\varphi(x)=e^{ix}\)</span> 定义的函数, 其中 <span class="math inline">\((\mathbb{R},+)\)</span> 和 <span class="math inline">\((\mathbb{C}^\times,+)\)</span> 分别代表实数的加法群和非零复数的乘法群.<ol type="1"><li>证明: <span class="math inline">\(\varphi\)</span> 是一个群同态.</li><li>求 <span class="math inline">\(\ker\varphi\)</span> 和 <span class="math inline">\({\rm Im}~\varphi\)</span>.</li><li>根据同态基本定理, 你能得到什么结论?</li></ol></li><li><p>(15分) 应用群作用证明: 8阶群的中心至少有两个元素.</p></li><li>(10分) 求下列环中的(乘法)可逆元:<ol type="1"><li>模8的剩余类环 <span class="math inline">\(\mathbb{Z}/8\mathbb{Z}\)</span>.</li><li>高斯整环 <span class="math inline">\(\mathbb{Z}[i]\)</span>.</li></ol></li><li>(20分)<ol type="1"><li><span class="math inline">\(\mathbb{Z}_{10}\)</span> 与 <span class="math inline">\(\mathbb{Z}_2\times\mathbb{Z}_5\)</span> 作为环同构吗? 为什么?</li><li><span class="math inline">\(\mathbb{Z}_9\)</span> 与 <span class="math inline">\(\mathbb{Z}_3\times\mathbb{Z}_3\)</span> 作为环同构吗? 为什么?</li></ol></li><li>(20分)<ol type="1"><li>利用环的同态基本定理证明: <span class="math inline">\(\mathbb{Z}[x]/\langle x^2+1\rangle\cong\mathbb{Z}[i]\)</span>.</li><li><span class="math inline">\(\langle x^2+1 \rangle\)</span> 是 <span class="math inline">\(\mathbb{Z}[i]\)</span> 的素理想吗? 是极大理想吗?</li></ol></li></ol><h2 id="期末试题-胡维-刘玉明">2016 期末试题 胡维 刘玉明</h2><ol type="1"><li>(20分) 整数集 <span class="math inline">\(\mathbb{Z}\)</span> 关于普通加法构成有理数集 <span class="math inline">\(\mathbb{Q}\)</span> 的子群. 任取 <span class="math inline">\(q\in\mathbb{Q}\)</span>, 用 <span class="math inline">\([q]=q+\mathbb{Z}\)</span> 表示商群 <span class="math inline">\(\mathbb{Q}/\mathbb{Z}\)</span> 中对应的元素.<ol type="1"><li>写出商群 <span class="math inline">\(\mathbb{Q}/\mathbb{Z}\)</span> 的单位元.</li><li>求元素 <span class="math inline">\([\frac{9}{4}]\)</span> 在群 <span class="math inline">\(\mathbb{Q}/\mathbb{Z}\)</span> 的阶.</li><li>证明: 群 <span class="math inline">\(\mathbb{Q}/\mathbb{Z}\)</span> 中每个元素的阶都有限.</li><li><span class="math inline">\(\mathbb{Q}/\mathbb{Z}\)</span> 是不是循环群? 为什么?</li></ol></li><li>(15分) 下列三个群互相同构吗? 说明理由. 其中, <span class="math inline">\(A_4\)</span> 代表4次交错群, <span class="math inline">\(\mathbb{Z}_{12}\)</span> 代表模12的剩余类加群, 等等.<ol type="1"><li><span class="math inline">\(\mathbb{Z}_{12}\)</span>.</li><li><span class="math inline">\(\mathbb{Z}_3\times\mathbb{Z}_4\)</span>. (群的外直积)</li><li><span class="math inline">\(A_4\)</span>.</li></ol></li><li><p>(10分) 设 <span class="math inline">\(G\)</span> 是一个群, 任取 <span class="math inline">\(x\in G\)</span>, 称 <span class="math inline">\(C_x=\{gxg^{-1}|g\in G\}\)</span> 为元素 <span class="math inline">\(x\)</span> 所在的共轭类. 每个共轭类 <span class="math inline">\(C_x\)</span> 中所含元素的个数一定整除群的阶 <span class="math inline">\(|G|\)</span>, 为什么?</p></li><li>(20分) 令 <span class="math inline">\(\mathbb{Z}[i]=\{a+bi|a,b\in\mathbb{Z}\}\)</span> 代表高斯整环. 在 <span class="math inline">\(\mathbb{Z}[i]\)</span> 中定义范数如下: <span class="math display">\[N(a+bi)=a^2+b^2.\]</span><ol type="1"><li>求出 <span class="math inline">\(\mathbb{Z}[i]\)</span> 中的所有单位 (即乘法可逆元).</li><li>求出 <span class="math inline">\(\mathbb{Z}[i]\)</span> 的商域.</li><li>素数2是 <span class="math inline">\(\mathbb{Z}[i]\)</span> 中的逆元吗? 为什么?</li><li>有人说, <span class="math inline">\(\mathbb{Z}[i]\)</span> 中的非零素理想也是极大理想. 你认为对吗? 为什么?</li></ol></li><li>(10分) 设 <span class="math inline">\(E=\mathbb{Q}(\sqrt{2},i)\)</span> 是有理数域 <span class="math inline">\(\mathbb{Q}\)</span> 的扩域.<ol type="1"><li>求扩域的次数 <span class="math inline">\([E:\mathbb{Q}]\)</span>.</li><li>证明: <span class="math inline">\(E=\mathbb{Q}(\sqrt{2}+i)\)</span>.</li></ol></li><li>(20分) 考虑有限域 <span class="math inline">\(\mathbb{Z}_3\)</span> 上的不可约多项式 <span class="math inline">\(p(x)=x^2+x-1\)</span>.<ol type="1"><li>设 <span class="math inline">\(\alpha\)</span> 是 <span class="math inline">\(p(x)\)</span> 在它的分裂域中的一个根. 单扩域 <span class="math inline">\(\mathbb{Z}_3(\alpha)\)</span> 是 <span class="math inline">\(\mathbb{Z}_3\)</span> 上的几次扩域?</li><li>写出 <span class="math inline">\(\mathbb{Z}_3(\alpha)\)</span>作为 <span class="math inline">\(\mathbb{Z}_3\)</span> 上的向量空间的一组基.</li><li>用这组基表达 <span class="math inline">\(\alpha\)</span> 和 <span class="math inline">\(1+\alpha\)</span> 在 <span class="math inline">\(\mathbb{Z}_3(\alpha)\)</span> 中的逆元.</li><li>证明: <span class="math inline">\(p(x)\)</span> 整除 <span class="math inline">\(x^9-x\)</span> (在 <span class="math inline">\(\mathbb{Z}_3[x]\)</span> 中).</li></ol></li><li><p>(5分) 考虑81元域 <span class="math inline">\(F\)</span> 的非零元乘法群 <span class="math inline">\(F^\times\)</span>. 设 <span class="math inline">\(\alpha\)</span> 是 <span class="math inline">\(F^\times\)</span> 的生成元. 证明: <span class="math inline">\(\alpha^{40}=-1\)</span>.</p></li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 抽象代数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学实变函数试卷</title>
      <link href="/2017/07/02/BNU-Real-Analysis-Exam/"/>
      <content type="html"><![CDATA[<ul><li>2016-2017学年第二学期期中考试 李俊峰</li></ul><a id="more"></a><h2 id="学年第二学期期中考试-李俊峰">2016-2017学年第二学期期中考试 李俊峰</h2><ol type="1"><li><p>(15分) 设 <span class="math inline">\(\{E_k\}\)</span> 是 <span class="math inline">\([0,1]\)</span> 中的可测集列, <span class="math inline">\(m(E_k)=1~(k=1,2,\cdots)\)</span>, 试证明 <span class="math display">\[m\left(\bigcap_{k=1}^\infty E_k\right)=1.\]</span></p></li><li><p>(15分) 试证明点集 <span class="math inline">\(E\)</span> 可测的充分必要条件是: 对于任给的 <span class="math inline">\(\epsilon&gt;0\)</span>, 存在开集 <span class="math inline">\(G_1,G_2\)</span>: <span class="math display">\[G_1\supset E,\quad G_2\supset E^C\]</span> 使得 <span class="math inline">\(m(G_1\cap G_2)&lt;\epsilon\)</span>.</p></li><li><p>(15分) 设 <span class="math inline">\(E\subset \mathbb{R}\)</span> 上可测函数列 <span class="math inline">\(\{f_k(x)\}\)</span> 满足 <span class="math display">\[f_k(x)\geqslant f_{k+1}(x),(k=1,2,\cdots).\]</span> 若 <span class="math inline">\(f_k\)</span> 在 <span class="math inline">\(E\)</span> 上依测度收敛到0, 试问 <span class="math inline">\(f_k\)</span> 在 <span class="math inline">\(E\)</span> 上是否几乎处处收敛到0.</p></li><li><p>(15分) 设 <span class="math inline">\(f(x)\)</span> 是 <span class="math inline">\((0,1)\)</span> 上的非负可测函数, 若存在 <span class="math inline">\(c\)</span> 使得 <span class="math display">\[\int\nolimits_{[0,1]}[f(x)]^ndx=c,(n=1,2,\cdots)\]</span> 试证明存在非负可测集 <span class="math inline">\(E\subset(0,1)\)</span>, s.t. <span class="math inline">\(f(x)=\chi_E(x)\)</span>, a.e. 若 <span class="math inline">\(f(x)\)</span> 不是非负的, 结论又如何?</p></li><li><p>(15分) 设 <span class="math inline">\(f\in L(0,a)\)</span>, <span class="math inline">\(g(x)=\int\nolimits_x^a \frac{f(t)}{t}dt\)</span>, <span class="math inline">\(a&gt;x&gt;0\)</span>. 试证明 <span class="math inline">\(g\in L(0,a)\)</span>, 且有 <span class="math display">\[\int\nolimits_0^a g(x)dx=\int\nolimits_0^a f(x)dx.\]</span></p></li><li><p>(15分) 设 <span class="math inline">\(f\in L^2(0,\infty)\)</span>, 且 <span class="math inline">\(f\geqslant 0\)</span>. 设 <span class="math inline">\(F(x)=\int\nolimits_0^x f(t)dt\)</span>, 试证明 <span class="math display">\[F(x)=o(\sqrt{x})~(x\to0,x\to\infty).\]</span></p></li><li>(10分) 设 <span class="math inline">\(f\in L^1(\mathbb{R}^n)\)</span>, 对 <span class="math inline">\(x\in\mathbb{R}^n\)</span>, 称 <span class="math display">\[\hat{f}(x)=\int\nolimits_{\mathbb{R}^n} f(t)e^{-2\pi x\cdot t}dx\]</span> 为 <span class="math inline">\(f\)</span> 的Fourier变换. 请验证以下几个性质:<ol type="a"><li><span class="math inline">\(||\hat{f}||_{L^\infty(\mathbb{R}^n)}\leqslant ||f||_{L^1(\mathbb{R}^n)}\)</span>.</li><li><span class="math inline">\(\hat{f}\)</span> 在 <span class="math inline">\(\mathbb{R}^n\)</span> 上一致连续.</li><li><span class="math inline">\(\lim\limits_{|x|\to\infty}\hat{f}(x)=0\)</span>. (提示: 计算阶梯函数的Fourier变换, 再应用阶梯函数在 <span class="math inline">\(L^1(\mathbb{R}^n)\)</span> 的稠密性).</li></ol></li></ol><p>记号说明: <span class="math inline">\(x,t\in\mathbb{R}^n\)</span>, 那么 <span class="math inline">\(x\cdot t=x_1t_1+x_2t_2+\cdots+x_nt_n\)</span>. 欧拉公式: <span class="math display">\[e^{i\theta}=\cos\theta+i\sin\theta.\]</span></p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 实变函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>组合数学复习重点</title>
      <link href="/2017/06/24/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/"/>
      <content type="html"><![CDATA[<h2 id="第二章-抽屉原理">第二章 抽屉原理</h2><p>吧 <span class="math inline">\(n+1\)</span> 个物体放入 <span class="math inline">\(n\)</span> 个抽屉, 则至少存在一个抽屉里面有至少两个物体.</p><h2 id="第三章-排列组合">第三章 排列组合</h2><h3 id="重集的排列">重集的排列</h3><p><span class="math inline">\(k\)</span> 种元素, 个数无限: <span class="math inline">\(r\)</span>-排列数为 <span class="math inline">\(k^r\)</span>. <span class="math inline">\(k\)</span> 种元素, 第 <span class="math inline">\(i\)</span> 种有 <span class="math inline">\(n_i\)</span> 个: 全排列为 <span class="math inline">\(\frac{(n_1+\cdots+n_k)!}{n_1!\cdots n_k!}\)</span>.</p><h3 id="重集的组合">重集的组合</h3><p><span class="math inline">\(x_1+\cdots+x_k=r\)</span> 的非负整数解个数为 <span class="math inline">\(\binom{r+k-1}{r}\)</span>.</p><h2 id="第四章-二项式系数">第四章 二项式系数</h2><h3 id="组合恒等式">组合恒等式</h3><ol type="1"><li>(帕斯卡公式): <span class="math inline">\(\binom{\alpha}{k}=\binom{\alpha-1}{k}+\binom{\alpha-1}{k-1}\)</span>;</li><li><span class="math inline">\(\binom{\alpha}{k}\binom{k}{p}=\binom{\alpha}{p}\binom{\alpha-p}{k-p}=\binom{\alpha}{k-p}\binom{\alpha+p-k}{p}\)</span>;</li><li><span class="math inline">\(\binom{\alpha+k}{p+k}\binom{p+k}{k}=\binom{\alpha+k}{k}\binom{\alpha}{p}\)</span>;</li><li><span class="math inline">\(\sum\limits_{k=0}^n\binom{n}{k}=\sum\limits_k\binom{n}{k}=2^n\)</span>;</li><li><span class="math inline">\(\sum\limits_{k=0}^n(-1)^k\binom{\alpha}{k}=(-1)^m\binom{\alpha-1}{m}\)</span>;</li><li><span class="math inline">\(\sum\limits_{k=0}^n\binom{\alpha}{k}\binom{\beta}{n-k}=\binom{\alpha+\beta}{n}\)</span>;</li><li><span class="math inline">\(\sum\limits_{k=0}^n\binom{\alpha+k}{k}\binom{\beta-k}{n-k}=\binom{\alpha+\beta+1}{n}\)</span>.</li></ol><h2 id="第五章-容斥原理">第五章 容斥原理</h2><h3 id="符号说明">符号说明</h3><ul><li><span class="math inline">\(A_i\)</span>: <span class="math inline">\(S\)</span> 中满足性质 <span class="math inline">\(P_i\)</span> 的元素集合;</li><li><span class="math inline">\(N(i)\)</span>: <span class="math inline">\(S\)</span> 中恰好具有 <span class="math inline">\(i\)</span> 个性质的元素集合;</li><li><span class="math inline">\(L(i)\)</span>: <span class="math inline">\(S\)</span> 中至少具有 <span class="math inline">\(i\)</span> 个性质的元素集合;</li><li><span class="math inline">\(W(i)\)</span>: <span class="math inline">\(A_1,\cdots,A_m\)</span> 中所有 <span class="math inline">\(i\)</span> 个交集的元素个数之和.</li></ul><h3 id="容斥原理">容斥原理</h3><ol type="1"><li><span class="math inline">\(N(0)=W(0)-W(1)+W(2)-\cdots+(-1)^mW(m)\)</span>;</li><li><span class="math inline">\(L(1)=|S|-N(0)=W(1)-W(2)+W(3)-\cdots+(-1)^{m-1}W(m)\)</span>.</li></ol><h3 id="重集的组合-1">重集的组合</h3><blockquote><p>求方程 <span class="math inline">\(x_1+\cdots+x_n=r\)</span> 带上下界 <span class="math inline">\((a_i\leqslant x_i\leqslant b_i)\)</span> 的整数解个数.</p></blockquote><p><strong>解答</strong>: 先做变换 <span class="math inline">\(y_i=x_i-a_i\)</span>, 则方程变形为 <span class="math inline">\(y_1+\cdots+y_n=r-a_1-\cdots-a_n\)</span>. 记 <span class="math inline">\(y_i\leqslant b_i-a_i\)</span> 为条件 <span class="math inline">\(P_i\)</span>, 用容斥原理即可.</p><h3 id="错位排列与禁位排列">错位排列与禁位排列</h3><h4 id="错位排列">错位排列</h4><ul><li>递推: <span class="math inline">\(D_n=(n-1)(D_{n-1}+D_{n-2})\)</span>, <span class="math inline">\(D_1=0\)</span>, <span class="math inline">\(D_2=1\)</span>;</li><li>通项: <span class="math inline">\(D_n=n!\cdot\left(1-\frac{1}{1!}+\frac{1}{2!}-\cdots+\frac{1}{n!}\right)\)</span>.</li></ul><h4 id="禁位排列">禁位排列</h4><ul><li>递推: <span class="math inline">\(Q_n=(n-1)Q_{n-1}+(n-2)Q_{n-2}\)</span>;</li><li>组合证明: 考虑去掉 <span class="math inline">\(n\)</span> 的情况, 若前 <span class="math inline">\(n-1\)</span> 项本身就能构成禁位排列, 则只需要 <span class="math inline">\(n\)</span> 不在 <span class="math inline">\(n-1\)</span> 后即可, 方案数 <span class="math inline">\((n-1)Q_{n-1}\)</span>; 若前 <span class="math inline">\(n-1\)</span> 项本身不能构成禁位排列, 则只能有一个 <span class="math inline">\(i\)</span> 使得 <span class="math inline">\(a_{i+1}=a_i+1\)</span>, 则此时 <span class="math inline">\(n\)</span> 只能放在此处, 考虑到 <span class="math inline">\(i\)</span> 有 <span class="math inline">\(n-2\)</span> 种选择, 并且去掉 <span class="math inline">\(i+1\)</span> 后, 序列构成长度为 <span class="math inline">\(n-2\)</span> 的禁位排列, 此时方案数为 <span class="math inline">\((n-2)Q_{n-2}\)</span>, 得证.</li></ul><h2 id="第六章-递推关系与生产函数">第六章 递推关系与生产函数</h2><h3 id="递推关系">递推关系</h3><h4 id="线性-齐次-常系数">线性 齐次 常系数</h4><p><span class="math inline">\(h_n-a_1h_{n-1}-\cdots-a_kh_{n-k}=0\)</span> 的特征方程为 <span class="math inline">\(q_k-a_1q_{k-1}-\cdots-a_k=0\)</span></p><ol type="1"><li>若特征方程有 <span class="math inline">\(k\)</span> 个单根, 则通解为 <span class="math inline">\(h_n=C_1q_1^n+\cdots+C_kq_k^n\)</span>;</li><li>若 <span class="math inline">\(q_i\)</span> 的重数为 <span class="math inline">\(s_i\)</span>, 则通解为 <span class="math inline">\(n^jq_i,~0\leqslant j\leqslant s_i,~1\leqslant i\leqslant k\)</span> 的线性组合.</li></ol><h4 id="非齐次">非齐次</h4><p>求一个特解, 然后求齐次方程的通解. 设 <span class="math inline">\(f(n)=D_r(n)q^n\)</span>, <span class="math inline">\(D_r\)</span> 为 <span class="math inline">\(r\)</span> 次多项式, 则有特解 <span class="math display">\[h(n)=n^sF_r(n)q^n\]</span> 其中 <span class="math inline">\(F_r\)</span> 为多项式, <span class="math inline">\(s\)</span> 是 <span class="math inline">\(q\)</span> 的重数.</p><h3 id="生成函数">生成函数</h3><p>生成函数: <span class="math inline">\(h(x)=\sum\limits_{n=0}^\infty h_nx^n\)</span>.</p><blockquote><p>若递推式为 <span class="math inline">\(h_n+a_1h_{n-1}+\cdots+a_kh_{n-k}=0\)</span>, 则其生成函数为 <span class="math display">\[h(x)=\frac{b_0+b_1x+\cdots+b_{k-1}x^{k-1}}{1+a_1x+\cdots+a_kx^k}.\]</span> 其中 <span class="math inline">\(b_n=\sum\limits_{i=0}^n a_ih_{n-i}\)</span>, <span class="math inline">\(a_0=1\)</span>.</p></blockquote><h2 id="第八章-二分图匹配">第八章 二分图匹配</h2><h3 id="最大匹配">最大匹配</h3><p>找 <span class="math inline">\(M\)</span>-交错链, 标记算法求最大匹配.</p><blockquote><p>König定理: 最大匹配 <span class="math inline">\(=\)</span> 最小点覆盖.</p></blockquote><p><span class="math inline">\(p\)</span>-正则: 每个点度都是 <span class="math inline">\(p\)</span>. 完美匹配: 若二分图 <span class="math inline">\(G\)</span> 满足 <span class="math inline">\(|X|=|Y|=n\)</span>, 且一个匹配含 <span class="math inline">\(n\)</span> 条边, 则称其为完美匹配.</p><blockquote><p>定理: <span class="math inline">\(p\geqslant 1\)</span> 的 <span class="math inline">\(p\)</span>-正则二分图一定有完美匹配.</p></blockquote><h3 id="稳定匹配">稳定匹配</h3><p>延迟认可算法.</p><blockquote><p>定理: 由延迟认可算法得到的匹配是稳定匹配.</p></blockquote><h2 id="第九章-组合设计">第九章 组合设计</h2><h3 id="pk-元域的构造"><span class="math inline">\(p^k\)</span> 元域的构造</h3><p>取 <span class="math inline">\(\mathbb{Z}_p\)</span> 的 <span class="math inline">\(k\)</span> 次不可约多项式 <span class="math inline">\(f\)</span>, 令其 <span class="math inline">\(k\)</span> 个根为 <span class="math inline">\(a_1,\cdots,a_k\)</span>, 则 <span class="math inline">\(\mathbb{Z}_p\)</span> 的 <span class="math inline">\(k\)</span> 次扩张 <span class="math inline">\(\mathbb{Z}_p(a_1,\cdots,a_k)\)</span> 即为 <span class="math inline">\(p^k\)</span> 元域.</p><h3 id="区组设计">区组设计</h3><h4 id="bibd-的性质">BIBD 的性质</h4><ul><li>每一组含 <span class="math inline">\(k\)</span> 个元素;</li><li>每一对都恰好出现在 <span class="math inline">\(\lambda\)</span> 个区组中, 则为平衡区组设计(Balanced);</li><li><span class="math inline">\(k&lt;v\)</span>, 不完全(Incomplete);</li></ul><blockquote><p>定理: BIBD 中, <span class="math inline">\(r(k-1)=\lambda(v-1)\)</span>.</p></blockquote><p>可利用包含 <span class="math inline">\(x_i\)</span> 的元素对的个数来组合证明.</p><blockquote><p>定理: BIBD 中, <span class="math inline">\(bk=vr\)</span>.</p></blockquote><p>可利用 BIBD 的关联矩阵中 <span class="math inline">\(1\)</span> 的个数来组合证明.</p><blockquote><p>定理: BIBD 中, <span class="math inline">\(b\geqslant v\)</span>.</p></blockquote><p><span class="math inline">\(b=v\)</span> 时称为 SBIBD (symmetric).</p><h4 id="符号说明-1">符号说明</h4><ul><li><span class="math inline">\(b\)</span>: 区组的个数;</li><li><span class="math inline">\(v\)</span>: 集合元素总数;</li><li><span class="math inline">\(k\)</span>: 每个区组中的元素个数;</li><li><span class="math inline">\(r\)</span>: 包含任何一个特定元素的不同区组的个数;</li><li><span class="math inline">\(\lambda\)</span>: 包含任何一对特定元素的不同区组的个数.</li></ul><h4 id="sbibd-的构造">SBIBD 的构造</h4><blockquote><p>定理: 若 <span class="math inline">\(B\)</span> 是 <span class="math inline">\(\mathbb{Z}_v\)</span> 的差分集, 则 <span class="math inline">\(B\)</span> 生成的区组构成一个指标为 <span class="math inline">\(\lambda=\frac{k(k-1)}{v-1}\)</span> 的 SBIBD.</p></blockquote><p>如 <span class="math inline">\(\mathbb{Z}_7\)</span> 中取 <span class="math inline">\(B=\{0,1,3\}\)</span>, 则 <span class="math display">\[\begin{align}B+0 &amp;=\{0,1,3\}, \\B+1 &amp;=\{1,2,4\}, \\B+2 &amp;=\{2,3,5\}, \\B+3 &amp;=\{3,4,6\}, \\B+4 &amp;=\{4,5,0\}, \\B+5 &amp;=\{5,6,1\}, \\B+6 &amp;=\{6,0,2\}, \\\end{align}\]</span> 构成一个 <span class="math inline">\(b=v=7,~k=r=3,~\lambda=1\)</span> SBIBD.</p><h3 id="steiner三元系统">Steiner三元系统</h3><blockquote><p>定理: STS 中, <span class="math inline">\(r=\frac{\lambda(v-1)}{2},~b=\frac{\lambda v(v-1)}{6}\)</span>.</p></blockquote><p>一个 <span class="math inline">\(v=9,~\lambda=1\)</span> 的 STS: <span class="math display">\[\begin{align}&amp;\{0,1,2\},\{3,4,5\},\{6,7,8\}, \\&amp;\{0,3,6\},\{1,4,7\},\{2,5,8\}, \\&amp;\{0,4,8\},\{1,5,6\},\{2,3,7\}, \\&amp;\{0,5,7\},\{1,3,8\},\{2,4,6\}. \\\end{align}\]</span></p><h3 id="拉丁方">拉丁方</h3><p><span class="math inline">\(n\)</span> 阶拉丁方: 由 <span class="math inline">\(n\)</span> 个元素构成的 <span class="math inline">\(n\times n\)</span> 方阵, 每行每列都包含了所有 <span class="math inline">\(n\)</span> 个元素.</p><blockquote><p>定理: <span class="math inline">\((r,n)=1\)</span>, 则 <span class="math inline">\(a_{ij}=r\times i+j\)</span> 构成 <span class="math inline">\(\mathbb{Z}_n\)</span> 的拉丁方, 记作 <span class="math inline">\(\mathbf{L}_n^r\)</span>.</p></blockquote><h4 id="正交拉丁方">正交拉丁方</h4><p>将两个 <span class="math inline">\(n\)</span> 阶拉丁方对应位置的元素组成二元有序组, 可以构成一个新的 <span class="math inline">\(n\)</span> 阶方阵. 如果该方阵中, <span class="math inline">\((0,0)\sim (n-1,n-1)\)</span> 都恰好出现一次, 则称这两个拉丁方正交. 称两两正交的拉丁方为MOLS. 第一行为 <span class="math inline">\(0,\cdots,n-1\)</span> 的MOLS由如下定理给出:</p><blockquote><p>定理: 设 <span class="math inline">\(F\)</span> 是一个 <span class="math inline">\(n=p^k\)</span> 元域, 其中元素为 <span class="math inline">\(f_i\)</span>, 则 <span class="math inline">\(a_{ij}=r\times a_i+a_j\)</span> 为拉丁方, <span class="math inline">\(\forall~r\neq 0\in F\)</span>, 记作 <span class="math inline">\(\mathbf{L}_n^r\)</span>. 当 <span class="math inline">\(r\)</span> 取遍所有 <span class="math inline">\(F\)</span> 中非零值时, 可以得到 <span class="math inline">\(n-1\)</span> 个两两正交的拉丁方.</p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 期末复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微分几何复习重点</title>
      <link href="/2017/06/23/%E5%BE%AE%E5%88%86%E5%87%A0%E4%BD%95%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/"/>
      <content type="html"><![CDATA[<h2 id="重要的定义">重要的定义</h2><h3 id="正则曲线">正则曲线</h3><p>给定参数曲线 <span class="math inline">\(C:r=r(t),~t\in(a,b)\)</span>. 若 <span class="math inline">\(r&#39;(t)\neq 0\)</span> 对于 <span class="math inline">\(\forall~t\)</span> 成立, 则称 <span class="math inline">\(C\)</span> 为<strong>正则曲线</strong>.</p><h3 id="曲线的容许参数变换">曲线的容许参数变换</h3><p>给定正则曲线 <span class="math inline">\(C:r=r(t)\)</span>, 若参数变换 <span class="math inline">\(t=t(u)\)</span> 满足</p><ol type="1"><li><span class="math inline">\(t(u)\)</span> 是 <span class="math inline">\(C^3\)</span> 阶的;</li><li><span class="math inline">\(t&#39;(u)\)</span> 处处非零,</li></ol><p>则称之为<strong>容许的参数变换</strong>. 当 <span class="math inline">\(t&#39;(u)&gt;0\)</span> 时称为保向的, <span class="math inline">\(t&#39;(u)&lt;0\)</span> 时称为反向的.</p><h3 id="曲率向量">曲率向量</h3><p>正则曲线 <span class="math inline">\(C:r=r(t)\)</span> 的单位切向量场 <span class="math inline">\(T(t(s))\)</span> 关于弧长 <span class="math inline">\(s\)</span> 的导向量 <span class="math inline">\(\frac{dT}{ds}=\frac{d^2r}{ds^2}\)</span> 称为曲线 <span class="math inline">\(C\)</span> 在 <span class="math inline">\(r(t(s))\)</span> 处的<strong>曲率向量</strong>; 曲率向量的模长 <span class="math inline">\(\kappa=|\frac{dT}{ds}|\)</span> 称为 <span class="math inline">\(C\)</span> 在 <span class="math inline">\(r(t(s))\)</span> 处的<strong>曲率</strong>.</p><h3 id="相对曲率">相对曲率</h3><p>给定二阶连续可微的弧长参数化平面曲线 <span class="math inline">\(C:r=r(s)=(x(s),y(s))\)</span>, 局部可取到切向角 <span class="math inline">\({\rm Arctan}\frac{y&#39;}{x&#39;}\)</span> 的可微单值支, 定义其对 <span class="math inline">\(s\)</span> 的导数 <span class="math inline">\(\kappa_r=\theta&#39;(s)\)</span> 为<strong>相对曲率</strong>.</p><h3 id="正则曲面">正则曲面</h3><p>给定参数曲面 <span class="math inline">\(S:r=r(u,v),~(u,v)\in U\)</span>. 若处处有 <span class="math inline">\(r_u(u,v)\times r_v(u,v)\neq 0\)</span>, 则称 <span class="math inline">\(S\)</span> 为<strong>正则曲面</strong>.</p><h3 id="曲面的容许参数变换">曲面的容许参数变换</h3><p>给定正则曲面 <span class="math inline">\(S:r=r(u,v)\)</span>, 若参数变换 <span class="math inline">\((u,v)=(u(x,y),v(x,y))\)</span> 满足:</p><ol type="1"><li>是连续可微的一一对应;</li><li>Jacobi 行列式 <span class="math inline">\(\frac{\partial(u,v)}{\partial(x,y)}\)</span> 处处非零,</li></ol><p>则称之为<strong>容许的参数变换</strong>, 若 <span class="math inline">\(\frac{\partial(u,v)}{\partial(x,y)}&gt;0\)</span>, 称为保向的, 若 <span class="math inline">\(\frac{\partial(u,v)}{\partial(x,y)}&lt;0\)</span>, 称为反向的.</p><h3 id="局部等距对应">局部等距对应</h3><p>对于两张对应的曲面, 若它们对应着的弧段总是具有相等的弧段长度, 则称这个对应是两张曲面的一个<strong>局部等距对应</strong>.</p><h3 id="内蕴量和内蕴几何体">内蕴量和内蕴几何体</h3><p>在曲面上, 由其第一基本形式可完全确定的几何量, 称为曲面的<strong>内蕴量</strong>; 由其第一基本形式可完全确定属性的几何体, 称为曲面的<strong>内蕴几何体</strong>.</p><h3 id="主曲率和主方向">主曲率和主方向</h3><p>曲面 <span class="math inline">\(S\)</span> 上的点 <span class="math inline">\(P\)</span> 处的法曲率关于切方向的两个最值, 分别称为曲面 <span class="math inline">\(S\)</span> 在 <span class="math inline">\(P\)</span> 处的<strong>主曲率</strong>, 使得法曲率达到最值的两个方向称为<strong>主方向</strong>.</p><h3 id="脐点">脐点</h3><p>若曲面 <span class="math inline">\(S\)</span> 在 <span class="math inline">\(P\)</span> 处的两个主曲率相等, 则称 <span class="math inline">\(P\)</span> 为曲面 <span class="math inline">\(S\)</span> 的<strong>脐点</strong>. 若脐点处的主曲率均为0, 称为平点, 否则称为圆点.</p><h3 id="极小曲面">极小曲面</h3><p>若曲面的平均曲率恒为零, 称之为<strong>极小曲面</strong>.</p><h3 id="抽象曲面">抽象曲面</h3><p>称二元有序组 <span class="math inline">\((D,ds^2)\)</span> 为一张<strong>抽象曲面</strong>, 其中 <span class="math inline">\(D\subset\mathbf{R}^2\)</span> 是参数平面 <span class="math inline">\(\mathbf{R}^2\)</span> 上指定的区域, <span class="math inline">\(ds^2\)</span> 是定义域上的正定的二次微分形式.</p><h2 id="重要的定理">重要的定理</h2><h3 id="曲线论基本定理">曲线论基本定理</h3><p>给定区间 <span class="math inline">\(I=(a,b)\)</span> 上的连续可微函数 <span class="math inline">\(\overline{\kappa}(s)&gt;0\)</span> 和连续函数 <span class="math inline">\(\overline{\tau}(s)\)</span>, 则在 <span class="math inline">\(E^3\)</span> 中</p><ol type="1"><li>存在弧长 <span class="math inline">\(s\)</span> 参数化曲线 <span class="math inline">\(C:r=r(s)\)</span>, 使其曲率函数 <span class="math inline">\(\kappa(s)=\overline{\kappa}(s)\)</span>, 并且其挠率函数 <span class="math inline">\(\tau(s)=\overline{\tau}(s)\)</span>;</li><li>上述曲线 <span class="math inline">\(C\)</span> 在合同的意义下是唯一的.</li></ol><h3 id="可展曲面的分类定理">可展曲面的分类定理</h3><p>可展曲面必是煮面、锥面和切线面之一或由它们沿直母线所适当拼接而成.</p><h3 id="局部等距对应的条件">局部等距对应的条件</h3><p>两张曲面能建立局部等距对应的充要条件是按照对应关系有相同的第一基本形式.</p><h3 id="gauss绝妙定理">Gauss绝妙定理</h3><p>曲面 <span class="math inline">\(S\)</span> 的Gauss曲率是内蕴量, 可表示为 <span class="math display">\[K=\frac{-R_{1212}}{g_{11}g_{22}-(g_{12})^2}.\]</span> 在正交网下, 有 <span class="math display">\[K=\frac{-1}{\sqrt{EG}}\left(\left[\frac{(\sqrt{E})_2}{\sqrt{G}}\right]_2+\left[\frac{(\sqrt{G})_1}{\sqrt{G}}\right]_1\right).\]</span></p><h3 id="曲面论基本定理">曲面论基本定理</h3><p>给定 <span class="math inline">\((u^1,u^2)\)</span> 平面上的单连通区域 <span class="math inline">\(U\)</span>. 给定 <span class="math inline">\(U\)</span> 上的 <span class="math inline">\(C^2\)</span> 函数 <span class="math inline">\(\overline{g}_{ij}\)</span> 和 <span class="math inline">\(\overline{\Omega}_{ij}\)</span>, s.t. <span class="math inline">\(\overline{g}\)</span> 正定, <span class="math inline">\(\overline{\Omega}\)</span> 对称, 并且 <span class="math inline">\(\overline{g}\)</span> 和 <span class="math inline">\(\overline{\Omega}\)</span> 满足 Gauss-Codazzi方程, 则在 <span class="math inline">\(E^3\)</span> 中</p><ol type="1"><li>存在正则曲面 <span class="math inline">\(S:r=r(u^1,u^2),~(u^1,u^2)\in U\)</span>, s.t. 其第一第二基本形式分别为 <span class="math inline">\(\overline{g}\)</span> 和 <span class="math inline">\(\overline{\Omega}\)</span>;</li><li>上述曲面 <span class="math inline">\(S\)</span> 在合同的意义下是唯一的.</li></ol><h3 id="测地线存在唯一性定理">测地线存在唯一性定理</h3><p>给定正则曲面 <span class="math inline">\(S:(u^1,u^2)\)</span> 上任意一点 <span class="math inline">\(P_0(u_0^1,u_0^2)\)</span>, 则存在 <span class="math inline">\(P_0\)</span> 的某个邻域 <span class="math inline">\(\Sigma_0\subset S\)</span>, s.t. 在 <span class="math inline">\(\Sigma_0\)</span> 内从点 <span class="math inline">\(P_0\)</span> 出发沿指定单位切向 <span class="math inline">\(T_0\in T_{P_0}\)</span> 存在唯一一条测地线 <span class="math inline">\(C:r(u^1(s),u^2(s))\)</span>, s.t. <span class="math display">\[\left(r_i\frac{du^i}{ds}\right)\Bigg|_{s=s_0}=T_0,~u^i(s_0)=u_0^i,~i=1,2.\]</span></p><h2 id="重要的式子">重要的式子</h2><h3 id="euler公式">Euler公式</h3><p><span class="math display">\[\kappa_n(P,a)=\kappa_1|_P\cos^2\theta+\kappa_2|_P\sin^2\theta.\]</span></p><h3 id="rodriques公式">Rodriques公式</h3><p>已知正则曲面 <span class="math inline">\(S:r(u^1,u^2)\)</span> 的弧长参数化曲线 <span class="math inline">\(C:r(u^1(s),u^2(s))\)</span>, 则 <span class="math inline">\(C\)</span> 是曲率线等价于沿 <span class="math inline">\(C\)</span> 存在 <span class="math inline">\(\lambda(s)\)</span>, s.t. <span class="math display">\[\frac{dn}{ds}=-\lambda(s)\frac{dr}{ds}.\]</span> 即, 沿 <span class="math inline">\(C\)</span> 有 <span class="math inline">\(dn=-\lambda(s)dr\)</span>.</p><h3 id="正交曲率线网下的gauss-codazzi方程">正交曲率线网下的Gauss-Codazzi方程</h3><p><span class="math display">\[\begin{cases}L_2 &amp;= HE_2, \\N_1 &amp;= HG_1. \\\end{cases}\]</span></p><h2 id="判断内蕴量几何体">判断内蕴量(几何体)</h2><h3 id="常见的内蕴量内蕴几何体">常见的内蕴量(内蕴几何体)</h3><p>曲线的弧段长度, 曲线的测地曲率, 曲线的交角, 曲面的第一基本形式, 曲线的区域面积, Gauss曲率, 测地线, 测地圆周, 测地开圆盘, 抛物点, 黎曼曲率张量, 联络系数.</p><h3 id="常见的不是内蕴量的东西">常见的不是内蕴量的东西</h3><p>曲线的曲率, 曲线的挠率, 法曲率, 直线, 圆周, <strong>第一基本形式的系数矩阵</strong>, 第二基本形式, 主曲率, 主方向, 脐点, 平点, 圆点, 平均曲率, Weingarten矩阵, 第三基本形式, 渐近曲线.</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 期末复习 </tag>
            
            <tag> 微分几何 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>概率论复习重点</title>
      <link href="/2017/06/23/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/"/>
      <content type="html"><![CDATA[<h2 id="第二章-概率空间">第二章 概率空间</h2><h3 id="性质和定理">性质和定理</h3><p>设 <span class="math inline">\((\Omega,\mathscr{F},\mathbb{P})\)</span> 为概率空间, 有如下性质和定理成立.</p><h4 id="可列可加性和次可加性">可列可加性和次可加性</h4><p><span class="math inline">\(\forall~\{A_n\}\subset\mathscr{F}\)</span>, 有 <span class="math display">\[\mathbb{P}\left(\bigcup_{n=1}^\infty A_n\right)\leqslant\sum\limits_{n=1}^\infty \mathbb{P}(A_n).\]</span> 对于两两不相容的集合列 <span class="math inline">\(\{A_n\}\subset\mathscr{F}\)</span>, 有 <span class="math display">\[\mathbb{P}\left(\bigcup_{n=1}^\infty A_n\right)=\sum\limits_{n=1}^\infty \mathbb{P}(A_n).\]</span></p><h4 id="连续性">连续性</h4><p>若事件 <span class="math inline">\(A_n\subset A_{n+1}\)</span>, <span class="math inline">\(n\geqslant 1\)</span>, 则 <span class="math display">\[\mathbb{P}\left(\bigcup\limits_{n=1}^\infty A_n\right)=\lim\limits_{n\to\infty}\mathbb{P}(A_n).\]</span> 若事件 <span class="math inline">\(A_n\supset A_{n+1}\)</span>, <span class="math inline">\(n\geqslant 1\)</span>, 则 <span class="math display">\[\mathbb{P}\left(\bigcap\limits_{n=1}^\infty A_n\right)=\lim\limits_{n\to\infty}\mathbb{P}(A_n).\]</span></p><h4 id="全概率公式">全概率公式</h4><p>设 <span class="math inline">\(\{B_n\}\)</span> 为 <span class="math inline">\(\Omega\)</span> 的一个分割, 则 <span class="math display">\[\mathbb{P}(A)=\sum\limits_n \mathbb{P}(B_n)\mathbb{P}(A|B_n),\quad\forall~A\in\mathscr{F}.\]</span></p><h4 id="bayes公式">Bayes公式</h4><p>设 <span class="math inline">\(\{B_n\}\)</span> 为 <span class="math inline">\(\Omega\)</span> 的一个分割, 对于 <span class="math inline">\(\forall~A\in\mathscr{F}\)</span>, 如果 <span class="math inline">\(\mathbb{P}(A)&gt;0\)</span>, 则对于 <span class="math inline">\(\forall~1\leqslant k\leqslant n\)</span>, 有 <span class="math display">\[\mathbb{P}(B_k|A)=\frac{\mathbb{P}(B_k)\mathbb{P}(A|B_k)}{\sum\limits_{n=1}^\infty \mathbb{P}(B_n)\mathbb{P}(A|B_n)}.\]</span></p><h4 id="事件的独立性">事件的独立性</h4><p>若 <span class="math inline">\(\mathbb{P}(AB)=\mathbb{P}(A)\mathbb{P}(B)\)</span>, 则称 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 独立.</p><h2 id="第三章-随机变量及其分布">第三章 随机变量及其分布</h2><h3 id="正态分布">正态分布</h3><h4 id="密度函数">密度函数</h4><p><span class="math display">\[\varphi_{a,\sigma}(x)=\frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{(x-a)^2}{2\sigma^2}},\quad a\in\mathbb{R},~\sigma&gt;0;\]</span></p><h4 id="分布函数">分布函数</h4><p><span class="math display">\[\Phi_{a,\sigma}(x)=\int\nolimits_{-\infty}^x \varphi_{a,\sigma}(t)dt;\]</span></p><h4 id="标准正态分布">标准正态分布</h4><p><span class="math display">\[\varphi(x)=\varphi_{0,1}(x)=\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}};\]</span></p><h4 id="正态分布的性质">正态分布的性质</h4><p><span class="math display">\[\Phi_{a,\sigma}(x)=\Phi(\frac{x-a}{\sigma}),\quad \Phi(x)=1-\Phi(-x).\]</span></p><h3 id="联合分布">联合分布</h3><h4 id="联合分布函数">联合分布函数</h4><p><span class="math display">\[F(x_1,\cdots,x_n)=\mathbb{P}(\xi_1\leqslant x_1,\cdots,\xi_n\leqslant x_n);\]</span></p><h4 id="联合密度函数">联合密度函数</h4><p><span class="math display">\[F(x_1,\cdots,x_n)=\int\cdots\int\nolimits_{\mathbf{R}^n}p(x_1,\cdots,x_n)dx_1\cdots dx_n;\]</span></p><h4 id="边缘分布函数">边缘分布函数</h4><p><span class="math display">\[F_1(x)=\lim\limits_{y\to\infty}F(x,y),\quad F_2(y)=\lim\limits_{x\to\infty}F(x,y);\]</span></p><h4 id="边缘密度">边缘密度</h4><ol type="1"><li>离散情形: <span class="math display">\[p_{i\bullet}=\sum\limits_j p_{ij},\quad p_{\bullet j}=\sum\limits_i p_{ij};\]</span></li><li>连续情形: <span class="math display">\[p_1(x)=\int\nolimits_{-\infty}^\infty p(x,y)dy,\quad p_2(y)=\int\nolimits_{-\infty}^\infty p(x,y)dx;\]</span></li></ol><h4 id="随机变量的独立">随机变量的独立</h4><p>联合密度等于边缘密度的乘积. 1. 离散情形: <span class="math display">\[p_{ij}=p_{i\bullet}p_{\bullet j},\quad\forall~i,j;\]</span> 2. 连续情形: <span class="math display">\[p(x,y)=p_1(x)p_2(y);\]</span> 若 <span class="math inline">\(\xi_1\)</span> 与 <span class="math inline">\(\xi_2\)</span> 独立, 则对于任何Borel可测函数 <span class="math inline">\(f_1\)</span> 与 <span class="math inline">\(f_2\)</span>, <span class="math inline">\(\eta_1=f_1(\xi_1)\)</span> 与 <span class="math inline">\(\eta_2=f_2(\xi_2)\)</span> 独立.</p><h3 id="随机变量函数的分布">随机变量函数的分布</h3><h4 id="分布函数-1">分布函数</h4><p>设 <span class="math inline">\(f(x_1,\cdots,x_n)\)</span> 为 <span class="math inline">\(n\)</span> 元Borel可测函数, <span class="math inline">\(p\)</span> 为 <span class="math inline">\((\xi_1\cdots,\xi_n)\)</span> 的密度函数, 则 <span class="math inline">\(\eta=f(\xi_1,\cdots,\xi_n)\)</span> 的分布函数为 <span class="math display">\[F_\eta(y)=\underset{f(x_1,\cdots,x_n)\leqslant y}{\int\cdots\int}p(x_1,\cdots,x_n)dx_1\cdots dx_n.\]</span></p><h4 id="卷积公式">卷积公式</h4><p>设 <span class="math inline">\((\xi,\eta)\)</span> 的联合密度函数为 <span class="math inline">\(p\)</span>, 则 <span class="math inline">\(\xi+\eta\)</span> 的密度函数为 <span class="math display">\[p_{\xi+\eta}(z)=\int\nolimits_{-\infty}^\infty p(x,z-x)dx=\int\nolimits_{-\infty}^\infty p(z-y,y)dy.\]</span></p><h4 id="商密度公式">商密度公式</h4><p>设 <span class="math inline">\((\xi,\eta)\)</span> 的联合密度为 <span class="math inline">\(p\)</span>, 则 <span class="math inline">\(\xi/\eta\)</span> 的密度函数为 <span class="math display">\[p_{\xi/\eta}(z)=\int\nolimits_{-\infty}^\infty |y|p(zy,y)dy.\]</span></p><h4 id="高维情形">高维情形</h4><p>设 <span class="math inline">\(n\)</span> 维随机向量 <span class="math inline">\(\xi\)</span> 的联合密度为 <span class="math inline">\(p\)</span>, <span class="math inline">\(f_i(x)\)</span> 为 <span class="math inline">\(n\)</span> 维Borel可测函数, <span class="math inline">\(\eta=(f_1(\xi),\cdots,f_n(\xi))\)</span>. 若对于 <span class="math inline">\(\eta\)</span> 的像空间 <span class="math inline">\(D\)</span> 中任何一个 <span class="math inline">\(y\)</span>, 方程组 <span class="math inline">\(y_i=f_i(x)\)</span>有唯一的可微解 <span class="math inline">\(x_i=h_i(y)\)</span>, 则 <span class="math inline">\(\eta\)</span> 的联合密度函数为 <span class="math display">\[q(y)==p(h_1(y),\cdots,h_n(y))|J|,\quad y\in D,\]</span> 其中 <span class="math inline">\(J=\frac{\partial(h_1(y),\cdots,h_n(y))}{\partial (y_1,\cdots,y_2)}\)</span> 为Jacobi行列式.</p><h2 id="第四章-数字特征与特征函数">第四章 数字特征与特征函数</h2><h3 id="数学期望">数学期望</h3><p>定义: 简单随机变量 <span class="math inline">\(\mathbb{E}(\xi)=\sum\limits_{i=1}^n x_i\mathbb{P}(\xi=x_i)\rightarrow\)</span> 非负随机变量用简单随机变量逼近 <span class="math inline">\(\mathbb{E}(\xi)=\lim\limits_{n\to\infty}\mathbb{E}(\xi_n)\rightarrow\)</span>, 一般随机变量 <span class="math inline">\(\mathbb{E}(\xi)=\mathbb{E}(\xi^+)-\mathbb{E}(\xi^-).\)</span></p><h4 id="单调收敛定理">单调收敛定理</h4><p>若 <span class="math inline">\(\xi_n\)</span> 为非负随机变量, 且 <span class="math inline">\(\xi_n\uparrow\xi\)</span>, 则 <span class="math inline">\(\lim\limits_{n\to\infty}\mathbb{E}(\xi_n)=\mathbb{E}(\xi)\)</span>.</p><h4 id="数学期望的性质">数学期望的性质</h4><ol type="1"><li>线性性质: <span class="math inline">\(\mathbb{E}(a\xi+b\eta)=a\mathbb{E}(\xi)+b\mathbb{E}(\eta)\)</span>;</li><li>若 <span class="math inline">\(\xi\)</span> 与 <span class="math inline">\(\eta\)</span> 独立, 则 <span class="math inline">\(\mathbb{E}(\xi\eta)=\mathbb{E}(\xi)\mathbb{E}(\eta).\)</span></li></ol><h4 id="数学期望的计算">数学期望的计算</h4><ol type="1"><li>离散型: <span class="math inline">\(\mathbb{E}(\xi)=\sum\limits_{k=1}^n x_kp_k\)</span> 或 <span class="math inline">\(\mathbb{E}(\xi)=\sum\limits_{k=1}^\infty x_kp_k\)</span>;</li><li>连续型: <span class="math inline">\(\mathbb{E}(\xi)=\int\nolimits_{-\infty}^\infty xp(x)dx\)</span>.</li></ol><h4 id="条件期望">条件期望</h4><ol type="1"><li>离散型: <span class="math inline">\(\mathbb{E}(\xi|\eta=y)=\sum\limits_{i=1}^n\mathbb{P}(\xi=x_i|\eta=y)\)</span>,</li><li>连续型: <span class="math inline">\(\mathbb{E}(\xi|\eta=y)=\int\nolimits_{-\infty}^\infty xp(x|\eta=y)dx\)</span>.</li><li>条件期望的平滑性: <span class="math inline">\(\mathbb{E}(\xi)=\mathbb{E}(\mathbb{E}(\xi|\eta))\)</span>.</li></ol><h3 id="方差">方差</h3><p>计算: <span class="math inline">\(D(\xi)=\mathbb{E}(\xi-\mathbb{E}(\xi))^2\)</span>; 协方差: <span class="math inline">\({\rm cov}(\xi_i,\xi_j)=\mathbb{E}((\xi_1-\mathbb{E}(\xi_1))(\xi_2-\mathbb{E}(\xi_2)))\)</span>. 容易证明协方差具有如下性质: <span class="math display">\[D(\xi+\eta)=D(\eta)+D(\xi)\Longleftrightarrow {\rm cov}(\xi,\eta)=0,\]</span> <span class="math display">\[{\rm cov}(\xi_1+\xi_2,\eta)={\rm cov}(\xi_1,\eta)+{\rm cov}(\xi_2,\eta).\]</span></p><h2 id="第五章-大数定律和中心极限定理">第五章 大数定律和中心极限定理</h2><h3 id="收敛性">收敛性</h3><h4 id="几乎处处收敛">几乎处处收敛</h4><p>若 <span class="math inline">\(\mathbb{P}(\lim\limits_{n\to\infty}\xi_n=\xi)=1\)</span>, 则称 <span class="math inline">\(\xi_n\)</span> 几乎处处收敛到 <span class="math inline">\(\xi\)</span>, 记作 <span class="math inline">\(\xi_n\xrightarrow{a.e.}\xi\)</span>.</p><h4 id="依概率收敛">依概率收敛</h4><p>若 <span class="math inline">\(\lim\limits_{n\to\infty}\mathbb{P}(|\xi_n-\xi|\geqslant\epsilon)=0\)</span>, <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, 则称 <span class="math inline">\(\xi_n\)</span> 依概率收敛于 <span class="math inline">\(\xi\)</span>, 记作 <span class="math inline">\(\xi_n\xrightarrow{\mathbb{P}}\xi\)</span>.</p><h4 id="弱收敛">弱收敛</h4><p>设 <span class="math inline">\(\xi_n\)</span> 和 <span class="math inline">\(\xi\)</span> 的分布函数分别为 <span class="math inline">\(F_n(x)\)</span> 和 <span class="math inline">\(F(x)\)</span>, 若 <span class="math inline">\(\lim\limits_{n\to\infty}F_n(x)=F(x)\)</span>, <span class="math inline">\(\forall~x\in C_F\)</span>, 其中 <span class="math inline">\(C_F\)</span> 为 <span class="math inline">\(F\)</span> 的连续点全体, 则称 <span class="math inline">\(\xi_n\)</span> 弱收敛于 <span class="math inline">\(\xi\)</span>, 记作 <span class="math inline">\(\xi_n\xrightarrow{w}\xi\)</span>.</p><h4 id="r-阶矩收敛"><span class="math inline">\(r\)</span> 阶矩收敛</h4><p>给定 <span class="math inline">\(r&gt;0\in\mathbb{R}\)</span>, 若 <span class="math inline">\(\xi\)</span> 和 <span class="math inline">\(\xi_n\)</span> 的 <span class="math inline">\(r\)</span> 阶矩均存在, 并且 <span class="math inline">\(\lim\limits_{n\to\infty}\mathbb{E}(|\xi_n-\xi|^r)=0\)</span>, 则称 <span class="math inline">\(\xi_n\)</span> <span class="math inline">\(r\)</span> 阶矩收敛于 <span class="math inline">\(\xi\)</span>, 记作 <span class="math inline">\(\xi_n\xrightarrow{L_r}\xi\)</span>.</p><h3 id="几种收敛的关系">几种收敛的关系</h3><p><span class="math inline">\(\xi_n\xrightarrow{a.e.}\)</span> 或 <span class="math inline">\(\xi_n\xrightarrow{L_r}\xi\Rightarrow\)</span> <span class="math inline">\(\xi_n\xrightarrow{\mathbb{P}}\xi\Rightarrow\)</span> <span class="math inline">\(\xi_n\xrightarrow{w}\xi\)</span>. 特别地, <span class="math inline">\(\forall~c\in\mathbb{R}\)</span>, <span class="math inline">\(\xi_n\xrightarrow{w} c\Rightarrow c_n\xrightarrow{\mathbb{P}} c\)</span>.</p><h3 id="大数定律">大数定律</h3><h4 id="大数定律-1">大数定律</h4><p>设 <span class="math inline">\(\xi_n\)</span> 为数学期望均有限的随机变量列, 若:</p><p><span class="math display">\[\frac{1}{n}\sum\limits_{k=1}^n (\xi_k-\mathbb{E}(\xi_k))\xrightarrow{\mathbb{P}}0~,\]</span> 则称 <span class="math inline">\(\xi_n\)</span> 满足弱大数定律. <span class="math display">\[\frac{1}{n}\sum\limits_{k=1}^n (\xi_k-\mathbb{E}(\xi_k))\xrightarrow{\text{a.e.}}0~,\]</span> 则称 <span class="math inline">\(\xi_n\)</span> 满足强大数定律.</p><h4 id="markov条件">Markov条件</h4><p>设随机变量列 <span class="math inline">\(\xi_n\)</span> 满足 <span class="math display">\[\frac{1}{n^2}D\left(\sum\limits_{k=1}^n \xi_k\right)\xrightarrow{n\to\infty}0~,\]</span> 则 <span class="math inline">\(\xi_n\)</span> 满足大数定律.</p><h4 id="bernoulli大数定律">Bernoulli大数定律</h4><p>设 <span class="math inline">\(\mu_n\)</span> 为 <span class="math inline">\(n\)</span> 重Bernoulli试验中成功的次数, <span class="math inline">\(p\)</span> 为单次成功概率, 则 <span class="math inline">\(\frac{\mu_n}{n}\xrightarrow{\mathbb{P}}p\)</span>.</p><h4 id="辛钦大数定律">辛钦大数定律</h4><p>设 <span class="math inline">\(\xi_n\)</span> 为独立同分布随机变量列, 弱大数定律成立的充要条件是 <span class="math inline">\(\mathbb{E}(\xi_1)=a\)</span> 为有限实数.</p><h4 id="kolmogorov强大数定律">Kolmogorov强大数定律</h4><p>设 <span class="math inline">\(\{\xi_n\}\)</span> 是独立随机变量列, 满足 <span class="math inline">\(\sum\limits_{k=1}^\infty \frac{D(\xi_n)}{n^2}&lt;\infty\)</span>, 则 <span class="math inline">\(\{\xi_n\}\)</span> 满足大数定律.</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 概率论 </tag>
            
            <tag> 期末复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>复变复习重点</title>
      <link href="/2017/06/22/%E5%A4%8D%E5%8F%98%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/"/>
      <content type="html"><![CDATA[<h2 id="重要的定义和定理">重要的定义和定理</h2><h3 id="实可微的定义">实可微的定义</h3><p>设 <span class="math inline">\(f\)</span> 是从开集 <span class="math inline">\(\Omega\)</span> 到 <span class="math inline">\(\mathbb{C}\)</span> 中的函数, <span class="math inline">\(a\in\Omega\)</span>, 如果有复常数 <span class="math inline">\(A,b\)</span>, s.t. <span class="math display">\[\lim\limits_{z\to\infty}\frac{f(a+z)-f(a)-Ax-By}{z}=0,\]</span> 则称 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(a\)</span> 处<strong>实可微</strong>.</p><h3 id="复可微">复可微</h3><p>设 <span class="math inline">\(f\)</span> 是定义在开集 <span class="math inline">\(\Omega\)</span> 上的复变函数, <span class="math inline">\(a\in\Omega\)</span>, 如果有常数 <span class="math inline">\(\alpha\)</span>, s.t. <span class="math display">\[\lim\limits_{z\to\infty}\frac{f(a+z)-f(a)}{z}=\alpha\]</span> 存在, 我们称 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(a\in\Omega\)</span> 处<strong>复可微</strong>或称 <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(a\)</span> 可导, 并把 <span class="math inline">\(\alpha\)</span> 记作 <span class="math inline">\(f&#39;(a)\)</span>.</p><h3 id="cauchy-riemann方程">Cauchy-Riemann方程</h3><p>如果 <span class="math inline">\(f(z)=u(x,y)+iv(x,y)\)</span> 在 <span class="math inline">\(a\in\Omega\)</span> 处实可微, <span class="math inline">\(u,v\)</span> 为实值函数, 则 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(a\)</span> 处复可微当且仅当 <span class="math display">\[\frac{\partial f}{\partial \overline{z}}(a)=0~或~\begin{cases}\frac{\partial u}{\partial x}=\frac{\partial y}{\partial y} \\\frac{\partial u}{\partial y}=-\frac{\partial v}{\partial x} \\\end{cases}\]</span> 以上式子被称为Cauchy-Riemann方程, 简称C-R方程.</p><h3 id="复解析">复解析</h3><p>如果存在 <span class="math inline">\(a\)</span> 的一个邻域 <span class="math inline">\(D(a,r)\subset\Omega\)</span>, 使得 <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(D(a,r)\)</span> 中每点都有导数, 则称 <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(a\)</span> 点<strong>解析</strong>. 如果 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(\Omega\)</span> 上的每点解析, 则称 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(\Omega\)</span> 中<strong>解析</strong>或<strong>全纯</strong>.</p><h3 id="cauchy高阶求导公式">Cauchy高阶求导公式</h3><p>设 <span class="math inline">\(\Omega\)</span> 是一个单连通区域, <span class="math inline">\(C\)</span> 是全在区域 <span class="math inline">\(\Omega\)</span> 中的闭Jordan分段光滑曲线, <span class="math inline">\(C\)</span> 所围区域是 <span class="math inline">\(\omega\)</span>. 如果 <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 中解析, 则有如下<strong>Cauchy公式</strong> <span class="math display">\[f(z_0)=\frac{1}{2\pi i}\int\nolimits_C\frac{f(z)dz}{z-z_0}\qquad(z_0\in\omega)\]</span> 且对于任意整数 <span class="math inline">\(m\)</span>, <span class="math inline">\(f\)</span> 的 <span class="math inline">\(m\)</span> 阶复导数 <span class="math inline">\(f^{(m)}(z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 中存在解析, 且有如下的Cauchy高阶求导公式 <span class="math display">\[f^{(m)}(z_0)=\frac{m!}{2\pi i}\int\nolimits_C\frac{f(z)dz}{(z-z_0)^{m+1}}\qquad(z_0\in\omega,~m\in\mathbb{N}^+)\]</span></p><h3 id="泰勒taylor定理">泰勒(Taylor)定理</h3><p>设 <span class="math inline">\(f\)</span> 在区域 <span class="math inline">\(\Omega\)</span> 内解析, <span class="math inline">\(a\in\Omega\)</span>, 只要 <span class="math inline">\(D(a,R)=\{z:|z-a|&lt;R\}\)</span> 包含在 <span class="math inline">\(\Omega\)</span> 中, 则 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(D(a,R)\)</span> 内能展成幂级数 <span class="math display">\[f(z)=\sum\limits_{n=0}^\infty c_n(z-a)^n=c_0+c_1(z-a)+\cdots+c_n(z-a)^n+\cdots,\]</span> 其中系数 <span class="math display">\[c_n=\frac{f^{(n)}(a)}{n!}=\frac{1}{2\pi i}\int\nolimits_{\partial D(a,\rho)}\frac{f(\zeta)d\zeta}{(\zeta-a)^{n+1}},\quad (0&lt;\rho&lt;R,n\in\mathbb{N})\]</span> 且如果 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(D(a,R)\)</span> 内能展成幂级数, 则其系数一定满足上述要求.</p><h3 id="解析函数唯一性定理">解析函数唯一性定理</h3><p>设函数 <span class="math inline">\(g\)</span> 和 <span class="math inline">\(h\)</span> 在区域 <span class="math inline">\(\Omega\)</span> 内解析, <span class="math inline">\(a\in\Omega\)</span>, 且 <span class="math inline">\(\Omega\)</span> 内有一个收敛于 <span class="math inline">\(a\in\Omega\)</span> 的点列 <span class="math inline">\(\{z_n\}~(z_n\neq a)\)</span>, s.t. <span class="math inline">\(g(z_k)=h(z_k)~(k\in\mathbb{N})\)</span>, 则 <span class="math inline">\(g\)</span> 和 <span class="math inline">\(h\)</span> 在 <span class="math inline">\(\Omega\)</span> 内恒等.</p><h3 id="洛朗laurent定理">洛朗(Laurent)定理</h3><p>设 <span class="math inline">\(f\)</span> 在区域 <span class="math inline">\(\Omega\)</span> 内解析, 只要 <span class="math inline">\(B(r,R)=\{z:r&lt;|z-a|&lt;R\}\subset\Omega\)</span>, 则 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(B(r,R)\)</span> 内能展成洛朗级数, 其中系数 <span class="math display">\[c_n=\frac{1}{2\pi i}\int\nolimits_{\partial D(a,\rho)}\frac{f(\zeta)d\zeta}{(\zeta-a)^{n+1}}\quad (r&lt;\rho&lt;R,~n\in\mathbb{Z}),\]</span> 且展式是唯一的(即系数 <span class="math inline">\(c_n\)</span> 由 <span class="math inline">\(f(z)\)</span> 和圆环 <span class="math inline">\(B(r,R)\)</span> 唯一确定).</p><h3 id="孤立奇点">孤立奇点</h3><p>设函数 <span class="math inline">\(f\)</span> 在点 <span class="math inline">\(a\)</span> 的某一去心邻域 <span class="math inline">\(D(a,r)\backslash\{a\}=\{z:0&lt;|z-a|&lt;r\}\)</span> 内解析, 则点 <span class="math inline">\(a\)</span> 称为 <span class="math inline">\(f\)</span> 的<strong>孤立奇点</strong>.</p><h3 id="留数定理">留数定理</h3><p>考虑 <span class="math inline">\(n+1\)</span> 条Jordan闭分段光滑曲线 <span class="math inline">\(C_0,C_1,\cdots,C_n\)</span>, 其中 <span class="math inline">\(C_1,C_2,\cdots,C_n\)</span> 中每一条都在其余各条的外部, 而它们又都在 <span class="math inline">\(C_0\)</span> 的内部. 在 <span class="math inline">\(C_0\)</span> 的内部同时又在 <span class="math inline">\(C_1,C_2,\cdots,C_n\)</span> 外部的点集构成一个多界的多连通区域 <span class="math inline">\(\Omega\)</span>, 以 <span class="math inline">\(C_1,C_2,\cdots,C_n\)</span> 为它的边界. <span class="math inline">\(z_k\in\Omega,~k=1,2,\cdots,m\)</span>, 函数 <span class="math inline">\(f\)</span> 在闭域 <span class="math inline">\(\overline{\Omega}=\Omega\cup\partial\Omega\)</span> 上除去孤立奇点 <span class="math inline">\(z_1,z_2,\cdots,z_k\)</span> 外是解析的, 则 <span class="math display">\[\int\nolimits_{\partial\Omega}f(z)dz=2\pi i\sum\limits_{k=1}^n {\rm Res}(f,z_k).\]</span></p><h3 id="儒歇rouche定理">儒歇(Rouche)定理</h3><p>设 <span class="math inline">\(\Omega\)</span> 是区域, <span class="math inline">\(\omega\subset\Omega\)</span> 是有界区域, 其边界 <span class="math inline">\(C=\partial\omega\subset\Omega\)</span> 是一条Jordan闭分段光滑曲线, 如果 <span class="math inline">\(f\)</span> 和 <span class="math inline">\(g\)</span> 在开集 <span class="math inline">\(\Omega\)</span> 中解析且在 <span class="math inline">\(C\)</span> 上有 <span class="math inline">\(|f(z)|&gt;|g(z)|\)</span>, 则函数 <span class="math inline">\(f(z)\)</span> 与 <span class="math inline">\(f(z)+g(z)\)</span> 在 <span class="math inline">\(C\)</span> 的内部 <span class="math inline">\(\omega\)</span> 有相同的( <span class="math inline">\(k\)</span> 阶零点算 <span class="math inline">\(k\)</span> 次)零点个数, 即 <span class="math display">\[N(f+g,C)=N(f,C).\]</span></p><h2 id="典型题目">典型题目</h2><h3 id="证明复级数的cauchy乘积收敛">证明复级数的Cauchy乘积收敛</h3><h4 id="师大复变习题一-31">师大复变习题一 31</h4><blockquote><p>设复级数 <span class="math inline">\(s=\sum\limits_{n=0}^\infty\alpha_n\)</span>, <span class="math inline">\(s&#39;=\sum\limits_{n=0}^\infty\alpha_n&#39;\)</span> 收敛, 且其中一个绝对收敛, 则其 Cauchy 乘积 <span class="math display">\[\sum\limits_{n=0}^\infty(\alpha_0\alpha_n&#39;+\alpha_1\alpha_{n-1}&#39;+\cdots+\alpha_n\alpha_0&#39;)=\sum\limits_{n=0}^\infty\sum\limits_{k=0}^n\alpha_k\alpha_{n-k}&#39;\]</span>也收敛, 且其和为 <span class="math inline">\(ss&#39;\)</span>.</p></blockquote><p><strong>证明</strong>: 不妨设 <span class="math inline">\(\sum\limits_{n=0}^\infty|\alpha_n|\)</span> 收敛, 记 <span class="math inline">\(S_m=\sum\limits_{n=0}^m\alpha_n\)</span>, <span class="math inline">\(S_m&#39;=\sum\limits_{n=0}^m\alpha_n&#39;\)</span>, <span class="math inline">\(\gamma_n=\alpha_0\alpha_n&#39;+\alpha_1\alpha_{n-1}&#39;+\cdots+\alpha_n\alpha_0&#39;\)</span>, <span class="math inline">\(\tau_m=\sum\limits_{n=0}^m\gamma_n\)</span>, 则有 <span class="math inline">\(S_m\to s\)</span>, <span class="math inline">\(S_m&#39;\to s&#39;\)</span>.</p><p>于是, <span class="math inline">\(\tau_m=\sum\limits_{n=0}^m\gamma_n=\alpha_0S_m&#39;+\cdots+\alpha_nS_0&#39;=S_ms&#39;+\delta_m\)</span></p><p>其中, <span class="math inline">\(\delta_m=\alpha_0(S_m&#39;-s&#39;)+\alpha_1(S_{m-1}&#39;-s&#39;)+\cdots+\alpha_n(S&#39;-s&#39;)\)</span></p><p>由于 <span class="math inline">\(\{S_m&#39;\}\)</span> 收敛, 故 <span class="math inline">\(\{S_m&#39;\}\)</span> 有界, 故 <span class="math inline">\(\exists~M&gt;0\)</span>, s.t. <span class="math inline">\(\forall~m\in\mathbb{N}\)</span>, <span class="math inline">\(|S_m&#39;-s&#39;|&lt;M\)</span></p><p>又由 <span class="math inline">\(\sum\limits_{n=0}^m\alpha_n\)</span> 绝对收敛, 知 <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, <span class="math inline">\(\exists~N_1\in\mathbb{N}\)</span>, s.t. <span class="math inline">\(\sum\limits_{k=N_1+1}^m|\alpha_k|&lt;\frac{\epsilon}{4M+1}\)</span>.</p><p>再记 <span class="math inline">\(L=\sum\limits_{k=0}^{N_1}|\alpha_k|\)</span>, 同理由 <span class="math inline">\(S_m&#39;\to s&#39;\)</span> 可得 <span class="math inline">\(\exists~N_2\in\mathbb{N}\)</span>, s.t. <span class="math inline">\(\forall~m&gt;N_2\)</span>, <span class="math inline">\(|S_m&#39;-s&#39;|&lt;\frac{\epsilon}{4L+1}\)</span>.</p><p>于是当 <span class="math inline">\(m&gt;N_1+N_2\)</span> 时有: <span class="math display">\[|\delta_m|\leq\sum\limits_{k=0}^m|\alpha_k||S_{m-k}&#39;-s&#39;|+(|\alpha_{N_1}|+\cdots+|\alpha_m|)M\leq\frac{\epsilon}{4L+1}\times L+\frac{\epsilon}{4M+1}&lt;\frac{\epsilon}{2}\]</span></p><p>故: <span class="math display">\[|\tau_m-ss&#39;|=|S_ms&#39;-ss&#39;+\delta_m|\leq |s&#39;||S_m-s|+|\delta_m|&lt;\frac{\epsilon}{2|s&#39;|}|s&#39;|+\frac{\epsilon}{2}=\epsilon\]</span></p><p>即 <span class="math inline">\(\sum\limits_{n=0}^\infty\sum\limits_{k=0}^n\alpha_k\alpha_{n-k}&#39;\)</span> 收敛到 <span class="math inline">\(ss&#39;\)</span>.</p><h3 id="分式线性映射映像区域">分式线性映射映像区域</h3><h4 id="师大复变习题五-5.1">师大复变习题五 5.(1)</h4><blockquote><p>求区域 <span class="math inline">\(\Omega=\{z:{\rm Re}~z&gt;0,{\rm Im}~z&gt;0\}\)</span> 在分式线性映射 <span class="math inline">\(w=\frac{z-i}{z+i}\)</span> 下的映像区域.</p></blockquote><p><strong>解答</strong>: 记 <span class="math inline">\(L_1=\{z:{\rm Im}~z=0\}\)</span>, <span class="math inline">\(L_2=\{z:{\rm Re}~z=0\}\)</span>. 由于 <span class="math inline">\(T(z)=\infty\Leftrightarrow z=-i\)</span>, 并且 <span class="math inline">\(-i\)</span> 在 <span class="math inline">\(L_2\)</span> 上, 不在 <span class="math inline">\(L_1\)</span> 上, 故 <span class="math inline">\(T(L_1)\)</span> 为圆, <span class="math inline">\(T(L_2)\)</span> 为直线.</p><p><strong>一方面</strong>, <span class="math inline">\(T(-i)=\infty\)</span>, <span class="math inline">\(T(i)=0\)</span>, 并且 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(-i\)</span> 关于 <span class="math inline">\(L_1\)</span> 对称, 故 <span class="math inline">\(\infty\)</span> 和 <span class="math inline">\(0\)</span> 关于 <span class="math inline">\(T(L_1)\)</span> 对称. 即 <span class="math inline">\(T(L_1)\)</span> 以 <span class="math inline">\(0\)</span> 为心. 取 <span class="math inline">\(0\in L_1\)</span>, 则有 <span class="math inline">\(T(0)=-1\in T(L_1)\)</span>, 故 <span class="math inline">\(T(L_1)=\{z:|z|=1\}\)</span>.</p><p><strong>另一方面</strong>, <span class="math inline">\(T(-1)=\frac{-1-i}{-1+i}=i\)</span>, <span class="math inline">\(T(1)=-i\)</span>, 故 <span class="math inline">\(T(L_2)\)</span> 为过原点的直线. 取 <span class="math inline">\(0\in L_2\)</span>, 有 <span class="math inline">\(-1\in T(L_2)\)</span>, 即 <span class="math inline">\(T(L_2)\)</span> 为实轴. 取 <span class="math inline">\(1+i\in\Omega\)</span>, 则 <span class="math inline">\(T(1+i)=\frac{1}{1+2i}=\frac{1}{5}-\frac{2}{5}i\in T(\Omega)\)</span>, 即可确定像区域.</p><h3 id="已知原区域和像区域求映射">已知原区域和像区域求映射</h3><h4 id="师大复变习题五-12">师大复变习题五 12</h4><blockquote><p>求把区域 <span class="math inline">\(\{z:|z-3i|&gt;2,~|z-4|&gt;2\}\)</span> 映射为同心圆环 <span class="math inline">\(\{w:1&lt;|w|&lt;R\}\)</span> 的分式线性映射 <span class="math inline">\(w=T(z)\)</span> 并求 <span class="math inline">\(R\)</span>.</p></blockquote><p><strong>解答</strong>: 记 <span class="math inline">\(L_1=\{z:|z-3i|=2\}\)</span>, <span class="math inline">\(L_2=\{z:|z-4|=2\}\)</span>. 由于 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(\infty\)</span> 为 <span class="math inline">\(T(L_1)\)</span> 和 <span class="math inline">\(T(L_2)\)</span> 的公共对称点, 故只需要寻找一对 <span class="math inline">\(L_1\)</span> 和 <span class="math inline">\(L_2\)</span> 的公共对称点. 考虑在圆心连线上寻找, 可以找到 <span class="math inline">\(\frac{4}{5}+\frac{12}{5}i\)</span> 和 <span class="math inline">\(\frac{16}{5}+\frac{3}{5}i\)</span> 为 <span class="math inline">\(L_1\)</span> 和 <span class="math inline">\(L_2\)</span> 的公共对称点.</p><p>于是可令 <span class="math inline">\(T(z)=\lambda\frac{z-\frac{16}{5}-\frac{3}{5}i}{z-\frac{4}{5}-\frac{12}{5}i}=\lambda\frac{5z-16-3i}{5z-4-12i}\)</span>. 此时只差 <span class="math inline">\(\lambda\)</span> 确定表达式. 不妨取 <span class="math inline">\(\{w:|w|=1\}\)</span> 为 <span class="math inline">\(T(L_2)\)</span>, 则 <span class="math inline">\(|T(2)|=1\)</span>, 可得 <span class="math inline">\(|\lambda|\cdot|\frac{10-16-3i}{10-4-12i}|=1\)</span>, 即 <span class="math inline">\(|\lambda|=2\)</span>. 故由 <span class="math inline">\(T(i)=R\)</span> 可知 <span class="math inline">\(|\lambda|\cdot|\frac{5i-16-3i}{5i-4-12i}|=R\)</span>, 即 <span class="math inline">\(R=4\)</span>.</p><p>至此, 映射的放大倍数已经确定, 只需要取一个点来确定方向, 不妨取 <span class="math inline">\(T(2)=-1\)</span>, 则 <span class="math inline">\(\lambda\cdot\frac{-6-3i}{6-12i}=-1\)</span>, 可得 <span class="math inline">\(\lambda=-2i\)</span>. 即 <span class="math inline">\(T(z)=-2i\cdot\frac{5z-16-3i}{5z-4-12i}\)</span>.</p><p>最后一步中, 如不取 <span class="math inline">\(T(2)=-1\)</span>, 则最后所得表达式与原表达式之间相差一个旋转, 映像区域仍然不变.</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 复变函数 </tag>
            
            <tag> 期末复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学概率论试卷</title>
      <link href="/2017/06/14/BNU-Probability-Theory-Exam/"/>
      <content type="html"><![CDATA[<ul><li>2010-2011学年第一学期期末考试试卷 张梅、李勇</li></ul><a id="more"></a><h2 id="学年第一学期期末考试试卷-张梅李勇">2010-2011学年第一学期期末考试试卷 张梅、李勇</h2><ol type="1"><li>(20分)设某地区成年居民中肥胖者占 <span class="math inline">\(10\%\)</span>, 不胖不瘦者占 <span class="math inline">\(82\%\)</span>, 瘦者占 <span class="math inline">\(8\%\)</span>. 又知道肥胖者患高血压的概率为 <span class="math inline">\(20\%\)</span>, 不胖不瘦者患高血压的概率为 <span class="math inline">\(10\%\)</span>, 瘦者患高血压的概率为 <span class="math inline">\(5\%\)</span>, 试求<ol type="1"><li>该地区居民患高血压的概率;</li><li>若知某人患高血压, 则他属于肥胖者的概率有多大?</li></ol></li><li>(20分)设 <span class="math inline">\(\{\xi_i,~i=1,2,\cdots\}\)</span> 为一列独立同分布的随机变量, 它们都服从 <span class="math inline">\([-1,1]\)</span> 上的均匀分布.<ol type="1"><li>求 <span class="math inline">\(\xi_1\)</span> 的特征函数;</li><li>设 <span class="math inline">\(\eta\)</span> 服从参数为 <span class="math inline">\(\lambda\)</span> 的Possion分布, 即 <span class="math inline">\(\mathbb{P}(\eta=k)=\frac{\lambda^k}{k!}e^{-\lambda},~k=0,1,2,\cdots\)</span>. 求 <span class="math inline">\(\eta\)</span> 的母函数;</li><li>假定 <span class="math inline">\(\eta_n\)</span> 服从参数为 <span class="math inline">\(3n\)</span> 的Possion分布, 并且与 <span class="math inline">\(\{\xi_i,~i=1,2,\cdots\}\)</span> 相互独立. 证明 <span class="math inline">\(X_n:=\sum\nolimits_{i=1}^{\eta_n}\xi_i\)</span> 的特征函数为 <span class="math inline">\(f_n(x)=e^{3n(\frac{\sin t}{t}-1)}\)</span> (约定 <span class="math inline">\(\sum\nolimits_{i=1}^0\xi_i=0\)</span>).</li><li>证明: 当 <span class="math inline">\(n\to\infty\)</span> 时, <span class="math inline">\(\frac{1}{\sqrt{n}}X_n\stackrel{w}{\rightarrow}N(0,1)\)</span>.</li></ol></li><li>(30分)若 <span class="math inline">\(\xi\sim N(0,\sigma^2)\)</span>,<ol type="1"><li>给出 <span class="math inline">\(\xi\)</span> 的特征函数表达式;</li><li>对于 <span class="math inline">\(\forall~b\in\mathbb{R}\)</span>, 证明 <span class="math display">\[\mathbb{P}(\xi=b)=0~\text{或}~1;\]</span></li><li>若 <span class="math inline">\(\vec{\xi}=(\xi_1,\xi_2,\cdots,\xi_n)\sim N(0,A&#39;A)\)</span>, 其中 <span class="math inline">\(A\)</span> 为 <span class="math inline">\(n\times n\)</span> 矩阵, 其 <span class="math inline">\((s,t)\)</span> 位置的元素 <span class="math display">\[a_{st}=\begin{cases}1, &amp; s = t - 1 \\0, &amp; s\neq t - 1\end{cases}\]</span> 利用 <span class="math inline">\(\xi\)</span> 的特征函数计算 <span class="math inline">\(\vec{\xi}\)</span> 的特征函数;</li><li><span class="math inline">\(\vec{\xi}\)</span> 是 <span class="math inline">\(n\)</span> 维连续型随机变量吗? 证明你的结果;</li><li><span class="math inline">\(\{\xi_n\}_{n=1}^{\infty}\)</span> 满足大数定律吗? 证明你的结果;</li><li><span class="math inline">\(\{\xi_n\}_{n=1}^{\infty}\)</span> 满足中心极限定理吗? 证明你的结果.</li></ol></li><li>(15分)<ol type="1"><li>证明依概率收敛的极限在几乎必然的意义下唯一, 即: 若 <span class="math inline">\(\xi_n\stackrel{\mathbb{P}}{\rightarrow}{\xi},~\xi_n\stackrel{\mathbb{P}}{\rightarrow}{\eta}\)</span>, 必有 <span class="math inline">\(\mathbb{P}(\xi=\eta)=1\)</span>;</li><li>设 <span class="math inline">\(\xi\sim N(0,1)\)</span>, 证明: <span class="math inline">\(-\xi\sim N(0,1)\)</span>;</li><li>距离说明: 弱收敛的极限在几乎必然的意义下不唯一, 即: 如果 <span class="math inline">\(\xi_n\stackrel{w}{\rightarrow}{\xi},~\xi_n\stackrel{w}{\rightarrow}{\eta}\)</span>, 未必有 <span class="math inline">\(\mathbb{P}(\xi=\eta)=1\)</span>.</li></ol></li><li>设 <span class="math inline">\(\{\xi_n\}\)</span> 为独立随机变量列, <span class="math inline">\(\mathbb{E}(\xi_n)=0\)</span>, <span class="math inline">\(D(\xi_n)&lt;\infty\)</span>, <span class="math inline">\(n\geqslant 1\)</span>.<ol type="1"><li><span class="math inline">\(\forall~\epsilon&gt;0\)</span>, 记 <span class="math inline">\(A_1=\{|S_1|\geq\epsilon\}\)</span>, <span class="math display">\[A_k=\{|S_k|\geq\epsilon\}\cap\left(\bigcap\limits_{k=1}^{k-1}\{|S_j|&lt;\epsilon\}\right),\quad k=2,\cdots,n.\]</span> 证明 <span class="math inline">\(A_1,A_2,\cdots,A_n\)</span> 互不相容;</li><li>证明 <span class="math inline">\(S_n-S_k\)</span> 与 <span class="math inline">\(S_k\chi_{A_k}\)</span> 相互独立, 其中 <span class="math inline">\(\chi_{A_k}\)</span> 表示事件 <span class="math inline">\(A_k\)</span> 的示性函数;</li><li>记 <span class="math inline">\(S_n=\sum\limits_{k=1}^n\xi_k\)</span>, 证明 <span class="math display">\[\mathbb{P}\left(\max_{1\leq k\leq n}|S_k|\geq\epsilon\right)\leq\frac{D(S_n)}{\epsilon^2},\qquad\forall~\epsilon&gt;0.\]</span></li></ol></li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 概率论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学复变函数试卷</title>
      <link href="/2017/06/11/BNU-Complex_Analysis-Exam/"/>
      <content type="html"><![CDATA[<ul><li>2015 期末考试 邓冠铁</li><li>2016-2017 学年第二学期期中考试 邓冠铁 赵纪满.</li><li>2016-2017 学年第二学期期末考试 邓冠铁 赵纪满.</li></ul><a id="more"></a><h2 id="复变函数-期末试题-邓冠铁">2015 复变函数 期末试题 邓冠铁</h2><ol type="1"><li>(20分)<ol type="1"><li>叙述孤立奇点的定义.</li><li>求下列各函数在复平面 <span class="math inline">\(\mathbb{C}\)</span> (不含 <span class="math inline">\(\infty\)</span> 点)中的孤立奇点, 孤立奇点各属于哪一种类型(极点指明阶数); <span class="math display">\[(a)~\frac{1}{z(z^2+1)^2};~(b)~\frac{e^z-1-z}{z^2(\cos z-1)}~;~(c)\frac{1}{z^3\sin(1/z)}\]</span></li><li>求 (a) 和 (b) 中函数在孤立奇点 <span class="math inline">\(0\)</span> 的留数.</li></ol></li><li><p>(20分) 叙述留数定理并计算下列积分: <span class="math display">\[(1)~\int\nolimits_{|z|=2}\frac{z-6}{z^2(z^2-1)}dz;~(2)\int\nolimits_{-\infty}^{+\infty}\frac{x\sin xdx}{(1+x^2)(4+x^2)}.\]</span></p></li><li><p>(15分)分式线性映射 <span class="math inline">\(w=T(z)=\frac{z-1}{z+1}\)</span> 将区域 <span class="math inline">\(\Omega=\{z:{\rm Re}~z&lt;0,{\rm Im}~z&lt;0\}\)</span> 映射为什么区域？即求 <span class="math inline">\(T(\Omega)=?\)</span> (作图标明原像区域和像区域.)</p></li><li><p>(20分)叙述儒歇(Rouche)定理并求方程 <span class="math inline">\(z^5-5z^2+z+1=0\)</span> 在圆环 <span class="math inline">\(1&lt;|z|&lt;2\)</span> 内根的个数.</p></li><li><p>(15分)设 <span class="math inline">\(f(z)\)</span> 在区域 <span class="math inline">\(\Omega\)</span> 内解析, 且 <span class="math inline">\(|f(z)|\)</span> 在区域 <span class="math inline">\(\Omega\)</span> 内为常数. 试证明 <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 中为常数.</p></li><li>(10分)<ol type="1"><li>说明多值函数 <span class="math inline">\((z(1-z)^2)^{\frac{1}{3}}\)</span> 在割去线段 <span class="math inline">\([0,1]\)</span> 的 <span class="math inline">\(z\)</span> 平面上可以分出三个单值解析分支;</li><li>求出在 <span class="math inline">\([0,1]\)</span> 的上沿取正值的那个单值解析分支 <span class="math inline">\(g_0(z)\)</span> 在点 <span class="math inline">\(z=-1\)</span> 处的值 <span class="math inline">\(g_0(-1)=?\)</span>;</li><li>计算积分 <span class="math inline">\(\int\nolimits_0^1\frac{\sqrt[3]{x(1-x)^2}dx}{(1+x)}\)</span>.</li></ol></li></ol><h2 id="年复变函数期中考试试卷">2017年复变函数期中考试试卷</h2><ol type="1"><li><p>(20分)设 <span class="math inline">\(z_1,z_2\)</span> 是任意两个复数, 证明 <span class="math display">\[|z_1+z_2|^2+|z_1-z_2|^2=2(|z_1|^2+|z_2|^2),\]</span> 并说明其几何意义(画图说明).</p></li><li><p>(20分)叙述函数 <span class="math inline">\(f(z)=u(x,y)+iv(x,y)\)</span> 在一点的(复)可微和解析的定义且讨论函数 <span class="math inline">\(f(z)=x^2y+ixy^2\)</span> 的(复)可微性和解析性(在何处(复)可微和解析).</p></li><li><p>(25分)将函数 <span class="math inline">\(\frac{z}{z^2+8z+20}\)</span> 按 <span class="math inline">\(z+4\)</span> 的幂展出, 并指出其收敛半径.</p></li><li>(25分)在下了区域中, 哪些区域存在 <span class="math inline">\(\sqrt{(z^2-1)(z^2-4)}\)</span> 的解析分支？请说明理由.<ol type="1"><li><span class="math inline">\(\mathbb{C}\backslash((-\infty,-1]\cup[1,+\infty))\)</span>;</li><li><span class="math inline">\(\mathbb{C}\backslash[-2,2]\)</span>;</li><li><span class="math inline">\(\mathbb{C}\backslash([-2,-1]\cup[1,2))\)</span>;</li><li><span class="math inline">\(\mathbb{C}\backslash((-\infty,-2]\cup[-1,2))\)</span>.</li></ol></li><li><p>(10分)设 <span class="math inline">\(\Omega\)</span> 为平面上的一个非空区域(区域 <span class="math inline">\(\Omega\)</span> 是连通开集, <span class="math inline">\(\Omega\)</span> 中任意两点可以用曲线连接), 如果 <span class="math inline">\(D\subset\Omega\)</span>, <span class="math inline">\(D\)</span> 是一个非空开集且 <span class="math inline">\(D\neq\Omega\)</span>, 证明存在 <span class="math inline">\(D\)</span> 的边界点 <span class="math inline">\(c\in\partial\Omega\)</span> 满足 <span class="math inline">\(c\in\Omega\)</span>.</p></li></ol><h3 id="粗略解答">粗略解答</h3><ol type="1"><li>显然. 几何意义: 平行四边形四边的平方和等于对角线的平方和.</li><li>由C-R方程可知, 函数只在原点可微, 处处不解析.</li><li>拆成分式即可直接展开，此处只列出前几项以供参考: <span class="math display">\[-1+\frac{x+4}{4}+\frac{1}{4} (x+4)^2-\frac{1}{16} (x+4)^3-\frac{1}{16} (x+4)^4+\frac{1}{64} (x+4)^5+O\left((x+4)^6\right).\]</span></li><li>(1)存在, (2)存在, (3)不存在, (4)存在.</li><li>证明从略.</li></ol><h2 id="年复变函数期末考试试卷">2017年复变函数期末考试试卷</h2><ol type="1"><li><p>(15分)叙述函数 <span class="math inline">\(f(z)=u(x,u)+iv(x,y)\)</span> 在一点的(复)可微和解析的定义且讨论函数 <span class="math inline">\(f(z)=x^3y+iy^3x\)</span> 的(复)可微性和解析性(在何处(复)可微和解析).</p></li><li>(25分)将下列函数在指定圆环内展成洛朗级数:<ol type="1"><li><span class="math inline">\(\frac{1}{z^2(z^2-9)},\quad 3&lt;|z|&lt;+\infty\)</span>;</li><li><span class="math inline">\(\cos(\frac{1}{z-1}),\quad 1&lt;|z-1|&lt;+\infty\)</span>;</li><li><span class="math inline">\(\frac{f(z)}{z^5}\)</span>, <span class="math inline">\(f(z)\)</span> 为 <span class="math inline">\({\rm Ln}(1-z)\)</span> 在 <span class="math inline">\(|z|&lt;1\)</span> 中满足 <span class="math inline">\(f(0)=0\)</span> 的解析分支.</li></ol></li><li><p>(25分) (1)求函数 <span class="math inline">\(\frac{z^2-4}{z(z^2-1)^2}\)</span> 和 <span class="math inline">\(\frac{1}{z^4\sin z}\)</span> 在复平面 <span class="math inline">\(\mathbb{C}\)</span> (不含 <span class="math inline">\(\infty\)</span> 点)中的孤立奇点, 孤立奇点各属于哪一种类型(极点要指明阶数); (2)求函数 <span class="math inline">\(\frac{1}{\sin z}\)</span>, <span class="math inline">\(\frac{1}{z^2\sin z}\)</span>, <span class="math inline">\(\frac{1}{z^4\sin z}\)</span> 在 <span class="math inline">\(0\)</span> 处的留数.</p></li><li><p>(10分)分式线性映射 <span class="math inline">\(w=T(z)=\frac{z+i}{z-i}\)</span> 将指定区域 <span class="math inline">\(\Omega=\{z:{\rm Re}~z&lt;0,{\rm Im}~z&lt;0\}\)</span> 映射为什么区域? ( <span class="math inline">\(T(\Omega)=~?\)</span> 作草图标明原像区域和像区域, 并说明理由.)</p></li><li><p>(15分)计算积分 <span class="math display">\[(1)~\int\nolimits_{-\infty}^{+\infty}\frac{x^2\cos x}{x^4+1}dx;\quad (2)\int\nolimits_0^{+\infty}\frac{x^\alpha}{4+x^2}dx~~(-1&lt;\alpha&lt;1).\]</span></p></li><li><p>(10分)说明多值函数 <span class="math inline">\((z^2(1+z)^3)^\frac{1}{5}\)</span> 在割去线段 <span class="math inline">\([-1,0]\)</span> 的 <span class="math inline">\(z\)</span> 平面上可以分出五个单值连续分支. 求出在 <span class="math inline">\([-1,0]\)</span> 的上沿取正值的那个单值解析分支 <span class="math inline">\(g_0(z)\)</span> 在 <span class="math inline">\(z=1\)</span> 点处的值和在点 <span class="math inline">\(z=i\)</span> 处的值.</p></li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 复变函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mathematica学习[2]——修改输入和输出字体</title>
      <link href="/2017/05/09/Mathematica%E6%8A%80%E5%B7%A7%5B2%5D%E2%80%94%E2%80%94%E4%BF%AE%E6%94%B9%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E5%AD%97%E4%BD%93/"/>
      <content type="html"><![CDATA[<p><code>Mathematica</code> 自带的修改字体功能似乎并没有什么用……如果想修改的话，需要手动运行代码修改。代码分为两部分</p><h2 id="函数定义">函数定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">setFont[fontFamily_, fontSize_] := With[</span><br><span class="line">    &#123;</span><br><span class="line">        styleNB = Notebook[</span><br><span class="line">            &#123;</span><br><span class="line">                Cell[StyleData[StyleDefinitions -&gt; &quot;Default.nb&quot;]],</span><br><span class="line">                Cell[StyleData[&quot;StandardForm&quot;],</span><br><span class="line">                FontFamily -&gt; ToString[fontFamily],</span><br><span class="line">                FontSize -&gt; ToExpression[fontSize]]</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        styleSheetName = FileNameJoin[</span><br><span class="line">            &#123;</span><br><span class="line">                $UserBaseDirectory, </span><br><span class="line">                &quot;SystemFiles&quot;, </span><br><span class="line">                &quot;FrontEnd&quot;, </span><br><span class="line">                &quot;StyleSheets&quot;, </span><br><span class="line">                &quot;myStyle.nb&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    If[</span><br><span class="line">    FileExistsQ[styleSheetName], </span><br><span class="line">    SetOptions[$FrontEnd,</span><br><span class="line">    DefaultStyleDefinitions -&gt; &quot;Default.nb&quot;]</span><br><span class="line">    ];</span><br><span class="line">    Export[styleSheetName, styleNB];</span><br><span class="line">    SetOptions[$FrontEnd, DefaultStyleDefinitions -&gt; styleSheetName]</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="函数运行">函数运行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setFont[&quot;字体名称&quot;, 字体大小]</span><br><span class="line">比如：</span><br><span class="line">setFont[&quot;Consolas&quot;, 12]</span><br><span class="line">或者</span><br><span class="line">setFont[&quot;Monaco&quot;, 13]</span><br></pre></td></tr></table></figure><h2 id="用法">用法</h2><p>将以上函数和运行的代码粘贴进一个<code>.nb</code>文档，运行即可修改字体。</p>]]></content>
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> Mathematica </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>几篇TOEFL独立写作范文</title>
      <link href="/2017/04/13/%E5%87%A0%E7%AF%87TOEFL%E7%8B%AC%E7%AB%8B%E5%86%99%E4%BD%9C%E8%8C%83%E6%96%87/"/>
      <content type="html"><![CDATA[<h2 id="第一篇">第一篇</h2><p>In such a competitive society with ceaseless changes, there is a heated debate of the most fundamental factor of keeping close bond with people we love. Obviously, opinions vary from person to person in accordance with their inner preference. After a scrupulous assessment, I would render my support to spending time with them as much as possible.</p><p>To begin with, regarding the potential harm brought by being apart from the closest people, to say that moving far away is crucial for everyone to attach importance to valuable relationships is an exaggeration. Admittedly, whenever we step into a totally unfamiliar cultural background, it is likely that we would suffer in nostalgia and feel it hard to adapt to new environment immediately, which allows us to realize the indispensable role they play in our life. However, when analyzing this issue from an objective angle, we would find that the benefits caused by getting away from our parents are dwarfed by its negative influences. Even if the technological development enables us to keep in touch with our friends and families across a long distance, there are still emotional feelings and genuine expressions that cannot be discerned by others through the Internet.</p><p>In addition, compared with living in a great distance, spending time together provides a greater opportunity for us to enhance our mutual relationship much more effectively. Living in a fast paced society, young generation has been suffered overwhelming pressure from daily work and intensive study, which means that hardly can they squeeze time to accompany their families and friends. As a result, they will definitely treasure the scarce chance of holiday to have fun with their beloved friends and relatives. For instance, in Spring Festival in China, which is one of the most grandeur festivals for Chinese people, not only will people set off firecrackers to celebrate the important moment, but also they can share the latest information with each other and enjoy the harmonious atmosphere together. Consequently, it would benefit their relationship in the long run.</p><p>Last but not least, living with our close friends or families together paves a good way for us to give them cares and unconditioned help, so that we would not regret for not standing besides them in their darkest time. Numerous people post their regretful comments on Facebook because of their families death and their absence in their tough times. There is no denying that facing challenges together and forming a unity fortress are the most effective ways to establish the solid relationships in everyone’s life. Since during the process of figuring out best solutions, we are likely to stand in others shoes to analyze problems and get deeper understanding of others. Generally speaking, people tend to cherish those friends who lend them a hand whenever they are stuck in dilemma.</p><p>In conclusion, considering the details mentioned above, it is a better choice for us to take time to accompany people who are important to us, instead of being far away from them. (498)</p><h2 id="第二篇">第二篇</h2><p>独立写作题目：Do you agree or disagree with the following statement? Workers would be much happier if they are doing different types of tasks at the same time than doing the same task. </p><p>范文立场选择：Disagree</p><h3 id="opening-60-100-words">Opening (60-100 Words)</h3><h4 id="intro">Intro</h4><p>Reasonable schedule arrangement and patient handling of each task demonstrate a person’s overall potential in his career. Especially in such a society with intensive competition, working pressures urge employees to devote much to the fulfillment of numerous projects. Therefore, some people would like to do several projects at a time for adjusting to a stressful working condition. </p><h4 id="thesis">Thesis</h4><p>However, as far as I am concerned, finishing one task completely then to another should be more efficient because attentiveness is crucial to the performance of any projects. </p><h3 id="body-120-150-words">Body (120-150 Words)</h3><h4 id="topic">Topic</h4><p>Last but not least, the focus of attention determines the final result of a project and is immediately related to working quality.</p><h4 id="state">State</h4><p>Doing several projects at the same time might divert attentiveness and may also undermine the general progress subsequently.</p><h4 id="e.g.">e.g.</h4><p>To illustrate, in the field of architecture which I am majoring in, there is sufficient evidence to show that treating each progress, from scheme design to construction documentation, with attention continually might keep each step more efficient and prepare more fruitful outcomes in the upcoming phase. In other words, it is more reliable for an architect to finish one design and then proceed to the next as well as an unnecessary mix-up of various programs can be a drag on the whole plan. </p><h4 id="close">Close</h4><p>It is no exaggeration to say that stopping one temporarily and changing to others might incur some undesirable accidents.</p><h2 id="第三篇">第三篇</h2><p>Facing the fierce competition in modern society, the pursuit for the success has been the essence of the education. There are multiple choices to promote students’ academic performance and accomplish final goals for students. Personally speaking, I would regard receiving support from families and friends as the most important element to be an elite.</p><p>First and foremost, modern society has witnessed that the career of private tutorship is developing at an alarming rate recently. Admittedly, knowledgeable advisors enable students to enlarge their knowledge base. However, this solution should be not considered as a wise choice. After all, parents and friends are the ones who know us best, because they have experienced every moment of our life with us. No matter what dilemma students are trapped in, it is their closest friends and families who are able to render solid support and lead them step out of woods. What’s more, considering the crucial role played by parents and friends, hiring private advisors would turn out to be a huge drain of parents’ money.</p><p>In addition, it is admitted that attending high school is an imperative factor, which defines students’ educational background and shapes their value. However, it is less rigorous to say that high school education holds the key to accomplish one’s dream. Tracing back to our childhood, whenever we were stuck in a disappointed situation, only if our parents spotted our anomaly, there is no doubt that they would reach out to us and have a deep conversation with us. All they want to do was to encourage us to step out of the shade with a positive attitude and embrace the bright life bravely. Comparatively speaking, high school teachers are only aiming at the promotion of students’ grades. Hardly can they teach students in accordance with their aptitude.</p><p>Last but not least, unconditional support of our families and friends constitutes the steppingstone towards further achievement. No one can substitute their imperative position in our life. For instance, after graduation from high school, not until I packed up my baggage and went abroad for study did I realize how important it is to master fundamental skills, such as financial management, car maintenance and cooking by myself, all of which are taught by my mother. Also, living in a foreign and unfamiliar environment is a huge challenge faced by international students, including me. However, in the darkest and hardest time, my friends always make video call through the convenient Internet, which enables me to receive their warm greetings and erase the severe nostalgia. It is because of their love that I have enough strength and faith to rise above the obstacles.</p><p>In conclusion, with respect to the most effective factor of success, nothing can be compared with the generous love and care from our families and beloved friends. (467)</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
            <tag> TOEFL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一些 LaTeX 技巧</title>
      <link href="/2017/04/04/LaTeX%E6%8A%80%E5%B7%A7/"/>
      <content type="html"><![CDATA[<ul><li>修改数学公式字体</li><li>打生僻字</li><li>一些数学符号</li><li>代码环境</li></ul><a id="more"></a><h2 id="修改数学公式字体">修改数学公式字体</h2><p>LaTeX - Beamer 中默认字体很难看，以下两种方法均可修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\usefonttheme[onlymath]&#123;serif&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\usefonttheme&#123;professionalfonts&#125;</span><br></pre></td></tr></table></figure><h2 id="左右结构的生僻字">左右结构的生僻字</h2><p>名字有“喆”的痛苦… 有些字体可能没有这个字.. 既然打不出来“喆”，那“吉”总可以搞定吧，那我打两个一半宽度的“吉”不就好了吗？</p><p>实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\hbox&#123;\resizebox&#123;1.1ex&#125;&#123;1.8ex&#125;&#123;吉&#125;&#125;\hbox&#123;\resizebox&#123;1.1ex&#125;&#123;1.8ex&#125;&#123;吉&#125;&#125;</span><br></pre></td></tr></table></figure><p>其中的高度和宽度可以自行调整。</p><p>类似“喆”的左右结构的生僻字都可以用这种方法解决。</p><h2 id="一些数学符号">一些数学符号</h2><ul><li>正规子群：<span class="math inline">\(\trianglelefteq\)</span> <code>\trianglelefteq</code> <span class="math inline">\(\triangleleft\)</span> <code>\triangleleft</code></li><li>半直积：<span class="math inline">\(\rtimes\)</span> <code>\rtimes</code> <span class="math inline">\(\ltimes\)</span> <code>\ltimes</code></li><li>逻辑运算：<span class="math inline">\(\lnot\)</span> <code>\lnot</code> <span class="math inline">\(\land\)</span> <code>\land</code> <span class="math inline">\(\lor\)</span> <code>\lor</code></li><li>映射：<span class="math inline">\(f: G\to H,~~a \mapsto f(a)\)</span> <code>\mapsto</code></li></ul><h2 id="代码环境">代码环境</h2><p>一般用 listings，C++ 的具体配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">\usepackage&#123;listings&#125;</span><br><span class="line">\usepackage&#123;xcolor&#125;</span><br><span class="line"></span><br><span class="line">\definecolor&#123;CPPLight&#125;  &#123;HTML&#125; &#123;686868&#125;</span><br><span class="line">\definecolor&#123;CPPSteel&#125;  &#123;HTML&#125; &#123;888888&#125;</span><br><span class="line">\definecolor&#123;CPPDark&#125;   &#123;HTML&#125; &#123;262626&#125;</span><br><span class="line">\definecolor&#123;CPPBlue&#125;   &#123;HTML&#125; &#123;4172A3&#125;</span><br><span class="line">\definecolor&#123;CPPGreen&#125;  &#123;HTML&#125; &#123;487818&#125;</span><br><span class="line">\definecolor&#123;CPPBrown&#125;  &#123;HTML&#125; &#123;A07040&#125;</span><br><span class="line">\definecolor&#123;CPPRed&#125;    &#123;HTML&#125; &#123;AD4D3A&#125;</span><br><span class="line">\definecolor&#123;CPPViolet&#125; &#123;HTML&#125; &#123;7040A0&#125;</span><br><span class="line">\definecolor&#123;CPPGray&#125;  &#123;HTML&#125; &#123;B8B8B8&#125;</span><br><span class="line"></span><br><span class="line">\lstset&#123;</span><br><span class="line">    columns=fixed,       </span><br><span class="line">    numbers=left,                                        % 在左侧显示行号</span><br><span class="line">    frame=none,                                          % 不显示背景边框</span><br><span class="line">    backgroundcolor=\color[RGB]&#123;245,245,244&#125;,            % 设定背景颜色</span><br><span class="line">    keywordstyle=\color[RGB]&#123;40,40,255&#125;,                 % 设定关键字颜色</span><br><span class="line">    numberstyle=\footnotesize\color&#123;darkgray&#125;,           % 设定行号格式</span><br><span class="line">    commentstyle=\it\color[RGB]&#123;0,96,96&#125;,                % 设置代码注释的格式</span><br><span class="line">    stringstyle=\rmfamily\slshape\color[RGB]&#123;128,0,0&#125;,   % 设置字符串格式</span><br><span class="line">    showstringspaces=false,                              % 不显示字符串中的空格</span><br><span class="line">    language=c++,                                        % 设置语言</span><br><span class="line">    morekeywords=&#123;alignas,continute,friend,register,true,alignof,decltype,goto,</span><br><span class="line">    reinterpret_cast,try,asm,defult,if,return,typedef,auto,delete,inline,short,</span><br><span class="line">    typeid,bool,do,int,signed,typename,break,double,long,sizeof,union,case,</span><br><span class="line">    dynamic_cast,mutable,static,unsigned,catch,else,namespace,static_assert,using,</span><br><span class="line">    char,enum,new,static_cast,virtual,char16_t,char32_t,explict,noexcept,struct,</span><br><span class="line">    void,export,nullptr,switch,volatile,class,extern,operator,template,wchar_t,</span><br><span class="line">    const,false,private,this,while,constexpr,float,protected,thread_local,</span><br><span class="line">    const_cast,for,public,throw,std&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="young-表绘制">Young 表绘制</h2><p>核心是去掉一些竖线.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;array&#125;&#123;|cc|&#125;</span><br><span class="line">  \cline&#123;1-1&#125; 1 &amp; \multicolumn&#123;1&#125;&#123;|c&#125;&#123;&#125; \\</span><br><span class="line">  \hline </span><br><span class="line">  2 &amp; 3 \\</span><br><span class="line">  \hline</span><br><span class="line">\end&#123;array&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>组合杂题</title>
      <link href="/2017/03/21/%E7%BB%84%E5%90%88%E6%9D%82%E9%A2%98/"/>
      <content type="html"><![CDATA[<h2 id="年03月21日">2017年03月21日</h2><h3 id="保险箱问题">保险箱问题</h3><p>这个题是老师在课上提出来的，比较有意思，随手记录一下.</p><blockquote><p><span class="math inline">\(6\)</span> 个人共用一个保险箱，要求任意 <span class="math inline">\(3\)</span> 人在一起时都可以打开保险箱，并且最少需要 <span class="math inline">\(3\)</span> 人才能打开. 请问至少需要多少把锁？每个人至少需要多少把钥匙？</p></blockquote><p><strong>解答</strong>：先估计一个锁数量的下界. 由题意，每 <span class="math inline">\(2\)</span> 个人都不能打开该保险箱， 故每 <span class="math inline">\(2\)</span> 个人都至少有一把不能打开的锁，且对于不同的两人组，不能打开的锁互不相同，故锁的数量不能少于 <span class="math inline">\(2\)</span> 元子集的个数，即 <span class="math inline">\(\binom{6}{2}=15\)</span>.</p><p>再考虑钥匙的数量. 由于任意 <span class="math inline">\(3\)</span> 个人都能打开保险箱，故每个人都需要有<strong>不包括自己的所有二人组所没有的钥匙</strong>，即每个人至少要有 <span class="math inline">\(\binom{5}{2}=10\)</span> 把钥匙.</p><p>以上只是对于下界的估计，要证明其最小性还需构造一组情况来证明最小值可以取到. 构造很容易，不多赘述.</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一些概率论题目</title>
      <link href="/2017/03/10/%E4%B8%80%E4%BA%9B%E6%A6%82%E7%8E%87%E8%AE%BA%E9%A2%98%E7%9B%AE/"/>
      <content type="html"><![CDATA[<h2 id="几句废话">几句废话</h2><p>本来觉得概率论是比较简单的课，学了几节课才知道原来简单的是别人家的概率论…我们自家的概率论其实很蛋疼…据刘伟说他当时概率论分比较低…弱菜非常恐慌…于是便在学习中顺便整理一下给自己启发的题目. 由于教材采用师大版概率论（李勇 主编），故题目大多来自于该书.</p><h2 id="年03月10日">2017年03月10日</h2><h3 id="师大概率论-练习-1.2.4">师大概率论 练习 1.2.4</h3><blockquote><p>甲乙两人抛硬币，甲抛 <span class="math inline">\(n+1\)</span> 枚，乙抛 <span class="math inline">\(n\)</span> 枚，求甲的正面比乙多的概率.</p></blockquote><p><strong>解答</strong>：考虑甲乙都抛 <span class="math inline">\(n\)</span> 枚硬币的情形，设甲正面比乙多的概率为 <span class="math inline">\(p\)</span>，则由对称性可知，乙比甲正面多的概率也为 <span class="math inline">\(p\)</span>. 故两人正面一样多的概率为 <span class="math inline">\(1-2p\)</span>. 再考虑甲抛的第 <span class="math inline">\(n+1\)</span> 枚硬币，有 <span class="math inline">\(\frac{1}{2}\)</span> 概率为正面，<span class="math inline">\(\frac{1}{2}\)</span> 为反面，则有如下讨论：</p><ul><li>若都抛 <span class="math inline">\(n\)</span> 枚时，甲比乙正面多，则无论甲的第 <span class="math inline">\(n+1\)</span> 枚为正面还是反面，甲的正面都会比乙多. 该情况出现的概率为 <span class="math inline">\(p_1=p\times1=p\)</span>；</li><li>若都抛 <span class="math inline">\(n\)</span> 枚时，甲比乙正面少，则无论甲的第 <span class="math inline">\(n+1\)</span> 枚为正面还是反面，甲的正面都无法比乙多. 该情况出现的概率为 <span class="math inline">\(p_2=p\times1=p\)</span>；</li><li>若都抛 <span class="math inline">\(n\)</span> 枚时，甲乙正面一样多，且甲的第 <span class="math inline">\(n+1\)</span> 枚为正面，甲的正面就会比乙多. 该情况出现的概率为 <span class="math inline">\(p_3=\frac{1-2p}{2}\times\frac{1}{2}\)</span>；</li><li>若都抛 <span class="math inline">\(n\)</span> 枚时，甲乙正面一样多，且甲的第 <span class="math inline">\(n+1\)</span> 枚为正面，甲的正面就会比乙少. 该情况出现的概率为 <span class="math inline">\(p_3=\frac{1-2p}{2}\times\frac{1}{2}\)</span>.</li></ul><p>以上情况中，第一种和第三种出现时，甲的正面会比乙多，否则不会. 故甲正面比乙多的概率为 <span class="math inline">\(p_1+p_3=\frac{1}{2}\)</span>.</p><hr><p>兔子提出了一种很好玩儿的解答.</p><p><strong>解答</strong>：甲抛 <span class="math inline">\(n+1\)</span> 枚，乙抛 <span class="math inline">\(n\)</span> 枚，只可能有两种情况出现：</p><ul><li>甲的正面比乙多；</li><li>甲的反面比乙多.</li></ul><p>两种情况不会同时发生，并且概率和为 <span class="math inline">\(1\)</span>，又由对称性可知两种情况出现的概率相同，故都为 <span class="math inline">\(\frac{1}{2}\)</span>.</p><h3 id="师大概率论-练习-1.2.9">师大概率论 练习 1.2.9</h3><blockquote><p>在单位圆周上任取三点 <span class="math inline">\(A,B,C\)</span>，试求事件 <span class="math inline">\(E=\{\triangle ABC\text{成锐角三角形}\}\)</span> 的概率.</p></blockquote><p><strong>解答</strong>：设 <span class="math inline">\(\triangle ABC\)</span> 的三个内角分别为 <span class="math inline">\(x,y,z\)</span>，则能构成三角形的条件为：</p><p><span class="math display">\[x+y+z=\pi\qquad x,y,z&gt;0\]</span></p><p>在三维坐标系中，“能构成三角形”所对应的样本空间为一个三角形，三个顶点分别为 <span class="math inline">\(D(0,0,\pi),E(0,\pi,0),F(0,0,\pi)\)</span>. 而能构成锐角三角形的条件为：</p><p><span class="math display">\[x+y+z=\pi\qquad 0&lt;x,y,z&lt;\frac{\pi}{2}\]</span></p><p>也会构成一个三角形，三个顶点分别为 <span class="math inline">\(G(0,\frac{\pi}{2},\frac{\pi}{2}),H(\frac{\pi}{2},0,\frac{\pi}{2}),I(\frac{\pi}{2},\frac{\pi}{2},0)\)</span>. 于是 <span class="math inline">\(\triangle ABC\)</span> 为锐角三角形的概率为 <span class="math inline">\(\frac{S_{\triangle GHI}}{S_{\triangle DEF}}=\frac{1}{4}\)</span> .</p><h2 id="年03月22日">2017年03月22日</h2><h3 id="师大概率论-练习-2.1.7">师大概率论 练习 2.1.7</h3><blockquote><p>设 <span class="math inline">\(\mathbb{P}(A)+\mathbb{P}(B)=1\)</span>，证明 <span class="math inline">\(\mathbb{P}(AB)=\mathbb{P}(\overline{A}\overline{B})\)</span>.</p></blockquote><p><strong>证明</strong>：由于事件“<strong><span class="math inline">\(A,B\)</span> 中有且仅有一个发生</strong>”和事件“<strong><span class="math inline">\(A,B\)</span> 中有且仅有一个不发生</strong>”是相同的事件，故其概率也应该相同.</p><p>由容斥原理，事件“<span class="math inline">\(A,B\)</span> 中至少有一个发生”的概率为 <span class="math inline">\(\mathbb{P}(A\cup B)=\mathbb{P}(A)+\mathbb{P}(B)-\mathbb{P}(AB)\)</span>.</p><p>故事件“<strong><span class="math inline">\(A,B\)</span> 中有且仅有一个发生</strong>”的概率为 <span class="math inline">\(\mathbb{P}(A)+\mathbb{P}(B)-\mathbb{P}(AB)\)</span>.</p><p>同理，事件“<span class="math inline">\(A,B\)</span> 中至少有一个不发生”的概率为 <span class="math inline">\(\mathbb{P}(\overline{A}\cup\overline{B})=\mathbb{P}(\overline{A})+\mathbb{P}(\overline{B})-\mathbb{P}(\overline{A}\overline{B})\)</span>.</p><p>故事件“<span class="math inline">\(A,B\)</span> 中有且仅有一个不发生”的概率为 <span class="math inline">\(\mathbb{P}(\overline{A})+\mathbb{P}(\overline{B})-\mathbb{P}(\overline{A}\overline{B})\)</span>.</p><p>于是有，<span class="math display">\[\mathbb{P}(A)+\mathbb{P}(B)-\mathbb{P}(AB)=\mathbb{P}(\overline{A})+\mathbb{P}(\overline{B})-\mathbb{P}(\overline{A}\overline{B}).\]</span></p><p>又由于 <span class="math inline">\(\mathbb{P}(A)+\mathbb{P}(B)=1\)</span>，故 <span class="math inline">\(\mathbb{P}(\overline{A})+\mathbb{P}(\overline{B})=1\)</span>，故有：<span class="math display">\[\mathbb{P}(AB)=\mathbb{P}(\overline{A}\overline{B}).\]</span></p><h2 id="年03月25日">2017年03月25日</h2><h3 id="师大概率论-练习-2.3.2">师大概率论 练习 2.3.2</h3><blockquote><p>试证明事件 <span class="math inline">\(A_1,A_2,\cdots,A_n\)</span> 相互独立的充要条件为：对每个事件 <span class="math inline">\(\hat{A}_{k}=A_k\)</span> 或者 <span class="math inline">\(\overline{A_k}(k=1,2,\cdots,n)\)</span>，总有 <span class="math display">\[\mathbb{P}(\hat{A}_{1}\hat{A}_{2}\cdots\hat{A}_{n})=\mathbb{P}(\hat{A}_{1})\mathbb{P}(\hat{A}_{2})\cdots\mathbb{P}(\hat{A}_{n}).\]</span></p></blockquote><p><strong>证明</strong>：显然 <span class="math inline">\(n=2\)</span> 时成立.</p><p>假设 <span class="math inline">\(n=k\)</span> 时结论成立，则有：</p><p><strong>必要性</strong>：令 <span class="math inline">\(B=A_k\cap A_{k+1}\)</span>，则 <span class="math inline">\(A_1,A_2,\cdots,A_{k-1},B\)</span> 相互独立. 于是有</p><p><span class="math display">\[\mathbb{P}(\hat{A}_{1}\hat{A}_{2}\cdots\hat{A}_{n-1}\hat{B})=\mathbb{P}(\hat{A}_{1})\mathbb{P}(\hat{A}_{2})\cdots\mathbb{P}(\hat{A}_{n-1})\mathbb{P}(\hat{B}).\]</span></p><p>即</p><p><span class="math display">\[\mathbb{P}(\hat{A}_{1}\hat{A}_{2}\cdots\hat{A}_{n-1}A_k A_{k+1})=\mathbb{P}(\hat{A}_{1})\mathbb{P}(\hat{A}_{2})\cdots\mathbb{P}(\hat{A}_{n-1})\mathbb{P}(A_k)\mathbb{P}(A_{k+1}).\]</span></p><p>同理也有：</p><p><span class="math display">\[\mathbb{P}(\hat{A}_{1}\hat{A}_{2}\cdots\hat{A}_{n-1}\overline{A_k} A_{k+1})=\mathbb{P}(\hat{A}_{1})\mathbb{P}(\hat{A}_{2})\cdots\mathbb{P}(\hat{A}_{n-1})\mathbb{P}(\overline{A_k})\mathbb{P}(A_{k+1}).\]</span></p><p><span class="math display">\[\mathbb{P}(\hat{A}_{1}\hat{A}_{2}\cdots\hat{A}_{n-1}A_k \overline{A_{k+1}})=\mathbb{P}(\hat{A}_{1})\mathbb{P}(\hat{A}_{2})\cdots\mathbb{P}(\hat{A}_{n-1})\mathbb{P}(A_k)\mathbb{P}(\overline{A_{k+1}}).\]</span></p><p><span class="math display">\[\mathbb{P}(\hat{A}_{1}\hat{A}_{2}\cdots\hat{A}_{n-1}\overline{A_k} \overline{A_{k+1}})=\mathbb{P}(\hat{A}_{1})\mathbb{P}(\hat{A}_{2})\cdots\mathbb{P}(\hat{A}_{n-1})\mathbb{P}(\overline{A_k})\mathbb{P}(\overline{A_{k+1}}).\]</span></p><p>即有 <span class="math inline">\(\mathbb{P}(\bigcap\limits_{i=1}^{k+1}\hat{A}_{i})=\prod\limits_{i=1}^{k+1}\mathbb{P}(\hat{A}_{i})\)</span>. 必要性得证.</p><p><strong>充分性</strong>：对于 <span class="math inline">\(\forall~1&lt;s&lt;k+1\)</span>，<span class="math inline">\(\forall~1\leq i_1&lt;i_2&lt;\cdots&lt;i_s\leq k+1\)</span>，由条件，对于 <span class="math inline">\(\forall~j\)</span> s.t. <span class="math inline">\(1\leq j\leq k+1\)</span> 且 <span class="math inline">\(j\notin\{i_1,i_2,\cdots,i_s\}\)</span>，总有：</p><p><span class="math display">\[\mathbb{P}(\hat{A}_{1}\cdots\hat{A}_{j-1}A_j\hat{A}_{j+1}\cdots\hat{A}_{k+1})=\mathbb{P}(\hat{A}_{1})\cdots\mathbb{P}(\hat{A}_{j-1})\mathbb{P}(A_j)\mathbb{P}(\hat{A}_{j+1})\cdots\mathbb{P}(\hat{A}_{k+1})\]</span></p><p>且</p><p><span class="math display">\[\mathbb{P}(\hat{A}_{1}\cdots\hat{A}_{j-1}\overline{A_j}\hat{A}_{j+1}\cdots\hat{A}_{k+1})=\mathbb{P}(\hat{A}_{1})\cdots\mathbb{P}(\hat{A}_{j-1})\mathbb{P}(\overline{A_j})\mathbb{P}(\hat{A}_{j+1})\cdots\mathbb{P}(\hat{A}_{k+1})\]</span></p><p>由于 <span class="math inline">\(\mathbb{P}(A_j)+\mathbb{P}(\overline{A_j})=1\)</span>，将以上两式相加即得：</p><p><span class="math display">\[\mathbb{P}(\hat{A}_{1}\cdots\hat{A}_{j-1}\hat{A}_{j+1}\cdots\hat{A}_{k+1})=\mathbb{P}(\hat{A}_{1})\cdots\mathbb{P}(\hat{A}_{j-1})\mathbb{P}(\hat{A}_{j+1})\cdots\mathbb{P}(\hat{A}_{k+1})\]</span></p><p>式中共有 <span class="math inline">\(k\)</span> 个事件，故由假设可知这 <span class="math inline">\(k\)</span> 个事件相互独立. 又由于 <span class="math inline">\(\{\hat{A}_{i_1},\cdots,\hat{A}_{i_s}\}\subset\{\hat{A}_{1},\cdots,\hat{A}_{k+1}\}\)</span>，故有 <span class="math inline">\(\mathbb{P}(\bigcap\limits_{j=1}^{s}A_{i_j})=\prod\limits_{j=1}^{s}\mathbb{P}(A_{i_j})\)</span>，<span class="math inline">\(\forall~1\leq i_1&lt;\cdots&lt;i_s\leq k+1\)</span>. 充分性得证.</p><p><strong>综上所述</strong>，原命题成立.</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 概率论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一些实变函数题目</title>
      <link href="/2017/03/09/%E4%B8%80%E4%BA%9B%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0%E9%A2%98%E7%9B%AE/"/>
      <content type="html"><![CDATA[<h2 id="符号说明">符号说明</h2><p><span class="math inline">\(m^*(E)\)</span> 表示 <span class="math inline">\(E\)</span> 的外测度; <span class="math inline">\(m(E)\)</span> 表示 <span class="math inline">\(E\)</span> 的测度.</p><h2 id="年03月09日">2017年03月09日</h2><h3 id="习题1-第一组-7">习题1 第一组 7</h3><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 是定义在 <span class="math inline">\([0,1]\)</span> 上的实值函数, 且存在常数 <span class="math inline">\(M\)</span>, 使得对于 <span class="math inline">\([0,1]\)</span> 中的任意有限个数 <span class="math inline">\(x_1,x_2,\cdots,x_n\)</span>, 均有 <span class="math inline">\(\vert f(x_1)+f(x_2)+\cdots+f(x_n)\vert \leqslant M\)</span>, 试证下述集合是可数集: <span class="math display">\[E=\{x\in[0,1]~\vert ~f(x)\neq0\}\]</span></p></blockquote><p><strong>证明</strong>: 考虑如下的两族集合:</p><p><span class="math display">\[A_n=\{x\in[0,1]~\vert ~f(x)&gt;\frac{1}{n}\}\]</span> <span class="math display">\[B_n=\{x\in[0,1]~\vert ~f(x)&lt;-\frac{1}{n}\}\]</span></p><p>则有:</p><p><span class="math display">\[E=\bigcup_{n=1}^\infty\{x\in[0,1]~\vert ~\vert  f(x)\vert &gt;\frac{1}{n}\}=\bigcup_{n=1}^\infty(A_n\cup B_n)\]</span></p><p>而对于 <span class="math inline">\(A_n\)</span>, 任取其中的 <span class="math inline">\(p\)</span> 个数 <span class="math inline">\(x_1,x_2,\cdots,x_p\)</span>, 均有:</p><p><span class="math display">\[p\times\frac{1}{n}&lt;\vert  f(x_1)+f(x_2)+\cdots+f(x_n)\vert \leqslant M\]</span></p><p>于是有 <span class="math inline">\(p&lt;nM\)</span>, 即 <span class="math inline">\(\forall~n\)</span>, <span class="math inline">\(A_n\)</span> 只含有限个数. 同理 <span class="math inline">\(\forall~n\)</span>, <span class="math inline">\(B_n\)</span> 也只含有限个数. 故 <span class="math inline">\(\forall~n\)</span>, <span class="math inline">\(A_n\cup B_n\)</span> 只含有限个数. 于是 <span class="math inline">\(E\)</span> 为可数个有限集合的并, 故 <span class="math inline">\(E\)</span> 是可数集.</p><h3 id="习题1-第一组-12">习题1 第一组 12</h3><blockquote><p>设 <span class="math inline">\(E=\bigcup\limits_{n=1}^\infty A_n\)</span>. 若 <span class="math inline">\(\vert E\vert =\aleph\)</span>, 试证明 <span class="math inline">\(\exists~n_0\)</span>, s.t. <span class="math inline">\(\vert A_{n_0}\vert =\aleph\)</span>.</p></blockquote><p><strong>证明</strong>: 显然 <span class="math inline">\(\forall~n\)</span>, <span class="math inline">\(\vert A_n\vert \leqslant\aleph\)</span>. 若 <span class="math inline">\(\forall~n\)</span>, <span class="math inline">\(\vert A_n\vert &lt;\aleph\)</span>, 则每个 <span class="math inline">\(A_n\)</span> 都是至多可数集. 即 <span class="math inline">\(E\)</span> 为至多可数个至多可数集的并集, 即 <span class="math inline">\(E\)</span> 至多可数, 与 <span class="math inline">\(\vert E\vert =\aleph\)</span> 矛盾. 故 <span class="math inline">\(\exists~n_0\)</span>, s.t. <span class="math inline">\(\vert A_{n_0}\vert =\aleph\)</span>.</p><h3 id="习题1-第一组-13">习题1 第一组 13</h3><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 是定义在 <span class="math inline">\(\mathbf{R}^1\)</span> 上的单调上升函数, 试证明点集 <span class="math display">\[E=\{x:\forall~\epsilon&gt;0,~f(x+\epsilon)-f(x-\epsilon)&gt;0\}\]</span> 是 <span class="math inline">\(\mathbf{R}^1\)</span> 中的闭集.</p></blockquote><p><strong>证明</strong>: 考虑 <span class="math inline">\(\forall~x\in E&#39;\)</span>, <span class="math inline">\(\exists~\{x_n\}\subset E\)</span>, s.t. <span class="math inline">\(\lim\limits_{n\to\infty}x_n=x\)</span>. 故 <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, <span class="math inline">\(\exists~N\)</span>, s.t. <span class="math inline">\(\forall~n&gt;N\)</span>, <span class="math inline">\(\vert x-x_n\vert &lt;\frac{\epsilon}{2}\)</span>. 于是由条件有 <span class="math inline">\(f(x_{N+1}+\frac{\epsilon}{2})-f(x_{N+1}-\frac{\epsilon}{2})&gt;0\)</span>, 由 <span class="math inline">\(f\)</span> 的单调性, 有 <span class="math display">\[(f(x+\epsilon)-f(x-\epsilon))-(f(x_{N+1}+\frac{\epsilon}{2})-f(x_{N+1}-\frac{\epsilon}{2}))&gt;0\]</span> 即 <span class="math inline">\(x\in E\)</span>. 故 <span class="math inline">\(E\)</span> 为闭集.</p><h3 id="习题1-第一组-14">习题1 第一组 14</h3><blockquote><p>设 <span class="math inline">\(F\subset\mathbf{R}^n\)</span> 为有界闭集, <span class="math inline">\(E\)</span> 是 <span class="math inline">\(F\)</span> 中的一个无限子集, 试证明: <span class="math inline">\(E&#39;\cap F\neq\varnothing\)</span>. 反之, 若 <span class="math inline">\(F\subset\mathbf{R}^n\)</span> 且对 <span class="math inline">\(F\)</span> 中任一无限子集 <span class="math inline">\(E\)</span>, 有 <span class="math inline">\(E&#39;\cap F\neq\varnothing\)</span>, 试证明 <span class="math inline">\(F\)</span> 是有界闭集.</p></blockquote><p><strong>证明</strong>: 一方面, 由于 <span class="math inline">\(E\subset F\)</span>, 故 <span class="math inline">\(E\)</span> 中存在收敛子列, 故 <span class="math inline">\(E&#39;\neq\varnothing\)</span>. 由于 <span class="math inline">\(F\)</span> 是有界闭集, 故 <span class="math inline">\(E&#39;\subset F&#39;\subset F\)</span>, 于是 <span class="math inline">\(E&#39;\cap F\neq\varnothing\)</span>. 另一方面, <strong>首先证明 <span class="math inline">\(F\)</span> 是闭集</strong>: <span class="math inline">\(\forall~x\in F&#39;\)</span>, <span class="math inline">\(\exists~E=\{x_n\}_{n=1}^{+\infty}\subset F\)</span>, s.t. <span class="math inline">\(\lim\limits_{n\to\infty}x_n=x\)</span>, 即 <span class="math inline">\(E&#39;=\{x\}\)</span>. 又由于 <span class="math inline">\(\forall~E\subset F\)</span>, 均有 <span class="math inline">\(E&#39;\cap F\neq\varnothing\)</span>, 故 <span class="math inline">\(x\in F\)</span>, 即 <span class="math inline">\(F\)</span> 为闭集. <strong>其次证明 <span class="math inline">\(F\)</span> 有界</strong>: 若 <span class="math inline">\(F\)</span> 无界, 则任取 <span class="math inline">\(E\)</span> 为 <span class="math inline">\(F\)</span> 中的发散序列, 即可得到 <span class="math inline">\(E&#39;=\varnothing\)</span>, 此时显然有 <span class="math inline">\(E&#39;\cap F=\varnothing\)</span>, 矛盾. 故 <span class="math inline">\(F\)</span> 有界. <strong>综上</strong>, <span class="math inline">\(F\)</span> 有界闭集.</p><h3 id="习题1-第一组-15">习题1 第一组 15</h3><blockquote><p>设 <span class="math inline">\(F\subset\mathbf{R}^n\)</span> 为闭集, <span class="math inline">\(r&gt;0\)</span>, 证明点集: <span class="math display">\[E=\{t\in\mathbf{R^n}:~\exists~x\in F,~\vert t-x\vert =r\}\]</span> 是闭集.</p></blockquote><p><strong>证明</strong>: <span class="math inline">\(\forall~t\in E&#39;\)</span>, <span class="math inline">\(\exists~\{t_n\}_{n=1}^{+\infty}\subset E\)</span>, s.t. <span class="math inline">\(\lim\limits_{n\to\infty}t_n=t\)</span>, 由 <span class="math inline">\(E\)</span> 的定义: <span class="math inline">\(\forall~n\)</span>, <span class="math inline">\(\exists~x_n\in F\)</span>, s.t. <span class="math inline">\(\vert t_n-x_n\vert =r\)</span>. 由于 <span class="math inline">\(\{t_n\}\)</span> 是收敛子列, 故 <span class="math inline">\(\{t_n\}\)</span> 有界, 于是 <span class="math inline">\(\{x_n\}\)</span> 也是有界数列, 故 <span class="math inline">\(\{x_n\}\)</span> 有收敛子列, 不妨设为 <span class="math inline">\(\{x_{n_k}\}\)</span>. 取 <span class="math inline">\(x=\lim\limits_{k\to\infty}x_{n_k}\)</span>, 则有 <span class="math inline">\(\vert t-x\vert =r\)</span>, 并且 <span class="math inline">\(x\in F\)</span>（由 <span class="math inline">\(F\)</span> 是闭集可知）, 即 <span class="math inline">\(t\in E\)</span>. 即 <span class="math inline">\(E\)</span> 是闭集.</p><h2 id="年03月15日">2017年03月15日</h2><h3 id="习题1-第一组-25">习题1 第一组 25</h3><blockquote><p>设 <span class="math inline">\(f:\mathbf{R}\to\mathbf{R}\)</span>, 令$G_1= \{ (x,y):~y&lt;f(x) \} $, $G_2= \{ (x,y):~y&gt;f(x) \} $, 试证明 <span class="math inline">\(f\in C(\mathbf{R})\)</span> 当且仅当 <span class="math inline">\(G_1\)</span> 与 <span class="math inline">\(G_2\)</span> 是开集.</p></blockquote><p><strong>证明</strong>: <strong>必要性</strong>是显然的, 以下证明<strong>充分性</strong>:</p><p>假设 <span class="math inline">\(f\notin C(\mathbf{R})\)</span>, 则 <span class="math inline">\(\exists~x_0\in\mathbf{R}\)</span>, <span class="math inline">\(\epsilon&gt;0\)</span>, 和 <span class="math inline">\(x_n\)</span>, 满足 <span class="math inline">\(\vert x_n-x_0\vert &lt;\frac{1}{n}\)</span>, 但 <span class="math inline">\(\vert f(x_n)-f(x_0)\vert \geqslant\epsilon\)</span>. 不妨设 <span class="math inline">\(f(x_n)\geqslant f(x_0)+\epsilon\)</span>, 则 <span class="math inline">\((x_n,f(x_0)+\epsilon)\in G_2^c\)</span>. 由于满足条件的 <span class="math inline">\(x_n\)</span> 构成数列 <span class="math inline">\(\{x_n\}\)</span> 且满足 <span class="math inline">\(\lim\limits_{n\to\infty}x_n=x_0\)</span>, 故 <span class="math inline">\(\lim\limits_{n\to\infty}(x_n,f(x_0)+\epsilon)=(x_0,f(x_0)+\epsilon)\)</span>, 又由 <span class="math inline">\(G_2\)</span> 为开集可知 <span class="math inline">\(G_2^c\)</span> 为闭集. 即有 <span class="math inline">\((x_0,f(x_0)+\epsilon)\in G_2^c\)</span>. 故 <span class="math inline">\(f(x_0)\geqslant f(x_0)+\epsilon\)</span>, 矛盾. 故 <span class="math inline">\(f\in C(\mathbf{R})\)</span>.</p><p><strong>综上</strong>, <span class="math inline">\(f\in C(\mathbf{R})\Longleftrightarrow G_1,~G_2\)</span> 为开集.</p><h3 id="证明完全集是不可数集">证明完全集是不可数集</h3><p>这个题目完全是在做周《实变函数论》1.5 的 思考题1 时相到的, <span class="math inline">\(n=2\)</span> 的情况可以参考周《实变函数论》1.5 的 例23.</p><blockquote><p>已知 <span class="math inline">\(E\subset\mathbf{R}^n\)</span> 为完全集, 证明 <span class="math inline">\(E\)</span> 不可数.</p></blockquote><p><strong>证明</strong>: 假设 <span class="math inline">\(E\)</span> 是可数集, 令 <span class="math inline">\(E=\{x_1,x_2,\cdots,x_n\}\)</span>. 则可如下构造一个开球列 <span class="math inline">\(\{B_n\}\)</span>:</p><ol type="1"><li>取 <span class="math inline">\(B_1=B(x_1,r_1)\subset E\)</span>, 则 <span class="math inline">\(\exists~x_{k_1}\in E\)</span>, s.t. <span class="math inline">\(x_{k_1}\in B_1\)</span>, 但 <span class="math inline">\(\forall~i\)</span>, s.t. <span class="math inline">\(2\leqslant i\leqslant k_1-1\)</span>, 均有 <span class="math inline">\(x_i\notin E\)</span>;</li><li>取 <span class="math inline">\(B_1=B(x_{k_1},r_2)\)</span>, s.t. <span class="math inline">\(B_2\subset B_1\)</span>, 且 <span class="math inline">\(r_2&lt;\frac{r_1}{2}\)</span>, 则 <span class="math inline">\(\exists~x_{k_2}\in E~(k_2&gt;k_1)\)</span>, s.t. <span class="math inline">\(x_{k_2}\in B_2\)</span>, 但 <span class="math inline">\(\forall~i\)</span>, s.t. <span class="math inline">\(k_1+1\leqslant i\leqslant k_2-1\)</span>, 均有 <span class="math inline">\(x_i\notin E\)</span>;</li><li><span class="math inline">\(\cdots\cdots\)</span></li><li>取 <span class="math inline">\(B_n=B(x_{k_{n-1} },r_n)\)</span>, s.t. <span class="math inline">\(B_n\subset B_{n-1}\)</span>, 且 <span class="math inline">\(r_n&lt;\frac{r_{n-1} }{2}\)</span>, 则 <span class="math inline">\(\exists~x_{k_n}\in E~(k_n&gt;k_{n-1})\)</span>, s.t. <span class="math inline">\(x_{k_n}\in B_n\)</span>, 但 <span class="math inline">\(\forall~i\)</span>, s.t. <span class="math inline">\(k_{n-1}+1\leqslant i\leqslant k_n-1\)</span>, 均有 <span class="math inline">\(x_i\notin E\)</span>;</li></ol><p>考虑 <span class="math inline">\(\{B_n\}\)</span> 的闭包构成的集合列 <span class="math inline">\(\{\overline{B_n}\}\)</span>, 显然有 <span class="math inline">\(\lim\limits_{n\to\infty}\vert \overline{B_n}\vert =0\)</span>, 即 <span class="math inline">\(\{\overline{B_n}\}\)</span> 形成了一个闭集套, 令 <span class="math inline">\(\bigcap\limits_{n=1}^\infty\overline{B_n}=\{a\}\)</span>.</p><p>则应有 <span class="math inline">\(a\in E\)</span>, 而由 <span class="math inline">\(\{B_n\}\)</span> 的定义可知 <span class="math inline">\(a\notin E\)</span>, 矛盾. 故 <span class="math inline">\(E\)</span> 为不可数集.</p><h3 id="习题1-第一组-26">习题1 第一组 26</h3><blockquote><p>设 <span class="math inline">\(\mathbf{R}\)</span> 中的一切开集构成的集合族为 <span class="math inline">\(\mathscr{G}\)</span>, 证明 <span class="math inline">\(\vert \mathscr{G}\vert =\aleph\)</span>. （$$ 表示 <span class="math inline">\(\mathscr{G}\)</span> 的基数）.</p></blockquote><p><strong>证明</strong>: <strong>一方面</strong>, 令 <span class="math inline">\(\mathscr{A}=\{(0,x)~\vert ~x\in\mathbf{R}\}\)</span>, 则 <span class="math inline">\(\vert \mathscr{A}\vert \subset\mathscr{G}\)</span>, 且 <span class="math inline">\(\vert \mathscr{A}\vert =\aleph\)</span>. 故 <span class="math inline">\(\vert \mathscr{G}\vert \geqslant\aleph\)</span>.</p><p><strong>另一方面</strong>, 设 <span class="math inline">\(E\)</span> 为 <span class="math inline">\(\mathbf{R}\)</span> 中以有理数为端点的开区间的全体, 则由 <span class="math inline">\(E\subset\mathbf{Q}^2\)</span> 可知 <span class="math inline">\(E\)</span> 为可数集, 于是有 <span class="math inline">\(\vert \mathscr{P}(E)\vert =\aleph\)</span>.</p><p>由于 <span class="math inline">\(\mathbf{R}\)</span> 中的每个开区间都可以表示为可数个有理开区间的并, 故对于 <span class="math inline">\(G\in\mathscr{G}\)</span>, 设 <span class="math inline">\(G=\bigcup\limits_{n=1}^\infty(\alpha_n,\beta_n)\)</span>, 其中 <span class="math inline">\((\alpha_n,\beta_n)\in E\)</span>. 据此可构造如下映射:</p><p><span class="math display">\[\varphi:~\mathscr{P}(E)\longrightarrow\mathscr{G},\quad\{(\alpha_n,\beta_n)\}_{n=1}^{+\infty}\longmapsto G~.\]</span></p><p>由于数列的极限唯一, 故 <span class="math inline">\(\varphi\)</span> 是良好定义的, 又由于 <span class="math inline">\(G\)</span> 的逼近方法不唯一, <span class="math inline">\(\overline{\mathbf{Q} }=\mathbf{R}\)</span>, 故 <span class="math inline">\(\varphi\)</span> 为满射但不为单射. 故 <span class="math inline">\(\vert \mathscr{G}\vert \leqslant\vert \mathscr{P}(E)\vert =\aleph\)</span>.</p><p><strong>综上</strong>, <span class="math inline">\(\vert \mathscr{G}\vert =\aleph\)</span>.</p><h2 id="年03月27日">2017年03月27日</h2><h3 id="思考题-2-ii">2.1 思考题 2 (ii)</h3><blockquote><p>设 <span class="math inline">\(A,B,C\)</span> 是 <span class="math inline">\(\mathbf{R}^n\)</span> 中的点集, 且有 <span class="math display">\[m^*(A\triangle B)=m^*(B\triangle C)=0\]</span> 求证 <span class="math inline">\(m^*(A\triangle C)=0\)</span>.</p></blockquote><p><strong>证明</strong>: 注意到 <span class="math display">\[A\backslash C=(A\cap C^c)\cap(B\cup B^c)=[A\cap (B\backslash C)]\cup[C^c\cap(A\backslash B)]\]</span> 又由条件有 <span class="math display">\[m^*(A\backslash B)=m^*(B\backslash A)=m^*(B\backslash C)=m^*(C\backslash B)=0\]</span> 可以很容易地得到 <span class="math inline">\(m^*(A\backslash C)=0\)</span>, 类似可得 <span class="math inline">\(m^*(C\backslash A)=0\)</span>, 故 <span class="math inline">\(m^*(A\triangle C)=0\)</span>.</p><h3 id="思考题-3">2.1 思考题 3</h3><blockquote><p>设 <span class="math inline">\(E\subset\mathbf{R}^n\)</span>, 若对于 <span class="math inline">\(\forall~x\in E\)</span>, 总存在开球 <span class="math inline">\(B(x,\delta_x)\)</span>, 使得 <span class="math inline">\(m^*(E\cap B(x,\delta_x))=0\)</span>, 试证明 <span class="math inline">\(m^*(E)=0\)</span>.</p></blockquote><p><strong>证明</strong>: 有条件, 存在一个开球族 <span class="math inline">\(\mathscr{B}\)</span>, s.t. <span class="math inline">\(x\in E\)</span>, 并且 <span class="math inline">\(E=\bigcup\limits_{B_x\in\mathscr{B} }(E\cap B_x)\)</span>. 可以取适当的 <span class="math inline">\(\delta_x\)</span>, 使得 <span class="math inline">\(B\)</span> 中的开球两两不相交, 此时 <span class="math inline">\(\mathscr{B}\)</span> 为 <span class="math inline">\(\mathbf{R}^n\)</span> 中互不相交的开集族, 即 <span class="math inline">\(\mathscr{B}\)</span> 至多可数, 且 <span class="math inline">\(\forall~B_x\in\mathscr{B}\)</span>, 总有 <span class="math inline">\(m^*(B_x\cap E)=0\)</span>.</p><p>故由测度的 <span class="math inline">\(\sigma\)</span>-可加性, <span class="math inline">\(m^*(E)=\sum\limits_{B_x\in\mathscr{B} }m^*(E\cap B_x)=0\)</span>.</p><p><strong>这个证法是错误的……以后再修改</strong></p><p>(翻到一个叫 <strong>lindelof 定理</strong> 的东西……这个题目好像就是定理的直接推论.）</p><h3 id="思考题-2">2.2 思考题 2</h3><blockquote><p>设 <span class="math inline">\(\{A_n\}\)</span> 是互不相交的可测集列, <span class="math inline">\(B_n\subset A_n~(n=1,2,\cdots)\)</span>, 证明: <span class="math display">\[m^*\left(\bigcup\limits_{n=1}^\infty B_n\right)=\sum\limits_{n=1}^\infty m^*(B_n).\]</span></p></blockquote><p><strong>证明</strong>: 由于 <span class="math inline">\(m^*\left(\bigcup\limits_{n=1}^\infty B_n\right)\leqslant\sum\limits_{n=1}^\infty m^*(B_n)\)</span> 显然成立, 故只需证明 <span class="math display">\[m^*\left(\bigcup\limits_{n=1}^\infty B_n\right)\geqslant\sum\limits_{n=1}^\infty m^*(B_n).\]</span></p><p>对于有限项的 <span class="math inline">\(B_k\)</span>, 由于 <span class="math inline">\(B_k\)</span> 两两不交, 由外测度的定义有 <span class="math display">\[\sum\limits_{k=1}^n m^*(B_k)=m^*\left(\bigcup\limits_{k=1}^n B_k\right).\]</span></p><p>显然 <span class="math inline">\(m^*\left(\bigcup\limits_{k=1}^n B_k\right)\)</span> 对于 <span class="math inline">\(n\)</span> 显然是递增集合列, 故对上式取极限可得:</p><p><span class="math display">\[\sum\limits_{k=1}^n m^*(B_k)=m^*\left(\bigcup\limits_{k=1}^n B_k\right)\leqslant m^*\left(\bigcup\limits_{k=1}^\infty B_k\right).\]</span></p><p>即有 <span class="math inline">\(\forall~n\in\mathbf{N}\)</span>, 均有 <span class="math display">\[\sum\limits_{k=1}^n m^*(B_k)\leqslant m^*\left(\bigcup\limits_{k=1}^\infty B_k\right),\]</span></p><p>对上式左侧也取极限, 有 <span class="math display">\[\sum\limits_{k=1}^\infty m^*(B_k)\leqslant m^*\left(\bigcup\limits_{k=1}^\infty B_k\right).\]</span> 即结论成立.</p><h3 id="思考题-3-1">2.2 思考题 3</h3><blockquote><p>设有点集 <span class="math inline">\(E_1,E_2\)</span>, 且 <span class="math inline">\(E_1\in\mathscr{M}\)</span>. 若 <span class="math inline">\(m(E_1\triangle E_2)=0\)</span>, 求证 <span class="math inline">\(E_2\in\mathscr{M}\)</span>, 且 <span class="math inline">\(m(E_1)=m(E_2)\)</span>.</p></blockquote><p><strong>证明</strong>: 考虑 <span class="math inline">\(E_2=[E_1\backslash(E_1\backslash E_2)]\cup(E_2\backslash E_1)\)</span>, 则易得结论.</p><h2 id="年04月20日">2017年04月20日</h2><h3 id="思考题-4">2.2 思考题 4</h3><blockquote><p>设点集 <span class="math inline">\(B\)</span> 满足: 对于 <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, <span class="math inline">\(\exists~A\in\mathscr{M}\)</span>, s.t. <span class="math inline">\(m^*(A\triangle B)&lt;\epsilon\)</span>, 试证明 <span class="math inline">\(B\)</span> 是可测集.</p></blockquote><p><strong>证明</strong>: 由条件, <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, <span class="math inline">\(\exists~\{A_k\}_{k=1}^{+\infty}\subset\mathscr{M}\)</span>, s.t. <span class="math inline">\(m^*(B\triangle A_k)&lt;\frac{\epsilon}{2^k}\)</span>, (<span class="math inline">\(k\in\mathbf{N})\)</span>.</p><p>故 <span class="math inline">\(m^*(B\backslash A_k)&lt;\frac{\epsilon}{2^k}\)</span>, 且 <span class="math inline">\(m^*(A_k\backslash B)&lt;\frac{\epsilon}{2^k}\)</span>.</p><p>令 <span class="math inline">\(A=\bigcup\limits_{k=1}^{\infty}A_k\)</span>, 则由任意 <span class="math inline">\(A_k\)</span> 均为可测集可知, <span class="math inline">\(A\)</span> 为可测集.</p><p>又有 <span class="math inline">\(B\backslash A=\bigcap\limits_{k=1}^{\infty}(B\backslash A_k)\)</span>, <span class="math inline">\(A\backslash B=\bigcap\limits_{k=1}^{\infty}(A_k\backslash B)\)</span>, 故 <span class="math inline">\(m^*(B\backslash A)\leqslant m^*(B\backslash A_k)\)</span>, 且 <span class="math inline">\(m^*(A\backslash B) \leqslant\sum\limits_{k=1}^{\infty}m^*(A_k\backslash B)\)</span>.</p><p>故 <span class="math inline">\(m^*(B\backslash A)\leqslant\frac{\epsilon}{2^k}\)</span>, <span class="math inline">\(m^*(A\backslash B)\leqslant\sum\limits_{k=1}^{\infty}\frac{\epsilon}{2^k}=\epsilon\)</span>, 即 <span class="math inline">\(m^*(A\backslash B)=m^*(B\backslash A)=0\)</span>.</p><p>于是 <span class="math inline">\(A\backslash B\)</span> 和 <span class="math inline">\(B\backslash A\)</span> 可测. 故由 <span class="math inline">\(B=(B\backslash A)\cup(A\backslash(A\backslash B))\)</span>, 故 <span class="math inline">\(B\)</span> 为可测集.</p><h3 id="思考题-8">2.2 思考题 8</h3><blockquote><p>设有 <span class="math inline">\(\mathbf{R}^1\)</span> 中可测集列 <span class="math inline">\(\{E_k\}\)</span>, 且当 <span class="math inline">\(k\geqslant k_0\)</span> 时, <span class="math inline">\(E_k\subset[a,b]\)</span>. 若存在 <span class="math inline">\(\lim\limits_{k\to\infty}E_k=E\)</span>, 试证明: <span class="math inline">\(m(E)=\lim\limits_{k\to\infty}m(E_k)\)</span>.</p></blockquote><p><strong>证明</strong>: <strong>一方面</strong>, 由于 <span class="math inline">\(\varlimsup\limits_{k\to\infty}E_k=\bigcap\limits_{j=1}^{\infty}\bigcup\limits_{k=j}^{\infty}E_k=\lim\limits_{k\to\infty}(\bigcup\limits_{j=k}^{\infty}E_j)\)</span>.</p><p>故 <span class="math inline">\(m\left(\varlimsup\limits_{k\to\infty}E_k\right)=m\left(\lim\limits_{k\to\infty}(\bigcup\limits_{j=k}^{\infty}E_j)\right)\geqslant\varlimsup\limits_{k\to\infty}m(E_k)\)</span>.</p><p>又由于 <span class="math inline">\(\{E_k\}\)</span> 收敛, 故有:</p><p><span class="math display">\[m(E)=m(\lim\limits_{k\to\infty}E_k)=m(\varlimsup\limits_{k\to\infty}E_k)\geqslant\varlimsup\limits_{k\to\infty}m(E_k)\geqslant\lim\limits_{k\to\infty}m(E_k).\]</span></p><p>即 <span class="math inline">\(m(E)\geqslant\lim\limits_{k\to\infty}m(E_k)\)</span>.</p><p><strong>另一方面</strong>, <span class="math inline">\(\varliminf\limits_{k\to\infty}E_k=\bigcup\limits_{j=1}^{\infty}\bigcap\limits_{k=j}^{\infty}E_k=\lim\limits_{k\to\infty}(\bigcup\limits_{j=k}^{\infty}E_j)\)</span>.</p><p>故 <span class="math inline">\(m\left(\varliminf\limits_{k\to\infty}E_k\right)=m\left(\lim\limits_{k\to\infty}(\bigcap\limits_{j=k}^{\infty}E_j)\right)\leqslant\varliminf\limits_{k\to\infty}m(E_k)\)</span>.</p><p>故 <span class="math inline">\(m(E)\leqslant\varliminf\limits_{k\to\infty}m(E_k)\leqslant\lim\limits_{k\to\infty}m(E_k)\)</span>.</p><p><strong>综上所述</strong>, <span class="math inline">\(m(E)=\lim\limits_{k\to\infty}m(E_k)\)</span>.</p><h2 id="年04月24日">2017年04月24日</h2><h3 id="习题2-第一组-8">习题2 第一组 8</h3><blockquote><p>设 <span class="math inline">\(\{E_k\}\)</span> 是 <span class="math inline">\([0,1]\)</span> 中的可测集列, <span class="math inline">\(m(E_k)=1\)</span>, <span class="math inline">\((k=0,1,\cdots)\)</span>, 试证明: <span class="math inline">\(m\left(\bigcap\limits_{k=1}^{\infty}E_k\right)=1\)</span>.</p></blockquote><p><strong>证明</strong>: 由于 <span class="math inline">\(\{E_k\}\)</span> 可测, 且 <span class="math inline">\(m(E_k)=1\)</span>, <span class="math inline">\(\forall~k\in\mathbf{N}_+\)</span>, 又 <span class="math inline">\(E_k\subset[0,1]\)</span>, 故 <span class="math inline">\(m([0,1]\backslash E_k)=0\)</span>, <span class="math inline">\(\forall~k\in\mathbf{N}_+\)</span>.</p><p>于是 <span class="math display">\[m\left(\bigcap\limits_{k=1}^{\infty}E_k\right)=1-\left([0,1]\backslash\bigcap\limits_{k=1}^{\infty}E_k\right)=1-\left(\bigcup\limits_{k=1}^{\infty}([0,1]\backslash E_k)\right)=1-\sum\limits_{k=1}^{\infty}m([0,1]\backslash E_k)=1.\]</span></p><p>又由于 <span class="math inline">\(m(\bigcap\limits_{k=1}^{\infty}E_k)\leqslant m(E_1)=1\)</span>, 故 <span class="math inline">\(m\left(\bigcap\limits_{k=1}^{\infty}E_k\right)=1\)</span>.</p><h3 id="习题2-第一组-11">习题2 第一组 11</h3><blockquote><p>设 <span class="math inline">\(\{B_\alpha\}_{\alpha\in I}\)</span> 是 <span class="math inline">\(\mathbf{R}^n\)</span> 中一族开球, 记 <span class="math inline">\(G=\bigcup\limits_{\alpha\in I}B_\alpha\)</span>. 若有 <span class="math inline">\(0&lt;\lambda&lt;m(G)\)</span>, 试证明存在有限个互不相交的开球 <span class="math inline">\(B_{\alpha_1},B_{\alpha_2},\cdots,B_{\alpha_m}\)</span>, 使得 <span class="math inline">\(\sum\limits_{k=1}^m m(B_{\alpha_k})\)</span> 大于 <span class="math inline">\(\frac{\lambda}{3^n}.\)</span></p></blockquote><p><strong>证明</strong>: 取紧集 <span class="math inline">\(K\subset G\)</span>, s.t. <span class="math inline">\(m(K)&gt;\lambda\)</span>, 则 <span class="math inline">\(\{B_\alpha\}\)</span> 构成 <span class="math inline">\(K\)</span> 的一个开覆盖. 于是存在有限子覆盖 <span class="math inline">\(B_1,B_2\cdots,B_k\)</span>.</p><p>取其中半径最大者为 <span class="math inline">\(B_{\alpha_1}\)</span>, 则将 <span class="math inline">\(B_{\alpha_1}\)</span> 的半径扩大三倍即可将 <span class="math inline">\(B_i\)</span> 中所有与 <span class="math inline">\(B_{\alpha_1}\)</span> 相交的开球全部覆盖;</p><p>再取 <span class="math inline">\(B_i\)</span> 中与 <span class="math inline">\(B_{\alpha_1}\)</span> 不相交的球中半径最大者为 <span class="math inline">\(B_{\alpha_2}\)</span>, 则将其半径扩大三倍即可将与其相交的开球全部覆盖.</p><p>如此继续下去可以选出有限个开球 <span class="math inline">\(B_{\alpha_1},B_{\alpha_2}\cdots,B_{\alpha_m}\)</span>, s.t. 将其中的每一个球半径扩大三倍可以构成 <span class="math inline">\(K\)</span> 的覆盖.</p><p>于是 <span class="math inline">\(\sum\limits_{i=1}^m 3^n\times m(B_{\alpha_i})&gt;\lambda\)</span>, 即 <span class="math inline">\(\sum\limits_{k=1}^m m(B_{\alpha_k})&gt;\frac{\lambda}{3^n}\)</span>, 原命题得证.</p><h2 id="年04月25日">2017年04月25日</h2><h3 id="习题2-第一组-12">习题2 第一组 12</h3><blockquote><p>设 <span class="math inline">\(\{B_k\}\)</span> 是 <span class="math inline">\(\mathbf{R}^n\)</span> 中递减可测集列, <span class="math inline">\(m^*(A)&lt;\infty\)</span>. 令 <span class="math inline">\(E_k=A\cap B_k~(k=0,1,\cdots)\)</span>, <span class="math inline">\(E=\bigcap\limits_{k=1}^\infty E_k\)</span>, 试证明 <span class="math display">\[\lim\limits_{k\to\infty}m^*(E_k)=m^*(E).\]</span></p></blockquote><p><strong>证明</strong>: 令 <span class="math inline">\(A\)</span> 的等测包为 <span class="math inline">\(H\)</span>, 则 <span class="math inline">\(\{B_k\cap H\}\)</span> 为递减可测集列.</p><p>于是 <span class="math inline">\(\lim\limits_{k\to\infty} m(H\cap B_k)=m\left(\lim\limits_{k\to\infty}(H\cap B_k)\right)=m\left((\bigcap\limits_{k=1}^\infty B_k)\cap H\right)\)</span>.</p><p>而对于 <span class="math inline">\(\forall~k\)</span>, <span class="math inline">\(m(H\cap B_k)-m\left(\bigcap\limits_{k=1}^\infty(H\cap B_k)\cap H\right)=m\left((H\cap B_k)\backslash\bigcap\limits_{k=1}^\infty(H\cap B_k)\right)\)</span>.</p><p>又由于 <span class="math inline">\(H\)</span> 和 <span class="math inline">\(B_k\)</span> 均为可测集, 故 <span class="math inline">\(m\left((H\cap B_k)\backslash\bigcap\limits_{k=1}^\infty(H\cap B_k)\right)=m^*\left((H\cap B_k)\backslash\bigcap\limits_{k=1}^\infty(H\cap B_k)\right)\)</span>.</p><p>即 <span class="math inline">\(m(H\cap B_k)-m\left(\bigcap\limits_{k=1}^\infty(H\cap B_k)\right)=m^*\left((H\cap B_k)\backslash\bigcap\limits_{k=1}^\infty(H\cap B_k)\right)\)</span>.</p><p>由于 <span class="math inline">\(A\subset H\)</span>, 故 <span class="math display">\[\begin{align}m(H\cap B_k)-m\left(\bigcap\limits_{k=1}^\infty(H\cap B_k)\right) &amp;\geqslant m^*\left(A\cap (B_k\backslash\bigcap\limits_{k=1}^{\infty}B_k)\right) \\ &amp;= m^*\left((A\cap B_k) \backslash \bigcap\limits_{k=1}^{\infty}(A\cap B_k)\right) \\ &amp;= m^*(E_k\backslash\bigcap\limits_{k=1}^{\infty} E_k) = m^*(E_k\backslash E) \\ &amp;\geqslant m^*(E_k)-m^*(E).\end{align}\]</span></p><p>由于 <span class="math inline">\(E_k\)</span> 递减, 故 <span class="math inline">\(m^*(E_k)\geqslant m^*(E)\)</span>, <span class="math inline">\(\forall~k\in\mathbf{N}_+\)</span>, 即 <span class="math inline">\(m^*(E_k)-m^*(E)\geqslant 0\)</span>.</p><p>又由于 <span class="math inline">\(\lim\limits_{k\to\infty}\left(m(H\cap B _k)-m(\bigcap\limits_{k=1}^{\infty}(H\cap B_k)\right)=0\)</span>.</p><p>故 <span class="math inline">\(\lim\limits_{k\to\infty}m^*(E_k)-m^*(E)=0\)</span>, 即 <span class="math inline">\(\lim\limits_{k\to\infty}m^*(E_k)=m^*(E)\)</span>.</p><h2 id="年04月26日">2017年04月26日</h2><h3 id="习题2-第一组-14">习题2 第一组 14</h3><blockquote><p>试证明点集 <span class="math inline">\(E\)</span>　可测的充要条件是: 对任意 <span class="math inline">\(\epsilon&gt;0\)</span>, 存在开集 <span class="math inline">\(G_1,G_2\)</span>: <span class="math display">\[G_1\supset E,\quad G_2\supset E^c,\]</span> 使得 <span class="math inline">\(m(G_1\cap G_2)&lt;\epsilon\)</span>.</p></blockquote><p><strong>证明</strong>: <strong>必要性</strong>: 由于 <span class="math inline">\(E\)</span> 为可测集, 故:</p><ol type="1"><li>存在开集 <span class="math inline">\(G\supset E\)</span>, s.t. <span class="math inline">\(m(G)-m(E)&lt;\frac{\epsilon}{2}\)</span>.</li><li>存在闭集 <span class="math inline">\(F\subset E\)</span>, s.t. <span class="math inline">\(m(E)-m(F)&lt;\frac{\epsilon}{2}\)</span>.</li></ol><p>取 <span class="math inline">\(G_1=G\)</span>, <span class="math inline">\(G_2=F^c\)</span>, 则 <span class="math inline">\(m^*(G_1\cap G_2)=m(G\backslash F)=m(G)-m(F)&lt;\epsilon\)</span>.</p><p><strong>充分性</strong>: 取递减开集列 <span class="math inline">\(G_{1n}\)</span> 和 <span class="math inline">\(G_{2n}\)</span>, s.t. <span class="math inline">\(\forall~n\)</span>, 有 <span class="math inline">\(E\subset G_{1n}\)</span>, <span class="math inline">\(E^c\subset G_{2n}\)</span> 且 <span class="math inline">\(m(G_{1n}-G_{2n})&lt;\frac{1}{n}\)</span>.</p><p>则取 <span class="math inline">\(G=\lim\limits_{n\to\infty} G_{1n}\)</span>, 即可使得 <span class="math inline">\(G\)</span> 为可测集, 且 <span class="math inline">\(m^*(G\backslash E)\leqslant m^*(G_{1n}\cap G_{2n})\)</span>. 取极限, 即有 <span class="math inline">\(m^*(G\backslash E)=0\)</span>.</p><p>于是 <span class="math inline">\(G\backslash E\)</span> 为零测集, 即 <span class="math inline">\(E\)</span> 可测.</p><h3 id="习题2-第一组-15">习题2 第一组 15</h3><blockquote><p>设 <span class="math inline">\(E\subset[0,1]\)</span> 是可测集且有 <span class="math display">\[m(E)\geqslant\epsilon &gt;0,\quad x_i\in[0,1],~i=1,2,\cdots,n,\]</span> 其中 <span class="math inline">\(n&gt;\frac{2}{\epsilon}\)</span>. 试证明 <span class="math inline">\(E\)</span> 中存在两个点, 其距离等于 <span class="math inline">\(\{x_1,x_2,\cdots,x_n\}\)</span> 中某两个点的距离.</p></blockquote><p><strong>证明</strong>: 由于 <span class="math inline">\(\forall~i\in\mathbf{N}\)</span>, s.t. <span class="math inline">\(1\leqslant i\leqslant n\)</span>, 总有 <span class="math inline">\(x_i\in[0,1]\)</span>. 于是 <span class="math inline">\(E+\{x_i\}\subset[0,2]\)</span>, <span class="math inline">\(\forall~i\)</span>.</p><p>故 <span class="math inline">\(\bigcup\limits_{i=1}^n (E+\{x_i\})\subset[0,2]\)</span>, 故 <span class="math inline">\(m\left(\bigcup\limits_{i=1}^n (E+\{x_i\})\right)\leqslant 2\)</span>.</p><p>由于 <span class="math inline">\(n&gt;\frac{2}{\epsilon}\)</span>, 故 <span class="math inline">\(\exists~i\neq j\)</span>, s.t. <span class="math inline">\((E+\{x_i\})\cap(E+\{x_j\})\neq\varnothing\)</span>. （否则 <span class="math inline">\(\sum\limits_{i=1}^n m(E+\{x_i\})\leqslant 2\)</span>, 即 <span class="math inline">\(n\leqslant\frac{\epsilon}{2}\)</span>, 矛盾.） 原命题得证.</p><h2 id="年05月11日">2017年05月11日</h2><h3 id="思考题-3-2">3.2 思考题 3</h3><blockquote><p>设 <span class="math inline">\(\{f_k(x)\}\)</span> 在 <span class="math inline">\(E\)</span>上依测度收敛于零, <span class="math inline">\(g(x)\)</span> 是 <span class="math inline">\(E\)</span> 上实值可测函数. 若 <span class="math inline">\(m(E)=+\infty\)</span>, 试说明 <span class="math inline">\(\{g(x)f_k(x)\}\)</span> 在 <span class="math inline">\(E\)</span> 上不一定依测度收敛于零.</p></blockquote><p><strong>证明</strong>: 取 <span class="math inline">\(g(x)=x,~f_k(x)=\frac{1}{k}\)</span> 即可.</p><h3 id="习题3-第一组-4">习题3 第一组 4</h3><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 是 <span class="math inline">\(E\subset\mathbf{R}^n\)</span> 上几乎处处有限的可测函数, <span class="math inline">\(m(E)&lt;\infty\)</span>, 试证明对于 <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, 存在 <span class="math inline">\(E\)</span> 上的有界可测函数 <span class="math inline">\(g(x)\)</span>, s.t. <span class="math inline">\(m(\{x\in E:\vert f(x)-g(x)\vert &gt;0\})&lt;\epsilon\)</span>.</p></blockquote><p><strong>证明</strong>: 令 <span class="math inline">\(E_\infty=\{x\in E:\vert f(x)\vert =\infty\}\)</span>, <span class="math inline">\(E_n=\{x\in E:\vert f(x)\vert \geqslant n\}\)</span>, <span class="math inline">\(n=1,2,\cdots\)</span>, 则 <span class="math inline">\(E\supset E_1\supset E_2\supset\cdots\)</span>, <span class="math inline">\(E_\infty=\bigcap\limits_{n=1}^\infty E_n\)</span>. 又由于 <span class="math inline">\(f(x)\)</span> 几乎处处有限, 故 <span class="math inline">\(\lim\limits_{n\to\infty}m(E_n)=m(\lim\limits_{n\to\infty}E_n)=0\)</span>. 故 <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, <span class="math inline">\(\exists~N\)</span>, s.t. <span class="math inline">\(m(E_N)=m(\{x\in E:\vert f(x)\vert \geqslant N\})&lt;\epsilon\)</span>, 故可以取函数 <span class="math display">\[g(x)=   \begin{cases}   f(x), &amp; x\in E\backslash E_N \\   0, &amp; x\in E_N   \end{cases}\]</span> 则 <span class="math inline">\(g(x)\)</span> 有界可测, 并且 <span class="math inline">\(m(\{x\in E:\vert f(x)-g(x)\vert &gt;0\})\leqslant m(E_N)&lt;\epsilon\)</span>.</p><h3 id="习题3-第一组-5">习题3 第一组 5</h3><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 及 <span class="math inline">\(f_n(x)~(n=1,2,\cdots)\)</span> 都是 <span class="math inline">\(A\subset\mathbf{R}^1\)</span> 上几乎处处有限的可测函数. 若对于 <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, 存在 <span class="math inline">\(A\)</span> 的可测子集 <span class="math inline">\(B:m(A\backslash B)&lt;\epsilon\)</span>, s.t. <span class="math inline">\(f_n(x)\)</span> 在 <span class="math inline">\(B\)</span> 上一致收敛于 <span class="math inline">\(f(x)\)</span>, 试证明 <span class="math inline">\(f_n(x)\)</span> 在 <span class="math inline">\(A\)</span> 上几乎处处收敛于 <span class="math inline">\(f(x)\)</span>.</p></blockquote><p><strong>证明</strong>: 由条件, 对于 <span class="math inline">\(\epsilon_m=\frac{1}{2^m}\)</span>, 存在 <span class="math inline">\(A\)</span> 的可测子集 <span class="math inline">\(B_m\)</span>, s.t. <span class="math inline">\(m(A\backslash B_m)&lt;\epsilon_m\)</span>, 且 <span class="math inline">\(f_n(x)\)</span> 在 <span class="math inline">\(B_m\)</span> 上一致收敛于 <span class="math inline">\(f(x)\)</span>. 令 <span class="math inline">\(B=\bigcap\limits_{j=1}^\infty\bigcup\limits_{m=j}^\infty(A\backslash B_m)\)</span>, 由于 <span class="math display">\[m(B)\leqslant m(\bigcup\limits_{m=j}^\infty(A\backslash B_m))\leqslant\sum\limits_{m=j}^\infty m(A\backslash B_m)&lt;\sum\limits_{m=j}^\infty\frac{1}{2^m},\quad\forall~j.\]</span> 故 <span class="math inline">\(m(B)=0\)</span>. 故 <span class="math inline">\(\forall~x\in A\backslash B=\bigcap\limits_{j=1}^\infty\bigcup\limits_{m=j}^\infty B_m\)</span>, <span class="math inline">\(\exists~j_0\)</span>, s.t. <span class="math inline">\(x\in\bigcap\limits_{m=j_0}^\infty B_m\)</span>, 由于 <span class="math inline">\(f_n\)</span> 在 <span class="math inline">\(B_m\)</span> 上一致收敛, 故在 <span class="math inline">\(x\)</span> 处应收敛. 由于 <span class="math inline">\(m(B)=0\)</span>, 故 <span class="math inline">\(f_n\)</span> 在 <span class="math inline">\(A\)</span> 上几乎处处收敛于 <span class="math inline">\(f\)</span>.</p><h3 id="习题3-第一组-6">习题3 第一组 6</h3><blockquote><p>设 <span class="math inline">\(\{f_k(x)\}\)</span> 是 <span class="math inline">\(E\subset\mathbf{R}^n\)</span> 上的实值可测函数列, <span class="math inline">\(m(E)&lt;\infty\)</span>, 试证明 <span class="math display">\[\lim\limits_{k\to\infty}f_k(x)=0,\quad\text{a.e.}~x\in E\]</span> 的充要条件是 <span class="math display">\[\forall~\epsilon&gt;0,~\lim\limits_{k\to\infty}m(\{x\in E:\sup\limits_{k\geqslant j}\{\vert  f_k(x)\vert \}\geqslant\epsilon\})=0.\]</span></p></blockquote><p><strong>证明</strong>: 记 <span class="math inline">\(I=\{x\in E:f_k(x)\nrightarrow0~(k\to\infty)\}\)</span>, <span class="math inline">\(I_m=\varlimsup\limits_{k\to\infty}\{\vert f_k(x)\vert \geqslant\frac{1}{m}\}\)</span>, 则 <span class="math inline">\(I=\bigcup\limits_{m=1}^\infty I_m\)</span>. <strong>充分性</strong>: 若 <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, 总有 <span class="math inline">\(\lim\limits_{j\to\infty} m\left(\{x\in E:\sup\limits_{k\geqslant}\{f_k(x)\}\geqslant\epsilon\}\right)=0\)</span>, 则 <span class="math display">\[\begin{align}m^*(I) &amp;\leqslant \sum\limits_{m=1}^\infty m(I_m) \\&amp;= \sum\limits_{m=1}^\infty m\left( \bigcap\limits_{j=1}^\infty\bigcup\limits_{k=j}^\infty\{x\in E:\vert  f_k(x)\vert \geqslant\frac{1}{m}\} \right) \\&amp;= \sum\limits_{m=1}^\infty \left( \lim\limits_{j\to\infty}m(\bigcup\limits_{k=j}^\infty \{x\in E:\vert  f_k(x)\vert \geqslant\frac{1}{m}\}) \right) \\&amp;\leqslant \sum\limits_{m=1}^\infty \lim\limits_{j\to\infty}m\left(\{x\in E:\sup\limits_{k\geqslant j}\vert  f_k(x)\vert \geqslant\frac{1}{m}\}\right) \\&amp;= 0 \\\end{align}\]</span> 即有 <span class="math inline">\(m^*(I)=0\)</span>, 故 <span class="math inline">\(\lim\limits_{k\to\infty}f_k(x)=0\)</span>, a.e. <span class="math inline">\(x\in E\)</span>. <strong>必要性</strong>: 由于 <span class="math inline">\(\lim\limits_{k\to\infty}f_k(x)=0\)</span>, a.e. <span class="math inline">\(x\in E\)</span>, 故 <span class="math inline">\(m(I)=0\)</span>. 而 <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, 总有 <span class="math display">\[\begin{align}\varlimsup\limits_{j\to\infty}m\left(\{x\in E:\sup\limits_{k\geqslant j}\vert  f_k(x)\vert \geqslant\epsilon\}\right)&amp;\geqslant \varlimsup\limits_{j\to\infty}m\left(\bigcup\limits_{k=j}^\infty \{x\in E:\vert  f_k(x)\vert \geqslant\frac{\epsilon}{2}\}\right) \\&amp;= m\left(\bigcap\limits_{j=1}^\infty \bigcup\limits_{k=j}^\infty\{x\in E:\vert  f_k(x)\vert \geqslant\frac{\epsilon}{2}\}\right) \\&amp;\leqslant m(I) \\&amp; =0 \\\end{align}\]</span> <strong>综上</strong>: <span class="math inline">\(\lim\limits_{k\to\infty}f_k(x)=0,~\text{a.e.}~x\in E\Longleftrightarrow\forall~\epsilon&gt;0,~\lim\limits_{k\to\infty}m(\{x\in E:\sup\limits_{k\geqslant j}\{\vert f_k(x)\vert \}\geqslant\epsilon\})=0\)</span>.</p><h3 id="习题3-第一组-7">习题3 第一组 7</h3><blockquote><p>设 <span class="math inline">\(f(x),f_1(x),f_2(x),\cdots\)</span> 是 <span class="math inline">\([a,b]\)</span> 上几乎处处有限的可测函数, 且有 <span class="math display">\[\lim\limits_{k\to\infty}f_k(x)=f(x),\quad\text{a.e.}~x\in[a,b],\]</span> 试证明 <span class="math inline">\(\exists~E_n\subset[a,b]~(n=1,2,\cdots)\)</span>, s.t. <span class="math inline">\(m\left([a,b]\backslash\bigcup\limits_{n=1}^\infty E_n\right)=0\)</span>, 而 <span class="math inline">\(\{f_k(x)\}\)</span> 在每个 <span class="math inline">\(E_n\)</span> 上一致收敛于 <span class="math inline">\(f(x)\)</span>.</p></blockquote><p><strong>证明</strong>: 由Egorov定理, <span class="math inline">\(\forall~n\)</span>, <span class="math inline">\(\exists~E_n\subset[a,b]\)</span>, s.t. <span class="math inline">\(m([a,b]\backslash E_n)\leqslant\frac{1}{n}\)</span>, 且在 <span class="math inline">\(E_n\)</span> 上, <span class="math inline">\(f_k(x)\rightrightarrows f(x)\)</span>. 又有 <span class="math display">\[\begin{align}m\left([a,b]\backslash\bigcup\limits_{n=1}^\infty E_n\right)&amp;= m\left(\bigcap_{n=1}^\infty ([a,b]\backslash E_n)\right) \\&amp;\leqslant \lim\limits_{n\to\infty}([a,b]\backslash E_n) \\&amp;\leqslant \lim\limits_{n\to\infty}\frac{1}{n}=0.\\\end{align}\]</span> 原命题得证.</p><h2 id="年05月12日">2017年05月12日</h2><h3 id="习题4-第一组-1">习题4 第一组 1</h3><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 是 <span class="math inline">\(E\subset\mathbf{R}^n\)</span> 上几乎处处大于零的可测函数, 且满足 <span class="math inline">\(\int_Ef(x){\rm d}x=0\)</span>, 试证明 <span class="math inline">\(m(E)=0\)</span>.</p></blockquote><p><strong>证明</strong>: <strong>反证法</strong> 假设 <span class="math inline">\(m(E)&gt;0\)</span>, 记 <span class="math inline">\(E_n=\{x\in E:f(x)&gt;\frac{1}{n}\}\)</span>, 并令 <span class="math inline">\(F=\bigcup\limits_{n=1}^\infty E_n\)</span>, 则由 <span class="math inline">\(E=(E\backslash F)\cup F\)</span> 且 <span class="math inline">\(m(E\backslash F)=0\)</span> 可知, <span class="math inline">\(\exists n_0\)</span>, s.t. <span class="math inline">\(m(E_{n_0})&gt;0\)</span>. 于是有 <span class="math inline">\(0=\int_Ef(x){\rm d}x\geqslant\int_{E_{n_0} }f(x){\rm d}x\geqslant\frac{1}{n_0}m(E_{n_0})\)</span>, 得 <span class="math inline">\(m(E_{n_0})=0\)</span>, 矛盾. 于是 <span class="math inline">\(m(E)=0\)</span>.</p><h3 id="习题4-第一组-4">习题4 第一组 4</h3><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 是 <span class="math inline">\(\mathbf{R}^1\)</span> 上的非负可测函数, 令 <span class="math display">\[F(x)=\int\nolimits_{(-\infty,x] }f(t)dt,\quad x\in\mathbf{R}^1.\]</span> 若 <span class="math inline">\(F\in L(\mathbf{R}^1)\)</span>, 试证明 <span class="math inline">\(\int\nolimits_{\mathbf{R}^1}f(x)dx=0\)</span>.</p></blockquote><p><strong>证明</strong>: 由于 <span class="math inline">\(F\in L(\mathbf{R}^1)\)</span>, 故 <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, <span class="math inline">\(\exists~N\)</span> s.t. <span class="math inline">\(\int\nolimits_{\{x:\vert x\vert &gt;N\} }F(x)dx&lt;\epsilon\)</span>. 又由于 <span class="math inline">\(f(x)\geqslant0\)</span>, 故 <span class="math inline">\(F(x)\)</span> 随 <span class="math inline">\(x\)</span> 递增, 且 <span class="math inline">\(\lim\limits_{x\to\infty}F(x)=\int\nolimits_{\mathbf{R}^1}f(x)dx\)</span>. 于是 <span class="math inline">\(\forall~y&gt;N\)</span>, 均有: <span class="math display">\[F(y)=\int\nolimits_{y}^{y+1}F(y)dx\leqslant\int\nolimits_y^{y+1}F(x)dx\leqslant\int\nolimits_{\{x:\vert  x\vert &gt;N\} }F(x)dx&lt;\epsilon\]</span>, 于是 <span class="math inline">\(\lim\limits_{y\to\infty}F(y)=0\)</span>. 即 <span class="math inline">\(\int\nolimits_{\mathbf{R}^1}f(x)dx=0\)</span>.</p><h3 id="习题4-第一组-5">习题4 第一组 5</h3><blockquote><p>设 <span class="math inline">\(f_k(x)~(k=1,2,\cdots)\)</span> 是 <span class="math inline">\(\mathbf{R}^n\)</span> 上非负可积函数列, 若对于任何一可测集 <span class="math inline">\(E\subset\mathbf{R}^n\)</span>, 总有 <span class="math display">\[\int\nolimits_Ef_k(x)dx\leqslant\int\nolimits_Ef_{k+1}(x)dx,\]</span> 试证明 <span class="math display">\[\lim\limits_{k\to\infty}\int\nolimits_Ef_k(x)dx=\int\nolimits_E \lim\limits_{k\to\infty} f_k(x)dx.\]</span></p></blockquote><p><strong>证明</strong>: 取 <span class="math inline">\(E_k=\{x:f_k(x)&gt;f_{k+1}(x)\}~(k=1,2,\cdots)\)</span>, 则由条件有 <span class="math inline">\(\int\nolimits_{E_k}(f_k(x)-f_{k+1}(x))dx\leqslant0\)</span>. 又由 <span class="math inline">\(E_k\)</span> 的定义可知 <span class="math inline">\(f_k(x)-f_{k+1}(x)&gt;0\)</span>, 故 <span class="math inline">\(m(E_k)=0\)</span>, <span class="math inline">\(\forall~k\)</span>. 于是 <span class="math inline">\(m\left(\bigcup\limits_{k=1}^\infty E_k \right)=0\)</span>, 故 <span class="math inline">\(f_k(x)\)</span> 在 <span class="math inline">\(E\)</span> 上几乎处处满足Levi定理的使用条件, 故在 <span class="math inline">\(E\)</span> 上由Levi定理有 <span class="math display">\[\lim\limits_{k\to\infty}\int\nolimits_Ef_k(x)dx=\int\nolimits_E \lim\limits_{k\to\infty} f_k(x)dx.\]</span></p><h2 id="年06月07日">2017年06月07日</h2><h3 id="习题4-第一组-7">习题4 第一组 7</h3><blockquote><p>假设有定义在 <span class="math inline">\(\mathbf{R}^n\)</span> 上的函数 <span class="math inline">\(f(x)\)</span>, 如果对于 <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, <span class="math inline">\(\exists~g,h\in L(\mathbf{R}^n)\)</span>, s.t. <span class="math inline">\(g(x)\leqslant f(x)\leqslant h(x)~(x\in\mathbf{R}^n)\)</span>, 并且 <span class="math inline">\(\int\nolimits_{\mathbf{R}^n}[h(x)-g(x)]dx&lt;\epsilon\)</span>, 试证明 <span class="math inline">\(f\in L(\mathbf{R}^n).\)</span></p></blockquote><p><strong>证明</strong>: 由条件, 取可积函数列 <span class="math inline">\(g_k(x),h_k(x)\)</span>, s.t. <span class="math inline">\(g_k(x)\leqslant f(x)\leqslant h_k(x)\)</span> 且 <span class="math inline">\(\int\nolimits_{\mathbf{R}^n}[h_k(x)-g_k(x)]dx&lt;\frac{1}{k}\)</span>. 故 <span class="math inline">\(\{h_k(x)-g_k(x)\}\)</span> 为非负可积函数列. 又由于 <span class="math inline">\(\lim\limits_{k\to\infty}\int\nolimits_{\mathbf{R}^n}[h_k(x)-g_k(x)]dx=0\)</span>, 故 <span class="math inline">\(h_k(x)-g_k(x)\)</span> 依测度收敛于0. 故由Riesz定理, 存在子列 <span class="math inline">\(\{h_{k_j}-g_{k_j}\}\)</span>, s.t. <span class="math inline">\(\lim\limits_{j\to\infty}[h_{k_j}(x)-g_{k_j}(x)]=0\)</span>, a.e. <span class="math inline">\(x\in\mathbf{R}^n\)</span>. 又 $f(x){g_k(x),h_k(x)}g_k(x)+h_k(x)$. 故 <span class="math inline">\(\vert f\vert \in L(\mathbf{R}^n)\)</span>, 故 <span class="math inline">\(f\in L(\mathbf{R}^n)\)</span>.</p><h3 id="习题4-第一组-8">习题4 第一组 8</h3><blockquote><p>设 <span class="math inline">\(\{E_k\}\)</span> 是 <span class="math inline">\(\mathbf{R}^n\)</span> 中测度有限的可测集列, 且有 <span class="math display">\[\lim\limits_{k\to\infty}\int\nolimits_{\mathbf{R}^n}\vert \chi_{E_k}(x)-f(x)\vert =0,\]</span> 试证明存在可测集 <span class="math inline">\(E\)</span> s.t. <span class="math inline">\(f(x)=\chi_E(x)\)</span>, a.e. <span class="math inline">\(x\in\mathbf{R}^n\)</span>.</p></blockquote><p><strong>证明</strong>: 由条件, <span class="math inline">\(\chi_{E_k}(x)\)</span> 依 <span class="math inline">\(L^1\)</span> 范数收敛于 <span class="math inline">\(f(x)\)</span>, 故 <span class="math inline">\(\chi_{E_k}(x)\)</span> 依测度收敛于 <span class="math inline">\(f(x)\)</span>. 由Riesz定理, 存在其几乎处处收敛于 <span class="math inline">\(f(x)\)</span> 的子列 <span class="math inline">\(\chi_{E_{k_i} }(x)\)</span>. 令 <span class="math inline">\(E_{k_i}\to E\)</span>, 则应有 <span class="math inline">\(f(x)=\chi_E(x)\)</span>, a.e. <span class="math inline">\(x\in\mathbf{R}^n\)</span>.</p><h2 id="年06月20日">2017年06月20日</h2><h3 id="习题4-第一组-13">习题4 第一组 13</h3><blockquote><p>设 <span class="math inline">\(f\in L(\mathbf{R}^1),p&gt;0\)</span>, 试证明 <span class="math display">\[\lim\limits_{n\to\infty}n^{-p}f(nx)=0,\quad\text{a.e.}~x\in\mathbf{R}^1.\]</span></p></blockquote><p><strong>证明</strong>: 考虑级数 $<em>{n=1}<sup>n</sup>{-p}f(nx)$, 则 <span class="math inline">\(n^{-p}f(nx)\)</span> 为非负可测函数, 即 <span class="math display">\[\begin{align}\int\nolimits_{\mathbf{R}^1}\left(\sum\limits_{n=1}^\infty\vert  n^{-p}f(nx)\vert \right)dx&amp;= \sum\limits_{n=1}^\infty\int\nolimits_{\mathbf{R}^1}\vert  n^{-p}f(nx)\vert  dx \\&amp;= \sum\limits_{n=1}^\infty\int\nolimits_{\mathbf{R}^1}\vert  n^{-p-1}f(nx)\vert  d(nx) \\&amp;= \sum\limits_{k=1}^\infty\frac{1}{n^{p+1} }\cdot\int\nolimits_{\mathbf{R}^1}\vert  f(x)\vert  dx \\\end{align}\]</span> 由于 <span class="math inline">\(1+p&gt;1\)</span>, 故 <span class="math inline">\(\sum\limits_{k=1}^\infty\frac{1}{n^{p+1} }\)</span> 收敛, 又由于 <span class="math inline">\(\int\nolimits_{\mathbf{R}^1}\vert f(x)\vert dx\)</span> 有限, 故 <span class="math inline">\(\int\nolimits_{\mathbf{R}^1}\left(\sum\limits_{n=1}^\infty\vert n^{-p}f(nx)\vert \right)dx\)</span> 有限, 故 $</em>{n=1}<sup>n</sup>{-p}f(nx)$ 有限, 即有 <span class="math inline">\(\lim\limits_{n\to\infty}n^{-p}f(nx)=0\)</span>, a.e. <span class="math inline">\(x\in\mathbf{R}^1\)</span>.</p><h3 id="习题4-第一组-21">习题4 第一组 21</h3><blockquote><p><strong>依测度收敛的Fatou引理</strong> 设 <span class="math inline">\(\{f_k(X)\}\)</span> 是 <span class="math inline">\(E\)</span> 上依测度收敛于 <span class="math inline">\(f(x)\)</span> 的非负可测函数列, 试证明 <span class="math display">\[\int\nolimits_E f(x)dx\leqslant \varliminf\limits_{k\to\infty}\int\nolimits_E f_k(x)dx.\]</span></p></blockquote><p><strong>证明</strong>: 由Riesz定理, 存在子列 <span class="math inline">\(\{f_{k_i}(x)\}\)</span>, s.t. <span class="math inline">\(\lim\limits_{i\to\infty}f_{k_i}(x)=f(x)\)</span>, a.e. <span class="math inline">\(x\in\mathbf{R}^n\)</span>. 故由Fatou引理, 有: <span class="math display">\[\begin{align}\int\nolimits_Ef(x)dx &amp;= \int\nolimits_E \lim\limits_{i\to\infty}f_{k_i}(x)dx \\&amp;= \int\nolimits_E \varliminf\limits_{i\to\infty}f_{k_i}(x)dx \\&amp;\leqslant \varliminf\limits_{i\to\infty}\int\nolimits_{E} f_{k_i}(x)dx \\&amp;= \varliminf\limits_{k\to\infty}\int\nolimits_E f_k(x)dx.\\\end{align}\]</span> 即 <span class="math inline">\(\int\nolimits_E f(x)dx\leqslant \varliminf\limits_{k\to\infty}\int\nolimits_E f_k(x)dx\)</span>. <strong>这个证法可能有问题, 慢慢解决.</strong></p><h3 id="习题4-第一组-23">习题4 第一组 23</h3><blockquote><p>设 <span class="math inline">\(f\in L(\mathbf{R}^n)\)</span>, <span class="math inline">\(f_k\in L(\mathbf{R}^n)~(k=1,2,\cdots)\)</span>, 且对任一可测集 <span class="math inline">\(E\subset\mathbf{R}^n\)</span>, 均有 <span class="math display">\[\int\nolimits_Ef_k(x)dx\leqslant \int\nolimits_Ef_{k+1}(x)dx~(k=1,2,\cdots),\]</span> <span class="math display">\[\lim\limits_{k\to\infty}\int\nolimits_Ef_k(x)dx=\int\nolimits_Ef(x)dx,\]</span> 试证明 <span class="math inline">\(\lim\limits_{k\to\infty}f_k(x)=f(x)\)</span>, a.e. <span class="math inline">\(x\in\mathbf{R}^n\)</span>.</p></blockquote><p><strong>证明</strong>: 易由 <span class="math inline">\(\int\nolimits_Ef_k(x)dx\leqslant \int\nolimits_Ef_{k+1}(x)dx\)</span> 知 <span class="math inline">\(f_k(x)\leqslant f_{k+1}(x)\)</span>, a.e. <span class="math inline">\(x\in\mathbf{R}^n\)</span>. 于是 <span class="math inline">\(\{f_k(x)-f_1(x)\{\)</span> 为非负渐升列, 由Levi定理, 有 <span class="math display">\[\begin{align}\int\nolimits_Ef(x)dx-\int\nolimits_Ef_1(x)dx&amp;= \lim\limits_{k\to\infty}\int\nolimits_Ef_k(x)dx-\int\nolimits_Ef_1(x)dx \\&amp;= \lim\limits_{k\to\infty}\int\nolimits_E\left(f_k(x)-f_1(x)\right)dx \\&amp;= \int\nolimits_E\lim\limits_{k\to\infty}(f_k(x)-f_1(x))dx \\&amp;= \int\nolimits_E\lim\limits_{k\to\infty}f_k(x)dx-\int\nolimits_Ef_1(x)dx \\\end{align}\]</span> 即 <span class="math inline">\(\int\nolimits_Ef(x)dx=\int\nolimits_E\lim\limits_{k\to\infty}f_k(x)dx\)</span>, 故 <span class="math inline">\(\lim\limits_{k\to\infty}f_k(x)=f(x)\)</span>, a.e. <span class="math inline">\(x\in\mathbf{R}^n\)</span>.</p><h2 id="年06月21日">2017年06月21日</h2><h3 id="习题4-第一组-30">习题4 第一组 30</h3><blockquote><p>计算下列积分: 1. <span class="math inline">\(\int\nolimits_{x&gt;0}\int\nolimits_{y&gt;0}\frac{dxdy}{(1+y)(1+x^2Y)}\)</span>; 2. <span class="math inline">\(\int\nolimits_0^\infty\frac{\ln x}{x^2-1}dx\)</span></p></blockquote><p><strong>解答</strong>:</p><ol type="1"><li>由Tonelli定理, <span class="math display">\[\begin{align}\int\nolimits_{x&gt;0}\int\nolimits_{y&gt;0}\frac{dxdy}{(1+y)(1+x^2y)} &amp;= \int\nolimits_{x&gt;0}\int\nolimits_{y&gt;0}\frac{\sqrt{y}dx}{1+x^2y}\frac{dy}{\sqrt{y}(1+y)} \\&amp;= 2\int\nolimits_{x&gt;0}\frac{dx}{1+x^2}\int\nolimits_{y&gt;0}\frac{dy}{1+y^2} \\&amp;= \frac{\pi^2}{2}.\end{align}\]</span></li><li><span class="math display">\[\begin{align}\frac{\pi^2}{2} &amp;= \int\nolimits_{x&gt;0}\frac{1}{x^2-1}\int\nolimits_{y&gt;0}\left(\frac{x^2}{1+x^2y}-\frac{1}{1+y}\right)dxdy \\&amp;= \int\nolimits_{x&gt;0}\frac{1}{x^2-1}\left(\ln \frac{1+x^2y}{1+y}\Bigg\vert _0^\infty\right)dx \\&amp;= 2\int\nolimits_0^\infty\frac{\ln x}{x^2-1}dx.\end{align}\]</span> 故 <span class="math inline">\(\int\nolimits_0^\infty\frac{\ln x}{x^2-1}dx=\frac{\pi^2}{4}\)</span>.</li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 实变函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>调教Hexo[2]——Hexo与Mathjax的冲突及解决方案</title>
      <link href="/2017/03/08/Hexo%E4%B8%8EMathjax%E7%9A%84%E5%86%B2%E7%AA%81%E5%8F%8A%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89%E8%A7%A3%E5%86%B3/"/>
      <content type="html"><![CDATA[<h2 id="问题出现的原因蛋疼的转义">问题出现的原因：蛋疼的转义</h2><p>Markdwon本身的特殊符号与Latex中的符号会出现冲突：</p><table><thead><tr class="header"><th style="text-align: center;">符号</th><th style="text-align: center;">Markdown中意义</th><th style="text-align: center;">LaTeX中意义</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>_</code></td><td style="text-align: center;">斜体</td><td style="text-align: center;">下标</td></tr><tr class="even"><td style="text-align: center;"><code>\\</code></td><td style="text-align: center;">转义为<code>\</code></td><td style="text-align: center;">换行</td></tr><tr class="odd"><td style="text-align: center;"><code>*</code></td><td style="text-align: center;">加粗</td><td style="text-align: center;">无变化</td></tr></tbody></table><p>这些问题是存在于Markdown语法中的，然而辣鸡Hexo默认使用marked.js解析markdown，于是表示斜体的<code>_</code>会被处理为<code>&lt;em&gt;</code>标签，如<code>x_i</code>在开始被渲染的时候，处理为<code>x&lt;em&gt;i&lt;/em&gt;</code>，这个时候Mathjax就无法将其渲染成下标了。 类似的问题还有很多，比如<code>*</code>和<code>\</code>字符。 所以从根本上来讲，是辣鸡Hexo使用的Markdown引擎造成的。。垃圾Hexo。。</p><h2 id="解决方案一手动转义">解决方案一：手动转义</h2><p>手动转义的意思很明确，你不是把我的<code>\\</code>转成了<code>\</code>么？那好，我输<code>\\\\</code>还不行么？你总得给我转成<code>\\</code>了吧？ 同理，在下标的地方写成<code>\_</code>，也同样能够避免这个问题。 听起来很棒耶，但手动转义的缺点其实是很明显的：无法移植。你辛辛苦苦改了很久的文章也许往其他平台上面一贴就面目全非了，因为大多数的Markdown解释引擎都没有这个毛病（垃圾Hexo）<del>这你不就傻逼了么</del>，所以手动转义需谨慎。。</p><h2 id="解决方案二保护公式">解决方案二：保护公式</h2><p>另一个听起来很棒的想法就是用代码环境来保护公式，并且在解析的时候，只要发现<code>$...$</code>字样就按照公式来解析。 听起来不错耶！既解决了转义的问题，又不会破坏兼容性。但是这种方法也会带来一个很严重的问题：如果你要插入的某段代码中也含有<code>$...$</code>的字样，就会出现错误。。 该方法详见 <a href="http://liam0205.me/2015/09/09/fix-conflict-between-mathjax-and-markdown/" target="_blank" rel="noopener">解决 MathJax 与 Markdown 的冲突</a>。</p><h2 id="解决方案三更换引擎">解决方案三：更换引擎</h2><p>既然这个marked.js这么烂，我们干脆把它换掉好了，简单粗暴没有后患。替代marked.js的方案有很多，只以<code>Hexo-renderer-pandoc</code>为例：</p><ul><li>安装Pandoc，官网提供了deb安装包，按照官网教程就可以安装完成。</li><li>卸载Hexo默认的markd,再安装新的:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall Hexo-renderer-marked --save</span><br><span class="line">npm install Hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure><p>这种解决方案的一点小瑕疵是语法与Markdown有很小的差别，需要注意一下。</p><h2 id="解决方案四修改引擎">解决方案四：修改引擎</h2><p>这个marked.js虽然烂，可是你说不定觉得它还是可以抢救一下的。。按照如下方法进行抢救也能一定程度上解决问题：</p><ul><li>找到<code>marked.js</code>，路径为<code>\nodes_modules/marked/lib/marked.js</code>；</li><li>将marked.js中的如下第一行代码改为第二行以去掉<code>\</code>的转义：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">escape: /^\\([\\`*&#123;&#125;\[\]()#+\-.!_&gt;])/,</span><br><span class="line">escape: /^\\([`*&#123;&#125;\[\]()# +\-.!_&gt;])/,</span><br></pre></td></tr></table></figure><ul><li>将marked.js中的如下第一行代码改为第二行以更改<code>&lt;em&gt;</code>符号：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br><span class="line">em:/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><ul><li><a href="https://segmentfault.com/a/1190000007261752" target="_blank" rel="noopener">SegmentFault——Hexo下mathjax的转义问题</a></li><li><a href="http://lukang.me/2014/mathjax-for-hexo.html" target="_blank" rel="noopener">空念远兮——在 Hexo 中完美使用 Mathjax 输出数学公式</a></li></ul><table><tbody><tr class="odd"><td><strong>垃圾Hexo！！！</strong></td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 计算机 </tag>
            
            <tag> Hexo </tag>
            
            <tag> Mathjax </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数学系转专业考试题及解答不完全版（2015.04）</title>
      <link href="/2017/03/08/%E6%95%B0%E5%AD%A6%E7%B3%BB%E8%BD%AC%E4%B8%93%E4%B8%9A%E8%80%83%E8%AF%95%E9%A2%98%E5%8F%8A%E8%A7%A3%E7%AD%94%E4%B8%8D%E5%AE%8C%E5%85%A8%E7%89%88%EF%BC%882015-04%EF%BC%89/"/>
      <content type="html"><![CDATA[<ul><li>北京师范大学数学科学学院转专业考试. 2015年4月.</li></ul><a id="more"></a><h2 id="几句废话">几句废话</h2><p>又是一年转专业的时候, 转专业这件事也又一次被提起。最初的转专业想法是在刚入校形成的, 经历了一些波折之后最终确定了转专业的事情, 于是在2015年的4月（其实也可能是3月, 记不清了）参加了转专业的考试。 笔试结果出来之后得知洲洲没有通过笔试, 洲洲希望我能整理一份题目和解答给他（或许是留作纪念）。但由于考完之后没有很及时地整理, 导致了个别问题的遗漏（至多两个）。 整理完之后将纸质版交给了洲洲, 为了保存一下相关内容, 我便将该文档拍照发到了<a href="https://tieba.baidu.com/lzcwr" target="_blank" rel="noopener">我的贴吧：lzcwr吧</a>里边。但是由于我当时过于naive, 还不懂得“图像压缩”的问题, 便直接将画质很差的图像上传到了网上。。导致帖子里边的图片全部是AV画质。。有兴趣可以点击<a href="https://tieba.baidu.com/p/3726485475" target="_blank" rel="noopener">原帖地址</a>看看。。现在想起来有点后悔, 于是决定重新整理一份（在较大程度上能还原原试卷）。</p><h2 id="试题">试题</h2><ol type="1"><li>设数列 $ { x_n } $ 满足 <span class="math inline">\(x_n&gt;0\)</span>, 且 <span class="math inline">\(\forall n\in \mathbb{N}\)</span>, 都有 <span class="math inline">\(x_{n+1}+\frac{1}{x_n}&lt;2\)</span>, 求证：<span class="math display">\[\lim_{n\to\infty}x_n=1\]</span></li><li>若函数 <span class="math inline">\(f(x)\)</span> 满足 <span class="math display">\[f(x+y)=f(x)\times f(y)\]</span>且 <span class="math inline">\(f(0)=1\)</span>, <span class="math inline">\(f&#39;(0)=2\)</span>, 求 <span class="math inline">\(f(x)\)</span> 的表达式.</li><li>求极限：<span class="math display">\[\lim\limits_{x\to0}\frac{\sin x^6}{x^2-\arcsin x^2}\]</span></li><li>设 <span class="math inline">\(f(x)=x^3\sin2x\)</span>, 求：<span class="math inline">\(f^{(10)}(0)\)</span>.</li><li>求积分：<span class="math display">\[\int_0^{\frac{\pi}{4}}\frac{x\sec^2x{\rm d}x}{(1+\tan x)^2}\]</span></li><li>求证：<span class="math display">\[\frac{2}{3}n\sqrt{n}&lt;1+\sqrt{2}+\sqrt{3}+\cdots+\sqrt{n}&lt;\frac{4n+3}{6}\sqrt{n}\]</span></li><li>令 <span class="math inline">\(f(x)=xe^{-x}\)</span>, 设 <span class="math inline">\(f(x)\)</span> 有极值点 <span class="math inline">\((x_1,y_1)\)</span>, 拐点 <span class="math inline">\((x_2,y_2)\)</span>：<ol type="1"><li>求 <span class="math inline">\((x_1,y_1)\)</span> 和 <span class="math inline">\((x_2,y_2)\)</span>.</li><li>求函数与 <span class="math inline">\(x\)</span> 轴在 <span class="math inline">\(x=x_1\)</span> 与 <span class="math inline">\(x=x_2\)</span> 之间围成的面积.</li></ol></li><li>令 <span class="math inline">\(f(x)\)</span> 为定义在 <span class="math inline">\((-\infty,+\infty)\)</span> 上的函数, 且对 <span class="math inline">\(\forall x\in\mathbb{R}\)</span>, 均有 <span class="math inline">\(|f(x)|\leq M_1\)</span>, <span class="math inline">\(|f&#39;&#39;(x)|\leq M_2\)</span>, 求证：<span class="math display">\[|f&#39;(x)|\leq \sqrt{2M_1M_2}\]</span></li></ol><h2 id="解答">解答</h2><p>因为我比较懒。。一些简单题目就不做详细的解答了。。一定要看详细解答的可以去原帖看av画质的图片, 应该能看懂。。（别问我为什么不用有序列表）</p><p>1.由条件, <span class="math inline">\(x_{n+1}-x_n&lt;2-(x_n+\frac{1}{x_n})\)</span>, 而由均值不等式有 <span class="math inline">\(x_n+\frac{1}{x_n}\geq 2\)</span>, 于是 <span class="math inline">\(x_{n+1}-x_n&lt;0\)</span>, 即数列 $ { x_n } $递减。于是数列 $ { x_n } $单调有界, 有极限。由 <span class="math inline">\(x_{n+1}+\frac{1}{x_n}&lt;2\)</span> 易得结论；</p><p>2.两边同时取对数即变为 Cauchy 方程 <span class="math inline">\(g(x+y)=g(x)+g(y)\)</span>, 用 Cauchy 方法即可求解；</p><p>3.换元 <span class="math inline">\(y=x^2\)</span> 后将分子分母分别泰勒展开至 <span class="math inline">\(y^3\)</span> 即可得答案为 <span class="math inline">\(-6\)</span>；</p><p>4.这个题不会做自觉面壁；</p><p>5.无脑积分：md劳资怎么改都generate不了, 只好截个图算了。。</p><center><img src="/img/blog-graph/转专业-5.png" alt="积分步骤" width="600"></center><p>6.一方面考虑 <span class="math inline">\(f(x)=\sqrt{x}\)</span> 在 <span class="math inline">\([0,n]\)</span> 的积分, 有 <span class="math inline">\(\sum_{i=1}^{n}\sqrt{i}&gt;\int_0^n\sqrt{x}{\rm d}x=\frac{2}{3}n\sqrt{n}\)</span>；另一边不等式只需给右边做差, 证明 <span class="math inline">\(\sqrt{k}&lt;\frac{4k+3}{6}\sqrt{k}-\frac{4k-1}{6}\sqrt{k-1}\)</span> 即可（不会做的自觉面壁）；</p><p>7.这个题不会做的继续面壁吧；</p><p>8.考场上没做出来, 后来问会了但是现在也不记得了……比较难, 这样的题考场上做不出来可以理解。</p><p>祝要转专业的各位转专业成功！</p><hr><p>不能忍。。存一下第五题的公式代码……问题解决了再贴上去……</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;align&#125;</span><br><span class="line">\int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;\frac&#123;x\sec^2x&#125;&#123;(1+\tan x)^2&#125;&#123;\rm d&#125;x &amp;= \int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;\frac&#123;x&#125;&#123;(1+\tan x)^2&#125;&#123;\rm d&#125;(1+\tan x) \\</span><br><span class="line"> &amp;= -\int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;x&#123;\rm d&#125;(\frac&#123;1&#125;&#123;1+\tan x&#125;) \\</span><br><span class="line"> &amp;= -(\frac&#123;x&#125;&#123;1+\tan x&#125;\Big|_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;-\int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;\frac&#123;&#123;\rm d&#125;x&#125;&#123;1+\tan x&#125;) \\</span><br><span class="line"> &amp;= -\frac&#123;\pi&#125;&#123;8&#125;+\int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;\frac&#123;\cos x&#125;&#123;\sin x+\cos x&#125;&#123;\rm d&#125;x \\</span><br><span class="line"> &amp;= -\frac&#123;\pi&#125;&#123;8&#125;+\int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;\frac&#123;\frac&#123;1&#125;&#123;2&#125;(\cos x+\sin x)+\frac&#123;1&#125;&#123;2&#125;(\cos x-\sin x)&#125;&#123;\sin x+\cos x&#125;&#123;\rm d&#125;x \\</span><br><span class="line"> &amp;= -\frac&#123;\pi&#125;&#123;8&#125;+\int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;\frac&#123;1&#125;&#123;2&#125;&#123;\rm d&#125;x+\frac&#123;1&#125;&#123;2&#125;\int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;\frac&#123;&#123;\rm d&#125;(\sin x+\cos x)&#125;&#123;\sin x+\cos x&#125; \\</span><br><span class="line"> &amp;= \frac&#123;1&#125;&#123;2&#125;\ln(\sin x+\cos x)\vert_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125; \\</span><br><span class="line"> &amp;= \frac&#123;1&#125;&#123;2&#125;\ln\sqrt&#123;2&#125; = \frac&#123;\ln2&#125;&#123;4&#125;</span><br><span class="line">\end&#123;align&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 数学分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构——树状数组 Binary Indexed Tree</title>
      <link href="/2017/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%20Binary%20Indexed%20Tree/"/>
      <content type="html"><![CDATA[<h2 id="树状数组概述">树状数组概述</h2><p>树状数组(binary indexed tree)能够高效地获取数组的子段和。 一般来说，树状数组可以用于解决数组子段和的动态查询或高效查询问题。</p><blockquote><p>传统的数组单点修改的复杂度为<span class="math inline">\(~O(1)~\)</span>，查询子段和的复杂度为<span class="math inline">\(~O(n)~\)</span>。 而树状数组的修改和查询子段和复杂度均为<span class="math inline">\(~O(\log n)~\)</span>。 所以在多组查询或动态查询时，用树状数组可以有效减小耗时，提高程序效率。</p></blockquote><h2 id="树状数组的操作">树状数组的操作</h2><h3 id="构建">构建</h3><p>从已知数组构建树状数组就是把线性的数组变成一棵树。那么，树状数组是如何把线性结构的数组变成一棵树的呢？以下以一个长度为8的数组为例：</p><p>原始数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[8]</span><br></pre></td></tr></table></figure><p>在修改和查询子段和时，很容易想到一种类似二分的想法来构建一棵树状的数组来保存原数组的所有信息。 用这种方法构造出的数组具有如下的结构（图片来自<a href="http://baike.baidu.com/link?url=MWXznqHrg5WOaQXOilx_IgGzC_YzDNcwVqbMqltULN9YUIPgB75WQU2xpoIfPXsq7z21_2LSn3wILiRRZXC97xYZleNY6LkqUEIlsCsOLeUEamNkjYhEvMKisCmKMNXK" target="_blank" rel="noopener">百度百科-树状数组</a>）：</p><figure><img src="http://static.zybuluo.com/lzcwr/cygbcza2ann0629f6fanea4n/image_1b9ho5pkm1vdbnld1hkc551nji9.png" alt="image_1b9ho5pkm1vdbnld1hkc551nji9.png-86.1kB"><figcaption>image_1b9ho5pkm1vdbnld1hkc551nji9.png-86.1kB</figcaption></figure><p>这样的一棵树满足如下的条件：</p><ul><li><span class="math inline">\(C_1=A_1\)</span></li><li><span class="math inline">\(C_2=A_1+A_2\)</span></li><li><span class="math inline">\(C_3=A_3\)</span></li><li><span class="math inline">\(C_4=A_1+A_2+A_3+A_4\)</span></li><li><span class="math inline">\(C_5=A_5\)</span></li><li><span class="math inline">\(C_6=A_5+A_6\)</span></li><li><span class="math inline">\(C_7=A_7\)</span></li><li><span class="math inline">\(C_8=A_1+A_2+A_3+A_4+A_5+A_6+A_7+A_8\)</span></li></ul><p>从中可以发现，若结点的标号为<span class="math inline">\(~n~\)</span>，则该结点的求和区域长度为<span class="math inline">\(~2^k~\)</span>，此处的<span class="math inline">\(~k~\)</span>为<span class="math inline">\(~n~\)</span>的二进制表示的末尾<span class="math inline">\(~0~\)</span>的个数。 由于<span class="math inline">\(~n~\)</span>号结点求和区域的最末一位一定是<span class="math inline">\(~A_n~\)</span>，于是有：</p><p><span class="math display">\[ C[n] = \sum_{i = n - 2^k + 1}^{n} A[i] = A[n-2^k+1]+A[n-2^k+1]+\cdots+A[n-1]+A[n] \]</span></p><p>于是构建树状数组的问题就变成了如何求<span class="math inline">\(~2^k~\)</span>的问题。 利用位运算的性质，有一个非常漂亮的解答（<span class="math inline">\(\oplus\)</span>表示异或）：</p><p><span class="math display">\[2^k=n\&amp;(n\oplus (n-1))=n\&amp;(-n)\]</span></p><p>这就是树状数组构建的核心：<code>lowbit()</code>函数，代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int lowbit(int x)   </span><br><span class="line">&#123;   </span><br><span class="line">    return x &amp; (-x);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单点修改">单点修改</h3><p>树状数组的单点修改过程很简单：修改需要修改的点，然后沿着树上的路径把受到牵连的点一并修改。 由于树高为<span class="math inline">\(~O(\log n)~\)</span>，故复杂度<span class="math inline">\(~O(\log n)~\)</span>。 示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void add(int x, int y) // 在x位置上加上y</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = x; i &lt;= n; i += lowbit(i)) // 找到与x相关的所有位置</span><br><span class="line">        c[i] += y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求前n项和">求前<span class="math inline">\(~n~\)</span>项和</h3><p>求前<span class="math inline">\(~n~\)</span>项和时，由于在<span class="math inline">\(~C_n~\)</span>记录了下标从<span class="math inline">\(~n-lowbit(n)+1~\)</span>到<span class="math inline">\(~n~\)</span>的子段和，故可以直接在结果中加上<span class="math inline">\(~C_n~\)</span>，接下来只需要计算<span class="math inline">\(~C[n-lowbit(n)]~\)</span>的值。一直循环下去即可。 由于树高为<span class="math inline">\(~O(\log n)~\)</span>，故复杂度<span class="math inline">\(~O(\log n)~\)</span>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int sum(int x) // 前x项和</span><br><span class="line">&#123;</span><br><span class="line">    int ret(0);</span><br><span class="line">    for(int i = x; i &gt;= 1; i -= lowbit(i))</span><br><span class="line">        ret += c[i];</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维树状数组">二维树状数组</h2><p>其结构与普通的树状数组相同，只不过在求前<span class="math inline">\(~n~\)</span>项和时是从<span class="math inline">\(~(1,1)~\)</span>到<span class="math inline">\(~(x,y)~\)</span>求和。 示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int lowbit(int x)</span><br><span class="line">&#123;</span><br><span class="line">return x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line">void add(int x, int y, int val) // 将[x][y]的值增加val</span><br><span class="line">&#123;</span><br><span class="line">for(int i = x; i &lt; N; i += lowbit(i))</span><br><span class="line">for(int j = y; j &lt; N; j += lowbit(j))</span><br><span class="line">sum[i][j] += val;</span><br><span class="line">&#125;</span><br><span class="line">int sum(int x, int y) // 求以[1][1]为左上角端点,[x][y]为右下角端点的矩阵和</span><br><span class="line">&#123;</span><br><span class="line">int ret(0);</span><br><span class="line">for(int i = x; i &gt; 0; i -= lowbit(i))</span><br><span class="line">for(int j = y; j &gt; 0; j -= lowbit(j))</span><br><span class="line">ret += sum[i][j];</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树状数组的应用">树状数组的应用</h2><ul><li>动态查询子段和——HDU 1166 敌兵布阵；</li><li>求逆序数——HDU 1349 Minimum Inversion Number；</li></ul><h3 id="练习题目">练习题目</h3><ul><li>POJ 1195 Mobile phones</li><li>POJ 2481 Cows</li><li>POJ 2155 Matrix</li><li>POJ 3321 Apple Tree</li><li>HDU 1556 color the ball</li><li>POJ 2299 Ultra-QuickSort</li></ul><h3 id="参考资料">参考资料</h3><ul><li><a href="http://blog.csdn.net/matrix_reloaded/article/details/32101509" target="_blank" rel="noopener">Matrix_Reloaded——树状数组题目集</a></li><li><a href="http://dongxicheng.org/structure/binary_indexed_tree/" target="_blank" rel="noopener">董的博客——树状数组</a></li><li><a href="http://blog.csdn.net/x_iya/article/details/8943264" target="_blank" rel="noopener">晚晴小筑——树状数组学习笔记</a></li></ul>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构——平衡树 Treap</title>
      <link href="/2017/02/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%B9%B3%E8%A1%A1%E6%A0%91%20Treap/"/>
      <content type="html"><![CDATA[<h2 id="treap概述">Treap概述</h2><p>Treap是一种平衡二叉树，不过Treap会记录一个优先级（一般来说是随机生成），即Treap在以关键码构成二叉搜索树的同时，还会按照优先级的高低满足堆的性质，因此得名Treap（Tree + Heap）。 Treap不是二叉堆，二叉堆必须是完全二叉树，但Treap不必是。</p><p>对于每个结点，该结点的优先级不大于其所有孩子的优先级。Treap引入优先级的原因就是防止BST（二叉搜索树）退化成一条链，从而影响查询效率。</p><p>所以对于结点上的关键字来说，它是一颗BST，而对于结点上的优先级来讲，它是一个小顶堆。其平均查找长度为<span class="math inline">\(~O(\log n)~\)</span>。 Treap有插入、删除、旋转和查询等基本操作，进而可以实现查询第<span class="math inline">\(~k~\)</span>大和查询关键字<span class="math inline">\(~x~\)</span>排名等功能。</p><h2 id="treap的结构">Treap的结构</h2><p>Treap是一颗BST，所以Treap的每一个结点都需要记录一个关键字和两个儿子指针； Treap又是一个小顶堆，所以需要记录一个优先级。 结点的构建方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Treap_Node</span><br><span class="line">&#123;</span><br><span class="line">    Treap_Node *left, *right; // 儿子指针</span><br><span class="line">    int value, fix; // 值和优先级</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="treap的操作">Treap的操作</h2><h3 id="旋转">旋转</h3><p>Treap本身对于关键字的构建和二叉查找树相同，但为对优先级维持其最小堆的性质，需要对树的结构进行调整，称为旋转，其操作方式如下：</p><ul><li><strong>左旋</strong>：将子树的根结点旋转到其根的左子树位置，同时根节点的右子节点成为该子树的根；</li><li><strong>右旋</strong>：将子树的根结点旋转到其根的右子树位置，同时根节点的左子节点成为该子树的根。</li></ul><p>例如下面这两棵树（表示方法为<code>[关键字-优先级]</code>）可以互相对根结点旋转得到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      [<span class="number">4</span><span class="number">-3</span>]                       [<span class="number">2</span><span class="number">-1</span>]</span><br><span class="line">      /   \     ==== 左旋 ===&gt;    /   \</span><br><span class="line">   [<span class="number">3</span><span class="number">-1</span>] [<span class="number">5</span><span class="number">-5</span>]                 [<span class="number">1</span><span class="number">-2</span>] [<span class="number">4</span><span class="number">-3</span>]</span><br><span class="line">   /   \        &lt;=== 右旋 ====       /   \</span><br><span class="line">[<span class="number">1</span><span class="number">-2</span>] [<span class="number">2</span><span class="number">-4</span>]                       [<span class="number">3</span><span class="number">-4</span>] [<span class="number">5</span><span class="number">-5</span>]</span><br></pre></td></tr></table></figure><p>旋转的实例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Left_Rotate</span><span class="params">(Treap_Node *&amp;a)</span> <span class="comment">//左旋 节点指针一定要传递引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Treap_Node *b = a -&gt; right;</span><br><span class="line">  a -&gt; right = b -&gt; left;</span><br><span class="line">  b -&gt; left = a;</span><br><span class="line">  a = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Right_Rotate</span><span class="params">(Treap_Node *&amp;a)</span> <span class="comment">//右旋 节点指针一定要传递引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Treap_Node *b = a -&gt; left;</span><br><span class="line">  a -&gt; left = b -&gt; right;</span><br><span class="line">  b -&gt; right = a;</span><br><span class="line">  a = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用下标来压缩代码量，具体实现方法在后边的模板给出。</p><h3 id="插入">插入</h3><p>在Treap中插入元素的法则与在BST中插入的法则相同，但插入完成后可能会破坏堆的性质，所以插入完成后要进行旋转，具体方法如下：</p><ol type="1"><li>从根结点开始访问；</li><li>若当前结点为空，则直接插入，否则执行下一步；</li><li>递归访问左右子树：</li></ol><ul><li>若插入的关键字小于当前访问结点，则访问其左子树，若插入后左子结点的优先级小于当前访问结点的优先级，则对当前结点进行右旋；</li><li>若插入的关键字大于当前访问结点，则访问其右子树，若插入后右子结点的优先级小于当前访问结点的优先级，则对当前结点进行左旋；</li></ul><p>以下是一个例子：</p><p>先在Treap中按照BST的方法插入<code>[3-2]</code>结点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                                          [2-1]</span><br><span class="line">   [2-1]                                  /   \</span><br><span class="line">   /   \                               [1-3] [5-4]</span><br><span class="line">[1-3] [5-4]      ==== 插入[3-2] ===&gt;          /   \</span><br><span class="line">      /   \                      不平衡 =&gt; [4-5] [6-6]</span><br><span class="line">   [4-5] [6-6]                            /</span><br><span class="line">                                       [3-2]</span><br></pre></td></tr></table></figure><p>由于当前访问结点<code>[4-5]</code>的左子结点<code>[3-2]</code>的优先级小于当前结点的优先级，需要进行右旋操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   [2-1]                                [2-1]</span><br><span class="line">   /   \                                /   \</span><br><span class="line">[1-3] [5-4]                          [1-3] [5-4] &lt;= 不平衡</span><br><span class="line">      /   \      == 对[4-5]右旋 =&gt;          /   \</span><br><span class="line">   [4-5] [6-6]                           [3-2] [6-6]</span><br><span class="line">   /                                        \</span><br><span class="line">[3-2]                                      [4-5]</span><br></pre></td></tr></table></figure><p>至此<code>[3-2]</code>和<code>[4-5]</code>已经调整完毕，向上回溯发现<code>[5-4]</code>的左子结点<code>[3-2]</code>优先级低于<code>[5-4]</code>，故对<code>[5-4]</code>进行一次右旋操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   [2-1]                                [2-1]      </span><br><span class="line">   /   \                                /   \      </span><br><span class="line">[1-3] [5-4]                          [1-3] [3-2]   </span><br><span class="line">      /   \      == 对[5-4]右旋 =&gt;              \  </span><br><span class="line">   [3-2] [6-6]                                [5-4]</span><br><span class="line">       \                                      /   \      </span><br><span class="line">      [4-5]                                [4-5] [6-6]</span><br></pre></td></tr></table></figure><p>至此，整个树调整完毕，插入操作结束。</p><p>插入的示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Treap_Node *root;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Treap_Node *&amp;P, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!P) <span class="comment">// 找到位置，建立节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        P = <span class="keyword">new</span> Treap_Node;</span><br><span class="line">        P -&gt; value = value;</span><br><span class="line">        P -&gt; fix = rand(); <span class="comment">// 生成优先级</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(value &lt;= P -&gt; value)</span><br><span class="line">    &#123;</span><br><span class="line">        Treap_Insert(P -&gt; left, r);</span><br><span class="line">        <span class="keyword">if</span>(P -&gt; left -&gt; fix &lt; P -&gt; fix)</span><br><span class="line">            Right_Rotate(P); <span class="comment">// 左子结点优先级低，右旋</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Treap_Insert(P -&gt; right, r);</span><br><span class="line">        <span class="keyword">if</span>(P -&gt; right -&gt; fix &lt; P -&gt; fix)</span><br><span class="line">            Left_Rotate(P); <span class="comment">// 右子结点优先级低，左旋</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询">查询</h3><p>与BST相同的二分查找，查询复杂度为<span class="math inline">\(~O(\log n)~\)</span>。</p><h3 id="删除">删除</h3><p>Treap的删除是基于旋转操作的，很容易理解的便是，只需要将要删除的结点旋转为叶子结点，再执行删除，具体步骤如下：</p><ul><li>先在Treap中找到该结点，则有两种情况分述如下；</li></ul><ol type="1"><li>该节点为叶节点或链节点；</li><li>该节点有两个非空子节点；</li></ol><ul><li>针对情况1，若该节点有非空子结点，则用非空子节点代替该结点，否则用空节点代替该结点，然后删除该结点；</li><li>针对情况2，要先通过旋转使该结点使之可以直接删除，针对旋转有两种情况，分述如下：</li></ul><ol type="1"><li>如果该结点的左子结点的优先级比右子结点低，需要右旋该结点，使该结点降为右子树的根结点，然后跳转到右子树的根结点，重新判断；</li><li>反之，则左旋该结点，使该结点降为左子树的根结点，然后访问左子树的根，不断操作下去，直到该结点可以直接删除。</li></ol><p>以上操作复杂度为<span class="math inline">\(~O(\log N)~\)</span>。</p><p>示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Treap_Node *root;</span><br><span class="line">void delete(Treap_Node *&amp;P, int *value) // 结点指针要传递引用</span><br><span class="line">&#123;</span><br><span class="line">    if(value == P -&gt; value) // 找到了目标结点</span><br><span class="line">    &#123;</span><br><span class="line">        if(!P -&gt; right || !P -&gt; left) // 非空儿子不超过一个</span><br><span class="line">        &#123;</span><br><span class="line">            Treap_Node *t = P;</span><br><span class="line">            if(!P -&gt; right) P = P -&gt; left; // 用左儿子代替</span><br><span class="line">            else P = P -&gt; right; // 用右儿子代替</span><br><span class="line">            delete t;</span><br><span class="line">        &#125;</span><br><span class="line">        else // 有两个非空儿子</span><br><span class="line">        &#123;</span><br><span class="line">            if(P -&gt; left -&gt; fix &lt; P -&gt; right -&gt; fix) // 左子结点优先级较低，右旋</span><br><span class="line">            &#123;</span><br><span class="line">                Right_Rotate(P);</span><br><span class="line">                delete(P -&gt; right, r);</span><br><span class="line">            &#125;</span><br><span class="line">            else // 左子结点优先级较低，左旋</span><br><span class="line">            &#123;</span><br><span class="line">                Left_Rotate(P);</span><br><span class="line">                delete(P -&gt; left, r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(value &lt; P -&gt; value) delete(P -&gt; left, r); // 查找左子树</span><br><span class="line">    else delete(P -&gt; right, r); // 查找右子树</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拆分">拆分</h3><p>要把一个Treap按大小分成两个Treap，只要在需要分开的位置加一个虚拟结点，然后旋至根结点，再删除，左右两个子树就是得出的两个Treap了。根据BST的性质，这时左子树的所有节点都小于右子树的节点。 拆分操作的复杂度与插入相同，也是<span class="math inline">\(~O(\log N)~\)</span>。</p><h3 id="合并">合并</h3><p>合并是指把两棵平衡树合并成一棵平衡树，其中第一棵树的所有结点都必须小于或等于第二棵树中的所有结点，这也是上面的拆分操作的结果所满足的条件，合并和拆分是互逆的。 Treap的合并操作的过程和分离完全相反，只要加一个虚拟的根，把两棵树分别作为左右子树，然后把根删除就可以了。 合并操作的复杂度与删除相同，也是<span class="math inline">\(~O(\log N)~\)</span>。</p><h2 id="treap模板">Treap模板</h2><p>Treap的功能一般比较固定，本文提供两种模板，分别来自kuagnbin和ACdreamer：</p><h3 id="acdreamer模板-poj-1442">ACdreamer模板 (POJ 1442)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct Treap</span><br><span class="line">&#123;</span><br><span class="line">    int size;</span><br><span class="line">    int key, fix;</span><br><span class="line">    Treap *ch[2];</span><br><span class="line">    Treap(int key)</span><br><span class="line">    &#123;</span><br><span class="line">        size=1;</span><br><span class="line">        fix=rand();</span><br><span class="line">        this-&gt;key=key;</span><br><span class="line">        ch[0]=ch[1]=NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    int compare(int x) const</span><br><span class="line">    &#123;</span><br><span class="line">        if(x==key) return -1;</span><br><span class="line">        return x&lt;key? 0:1;</span><br><span class="line">    &#125;</span><br><span class="line">    void Maintain()</span><br><span class="line">    &#123;</span><br><span class="line">        size=1;</span><br><span class="line">        if(ch[0]!=NULL) size+=ch[0]-&gt;size;</span><br><span class="line">        if(ch[1]!=NULL) size+=ch[1]-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void Rotate(Treap* &amp;t, int d)</span><br><span class="line">&#123;</span><br><span class="line">    Treap *k=t-&gt;ch[d^1];</span><br><span class="line">    t-&gt;ch[d^1]=k-&gt;ch[d];</span><br><span class="line">    k-&gt;ch[d]=t;</span><br><span class="line">    t-&gt;Maintain();  </span><br><span class="line">    k-&gt;Maintain();</span><br><span class="line">    t=k;</span><br><span class="line">&#125;</span><br><span class="line">void Insert(Treap* &amp;t, int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(t==NULL) t=new Treap(x);</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        int d=x &lt; t-&gt;key ? 0 : 1;  </span><br><span class="line">        Insert(t-&gt;ch[d], x);</span><br><span class="line">        if(t-&gt;ch[d]-&gt;fix &gt; t-&gt;fix)</span><br><span class="line">            Rotate(t, d^1);</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;Maintain();</span><br><span class="line">&#125;</span><br><span class="line">void Delete(Treap* &amp;t, int x)</span><br><span class="line">&#123;</span><br><span class="line">    int d=t-&gt;compare(x);</span><br><span class="line">    if(d==-1)</span><br><span class="line">    &#123;</span><br><span class="line">        Treap *tmp=t;</span><br><span class="line">        if(t-&gt;ch[0]==NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            t=t-&gt;ch[1];</span><br><span class="line">            delete tmp;</span><br><span class="line">            tmp=NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(t-&gt;ch[1]==NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            t=t-&gt;ch[0];</span><br><span class="line">            delete tmp;</span><br><span class="line">            tmp=NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            int k=t-&gt;ch[0]-&gt;fix &gt; t-&gt;ch[1]-&gt;fix ? 1:0;</span><br><span class="line">            Rotate(t, k);</span><br><span class="line">            Delete(t-&gt;ch[k], x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else Delete(t-&gt;ch[d], x);</span><br><span class="line">    if(t!=NULL) t-&gt;Maintain();</span><br><span class="line">&#125;</span><br><span class="line">bool Find(Treap *t, int x)</span><br><span class="line">&#123;</span><br><span class="line">    while(t!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        int d=t-&gt;compare(x);</span><br><span class="line">        if(d==-1) return true;</span><br><span class="line">        t=t-&gt;ch[d];</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int Kth(Treap *t, int k)</span><br><span class="line">&#123;</span><br><span class="line">    if(t==NULL||k&lt;=0||k&gt;t-&gt;size)</span><br><span class="line">        return -1;</span><br><span class="line">    if(t-&gt;ch[0]==NULL&amp;&amp;k==1)</span><br><span class="line">        return t-&gt;key;</span><br><span class="line">    if(t-&gt;ch[0]==NULL)</span><br><span class="line">        return Kth(t-&gt;ch[1], k-1);</span><br><span class="line">    if(t-&gt;ch[0]-&gt;size&gt;=k)</span><br><span class="line">        return Kth(t-&gt;ch[0], k);</span><br><span class="line">    if(t-&gt;ch[0]-&gt;size+1==k)</span><br><span class="line">        return t-&gt;key;</span><br><span class="line">    return Kth(t-&gt;ch[1], k-1-t-&gt;ch[0]-&gt;size);</span><br><span class="line">&#125;</span><br><span class="line">int Rank(Treap *t, int x)</span><br><span class="line">&#123;</span><br><span class="line">    int r;</span><br><span class="line">    if(t-&gt;ch[0]==NULL) r=0;</span><br><span class="line">    else  r=t-&gt;ch[0]-&gt;size;</span><br><span class="line">    if(x==t-&gt;key) return r+1;</span><br><span class="line">    if(x&lt;t-&gt;key)</span><br><span class="line">        return Rank(t-&gt;ch[0], x);</span><br><span class="line">    return r+1+Rank(t-&gt;ch[1], x);</span><br><span class="line">&#125;</span><br><span class="line">void DeleteTreap(Treap* &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">    if(t==NULL) return;</span><br><span class="line">    if(t-&gt;ch[0]!=NULL) DeleteTreap(t-&gt;ch[0]);</span><br><span class="line">    if(t-&gt;ch[1]!=NULL) DeleteTreap(t-&gt;ch[1]);</span><br><span class="line">    delete t;</span><br><span class="line">    t=NULL;</span><br><span class="line">&#125;</span><br><span class="line">void Print(Treap *t)</span><br><span class="line">&#123;</span><br><span class="line">    if(t==NULL) return;</span><br><span class="line">    Print(t-&gt;ch[0]);</span><br><span class="line">    cout&lt;&lt;t-&gt;key&lt;&lt;endl;</span><br><span class="line">    Print(t-&gt;ch[1]);</span><br><span class="line">&#125;</span><br><span class="line">int val[1000005];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, x, m;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;val[i]);</span><br><span class="line">        int idx=1;</span><br><span class="line">        Treap *root=NULL;</span><br><span class="line">        for(int i=1; i&lt;=m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">            for(int j=idx; j&lt;=x; j++)</span><br><span class="line">                Insert(root, val[j]);</span><br><span class="line">            idx=x+1;</span><br><span class="line">            printf(&quot;%d\n&quot;, Kth(root, i));</span><br><span class="line">        &#125;</span><br><span class="line">        DeleteTreap(root);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="kuangbin模板-zoj-3765">kuangbin模板 (ZOJ 3765)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line">long long gcd(long long a, long long b)</span><br><span class="line">&#123;</span><br><span class="line">    if(b == 0)return a;</span><br><span class="line">    else return gcd(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line">const int MAXN = 300010;</span><br><span class="line">int num[MAXN], st[MAXN];</span><br><span class="line">struct Treap</span><br><span class="line">&#123;</span><br><span class="line">    int tot1;</span><br><span class="line">    int s[MAXN], tot2;</span><br><span class="line">    int ch[MAXN][1];</span><br><span class="line">    int key[MAXN], size[MAXN];</span><br><span class="line">    int sum0[MAXN], sum1[MAXN];</span><br><span class="line">    int status[MAXN];</span><br><span class="line">    void Init()</span><br><span class="line">    &#123;</span><br><span class="line">        tot1 = tot2 = 0;</span><br><span class="line">        size[0] = 0;</span><br><span class="line">        ch[0][0] = ch[0][2] = 0;</span><br><span class="line">        sum0[0] = sum1[0] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    bool random(double p)</span><br><span class="line">    &#123;</span><br><span class="line">        return (double)rand() / RAND_MAX &lt; p;</span><br><span class="line">    &#125;</span><br><span class="line">    int newnode(int val, int _status)</span><br><span class="line">    &#123;</span><br><span class="line">        int r;</span><br><span class="line">        if(tot2)r = s[tot2--];</span><br><span class="line">        else r = ++tot1;</span><br><span class="line">        size[r] = 1;</span><br><span class="line">        key[r] = val;</span><br><span class="line">        status[r] = _status;</span><br><span class="line">        ch[r][0] = ch[r][3] = 0;</span><br><span class="line">        sum0[r] = sum1[r] = 0;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">    void del(int r)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!r)return;</span><br><span class="line">        s[++tot2] = r;</span><br><span class="line">        del(ch[r][0]);</span><br><span class="line">        del(ch[r][4]);</span><br><span class="line">    &#125;</span><br><span class="line">    void push_up(int r)</span><br><span class="line">    &#123;</span><br><span class="line">        int lson = ch[r][0],  rson = ch[r][5];</span><br><span class="line">        size[r] = size[lson] + size[rson] + 1;</span><br><span class="line">        sum0[r] = gcd(sum0[lson], sum0[rson]);</span><br><span class="line">        sum1[r] = gcd(sum1[lson], sum1[rson]);</span><br><span class="line">        if(status[r] == 0)</span><br><span class="line">            sum0[r] = gcd(sum0[r], key[r]);</span><br><span class="line">        else sum1[r] = gcd(sum1[r], key[r]);</span><br><span class="line">    &#125;</span><br><span class="line">    void merge(int &amp;p, int x, int y)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!x || !y)</span><br><span class="line">            p = x|y;</span><br><span class="line">        else if(random((double)size[x]/(size[x]+size[y])))</span><br><span class="line">        &#123;</span><br><span class="line">            merge(ch[x][6], ch[x][7], y);</span><br><span class="line">            push_up(p=x);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            merge(ch[y][0], x, ch[y][0]);</span><br><span class="line">            push_up(p=y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void split(int p, int &amp;x, int &amp;y, int k)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!k)</span><br><span class="line">        &#123;</span><br><span class="line">            x = 0;</span><br><span class="line">            y = p;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(size[ch[p][0]] &gt;= k)</span><br><span class="line">        &#123;</span><br><span class="line">            y = p;</span><br><span class="line">            split(ch[p][0], x, ch[y][0], k);</span><br><span class="line">            push_up(y);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            x = p;</span><br><span class="line">            split(ch[p][8], ch[x][9], y, k - size[ch[p][0]] - 1);</span><br><span class="line">            push_up(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void build(int &amp;p, int l, int r)</span><br><span class="line">    &#123;</span><br><span class="line">        if(l &gt; r)return;</span><br><span class="line">        int mid = (l + r)/2;</span><br><span class="line">        p = newnode(num[mid], st[mid]);</span><br><span class="line">        build(ch[p][0], l, mid-1);</span><br><span class="line">        build(ch[p][10], mid+1, r);</span><br><span class="line">        push_up(p);</span><br><span class="line">    &#125;</span><br><span class="line">    void debug(int root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root == 0)return;</span><br><span class="line">        printf(&quot;%d 左儿子：%d 右儿子: %d size = %d key</span><br><span class="line">               = %d\n&quot;, root, ch[root][0], ch[root][11], size[root], key[root]);</span><br><span class="line">        debug(ch[root][0]);</span><br><span class="line">        debug(ch[root][12]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Treap T;</span><br><span class="line">char op[10];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, q;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;q) == 2)</span><br><span class="line">    &#123;</span><br><span class="line">        int root = 0;</span><br><span class="line">        T.Init();</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)</span><br><span class="line">            scanf(&quot;%d%d&quot;, &amp;num[i], &amp;st[i]);</span><br><span class="line">        T.build(root, 1, n);</span><br><span class="line">        while(q--)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%s&quot;, op);</span><br><span class="line">            if(op[0] == &apos;Q&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                int l, r, s;</span><br><span class="line">                scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;s);</span><br><span class="line">                int x, y, z;</span><br><span class="line">                T.split(root, x, z, r);</span><br><span class="line">                T.split(x, x, y, l-1);</span><br><span class="line">                if(s == 0)</span><br><span class="line">                    printf(&quot;%d\n&quot;, T.sum0[y] == 0? -1:T.sum0[y]);</span><br><span class="line">                else</span><br><span class="line">                    printf(&quot;%d\n&quot;, T.sum1[y] == 0?-1:T.sum1[y]);</span><br><span class="line">                T.merge(x, x, y);</span><br><span class="line">                T.merge(root, x, z);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(op[0] == &apos;I&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                int v, s, loc;</span><br><span class="line">                scanf(&quot;%d%d%d&quot;, &amp;loc, &amp;v, &amp;s);</span><br><span class="line">                int x, y;</span><br><span class="line">                T.split(root, x, y, loc);</span><br><span class="line">                T.merge(x, x, T.newnode(v, s));</span><br><span class="line">                T.merge(root, x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(op[0] == &apos;D&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                int loc;</span><br><span class="line">                scanf(&quot;%d&quot;, &amp;loc);</span><br><span class="line">                int x, y, z;</span><br><span class="line">                T.split(root, x, z, loc);</span><br><span class="line">                T.split(x, x, y, loc-1);</span><br><span class="line">                T.del(y);</span><br><span class="line">                T.merge(root, x, z);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(op[0] == &apos;R&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                int loc;</span><br><span class="line">                scanf(&quot;%d&quot;, &amp;loc);</span><br><span class="line">                int x, y, z;</span><br><span class="line">                T.split(root, x, z, loc);</span><br><span class="line">                T.split(x, x, y, loc-1);</span><br><span class="line">                T.status[y] = 1-T.status[y];</span><br><span class="line">                T.push_up(y);</span><br><span class="line">                T.merge(x, x, y);</span><br><span class="line">                T.merge(root, x, z);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                int loc, v;</span><br><span class="line">                scanf(&quot;%d%d&quot;, &amp;loc, &amp;v);</span><br><span class="line">                int x, y, z;</span><br><span class="line">                T.split(root, x, z, loc);</span><br><span class="line">                T.split(x, x, y, loc-1);</span><br><span class="line">                T.key[y] = v;</span><br><span class="line">                T.push_up(y);</span><br><span class="line">                T.merge(x, x, y);</span><br><span class="line">                T.merge(root, x, z);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习题目和参考资料">练习题目和参考资料</h2><h3 id="练习题目">练习题目</h3><ul><li>POJ 1442 Black Box</li><li>SPOJ 3273 Order statistic set</li><li>POJ 2761 Feed the dogs</li><li>Hohocoder 1325 平衡树·Treap</li><li>POJ 2985 The k-th LargestGroup</li><li>HDU 4585 ShaoLin</li><li>hdu 5096 ACM Rank</li></ul><h3 id="参考资料">参考资料</h3><ul><li><a href="http://blog.csdn.net/acdreamers/article/details/11309971" target="_blank" rel="noopener">ACdreamer的博客——Treap原理和实现方法</a></li><li><a href="http://dongxicheng.org/structure/treap/" target="_blank" rel="noopener">董的博客——数据结构之Treap</a></li><li><a href="http://blog.csdn.net/yang_yulei/article/details/46005845" target="_blank" rel="noopener">菜鸟的自留地——图文详解Treap</a></li><li><a href="http://www.nocow.cn/index.php/Treap" target="_blank" rel="noopener">NOCOW——Treap</a></li></ul>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构——线段树 Segment Tree</title>
      <link href="/2017/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%BA%BF%E6%AE%B5%E6%A0%91%20Segment%20Tree/"/>
      <content type="html"><![CDATA[<h2 id="线段树的概述">线段树的概述</h2><p>线段树是一颗完全二叉树，它的每个结点都表示一条线段，可以用来解决连续区间的动态查询问题。 线段树<strong>只支持区间信息可以由子区间信息合并而来的问题</strong>（如最值、乘积、区间和等）。</p><ul><li>线段树的结构：一般来说，区间<span class="math inline">\(~[a,b]~\)</span>的左儿子是<span class="math inline">\(~[a,m]~\)</span>，右儿子是<span class="math inline">\(~[m+1,b]~\)</span>；</li><li>线段树的空间：若数组长度是<span class="math inline">\(~N~\)</span>，线段树需要的最大空间为<span class="math inline">\(~4N~\)</span>；</li><li>线段树的效率：由于二叉树的性质，二叉树的操作时间复杂度基本保持在<span class="math inline">\(~O(\log N)~\)</span>。</li></ul><h2 id="线段树的操作">线段树的操作</h2><p>线段树的主要操作有：建树、更新、查询。</p><h3 id="建树">建树</h3><p>线段树的构造过程主要是递归构造：如果当前结点的区间<strong>左右端点相等</strong>，则给该节点<strong>赋值</strong>；若该结点区间<strong>左右端点不相等</strong>，则<strong>递归构造它的两个子树</strong>，构造完毕它的两个子树后再给该节点赋值。 建树的实例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[N], tree[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) tree[rt] = arr[l]; <span class="comment">// 左右端点相等，为叶子结点，直接赋值</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(l, m, rt &lt;&lt; <span class="number">1</span>); <span class="comment">// 构建左子树</span></span><br><span class="line">        build(m + <span class="number">1</span>, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>); <span class="comment">// 构建右子树</span></span><br><span class="line">    <span class="comment">// 由于不明确线段树存储的内容，故用push up函数来表示两个子区间的合并</span></span><br><span class="line">        push_up(rt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如下面的这段序列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">5</span>] = &#123;<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;;</span><br></pre></td></tr></table></figure><p>记录其区间和的线段树如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                         ([0, 4]=65)</span><br><span class="line">                       /            \</span><br><span class="line">            ([0, 2]=36)             ([3, 4]=29)</span><br><span class="line">            /          \            /         \</span><br><span class="line">      ([0, 1]=23) ([2, 2]=13) ([3, 3]=14) ([4, 4]=15)</span><br><span class="line">      /         \</span><br><span class="line">([0, 0]=11) ([1, 1]=12)</span><br></pre></td></tr></table></figure><p>记录其区间最大值的线段树如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                        ([0, 4]=15)</span><br><span class="line">                       /            \</span><br><span class="line">            ([0, 2]=13)             ([3, 4]=15)</span><br><span class="line">            /          \            /         \</span><br><span class="line">      ([0, 1]=12) ([2, 2]=13) ([3, 3]=14) ([4, 4]=15)</span><br><span class="line">      /         \</span><br><span class="line">([0, 0]=11) ([1, 1]=12)</span><br></pre></td></tr></table></figure><h3 id="查询">查询</h3><p>由于单点查询也可以视为左右端点相等的区间查询，故以下只讨论区间查询。 对于区间<span class="math inline">\(~[a,b]~\)</span>，可以从根结点开始，递归地判断查询区间与当前结点的关系。 由线段树的特性可知，查询的过程中，在每一层选择的区间个数不会多余两个（如果一层选择了三个区间，则一定会有两个相邻的区间是同一个结点的儿子，因此这两个区间可以直接合并为它们的父结点区间。） 区间查询的示例代码如下（以记录区间和为例）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [L, R]表示查询区间，rt表示当前区间标号，[l, r]为当前访问区间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 查询区间包含当前访问区间，直接返回当前区间的值</span></span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> tree[rt];</span><br><span class="line">    <span class="comment">// 否则，查询当前区间的两个儿子区间，再合并</span></span><br><span class="line">    <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>， ret(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(m &gt;= L) ret = query(L, R, l, m, rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(m &lt; R) ret += query(L, R, m + <span class="number">1</span>, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度的估计</strong>：由于该树共有<span class="math inline">\(~O(\log N)~\)</span>层，每层最多选择两个结点，故选择的结点个数也是<span class="math inline">\(~O(\log N)~\)</span>，即查询的时间复杂度为<span class="math inline">\(~O(\log N)~\)</span>。</p><h3 id="更新">更新</h3><p>更新是线段树的核心操作，线段树需要维护的一切信息都要由更新操作来体现。 对于更新，一个关键的操作是把儿子的信息合并到父结点上，以求和为例，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[rt] = tree[rt &lt;&lt; <span class="number">1</span>] + tree[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单点更新">单点更新</h4><p>单点更新的步骤非常简单：</p><ol type="1"><li>找到需要更新的单点，进行更新操作；</li><li>利用<code>push_up()</code>函数更新相关区间信息。</li></ol><p>仍然以区间求和为例，给出如下示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// idx为更新的下标，val为更新的值，[l, r]为更新区间，rt为更新区间标号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> val, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="comment">// 左右端点相等，进行更新</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree[rt] += val;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>; <span class="comment">// 递归地搜索左右子树</span></span><br><span class="line">    <span class="keyword">if</span>(m &gt;= idx) updata(idx, val, l, m, rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> updata(idx, val, m + <span class="number">1</span>, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    push_up(rt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="区间更新">区间更新</h4><p>线段树更新中<strong>最难理解的内容就是区间更新</strong>。 区间更新需要用到<strong>延迟标记</strong>，即给每个结点新增一个标记，记录这个结点是否被做过修改。 对于任意区间的修改，我们按照如下方式进行操作：</p><ol type="1"><li>按查询的方式将其划分成线段树中的结点；</li><li>修改这些结点的信息，并打上标记；</li><li>在修改和查询的时候，每访问到一个结点，如果该结点有标记，则执行<code>push_down</code>；</li><li><code>Push_Down</code>操作：</li></ol><ul><li>按标记对子结点进行更新；</li><li>给子结点都打上相同标记；</li><li>消掉该结点的标记。</li></ul><p>实例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> c,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R)</span><br><span class="line">    &#123;  </span><br><span class="line">        lazy[rt] += ...;</span><br><span class="line">        tree[rt] += ...;</span><br><span class="line">        <span class="keyword">return</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    PushDown(rt , r - l + <span class="number">1</span>); <span class="comment">// 向下更新</span></span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">if</span> (L &lt;= m) update(L , R , c , l, m, rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (m &lt; R) update(L , R , c , m + <span class="number">1</span>, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    PushUp(rt); <span class="comment">// 向上更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简化代码">简化代码</h3><p>在线段树中频繁用到的就是访问左儿子和访问右儿子两个操作，而查询等操作最常使用的就是根结点，我们可以利用宏定义将其简化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> root 1, n, 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br></pre></td></tr></table></figure><h2 id="基础练习题目">基础练习题目</h2><h3 id="hdu-4116-敌兵布阵">HDU 4116 敌兵布阵</h3><p>单点修改，区间查询：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> root 1, n, 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e4</span>;</span><br><span class="line"><span class="keyword">int</span> sum[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[rt] = sum[rt &lt;&lt; <span class="number">1</span>] + sum[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;sum[rt]);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(lson); build(rson);</span><br><span class="line">    push_up(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> d, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[rt] += d;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(m &gt;= k) updata(k, d, lson);</span><br><span class="line">    <span class="keyword">else</span> updata(k, d, rson);</span><br><span class="line">    push_up(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> sum[rt];</span><br><span class="line">    <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>, res(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(m &gt;= L) res = query(L, R, lson);</span><br><span class="line">    <span class="keyword">if</span>(m &lt; R) res += query(L, R, rson);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ca = <span class="number">1</span>; ca &lt;= T; ca++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>, ca);</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        build(root);</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>, op) &amp;&amp; op[<span class="number">0</span>] != <span class="string">'E'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'A'</span>) updata(a, b, root);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'S'</span>) updata(a, -b, root);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(a, b, root));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hdu-1754-i-hate-it">HDU 1754 I hate it</h3><p>单点更新，区间查询：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">222222</span>;</span><br><span class="line"><span class="keyword">int</span> MAX[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushUP</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MAX[rt] = max(MAX[rt &lt;&lt; <span class="number">1</span>], MAX[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;MAX[rt]);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build(lson); build(rson);</span><br><span class="line">PushUP(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> sc, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r)</span><br><span class="line">&#123;</span><br><span class="line">MAX[rt] = sc;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p &lt;= m) update(p, sc, lson);</span><br><span class="line"><span class="keyword">else</span> update(p, sc, rson);</span><br><span class="line">PushUP(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> MAX[rt];</span><br><span class="line"><span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>, ret(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(L &lt;= m) ret = max(ret , query(L, R, lson));</span><br><span class="line"><span class="keyword">if</span>(R &gt; m) ret = max(ret , query(L, R, rson));</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))</span><br><span class="line">&#123;</span><br><span class="line">build(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>, op, &amp;a, &amp;b);</span><br><span class="line"><span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'Q'</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(a, b, <span class="number">1</span>, n, <span class="number">1</span>));</span><br><span class="line"><span class="keyword">else</span> update(a, b, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hdu-1394-minimum-inversion-number">HDU 1394 Minimum Inversion Number</h3><p>单点更新，区间查询：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5555</span>;</span><br><span class="line"><span class="keyword">int</span> sum[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushUP</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sum[rt] = sum[rt &lt;&lt; <span class="number">1</span>] + sum[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sum[rt] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build(lson); build(rson);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r)</span><br><span class="line">&#123;</span><br><span class="line">sum[rt]++;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p &lt;= m) update(p, lson);</span><br><span class="line"><span class="keyword">else</span> update(p, rson);</span><br><span class="line">PushUP(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> sum[rt];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>, ret(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(L &lt;= m) ret += query(L, R, lson);</span><br><span class="line"><span class="keyword">if</span>(R &gt; m) ret += query(L, R, rson);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n))</span><br><span class="line">&#123;</span><br><span class="line">build(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x[i]);</span><br><span class="line">sum += query(x[i], n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">update(x[i], <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ret = sum;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">sum += n - x[i] - x[i] - <span class="number">1</span>;</span><br><span class="line">ret = min(ret, sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span> ,ret);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="poj-3468-a-simple-problem-with-integers">POJ 3468 A Simple Problem with Integers</h3><p>区间修改，区间求和（注意乘法会爆int）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">111111</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> lazy[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[rt] = sum[rt &lt;&lt; <span class="number">1</span>] + sum[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushDown</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lazy[rt])</span><br><span class="line">    &#123;</span><br><span class="line">        lazy[rt &lt;&lt; <span class="number">1</span>] += lazy[rt];</span><br><span class="line">        lazy[rt &lt;&lt; <span class="number">1</span>|<span class="number">1</span>] += lazy[rt];</span><br><span class="line">        sum[rt &lt;&lt; <span class="number">1</span>] += lazy[rt] * (m - (m &gt;&gt; <span class="number">1</span>));</span><br><span class="line">        sum[rt &lt;&lt; <span class="number">1</span>|<span class="number">1</span>] += lazy[rt] * (m &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        lazy[rt] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lazy[rt] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;sum[rt]);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">    PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> c, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        lazy[rt] += c;</span><br><span class="line">        sum[rt] += (<span class="keyword">long</span> <span class="keyword">long</span>)c * (r - l + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    PushDown(rt, r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= m) update(L, R, c, lson);</span><br><span class="line">    <span class="keyword">if</span> (m &lt; R) update(L, R, c, rson);</span><br><span class="line">    PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> sum[rt];</span><br><span class="line">    &#125;</span><br><span class="line">    PushDown(rt, r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= m) ret += query(L, R, lson);</span><br><span class="line">    <span class="keyword">if</span> (m &lt; R) ret += query(L, R, rson);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, Q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;Q);</span><br><span class="line">    build(<span class="number">1</span>, N, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (Q --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, op);</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">'Q'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(a, b, <span class="number">1</span>, N, <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">            update(a, b, c, <span class="number">1</span>, N, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他基础题目">其他基础题目</h3><ul><li>POJ 3667 Hotel：区间更新；</li><li>HDU 1540 Tunnel Warfare：单点更新，查询结点所在区间；</li><li>HDU 2871 Memory Control：与POJ 3667类似；</li></ul><h2 id="进阶题目">进阶题目</h2><p>这类题目或是写起来比较复杂，或是思维上有难度。</p><h3 id="bnuoj-51636-squared-permutation">BNUOJ 51636 Squared Permutation</h3><p>一次更新需要更新多个点，不容易刻画更新的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, i &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, i &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">111111</span>; </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[maxn], b[maxn]; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> left, right, value; </span><br><span class="line">&#125;   t[maxn &lt;&lt; <span class="number">2</span>]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     t[i].value = t[i &lt;&lt; <span class="number">1</span>].value+t[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].value; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[i].left = l; </span><br><span class="line">    t[i].right = r; </span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        t[i].value = a[a[l]]; </span><br><span class="line">        <span class="keyword">return</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>; </span><br><span class="line">    build(lson);  build(rson); </span><br><span class="line">    push_up(i); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> val, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == t[i].left &amp;&amp; k == t[i].right)</span><br><span class="line">    &#123;</span><br><span class="line">        t[i].value=val; </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (t[i].left + t[i].right) &gt;&gt; <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">if</span>(k &lt;= m) update(k, val, i &lt;&lt; <span class="number">1</span>); </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m + <span class="number">1</span> &lt;= k) update(k, val, i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>); </span><br><span class="line">    push_up(i); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == t[i].left &amp;&amp; r == t[i].right) <span class="keyword">return</span> t[i].value; </span><br><span class="line">    <span class="keyword">int</span> m = (t[i].left+t[i].right) &gt;&gt; <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">if</span>(r &lt;= m)</span><br><span class="line">        <span class="keyword">return</span> query(l, r, i &lt;&lt; <span class="number">1</span>); </span><br><span class="line">    <span class="keyword">if</span>(m + <span class="number">1</span> &lt;= l)</span><br><span class="line">        <span class="keyword">return</span> query(l, r, i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> query(lson) + query(rson); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T); </span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n, q; </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]); </span><br><span class="line">            b[a[i]] = i; </span><br><span class="line">        &#125;</span><br><span class="line">        build(<span class="number">1</span>, n, <span class="number">1</span>); </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q); </span><br><span class="line">        <span class="keyword">int</span> op, l, r; </span><br><span class="line">        <span class="keyword">while</span>(q--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;op, &amp;l, &amp;r); </span><br><span class="line">            <span class="keyword">if</span>(op == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(a[l], a[r]); </span><br><span class="line">                swap(b[a[l]], b[a[r]]); </span><br><span class="line">                update(l, a[a[l]], <span class="number">1</span>); </span><br><span class="line">                update(b[l], a[l], <span class="number">1</span>); </span><br><span class="line">                update(r, a[a[r]], <span class="number">1</span>); </span><br><span class="line">                update(b[r], a[r], <span class="number">1</span>); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(l, r, <span class="number">1</span>)); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="codeforces-gym-101116g-ground-defense">Codeforces gym 101116G Ground Defense</h3><p>区间更新，实现起来比较麻烦。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> root 1, n, 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500005</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> va[maxn &lt;&lt; <span class="number">2</span>], vd[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> lazy_a[maxn &lt;&lt; <span class="number">2</span>], lazy_d[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va[rt] = vd[rt] = lazy_a[rt] = lazy_d[rt] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va[rt &lt;&lt; <span class="number">1</span>] += lazy_a[rt];     lazy_a[rt &lt;&lt; <span class="number">1</span>] += lazy_a[rt];</span><br><span class="line">    va[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += lazy_a[rt]; lazy_a[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += lazy_a[rt];</span><br><span class="line">    lazy_a[rt] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    vd[rt &lt;&lt; <span class="number">1</span>] += lazy_d[rt];     lazy_d[rt &lt;&lt; <span class="number">1</span>] += lazy_d[rt];</span><br><span class="line">    vd[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += lazy_d[rt]; lazy_d[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += lazy_d[rt];</span><br><span class="line">    lazy_d[rt] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> d, <span class="keyword">long</span> <span class="keyword">long</span> L, <span class="keyword">long</span> <span class="keyword">long</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(R == r &amp;&amp; L == l)</span><br><span class="line">    &#123;</span><br><span class="line">        va[rt] += a; lazy_a[rt] += a;</span><br><span class="line">        vd[rt] += d; lazy_d[rt] += d;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(rt);</span><br><span class="line">    <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(R &lt;= m) update(a, d, L, R, lson);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L &gt; m) update(a, d, L, R, rson);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        update(a, d, L, m, lson);</span><br><span class="line">        update(a, d, m + <span class="number">1</span>, R, rson);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> va[rt] + l * vd[rt];</span><br><span class="line">    push_down(rt);</span><br><span class="line">    <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p &lt;= m) <span class="keyword">return</span> query(p, lson);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(p, rson);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n);</span><br><span class="line">        build(root);</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> op[<span class="number">5</span>];</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, op);</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'Q'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> idx;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;idx);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(idx, root));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'U'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> dir[<span class="number">5</span>];</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%s"</span>, dir);</span><br><span class="line">                <span class="keyword">int</span> idx, d, l, r;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> s, a;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%lld%lld%d"</span>, &amp;idx, &amp;s, &amp;a, &amp;d);</span><br><span class="line">                <span class="keyword">if</span>(dir[<span class="number">0</span>] == <span class="string">'E'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    l = idx;</span><br><span class="line">                    r = l + d - <span class="number">1</span>;</span><br><span class="line">                    s -= l * a;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    r = idx;</span><br><span class="line">                    l = r - d + <span class="number">1</span>;</span><br><span class="line">                    s += r * a;</span><br><span class="line">                    a = -a;</span><br><span class="line">                &#125;</span><br><span class="line">                update(s, a, l, r, root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hdu-5023-a-corrupt-mayors-performance-art">HDU 5023 A Corrupt Mayor’s Performance Art</h3><p>区间修改的又一典型例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __WINDOWS_</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> showtime printf(<span class="meta-string">"time = %.15f\n"</span>, clock() / (double)CLOCKS_PER_SEC);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> root 1, n, 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e6</span> + <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x, lz;</span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line">    Node(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">long</span> <span class="keyword">long</span> c, <span class="keyword">long</span> <span class="keyword">long</span> d)</span><br><span class="line">    &#123;</span><br><span class="line">        l = a; r = b; x = c; lz = d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; a[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans, b[<span class="number">45</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[rt].l == a[rt].r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(a[rt].lz == <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    a[rt &lt;&lt; <span class="number">1</span>].lz = a[rt &lt;&lt; <span class="number">1</span>].x = a[rt].lz;</span><br><span class="line">    a[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lz = a[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].x = a[rt].lz;</span><br><span class="line">    a[rt].lz = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[rt] = Node(l, r, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt, <span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[rt].l == l &amp;&amp; a[rt].r == r)</span><br><span class="line">    &#123;</span><br><span class="line">        a[rt].lz = b[op];</span><br><span class="line">        a[rt].x = b[op];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(rt);</span><br><span class="line">    <span class="keyword">int</span> m = (a[rt].l + a[rt].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= m) update(l, r, rt &lt;&lt; <span class="number">1</span>, op);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l &gt; m) update(l, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, op);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        update(lson, op);</span><br><span class="line">        update(rson, op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a[rt &lt;&lt; <span class="number">1</span>].x == a[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].x)</span><br><span class="line">        a[rt].x = a[rt &lt;&lt; <span class="number">1</span>].x;</span><br><span class="line">    <span class="keyword">else</span> a[rt].x = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[rt].x != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans |= a[rt].x;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (a[rt].l + a[rt].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    push_down(rt);</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= m) query(l, r, rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l &gt; m) query(l, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        query(lson);</span><br><span class="line">        query(rson);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">30</span>; i++)</span><br><span class="line">        b[i] = b[i - <span class="number">1</span>] * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span> &amp;&amp; n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        build(root);</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> op[<span class="number">5</span>];</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, op);</span><br><span class="line">            <span class="keyword">int</span> l, r;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'P'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">                update(l, r, <span class="number">1</span>, x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'Q'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = <span class="number">0</span>;</span><br><span class="line">                query(l, r, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> first = <span class="number">1</span>, x;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(ans &amp; <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(first == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">                        first = <span class="number">0</span>;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"%d"</span>, i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans /= <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他线段树进阶题目">其他线段树进阶题目</h3><ul><li>HDU 3308 LCIS：细节很多，非常容易错；</li><li>POJ 1436 Horizontally Visible Segments：转化为区间染色；</li><li>HDU 4747 Mex： 区间更新，区间求和；</li><li>HDU 4601 Letter Tree：线段树+字典树；</li><li>Codeforces 258E Little Elephant and Tree：DFS+线段树；</li><li>Codeforces 269D Maximum Waterfall：线段树+dp。</li></ul>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mathematica学习[1]——图像复原与处理</title>
      <link href="/2017/02/16/Mathematica%E6%8A%80%E5%B7%A7%5B1%5D%E2%80%94%E2%80%94%E5%9B%BE%E5%83%8F%E5%A4%8D%E5%8E%9F%E4%B8%8E%E5%A4%84%E7%90%86/"/>
      <content type="html"><![CDATA[<h2 id="函数介绍">函数介绍</h2><p>官方文档中对该函数的翻译是“润饰”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inpaint[image, region]</span><br><span class="line">    润饰 region 中非零元素的 image 部分</span><br></pre></td></tr></table></figure><p>Inpaint函数在使用时，需要两个参数，分别是<em>image</em>和<em>region</em>。一般来说，<em>image</em>就是需要处理的原始图像，而<em>region</em>更像是一个mask。所以Inpaint一般需要接受两个大小相同的图像，也总是会返回和image有着相同大小和类型的图片。</p><hr><p>Inpaint函数有接受Method选项，并给出如下方法：</p><table><thead><tr class="header"><th style="text-align: center;">方法</th><th style="text-align: center;">含义</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">“Diffusion”</td><td style="text-align: center;">迭代各向同性扩散方法</td></tr><tr class="even"><td style="text-align: center;">“TotalVariation”</td><td style="text-align: center;">迭代全变差方法</td></tr><tr class="odd"><td style="text-align: center;">“FastMarching”</td><td style="text-align: center;">快速行进方法</td></tr><tr class="even"><td style="text-align: center;">“NavierStokes”</td><td style="text-align: center;">Navier-Stokes 方法</td></tr><tr class="odd"><td style="text-align: center;">“TextureSynthesis”</td><td style="text-align: center;">利用随机采样的最佳拟合纹理合成方法</td></tr></tbody></table><p>默认情况下，使用TextureSynthesis方法。</p><hr><p>设置 Method-&gt;{“TotalVariation”, <em>subopt</em>} 下，可以指定下列子选项：</p><table><thead><tr class="header"><th style="text-align: center;">子操作</th><th style="text-align: center;">值</th><th style="text-align: center;">含义</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">“NoiseModel”</td><td style="text-align: center;">“Gaussian”</td><td style="text-align: center;">“Gaussian”、“Laplacian”或“Poisson”</td></tr><tr class="even"><td style="text-align: center;">“Regularization”</td><td style="text-align: center;">Automatic</td><td style="text-align: center;">正则化参数</td></tr></tbody></table><hr><p>设置 Method-&gt;{“TextureSynthesis”, <em>subopt</em>} 下，可以指定下列子选项：</p><table><thead><tr class="header"><th style="text-align: center;">子操作</th><th style="text-align: center;">值</th><th style="text-align: center;">含义</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Masking</td><td style="text-align: center;">Automatic</td><td style="text-align: center;">为二元掩模，可指定用于求出最佳拟合纹理的像素</td></tr><tr class="even"><td style="text-align: center;">“MaxSamples”</td><td style="text-align: center;">300</td><td style="text-align: center;">用于求出最佳拟合纹理的样本最大数量</td></tr><tr class="odd"><td style="text-align: center;">“NeighborCount”</td><td style="text-align: center;">30</td><td style="text-align: center;">用于纹理比较的邻近像素的数目</td></tr></tbody></table><hr><p>Inpaint 接受 MaxIterations 选项，指定使用迭代方法执行迭代的最大数. 默认设置是 MaxIterations-&gt;100。关于参数，本文不再详谈。</p><h2 id="两个应用">两个应用</h2><p>Inpaint函数有着强大的功能，在图形处理中有着不可思议的作用，以下依据<a href="http://reference.wolfram.com/language/ref/Inpaint.html" target="_blank" rel="noopener">官方文档</a>介绍Inpaint的两个较为直接的应用。</p><h3 id="修复图像损坏的部分">修复图像损坏的部分</h3><p>用合适的Mask图片传入Inpaint可以修复图像的损坏部分：</p><figure><img src="http://static.zybuluo.com/lzcwr/acvr1e10vda50lld9excuywm/image_1b95789ipkjg1gudqgq9mqrmg57.png" alt="image_1b95789ipkjg1gudqgq9mqrmg57.png-182.4kB"><figcaption>image_1b95789ipkjg1gudqgq9mqrmg57.png-182.4kB</figcaption></figure><p>在处理中也可以使用其他的Method选项：</p><figure><img src="http://static.zybuluo.com/lzcwr/xzw3f225yjm0ggjr98sfi3sr/image_1b9579v3t1mvv1nc0163e18ps27q5k.png" alt="image_1b9579v3t1mvv1nc0163e18ps27q5k.png-83.3kB"><figcaption>image_1b9579v3t1mvv1nc0163e18ps27q5k.png-83.3kB</figcaption></figure><h3 id="去除图片中较大的对象">去除图片中较大的对象</h3><p>通过调整Mask图片的形状和黑白区域分配，可以去除图片中较大的对象。以下是官方文档中的两个例子：</p><p><img src="http://static.zybuluo.com/lzcwr/3qjuejedy1c4s4ztljrc40h7/image_1b957fb3hjgqv46l3q1af9l761.png" alt="image_1b957fb3hjgqv46l3q1af9l761.png-55.6kB"> <img src="http://static.zybuluo.com/lzcwr/xbwvvxwxmytb0o8rl9uyc159/image_1b957g7671akai2lt7hsu358n6e.png" alt="image_1b957g7671akai2lt7hsu358n6e.png-99.4kB"></p><h2 id="mask图片的生成技巧">Mask图片的生成技巧</h2><p>从以上例子中可以看出，关于图像的修复和改动，最关键最核心的就是函数中的region参数，也就是Mask图片的生成。以下讨论两种生成Mask图片的方法：</p><h3 id="掩模工具">掩模工具</h3><p>利用“去除较大对象”的功能以及<code>Mathematica</code>自带的掩模工具，可以去除图片上的水印。 例如下面这张图片，也就是我的头像。来源是<a href="http://baike.baidu.com/link?url=KT1OSCvJNCAtnTD8lciSq6sfiH8Zd2hDvqy93GIykGWVhQ2sDAVivz4fyu41sHA-vu1ZWB_LDp61jTpd6GodvrEWPS9Fndw9lrQ_ek6-0xDlHnj7v4LuH5S9TmCUUIHnfPhhmYJogwklspdtxiq-HeAaWAdvJ2MZDjM3Y8v8klW" target="_blank" rel="noopener">百度百科-正一百二十胞体</a>。但图片左下角带有百度百科的水印：</p><figure><img src="http://static.zybuluo.com/lzcwr/xh1jopg1uuaq5f5k2uqoamvn/image_1b93g3b6r1ac3qugnj33q4pgj1f.png" alt="image_1b93g3b6r1ac3qugnj33q4pgj1f.png-75kB"><figcaption>image_1b93g3b6r1ac3qugnj33q4pgj1f.png-75kB</figcaption></figure><p>利用Inpaint函数可以很好地处理这件事情，以下是处理的方法：</p><ul><li>先将图片导入<code>Mathematica</code>：<img src="http://static.zybuluo.com/lzcwr/s4c1yxtq4yrk05qzuqr0wcnr/mma1-1.jpg" alt="mma1-1.jpg-20kB"></li><li>然后进行掩模，即生成一个黑白的图片，其中黑色的部分保留，白色的部分去除：<img src="http://static.zybuluo.com/lzcwr/bqzwzw262qdhi0ocq4lco285/mma1-2.jpg" alt="mma1-2.jpg-18.5kB"></li><li>掩模完成后就可以直接调用Inpaint函数将左下角的水印去掉了（<code>Mathematica</code>可以直接把图片作为参数，非常便捷）：<img src="http://static.zybuluo.com/lzcwr/hunbysi0g3gojegdgdlmmuay/mma1-3.jpg" alt="mma1-3.jpg-9.7kB"></li><li>然后将图像导出，即可得到一个没有水印的图片（如下图所示）。</li></ul><figure><img src="http://static.zybuluo.com/lzcwr/05x06nkjuw8oztloswld5zgs/image_1b93giupt1321lqv26p1b2r183p3j.png" alt="image_1b93giupt1321lqv26p1b2r183p3j.png-75.7kB"><figcaption>image_1b93giupt1321lqv26p1b2r183p3j.png-75.7kB</figcaption></figure><p>在很多情况下，用掩模工具生成Mask图片作为region参数对图像进行处理都是非常方便的。</p><h3 id="利用颜色的值自动从原图生成mask">利用颜色的值自动从原图生成Mask</h3><p>还有一种方法能够直接从原图中生成Mask图片，以下是官方文档中非常具有启发性的一个例子：</p><figure><img src="http://static.zybuluo.com/lzcwr/qfsl33sfd2l7a44mv4cdnz8a/image_1b958k6rv1mg1ai41lafg3abd26r.png" alt="image_1b958k6rv1mg1ai41lafg3abd26r.png-104.6kB"><figcaption>image_1b958k6rv1mg1ai41lafg3abd26r.png-104.6kB</figcaption></figure><p>在这个例子中，非常完美地地去掉了图片右下的日期标记，而且在命令中没有直接出现Mask图片，而是用了一行命令来自动生成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dilation[Binarize[ColorSeparate[img][[1]], 0.93], 1]</span><br></pre></td></tr></table></figure><p>其含义是：用ColorSeperate函数将图片分为RGB三层，然后将Red层像素值大于255×0.93的设为白色，其余为黑色，然后用二值化函数Binarize来生成黑白图片作为region参数。其中的Dilation函数是一个处理函数，本文不多赘述。</p><p>由这个例子，我们可以产生一种想法： 用图像处理的软件很简单地将图片中不想要的部分染色（染成一个图片当中没有的颜色），然后用上面的方法生成一个region参数，再对原图进行处理。此时便不再需要掩模：</p><ul><li>比如这样一张照片： <img src="http://static.zybuluo.com/lzcwr/o2ihbg3nlnrfe0qtvvkza3u9/image_1b94pcrduqe51l2h1k4c12hq10g240.png" alt="image_1b94pcrduqe51l2h1k4c12hq10g240.png-242.1kB"></li><li>用工具把不想要的部分染色，作为Mask <img src="http://static.zybuluo.com/lzcwr/3tin320gpf8dhifgxvor4rf9/image_1b94pkcvg9q7705s4r1fdtupo4d.png" alt="image_1b94pkcvg9q7705s4r1fdtupo4d.png-199.2kB"></li><li>运行代码可得如下结果，效果 <del>不咋地</del> 很好，但是确实能去掉该部分。（原因是像素值筛选范围的设定出现了问题，不过我比较懒，没有进行更好的调整） <img src="http://static.zybuluo.com/lzcwr/g1t9y9iqf73nf3vnxwcm08x9/image_1b94qh78nbpvmfq6tm1e471d5h4q.png" alt="image_1b94qh78nbpvmfq6tm1e471d5h4q.png-234.6kB"></li></ul><p>原理和官方文献中的类似，于是处理这样的问题<strong>只需要一行代码</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Inpaint[#1,ImageResize[Binarize[#2,#==&#123;1,0,0&#125;&amp;], ImageDimensions@#1]]&amp;[img,mask]</span><br></pre></td></tr></table></figure><h2 id="纹理和画作分析">纹理和画作分析</h2><p>如果说刚刚的功能看起来也比较平常的话，那么根据一幅画来创作一幅风格相近的画，或是分析图片中的纹理，总应该是看起来很高端很厉害的功能了。以下是官方文档中的例子：</p><ul><li>纹理合成：</li></ul><figure><img src="http://static.zybuluo.com/lzcwr/1od15epr9dwdghtqpttbo7jz/image_1b95a50op1m0h14pbs74fjdp6978.png" alt="image_1b95a50op1m0h14pbs74fjdp6978.png-125.8kB"><figcaption>image_1b95a50op1m0h14pbs74fjdp6978.png-125.8kB</figcaption></figure><ul><li>画作分析：</li></ul><figure><img src="http://static.zybuluo.com/lzcwr/00ngpy90vzmlfb2zgn2jw2l0/image_1b95auqqggfh1lic1f5k1qsq16tc7l.png" alt="image_1b95auqqggfh1lic1f5k1qsq16tc7l.png-267.5kB"><figcaption>image_1b95auqqggfh1lic1f5k1qsq16tc7l.png-267.5kB</figcaption></figure><p>有关<code>Mathematica</code>的其他资料请自行查阅。本文只做普及，不做详解。</p>]]></content>
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> Mathematica </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>调教Hexo[1]——github+hexo搭建个人网站</title>
      <link href="/2017/02/12/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <content type="html"><![CDATA[<p><code>github + hexo 搭建个人网站详细过程.</code></p><blockquote><p><strong>本文针对的主要是Windows用户，不过总体步骤和Linux/Mac大同小异。</strong></p></blockquote><a id="more"></a><ul><li><strong>本文中所有需要打开文件编辑的地方均不推荐记事本，推荐使用<a href="https://notepad-plus-plus.org/" target="_blank" rel="noopener">nodepad++</a>或<a href="http://www.sublimetext.com/" target="_blank" rel="noopener">sublime text</a>。</strong></li></ul><h2 id="环境配置">环境配置</h2><h3 id="安装git-bash">安装git bash</h3><p>直接在<a href="https://git-for-windows.github.io/" target="_blank" rel="noopener">官网</a>下载最新版本并安装；</p><h3 id="申请github账号">申请github账号</h3><p>在<a href="https://github.com/" target="_blank" rel="noopener">github</a>填写信息注册账号；</p><ul><li><strong>方便起见，以下均假设你的github用户名为 XXX.</strong></li><li><strong>方便起见，以下均假设你的github邮箱为 aa@bb.com</strong></li></ul><h3 id="建立github仓库">建立github仓库</h3><ul><li>建立一个仓库来存博客的源码，假设标题为“blog”；</li><li>建立一个github仓库，标题是<code>XXX.github.io</code>；</li></ul><h3 id="安装node.js">安装Node.js</h3><ul><li>安装Node.js：直接在Node.js<a href="https://nodejs.org/en/" target="_blank" rel="noopener">官网</a>下载最新版本并安装；</li></ul><h3 id="安装hexo">安装hexo</h3><ul><li>在git bash中执行如下命令以安装hexo（必须在安装Node.js之后进行）；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><ul><li>执行以下语句以安装hexo所需的依赖包； <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></li></ul><h2 id="搭建博客">搭建博客</h2><h3 id="本地搭建">本地搭建</h3><ul><li>任意建一个名为“hexo”文件夹，并在该文件夹下运行git bash（右键菜单中选择运行git bash）；</li><li>git bash中执行如下命令，hexo会自动将搭建所需的所有初始材料放入hexo文件夹中；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><ul><li>在git bash中运行如下命令，即可将博客的静态页面生成在<code>\hexo\public</code>目录下；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate #(或简写为 hexo g)</span><br></pre></td></tr></table></figure><ul><li>generate完毕后即可运行如下指令，成功后即可在<code>localhost:4000</code>浏览博客； <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server #(或简写为 hexo s)</span><br></pre></td></tr></table></figure></li></ul><h3 id="部署到github">部署到github</h3><ul><li>修改hexo文件夹中的<code>_config.yml</code>文件：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git #用git来部署</span><br><span class="line"># 以下两个&quot;repo&quot;任选一种即可</span><br><span class="line">    repo: https://github.com/XXX/XXX.github.io.git</span><br><span class="line">    repo: git@github.com:XXX/XXX.github.io.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure><p>保存后即可将本地博客与<code>XXX.github.io</code>建立关联；</p><ul><li>本地浏览确认无误后运行如下命令即可将博客部署到<code>XXX.github.io</code>；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy #(或简写为 hexo d)</span><br></pre></td></tr></table></figure><ul><li>部署完毕后即可在<code>XXX.github.io</code>浏览页面。</li></ul><h3 id="可能出现的问题及解决办法">可能出现的问题及解决办法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在执行 hexo d 时，可能会出现提示：</span><br><span class="line">    ERROR Deployer not found: git</span><br><span class="line">此时，需要执行如下命令：</span><br><span class="line">    npm install hexo-deployer-git --save</span><br><span class="line">完成后再执行 hexo d 即可。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在执行 hexo s 时，可能会出现提示：</span><br><span class="line">    ERROR Plugin load failed: hexo-server</span><br><span class="line">此时需要执行如下命令：</span><br><span class="line">    npm install hexo-server</span><br></pre></td></tr></table></figure><h2 id="博客源码备份">博客源码备份</h2><h3 id="git配置">git配置</h3><p>初次使用git，需要进行如下配置：</p><h4 id="全局配置">全局配置</h4><p>在git bash中依次执行如下语句以完成全局配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name XXX</span><br><span class="line">git config --global user.email aa@bb.com</span><br></pre></td></tr></table></figure><h4 id="配置ssh-key">配置ssh-key</h4><ul><li>在git bash中执行以下语句：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot; #(在github注册的邮箱)</span><br></pre></td></tr></table></figure><ul><li>添加key到ssh： 将<code>C:/Users/xxxx/.ssh/github_rsa.pub</code>中的全文复制，添加到github。 （浏览器登录github，找到<code>settings -&gt; SSH and GPG keys -&gt; new SSH key</code>粘贴进去确认即可）</li></ul><p>至此，你的github账户已经和你的电脑建立了关联。 有关SSH的更详尽步骤可以参考<a href="http://www.jianshu.com/p/21234432c94e" target="_blank" rel="noopener">这里</a>，本文不再细化。</p><h3 id="git仓库更新">git仓库更新</h3><ul><li>在hexo目录下运行git bash；</li><li>运行如下命令即可将该文件夹初始化为git仓库；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><ul><li>运行如下命令，将本地仓库至连接远程仓库(blog)；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:XXX/blog</span><br></pre></td></tr></table></figure><ul><li>依次运行如下命令，即可将源码更新至github的blog仓库，至此备份已经完成。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;message here&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>每次写新文章之后，都可以按照相同方式将源码再次更新一遍。 更多git操作可以查阅相关文档（例如<a href="http://www.liaoxuefeng.com/" target="_blank" rel="noopener">这里</a>），本文不再赘述。</p><h2 id="后续操作">后续操作</h2><h3 id="主题的选择">主题的选择</h3><p>hexo默认的主题是landscape，<del>样子比较难看</del>，网络上有各种其他样式的主题：</p><ul><li><a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">litten：yilia</a>，一个简洁优雅的hexo主题.</li><li><a href="https://github.com/forsigner/fexon/hexo-theme-yilia" target="_blank" rel="noopener">forsigner：fexo</a>，一个极简主义风格的hexo主题.</li><li><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">iissnan：next</a>，An elegant theme for Hexo.</li><li><a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="noopener">MOxFIVE：yelee</a>，简而不减Hexo双栏博客主题.</li></ul><p>例如你想用的主题是yilia，那么需要先执行如下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure><p>然后将hexo目录中的<code>_config.yml</code>文件修改为<code>theme: yilia</code>，再重新部署一次即可使用yilia主题。</p><p>在使用各种主题时，可以按照自己的需要修改主题中的<code>_config.yml</code>文件。 <strong>修改主题的各项操作均可在该主题的说明文档中查阅，本文不再赘述。</strong></p><h3 id="撰写新文章">撰写新文章</h3><ul><li>运行如下命令，在<code>hexo\source\_posts</code>文件夹中就会出现一个名为<code>AAA.md</code>的文件；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;AAA&quot;</span><br></pre></td></tr></table></figure><ul><li>按照markdown语法编辑该文件并保存；</li><li>依次运行如下命令即可完成部署。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>关于markdown语法以及编辑器可自行查阅相关资料，本文不再赘述。</p><h3 id="将博客绑定在自己的域名上">将博客绑定在自己的域名上</h3><p><strong>方便起见，假定域名为<code>www.domain.com</code>。</strong> 绑定域名步骤如下：</p><ul><li>进入仓库<code>github.com/XXX/XXX.github.io</code>，进入settings页面，在custom domain一项中填写<code>www.domain.com</code>（也可以在<code>hexo</code>目录下直接新建一个名为CNAME的文件，内容为<code>www.domain.com</code>，然后更新博客源码即可）；</li><li>然后在域名的设置页面设置解析为<code>lzcwr.github.io</code>即可。 具体解析步骤可在自己购买域名后查看，本文不再赘述。</li></ul><h3 id="hexo的常用命令">hexo的常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot; # 新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; # 新建页面</span><br><span class="line">hexo generate # 生成静态页面至public目录</span><br><span class="line">hexo server # 开启预览端口</span><br><span class="line">hexo deploy # 将.deploy目录部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  # 查看Hexo的版本</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>以上谈到的步骤按照顺序大概是：</p><ul><li>安装所需要的软件：git bash，Node.js，hexo；</li><li>申请github账号并新建仓库储存源码和博客页面；</li><li>本地配置好git：全局配置（用户名和邮箱），和SSH-key配置；</li><li>本地搭建博客：<code>hexo init</code>，<code>hexo g</code>，<code>hexo s</code>预览；</li><li>将博客部署至github：修改<code>_config.yml</code>中的<code>deploy</code>部分，执行<code>hexo g</code>，<code>hexo d</code>；</li><li>可能会出现无法部署至git的问题：安装<code>git-deployer</code>；</li><li>撰写新文章：<code>hexo new &quot;postName&quot;</code>，<code>hexo g</code>，<code>hexo d</code>；</li><li>更新源码：git操作（<code>add</code>，<code>commit</code>，<code>push</code>）。</li></ul><p>## 可能遇到的其他问题</p><h3 id="hexo与mathjax的冲突">Hexo与Mathjax的冲突</h3><p>参见<a href="http://www.lizhechen.com/2017/03/08/Hexo%E4%B8%8EMathjax%E7%9A%84%E5%86%B2%E7%AA%81%E5%8F%8A%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89%E8%A7%A3%E5%86%B3/" target="_blank" rel="noopener">Lzcwr——Hexo与Mathjax的冲突及（部分）解决</a>。</p>]]></content>
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 计算机 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
