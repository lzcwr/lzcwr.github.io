<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[论文笔记[14]——Private Pareto Optimal Exchange]]></title>
    <url>%2F2020%2F03%2F08%2FPaper-reading-14-Private-pareto-optimal-exchange%2F</url>
    <content type="text"><![CDATA[Justin Hsu 在其 STOC 2014 的工作中表明了，在 dp，甚至是放宽条件后的 Joint-dp 之下，都无法保证得到一个渐进 Pareto 最优的分配（在所有分配参与者都是理性的情况下）. 因此，在此工作中使用了比 Joint-dp 更为宽松的 Marginal-dp，并在此条件下找到了渐进 Pareto 最优的分配. Sampath Kannan, et al. Private pareto optimal exchange. ACM Transactions on Economics and Computation (TEAC), 2018.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>北大</tag>
        <tag>社会计算</tag>
        <tag>论文笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文笔记[13]——Mechanism design via differential privacy]]></title>
    <url>%2F2020%2F03%2F01%2FPaper-reading-13-Mechanism-design-via-differential-privacy%2F</url>
    <content type="text"><![CDATA[Frank McSherry, Kunal Talwar. Mechanism design via differential privacy. FOCS 2007. Paper Outline： Something about dp Approximate Truthfulness 引理 3. 对 \(\forall\) 满足\(\epsilon\)-dp 的机制 $，以及定义在其作用域上的非负函数 \(g\). 对 \(\forall D_1,D_2\) 的输入, s.t. \(|D_1\triangle D_2|=1\)，均有： \[E\left[g\left(\mathcal{M}\left(D_{1}\right)\right)\right] \leq \exp (\epsilon) \times E\left[g\left(\mathcal{M}\left(D_{2}\right)\right)\right]\] Collusion Resistance 推论 4. 对任意 \(\epsilon\)-dp 的机制 \(\mathcal{M}\) 以及定义在其作用域上的非负函数 \(g\)，对 \(\forall D_1,D_2\)，s.t. \(|D_1\triangle D_2|\leqslant t\)，总有： \[E\left[g\left(\mathcal{M}\left(D_{1}\right)\right)\right] \leq \exp (\epsilon t) \times E\left[g\left(\mathcal{M}\left(D_{2}\right)\right)\right]\] Composability 就是 dp 的结合方法，串行进程 \(\epsilon\) 相加. A General dp Mechanism domain: \(\mathcal{D}\)，range: \(\mathcal{R}\) query function：\(q:\mathcal{D}^n\times \mathcal{R}\to\mathbb{R}\)，是对 (input, output) 二元组的估值，\(q\) 越大，二者越匹配. 给定 \(d\in\mathcal{D}^n\)，我们希望给出一个机制，其输出为 \(r\in\mathcal{R}\)，s.t. \(q(d,r)\) 最大. 定义 对于 \(\forall q:\mathcal{D}^n\times\mathcal{R}\to\mathbb{R}\)，以及 \(\mathcal{R}\) 上的一个测度，定义： \[\mathcal{E}_{q}^{\epsilon}(d):=~\text{Choose}~r~\text{with probability proportional to}~\exp (\epsilon q(d, r)) \times \mu(r)\] 隐私性 定理 6. \(\mathcal{E}^\epsilon_q\) 提供 \((2\epsilon\triangle q)\)-dp 保护. 准确性 令 \(\mu(A)\) 为 \(A\subseteq\mathcal{R}\) 的测度，且 \(\mu(\mathcal{R})=1\)； 令 \(p(A)\) 为 \(\mathcal{E}_q^\epsilon(d)\) 所定义的测度（同样也进行正则化）； 令 \(OPT=\max_r q(d,r)\). 引理 7. 令 \(S_t\{r: q(d,r)&gt;OPT-t\}\)，则 \(p(\bar{S}_{2t})\) 至多为 \(\exp(\epsilon t)/\mu(S_t)\). 进一步，有如下的结果： 定理 8. 若 \(t\) 满足 \(t \geq\) \(\ln \left(O P T / t \mu\left(S_{t}\right)\right) / \epsilon,\) 则有 \(E\left[q\left(d, \mathcal{E}_{q}^{\epsilon}(d)\right)\right] \geq O P T-3 t\) Applications to Pricing and Auctions 本节将 gneral mechanism 应用于无限供给拍卖. 本节所有的机制都是 single price，且 envy-free 的. 考虑一个物品无限量供给的拍卖会： 每个参与者都有一个需求函数 \(b_i:[0,1]\to\mathbb{R}^+\)，表示在定价为 \(p\in[0,1]\) 时该参与者对物品的需求量； 为符合常理，每一个 \(b_i\) 都是不增的，且 \(\forall i,p\)，\(pb_i(p)\leqslant 1\)； 对 \(\forall\) 价格 \(p\)，我们可以卖掉 \(\sum_i b_i(p)\) 件商品，取总收益为 \(q(b,p)=p\sum_i b_i(p)\). 定理 9. 取 \(q(b, p)=p \sum_{i} b_{i}(p),\) 则 \(\mathcal{E}_{q}^{\epsilon}\) 满足 \(2 \epsilon\)-dp, 且期望收益至少为 \(O P T-3 \ln \left(e+\epsilon^{2} O P T m\right) / \epsilon,\)，其中 \(m\) 为 \(OPT\) 情形下卖掉的商品数. General mechanism 还可以推广到 attribute auctions. 所谓 attribute auction，是指在拍卖的基础上考虑竞拍者的属性，将市场进行细分，为不同的人提供不同的价格，以获得更高预期收入的一种拍卖方式. 用 \(OPT_k\) 表示分割为 \(k\) 部分的市场的最大收入； 用 \(SEG_k\) 表示 \(n\) 个竞拍者进入 \(k\) 个市场时被允许划分的部分数； 有结果表明 \(SEG_k\leqslant n^{kVC}\). 定理 10. 令 \(q\) 为将市场分割为 \(k\) 个部分的收益函数, 则 \(\mathcal{E}_{q}^{\epsilon}\) 的预期收益至少为 \[O P T_{k}-3(\ln (e+\left.\left.\epsilon^{k+1} O P T_{k} S E G_{k} m^{k}\right)\right) / \epsilon.\] 以下是一个看不懂的结果... 考虑一个约束定价问题： 这是多参数问题的一个特例，即竞拍人对 \(k\) 种不同的物品中的每一种都有一个出价，并且拍卖只能以固定价格出售最多一种物品. 每个 \(i\) 对物品 \(j\in[k]\) 有一个需求函数 \(b_i^j:[0,1]\to\mathbb{R}^+\)； 须对 \(\forall i,j,p\) 确保 \(pb_i^j(p)\leqslant 1\). \(\mathcal{R}=[k]\times\mathbb{R}\)； 对物品 \(j\)，价格为 \(p\)，可以卖掉 \(\sum_i b_i^j(p)\) 件，得到 \(q(b,(j,p))=p\sum_i b_i^j(p)\) 的收入. 定理 12. 令 \(q(b,(j, p))=p \sum_{i} b_{i}^{j}(p), \mathcal{E}_{q}^{\epsilon}\) 满足 \(2\epsilon\)-dp, 且预期收益至少为 \(O P T-3 \ln \left(e+\epsilon^{2} O P T k m\right) / \epsilon,\) 其中 \(m\) 为 \(OPT\) 情形下卖掉的商品数.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>北大</tag>
        <tag>社会计算</tag>
        <tag>论文笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文笔记[12]——Private Matchings and Allocations]]></title>
    <url>%2F2020%2F01%2F20%2FPaper-reading-12-Private-Matchings-and-Allocations%2F</url>
    <content type="text"><![CDATA[Justin Hsu, et al. Private matchings and allocations. SIAM Journal on Computing, 2016. Justin Hsu, Zhiyi Huang, Aaron Roth, Tim Roughgarden, and Zhiwei Steven Wu. Private matchings and allocations. STOC 2014. Differential Privacy &amp; Resource Allocation 文章概要 \(k\) goods：\(j\in \{1,\ldots,k\}\)，\(n\) buyers：\(i\in \{1,\ldots,n\}\); Each \(i\) has a value \(v_{ij}\in[0,1]\) for each good \(j\). Our goal 找到 buyer-good 匹配 \(\mu\)，s.t. 最大化社会总福利 \(SW=\sum\limits_{i=1}^nv_{i,\mu(i)}\). 隐私性问题：values 是敏感信息，会涉及隐私. 因此，需要一个不会泄露 values 的匹配机制. DP在此问题上的局限性 It is not hard to see that this goal is impossible under the standard notion of differential privacy. 作者认为，DP 要求分配方案（输出）对 \(v_{ij}\) （输入）不敏感，但这是不可能的.. 解决方法：使用 Kearns 等在 2014 年提出的联合差分隐私（Joint DP） 思路：将 Market Clearing prices 与 DP 结合 使用 Walrasian equilibrium prices： 在 Joint DP 的要求下计算 Walrasian equilibrium prices. Kelso 和 Crawford 在 1982 的经典分析：用递增价格拍卖来计算 Walrasian... 基础知识 物品集 \(G\)，以及 agent 集合 \([n]\)： 每个 agent \(i\in[n]\) 都有一个估值函数 \(v_i:2^G\to [0,1]\)； 一个可行的分配是一列集合 \(S_1,\ldots,s_n\subseteq G\)，s.t. \(S_i\cap S_j=\varnothing\)，\(\forall i\neq j\). 上述分配的社会总福利为 \(\sum\limits_{i=1}^n v_i(S_i)\). 最大社会总福利 \(OPT=\max\limits_{S_1,\ldots,S_n}\sum\limits_{i=1}^n v_i(S_i)\). 我们考虑一个比较简单的估值函数：一个人只要一个物品.(unit demand valuation) 但本文的结果对于 gross substitute valuation 也同样成立(简言之，就是物品 \(i\) 涨价会使得其他物品更受欢迎，参见 wiki: Gross substitutes). 形式化描述 价格向量 \(\{p_g\}_{g\in G}\)，物品集 \(S\) 对参与者 \(i\) 的效用为 \(u_i(S,p)=v_i(S)-\sum\limits_{j\in S}p_j\). 若定价 \(p\) 和 \(p&#39;\) 满足 \(p_g\leqslant p&#39;_g\)，\(\forall g\in G\)，则记为 \(p \preceq p^{\prime}\). 在定价 \(p\) 下，参与者 \(i\in[n]\) 最想要的物品集为 \(\omega(p)=\arg \max\limits _{S \subseteq G} u_{i}(S, p)\). Def 现有估值函数 \(v_i: 2^G\to [0,1]\)，如果对于定价向量 \(p\preceq p&#39;\) 以及 \(\forall S\in\omega(p)\)，若 \(S&#39;\subseteq S\) 满足 \(p&#39;_g=p_g\)，\(\forall g\in S&#39;\)，则存在 \(S^*\in\omega(p)\)，s.t. \(S&#39;\subset S^*\)，则称 \(v_i\) 满足 gross substitutes. 这个定义很别扭...我没懂 本文的工作还是只考虑了一人一个物品的情况. 设共有 \(k\) 种物品，代表元为 \(g_1,\ldots,g_k\in G\) 若所有人都认为两个物品 \(g_1,g_2\in G\) 等值，则这两个物品就被认为是相同的. 差分隐私 Def of DP 若算法 \(\mathcal{M}: C^{n} \rightarrow \mathcal{R}\) 满足 \(\forall D,D&#39;\in C^n\)，s.t. \(|D\triangle D&#39;|=1\)，以及 \(\forall S\subseteq \mathcal{R}\)，总有\[\operatorname{Pr}[\mathcal{M}(D) \in S] \leq e^{\epsilon} \operatorname{Pr}\left[\mathcal{M}\left(D^{\prime}\right) \in S\right]+\delta\]则称 \(\mathcal{M}\) 是 \((\epsilon,\delta)\)-差分隐私的. 若 \(\delta=0\)，则称为 \(\epsilon\)-差分隐私. 由于在资源分配问题中，输出结果是 \(n\) 元集列，因而 \(\mathcal{M}\) 的陪域为 \((2^G)^n\). Joint DP 若算法 \(\mathcal{M}: C^n\to (2^G)^n\) 满足：对 \(\forall i\) 以及 \(i\)-neighbors \(D,D&#39;\in C^n\)，以及 \(S\subseteq (2^G)^n\)，总有： \[\operatorname{Pr}\left[\mathcal{M}(D)_{-i} \in S\right] \leq e^{\epsilon} \operatorname{Pr}\left[\mathcal{M}\left(D^{\prime}\right)_{-i} \in S\right]+\delta\] 则称其满足 \((\epsilon,\delta)\)-联合差分隐私. DP Counter 一个二进制串 \(\sigma=(\sigma_1,\ldots,\sigma_T)\in\{0,1\}^T\)，计数器 \(\mathcal{M}\) 给出了 \(c_\sigma(t)=\sum\limits_{i=1}^t \sigma_i\) 的一个近似. 计数器的 \(\alpha,\beta\)-有效性 若 \(\forall t\in [T]\)，\(\operatorname{Pr}[|\mathcal{M}(\sigma)(t)-c_\sigma(t)|\leqslant\alpha]\geqslant 1-\beta\)，则称 \(\mathcal{M}\) 是 \((\alpha,\beta)\)-有效的. 定理 Chen 等在2011 年提出的计数器 \(\mathbf{Counter}(\epsilon,T)\) 对于01串的每一位，是 \(\epsilon\)-差分隐私的，且是 \((\alpha,\beta)\)-有效的，其中 \[\alpha=\frac{2 \sqrt{2}}{\epsilon} \ln (2 / \beta) \log (T)^{5 / 2}.\] 隐私化的最大匹配 \(n\) 个人，\(k\) 种物品，每种 \(s\) 个. 估值函数 \(v_{ij}\in[0,1]\) 定价向量 \(p\in[0,1]^k\)，分配方案 \(\mu: [n]\to[k]\cup\{\perp\}\) \(\perp\) 的解释：未匹配到物品的人被统一匹配到一个虚拟物品，记作 \(\perp\). Def 给定定价向量 \(p\in[0,1]^k\) 以及从人到物的匹配 \(\mu:[n]\to[k]\cup\{\perp\}\)，若 \(\mu\) 满足： 至少 \((1-\rho)\) 比例的人匹配到的物品是 \(\alpha\)-最优的； 即对至少 \((1-\rho)\) 比例的 \(i\) 而言，有 \(v_{i \mu(i)}-p_{\mu(i)} \geq v_{i j}-p_{j}-\alpha\)，\(\forall j\). 每种物品被分配的量不能超过总供应量； 每种供不应求的物品(over-demanded)都会被抢光，除非其供应量不超过 \(\beta\). 原文：each over-demanded good clears except for at most β supply. 则称其是一个 \((\alpha,\beta,\rho)\)-近似匹配. 算法描述：PMatch Algorithm 修改版的延迟认可(deferred acceptance)算法 [Kelso and Crawford 1982] Propose Function 同时进行 \(k\) 场竞价选举，每场代表一种物品. 任意时刻，每种物品的 proposal price 为 \(p_j\). 给所有参与者规定一个（大家都知道的）顺序，依次访问每一个人. 给访问到的未被匹配到物品的参与者分配一个对他而言效用最大的物品. Bid Function 很想吐槽一下。。。文章写得不像人话... 对每类物品来说：申请与某类物品匹配的前 \(s\) 名暂时获得该类物品 对某物品而言，若某个人比其当前持有者出价更高，则该物品将易主. 对每个物品的出价每次上涨固定值 \(\alpha\).]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>北大</tag>
        <tag>社会计算</tag>
        <tag>论文笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北京大学群表示论试题]]></title>
    <url>%2F2020%2F01%2F07%2F%E5%8C%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E7%BE%A4%E8%A1%A8%E7%A4%BA%E8%AE%BA%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[2019 - 2020 学年 秋季学期 研究生课程 群表示论 王立中老师 19-20学年秋 群表示论 王立中老师 前 6 题每题 15 分，第 7 题 10 分..这里没有记下第 7 题...（学得太差...Orz） 证明有限群 \(G\) 的不可约复表示只有有限多个，且其特征标线性无关.（所有不可约表示都在正则表示中出现，因而只有有限多，线性无关用正交关系证明） 设 \(K\) 是特征为 \(p&gt;0\) 的域，\(G\) 是有限群，证明 \(K[G]\) 半单当且仅当 \(p\) 不整除 \(G\) 的阶.（Serre 习题 6.1，互素推半单同 Serre 书 Thm 1 的证明，半单推互素用反证法） 设 \(K\) 是一个有限域，\(H\) 是 \(\mathrm{SL}_n(K)\) 中所有上三角矩阵所构成的子群. 设有乘法群同态 \(\omega: K^*\to\mathbb{C}^*\)，且 \(\omega^2\neq 1\). 则 \(H\) 有 \(1\) 级表示：\[\chi_\omega\left(\begin{bmatrix} a &amp; b \\ 0 &amp; d \\ \end{bmatrix}\right)=\omega(a).\]证明 \(\chi_\omega\) 的诱导表示不可约.（Serre 习题 7.4，用 Mackey 判定） 设 \(X\) 是 \(G\) 的子群族，考虑映射：\[\mathbb{C}\otimes\operatorname{Ind}:\mathbb{C}\otimes \bigoplus\limits_{H\in X}R(H)\to \mathbb{C}\otimes R(G)\] \[\mathbb{C}\otimes\operatorname{Res}:\mathbb{C}\otimes R(G)\to \mathbb{C}\otimes \bigoplus\limits_{H\in X}R(H)\]证明： \(\mathbb{C}\otimes \operatorname{Ind}\) 的像是环 \(\mathbb{C}\otimes R(G)\) 的理想；（用 \(\operatorname{Ind}(\varphi\cdot\operatorname{Res}\psi) = \operatorname{Ind}\varphi\cdot \psi\)） 证明 \(\mathbb{C}\otimes\operatorname{Ind}\) 是满射当且仅当 \(\mathbb{C}\otimes\operatorname{Res}\) 是单射. 求二面体群 \(D_{10}\) 的特征标表，并求其在域 \(\mathbb{Q}(\sqrt{2})\) 上所有表示的 Schur 指数.（特征标表见 Serre 书 chp 5，Schur 指标是 \(1\)，参见 Serre 习题 12.1） 证明： 有限群 \(G\) 的所有特征标都可以写为单项特征标的整系数线性组合；（特征标 \(\to\) 初等子群 \(\to\) 单项特征标） 证明交错群 \(A_5\) 至少有一个特征标不能写为单项特征标的正实系数线性组合.（Serre 习题 10.5） 还有一个题，但敝人才疏学浅...并不会做...也没有记下是什么题.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>抽象代数</tag>
        <tag>各种试卷</tag>
        <tag>表示论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法期末复习小记]]></title>
    <url>%2F2019%2F12%2F30%2F%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[很久不写题，手法生疏.. 做个简短记录吧，或是卡的比较久的题，或是手生忘记怎么写的题. Dynamic Median：堆 Ultra-QuickSort：线段树+离散化/树状数组+离散化/归并 重要逆序对：归并/线段树+离散化/树状数组+离散化 Dynamic Median http://algorithm.openjudge.cn/19exfinalsim/C 不算困难的题目... 用对顶堆解决：建一个最大堆 max_heap 和一个最小堆 min_heap，保持： max_heap 的堆顶始终小于等于 min_heap 的堆顶； 两个堆的元素个数差不超过 \(1\). 事实上，保持 max_heap 元素更多，且比 min_heap 多不超过 \(1\) 个元素即可. 写完之后先 TLE 一发，稍作优化之后便是 RE + WA...？？？经过多次修改尝试（炸OJ）之后，发现是 unsigned int 的问题...负数的情况会和 int 有所不同... 简单总结一下：priority_queue 的 size() 方法返回值是 unsigned int，所以不要乱做减法... 贴一份 AC 代码吧... 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int t; scanf("%d", &amp;t); while (t--) &#123; std::priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; min_heap; std::priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; max_heap; int N; scanf("%d", &amp;N); while (N--) &#123; char op[5]; scanf("%s", op); if (op[0] == 'I') &#123; int x; scanf("%d", &amp;x); if (max_heap.empty()) max_heap.push(x); else &#123; if (x &lt; max_heap.top()) max_heap.push(x); else min_heap.push(x); &#125; // 之前写的是 max_heap.size() - min_heap.size() &gt;= 2 // 因此在把 if 改成 while 后会反复执行非常多次... 提交结果会是 MLE. // 但正常情况下，这里的 if 改成 while 是没有任何问题的. if (max_heap.size() &gt;= min_heap.size() + 2) &#123; min_heap.push(max_heap.top()); max_heap.pop(); &#125; if (max_heap.size() &lt; min_heap.size()) &#123; max_heap.push(min_heap.top()); min_heap.pop(); &#125; &#125; if (op[0] == 'D') &#123; max_heap.pop(); if (max_heap.size() &lt; min_heap.size()) &#123; max_heap.push(min_heap.top()); min_heap.pop(); &#125; &#125; if (op[0] == 'Q') printf("%d\n", max_heap.top()); &#125; &#125; return 0;&#125; Ultra-QuickSort http://bailian.openjudge.cn/practice/2299/ 求逆序...数字范围很大，因此需要离散化. 因为结果可能爆 int 而 WA 很多发...（当然，也有树状数组的做法，以及归并的做法） 线段树做法 严格来说这份代码采取的思路并不能算作真正的离散化. 这里的做法是对每个 \(a_i\)，把下标 \(i\) 与值 \(a_i\) 都存下来，存到 \((val,idx)\) 这样结构的二元组中，那么初始状况下，所有二元组是按照 \(idx\) 排序的，我们需要求 \(val\) 序列的逆序数. 这等价于将 \(val\) 排序后，求 \(idx\) 序列的逆序数. 而 \(idx\) 的取值范围就是 \([1,n]\)，因此只需要开规模为 \(n\) 的线段树即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;#define lson l, m, rt &lt;&lt; 1#define rson m + 1, r, rt &lt;&lt; 1 | 1#define root 1, n, 1const int maxn = 500005;int sum[maxn &lt;&lt; 2];vector&lt;pair&lt;int, int&gt;&gt; v;void pushup(int rt)&#123; sum[rt] = sum[rt &lt;&lt; 1] + sum[rt &lt;&lt; 1 | 1];&#125;void build(int l, int r, int rt)&#123; if (l == r) &#123; sum[rt] = 0; return; &#125; int m = (l + r) &gt;&gt; 1; build(lson); build(rson); pushup(rt);&#125;void update(int x, int l, int r, int rt)&#123; if (l == r) &#123; sum[rt]++; return; &#125; int m = (l + r) &gt;&gt; 1; if (x &lt;= m) update(x, lson); else update(x, rson); pushup(rt);&#125;int query(int l, int r, int rt, int ll, int rr)&#123; if (ll &lt;= l &amp;&amp; rr &gt;= r) return sum[rt]; int ret = 0; int m = (l + r) &gt;&gt; 1; if (ll &lt;= m) ret += query(lson, ll, rr); if (rr &gt; m) ret += query(rson, ll, rr); return ret;&#125;int main()&#123; int n; while (scanf("%d", &amp;n) != EOF) &#123; if (n == 0) break; memset(sum, 0, sizeof(sum)); v.clear(); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); v.push_back(make_pair(x, i)); &#125; stable_sort(v.begin(), v.end()); long long res = 0; for (int i = 0; i &lt; v.size(); i++) &#123; update(v[i].second, 1, maxn, 1); res += query(1, maxn, 1, v[i].second + 1, maxn); &#125; printf("%lld\n", res); &#125; return 0;&#125; 归并排序做法 一个很标准的用归并求逆序的做法... 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500005;int n, x[maxn], f[maxn];long long Merge_Sort(int l, int r, int *a, int *b)&#123; if (r - l == 1) return 0; int m = (l + r) &gt;&gt; 1; long long ans = Merge_Sort(l, m, a, b) + Merge_Sort(m, r, a, b); int p = l, q = m, c = l; while (p &lt; m || q &lt; r) &#123; if (q &gt;= r || (p &lt; m &amp;&amp; a[p] &lt;= a[q])) b[c++] = a[p++]; else &#123; ans += m - p; b[c++] = a[q++]; &#125; &#125; for (int i = l; i &lt; r; i++) a[i] = b[i]; return ans;&#125;int main()&#123; while (scanf("%d", &amp;n) != EOF) &#123; if(n == 0) break; for (int i = 0; i &lt; n; i++) scanf("%d", &amp;x[i]); printf("%lld\n", Merge_Sort(0, n, x, f)); &#125; return 0;&#125; 重要逆序对 http://algorithm.openjudge.cn/201919191919/18xlyB/ 归并做法 一直不会的归并排序...学♂习一下.. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 5;int n, a[maxn], b[maxn];long long res;int Binary_Search(int l, int r, int val)&#123; int ret = r + 1; while (l &lt;= r) &#123; if (l == r) &#123; if (a[l] &gt; val) ret = l; break; &#125; int m = (l + r) &gt;&gt; 1; if (a[m] &gt; val) &#123; ret = m; r = m; &#125; else l = m + 1; &#125; return ret;&#125;void merge(int l, int m, int r)&#123; int i = l, j = m + 1, cnt = 0; while (cnt &lt; r - l + 1) &#123; if (i &gt; m) b[cnt++] = a[j++]; else if (j &gt; r) b[cnt++] = a[i++]; else if (a[i] &gt; a[j]) &#123; res += m - Binary_Search(i, m, 2 * a[j]) + 1; b[cnt++] = a[j++]; &#125; else b[cnt++] = a[i++]; &#125; for (int k = 0; k &lt; cnt; k++) a[l + k] = b[k];&#125;void Merge_Sort(int l, int r)&#123; if (l == r) return; int m = (l + r) &gt;&gt; 1; Merge_Sort(l, m); Merge_Sort(m + 1, r); merge(l, m, r);&#125;int main()&#123; while (scanf("%d", &amp;n) != EOF) &#123; if(n == 0) break; res = 0; for (int i = 0; i &lt; n; i++) scanf("%d", &amp;a[i]); Merge_Sort(0, n - 1); printf("%lld\n", res); &#125; return 0;&#125; 线段树做法 夏令营和算法期末考试都写挂的题...（都写的是线段树，但甚至没有过样例Orz）一定要用线段树写过... 一开始妄想直接从 Ultra-Quicksort 的代码改，但 val 序列的重要逆序很难转换为 idx 序列的逆序（也可能是我没想到）. 因此转而考虑将序列 \(a_1,\ldots,a_n\) 直接离散化，依次将其插入线段树，对每个 \(i\) 都查询比 \(2a_i\) 大的个数，并存到答案中. 但是这样会出问题：\(2a_i\) 可能超过原先 \(a\) 的取值范围，从而导致一些问题. 解决办法很简单，倒序插入，然后查询小于 \(a_i/2\) 的数即可. 随后因为 \(a_i/2\) 可能不是整数的情况费了一番功夫...然后才成功 AC... 果然是菜... 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;using namespace std;#define lson l, m, rt &lt;&lt; 1#define rson m + 1, r, rt &lt;&lt; 1 | 1#define root 1, maxn, 1const int maxn = 400005;int origional_a[maxn], a[maxn], uniqued_a[maxn], half_a[maxn];int sum[maxn &lt;&lt; 2];void pushup(int rt)&#123; sum[rt] = sum[rt &lt;&lt; 1] + sum[rt &lt;&lt; 1 | 1];&#125;void build(int l, int r, int rt)&#123; if (l == r) &#123; sum[rt] = 0; return; &#125; int m = (l + r) &gt;&gt; 1; build(lson); build(rson); pushup(rt);&#125;void update(int x, int l, int r, int rt)&#123; if (l == r) &#123; sum[rt]++; return; &#125; int m = (l + r) &gt;&gt; 1; if (x &lt;= m) update(x, lson); else update(x, rson); pushup(rt);&#125;long long query(int l, int r, int rt, int ll, int rr)&#123; if (ll &lt;= l &amp;&amp; rr &gt;= r) return sum[rt]; long long ret = 0; int m = (l + r) &gt;&gt; 1; if (ll &lt;= m) ret += query(lson, ll, rr); if (rr &gt; m) ret += query(rson, ll, rr); return ret;&#125;int main()&#123; int n; while (scanf("%d", &amp;n) != EOF) &#123; if(n == 0) break; memset(sum, 0, sizeof(sum)); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;origional_a[i]); origional_a[i] *= 2; // 保证除以2还是整数 a[i] = origional_a[i]; uniqued_a[i] = origional_a[i]; &#125; sort(uniqued_a + 1, uniqued_a + 1 + n); int sz = unique(uniqued_a + 1, uniqued_a + 1 + n) - uniqued_a - 1; for(int i = 1; i &lt;= n; i++) &#123; a[i] = lower_bound(uniqued_a + 1, uniqued_a + sz + 1, origional_a[i]) - uniqued_a; a[i] *= 2; // 变成整数 half_a[i] = lower_bound(uniqued_a + 1, uniqued_a + sz + 1, origional_a[i] / 2) - uniqued_a; half_a[i] = 2 * half_a[i] - 1; // 保证顺序 &#125; long long res = 0; for (int i = n; i &gt;= 1; i--) &#123; update(a[i], root); res += query(root, 1, half_a[i]); &#125; printf("%lld\n", res); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>计算机</tag>
        <tag>算法</tag>
        <tag>北大</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文笔记[11]——Gibbard-Satterthwaite 定理]]></title>
    <url>%2F2019%2F12%2F04%2F%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-11-%E2%80%94%E2%80%94Gibbard-Satterthwaite-%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[文章：Svensson L G, Reffgen A. The proof of the Gibbard–Satterthwaite theorem revisited[J]. Journal of Mathematical Economics, 2014, 55: 11-14. Gibbard-Satterthwaite 定理：对于至少有 \(3\) 个候选人的投票，若它是 中立 且 strategy-proof 的，则它一定是一个 dictatorial. The voting model \(N=\{1,\ldots,1\}\) voter； \(A=\{a_1,\ldots,a_m\}\) 候选人； 偏好 \(P\)：\(A\) 上的序. 序 \(P\) 的第 \(k\) 位用 \(r_k(P)\) 表示. \(A\) 上的所有偏好用 \(\Sigma\) 表示. i.e. profile \((P_1,\ldots,P_n)\in\Sigma^n\). \(P_{-i}\)：\(P\) 的序列中抠掉 voter \(i\)，\(P_{-\{i,j\}}\) 同理. 一个投票规则是映射 \(f:\Sigma^n\to A\). Def. 1 (strategy-proof) Def. 2 (dictatorial) Def. 3 (neutral) Gibbard-Satterwaite theorem 候选人至少三个，若投票机制 \(f\) 是满射，则 \(f\) 是 strategy-proof 的 \(\Rightarrow\) \(f\) 是 dictatorial. Two basic properties of strategy-proof rules Lemma 1 （单调性） 设 \(f\) 是 strategy-proof rule. 若 \(f(P_1,\ldots,P_n)=a\) 且对 \((P_1&#39;,\ldots,P_n&#39;)\in\Sigma^n\) 有 \(a P_i x\Rightarrow a P_i&#39; x\)，\(\forall i\in N, \forall x\in A\)，则 \(f(P_1&#39;,\ldots,P_n&#39;)=a\). 总结一下：只要大家在谎报偏好时，都没有降低 \(a\) 的位次，那么结果就仍然会是 \(a\). Lemma 2 （Pareto 最优） 设 \(f\) 是 strategy-proof 的满射. 若 \((P_1,\ldots,P_n)\in\Sigma^n\) 对 \(\forall i\in N\) 都满足 \(aP_ib\)，则 \(f(P_1,\ldots,P_n)\neq b\). 一种归纳证明 先来一个例子： \(N=\{1,2\}\)，\(A=\{a,b,c\}\)，\(P=(P_1,P_2)\). 我们需要在 \(N\) 中找一个 dictator. 考虑 \(P_1=(a,b,c), P_2=(b,a,c), P_2&#39;=(b,c,a)\)：不妨设 \(f(P_1,P_2)=a\). 由 Pareto 最优性，\(f(P_1,P_2)\neq c\). 考虑到 \(a,b\) 的对称性，不妨设 \(f(P_1,P_2)=a\). 由 Pareto 最优性，\(P_1\) 和 \(P_2&#39;\) 中，\(b\) 都比 \(c\) 好，故 \(f(P_1,P_2&#39;)\neq c\). 由 strategy-proof 可知 \(f(P_1,P_2&#39;)\neq b\). 换言之，\(f(P_1,P_2&#39;)\) 只能是 \(a\). 这实际上是在说，\(1\) 是 dictator. 我们现在来证明，每个候选人都存在一个 dictator. 先考虑 \(n=2\) 情形.，我们来证明如下定理： Th. 1. 设 \(N=\{1,2\}\)，且 \(|A|\geqslant 3\)，则 strategy-proof 的满射都是 dictatorial. Proof. 取 \(a,b\in A\)，构造 \((\bar{P_1},\bar{P_2})\in \Sigma^2\)，s.t. 其第一位和第二位分别是 \(ab\) 和 \(ba\). 不妨设 \(f(\bar{P_1},\bar{P_2})=a\). 然后证明无论 \(2\) 怎么改偏好，都不会改变最终结果. 以下引理对于归纳至关重要： Lemma 3. 令 \(f: \Sigma^n\to A\) 是满射，且是 strategy-proof 的. 对于 \(i,j\in N\)，定义 \(f_{i,j}\)： \[f_{i,j}: \Sigma^{n-1}\to A, ~~~(P_i,P_{-\{i,j\}})\mapsto f(P_i,P_i,P_{-\{i,j\}}).\] 则 \(f_{i,j}\) 也是满射，并且也是 strategy-proof 的. Proof. 满射比较容易证明，可直接由 \(f\) 是满射得到. 对于 strategy-proof 性质，首先我们考虑除 \(i,j\) 外的其他 voter. 如果存在一个非 \(i,j\) 的 voter 能够操纵投票结果，这将与 \(f\) 的 strategy-proof 性质矛盾. 换言之，只有 \(i\) 和 \(j\) 有可能能够操纵投票结果. 我们再对 \(i\) 和 \(j\) 进行讨论即可. Th. 2 若候选人的个数至少是 \(3\)，则 strategy-proof 的满射 \(f\) 一定是 dictatorial. Proof. 现在只需要考虑 \(n\geqslant 3\) 的情况了，设 \(&lt;n\) 的情形全部成立，下证 \(n\) 的情形成立. 考虑 \(n\) 情形下的 \(f\)，则其诱导的 \(f_{i,j}\) 都是 strategy-proof 的满射，因而都是 dictatorial. 则有且仅有以下两种情况： 对于一些 \(f_{i,j}\)，dictator 是某个 \(k\in N\backslash\{a,b\}\)，则可证明（用 lemma 1 的单调性） \(k\) 同样是 \(f\) 的 dictator. 对 \(\forall f_{i,j}\)，\(i\) 是 dictator，可以证明这种情况是不可能的. 中立情形下的直接证明 两个前提：(1) 中立，(2) \(m\geqslant n\). （Excuse me？？投票人比候选人还少？？） Theorem 3. 至少 \(3\) 个候选人，且 \(m\geqslant n\). 则 neutral + strategy-proof \(\Rightarrow\) dictatorial. Proof. 令 \(P\in\Sigma\)，s.t. \(r_k(P)=a_k\)，取 \(A\) 上的置换 \(\pi\)：\(\pi(a_k)=\begin{cases} a_{k+1}, &amp; 1\geqslant k\geqslant n - 1\\ a_1, &amp; k=n\\ a_k, &amp; k&gt;n \end{cases}\)，考虑 profile \(\left(P, \pi P, \pi^{2} P, \ldots, \pi^{n-1} P\right) \in\Sigma^n\)，这时前 \(n\) 个候选人的标号恰好完全轮换了一次. 这时 \(a_n\) 及下标更小的 \(a_i\) 要比下标更大的 \(a_j\) Pareto 占优（为什么？），因此由(1) neutral \(\Rightarrow\) surjective; (2) Lemma 2. 可得 \(f\left(P, \pi P, \ldots, \pi^{n-1} P\right)=a_{i}\)，其中 \(i\leqslant n\)，那么不妨设它就是 \(a_1\). 现在，取 profile \(\left(P_{1}^{\prime}, \ldots, P_{n}^{\prime}\right) \in \Sigma^{n}\)，s.t. 在这个 profile 中，只有\(1\) 把 \(a_1\) 排第一，\(a_n\) 排第二；其他人都把 \(a_n\) 排第一，\(a_1\) 排第二. 那么，相比 \((P,\pi P,\ldots)\) 那个 profile，\(a_1\) 的地位没有下降，故 \(f(P_1&#39;,\ldots,P_n&#39;)=a_1\). 现在来定义一列 profile： \(\left(P_{1}^{1}, \ldots, P_{n}^{1}\right)=\left(P_{1}^{\prime}, \ldots, P_{n}^{\prime}\right)\)； 当 \(j\geqslant 2\) 时，对 \(i\neq j\)，取 \(P_i^j=P_i^{j-1}\)；对 \(i=j\)，取 \(r_1(P_i^i)=a_n\)，\(r_m(P_i^i)=a_1\). 由 Pareto 最优性，\(f\left(P_{1}^{j}, \ldots, P_{n}^{j}\right) \in\left\{a_{1}, a_{n}\right\}\)，而 strategy-proof 要求这个结果不能是 \(a_n\). 那就只能是 \(a_1\) 了！进一步，在 \((P_1^n,\ldots,P_n^n)\) 中，除了 \(1\) 把 \(a_1\) 放在第一位之外，其他人都把 \(a_1\) 放到了最后. 但尽管如此，选举的获胜者仍然是 \(a_1\). 单调性告诉我们，这里没有别的原因，只能说 \(a_1\) 真的强. 换言之，voter \(1\) 是一个 dictator.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>北大</tag>
        <tag>社会计算</tag>
        <tag>论文笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文笔记[10]——Voting, the Symmetric Group, and Representation Theory]]></title>
    <url>%2F2019%2F11%2F21%2F%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-10-%E2%80%94%E2%80%94Voting-the-Symmetric-Group-and-Representation-Theory%2F</url>
    <content type="text"><![CDATA[用杨表和 tabloid 来描述偏好和选票； 将计票过程是为模同态，进而应用 Schur 引理等表示论的内容来研究投票过程. 基础知识 整数划分与 tabloid 称 \(\lambda=(\lambda_1,\ldots,\lambda_m)\)，s.t. \(\sum\limits_{i=1}^m \lambda_i=n\) 为 \(n\) 的一个分解(composition)，若该序列是递减的，则称为一个划分(partition)； 给定 \(n\) 的划分 \(\lambda\)，考虑 \(n\) 个方块的一个图表，第 \(i\) 行有 \(\lambda_i\) 个格子，这样的图表称为形状为 \(\lambda\) 的杨表； 现给出杨表的一个等价关系：每行的元素集合相等，则两个杨表等价，容易验证这是一个等价关系； 杨表在该等价关系下的一个等价类叫做一个（形状为 \(\lambda\) 的） tabloid. 形状为 \(\lambda\) 的全体 tabloid 记为 \(X^\lambda\)； \(X^\lambda\) 上所有函数 \(f: X^\lambda\to\mathbb{Q}\) 记作 \(M^\lambda\). \(X^\lambda\) 中所有元的示性函数构成 \(M^\lambda\) 的一组基，进而有 \(\dim M^\lambda=|X^\lambda|\). 与投票建立联系 偏好与 tabloid：\(i\succ j\iff i\) 在 \(j\) 的上层；\(i\sim j\iff i\) 与 \(j\) 在同一层. 换言之，一个序就是一个 tabloid. 进一步，给定 \(\lambda\) 之后，一个 profile 就是一个 \(p\in M^\lambda\). 偏序与全序的转化： 偏序 \(\to\) 全序：同一行的权重均分； 转化的映射：\(\iota: M^\lambda\to M^{(1,\ldots,1)}\). 对称群 \(S_n\) 的作用 \(S_n\) 在 \(X^\lambda\) 上有自然的左乘作用. 可通过定义 \((\sigma p)(x)=p(\sigma^{-1}x)\) 将该作用提升到 \(M^\lambda\) 上. 进一步可扩展为 \(\mathbb{Q}S_n\) 的作用. 这说明什么？？？这意味着什么？？？意味着 \(M^\lambda\) 是 \(\mathbb{Q}S_n\)-模. 从现在开始，主要讨论全序（\(\lambda=(1,\ldots,1)\)）情形. 对投票过程的分析 投票？模同态！ 这里主要讨论的是位置投票(positional voting) 以及孔多塞投票 (Condorcet voting) 位置投票制 核心：权重向量 \(w=[w_1,\ldots,w_n]^T\). 计票：映射 \(T_w: M^{(1,\ldots,1)}\to M^{(1,n-1)}\). 这个映射的线性性很好验证. 位置投票的中立性告诉我们 \(\forall \sigma\in S_n\)，总有 \(T_w(\sigma p)=\sigma T_w(p)\). 这意味着什么？？？意味着 \(T_w\) 与群运算相容. 换言之，\(T_w\) 是模同构！ 孔多塞投票 定义这里不多赘述. 其核心是拉两个元素出来配对比较. 因而其计票过程是一个配对映射 \(P: M^{(1,\ldots,1)}\to M^{(1,1,n-2)}\)（同样可以验证其线性性） 类似地，\(P\) 也是模同态. 那这样，我们用群表示的芝士知识来分析分析吧. 首先，\(\mathbb{Q}\) 是一个特征为 \(0\) 的域，因此我们可以做什么？可以用 Maschke 定理. 即所有的 \(M^\lambda\) 都是半单的，即可以分解为 \(\mathbb{Q}S_n\) 单模的直和. - 这里在GTM 203里有经典的结果：specht module. 这个结果正是利用整数拆分来做的. 那我们就把 \(M^\lambda\) 拆成不可约模的直和，然后呢？ 然后可以用 Schur 引理啊！这样我们就可以知道哪些选票是有用的，哪些是无用的了. 进一步还可以得到一些其他的结果. 值得一提的是，这些结果与 Saari 先前的一些结果能够相互印证. 部分序情形：Approval voting 这一部分讨论给全序加断点后的故事，即 \(\lambda=(1,\ldots,1,n-k)\). Borda count 的特殊性 总的来说，我觉得这篇文章没有真正落实作者的豪言壮语...&quot;重建了一些 voting paradox&quot;...嗯？没找着...]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>北大</tag>
        <tag>社会计算</tag>
        <tag>论文笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文笔记[9]——Strategy-proof allocation of indivisible goods]]></title>
    <url>%2F2019%2F10%2F23%2F%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-9-%E2%80%94%E2%80%94Strategy-proof-allocation-of-indivisible-goods%2F</url>
    <content type="text"><![CDATA[文章：Svensson L G. Strategy-proof allocation of indivisible goods[J]. Social Choice and Welfare, 1999, 16(4): 557-567. 其实是夏老师 Allocating Indivisible Items in Categorized Domains 一文的单类型版本. 主要结果：strategyproof, nonbossy 且中立的分配机制 \(f\) 一定是 serial dictatorial. Lemma 1 设 \(f\) 是 strategyproof 且 nonbossy 的，若 \(u,v\in\mathscr{U}\) 满足：\(\forall i\in N,\forall x\in A\)，\(u_i(x)\leqslant u_i(f_i(u)) \Rightarrow v_i(x)\leqslant v_i(f_i(u))\)，则 \(f(v)=f(u)\). 换言之：\(v\) 只要没有扩大 \(u\) 中优于 \(f_i(u)\) 的集合，就不会改变分配结果. 证明：先证 \(f(v_i, u_{-i})=f(u)\)，再取 \(u^{p}=(v_1,\ldots,v_{p-1},u_p,\ldots u_n)\) 进行证明. Lemma 2 设 \(f\) strategyproof, nonbossy 且中立的机制，profile \(u\) 中所有人的偏好都相同，则其分配结果是 Pareto 最优的. 证明：反证法，假设不是 Pareto efficient，则存在一个 \(a\in A-\{f_i(u): i\in N\}\)，s.t. ... Thm 1 strategyproof, nonbossy 且中立的分配机制 \(f\) 一定是 serially dictatorial. 同时，也容易验证 serially dictatorial 满足上述三条性质. 值得注意的是，在 Thm 1 中，nonbossy 是必须的，否则 \(f\) 未必是 serially dictatorial. - 若将其去掉，文中给出了反例； - 若将其替换为 pareto consistency，文中也给出反例. Lemma 3 对 \(\forall u\in\mathscr{U}\)，恰好存在一个 core allocation \(\varphi\). 同时存在一个与之相对应的 \(N\) 的划分 \(\{N_j\}_{j=1}^r,~r\leqslant n\)，s.t. \[A_j=\varphi(N_j)对 \forall 1\leqslant j\leqslant r 是\text{cycle}，且若 i\in N_j，则 u_i(\varphi(i))\geqslant u_i(a),~\forall a\in A-\bigcup\limits_{k=1}^{j-1}A_k.\] Thm. 2 一个 strategyproof，individually rational 且 pareto consistent 的机制 \(f\) 是一个 core mechanism.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>北大</tag>
        <tag>社会计算</tag>
        <tag>论文笔记</tag>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Something about 四色猜想]]></title>
    <url>%2F2019%2F10%2F21%2F%E5%9B%9B%E8%89%B2%E7%8C%9C%E6%83%B3%2F</url>
    <content type="text"><![CDATA[许进老师《现代图论》课中所讲授的四色猜想的相关内容. 基础知识 这里只讨论有限平面图，且无自环、重边. 一些相关概念介绍如下（图的定义、Euler公式、Kuratowski定理等不再赘述）： 图的染色（着色） 给图的顶点赋权（一般为整数，当然，不是整数也可以强行调整为整数...），相邻顶点不同权. 四色猜想 任意平面图都是可以 \(4\)-染色的. 导出子图 设有图 \(G=(V,E)\)，及其顶点集的子集 \(V&#39;\subset V\)，记 \(E&#39;=\{(u,v)\in E:u,v\in W\}\)，则称 \(G&#39;(V&#39;)=(V&#39;,E&#39;)\) 为 \(V&#39;\) 的导出子图. 随便举个例子吧：\(K_n\) 的任意 \(m\) 元子集的导出子图都是 \(K_m\). （当然，\(m\leqslant n\) ...） 极大平面图 顾名思义，就是边已经多到极限的平面图，以至于再加一条边，它就不是平面图了. 极大平面图又称三角剖分图，其每个面都是三角（二维单形就是三角，课上许老师没有提单形的故事，但其实单形剖分是在任何维度存在的）； 任何一个图都可以通过不断加边而变成一个极大平面图。 符号说明 \(n\)：点数； \(m\)：边数； \(\delta\)：图中顶点的最小度数. 关键术语： Kempe 链：只含两种颜色的链. Kempe 变换：一种通过换色来减少颜色的技巧. Kempe 的证明思路 用数学归纳法： 容易验证 \(n\leqslant 5\) 时，所有的极大平面图都可以被 \(4\)-染色. 设 \(n\leqslant p\) 时，所有 \(n\) 个顶点的极大平面图都可以被 \(4\)-染色，考虑 \(p+1\) 的情. 由 Euler 公式可知，对于极大平面图，有 \(3\leqslant \delta\leqslant 5\)，故分三种情况讨论： \(\delta=3\)： 由于 \(\delta=3\)，故必定会存在一个 \(3\) 度顶点，即有图中所示的结构. 记 \(G&#39;=G-D\)，则 \(|G&#39;|=p\)，因而可以被 \(4\)-染色. 而 \(D\) 相邻的 \(A,B,C\) 点也至多占掉三种颜色，故此时的图 \(G\) 是可以被 \(4\)-染色的. \(\delta=4\)： 同上，会存在一个图示的结构，记 \(G&#39;=G-E\)，则 \(G&#39;\) 有一个 \(4\)-染色. 若 \(A,B,C,D\) 只用了至多 \(3\) 种颜色，则可以完全沿用上述方法. 因此只讨论 \(A,B,C,D\) 分别用了颜色 \(1,2,3,4\) 的情形. 此时采用的办法被称为 Kempe 变换： 考虑 \(G&#39;\) 中，颜色 \(1\) 和 \(3\) 的导出子图 \(G&#39;[1,3]\)： 若 \(A\) 和 \(C\) 不在 \(G&#39;[1,3]\) 的同一个连通分支内，则可以将其中一者（不妨设是 \(A\)）所在的连通分支上的 \(1\) 与 \(3\) 全部交换，该种转换不会产生颜色的冲突. 转换完毕后，\(A\) 与 \(C\) 将变为同色，即 \(A,B,C,D\) 只占三种颜色； 若 \(A\) 和 \(C\) 在 \(G&#39;[1,3]\) 的同一连通分支内，则必定存在一条连接 \(A\) 与 \(C\) 的 \(1-3-1-3-\cdots\) 路径（这样的路径称为 Kempe 链）. 此时考虑 \(G&#39;[2,4]\)，则 \(B\) 和 \(D\) 一定不在 \(G&#39;[2,4]\) 的同一连通分支内（有点像 Jordan 闭曲线定理的那种感觉，\(B\) 和 \(D\) 一个在内一个在外），即可以对 \(G&#39;[2,4]\) 做变换，此时也可转换为 \(A,B,C,D\) 只占三种颜色的情形. \(\delta=5\)： 同样会存在一个图示的结构，记 \(G&#39;=G-F\)，则 \(G&#39;\) 存在一个 \(4\)-染色. 若 \(A,B,C,D,E\) 只用了至多 \(3\) 种颜色，则很容易给出该种情形的一个 \(4\)-染色. 当 \(A,B,C,D,E\) 恰好用了 \(4\) 种颜色时，必定有且仅有两个顶点同色，不失一般性，设 \(f(A)=1,f(B)=f(E)=2,f(C)=3,f(D)=4\). 此时考虑 \(G&#39;[1,3]\) 和 \(G&#39;[1,4]\)： 若 \(A,C\) 和 \(A,D\) 至少有一对在相应的导出子图上不连通，则可以直接采取换色的方式消灭掉颜色 \(1\)，此时在 \(G\) 中给 \(F\) 染颜色 \(1\) 即可. 若 \(A,C\) 和 \(A,D\) 在相应的导出子图上都连通，则在 \(G&#39;\) 中存在一条连接 \(A,C\) 的 \(1-3-1-3\cdots\) 链和一条连接 \(A,D\) 的 \(2-4-2-4\cdots\) 链，分别将 \(B\) 与 \(E\) 包围. 故类似 \(\delta=4\) 的情况，不难发现此时不存在 \(E\to C\) 和 \(B\to C\) 的 Kempe 链，因而进行两次换色，即可将颜色 \(2\) 消除. 进一步给 \(F\) 染颜色 \(4\) 即可得到 \(G\) 的 \(4\)-染色. 听起来很简单，不是吗？但很遗憾这个证法是错误的. 错误的关键就在于：虽然图中有一条 \(A\to C\) 和一条 \(A\to D\) 的 Kempe 链，但这两条链可能在处 \(A\) 点之外的其他地方也有交点，这可能会导致我们在后面消除颜色 \(2\) 的换色过程中失败. 听起来好绕啊！那就详细说说... 当 \(\delta=5\)，且 \(|f\{A,B,C,D,E\}|=4\)，且 \(A,C\) 在 \(G&#39;[1,3]\) 中连通，\(A,D\) 在 \(G&#39;[1,4]\) 中连通时，我们需要进行两次换色： 在 \(G&#39;[2,3]\) 中，将 \(E\) 所在的连通分支中的所有 \(2\) 和 \(3\) 对换，即可将 \(E\) 换为颜色 \(3\). 在 \(G&#39;[2,4]\) 中，将 \(B\) 所在的连通分支中的所有 \(2\) 和 \(4\) 对换，即可将 \(B\) 换为颜色 \(4\). 两次换色后，\(A,B,C,D,E\) 的颜色分别为 \(1,4,3,4,3\)，成功减少了一种颜色！ 那么，问题出在哪里呢？ 就是上述过程中，第一次换色完全可能影响到第二次换色. 试想，如果第一次换色使得 \(B\) 和 \(D\) 在 \(G&#39;[2,4]\) 中连通了怎么办？第二次换色就无法进行了！！那我们构造 \(G\) 的 \(4\)-染色的计划就失败了（ 那么，什么情况会导致第二次换色失败呢？ 我们要让第一次和第二次换色产生关系. 因此我们努力让它们换色的前提产生关系. 那就是说，我们要让 \(A\to C\) 的 Kempe 链与 \(A\to D\) 的 Kempe 链在 \(A\) 以外的一点相交，这样两次换色就可以互相干扰了. 事实上，Heawood 给出的反例正是应用了这个思路. 其具体的反例如下图所示： 虽然 Kempe 没有成功证明四色定理，但 Kempe 的工作仍然是非常有意义的，在其做法的基础上稍加改动，即可证明比四色定理稍弱的五色定理. 后来 Appel–Haken 对 Kempe 变换失效的不可约情形进行了研究，并利用计算机给出了证明. 对 Kempe 工作的进一步思考 既然两条 Kempe 链相交会导致 Kempe 变换失效，那么我们就需要寻找不相交的 Kempe 链. Mr. Xu 的猜想！ 对于 \(\delta=5\) 的情形，对任意一个 \(5\) 度顶点 \(v_0\)（\(N(v_0)=\{v_1,v_2,v_3,v_4,v_5\}\)），都存在 \(G&#39;\) 的一种染色方案 \(f\)，s.t. 存在 \(v_1\to v_3\) 和 \(v_1\to v_4\) 两条 Kempe 链，且这两条链仅在 \(v_1\) 相交. 若能证明这个猜想，那当然能修复 Kempe 的证明.（不过我8太看好... 貌似 Heawood 的图中，中心的 \(5\) 度顶点就根本不行... 我始终觉得这个猜想只需要存在性就行了（存在一个 \(5\) 度顶点...），但 Mr. Xu 课上说的的确是任意... 迷惑...]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>计算机</tag>
        <tag>北大</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019算法分析和复杂性理论课程作业]]></title>
    <url>%2F2019%2F10%2F16%2F2019%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%92%8C%E5%A4%8D%E6%9D%82%E6%80%A7%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[没来由地...突然很想记录一下... 第一次上机作业（09.09 - 09.23）：http://algorithm.openjudge.cn/hw201901/ 第二次上机作业（10.14 - 10.28）：http://algorithm.openjudge.cn/hw201902/ 第三次上机作业（10.28 - 11.18）：http://algorithm.openjudge.cn/hw201903/ 第四次上机作业（11.18 - 12.16）：http://algorithm.openjudge.cn/201904/ 第一次上机作业代码 A. 石头剪刀布：模拟 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;int a[maxn], b[maxn];int main()&#123; int n, na, nb; scanf("%d%d%d", &amp;n, &amp;na, &amp;nb); for(int i = 0; i &lt; na; i++) scanf("%d", &amp;a[i]); for(int i = 0; i &lt; nb; i++) scanf("%d", &amp;b[i]); int awin(0), bwin(0), draw(0); for(int i = 0; i &lt; n; i++) &#123; if(a[i % na] == 0 &amp;&amp; b[i % nb] == 0) draw++; if(a[i % na] == 0 &amp;&amp; b[i % nb] == 2) awin++; if(a[i % na] == 0 &amp;&amp; b[i % nb] == 5) bwin++; if(a[i % na] == 2 &amp;&amp; b[i % nb] == 0) bwin++; if(a[i % na] == 2 &amp;&amp; b[i % nb] == 2) draw++; if(a[i % na] == 2 &amp;&amp; b[i % nb] == 5) awin++; if(a[i % na] == 5 &amp;&amp; b[i % nb] == 0) awin++; if(a[i % na] == 5 &amp;&amp; b[i % nb] == 2) bwin++; if(a[i % na] == 5 &amp;&amp; b[i % nb] == 5) draw++; &#125; if(awin &gt; bwin) printf("A\n"); if(bwin &gt; awin) printf("B\n"); if(awin == bwin) printf("draw\n"); return 0;&#125; B: 汉诺塔问题(Hanoi)：递归 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;int n;char s[3][2];void solve(char a, char b, char c, int n)&#123; if(n == 1) printf("%d:%c-&gt;%c\n", n, a, c); else &#123; solve(a, c, b, n - 1); printf("%d:%c-&gt;%c\n", n, a, c); solve(b, a, c, n - 1); &#125;&#125;int main()&#123; scanf("%d", &amp;n); for(int i = 0; i &lt; 3; i++) scanf("%s", s[i]); solve(s[0][0], s[1][0], s[2][0], n); return 0;&#125; C: 二维数组右上左下遍历：模拟 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;int row, col;int a[maxn][maxn];bool judge(int x, int y)&#123; if (x &lt; 0 || y &lt; 0) return false; if (x &gt; row - 1 || y &gt; col - 1) return false; return true;&#125;int main()&#123; scanf("%d%d", &amp;row, &amp;col); for(int i = 0; i &lt; row; i++) for(int j = 0; j &lt; col; j++) scanf("%d", &amp;a[i][j]); for(int y = 0; y &lt; col; y++) &#123; int r = 0; int c = y; while(judge(r, c)) printf("%d\n", a[r++][c--]); &#125; for(int x = 1; x &lt; row; x++) &#123; int r = x; int c = col-1; while(judge(r, c)) printf("%d\n", a[r++][c--]); &#125; return 0;&#125; 另一个做法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;int a[maxn][maxn];int n, m;bool judge(int x, int y)&#123; if(x &lt; 0 || y &lt; 0) return false; if(x &gt; n - 1 || y &gt; m - 1) return false; return true;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) scanf("%d", &amp;a[i][j]); int r = 0, c = 0; bool state = true; while(state) &#123; printf("%d\n", a[r][c]); if(judge(r + 1, c - 1)) &#123; r = r + 1; c = c - 1; &#125; else &#123; if(judge(0, r + c + 1)) &#123; int tmp = r; r = 0; c = tmp + c + 1; &#125; else &#123; if(judge(r + c + 2 - m, m - 1)) &#123; r = r + c + 2 - m; c = m - 1; &#125; else state = false; &#125; &#125; &#125; return 0;&#125; D: 由中根序列和后根序列重建二叉树：递归 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;std::vector&lt;int&gt; node;int tree[65536];void solve(int l, int r, int rt, int idx)&#123; tree[idx] = node[rt]; if (l == r) return; int pos, lson, rson; for (pos = l; pos &lt;= r; pos++) if (node[pos] == node[rt]) break; if (pos &gt; l) &#123; lson = rt - r + pos - 1; printf(" %d", node[lson]); solve(l, pos - 1, lson, idx &lt;&lt; 1); &#125; if (pos &lt; r) &#123; rson = rt - 1; printf(" %d", node[rson]); solve(pos + 1, r, rson, (idx &lt;&lt; 1) + 1); &#125;&#125;int main()&#123; int x; while (scanf("%d", &amp;x) != EOF) node.push_back(x); int n = node.size(); printf("%d", node[n - 1]); solve(0, (n &gt;&gt; 1) - 1, n - 1, 1); return 0;&#125; E: 文本二叉树：先建树/然后遍历/关键是建树 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;std::vector&lt; std::pair&lt;int, char&gt; &gt; v;std::vector&lt;int&gt; g[maxn];bool vis[maxn];void init()&#123; v.clear(); for(int i = 0; i &lt; maxn; i++) g[i].clear();&#125;void addedge(int u, int v)&#123; g[u].push_back(v);&#125;void build(int n)&#123; for(int i = 1; i &lt; n; i++) &#123; int dep = v[i].first; char key = v[i].second; for(int j = i - 1; j &gt;= 0; j--) if(g[j].size() &lt; 2 &amp;&amp; v[j].first == dep - 1 &amp;&amp; v[j].second != '*') &#123; addedge(j, i); break; &#125; &#125;&#125;void PreOrder(int s)&#123; if(v[s].second == '*') return; printf("%c", v[s].second); for(int i = 0; i &lt; g[s].size(); i++) PreOrder((g[s][i])); return ;&#125;void InOrder(int s)&#123; if(v[s].second == '*') return ; if(g[s].size() &gt; 0) InOrder(g[s][0]); printf("%c", v[s].second); if(g[s].size() &gt; 1) InOrder(g[s][1]); return ;&#125;void PostOrder(int s)&#123; if(v[s].second == '*') return; for(int i = 0; i &lt; g[s].size(); i++) PostOrder(g[s][i]); printf("%c", v[s].second); return ;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--) &#123; init(); char s[maxn]; scanf("%s", s); v.push_back(make_pair(0, s[0])); while(scanf("%s", s) != EOF) &#123; if(s[0] == '0') break; int len = strlen(s); v.push_back(make_pair(len - 1, s[len - 1])); &#125; int n = v.size(); build(n); PreOrder(0); printf("\n"); PostOrder(0); printf("\n"); InOrder(0); printf("\n"); if(t) printf("\n"); &#125; return 0;&#125; 更“正统”的做法是这样...用二叉树的方法来做二叉树的题...故称正统 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;char s[maxn];struct node&#123; char name; node *lson, *rson; int len, cnt;&#125;;node *build()&#123; int top = 1; std::stack&lt;node *&gt; stk; scanf("%s", s); node *root = new node; root-&gt;name = s[0]; root-&gt;lson = NULL; root-&gt;rson = NULL; root-&gt;len = 0; root-&gt;cnt = 0; stk.push(root); while (scanf("%s", s) != EOF) &#123; if (s[0] == '0') break; int len = strlen(s); node *new_Node = new node; new_Node-&gt;name = s[len - 1]; new_Node-&gt;lson = NULL; new_Node-&gt;rson = NULL; new_Node-&gt;len = len - 1; new_Node-&gt;cnt = 0; node *r = stk.top(); while (new_Node-&gt;len - r-&gt;len != 1) &#123; stk.pop(); r = stk.top(); &#125; if (new_Node-&gt;name == '*') &#123; r-&gt;cnt++; continue; &#125; if (r-&gt;cnt == 0) &#123; r-&gt;lson = new_Node; r-&gt;cnt++; &#125; else if (r-&gt;cnt == 1) &#123; r-&gt;rson = new_Node; r-&gt;cnt++; &#125; if (r-&gt;cnt == 2) stk.pop(); stk.push(new_Node); &#125; return root;&#125;void PreOrder(node *root)&#123; if (!root) return; printf("%c", root-&gt;name); PreOrder(root-&gt;lson); PreOrder(root-&gt;rson);&#125;void InOrder(node *root)&#123; if (!root) return; InOrder(root-&gt;lson); printf("%c", root-&gt;name); InOrder(root-&gt;rson);&#125;void PostOrder(node *root)&#123; if (!root) return; PostOrder(root-&gt;lson); PostOrder(root-&gt;rson); printf("%c", root-&gt;name);&#125;int main()&#123; int t; scanf("%d", &amp;t); while (t--) &#123; node *root = build(); PreOrder(root); printf("\n"); PostOrder(root); printf("\n"); InOrder(root); printf("\n"); if (t != 0) printf("\n"); &#125; return 0;&#125; F: 棋盘问题：DFS 计数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 25;char mp[maxn][maxn];int vis[maxn];int n, k, ans;void init()&#123; memset(vis, false, sizeof(vis)); memset(mp, false, sizeof(mp)); ans = 0;&#125;void dfs(int x, int y)&#123; if(y &gt;= k) &#123; ans++; return ; &#125; for(int i = x; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; if(!vis[j] &amp;&amp; mp[i][j] == '#') &#123; vis[j] = true; dfs(i + 1 , y + 1); vis[j] = false; &#125; &#125; &#125;&#125;int main()&#123; while(scanf("%d%d", &amp;n, &amp;k) != EOF) &#123; init(); if(n == -1 &amp;&amp; k == -1) break; for(int i = 0; i &lt; n; i++) scanf("%s", mp[i]); dfs(0, 0); printf("%d\n", ans); &#125; return 0;&#125; 第二次上机作业代码 A: 仙岛求药：最最 naive 的 BFS 搜索 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 25;const int dx[] = &#123;0, 1, 0, -1&#125;;const int dy[] = &#123;1, 0, -1, 0&#125;;int n, m;char mp[maxn][maxn];int step[maxn][maxn];void init()&#123; memset(step, -1, sizeof(step));&#125;bool judge(int x, int y)&#123; if (x &lt; 0 || y &lt; 0) return false; if (x &gt;= n || y &gt;= m) return false; if (mp[x][y] == '#') return false; return true;&#125;int main()&#123; while (scanf("%d %d", &amp;n, &amp;m) != EOF) &#123; if (m == 0 &amp;&amp; n == 0) break; init(); for (int i = 0; i &lt; n; i++) scanf("%s", mp[i]); int sx, sy; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (mp[i][j] == '@') &#123; sx = i; sy = j; break; &#125; std::queue&lt;std::pair&lt;int, int&gt;&gt; Q; Q.push(make_pair(sx, sy)); step[sx][sy] = 0; bool state = false; int ans; while (!Q.empty()) &#123; int xx = Q.front().first; int yy = Q.front().second; if (mp[xx][yy] == '*') &#123; state = true; ans = step[xx][yy]; break; &#125; for (int i = 0; i &lt; 4; i++) &#123; int tmpx = xx + dx[i]; int tmpy = yy + dy[i]; if (judge(tmpx, tmpy) &amp;&amp; step[tmpx][tmpy] == -1) &#123; Q.push(make_pair(tmpx, tmpy)); step[tmpx][tmpy] = step[xx][yy] + 1; &#125; &#125; Q.pop(); &#125; if (!state) printf("-1\n"); else printf("%d\n", ans); &#125; return 0;&#125; B: Butterfly：染色判断二分图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1005;int n, m, color[maxn];std::vector&lt;std::pair&lt;int, int&gt;&gt; g[maxn];void init()&#123; memset(color, 0, sizeof(color)); for (int i = 0; i &lt; n; i++) g[i].clear();&#125;void addedge(int u, int v, int w)&#123; g[u].push_back(make_pair(v, w)); g[v].push_back(make_pair(u, w));&#125;bool dfs(int u, int c)&#123; color[u] = c; int sz = g[u].size(); for (int i = 0; i &lt; sz; i++) &#123; int v = g[u][i].first; int w = g[u][i].second; if (w == 0) // same color &#123; if (color[v] == -c) return false; if (color[v] == 0 &amp;&amp; !dfs(v, c)) return false; &#125; if (w == 1) // diff color &#123; if (color[v] == c) return false; if (color[v] == 0 &amp;&amp; !dfs(v, -c)) return false; &#125; &#125; return true;&#125;int main()&#123; while (scanf("%d%d", &amp;n, &amp;m) != EOF) &#123; init(); while (m--) &#123; int a, b, color; scanf("%d%d%d", &amp;a, &amp;b, &amp;color); addedge(a, b, color); &#125; if (dfs(0, 1)) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; C: 区间合并：For 一遍判断是否有不相交 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 50005;const int inf = 0x3f3f3f3f;std::pair&lt;int, int&gt; x[maxn];bool inter(std::pair&lt;int, int&gt; x, std::pair&lt;int, int&gt; y)&#123; if (x.first &lt; y.first &amp;&amp; x.second &lt; y.first) return false; if (y.first &lt; x.first &amp;&amp; y.second &lt; x.first) return false; return true;&#125;std::pair&lt;int, int&gt; Union(std::pair&lt;int, int&gt; x, std::pair&lt;int, int&gt; y)&#123; return make_pair(min(x.first, y.first), max(x.second, y.second));&#125;int main()&#123; int n; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) scanf("%d %d", &amp;x[i].first, &amp;x[i].second); sort(x, x + n); bool state = true; for (int i = 1; i &lt; n; i++) &#123; if (inter(x[0], x[i])) x[0] = Union(x[0], x[i]); else &#123; state = false; break; &#125; &#125; if (state) printf("%d %d\n", x[0].first, x[0].second); else printf("no\n"); return 0;&#125; D: Radar Installation：贪心 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1005;int n, d;std::pair&lt;int, int&gt; p[maxn];std::pair&lt;double, double&gt; r[maxn];double dis(int x)&#123; return (double)sqrt((double)(d * d - x * x));&#125;int main()&#123; int cas(0); while (scanf("%d%d", &amp;n, &amp;d) != EOF) &#123; if (n == 0) break; bool state = true; for (int i = 0; i &lt; n; i++) &#123; scanf("%d%d", &amp;p[i].first, &amp;p[i].second); if (p[i].second &gt; d) state = false; &#125; if (state) &#123; for (int i = 0; i &lt; n; i++) &#123; r[i].first = p[i].first - dis(p[i].second); r[i].second = p[i].first + dis(p[i].second); &#125; sort(r, r + n); int res(0), p(0); while (p &lt; n) &#123; double rx = r[p].second; p++; while (p &lt; n &amp;&amp; (double)(r[p].first) &lt;= rx) &#123; rx = min(rx, r[p].second); p++; &#125; res++; &#125; printf("Case %d: %d\n", ++cas, res); &#125; else printf("Case %d: -1\n", ++cas); &#125; return 0;&#125; E: The Unique MST：判断 mst 唯一性/求次小并与之比较即可 Kruskal 求出 mst 并存起来，枚举 mst 中的边，将其删掉并在剩余图中求 mst，这些 mst 中最小者即为次小生成树。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;const int inf = 0x3f3f3f3f;int fa[maxn];std::vector&lt;int&gt; mst;struct Edge&#123; int u, v, w; Edge() &#123;&#125; Edge(int _u, int _v, int _w) : u(_u), v(_v), w(_w) &#123;&#125;&#125;;std::vector&lt;Edge&gt; e;void addedge(int u, int v, int w)&#123; e.push_back(Edge(u, v, w));&#125;bool cmp(Edge a, Edge b)&#123; return a.w &lt; b.w;&#125;int Find(int x)&#123; while(fa[x] != x) x = fa[x]; return x;&#125;void init()&#123; e.clear(); mst.clear();&#125;int Kruskal(int n)&#123; for(int i = 1; i &lt;= n; i++) fa[i] = i; sort(e.begin(), e.end(), cmp); int cnt(0), ans(0); for (int i = 0; i &lt; e.size(); i++) &#123; int u = e[i].u; int v = e[i].v; int w = e[i].w; int t1 = Find(u); int t2 = Find(v); if (t1 != t2) &#123; ans += w; fa[t1] = t2; cnt++; mst.push_back(i); &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; else return ans;&#125;int fuckyou(int n, int skip)&#123; for (int i = 1; i &lt;= n; i++) fa[i] = i; int cnt(0), ans(0); for (int i = 0; i &lt; e.size(); i++) &#123; if (i == skip) continue; int u = e[i].u; int v = e[i].v; int w = e[i].w; int t1 = Find(u); int t2 = Find(v); if (t1 != t2) &#123; ans += w; fa[t1] = t2; cnt++; &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; else return ans;&#125;int main()&#123; int t; scanf("%d", &amp;t); while (t--) &#123; init(); int n, m; scanf("%d%d", &amp;n, &amp;m); while (m--) &#123; int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); addedge(a, b, c); &#125; int x = Kruskal(n), y = inf; for (int i = 0; i &lt; mst.size(); i++) &#123; int tmp = fuckyou(n, mst[i]); if (tmp != -1 &amp;&amp; tmp &lt; y) y = tmp; &#125; if (x == y) printf("Not Unique!\n"); else printf("%d\n", x); &#125; return 0;&#125; F: Sorting It All Out：拓扑排序并判断排序是否唯一 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 30;int n, m;int vis[maxn], indeg[maxn], in[maxn];std::vector&lt;int&gt; g[maxn];std::vector&lt;int&gt; ans;void addedge(int u, int v)&#123; g[u].push_back(v);&#125;void init()&#123; for(int i = 0; i &lt; maxn; i++) g[i].clear(); memset(indeg, 0, sizeof(indeg)); ans.clear();&#125;int toposort()&#123; ans.clear(); int ret_state(1); for(int i = 0; i &lt; n; i++) in[i] = indeg[i]; std::queue&lt;int&gt; Q; for(int i = 0; i &lt; n; i++) if(in[i] == 0) Q.push(i); while(!Q.empty()) &#123; if(Q.size() &gt; 1) ret_state = 0; int u = Q.front(); for(int i = 0; i &lt; g[u].size(); i++) &#123; int v = g[u][i]; if(--in[v] == 0) Q.push(v); &#125; ans.push_back(u); Q.pop(); &#125; if(ans.size() &lt; n) return -1; return ret_state;&#125;int main()&#123; while(scanf("%d%d", &amp;n, &amp;m) != EOF) &#123; if(n == 0 &amp;&amp; m == 0) break; init(); int state(0); for(int step = 1; step &lt;= m; step++) &#123; char s[5]; scanf("%s", s); if(state != 0) continue; int u = s[0] - 'A'; int v = s[2] - 'A'; // u &lt; v ====&gt; Edge u -&gt; v addedge(u, v); indeg[v]++; state = toposort(); if(state == 1) &#123; printf("Sorted sequence determined after %d relations: ", step); for(int i = 0; i &lt; ans.size(); i++) printf("%c", 'A' + ans[i]); printf(".\n"); &#125; if(state == -1) printf("Inconsistency found after %d relations.\n", step); &#125; if(state == 0) printf("Sorted sequence cannot be determined.\n"); &#125; return 0;&#125; 第三次上机作业代码 A: 求逆序对数：线段树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;#define lson l, m, rt &lt;&lt; 1#define rson m + 1, r, rt &lt;&lt; 1 | 1const int maxn = 20000 + 5;int sum[maxn &lt;&lt; 2];std::vector&lt; std::pair&lt;int, int&gt; &gt; v;void pushup(int rt)&#123; sum[rt] = sum[rt &lt;&lt; 1] + sum[rt &lt;&lt; 1 | 1];&#125;void update(int p, int l, int r, int rt)&#123; if (l == r) &#123; sum[rt]++; return; &#125; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) update(p, lson); else update(p, rson); pushup(rt);&#125;int query(int ll, int rr, int l, int r, int rt)&#123; if (ll &lt;= l &amp;&amp; rr &gt;= r) return sum[rt]; int ret = 0; int m = (l + r) &gt;&gt; 1; if(ll &lt;= m) ret += query(ll, rr, lson); if(rr &gt; m) ret += query(ll, rr, rson); return ret;&#125;int main()&#123; int n; while (scanf("%d", &amp;n), n) &#123; memset(sum, 0, sizeof(sum)); v.clear(); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); v.push_back(make_pair(x, i)); &#125; stable_sort(v.begin(), v.end()); int res = 0; for (int i = 0; i &lt; v.size(); i++) &#123; update(v[i].second, 1, maxn, 1); res += query(v[i].second + 1, maxn, 1, maxn, 1); &#125; printf("%d\n", res); &#125; return 0;&#125; B: Raid：暴力求解最近点对 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1005;struct Point&#123; double x, y;&#125; p[maxn], q[maxn];double d(Point a, Point b)&#123; return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--) &#123; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) scanf("%lf%lf", &amp;p[i].x, &amp;p[i].y); for(int i = 0; i &lt; n; i++) scanf("%lf%lf", &amp;q[i].x, &amp;q[i].y); double res = 1e15; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) res = min(res, d(p[i], q[j])); printf("%.3f\n", res); &#125; return 0;&#125; C: 公共子序列：LCS 动态规划 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 205;char s1[maxn], s2[maxn];int dp[maxn][maxn], n1, n2;void init()&#123; for(int i = 0; i &lt; maxn; i++) dp[i][0] = 0; for(int i = 0; i &lt; maxn; i++) dp[0][i] = 0; for(int i = 1; i &lt;= n1; i++) for(int j = 1; j &lt;= n2; j++) &#123; if(s1[i - 1] == s2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); &#125;&#125;int main()&#123; while(scanf("%s %s", s1, s2) != EOF) &#123; memset(dp, 0, sizeof(dp)); n1 = strlen(s1), n2 = strlen(s2); init(); printf("%d\n", dp[n1][n2]); &#125; return 0;&#125; D: 股票买卖：动态规划 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;int t, n, a[maxn];int dp1[maxn], dp2[maxn];int main()&#123; scanf("%d", &amp;t); while(t--) &#123; memset(dp1, 0, sizeof(dp1)); memset(dp2, 0, sizeof(dp2)); scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) scanf("%d", &amp;a[i]); int head = a[0], tail = a[n - 1]; for(int i = 0; i &lt; n; i++) &#123; dp1[i] = max(dp1[i - 1], a[i] - head); head = min(head, a[i]); &#125; for(int j = n - 1; j &gt;= 0; j--) &#123; dp2[j] = max(dp2[j + 1], tail - a[j]); tail = max(tail, a[j]); &#125; int res(0); for(int i = 0; i &lt; n; i++) res = max(res, dp1[i] + dp2[i + 1]); printf("%d\n", res); &#125; return 0;&#125; E: 最大子矩阵：动态规划 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;int a[maxn][maxn], sum[maxn], dp[maxn];int solve(int m, int n)&#123; int res = a[0][0]; for (int i = 0; i &lt; n; i++) &#123; for (int r = 0; r &lt; m; r++) sum[r] = a[r][i]; dp[0] = sum[0]; for (int r = 1; r &lt; m; r++) dp[r] = max(dp[r - 1] + sum[r], sum[r]); for (int r = 0; r &lt; m; r++) res = max(res, dp[r]); for (int j = i + 1; j &lt; n; j++) &#123; for (int r = 0; r &lt; m; r++) sum[r] += a[r][j]; dp[0] = sum[0]; for (int r = 1; r &lt; m; r++) dp[r] = max(dp[r - 1] + sum[r], sum[r]); for (int r = 0; r &lt; m; r++) res = max(res, dp[r]); &#125; &#125; return res;&#125;int main()&#123; int n; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) scanf("%d", &amp;a[i][j]); printf("%d\n", solve(n, n)); return 0;&#125; F: Multiplication Puzzle：类似背包 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;const int inf = 0x3f3f3f3f;int a[maxn], dp[maxn][maxn];int main()&#123; int n; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) scanf("%d", &amp;a[i]); memset(dp, 0, sizeof(dp)); for(int i = 2; i &lt; n; i++) for(int j = 0; j &lt; n - i; j++) for(int k = j + 1; k &lt; j + i; k++) &#123; if(dp[j][j + i] == 0) dp[j][j + i] = dp[j][k] + dp[k][j + i] + a[j] * a[k] * a[j + i]; else dp[j][j + i] = min(dp[j][j + i], dp[j][k] + dp[k][j + i] + a[j] * a[k] * a[j + i]); &#125; printf("%d\n", dp[0][n-1]); return 0;&#125; 第四次上机作业代码 A: Currency Exchange：BellmanFord 判断负环 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;struct Edge&#123; int a, b; double r, c; Edge()&#123;&#125; Edge(int _a, int _b, double _r, double _c): a(_a), b(_b), r(_r), c(_c) &#123;&#125;&#125;;int n, m, beg;double s, d[maxn];std::vector&lt;Edge&gt; e;bool bellman_ford()&#123; memset(d, 0, sizeof(d)); d[beg] = s; for (int i = 1; i &lt; n; i++) &#123; bool state = false; for (int j = 0; j &lt; e.size(); j++) &#123; if (d[e[j].b] &lt; (d[e[j].a] - e[j].c) * e[j].r) &#123; d[e[j].b] = (d[e[j].a] - e[j].c) * e[j].r; state = true; &#125; &#125; if (!state) break; &#125; for (int k = 0; k &lt; e.size(); k++) &#123; if (d[e[k].b] &lt; (d[e[k].a] - e[k].c) * e[k].r) return true; &#125; return false;&#125;int main()&#123; while (scanf("%d%d%d%lf", &amp;n, &amp;m, &amp;beg, &amp;s) != EOF) &#123; e.clear(); while(m--) &#123; int a, b; double R_ab, R_ba, C_ab, C_ba; scanf("%d%d%lf%lf%lf%lf", &amp;a, &amp;b, &amp;R_ab, &amp;C_ab, &amp;R_ba, &amp;C_ba); e.push_back(Edge(a, b, R_ab, C_ab)); e.push_back(Edge(b, a, R_ba, C_ba)); &#125; if (bellman_ford()) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; B: Shopping Offers：动态规划 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1005;const int inf = 1e9;int idx[6], cnt[6], price[6];int b, s;int dp[6][6][6][6][6];int special_combine[maxn][6];int special_price[maxn];int main()&#123; scanf("%d", &amp;b); for (int i = 0; i &lt; b; i++) scanf("%d %d %d", &amp;idx[i], &amp;cnt[i], &amp;price[i]); scanf("%d", &amp;s); for (int i = 0; i &lt; s; i++) &#123; int tmp; scanf("%d", &amp;tmp); for (int j = 0; j &lt; tmp; j++) &#123; int a, b; scanf("%d %d", &amp;a, &amp;b); for (int k = 0; k &lt; 6; k++) &#123; if (idx[k] == a) &#123; special_combine[i][k] = b; break; &#125; &#125; &#125; scanf("%d", &amp;special_price[i]); &#125; memset(dp, -1, sizeof(dp)); dp[0][0][0][0][0] = 0; for (int i = 0; i &lt;= cnt[0]; i++) &#123; for (int j = 0; j &lt;= cnt[1]; j++) &#123; for (int k = 0; k &lt;= cnt[2]; k++) &#123; for (int x = 0; x &lt;= cnt[3]; x++) &#123; for (int y = 0; y &lt;= cnt[4]; y++) &#123; int FinalPrice = inf; int TempPrice = inf; for (int si = 0; si &lt; s; si++) &#123; if (i &gt;= special_combine[si][0] &amp;&amp; j &gt;= special_combine[si][1] &amp;&amp; k &gt;= special_combine[si][2] &amp;&amp; x &gt;= special_combine[si][3] &amp;&amp; y &gt;= special_combine[si][4]) &#123; TempPrice = dp[i - special_combine[si][0]][j - special_combine[si][1]][k - special_combine[si][2]][x - special_combine[si][3]][y - special_combine[si][4]] + special_price[si]; FinalPrice = min(FinalPrice, TempPrice); &#125; &#125; if (FinalPrice != inf) &#123; dp[i][j][k][x][y] = FinalPrice; &#125; else &#123; dp[i][j][k][x][y] = i * price[0] + j * price[1] + k * price[2] + x * price[3] + y * price[4]; &#125; &#125; &#125; &#125; &#125; &#125; printf("%d\n", dp[cnt[0]][cnt[1]][cnt[2]][cnt[3]][cnt[4]]); return 0;&#125; C: The Perfect Stall：二分图最大匹配 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 300;char map[maxn][maxn];int col[maxn][maxn], row[maxn][maxn];int linker[maxn], head[maxn];bool vis[maxn];int cnt, n, m;int R, C;struct Edge&#123; int to; int next;&#125;;Edge edge[maxn * maxn];void Init()&#123; cnt = 0; memset(head, -1, sizeof(head)); memset(col, 0, sizeof(col)); memset(row, 0, sizeof(row));&#125;void add(int u, int v)&#123; edge[cnt].to = v; edge[cnt].next = head[u]; head[u] = cnt++;&#125;bool dfs(int u)&#123; for(int i=head[u]; ~i; i=edge[i].next) &#123; int v = edge[i].to; if(!vis[v]) &#123; vis[v] = 1; if(linker[v] == -1 || dfs(linker[v])) &#123; linker[v] = u; return true; &#125; &#125; &#125; return false;&#125;int hungary()&#123; int ans = 0; memset(linker, -1, sizeof(linker)); for(int i=1; i&lt;=R; i++) &#123; memset(vis, 0, sizeof(vis)); if(dfs(i)) ans++; &#125; return ans;&#125;int main()&#123; while(cin &gt;&gt; R &gt;&gt; C) &#123; Init(); for (int i = 1; i &lt;= R; i++) &#123; int s; cin &gt;&gt; s; for (int j = 0; j &lt; s; j++) &#123; int a; cin &gt;&gt; a; add(i, a); &#125; &#125; cout &lt;&lt; hungary() &lt;&lt; endl; &#125; return 0;&#125; D: Drainage Ditches：最小割 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 205;const int inf = 0x3f3f3f3f;int n, m;int fl[maxn][maxn], dis[maxn];bool bfs()&#123; for(int i = 1; i &lt;= maxn; i++) dis[i] = -1; dis[1] = 0; queue&lt;int&gt; Q; Q.push(1); while(!Q.empty()) &#123; int k = Q.front(); Q.pop(); for(int i = 1; i &lt;= m; i++) &#123; if(fl[k][i]&gt;0 &amp;&amp;dis[i]&lt;0) &#123; dis[i] = dis[k] + 1; Q.push(i); &#125; &#125; &#125; if(dis[m] &gt; 0) return true; else return false;&#125;int dfs(int q, int mx)&#123; if(q == m) return mx; int i, a; for(i = 1; i &lt;= m; i++) &#123; if(fl[q][i]&gt;0 &amp;&amp; dis[i] == dis[q] + 1 &amp;&amp; (a = dfs(i, min(fl[q][i], mx))) ) &#123; fl[i][q] += a; fl[q][i] -= a; return a; &#125; &#125; return 0;&#125;int main()&#123; while(scanf("%d%d", &amp;n, &amp;m) != EOF) &#123; memset(fl, 0, sizeof(fl)); for(int i = 1; i &lt;= n; i++) &#123; int u, v, d; scanf("%d%d%d", &amp;u, &amp;v, &amp;d); fl[u][v] += d; &#125; int ans = 0, tmp; while(bfs()) &#123; while(tmp = dfs(1, inf)) ans += tmp; &#125; printf("%d\n", ans); &#125; return 0;&#125; E: Dual Core CPU：最小割 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;bits/stdc++.h&gt;using namespace std; const int maxn = 20005; const int maxm = 2000005; const int INF = 0x3f3f3f3f; int head[maxn], cur[maxn], d[maxn], st[maxm], s, e, no, n; struct point&#123; int u, v, flow, nxt; point()&#123;&#125;; point(int x, int y, int z, int w):u(x), v(y), nxt(z), flow(w)&#123;&#125;; &#125; p[maxm]; void add(int x, int y, int z)&#123; p[no] = point(x, y, head[x], z); head[x] = no++; p[no] = point(y, x, head[y], 0); head[y] = no++; &#125;void init()&#123; memset(head, -1, sizeof(head)); no = 0; &#125;bool bfs()&#123; int i, x, y; queue &lt; int&gt;q; memset(d, -1, sizeof(d)); d[s] = 0; q.push(s); while(!q.empty()) &#123; x = q.front(); q.pop(); for(i = head[x]; i != -1; i = p[i].nxt) &#123; if(p[i].flow &amp;&amp; d[y = p[i].v] &lt; 0) &#123; d[y] = d[x] + 1; if(y == e) return true; q.push(y); &#125; &#125; &#125; return false; &#125;int dinic()&#123; int i, loc, top, x = s, nowflow, maxflow = 0; while(bfs()) &#123; for(i = s; i &lt;= e; i++) cur[i] = head[i]; top = 0; while(true) &#123; if(x == e) &#123; nowflow = INF; for(i = 0; i &lt; top; i++) &#123; if(nowflow &gt; p[st[i]].flow) &#123; nowflow = p[st[i]].flow; loc = i; &#125; &#125; for(i = 0; i &lt; top; i++) &#123; p[st[i]].flow -= nowflow; p[st[i]^1].flow += nowflow; &#125; maxflow += nowflow; top = loc; x = p[st[top]].u; &#125; for(i = cur[x]; i != -1; i = p[i].nxt) if(p[i].flow&amp;&amp;d[p[i].v] == d[x] + 1) break; cur[x] = i; if(i != -1) &#123; st[top++] = i; x = p[i].v; &#125; else &#123; if(!top) break; d[x] = -1; x = p[st[--top]].u; &#125; &#125; &#125; return maxflow; &#125;int main()&#123; int N, M; while(scanf("%d%d", &amp;N, &amp;M) != EOF) &#123; init(); s = 0; e = N + 1; for(int i = 1; i &lt;= N; i++) &#123; int ai, bi; scanf("%d%d", &amp;ai, &amp;bi); add(s, i, ai); add(i, e, bi); &#125; while(M--) &#123; int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); add(a, b, c); add(b, a, c); &#125; printf("%d\n", dinic()); &#125; return 0; &#125; F: PIGS：最大流 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;const int maxp = 1e3 + 5;const int maxm = 1e5 + 5;const int inf = 0x3f3f3f3f;int m, n, T, cnt = 1;int h[maxn], q[maxn], last[maxn], cur[maxn];int pig[maxp];vector&lt;int&gt; a[maxn];int L[maxp];struct Edge&#123; int nxt, v, to;&#125; e[maxm];void addedge(int u, int v, int w)&#123; e[++cnt].to = v; e[cnt].nxt = last[u]; last[u] = cnt; e[cnt].v = w; e[++cnt].to = u; e[cnt].nxt = last[v]; last[v] = cnt; e[cnt].v = 0;&#125;bool bfs()&#123; int head = 0, tail = 1; memset(h, -1, sizeof(h)); q[0] = 0; h[0] = 0; while (head != tail) &#123; int now = q[head]; head++; for (int i = last[now]; i; i = e[i].nxt) if (e[i].v &amp;&amp; h[e[i].to] == -1) &#123; h[e[i].to] = h[now] + 1; q[tail++] = e[i].to; &#125; &#125; return h[T] != -1;&#125;int dfs(int x, int f)&#123; if (x == T) return f; int w, used = 0; for (int i = cur[x]; i; i = e[i].nxt) if (h[e[i].to] == h[x] + 1) &#123; w = dfs(e[i].to, min(f - used, e[i].v)); e[i].v -= w; e[i ^ 1].v += w; if (e[i].v) cur[x] = i; used += w; if (used == f) return f; &#125; if (!used) h[x] = -1; return used;&#125;int dinic()&#123; int tmp = 0; while (bfs()) &#123; for (int i = 0; i &lt;= T; i++) cur[i] = last[i]; tmp += dfs(0, inf); &#125; return tmp;&#125;int main()&#123; cin &gt;&gt; m &gt;&gt; n; T = n + 1; for (int i = 1; i &lt;= m; i++) cin &gt;&gt; pig[i]; for (int i = 1; i &lt;= n; i++) &#123; int x; cin &gt;&gt; x; while (x--) &#123; int y; cin &gt;&gt; y; a[i].push_back(y); &#125; int z; cin &gt;&gt; z; addedge(i, T, z); &#125; for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt; a[i].size(); j++) &#123; int v = a[i][j]; if (!L[v]) &#123; L[v] = i; addedge(0, i, pig[v]); &#125; else &#123; addedge(L[v], i, inf); L[v] = i; &#125; &#125; printf("%d\n", dinic()); return 0;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>计算机</tag>
        <tag>算法</tag>
        <tag>北大</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[群表示论龟速学习]]></title>
    <url>%2F2019%2F10%2F06%2F%E7%BE%A4%E8%A1%A8%E7%A4%BA%E8%AE%BA%E9%BE%9F%E9%80%9F%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[感觉自己远离抽象代数太久了...很僵硬... 内容主要是 GTM 42：Serre 所著的《Linear Representations of Finite Groups》. 也参考了一些丘维声先生的《群表示论》. 第一章 线性表示概论 Def. 同态 \(\rho: G\to GL(V)\) 称为 \(G\) 在 \(V\) 内的一个线性表示. 等价定义： 空间 \(V\) 是群代数 \(K[G]\) 的左模（左-\(K[G]\) 模）. 顾名思义，就是用一个 \(GL(V)\) 中的矩阵来表示 \(G\) 中的一个元素，而且 \(GL(V)\) 中的运算也完全能刻画 \(G\) 中的运算. 例子：degree 为 \(1\) 的表示，正则表示，置换表示... 我们只考虑 \(V\) 是有限维的情形. 我们一般设 \(V\) 是 \(\mathbb{C}\) 上的空间. 表示与群代数的模：\(G\) 的表示 \((\varphi,V)\) \(\overset{\varphi^*(\sum a_g g)=\sum a_g\varphi(g)}{\Longleftrightarrow}\) \(K[G]\) 的表示 \((\varphi^*,V)\) \(\Longleftrightarrow\) \(V\) 是左 \(K[G]\)-模. 范畴上的表示 更一般地，设 \(\mathscr{U}\) 是一个范畴，取 \(\forall A\in \mathscr{U}\)，则同态 \(\rho: G\to Aut(A)\) 是一个 \(G\) 的表示. 表示的同态：设有表示 \((\rho, V)\) 和 \((\rho&#39;, W)\)，若同态 \(f: V\to W\) 满足 \(\rho_s\circ f = f\circ \rho_s&#39;\)（即图表 \(\begin{matrix} V &amp; \overset{\rho_s}{\longrightarrow} &amp; V \\ f \downarrow &amp; &amp; \downarrow f \\ W &amp; \overset{\rho_s&#39;}{\longrightarrow} &amp; W \\ \end{matrix}\)交换），则称 \(f\) 为二者之间的同态. 若 \(f\) 为 \(V\to W\) 的同构，则 \(f\) 也是表示之间的同构. 子表示：若 \(W\leqslant V\) 的子空间且在 \(G\) 下不变，则 \(\rho\) 在 \(W\) 上的限制被 \(\rho |_W\) 称为子表示. 当然，子表示 \(\iff\) 子模. 表示的运算 直和：\(V\oplus W\)，基本上是空间做直和； 张量积：\(V\otimes W\)，基本上是空间做张量积。 有自然同构：\(End(W)\otimes End(V)\cong End(W\otimes V)\). 对偶表示：\(\langle \rho_s x,\rho_s&#39;x&#39;\rangle = \langle x,x&#39;\rangle\) Maschke 定理 每个表示都是不可约表示的直和. （每个表示都是半单代数） \(Sym^2\) 和 \(Alt^2\)：令 \(\theta\) 是 \(V\otimes V\) 的自同构，s.t. \(\theta(e_i\cdot e_j)=e_j\cdot e_i\). 定义 \(Sym^2(V)=\{z: \theta(z)=z\}=\{e_i\otimes e_j + e_j\otimes e_i\}\)，\(\dim = \frac{n(n+1)}{2}\); \(Alt^2(V)=\{z: \theta(z)=-z\}=\{e_i\otimes e_j - e_j\otimes e_i\}\)，\(\dim = \frac{n(n-1)}{2}\). 显然有 \(Alt^2\cap Sym^2=\{0\}\)，因此结合维数，我们有 \(V\otimes V=Sym^2(V)\oplus Alt^2(V)\). 第二章 特征标理论 Def. 设有表示 \(\rho: G\to GL(V),~s\mapsto \rho_s\)，令 \(\chi_\rho: G\to \mathbb{C},~s\mapsto tr(\rho_s)\)，称为 \(\rho\) 的特征标. \(\chi_\rho(1)=tr(\rho(1))=\dim(V)=degree(\rho)\); \(\chi_\rho(s^{-1})=\lambda_1^*+\cdots+\lambda_n^*=(\lambda_1+\cdots+\lambda_n)^*=\chi_\rho^*(s)\); \(\forall s,t\)，总有 \(\chi(st)=\chi(ts)\)（trace 的交换性）. 类函数：在共轭类上取值相等的函数. （特征标就是一种类函数） 类函数全体构成线性空间，维数即为共轭类的数量. 特征标的运算性质： 直和：\(\chi_{\rho_1\oplus \rho_2}=\chi_{\rho_1}+\chi_{\rho_2}\). 张量积：\(\chi_{\rho_1\otimes \rho_2}=\chi_{\rho_1}\times \chi_{\rho_2}\). Sym 与 Alt：\(\chi_{Sym^2}=\frac{1}{2}\chi_\rho^2+\frac{1}{2}\chi_{\rho^2}\)，\(\chi_{Alt^2}=\frac{1}{2}\chi_\rho^2-\frac{1}{2}\chi_{\rho^2}\). Schur 引理 不可约表示间的非平凡同态是同构. 特征标的内积：\(\langle \varphi, \psi\rangle=\frac{1}{|G|}\sum\limits_{s\in G} \varphi(s)\psi(s)^*\). 懒，不想细改，有时内积写作 \(\langle\cdot, \cdot\rangle\)，有时写作 \((\cdot|\cdot)\)... 应不致混淆吧... 特征标的正交： 对于不可约指标，\(\langle \chi,\chi \rangle = 1\); 对不同构的不可约表示 \(\rho_1,\rho_2\)，设其特征标为 \(\chi_1,\chi_2\)，则 \(\langle \chi_1,\chi_2 \rangle = 0\). 不可约分解的重数：设 \(\rho: G\to GL(V)\) 的特征标为 \(\varphi\)，且有不可约分解 \(V=\bigoplus\limits_{i=1}^k W_i\)，则其中与 \(W\)（特征标设为 \(\chi\)）同构的个数为 \(\langle \varphi,\chi \rangle\). 由此立刻可得：两个表示同构当且仅当具有相同的特征标. 正则表示的特征标：\(r_G(s)=\begin{cases} |G|~ &amp; s = 1 \\ 0~ &amp; s\neq 1 \end{cases}\Rightarrow 不可约表示 ~W_i~ 在正则表示中的重数为其~degree~ \chi_i(1)\). 立即得到：\(r_G(s)=\sum \chi_i(1)\chi_i(s)\)，于是有： \(\sum\limits \chi_i^2(1)=|G|\); 若 \(s\neq 1\)，则 \(\sum \chi_i(1)\chi_i(s)=0\). 不可约表示的个数 Prop. \(f\) 是类函数，\((\rho, V)\) 是 \(G\) 的一个线性表示，特征标为 \(\chi\). 若 \(V\) 是不可约表示，则 \(\rho_f = \sum\limits_{t\in G}f(t)\rho_t\) 是一个常数变换： \[\lambda = \frac{1}{\chi(1)}\sum\limits_{t\in G} f(t)\chi(t)=\frac{|G|}{\chi(1)}\langle f, \chi^*\rangle.\] 简略证明 计算 \(\rho_s^{-1}\rho_f\rho_s\) 可知其与 \(\rho_f\) 相等，即 \(\rho_f\) 是 \(V\) 的自同态，因而为同构. 然后计算 \(tr(\rho_f)\) 即可求得系数. 记 \(G\) 上所有类函数构成的空间为 \(H\)，则不可约特征标 \(\chi_1,\ldots,\chi_h\in H\). Thm. 不可约特征标 \(\chi_1,\ldots,\chi_h\) 构成 \(H\) 的一组规范正交基. （只需证明每个与 \(\chi_i^*\) 正交的元素都是 \(0\)） 进一步容易得到如下定理： Thm. \(G\) 的不可约表示个数等于 \(G\) 的共轭类个数. \(s\) 的共轭类元素个数 \(c(s)\). 还有如下推论： \(\sum\limits_{i=1}^h \chi_i(s)^*\chi_i(s)=\frac{|G|}{c(s)}\). 若 \(t\) 与 \(s\) 不共轭，则 \(\sum\limits_{i=1}^h \chi_i(s)^*\chi_i(t)=0\). 典范分解：将不可约分解中同构的项合并所得到的分解 \(V=\bigoplus\limits_{i=1}^h V_i\). 典范分解是唯一的. 该分解可以由如下投影确定： \[p_{i}=\frac{\chi_{i}(1)}{|G|} \sum_{t \in G} \chi_{i}(t)^{*} \rho_{t}.\] 简略说明：由上面的 Prop 可知，\(p_i\) 在某个不可约表示 \(W\) 上的限制是常数 \(\frac{\chi_i(1)}{\chi_W(1)}\langle \chi_i,\chi_W \rangle\)，这个常数在 \(\chi_W=\chi_i\) 时是 \(1\)，否则是 \(0\)，因此 \(p_i\) 就是 \(V\to V_i\) 的射影. 显分解：将典范分解的组分 \(V_i\) 分解为若干 \(W_i\) 的直和. 这里没有完全搞懂... 第三章 子群、群的直积、诱导表示 Abel 群的表示：\(G\) 是 Abel 群当且仅当其所有不可约表示的 degree 都为 \(1\). 群的直积：\(G_1\times G_2\) 中的乘法为 \((s_1,s_2)(t_1,t_2)=(s_1t_1,s_2t_2)\). 直积的表示：张量积 —— \((\rho_1\otimes \rho_2)(s_1,s_2)=\rho_1(s_1)\otimes \rho_2(s_2)\). 这是一个 \(G_1\times G_2\to GL(V_1\otimes V_2)\) 的同态. 不可约性在乘积上的传递： 若 \(\rho_i\) 是 \(G_i\) 的不可约表示，则 \(\rho_1\otimes \rho_2\) 是 \(G_1\times G_2\) 的不可约表示； 进一步，\(G_1\times G_2\) 的所有不可约表示都来自上述渠道. 诱导表示 给出 \(G\) 的一个表示 \(\rho: G\to GL(V)\)，将其限制在 \(G\) 的子群 \(H\) 上，可得到一个 \(H\) 在 \(V\) 上的表示 \(\rho |_H\). 考虑 \(W\leqslant V\)，且在 \(\rho_t,~t\in H\) 下稳定，则有 \(\rho|_H\) 的子表示 \(\theta: H\to GL(W)\). 故 \(\forall s\in G\)，\(\rho_s W\) 只取决于 \(s\) 所在的 \(H\) 的左陪集 \(sH\).\(\Longrightarrow\) 所有 \(\sigma\in G/H\) 都对应一个 \(V\) 的子空间 \(W_\sigma=\rho_s W\)，其中 \(s\in \sigma\). 这样，我们就可以定义 \(V\) 的子表示 \(\sum\limits_{\sigma\in G/H} W_\sigma\). 进一步，有下面的定义 诱导表示：若 \(V=\bigoplus\limits_{\sigma\in G/H} W_\sigma\) 则称 \((\rho, V)\) 是由 \((W,\theta)\) 诱导的. 若 \(R\) 是 \(G/H\) 的一个代表系，则 \(V=\bigoplus\limits_{r\in R}\rho_rW\)，故 \(\dim(V)=\sum\limits_{r\in R}\dim(\rho_rW)=[G:H]\dim(W)\). 例：\(V\) 是 \(G\) 的正则表示，则其由 \(H\leqslant G\) 在 \(W\leqslant V\) 内的正则表示诱导. 若 \(\rho_i\) 是由 \(\theta_i\) 诱导的（\(i=1,2\)）， 则 \(\rho_1\oplus \rho_2\) 可由 \(\theta_1\oplus\theta_2\) 诱导. 若 \(\rho\) 由 \(\theta\) 诱导，则 \(\rho\otimes\rho&#39;\) 可由 \(\theta\otimes \rho&#39;|_H\) 诱导. 存在性和唯一性 Thm. 设 \((W,\theta)\) 是 \(H\leqslant G\) 的一个表示，则存在 \(G\) 的表示 \((V,\rho)\)，s.t. \(\rho\) 是由 \(\theta\) 诱导的. 进一步，这个 \(\rho\) 在同构意义下唯一. 诱导表示的特征标 诱导表示的特征标 设 \(R\) 是 \(G/H\) 的一个代表系，则 \[\chi_\rho(u)=\sum\limits_{r\in R\atop r^{-1}ur\in H}\chi_\theta(r^{-1}ur)=\frac{1}{|H|} \sum_{s \in G \atop s^{-1} u s \in H} \chi_{\theta}\left(s^{-1} u s\right).\] 第六章 群代数 Prop. 如果 \(ch K=0\)，则 \(K[G]\) 是半单代数. 一个练习 设 \(ch K&gt;0\)，则 \(K[G]\) 半单 \(\iff\) \(p \nmid |G|\). 后面我们基本认为 \(K=\mathbb{C}\). \(\mathbb{C}[G]\) 的分解 令 \(\rho_i: G\to GL(W_i), 1\leqslant i\leqslant h\) 是 \(G\) 同构意义下所有的不可约表示，记 \(n_i=\dim (W_i)\)，则可将 \(\rho_i\) 扩展为代数同态： \[\tilde{\rho}: \mathbf{C}[G] \rightarrow \prod_{i=1}^{h} \operatorname{End}\left(W_{i}\right) \cong \prod_{i=1}^{h} M_{n_{i}}(\mathbf{C}).\] 事实上，\(\tilde{\rho}\) 是一个同构. 考虑它的中心： \[Z(\mathbb{C}[G])\cong Z(M_{n_1}(\mathbb{C})\oplus\cdots\oplus M_{n_h}(\mathbb{C})) \cong \mathbb{C}\oplus\cdots\oplus\mathbb{C}.\] 即：\(Z(\mathbb{C}[G])\cong CF(G)\). 代数整数 \(\mathbb{C}\) 上整系数多项式的根. 下列命题等价： \(x\) 在 \(\mathbb{Z}\) 上是整的； \(R\) 中由 \(x\) 生成的子环 \(\mathbb{Z}[x]\) 作为一个 \(\mathbb{Z}\)-模是有限生成的； 存在一个 \(R\) 的有限生成 \(\mathbb{Z}\)-模，它包含 \(\mathbb{Z}[x]\). 特征标与代数整数 有限群表示的特征标是代数整数. Prop. 令 \(u=\sum u(s)s\in Z(\mathbb{C}[G])\)，且 \(u(s)\) 都是代数整数，则 \(u\) 在 \(\mathbb{Z}\) 上也是整的. Prop. 设 \(C\) 是 \(G\) 的中心，则 \(G\) 的不可约表示维数整除 \([G:C]\). 第七章 诱导表示与 Mackey 分解 \(H\) 是 \(G\) 的子群，\(R\) 是 \(H\) 的左陪集代表系. \(V\) 是一个 \(\mathbb{C}[G]\)-模，\(W\) 是 \(V\) 的一个子模. 诱导表示的定义是 \(V=\bigoplus\limits_{s\in R} sW\)，这实际上是在说 \(V\) 这个表示是不依赖于代表系 \(R\) 选取的. 一个等价的表述是： 令 \(W&#39;=\mathbb{C}[G]\otimes_{\mathbb{C}[H]} W\) 是由 \(W\) 通过 \(\mathbb{C}[H]\) 到 \(\mathbb{C}[G]\) 的标量扩张而得到的 \(\mathbb{C}[G]\)-模，则单射 \(W\to V\) 可以线性地开拓为一个 \(\mathbb{C}[G]\)-同态 \(W&#39;\to V\). 进一步，有 Prop. \(V\) 是由 \(W\) 所诱导的，当且仅当同态 \(i:\mathbb{C}[G]\otimes_{\mathbb{C}[H]}W\to V\) 是一个同构. 以下将 \(W\) 所诱导的 \(G\) 的表示记作 \({\rm Ind}_H^G (W)\) 或者 \({\rm Ind}(W)\). （其实感觉 \(W^G\) 更好... 诱导特征标 下面这个特征标叫做诱导特征标，即 \(\operatorname{Ind}_H^G (W)\) 的特征标： \[\mu^G(g)=\sum\limits_{i=1}^t \hat{\mu}(g_i^{-1}gg_i),~~~~其中~\hat{\mu}(x)=\begin{cases} \mu(x),&amp; y\in H\\ 0, &amp; y\notin H \end{cases}.\] 关于诱导特征标，有如下定理成立： Frobenius 互反律 设 \(G\) 是有限群，\(H&lt;G\). 设 \(\mu\) 是 \(H\) 的复特征标，\(\chi\) 是 \(G\) 的复特征标，则 \[\langle\mu^G ,\chi\rangle_G=\langle\mu,\chi|H\rangle_H\] 换言之：设 \(\psi\) 是 \(H\) 的不可约复表示，\(\varphi\) 是 \(G\) 的不可约复表示，则 \(\varphi\) 在 \(\psi^G\) 中的重数等于 \(\psi\) 在 \(\varphi|H\) 中的重数. 部分习题简略解答 以下是一些习题的解答...其中包括了几个wlz老师课上留的思考题 /* Only resize the element if PDF is embedded */ .pdfobject-container { width: 800px; height: 900px; } PDFObject.embed("/pdf/Solution_to_Serre_gtm42.pdf", "#my-container");]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>北大</tag>
        <tag>抽象代数</tag>
        <tag>表示论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文笔记[8]——Allocating Indivisible Items in Categorized Domains]]></title>
    <url>%2F2019%2F09%2F21%2F%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-8-%E2%80%94%E2%80%94Allocating-Indivisible-Items-in-Categorized-Domains%2F</url>
    <content type="text"><![CDATA[文章：Allocating Indivisible Items in Categorized Domains CDAP (categorized domain allocation problem)：多个类别的不可分物品被分配给若干 agent，每个 agent 在每一类中至少获得一个物品。 本文讨论的是常见的情形：一个 agent 只获取每一类的一个物品 CSAM (categorial sequential allocation mechanism)：serial dictatorship 的推广，将分配拆分成多个轮次，每轮每个候选人从指定类别中选取一个 bundle。 Serial dictatorship 的刻画：三个公理化特征 Strategyproofness; Non-bossiness; Category-wise neutrality. 分配问题的相关研究所面临的三大障碍： 偏好瓶颈（Preference bottleneck）：当物品个数较多时，bundle 的偏好情况将以指数级别增长； 计算瓶颈（Computational bottleneck）：即便能够使用某种偏好语言简洁地表达他们的偏好，计算“最优”分配通常也是困难的； Agent 的策略（Threats of agents' strategic behavior）：agent 可能谎报偏好，以获得更好的 bundle。这可能导致社会效率低下的分配。 主要工作 关于 Basic CDAP：每个类别中的物品数量都等于 agent 数量。 首先用三条公理化特征来描述 serial dictatorship： Strategyproofness：不能通过谎报偏好来获取更大好处； Non-bossiness：不能在不改变自己偏好的情况下改变其他 agent 的分配； Category-wise neutrality：类别标记不改变分配结果； 上述三条特征可以帮我们克服“Agent 的策略”带来的影响。 为克服偏好和计算瓶颈，并且防止 serial dictatorship，定义 CSAM CSAM 是一类间接机制，前文描述过其过程。 两种 myopic agent 下 CSAM 最坏情况下的效率： Optimistic agent：总是选择当前可选的最优 bundle 中的物品； Pessimistic agent：总是选择最坏情形下的最优项目。 Categorized Domain Allocation Problems Def 1. 一个 categorized domain 由 \(p\geqslant 1\) 个不可分的物品类构成，用 \(\{D_1,\ldots,D_p\}\)。在一个 CDAP 中，物品被分配给 \(n\) 个 agent，每个 agent 至少获取每类中的一个物品。 对于一个 basic categorized domain，\(\forall i\)，\(|D_i|=n\)，\(\mathfrak{D}=D_1\times\cdots\times D_p\)，agent 的偏好为 \(\mathfrak{D}\) 上的一个序。 在 basic CDAP 中，每个 agent 在每一类中恰好得到一个物品。 我们研究的主要对象是 non-sharable items，即每个物品只能分配给一个 agent； \(\mathfrak{D}\) 中的元素被称为一个 bundle； 对 \(\forall j\in \{1,2,\ldots,n\}\)，令 \(R_j\) 表示一个 \(\mathfrak{D}\) 上的序； 用 \(P=(R_1,\ldots,R_n)\) 表示所有 agent 的偏好构成的 profile. 分配 \(A\) 是 \(\{1,2,\ldots,n\}\to \mathfrak{D}\) 的一个映射，s.t. \[\bigcup\limits_{j=1}^nA(j)_i=D_i\] 一个分配机制是一个函数，输入为 profile，输出为一个分配 用 \(f^j(P)\) 表示机制 \(f\) 在 profile \(P\) 下分配给 agent \(j\) 的 bundle. 三条公理化性质 Strategyproofness 对于 \(\forall\) profile \(P\)，\(\forall\) agent \(j\)，以及 \(\mathfrak{D}\) 上的序 \(R_j&#39;\)，都有： \[f^j(P)\succ_{R_j} f^j(R_j&#39;,R_{-j}).\] Non-bossiness \(f\) 满足 non-bossiness 当且仅当 agent 中不存在黑社会； 黑社会：通过谎报自己的偏好来改变他人的分配结果，但不改变自己的分配结果。 对于 \(\forall\) profile \(P\)，\(\forall\) agent \(j\)，以及 \(\mathfrak{D}\) 上的序 \(R_j&#39;\)，都有： \[[f^j(P)=f^j(R_j&#39;,R_{-j})]\Rightarrow [f(P)=f(R_j&#39;,R_{-j})].\] Category-wise neutrality 对 \(\forall P\)，\(\forall i\)，取置换 \(\sigma\in S_n\)，将其作用在 \(D_i\) 上不改变分配结果，即总有： \[f(\sigma(P))=\sigma(f(P)).\] Serial dictatorship 由一个 \(\{1,2,\ldots,n\}\) 上的序 \(\mathcal{K}\) 来表达，所有 agent 按照 \(\mathcal{K}\) 所规定的顺序选取物品，每次都选择当前所能选取的物品中，他所认为优先级最高的物品。 Serial dictatorship 的公理化特征 Th 1. 对于任意满足 \(p\geqslant 2\)，\(n\geqslant 2\) 的 basic CDAP，一个分配机制是 strategyproof, non-bossy, 且 category-wise neutral 的，当且仅当它是 serial dictatorship. 进一步，这三条公理是刻画 serial dictatorship 的最低要求。 以下引理表明，对于任何 strategyproof 且 non-bossy 的机制 \(f\)，以及任意 profile \(P\)。若某些 agent \(j\) 谎报了偏好，但未扩大比 \(f^j(P)\) 顺位更高的 bundle 集合，则分配结果不会改变。 Lemma 1. 令 \(f\) 为一个 \(p\geqslant 2\) 的 basic categorized domain 上的一个 strategyproof 且 non-bossy 的分配机制。对任意 profile \(P,P&#39;\)，若 \(\forall j\leqslant n\)，总有： \[\{\vec{d}\in\mathfrak{D}: \vec{d}\succ_{R_j&#39;} f^j(P)\}\subseteq \{ \vec{d}\in\mathfrak{D}:\vec{d}\succ_{R_j} f^j(P) \}\] 则 \(f(P)=f(P&#39;)\). 对于一个 \(\mathfrak{D}\) 上的序 \(R\)以及 bundle \(\vec{d}\in\mathfrak{D}\)，若序 \(R&#39;\) 相比 \(R\) 只提升了 \(\vec{d}\) 的位置，而不改变其他 bundle 的相对位置，则称 \(R&#39;\) 为 \(\vec{d}\) 在 \(R\) 上的一个 pushup. 以下引理表明，对于任意 strategyproof 且 non-bossy 的机制 \(f\), 若某个 agent 在谎报偏好时，报告的偏好是 \(\vec{d}\) 的 pushup，则只会导致以下两种结果之一： 其他 agent 获得的东西都不改变； 该 agent 获得 \(\vec{d}\). Lemma 2. 令 \(f\) 是一个 \(p\geqslant 2\) 的 basic categorized domain 上的 strategyproof，non-bossy 的分配机制，则对任意 profile \(P\)，\(\forall j\leqslant n\)，以及 \(\forall \vec{d}\) 和 \(\vec{d}\) 在 \(R_j\) 上的一个 pushup，只有以下两种结果之一会发生： \(f(R_j&#39;,R_{-j})=f(R)\) （什么都没变）; \(f^j(R_j&#39;,R_{-j})=\vec{d}\) （agent \(j\) 得到了 \(\vec{d}\)）. Lemma 3. 对任意 \(p\geqslant 2\) 的 basic categorized domain，所有 strategyproof，non-bossy，category-wise neutral 的分配机制都是帕累托最优的。 以下引理表明，对任意 strategyproof 且 non-bossy 的机制 \(f\), 以及任意 profile \(P\) 中的一对 agent \(j_1\)，\(j_2\)，不存在这样的 bundle \(\vec{c}\)：它由 \(j_1\)，\(j_2\) 在 \(f\) 下得到的物品构成，同时 \(j_1\) 和 \(j_2\) 都更喜欢 \(\vec{c}\). Lemma 4. 令 \(f\) 是一个 \(p\geqslant 2\)，\(n\geqslant 2\) 的 basic categorized domain 上的 strategyproof，non-bossy 的分配机制。\(\forall\) profile \(P\) 以及 \(\forall j_1\neq j_2\leqslant n\)，令 \(\vec{a}=f^{j_1}(P)\)，\(\vec{b}=f^{j_2}(P)\)，则： \[不存在 \vec{c}\in(a_1,b_1)\times\{a_2,b_2\}\times\cdots\times\{a_p,b_p\} ，s.t.~~\vec{c}\succ_{R_{j_1}} \vec{a}~~且~~\vec{c}\succ_{R_{j_2}} \vec{b}\] 其中 \(a_i\) 是 \(\vec{a}\) 的第 \(i\) 位的物品。 Proof. 用反证法：假设对某个 profile \(P\)，存在这样的 \(j_1\)，\(j_2\)，和 \(c\). 设 \(\vec{d}\) 表示 \(\vec{c}\) 在 \(\vec{a}\cup\vec{b}\) 中的补集，则 \(\forall i\)，都有 \(\{a_i,b_i\}=\{c_i,d_i\}\). 我们按照如下步骤构造反例： 令 \(\hat{R}_{j_1}=[\vec{c}\succ\vec{a}\succ\vec{d}\succ\vec{b}\succ 其他]\)，\(\hat{R}_{j_2}=[\vec{c}\succ\vec{b}\succ\vec{a}\succ\vec{d}\succ 其他]\)，其余 \(j\) 满足 \(\hat{R}_j=[f^j(P)\succ 其他]\). 则由 Lemma 1，有 \(f(\hat{P})=f(P)\). 令 \(\bar{R}_{j_2}=[\vec{c}\succ\vec{a}\succ\vec{b}\succ\vec{d}\succ 其他]\)，由于 \(\bar{R}_{j_2}\) 为 \(\vec{a}\) 在 \(\hat{R}_{j_2}\) 上的 pushup，故由 Lemma 2，\(f^{j_2}(\bar{R}_{j_2},\hat{R}_{-j_2})\) 为 \(\vec{a}\) 或 \(\vec{b}\). 可由帕累托最优性（Lemma 3）得知不可能是 \(\vec{a}\)，故只能有 \(f^{j_2}(\bar{R}_{j_2},\hat{R}_{-j_2})=\vec{b}=f^{j_2}(\hat{P})\). 故由 non-bossiness，可得 \(f(\bar{R}_{j_2},\hat{R}_{-j_2})=f(\hat{P})=f(P)\). 令 \(\bar{R}_{j_1}=[\vec{c}\succ\vec{b}\succ\vec{a}\succ\vec{d}\succ 其他]\)，与 2 类似可得 \(f(\bar{R}_{j_1},\bar{R}_{j_2},\hat{R}_{-\{j_1,j_2\}})=f(P)\). 令 \(\mathring{R}_{j_2}=[\vec{c}\succ\vec{a}\succ\vec{d}\succ\vec{b}\succ 其他]\)，由 Lemma 1 可得 \(f(\bar{R}_{j_1},\mathring{R}_{j_2},\hat{R}_{-\{j_1,j_2\}})\) 中，\(j_1\) 获得 \(\vec{b}\)，\(j_2\) 获得 \(\vec{a}\)，其余 \(j\) 所得与 \(f(P)\) 相同. 令 \(\mathring{R}_{j_1}=[\vec{c}\succ\vec{a}\succ\vec{b}\succ\vec{d}\succ 其他]\)，与 2 类似可得 \(f(\mathring{R}_{j_1},\mathring{R}_{j_2},\hat{R}_{-\{j_1,j_2\}})=f(\bar{R}_{j_1},\mathring{R}_{j_2},\hat{R}_{-\{j_1,j_2\}})\). 由于 \(\mathring{R}_{j_1}\) 是 \(\vec{b}\) 在 \(\hat{R}_{j_1}\) 上的一个 pushup，故由 Lemma 1，可得 \(f(\mathring{R}_{j_1},\bar{R}_{j_2},\hat{R}_{-\{j_1,j_2\}})=f(\hat{R}_{j_1},\bar{R}_{j_2},\hat{R}_{-\{j_1,j_2\}})\). 式子的右端便是 2 中的 profile. 由 5 和 6 得到的结果，若 agent 们的偏好为 \(\mathring{R}_{j_1}\) 和 \(\bar{R}_{j_2}\)，则 \(j_2\) 可通过将自己的偏好谎报为 \(\mathring{R}_{j_2}\) 以获取更大利益。这与 strategyproof 矛盾。Lemma 4 得证。 容易验证 serial dictatorship 是 strategyproof，non-bossy，且 category-wise neutral 的，接下来我们证明满足以上三条的性质只有 serial dictatorship. 令 \(R^*\) 是 \(\mathfrak{D}\) 上满足以下几条的序： \((1,\ldots,1)\succ (2,\ldots,2)\succ\cdots\succ (n,\ldots,n)\); \(\forall j&lt;n\)，\((j,\ldots,j)\) 与 \((j+1,\ldots,j+1)\) 之间的 bundle 都满足以下两条（记为 \(B_j\)）： 至少有一维是 \(j\)； 所有维度的值都在 \(\{j,j+1,\ldots,n\}\) 中. \(\forall j\) 以及 \(\forall \vec{d},\vec{e}\in B_j\)，若 \(\vec{d}\) 中 \(j\) 的数量严格多余 \(\vec{e}\)，则 \(\vec{d}\succ\vec{e}\). Thenextclaimstatesthatf agreeswithaserialdictatorship on the profile (R ∗ ,...,R ∗ ) where all agents have the same preferences R ∗ that we have just defined. We will later show that f agrees with the same serial dictatorship on all profiles. Claim 1. 令 \(P^*=(R^*,\ldots,R^*)\)，则对 \(\forall l\leqslant n\)，存在 \(j_l\leqslant n\)，s.t. \(f^{j_1}(P)=(l,\ldots,l)\). 事实上，这个定理是比较负面的一个结果。因为它意味着同时满足三条的分配机制并不好，因此我们需要舍弃其中至少一条。其中 non-bossy 是比较不自然的。 Categorial Sequencial Allocation Mechanisms (CSAM) 给定 \(\{1,\ldots,n\}\times\{1,\ldots,p\}\) 上的序 \(\mathcal{O}\)，由 \(\mathcal{O}\) 生成的 CSAM \(f_\mathcal{O}\) 的过程分为 \(np\) 个步骤： 在第 \(t\) 步中，设 \(\mathcal{O}\) 的第 \(t\) 顺位为 \((j,i)\). Agent \(j\) 被称为第 \(t\) 步中的 active agent，他将选择（可选择的）物品 \(d_{j,i}\in D_i\)； 将 \(d_{j,i}\) 广播给所有的 agent. 后面是一些效率的问题，先略过。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>北大</tag>
        <tag>社会计算</tag>
        <tag>论文笔记</tag>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表示论在投票理论中的应用]]></title>
    <url>%2F2019%2F07%2F26%2F%E8%A1%A8%E7%A4%BA%E8%AE%BA%E5%9C%A8%E6%8A%95%E7%A5%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[似乎主要是 Donald G. Saari 和 Zajj Daugherty 等人的工作... 大致思路：用 tabloid 来描述投票中的对象，然后将过程中的状态空间视为 \(\mathbb{Q}S_n\)-模，然后将其分解为不可约模的直和，并分析在投票过程中真正起作用的成分。 太懒了...直接把曹老师作报告用的 Slides 放上来吧... /* Only resize the element if PDF is embedded */ .pdfobject-container { width: 800px; height: 900px; } PDFObject.embed("/pdf/BNU20190907.pdf", "#my-container"); 参考文献 Barcelo, H., Bernstein, M., Bockting-Conrad, S., Mcnicholas, E., Nyman, K., Viel, S. (2018). Algebraic voting theory and representations of \(S_m ≀ S_n\) . arXiv:1807.03743v1 [math.CO] 6 Jul 2018. Crisman, K. D., Orrison, M. E. (2017). Representation theory of the symmetric group in voting theory and game theory. Algebraic and Geometric Methods in Discrete Mathematics, 685, 97. Daugherty, Z., Eustis, A. K., Minton, G., Orrison, M. E. (2009). Voting, the symmetric group, and representation theory. The American Mathematical Monthly, 116(8), 667-687. Saari, D. G. (1999). Explaining all three-alternative voting outcomes. Journal of Economic Theory, 87(2), 313-355. Saari, D. G. (2000). Mathematical structure of voting paradoxes. Economic Theory, 15(1), 1-53; 55-102]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>计算机</tag>
        <tag>北大</tag>
        <tag>抽象代数</tag>
        <tag>表示论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文笔记[7]——Privacy Analysis on Microblogging Online Social Networks: A Survey]]></title>
    <url>%2F2019%2F07%2F08%2F%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-7-%E2%80%94%E2%80%94Privacy-Analysis-on-Microblogging-Online-Social-Networks-A-Survey%2F</url>
    <content type="text"><![CDATA[文章：Oukemeni S, Rifà-Pous H, Puig J M M. Privacy Analysis on Microblogging Online Social Networks: A Survey[J]. ACM Computing Surveys (CSUR), 2019, 52(3): 60. 社交网络的隐私性调研 社交网络及其隐私性定义 什么是社交网络（OSN）？ 社交网络（Online Social Network）（以下简称OSN）是为用户提供以下服务的网络应用： 可创建半公开（原文用 semi-public）的档案； 可以加好友（creat connections）； 可以在系统中发布一些动态，并且可以查看一些其他用户发布的动态； OSN的隐私性 微观：user-related threats 用户的恐慌： 用户自己会发布一些敏感信息； 对手可以从不同用户的数据中挖掘一些隐藏的关系，也可以的从不同OSN中获取更多信息； 宏观：system provider-related threats 数据库的恐慌： OSN们收集了比他们所需要的更多的敏感信息； OSN中的数据用户无法彻底删除； 隐私保护 匿名化 Anonymization：去除可以直接识别用户的敏感信息或添加一些随机扰动； 去中心化 Decentralization：分散架构，避免数据及其使用权过于集中； 加密 Encryption：保护用户数据； 信息安全 Information security：维持数据的保密性、完整性和有效性； Fine-grained隐私与访问控制：没懂QAQ，大概是要让用户享受服务的同时隐私不被泄露？ 用户意识与行为变化 User awarness and hange of behavior：提高用户意识...听着像废话？ OSN相关的隐私法律法规 然后第一句话就是：Currently, there are no specific privacy regulations or laws for OSNs... 对于隐私性，有以下几种规则： Organization of Economic Cooperation and Development(OECD) General Data Protection Regulation(GDPR) Personal Information Protection and Electronic Document Act(PIPEDA) Information System Audit and Control Association(ISACA) ISO/IEC 29100:2011 评价隐私的指标 六种保护隐私的方面 1. 匿名 2. 去中心化 3. 加密 4. 信息安全 5. Fine-grained隐私与访问控制 6. 用户意识与行为变化 OSN在此方面的七个特征 1. 提供的服务 2. 架构 3. 存储与应答技术 4. 加密机制与秘钥管理 5. 安全目的 6. 隐私目的 7. 功能 Functionalities 提供的服务种类 架构 中心化架构； 非中心化架构； 混合架构； 存储与应答技术 中心服务器+单一权限； 联邦服务器？(federated servers)+多重权限； 非中心化架构； 混合架构； 加密机制与秘钥管理 对称加密； 非对称加密：公钥+私钥； 安全目的 可获取性：确保数据是可访问、可获取的； 完整性：保证数据的可靠性，避免未被授权的更改； 创建用户档案：用户在系统中能注册； 用户身份验证：入口的权限认证； 访问控制与隐私目的 档案是否默认可见； 是否可以更改档案的可见性； 动态是否默认可见； 是否可以更改动态的可见性； 系统管理员的访问权限：系统管理员是否能任意获取用户数据； 存储控制：用户是否能够控制数据的存储； 功能 Functionalities 档案管理：创建和管理用户档案； 好友关系：添加/删除好友； 动态和私信：发布动态和私信； 搜索功能：搜索用户、状态、评论等；可能会泄露用户的偏好信息 评论与回复功能：可能会泄露用户的Social graph； 提到其他用户：@其他用户的功能；泄露social graph 关注话题/设置兴趣：泄露用户的偏好信息 OSN 现况 文中将OSN分为实际存在的和不存在的两种： 文中对这些社交网络一一进行了评述，此处不展开。 OSNs 之间的比较与评估 服务种类、架构、存储技术 安全目的 Security goals 功能 Functionalities 隐私状况 Privacy Violation Comarison of Systems 下图对所有上文提到的OSN的功能、风险以及隐私保护三方面进行了比较。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>计算机</tag>
        <tag>北大</tag>
        <tag>社会计算</tag>
        <tag>论文笔记</tag>
        <tag>经济学</tag>
        <tag>隐私</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文笔记[6]——Fair assignment of indivisible objects under ordinal preferences]]></title>
    <url>%2F2019%2F06%2F04%2F%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-6-%E2%80%94%E2%80%94Fair-assignment-of-indivisible-objects-under-ordinal-preferences%2F</url>
    <content type="text"><![CDATA[文章：Aziz H , Gaspers S , Mackenzie S , et al. Fair assignment of indivisible objects under ordinal preferences[J]. Artificial Intelligence, 2015, 227:71-92. 离散物品，公平分配 基础知识 Assignment problem 是一个三元组 \((N,O,\succeq)\)： \(N=\{1,2,\cdots,n\}\)：参与者； \(O=\{o_1,\cdots,o_m\}\)：待分配物品（离散物品）； \(\succeq=\{\succeq_1,\cdots,\succeq_n\}\)：人对物品的偏好（单物品偏好，Ordinal preference）； 考虑到偏好可能是非严格的，因此将所有被选手 \(i\) 视为等值的物品记为一个等价类； 选手 \(i\) 的等价类共有 \(k_i\) 个； 按照顺序为 \(E_i^1,\cdots,E_i^{k_i}\)； 若某个 \(E_i^j\) 只包含一个物品 \(o\)，则我们在表示该等价类时，不区分 \(o\) 与 \(\{o\}\) 的区别； 若所有 \(E_i^j\) 都只包含一个物品，则此时的偏好是 严格 的。 设有 \(O&#39;\subseteq O\)，定义如下两个记号： \(\max_{\succeq_i}(O&#39;)=\{o\in O&#39;:o\succeq_i o&#39;, \forall o&#39;\in O&#39;\}\)； \(\min_{\succeq_i}(O&#39;)=\{o\in O&#39;:o&#39;\succeq_i o, \forall o&#39;\in O&#39;\}\)； 一个分数分配（fractional assignment）\(p\) 是指一个 \((n\times m)\) 双随机矩阵 \([p(i)(o_j)]\)； 实际上就是 Bogomolnaia 和 Moulin 所著 &quot;A New Solution to the Random Assignment Problem&quot; 一文中的随机性分配（random assignment），参见 论文笔记[1]——随机分配问题的PS算法和依次有效性 一文； 本文中对此的理解与 &quot;New solution&quot; 一文不同，没有以概率的眼光看待 \(p(i)(o_j)\)，而是认为 \(i\) 得到了 \(o_j\) 的一部分。两种思路其实是等价的； 一个分数分配是 离散 的（discrete），如果所有的 \(p(i)(o_j)\) 不是 \(1\) 就是 \(0\)。 平均分配（uniform assignment）是指 “每个人，都得到每个物品的 \(1/n\)” 的一个分数分配； 随机占优（stochastic dominance）的定义如下： Def 1.（随机占优） 参考 论文笔记[1]——随机分配问题的PS算法和依次有效性 一文中随机占优关系的定义。 这里记为 \(p(i)\succeq_i^{SD} q(i)\)。 严格随机占优 就是指 \(p(i)\) 随机占优于 \(q(i)\)，但反之不然； 所有与偏好 \(\succeq_i\) 相容的效用函数构成的集合记为 \(\mathcal{U}(\succeq_i)\)。 Def 2.（无嫉妒） 若对 \(\forall i\)，都有 \[u_i(p(i))\geqslant u_i(p(j)),~\forall j\in N\] 则称 \(p\) 是无嫉妒的。（基本上都是这个定义吧） Def 3.（Proportional） 若 \(\forall i\)，都有 \[u_i(p(i))\geqslant u_i(O)/n\] 则称 \(p\) 是 Proportional 的。（可以将其翻译为“按比例满足”） 每个单物品偏好都可以进行 合理 （responsive）扩张，在 \(O\) 的幂集上得到一个 合理 的偏好，记为 \(\succeq^{RS}_i\)。 合理性 的定义参见 论文笔记[3]——可接受集的定义与计算 一文中的 Def 3。 现在给出如下定理： Th 1.（随机占优的等价命题） 对于 离散 的分配 \(p\) 和 \(q\)，下列命题等价： \(p(i)\succeq_i^{SD} q(i)\)； \(\forall u_i\in \mathcal{U}(\succeq_i)\)，有 \(u(p(i))\geqslant u_i(q_i))\)； \(p(i)\succeq_i^{RS} q(i)\)； Proof. 首先，1 \(\iff\) 2 是显然的； 接下来我们证明 3 \(\Rightarrow\) 2：由于 \(p(i)\succeq_i^{RS} q(i)\)，故可以建立一个从 \(q(i)\) 到 \(p(i)\) 的单射，且 \(p(i)\) 中的物品比 \(q(i)\) 中的对应物品更受 \(i\) 的喜爱（即效用值更大）。因此 2 成立。 最后我们证明 1 \(\Rightarrow\) 3：假设 \(p(i)\not\succeq_i^{RS} q(i)\)。以 \(V=q(i)\cup p(i)\) 为结点构造二分图 \(G(V,E)\)，其中 \(\{o,o&#39;\}\in E\) 当且仅当 \(o\in q(i)\)，\(o&#39;\in p(i)\)，且 \(o&#39;\succeq_i o\)。由于 \(p(i)\not\succeq_i^{RS} q(i)\)，故 \(G\) 不存在填满 \(q(i)\) 的匹配，因而不存在完美匹配。由 Hall 定理，可得结论。 公平性定义框架 Proportional 弱 SD-proportional 没有人更 SD-喜欢 平均分配，即 \(\lnot[(1/n,,cdots,1/n)\succ_i^{SD} p(i)]\)，\(\forall i\in N\)； 可能 proportional 对每个人，都存在效用函数，使得在该效用下这个分配是 proportional 的，即 \(\forall i\in N\)，\(\exists u_i\in\mathcal{U}(\succeq_i)\)，s.t. \(u_i(p(i))\geqslant u_i(O)/n\)； SD proportional 每个人相比起 平均分配，都更喜欢 \(p\)，即 \(p(i)\succeq_i^{SD} (1/n,\cdots,1/n)\)，\(\forall i\in N\)； 必然 proportional 对每个人来说，只要是与偏好相容的效用函数，效用都不低于 平均分配，即 \(\forall i\in N\)，\(\forall u_i\in\mathcal{U}(\succeq_i)\)，总有 \(u_i(p(i))\geqslant u_i(O)/n\)； 无嫉妒 弱 SD-无嫉妒 每个人都不 SD-严格喜欢其他人所得的物品，即 \(\lnot[p(j)\succ_i^{SD} p(i)]\)，\(\forall i\in N\)； 可能 SD-无嫉妒 对每个人，都存在与其偏好相容的效用函数，使得在该函数下，这个分配是无嫉妒的，即 \(\forall i\in N\)，\(\exists u_i\in\mathcal{U}(\succeq_i)\)，s.t. \(u_i(p(i))\geqslant u_i(p(j))\)，\(\forall j\in N\)。 可能完全无嫉妒 对每个人 \(i\)，都存在一个集合的弱序（weak order），使得该弱序与 \(i\) 的偏好的某个 responsive 扩展相容，且在该弱序下，\(i\) 认为自己得到的东西优于其他人。 （虽然一眼看不懂是啥，但是后面好像证明了这玩意儿和 弱 SD-无嫉妒 等价... SD-无嫉妒 每个人都不会 SD-更喜欢其他人得到的东西，即 \(\forall i\in N\)，总有 \(p(i)\succeq_i^{SD} p(j)\)，\(\forall j\in N\)； 必然无嫉妒 所有与参与者偏好相容的效用函数，都会使得该分配是无嫉妒的，即 \(\forall i,j\in N\)，\(\forall u_i\in\mathcal{U}(\succeq_i)\)，有 \(u_i(p(i))\geqslant u_i(p(j))\)； 必然完全无嫉妒 对每个人 \(i\)，对于任一个集合的全序（total order），只要该全序与 \(i\) 的偏好的某个 responsive 扩展相容，那么在该全序下，\(i\) 就会认为自己得到的东西优于其他人。 （虽然一眼看不懂是啥，但是后面好像证明了这玩意儿和 SD-无嫉妒 等价... 以上定义之间的关系 Th 2.（等价关系） 对于任意数量的参与者和物品，有： 弱 SD-proportional \(\iff\) 可能 proportional； SD-proportional \(\iff\) 必然proportional； 弱 SD-无嫉妒 \(\iff\) 可能完全无嫉妒； SD-无嫉妒 \(\iff\) 必然无嫉妒 \(\iff\) 必然完全无嫉妒。 Th 3.（强弱关系） 对于以上公平性定义，有： SD-无嫉妒 \(\Rightarrow\) SD-proportional； SD-proportional \(\Rightarrow\) 弱 SD-proportional； 可能无嫉妒 \(\Rightarrow\) 弱 SD-proportional； 可能无嫉妒 \(\Rightarrow\) 弱 SD-无嫉妒。 对于两个参与者的情形，有： Th 4.（退化情形） 只有 \(2\) 个参与者时，有： proportional \(\iff\) 无嫉妒； SD-proportional \(\iff\) SD-无嫉妒； 可能无嫉妒 \(\iff\) 弱 SD-proportional； 可能无嫉妒 \(\iff\) 弱 SD-无嫉妒。 可将几种定义的关系总结如下： 计算复杂度 主要关心的问题： 是否存在满足某一公平性条件的离散分配； 若存在，如何得到这样的分配； 验证给定分配方案是否满足某一公平性定义； 这个显然很容易做... Remark 1. 对于所有的公平性定义，都可以在 \(m\) 和 \(n\) 的多项式时间内验证某一给定分配方案是否满足该公平性定义。 Remark 2. 对于常数个物品和任一种公平性定义，均可以在多项式时间内判定是否存在满足条件的离散分配方案。 Th 5. 若 \(p\) 是一个 SD-proportional 的分配，则 \(n~|~m\)，且分配方案中一定是每个人得到 \(m/n\) 个物品。 Th 6. 可以在多项式时间内判定是否存在 SD-proportional 的分配，即便偏好不是严格的。（原文用 agents are allowed to express indifference between objects.） Th 7. 在严格的偏好下，存在 弱 SD-proportional 的分配，当且仅当： \(m=n\) 且存在一个匹配方案，使得每个人都不会得到他最不喜欢的物品； \(m&gt;n\)。 进一步，该过程显然是多项式时间的，这说明 弱 SD-prop 是可以在多项式时间内判定存在性的。 Th 8. 可以在多项式时间内判定是否存在 SD-proportional 的分配，即便偏好不是严格的。（原文用 agents are allowed to express indifference between objects.）]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>数学</tag>
        <tag>计算机</tag>
        <tag>算法</tag>
        <tag>北大</tag>
        <tag>组合数学</tag>
        <tag>社会计算</tag>
        <tag>论文笔记</tag>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文笔记[5]——The undercut procedure: an algorithm for the envy-free division of indivisible items]]></title>
    <url>%2F2019%2F05%2F25%2F%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-5-%E2%80%94%E2%80%94The-undercut-procedure-an-algorithm-for-the-envy-free-division-of-indivisible-items%2F</url>
    <content type="text"><![CDATA[Brams S J, Kilgour D M, Klamler C. The undercut procedure: an algorithm for the envy-free division of indivisible items[J]. Social Choice and Welfare, 2012, 39(2-3): 615-631. 离散资源，无嫉妒划分 概要 两位参与者 \(A\) 和 \(B\)，分割一整个物品集 \(X\)； 二者的偏好均是 \(X\) 幂集 \(\mathcal{X}\) 上的全序； 文中提出UP算法，必定能得到一个 \(X\) 的无嫉妒划分： 无嫉妒的定义：每个人都觉得自己的比对方的好； 即使 \(A\) 和 \(B\) 的偏好完全相同也可以得到； 基本思路：Undercut： 一人提出proposal，另一人undercut。 基础知识 记号： \(i\) 的单物品偏好用 \(P_i\) 表示，每个 \(P_i\) 都是 严格、 完全 的； \(i\) 的偏好用 \(\succeq_i\) 表示； \(S\) 的补集用 \(-S\) 表示。 相关定义： Def 1. \(\mathcal{X}\) 上的偏好 \(\succeq\) 称为是合理（responsive）的，若 \(\forall S\in\mathcal{X}\) 和 \(\forall x\in X\)，\(y\in X\backslash S\)，总有： \(S\succ S\backslash \{x\}\cup\{y\}\iff x~P~y\)； \(S\backslash \{x\}\cup\{y\}\succ S\iff y~P~x\)； \(S\succ S\backslash\{x\}\)。（单调性，monotonic） Def 2. 令 \(S,T\subseteq X\)，\(S\neq T\)，令 \(P\) 是 \(X\) 上的一个严格的序。如果： 存在一个单射 \(\sigma_{T,S}: T\backslash S\to S\backslash T\)，s.t. \(\forall x\in T\backslash S, \sigma_{T,S}(x)~P~x\)； 则称 \(T\) 依次劣于（ordinally less）\(S\)，记作 \(T\leqslant_{OL} S\)。 简言之，\(S\leqslant _{OL}T\) 的意思就是存在 \(S\to T\) 的一个映射，按照这种对应，\(S\) 中的每个物品都不如 \(T\) 中的对应物品。（是 \(S\) 比 \(T\) 差了很多的意思） Def 3. 参与者 \(i\) 认为 \(S\subseteq X\) 是至少值50% 的，如果 \(S\succeq_i -S\)。 Def 4. 集合 \(S\subseteq X\) 对 \(i\) 来说是一个minimal bundle，如果： \(S\succeq_i -S\)； \(\forall T\leqslant _{OL} S\)，总有 \(-T\succeq_i T\)。 Def 5. \(\forall S\subseteq X\)，划分 \((S,-S)\) 是无嫉妒的，如果： \(S\succeq_A -S\)； \(-S\succeq_B S\)。 Def 6. 一个无嫉妒划分 \((S,-S)\) 称为是平凡（trivial）的，如果： \(S\sim_A -S\)； \(S\sim_B -S\)。 UP：Undercut Procedure UP算法的步骤 初始物品堆为 \(X\)，\(A\) 和 \(B\) 分别取当前物品堆中选取各自当前最喜欢的物品 \(x_A\) 和 \(x_B\)： 若 \(x_A\neq x_B\)：将 \(x_A\) 分配给 \(A\)，\(x_B\) 分配给 \(B\)； 若 \(x_A=x_B\)：将该物品放入待定区，记为 \(I_c\subseteq X\)； 继续执行 1，直到所有物品都被标记为 \(A\)，\(B\) 或 \(I_c\)； 考察 \(I_c\)： 若 \(I_c\) 为空，则分配结束...（这应该是 废话 显然的）； 若 \(I_c\) 非空，记参与者 \(i\)（\(i=A,B\)）在 \(I_c\) 中的minimal bundle集合为 \(MB_i\)，\(i\) 将 \(MB_i\) （私密地）提交给裁判； 若 \(MB_A\neq MB_B\)，则 \(i\) 将 \(i\) 将 \(MB_i\) 中的偏好顺序提交给裁判。 任取一名选手（例如是 \(A\)）； 取 \(MB_A\) 中排名最高的集合，记为 \(T\)： 若 \(T\notin MB_B\)，则称其为一个proposal，此时称 \(A\) 为一个proposer； 若 \(T\in MB_B\)，则转而考虑 \(MB_B\) 中排名最高的集合，判断其是否属于 MB_A$...反复进行； 由于 \(MB_A\neq MB_B\)，故反复进行上述步骤一定能得到一个 \(MB_A\) 中的排第一，但 \(MB_B\) 中不排第一 或者 \(MB_B\) 中的排第一，但 \(MB_A\) 中不排第一 的集合，将其作为proposal。 若 \(MB_A=MB_B\)： 若 \(\exists i\)，\(\exists S\in MB_i\)，s.t. \(-S\in MB_i\)，则此时将 \(S\) 做为 proposal，\(i\) 为proposer； 若 \(\forall i\)，\(\not\exists S\in MB_i\)，s.t. \(-S\in MB_i\)，则此时随意选择一个minimal bundle \(S\) 做为 proposal； 假设 \(S\) 是proposal，\(A\) 是proposer，则 \(B\) 的undercut操作为： （Accepting）若 \(-S\) 对于 \(B\) 是至少价值 50% 的，则 \(B\) 可以同意 \(I_c\) 的划分 \((S,-S)\)； （Undercutting）在所有比 \(S\) ordinally less的集合中，取 \(B\) 最喜欢的集合 \(T\)，重新提出划分 \((-T,T)\)； 最终得到一个划分 \((F,-F)\)，将 \(F\) 分配给 \(A\)，\(-F\) 分配给 \(B\)。 关于UP的讨论 Th 1. 存在一个非平凡的无嫉妒划分，当且仅当 \(MB_A\neq MB_B\)。并且该情形下，UP给出的是一个无嫉妒划分。 Proof. \(\Leftarrow\)：假设存在一个无嫉妒划分 \((S,-S)\)，则必定存在一个参与者更喜欢 \(S\)（不妨设为 \(A\)），即 \(S\succ_A -S\)。 - 若 \(S\notin MB_B\)，则 \(MB_A\neq MB_B\)，\(\Rightarrow\) 得证； - 若 \(S\in MB_B\)，则 \(S\succeq_B -S\)，结合 \((S,-S)\) 是一个无嫉妒划分，应有 \(-S\succeq_B S\)，因此 \(S\sim_B -S\)。现取 \(T\subset X\)，s.t. 对 \(B\) 而言有 \(T\leqslant_{OL} -S\)（同时亦有 \(S\leqslant_{OL} -T\)），则若 \(\succeq_B\) 是 合理 的，应有 \(-T\succ_B T\)，因此 \(-S\) 是 \(B\) 的 minimal bundle。即 \(-S\in MB_B\)，但 \(-S\) 显然不在 \(MB_A\) 中，因此 \(MB_B\neq MB_A\)。 \(\Rightarrow\)：若存在 \(S\)，s.t. \(S\in MB_A\) 但 \(S\notin MB_B\)，则有且仅有以下两种互斥的情形： \(S\succ_B -S\)，此时存在一个 \(T\leqslant_{OL} S\)，s.t. \(T\succeq _B -T\)，即 \(T\) 对 \(B\) 来说 至少价值50%； \(-S\succ_B T\)。 由于以上两种情况是互斥的，因此有且仅有一个发生。然而，在以上两种中的每一种情况下，\(B\) 都得到了 至少价值50% 的集合。同时，\(A\) 也得到了 至少价值50% 的集合： 若 \(B\) 接受了 \(A\) 的proposal，则 \(A\) 得到了 至少价值50% 的集合； 若 \(B\) undercut了\(A\) 的proposal，则\(B\) 的每一种undercut操作都会使得 \(A\) 得到 价值至少50% 的集合。 因此，此时一定能得到一个无嫉妒划分。 Cor 1. 在待定区的划分中，一个参与者（例如是 \(A\)）的 maximin 策略是给出自己所有的minimal bundle。若 \(MB_A\neq MB_B\)，则 \(A\) 的收益不会低于 50%，如果他的proposal是一个自己的minimal bundle。但若存在未提交的minimal bundle，或是提交了非minimal bundle 的集合，则可能导致他的收益低于 50%。 Def 7. 称 \(\mathcal{X}\) 上的偏好 \(\succeq\) 满足扩展单调性，如果： \(\forall S,T\in\mathcal{X}\)，所有单物品偏好 \(P\)，以及所有 \(x,y\in X\backslash(S\cup T)\)，总有： \[\begin{cases} S\succeq T \\ x~P~y \end{cases}\Rightarrow S\cup\{x\}\succ T\cup\{y\}.\] Prop 1. 假设参与者的偏好都是 合理 且 扩展单调 的，给定待定区的一个无嫉妒划分，则UP给出的整体划分是无嫉妒的。 Proof. 这个命题基本上一听就是个废话。 两个参与者偏好完全相同的情形 \(A\) 和 \(B\) 在 \(I_c\) 上的单物偏好相同，均为 \(1~P~2~P\cdots P~c\)； 记 \(I_c=\{1,2,\cdots,c\}\)。 Def 8. 集合 \(S\subseteq I_c\) 称为是可行的，如果存在一个 合理 的偏好 \(\succeq\)，s.t. \(S\succ -S\)。 Th 2. 令 \(S\subseteq I_c\)，且 \(S\neq\varnothing\)。则 \(S\) 是 可行 的，当且仅当存在 \(k\leqslant c\)，s.t. \(|I_k\cap S|&gt; \frac{k}{2}\)。 Proof. 这个定理的样子类似于 &quot;Computing a small agreeable set of indivisible items&quot; 一文中的 Prop 1，证明也比较显然。 Cor 2. 对 \(\forall c\)，\(\{1\}\) 和 \(\forall S\)，s.t. \(1\in S\) 都是 可行 的。 Cor 3. 假设 \(S\subseteq I_c\) 且 \(1\notin S\)。若 \(S\) 是 可行 的，则 \((S,-S)\) 和 \((-S,S)\) 都可能是无嫉妒的划分。 以上两个推论都很容易理解和证明...不再赘述。 除此之外，还有一个很有意思的结论： 用 \(f(c)\) 表示待定区包含 \(c\) 个物品时，\(I_c\) 的无嫉妒划分方案数，则有： \[f(c)=\begin{cases} 2^{c-1}-\binom{c}{(c-1)/2}, &amp; 2\not| ~c \\ 2^{c-1}-\binom{c}{c/2},&amp; 2~|~c \end{cases}\] 待定区大小的估计 用 \(n\) 表示物品数量，参与者 \(A\) 的偏好为 \(1P_A 2P_A\cdots P_A n\)，且该偏好是严格的； 记 \(c(n)\) 为待定区中物品个数的期望。 若 \(n=1\)，显然物品 \(1\) 会被丢入待定区，因此 \(c(1)=1\)； 若 \(n=2\)，则 \(B\) 的可能偏好有两种，每种情况的概率为 \(1/2\)，因此 \(c(2)=\frac{1}{2}\cdot 0+\frac{1}{2}\cdot 2=1\)。 若 \(n\geqslant 3\)，则： \(B\) 最喜欢物品 \(1\) 的概率为 \(\frac{1}{n}\)，此时 \(1\) 会被置入待定区，随后进入 \(c(n-1)\) 情形； \(B\) 最喜欢的不是 \(1\) 的概率为 \(\frac{n-1}{n}\)，此时 \(1\) 会被送给 \(A\)，\(B\) 也会得到他最喜欢的物品，随后进入 \(c(n-2)\) 情形。 综上所述，在 \(n\geqslant 3\) 时，有： \[c(n)=\frac{1}{n}[1+c(n-1)]+\frac{n-1}{n}c(n-2).\] Lemma 1. 若 \(c(n-1)=c(n-2)=x\)，则 \(c(n)=c(n+1)=x+\frac{1}{n}\)。 Proof. 这个证明是不是过于简单了... Th 3. 若 \(k\geqslant 1\)，则 \[c(2k+1)=c(2k+2)=1+\frac{1}{3}+\frac{1}{5}+\cdots+\frac{1}{2k+1}.\] Proof. 这个证明也很简单（ Th 3 表明，\(c(n)\) 是发散的。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>数学</tag>
        <tag>计算机</tag>
        <tag>算法</tag>
        <tag>北大</tag>
        <tag>组合数学</tag>
        <tag>社会计算</tag>
        <tag>论文笔记</tag>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文笔记[4]——On social envy-freeness in multi-unit markets]]></title>
    <url>%2F2019%2F03%2F15%2F%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-4-%E2%80%94%E2%80%94On-social-envy-freeness-in-multi-unit-markets%2F</url>
    <content type="text"><![CDATA[文章：Michele Flammini and Manuel Mauro and Matteo Tonelli, On social envy-freeness in multi-unit markets, Artificial Intelligence, volume 269, 2019, Pages 1-26. 准备工作 一个多单位市场 \(\mu\) 可以用一个元组 \((n, m, (v_i)_{i\in n})\) 来表示： \(N=\{1,\cdots,n\}\) 是 \(n\) 个买家； \(M\) 是商品集合，是一组 \(m\) 个相同的物品； \(v_i\) 是一族函数：对于每个买家 \(i\in N\)，\(v_i=(v_i(1),\cdots,v_i(m))\) 是一个估价函数（或说向量）. 其意义是给定一堆物品 \(X\subset M\)，且 \(|X|=j\)，则 \(i\) 为了买到 \(X\)，愿意付出的价值是 \(v_i(j)\). 我们假定 \(v_i(0)=0\)，且 \(j\geqslant 1\) 时，\(v_i(j)\geqslant 0\)，\(\forall i\in N\). 对估价函数，有两种假定： single-minded（一心一意的买家）：买家仅对一定数量的物品有兴趣，即只在一个特定的size处有正值（记为 \(m_i\)），其余时候都为 \(0\)； general：不受上述限制. 定价函数（向量）是指一个 \(m\) 元组 \(\overline{p}=(\overline{p}(1),\cdots,\overline{p}(m))\)，s.t. \(1\leqslant j\leqslant m\)，\(\overline{p}(j)\geqslant 0\) 表示 \(j\) 个物品的价格, 对于商品的定价模式，也有两种假定： item-pricing：按照物品来定价，例如单个物品价格是 \(p\)，则 \(\overline{p}(X)=|X|\cdot p\). bundle-pricing：对一捆物品直接定价，并且该价格与物品数量不是成比例的（否则同item-pricing）. 消费者的效用（utility）是指：消费者对所得物品的估价 \(-\) 消费者为此付出的价格. 即：\[u_i(X,\overline{p})=v_i(|X|)-\overline{p}(X).\] 一个分配向量是指一个 \(n\) 元组 \(\overline(X)=\{X_1,\cdots,X_n\}\)，其中 \(X_i\subset M\) 表示分配给买家 \(i\) 的商品. 称一个分配是可行的，如果： 货物够分：\(\sum\limits_{i=1}^n |X_i|\leqslant |X|\)； 买家不傻：\(u_i(X_i,\overline{p})\geqslant 0\). 一个市场输出 \((\overline{X},p)\) 的总收益用 \(r(\overline{X},p)\) 表示. Def 1. 一个市场 \(\mu\) 得出的一个可行分配 \((\overline{X},\overline{p})\) 在关系图 \(G(V,E)\) 下是社会无嫉妒（或称稳定）的，如果 \(u_i(X_i,\overline{p})\geqslant u_i(X_j,\overline{p})\)，\(\forall i\in N\)，\(j\in N(i)\)，其中 \(N(i)\) 表示图 \(G\) 中 \(i\) 的所有邻居构成的集合. 该定义实际上是说，每个人相比邻居得到的，更喜欢自己得到的，那么就不会嫉妒邻居. 每个人都不嫉妒自己认识的人，那么久无嫉妒了； 当图 \(G\) 是完全图时，此时的social envy-free即常义的无嫉妒. Def 2. 给定一族市场模型 \(\mathcal{M}\) 和一族社会关系图 \(\mathcal{G}\)，无嫉妒的代价（price of envy-free）\(c(\mathcal{M}, \mathcal{G})\) 是指：不考虑无嫉妒时 \(\mathcal{M}\) 中模型能达到的最大收入与考虑无嫉妒后的最大收入的比值的上确界，即： \[c(\mathcal{M}, \mathcal{G})=\sup_{\mu\in\mathcal{M}, G\in\mathcal{G}}\frac{opt(\mu)}{opt(\mu,G)}.\] 在对分配问题进行讨论时，我们经常将其规约到 MULTIPLE-CHOICE KNAPSACK（多重背包问题）. 多重背包问题 \((o,z,w,k)\)： \(O\)：物品集合； \(z\)：物品体积； \(w\)：物品价值； \(k\)：背包容量. 我们通常这样构造： 背包的容量为 \(k\)； 考虑 \(t\) 个物品类 \(\{O_1,\cdots,O_t\}\)； 物品 \(o_{j,h}\) 的体积和价值分别是 \(z_{j,h}\) 和 \(w_{j,h}\). 我们需要从每个物品类中恰好选取一个物品装入，使得总价值最大，且总体积不超过背包容量. 多重背包问题已被证明是NP难的，但有FPTAS近似解法. single-minded买家 按照定价模式，有两种情况，分述如下. Item-pricing Lemma 3. 对于single-minded买家，设 \(p^{opt}\) 是能达到最优稳定分配 \((\overline{X}^{opt},p^{opt})\) 的价格函数，且能最大化卖家的收入，则 \(p\in\mathbb{P}=\{\frac{v_i(m_i)}{m_i}|i\in N\}\). 这个引理实际上是在说，对于single-minded情况，最优定价 \(p^{opt}\) 一定是某个买家对单物品的估价. Proof. 假设 \((\overline{X}^{opt},p^{opt})\) 中的 \(p^{opt}\notin\mathbb{P}\). 取 \(p=\frac{v_i(m_i)}{m_i}\in\mathbb{P}\) 为 \(\mathbb{P}\) 中比 \(p^{opt}\) 大的最小者，考虑 \((\overline{X}^{opt},p)\)： 由于二者的分配方案是一致的，故 \((\overline{X}^{opt},p)\) 也满足可行性的两个要求（货物够分，买家不傻）. 现将价格从 \(p^{opt}\) 涨至 \(p\)，没有任何卖家的效用会因此变为负值. 于是 \((\overline{X}^{opt},p)\) 也是social envy-free的，因为价格的上涨只会使得估值在 \(p^{opt}\) 与 \(p\) 之间的买家效用变为 \(0\)，因此对于买家对邻居的评估没有影响，故仍然是social envy-free的. 但是，值得注意的是 \(p\) 显然会比 \(p^{opt}\) 给卖家带来严格正的收益增幅，故 \(p\) 比 \(p^{opt}\) 更优. This is a contradition. 命题得证！ 尽管有了该结论，但 (SINGLE, ITEM) 设定下的分配问题仍然是困难的： Th 4. (SINGLE, ITEM) 设定下的分配问题是NP难的. 其证明考虑从 SUBSET-SUM 问题进行规约. SUBSET-SUM 问题：给定一个自然数集 \(A\subset\mathbb{N}\) 以及一个自然数 \(k\in\mathbb{N}\)，找到 \(S\subset A\)，s.t. \(\sum_{a_i\in S} a_i=k\). 一个 SUBSET-SUM 问题通常可以被表示为 \((A=\{a_1,\cdots,a_n\},k)\). Proof. 记 \(N=\{1,\cdots,N\}\)，\(M=\{1,\cdots,M\}\)，\(v_i(x)=\begin{cases} a_i, &amp; x=a_i \\ 0, &amp; x\neq a_i \end{cases}\)，则： 考虑 SUBSET-SUM 中的一个 \(S\)，若 \(a_i\in S\)，则给买家 \(i\)分配一捆大小为 \(a_i\) 的商品，否则不给 \(i\) 分配任何东西. 反过来，市场 \(\mu\) 的每一个输出也对应了一个 \(S\). 由 Lemma 3，要想达到最优结果，\(\mu\) 的单物品定价必定是 \(1\)，此时所有买家的效用都是 \(0\)，因而是稳定的. 因此，\(A\) 存在和为 \(k\) 的子集 \(S\)，当且仅当 \(\mu\) 在稳定前提下的最大收益是 \(k\). 尽管问题本身是NP的，但存在好的近似算法. Th 5. (single,item) 分配问题有FPTAS. 考虑算法： 对 \(\forall p\in\mathbb{P}\)： 对 \(\forall j\)，定义： \(N_j^+\)：对大小为 \(j\) 的商品集持严格正估价的买家数，\(n_j^+=|N_j^+|\)； \(N_j^0\)：对大小为 \(j\) 的商品集持零估价的买家数，\(n_j^0=|N_j^0|\)； 建立如下的背包问题 \(K(\overline{O},\overline{z},\overline{w},k)\)： \(k=m\)； 对每个至少有一个买家喜欢的 \(j\)，\(O_j=\{o_{j,0},\cdots,o_{j,n_j^0},\}\) 表示 \(j\) 生成的 \(n_j^0+1\) 个物品； \(z_{j,h}=w_{j,h}=j\cdot (n_j^++h)\)，\(\forall o_{j,h}\in O_j\). 求解该背包问题，对得到的结果做如下处理： 若选择了物品 \(o_{j,h}\)，则给所有 \(N_j^+\) 中的买家以及 \(h\) 个 \(N_j^0\) 中的买家每人分配 \(j\) 个商品. 得到分配方案后，即可计算收入并将其存下来. 在所有 \(p\) 中，求使得收入最大的分配方案 \((\overline{X},p)=\arg\max_p r(\overline{X}&#39;,p&#39;)\). 以下对该算法进行证明： Proof. 由 Lemma 3，对每个 \(p=\frac{v_i(m_i)}{m_i}\)，\(i\in N\)，我们建立一个多重背包问题 \(K(\mu\))...（具体构建方法见上述算法） 构建完成后，我们来证明：一个 \(K(\mu)\) 的解 \(T\)，对应着一个 \(\mu\) 的稳定输出 \((\overline{X},p)\). 事实上，\(T\) 所装载的物品不会超过背包容量，而背包容量恰好就是商品的总量. 进一步，\(\overline{X},p)\) 是稳定的，因为当我们分配了一捆数量为 \(j\) 商品时，只有 \(N_j^+\) 里的人可能会因此产生嫉妒. 于是对于确定的 \(p\)，\(K(\mu)\) 的 \((1-\epsilon)\)-近似解 \(T\)，都对应了一个 \(\mu\) 的 \((1-\epsilon)\)-近似解 \((\overline{X},p)\)，并且这个解是稳定的. Th 6. (SINGLE, ITEM) 问题是强NP难的. 证明考虑规约到问题 DENSEST K-SUBGRAPH： 给定无向图 \(H(V,F)\) 和整数 \(k\)，求一个 \(S\subset V\)，s.t. \(|S|\leqslant k\) 且 \(S\) 能最大化 \(S\) 引出的边数. 一个 DENSEST K-GRAPH 的实例由 \((G,k)\) 二元组表示. Proof. 进行如下考虑： 对市场 \(\mu\)： 对每个 \(u\in V\)，将其与 \(|F|+1\) 个买家对应（记为 \(N_u\)）. 进一步，对每个 \(i\in N_u\)，都有 \(v_i(1)=1+\epsilon\)，其中 \(\epsilon=\frac{k}{|V|+1}\)； 对图 \(G\) 的每条边 \(e\in F\)，存在一个买家 \(i_e\)，s.t. \(v_{i_e}=1\)； 再来一个买家 \(w\)，s.t. \(v_w(|V|(|F|+1))=|V|(|F|+1)\)； 总共有 \(m=(|V|+k)(|F|+1)+|F|\) 件商品. 对社会关系图 \(G(N,E)\)： 设 \(u\in V\)，则对所有 \(i,i&#39;\in N_u\)，有 \(\{i,i&#39;\}\in E\)； 对 \(\forall i\in N_u\)，\(\{i,i_e\}\in E\)，其中 \(e\) 在 \(H\) 中是由 \(u\) 引出的. 以下证明 \(H\) 存在一个有 \(h\) 条边的 \(k\) 阶子图，当且仅当上述市场 \(\mu\) 在 \(G\) 下有一个稳定的输出 \((\overline{X},p)\)，s.t. \(r(\overline{X},p)=(|V|+k)(|F|+1)+h\). 简单来说，就是： 买家一共有 \((|V|+1)(|F|+1)\) 个： 给 \(V\) 里的每个点分别配 \(|F|+1\) 个未来在 \(G\) 中的邻居，记作 \(N_u\)，这些邻居都只喜欢一个物品，并且效用只比 \(0\) 严格大一点点；（这里共 \(|V|(|F|+1)\) 个） \(H\) 里的每条边，都对应一个买家，只喜欢一个物品，且效用是 \(0\)；（这里共 \(|F|\) 个） 有一个超级买家，喜欢很多物品，但效用是 \(0\)；（这里共 \(1\) 个） 物品总量是 \((|V|+k)(|F|+1)+|F|\)，小于总需求量： 上述第1步，共需要物品 \(|V|(|F|+1)\) 个； 上述第2步，共需要物品 \(|F|\) 个； 上述第3步，共需要物品 \(|V|(|F|+1)\) 个； 图 \(G\) 是这样规划的： 所有 \(N_u\) 内部的点两两相连； 点 \(u\) 在 \(H\) 中的所有邻居，在 \(G\) 中都要与 \(u\) 现在的所有邻居相连； 先证 \(\Rightarrow\)：假设 \(|S|=k\) 且 \(S\) 引出的边数为 \(h\). 考虑 \(p=1\) 时的输出，得到物品的买家为 \[\{w\}\cup\bigcup_{u\in S} N_u\cup\{i_e\in N:e=\{u,z\}\in F,~u,z\in S\}.\] 就是说，给：超级卖家 \(w\)，\(S\) 中的所有点对应的买家，以及 \(S\) 内部所有边对应的卖家 分配了商品. 考虑所有 \(i_e\) 中未得到物品的买家，他们所喜欢的物品对他们的效用也不过是 \(0\)，所以不会产生嫉妒；其他未得到物品的买家，他们所处的 \(N_u\) 中，\(u\notin S\)，即他们的邻居也都没有得到东西，故他们也不会产生嫉妒. 于是 \((\overline{X},p)\) 是稳定的，其总收益是 \((|V|+k)(|F|+1)+k\). 再证 \(\Leftarrow\)：假设存在总收益为 \((|V|+k)(|F|+1)+h\) 的稳定输出 \((\overline{X},p)\)，则： 在 \((\overline{X},p)\) 中，\(p\) 绝不能严格大于 \(1+\epsilon\)，否则收益将为 \(0\) （这是个废话）. 事实上，如果 \(p&gt;1\)，那么只有 \(N_u\) 里的买家愿意购买，此时收益至多为 \[(1+\epsilon)[|V|(|F|+1)]&lt;(|V|+k)(|F|+1)+h,~~其中~ \epsilon=\frac{k}{|V|+1}.\] 因此，必定有 \(p\leqslant 1\). 此时，为获取 \(r(\overline{X},p)=(|V|+k)(|F|+1)+h\) 的总收益，必须满足超级买家 \(w\) 的购买需求. 继续进行分配，由稳定性条件，\(N_u\) 只要有一个人得到了他想要的商品堆，\(N_u\) 里的其他人也必须得到他们想要的. 又根据解的可行性条件（商品够 + 人不傻），我们至多分给 \(k\) 个 \(N_u\) 足够的商品，考虑到预期收益，我们也必须分给 \(k\) 个 \(N_u\) 足够的商品. 至此，还剩 \(h\) 个商品，分配给 \(i_e\) 中的买家. 此时考虑 \(S=\{u:\forall i\in N_u,|X_i|=1\}\)（即所分到物品的 \(N_u\) 的 \(u\) 构成的集合），容易知道 \(|S|=k\). 以下只需说明 \(S\) 引导的 \(H\) 的子图至少有 \(h\) 条边，而这正是分配了物品的 \(i_e\) 的数量. 因此由一个市场也可以导出一个 DENSTEST K-GRAPH 的解. 由 DENSTEST K-GRAPH 的复杂性，命题得证. 由以上的定理可知，分配问题的 FPTAS 是不存在的（除非已经证明 \(P=NP\)）. 另一方面，我们可以找到一个较好的近似算法（一个 PTAS）. 证明思路：给定了 \((\mu, G)\) 和给定的价格 \(p\)，\(j\leqslant m\)，\(h\leqslant n\). 假设我们可以迅速求解一个受限制的子问题：将商品每 \(j\) 个捆成一捆，再在 \(G\) 下分给 \(h\) 个买家，且该分配在 \(G\) 下稳定（如果存在）. \(J\) 表示所有“至少有一个买家喜欢的物品量”构成的集合，且至多含 \(n\) 个元素. 在以上假设之下我们甚至可以找到一个 FTPAS，仍然是利用多重背包 \(K(\mu, G,p)\)： 背包容量 \(k=m\)； 对 \(\forall j\in J\)，考虑 \(O_j=\{o_{j,h}:存在~j~个商品分给~h~个买家的在~G~下稳定的分配\}\)； 物品的重量和价值：\(z_{j,h}=w_{j,h}=j\cdot h\). 事实上，这样的一个背包的物品个数是多项式的. 至多有 \(n\) 个不同的物品类 \(O_j\)； 每个物品类都至多有 \(n\) 个物品. 于是由 Lemma 3，对每个 \(p=\frac{v_i(m_i)}{m_i}\) 跑一次 FPTAS，选取最大的总收益，这样就得到了一个多项式时间的 \((1-\epsilon)\)-近似. 即一个 (SINGLE, ITEM) 的FPTAS. 然而，由 Th 6，上述思路的基本假设就是不成立的...换言之，受限制的子问题是不可能在多项式时间内解决的. 然而，以下的近似结果仍能保持： Lemma 7. 给定一个 (SINGLE, ITEM) 分配问题的实例和一组固定的价格 \(p\)，\(j\leqslant m\)，\(h\leqslant n\)，则求一个 将商品 \(j\) 个一捆包装起来，分给至多 \(h\) 个买家的分配； 在 \(G\) 下稳定； 能最大化总收益； 这样的问题，存在一个 PTAS. Proof. 记 \(N_j^+\) 和 \($N_j^0\) 分别为在价格 \(p\) 下对 \(j\) 持严格正效用的买家以和持零效用的买家，记 \(G_j^*\) 为 \(N_j^+\) 引导的子图，则对于任意 \(\mu\) 的稳定（文中用了optimal）输出 \((\overline{X},p)\)，\(G_j^+\) 的所有连通分支中的买家要不都获得 \(j\) 个商品，要不都没有得到 \(j\) 个商品. （由稳定性易得） 取定 \(\epsilon&gt;0\)，记 big 为 \(G_j^+\) 的至少包含 \(\epsilon\cdot h\) 个买家的连通分支（可能有多个），small 为其余的连通分支. 则，任意的optimal输出 \((\overline{X},o)\) 至多分给 \(h\) 个人每人 \(j\) 个商品，于是 \((\overline{X},p)\) 至多给 \(O(\lfloor\frac{1}{\epsilon}\rfloor)\) 个 big 连通分支分配商品. 当然，此外它还可以给一些 small 的连通分支分配商品. 再次，也可以给 \(N_j^0\) 中的买家分配，但仅限通过 \(G_j^+\) 与 \(G\) 相连的买家. （否则可能引起嫉妒） 考虑以下步骤： 给所有 big 连通块分配商品； 不停地给 small 连通块分配商品，直到无法分配. 无法分配有两种情况： 商品不够分了： 此时至少有 \((1-\epsilon)h\) 个买家被分配了商品； 所有small都被分配了商品： 继续给 \(N_j^0\) 中的弟兄们分配商品，直到无法继续，有以下两种情况： 总共已经分配了 \(h\) 个买家：如此便是一个optimal分配； 所有 \(N_j^0\) 中的买家都被分配了商品：我们也得到了最优的结果. 综上所述，以上算法可以产出一个 \((1-\epsilon)\)-近似最优结果，并且是多项式时间的. 由以上引理，给定价格 \(p\)，我们可以构造一个多重背包的近似实例 \(K_\epsilon(\mu, G, p)\)，对应于 MULTIPLE-CHOICE KNAPSACK 实例 \(K(\mu,G,p)\)： 背包容量 \(k=m\)； 对每个 \(j\in J\)，物品类 \(O_j=\{o_{j,l}:对某个~1\leqslant h\leqslant n~运行上述PTAS，j~个一捆，买家数~l\leqslant h\}\)； 体积和价值：\(w_{j,l}=z_{j,l}=j\cdot h\). 显然，若 \(T=\{o_{j_1,h_1},\cdots,o_{j_t,h_t}\}\) 是 \(K(\mu,G,p)\) 的一个可行解，则存在一个 \(K_\epsilon(\mu,G,p)\) 的可行解 \(\{o_{j_1,l_1},\cdots,o_{j_t,l_t}\}\)，s.t. \((1-\epsilon)h_q\leqslant l_q\leqslant h_q\)，\(\forall 1\leqslant q\leqslant t\). 因此，若用 \(opt(K)\) 和 \(opt(K_\epsilon)\) 分别表示 \(K\) 和 \(K_\epsilon\) 的最优解，我们有 \(opt(K_\epsilon)\geqslant (1-\epsilon)opt(K)\). 进一步，\(opt(K_\epsilon)\) 对 \(K\) 也是可行的. 进一步，有以下定理成立： Th 8. (SINGLE, ITEM) 问题有 PTAS. 考虑算法： 对每个 \(p=\frac{v_i(m_i)}{m_i}\)： 计算多重背包 \(K_{\epsilon/2}(\mu,G,p)\)； 记 \(T\) 为 \((K_{\epsilon/2}(\mu,G,p),\epsilon/2)\)； 对 \(\forall o_{j,l}\in T\): \(\overline{X}\) 给 \(l\) 个买家每人一个大小为 \(j\) 的物品堆； 算一下收益. 收益对所有 \(p\) 取最大. Proof. 证明暂时从略Orz. Bundle-pricing 与item-pricing相同，bundle-pricing情形的计算也是困难的. Th. 9 (SINGLE, BUNDLE) 分配问题是NP难的. Proof. 与 Th 4 进行类似的规约（利用 SUBSET-SUM），集合 \(S\subset A\) 对应于一个市场 \(\mu\) 的输出： 买家 \(i\) 得到大小为 \(a_i\) 的一捆商品，当且仅当 \(a_i\in S\). 进一步，一个最优的稳定分配方案中，已分配的大小为 \(j\) 的物品堆价格至少是 \(j\)，否则提价到 \(j\) 可继续增大收入. 于是： 存在 SUBSET-SUM \((A,k)\) 的解，当且仅当 \(\mu\) 存在收益为 \(k\) 的最优稳定分配. 不过Bundle-pricing条件下，同样有好的近似. Th 10. (SINGLE, BUNDLE) 分配问题有FPTAS. Proof. 考虑给定的物品堆大小 \(j\leqslant m\)，令 \(i_{j,1},\cdots,i_{j,n_j}\) 为买家对 \(j\) 的喜好程度的顺序，即 \(v_{i_{j,1}}(j)\geqslant \cdots\geqslant v_{i_{j,n_j}}(j)\). 对于 \(h\leqslant n_j\)，取价格 \(v_{i_{j,h}}(j)\)，考虑 \(h\) 个大小为 \(j\) 的物品堆分给上述序列的前 \(h\) 位的情况，它将得到一个稳定的分配. 由于一心一意的买家只可能嫉妒和自己有相同喜好的买家，故上述过程可以对任意“至少有一个买家喜欢的bundle size”运行. 到这一步，就可以继续参考item情形的思路，规约到多重背包问题. 考虑以下算法： 对每个 \(j\in J\)，令 \(i_1,\cdots,i_{n_j}\) 为 \(n_j\) 个喜欢大小为 \(j\) 的物品堆的买家的序，即 \(v_{i_1}(j)\geqslant\cdots\geqslant v_{i_{n_j}}(j)\). 构造如下的多重背包问题： 背包容量 \(k=m\)； 物品类 \(O_j=\{o_{j,i,h}:i\in N,h]in M\}\)； 体积 \(z_{j,i,h}=v_{j,h}(j)\cdot h\)； 价值 \(w_{j,i,h}=j\cdot h\)； 令 \(T\) 为背包问题 \((K,\epsilon)\) 的解； 对每个 \(o_{j,i,h}\in T\)： \(p(j)=v_{j,h}(j)\)； 给 \(i_{j,1},\cdots,i_{j,h}\) 每人一个大小为 \(j\) 的物品堆 应当注意，上述算法中没有用到社会关系图 \(G\) 的任何信息，即该算法在完全图下也是social envy-free的. 事实上，后文将证明，在 (SINGLE, BUNDLE) 设定下，social envy-free与否不影响总收益的大小. 与前文类似，可立刻得到如下推论： Cor 11. (SINGLE, BUNDLE) 分配问题有FPTAS. 自由处置 什么是自由处置（Free disposal） 自由处置是指，不考虑代价的情况下，拿到更多的东西总不是坏事。体现在估价函数上，就是指： \[v(j)\geqslant v(i),~~若~j\leqslant i.\] 如果对于single-minded买家 \(i\)，应有： \[v_i(j)\geqslant v_i(m_i),~~若~j\geqslant m_i.\] 以下引理来自文献27：Revenue maximization envy-free pricing for homogeneous resources. IJCAI 2015. Lemma 12. 给定一个pair envy-free的输出 \((X,p)\)，若其不满足货物够分的条件，则可在多项式时间内找到一个pair envy-free的可行输出 \((X&#39;,p&#39;)\)，s.t. \(r(X&#39;,p&#39;)\geqslant \frac{m}{2}\cdot p\). 仍然考虑 (SINGLE, ITEM) 的买家，与非自由处置情形（能找到一个多项式规模的最优定价集 \(\mathbb{P}=\{\frac{v_i(m_i)}{m_i}\}\)）不同，此处不能找到多项式规模的最优定价集 \(\mathbb{P}\) （即至少能包含一个 \(p^{opt}\)，使其能构成一个稳定的最优输出 \((X^{opt}, p^{opt})\)）. 然而，考虑定价集 \(\mathbb{P}_\epsilon=\{(1+\epsilon/2)^\ell\}\)，其规模对于输入规模和 \(1/\epsilon\) 是多项式级别的，并且至少包含一个价格 \(p\)，s.t. 对于某个 \(p^{opt}\)，有 \(\frac{p^{opt}}{1+\epsilon/2}\leqslant p\leqslant p^{opt}\). 最终的算法需要对 \(\mathbb{P}_\epsilon\) 中的每一个 \(p\)，选择最优的分配方案. 不失一般性，设买家的最低估价为 \(1\)，再令 \(v_{max}\) 为最大的买家估价，给定 \(\epsilon&gt;0\)，令 \(\mathbb{P}_\epsilon=\{(1+\epsilon/2)^\ell :-\log_{(1+\epsilon/2)}m\leqslant \ell\leqslant \log_{(1+\epsilon/2)}v_{max}\}\). 则 \(\mathbb{P}\) 的规模大约为 \(O(\log_{(1+\epsilon/2)}m+\log_{(1+\epsilon/2)}v_{max})=O(\frac{\log v_{max}+\log m}{\epsilon})\). 又由于 \(p^{opt}\) 须满足 \(\frac{1}{m}\leqslant p^{opt}\leqslant v_{max}\)，故 \(\mathbb{P}\) 中存在一个 \(p\)，s.t. \(\frac{p^{opt}}{1+\epsilon/2}\leqslant p\leqslant p^{opt}\). 定义一个子问题： 给定市场 \(\mu\) 和定价 \(p\)，求一个 pair envy-free 的分配方案 \((\overline{X},p)\)，s.t. 该方案能最大化已分配的商品数量（无视商品总量的限制）. 则整个问题将通过如下算法转化为子问题的求解： 记 \(\mathbb{P}_\epsilon=\{(1+\epsilon/2)^\ell :-\log_{(1+\epsilon/2)}m\leqslant \ell\leqslant \log_{(1+\epsilon/2)}v_{max}\}\)； 对于每个 \(p\in\mathbb{P}_\epsilon\)： 对 \((\mu,p)\) 找到一个（不考虑商品数量限制）卖掉商品最多的分配，记为 \((\overline{X}^p,p)\)（子问题他lei了）； 记 \((\overline{X}^{p&#39;},p&#39;)\) 为 \((\overline{X}^p,p)\) 按照 Lemma 12 的方法所得到的可行解； 算一下收益； 对所有 \(p\) 算最大收益. 记 \((\overline{X}^{opt},p^{opt})\) 是一个最优输出，\(p=(1+\epsilon/2)^{\lfloor \log_{(1+\epsilon/2)}p^{opt} \rfloor}\in\mathbb{P}_\epsilon\)，s.t. \(\frac{p^{opt}}{1+\epsilon/2}\leqslant p\leqslant p^{opt}\). 由于 \(p\leqslant p^{opt}\)，故在子问题中，\(p\) 对应的方案能比 \(p^{opt}\) 对应的方案卖掉更多（至少不会更少）的商品. 考虑 \(\overline{X}&#39;\)，s.t. \(|X_i&#39;|=|X_i^{opt}|\)，若 \(X_i^{opt}\neq\varnothing\)，且 \(|X_i&#39;|\) 是被 \(\overline{X}^{opt}\) 分配的商品集大小中，在 \(p\) 下使 \(i\) 的效用最大的商品集大小？？？ 显然，\(\overline{X}&#39;\) 在 \(p\) 下是pair envy-free的，并且至少分配了和 \(\overline{X}^{opt}\) 一样多的商品. 因此，对于子问题的最优解，它一定是这样的一个 \(\overline{X}^p\)，s.t. \(\sum\limits_{i=1}^n |X_i^p|\geqslant \sum\limits_{i=1}^n |X_i&#39;|\leqslant \sum\limits_{i=1}^n |X_i^{opt}|\). 若 \(\sum\limits_{i=1}^n |X_i^p|&gt; m\)，则 \((\overline{X}^p,p)\) 分配了过多的商品，应当用 Lemma 12 来修正为 \((\overline{X}^{p&#39;},p&#39;)\). 于是，考虑到 \((\overline{X}^{p&#39;},p&#39;)\) 至少分配了 \((\overline{X}^{opt},p^{opt})\) 所分配商品量的一半，并且价格 \(p&#39;\geqslant p\geqslant \frac{p^{opt}}{1+\epsilon/2}\)，故 \(r(\overline{X}^{p&#39;},p&#39;)\geqslant \frac{r(\overline{X}^{opt},p&#39;)}{2}\geqslant \frac{r(\overline{X}^{opt},p^{opt})}{2+\epsilon}\). 至此，我们只剩下子问题的最优解需要讨论. 给定一个pair envy-free的分配方案 \((\overline{X},p)\)，使其能在市场 \((\mu,p)\) 下最大化商品分配数. 记 \(B_{\overline{X}}\) 为 \(\overline{X}\) 中出现的所有“商品捆”大小构成的集合. 由于 \(\overline{X}\) 是pair envy-free 并且最优的，故对于每个对 \(B_{\overline{X}}\) 中至少一个 \(j\) 持非负效用的买家，我们都必须给该买家分配他认为最好（效用最高）的商品量. 因此，给定 \(B_\overline{X}\)，我们可以在多项式时间内将 \(\overline{X}\) 重建，换言之，子问题的解决只需确定 \(B_\overline{X}\). 注意到，给定 \(p\)，每个买家 \(i\)，若 \(m_i\leqslant \frac{v_i(m_i)}{p}\)，则 \(i\) 对所有处在区间 \([m_i, \lfloor\frac{v_i(m_i)}{p}\rfloor]\) 中的“捆大小”都具有非负效用（这是句废话）. 由于一捆商品的价格会随着size增大而增大，但价值并不会，因此效用是在递减的（也是废话）. 因此，给定 \(B_\overline{X}\)，（若下述集合为空，则取 \(0\)） \[|X_i|=\min\{t:t\in [m_i, \lfloor\frac{v_i(m_i)}{p}\rfloor]\cap B_\overline{X}\}.\] 由于输入可能是指数级别？？？为什么？故我们需要搞一个包含 \(B_\overline{X}\) 的多项式级别的集合 \(B_p\). Lemma 14. 给定市场 \(\mu\) 和价格 \(p\)，令 \(B_p=\{\lfloor\frac{v_i(m_i)}{p}\rfloor :i\in n\}\)，则 \(B_\overline{X}\subset B_p\)，对所有最大化商品分配数的输出 \((\overline{X},p)\). 证明考虑反证法，假设存在 \(j\notin B_p\)，再记 \(N_i\) 为所有在 \((\overline{X},p)\) 中拿到 \(j\) 个物品的买家. 将他们得到的商品量调整为 \(\min_{i\in N_j}\frac{v_i(m_i)}{p}\) 即可. 细节略去. 最终子问题的解决办法如下: 令 \(B_p=\{\lfloor\frac{v_i(m_i)}{p}\rfloor:i\in N\}\)； 对 \(j\in B_p\)（从大到小）： 计算一个“最大化‘收入’的分配”所分配掉的商品总数 \(x(j)\)，其所分配的最小的商品集大小为 \(j\)，即：\[x(j)=\max\{\max_{k\in B,k&gt;j}\{x(k)+\Delta_k^j\},~j\cdot|N_j|\};\] 返回最大的 \(x(j)\) 所对应的分配 \((\overline{X}^j,p)\). General 买家 Item-pricing 现有如下猜想： 一个随机的 \(n\) 元3-SAT问题，有 \(m=\Delta n\) 条约束，该猜想断言对 \(\forall \epsilon&gt;0\)，以及一个与 \(n\) 无关的大常数 \(\Delta\)，不存在这样的多项式时间算法，能够求解满足 \((1-\epsilon)\) 比例的约束. 一个问题被称为是 R3SAT 困难的，如果”该问题有多项式时间解法“能够证伪上述猜想. Def 15. MES 是如下的问题： 给定全集 \(U\) 和一个有序子集族 \(\mathcal{C}=\{S_1,\cdots,S_c\}\)； 一个长度为 \(\ell\) 的扩张序列(expanding sequence)\(\phi=(\phi(1)&lt;\cdots&lt;\phi(\ell))\) 是一系列集合 \(S_{\phi(1)},\cdots,S_{\phi(\ell)}\)，s.t. \(\forall 1\leqslant y\leqslant \ell\)，\(S_{\phi(y)}\not\subseteq\bigcup\limits_{l=1}^{y-1} S_{\phi(l)}\). MES 的目标就是求出最长的序列(Maximum expanding sequence). MES 问题是一个 R3SAT 困难的问题. Def 16. 称一个 MES 问题是 \(\kappa\)-separable的，若 \(\mathcal{C}\) 的序列可以被分为 \(\kappa\) 个不交子列/子类 \(\mathcal{C}_1,\cdots,\mathcal{C}_\kappa\). 文献[21]证明了，\(\exists\epsilon&gt;0\)，s.t 当 MES 问题是 \(f(c)\)-separable的，在 \(O(f(c)^\epsilon)\) 内逼近该问题也是 R3SAT 困难的. 其中 \(f\) 满足： \(f\) 是不减的； \(f(a)\leqslant a\) 且 \(f(a^b)\leqslant f(a)^b\)，\(\forall b&gt;1\)，\(a\in\mathbb{N}\). Th 17. 对一些 \(\epsilon&gt;0\) 来说，在 \(O(\log^\epsilon n)\) 下逼近 (GENERAL, ITEM) 问题是 R3SAT-困难的. Lemma 18. 如果市场 \(\mu\) 存在一个稳定的输出 \((\overline{X},p\neq 1)\)，记其收益为 \(r\)，则也存在一个稳定的输出 \((\overline{X}&#39;,1)\)，其收益为 \(r/4\). Bundle-pricing Th 22. (GENERAL, BUNDLE) 分配问题有 \(\frac{\log n}{1-\frac{1}{e}}\) 近似算法. 无嫉妒的代价 Th 24. (SINGLE, ITEM) 情形的代价是 \(2\). Th 25. (SINGLE, BUNDLE) 情形的代价是 \(1\). Th 26. (GENERAL, ITEM) 情形的代价是 \(\Theta(\log n)\). Th 27. (GENERAL, BUNDLE) 情形的代价是 \(\Theta(\log n)\).]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>数学</tag>
        <tag>计算机</tag>
        <tag>北大</tag>
        <tag>组合数学</tag>
        <tag>社会计算</tag>
        <tag>论文笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文笔记[3]——Computing a small agreeable set of indivisible items]]></title>
    <url>%2F2019%2F03%2F10%2F%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-3-%E2%80%94%E2%80%94Computing-a-small-agreeable-set-of-indivisible-items%2F</url>
    <content type="text"><![CDATA[文章：Pasin Manurangsi, Warut Suksompong, Computing a small agreeable set of indivisible items, Artificial Intelligence, Volume 268, 2019, Pages 96-114. Agreeable set -- necessarily agreeable set -- agreeable set 一个最坏上界（证明 and 2和3情况的构造） -- 计算necessarily agreeable set -- 一般情形下求最小的agreeable set -- 可加效用函数下的探讨. 准备工作 记号说明 \([n]\)：代理人，编号为 \(1,2,\cdots,n\)； \(S=\{x_1,\cdots,x_m\}\)：物品集合，\(\mathcal{S}\) 表示其幂集； 偏好：每个代理人 \(i\) 都被赋予了一个偏好关系 \(\succeq_i\)，用以比较 \(S\) 子集之间的好坏关系. 偏好关系是自反、完全、和传递的； \(\begin{bmatrix}V \\ t\end{bmatrix}\) 表示集合 \(V\) 的 \(t\) 元子集族； 相关定义 Def 0. 分配问题是把 \(S\) 分给 \(n\) 个代理人的问题. Def 1. 单调性：\(\mathcal{S}\) 上的一个偏好关系 \(\succeq\) 是单调的，当且仅当 \(T\cup\{x\}\succeq T\)，\(\forall T\subset S\). Def 2. Agreeable：\(T\subset S\) 对代理人 \(i\) 来说是agreeable的，当且仅当 \(T\succeq_i S\backslash T\). （越大的集合越好） Agreeable set有时也指对所有代理人都agreeable的集合. 当偏好单调时，显然一定存在这样的集合（\(S\) 就是这样的集合）；当偏好不单调时则可能不存在. Def 3. Responsive：\(\mathcal{S}\) 上的偏好关系是responsive的，当且仅当： \(\succeq\) 是单调的； \((T\backslash\{y\})\cup\{x\}\succeq T\)，\(\forall T\subset S\)，其中 \(x\succeq y\)，\(x\notin T\)，\(y\in T\). （扔掉一个不好的，再拿来一个好的，情况会变好） 一般来说，判断集合对代理人 \(i\) 是否agreeable，需要访问其完整偏好，仅凭单物品偏好无法判断； 但只要偏好是responsive的，便可以仅通过单物品偏好来判断集合是否agreeable. Def 4. Necessarily agreeable：取定 \(\mathcal{S}\) 上的一个单物品偏好 \(\succeq^{sing}\)（即物品的一个排列）. 称\(T\subset S\) 在 \(\succeq^{sing}\) 下是necessarily agreeable的，若对与 \(\succeq^{sing}\) 相容的任意偏好 \(\succeq\)，都有 \(T\succeq S\backslash T\). 简单起见，若 \(T\) 对代理人 \(i\) 的单物品偏好是necessarily agreeable的，则称 \(T\) 对 \(i\) 是necessarily agreeable的. Def 效用函数：效用函数 \(f\) 是 \(\mathcal{S}\to\mathbb{R}_{\geqslant 0}\) 的映射. \(f\) 的大小标志着集合的好坏. 由于每个代理的偏好是自反、完全和传递的，故 \(\forall T_1,T_2\subset S\)，\(T_1\succeq T2\) 当且仅当 \(f(T_1)\geqslant f(T_2)\). 对于单调的偏好，\(\forall T_1\subset T_2\)，总有 \(f(T_1)\leqslant f(T_2)\). 可加效用：效用函数 \(u\) 称为是可加的，当且仅当 \(u(T_1\cup T_2)=u(T_1)+u(T_2)\)，其中 \(T_1\cap T_2=\varnothing\). 次可加效用：\(u\) 称为是次可加的，当且仅当 \(u(T_1\cup T_2)\leqslant u(T_1)+u(T_2)\)，\(\forall T_1,T_2\). 任何单调的效用函数都是次可加的. Necessarily agreeable set 对于necessarily agreeable set，有一个重要的命题： Prop. 1. 取定 \(\mathcal{S}\) 上的单物品偏好 \(\succeq^{sing}\)，不妨设为 \[x_1\succeq^{sing} x_2\succeq^{sing}\cdots\succeq^{sing} x_m.\] 令 \(T\subset S\)，记 \(I_k=\{x_1,x_2,\cdots,x_m\}\)，\(\forall k=1,\cdots,m\)，则有： 若 \(\vert I_k\cap T \vert\geqslant k/2\)，\(\forall k=1,\cdots,m\)，则 \(T\) 在 \(\succeq^{sing}\) 下是necessarily agreeable的. 当偏好 \(\succeq^{sing}\) 是严格的，其逆命题也成立. Proof. 先证 \(\Rightarrow\)：由条件可知 \(|I_m\cap T|\geqslant m/2\)，于是 \(|T|\geqslant |S\backslash T|\). 取 \(T&#39;\in\begin{bmatrix}T \\ |S\backslash T|\end{bmatrix}\) 且 \(T&#39;\) 是其中下标最小的. 由此即可在 \(T&#39;\) 与 \(S\backslash T\) 间定义一个保序的双射 \(f:T&#39;\to S\backslash T\)，即下标最小的映射到下标最小的. 由于 \(|I_k\cap T|\geqslant k/2\)，\(\forall k=1,\cdots,m\)，故 \(f\) 必定将 \(x_k\) 映射到某个 \(l&gt;k\) 的 \(x_l\). 由responsive的定义可知，任意一个与 \(\succeq^{sing}\) 相容的responsive的偏好，都保持 \(T&#39;\succeq S\backslash T\). 又由于所有responsive的偏好都是单调的，故 \(T\succeq S\backslash T\)，即 \(T\) 在 \(\succeq^{sing}\) 之下是necessarily agreeable的. 再证 \(\Leftarrow\)：用反证法：假设存在 \(l\)，s.t. \(|I_l\cap T|&lt;1/2\). 取一个小常数 \(\epsilon&gt;0\)，假设偏好 \(\succeq\) 由可加效用函数 \(u\) 给出： \[u(x_i)=\begin{cases} 1+(l-i)\epsilon,&amp; 1\leqslant i\leqslant l;\\ (m-i)\epsilon,&amp; l&lt;i\leqslant m. \end{cases}\] 由于“所有由可加效用函数给出的偏好都是responsive的”，故 \(\succeq\) 是responsive的. 进一步，当 \(\epsilon\) 足够小时，有 \(u(S\backslash T)&gt;1/2\)，同时 \(u(T)&lt;1/2\). 由于 \(\succeq\) 是responsive的，且与 \(\succeq^{sing}\) 相容，故有 \(S\backslash T\succ T\). 因此 \(T\) 在 \(\succeq^{sing}\) 下不是necessarily agreeable的. 矛盾！故逆命题得证. 综上，原命题得证. 最坏情况的上界 普适的最坏上界 Th 1. 对于 \(n\) 个代理人，\(m\) 个物品的分配问题，存在 \(T\subseteq S\)，s.t. \[|T|\leqslant\min\left(\lfloor\frac{m+n}{2}\rfloor,m\right)\] 且 \(T\) 对所有代理人都是agreeable的. 进一步，存在特定的偏好，使得该界是紧的. 一般情况的证明较为复杂，先给出了 \(n=2\) 的情形： 两个代理人的情形 Proof when \(n=2\). 此时上界为 \(\lfloor\frac{m+2}{2}\rfloor\). 记两个代理人的偏好分别是 \(\succeq_1\) 和 \(\succeq_2\). 当 \(m=2k+1\) 为奇数时，用反证法：假设不存在至多 \(k+1\) 元子集对两个代理人同时保持agreeable. 取 \(T\subset S\)，s.t. \(|T|=k\). 以下先证明一个引理： 引理 若 \(T\succ_1 S\backslash T\)，则 \[(T\cup\{x\})\backslash\{x&#39;\}\succ_1 ((S\backslash T)\backslash \{x\})\cup\{x&#39;\}.\] \(\forall x\in S\backslash T\)，\(x&#39;\in T\). Proof. 由单调性，有： \[T\cup\{x\}\succ_1(S\backslash T)\backslash\{x\}.\] 此时 \(|T\cup\{x\}|=k+1\)，由于不存在 \(k+1\) 元的agreeable set，故 \[(S\backslash T)\backslash\{x\}\succ_2T\cup\{x\}.\] 进一步，由单调性，有： \[((S\backslash T)\backslash\{x\})\cup\{x&#39;\}\succ_2(T\cup\{x\})\backslash\{x&#39;\}.\] 此时 \(|((S\backslash T)\backslash\{x\})\cup\{x&#39;\}|=k+1\)，再由不存在 \(k+1\) 元的agreeable set，有： \[(T\cup\{x\})\backslash\{x&#39;\}\succ_2((S\backslash T)\backslash\{x\})\cup\{x&#39;\}.\] 至此，引理得证. （只要 \(T\) 比其补集更好，则任意与补集交换一件物品后仍然更好.） 继续，不失一般性，设 \(\{x_1,\cdots,x_k\}\succ_1\{x_{k+1},\cdots,x_{2k+1}\}\). 反复使用引理，可得： \[\{x_{k+1},x_2,\cdots,x_k\}\succ_1\{x_1,x_{k+2},\cdots,x_{2k+1}\},\] \[\{x_{k+1},x_{k+2},x_3,\cdots,x_k\}\succ_1\{x_1,x_2,x_{k+3},\cdots,x_{2k+1}\},\] \[\cdots\cdots\] \[\{x_{k+1},x_{k+2},\cdots,x_{2k}\}\succ_1\{x_1,x_2,\cdots,x_k,x_{2k+1}\}.\] 由单调性，\(\{x_{k+1},x_{k+2},\cdots,x_{2k+1}\}\succ_1\{x_1,x_2,\cdots,x_k\}\)，与假设矛盾！奇数情形得证. 当 \(m=2k\) 为偶数时，令 \(S1=S\backslash\{x_1\}\). 由奇数情形下的结果，存在 \(T\subset S&#39;\)，s.t. \(|T|\leqslant k\) 且 \(T\succeq_{1,2} S&#39;\backslash T\). 于是由单调性即可知，\(T\cup \{x_1\}\) 即为所求的 \(k+1\) 元集合. 综上，命题得证. 上述证明实际上给出了一个多项式时间的算法，可以得到一个至多 \(\lfloor\frac{m+2}{2}\rfloor\) 元的agreeable set. 具体过程参见证明，不多赘述. 一般情形的证明 一般情形的证明需要用到所谓Kneser猜想： Lemma 1. (Kneser 猜想) Kneser图 \(KG_{n,k}\) 的染色数为： \[\chi(G)=\begin{cases} n-2k+2, &amp; n\geqslant 2k;\\ 1, &amp; \text{otherwise.} \end{cases}\] Kneser图的定义如下： Def X. Kneser图：考虑 \([n]=\{1,\cdots,n\}\) 的 \(k\) 元子集族 \(\begin{bmatrix} [n] \\ k \end{bmatrix}\)，以 \(\begin{bmatrix} [n] \\ k \end{bmatrix}\) 为顶点，建立一个 \(\binom{n}{k}\) 阶图，结点 \(T_1\)，\(T_2\) 之间有边相连，当且仅当 \(T_1\cap T_2=\varnothing\). 这样的图称为Kneser图. \(KG_{5,2}\) 即是大名鼎鼎的Petersen图. 更多Kneser图的形状如下图所示（来源：Wolfram mathworld） 有了这个猜想，即可证明Th 1. Proof of Th 1. 令 \(k=\lfloor\frac{m+n}{2}\rfloor\). 显然 \(k\geqslant m\) 的情况是平凡的，只须取 \(S\) 为agreeable set即可，故以下只讨论 \(k&lt;m\) 的情形. 考虑 \(\{x_1,\cdots,x_m\}\) 的 \(m-k\) 元子集生成的Kneser图 \(KG_{m,m-k}\). 若存在 \(T\subset S\)，s.t. \(|T|=m-k\)，且 \(S\backslash T\succeq_i T\)，\(\forall i\)，则 \(S\backslash T\) 即为所求的 \(k\) 元agreeable set. 假设不存在上述这样的 \(T\)，即 \(\forall T\in\begin{bmatrix}S \\ m-k\end{bmatrix}\)，都存在 \(i\)，s.t. \(T\succ_i S\backslash T\). 对图 \(KG_{m,m-k}\) 染色，给结点 \(T\) 染上颜色 \(i\)，其中 \(T\succ_i S\backslash T\). 若有多个 \(i\) 对应，任选其一即可. 由于 \(k\geqslant m/2\)，故 \(m\geqslant 2(m-k)\). 由Kneser猜想（Lemma 1.），\(KG_{m,m-k}\) 的染色数为： \[\begin{align}\chi(KG_{m,m-k}) &amp;= m-2(m-k)+2 \\ &amp;= 2k-m-2 \\ &amp;\geqslant 2(\frac{m+n-1}{2})-m+2=n+1.\end{align}\] 而上述染色过程只使用了 \(n\) 种颜色，故由染色数的定义，至少存在一条边，其两端点共色. 不妨设这两个端点为 \(T_1\) 和 \(T_2\). 即有，对于某个 \(i\in[n]\)，\(T_1\succ_i S\backslash T_1\)，\(T_2\succ_i S\backslash T_2\). 但由 \(T_1\) 和 \(T_2\) 之间有边相连，有 \(T_1\cap T_2=\varnothing\)，故 \(T_1\subset S\backslash T_2\)，\(T_2\subset S\backslash T_1\). 由单调性立得矛盾： \[S\backslash T_1\succeq_i T_2\succ_i S\backslash T_2\succeq_i T_1\succ_i S\backslash T_1.\] 因此必定存在上述的 \(T\)，即命题得证. 一组偏好，使得该界是紧的 分为两种情况，以下效用函数均是可加的： \(n\geqslant m\)，此时 \(\min(k,m)=m\). 取 \(u_i(x_j)=\begin{cases} 1, &amp; j=\min(i,m) \\ 0, &amp; j\neq\min(i,m) \end{cases}\)，则对代理人 \(i\) agreeable的集合必定得包含 \(x_{\min(i,m)}\)，此时agreeable set必须包含所有物品，共计 \(m\) 个； \(n&lt;m\)，此时 \(\min(k,m)=k\). 对 \(i=1,\cdots,n-1\)，取 \(u_i(x_j)=\begin{cases} 1, &amp; j=i \\ 0, &amp; j\neq i \end{cases}\)；同时 \(u_n(x_j)=\begin{cases} 1, &amp; j\geqslant n \\ 0, &amp; j&lt; n \end{cases}\). 此时，一个集合若对所有代理人都是agreeable的，则必须包含 \(x_1,\cdots,x_{n-1}\)，以及 \(\{x_n,\cdots,x_m\}\) 的至少一半，共计 \(n-1+\lceil\frac{m-n+1}{2}\rceil=\lceil\frac{m+n-1}{2}\rceil=\lfloor\frac{m+n}{2}\rfloor\). 至此，我们已经完成了一般情形的证明，接下来文章对如何获得这样的agreeable set进行了讨论. 获取最坏上界的agreeable set 二人情形 二人情形中，我们只需知道单物品偏好即可得到对二人都necessarily agreeable的集合. 在此我们假设所有偏好是responsive的，并且可以将单物品偏好扩展为 \(\mathcal{S}\) 上的偏序. 算法的思路是：按 \(1\) 的偏好排序，然后分组，按照 \(2\) 的偏好进行选择. 具体的内容由下面的定理给出： Th 2. （两人情形）给定两个代理人在 \(S\) 上的单物品偏好 \(\succeq_1^{sing}\) 和 \(\succeq_2^{sing}\)，存在 \(T\subset S\)，s.t. \(|T|\leqslant \lfloor\frac{m+2}{2}\rfloor\)，且 \(T\) 对 \(\succeq_1^{sing}\) 和 \(\succeq_2^{sing}\) 都是necessarily agreeable的. 并且可在多项式时间内求得一个这样的 \(T\). 进一步，存在一组偏好，使得这个界是紧的. Proof. 分奇偶性来讨论： 当 \(m=2k+1\) 时，不妨设 \(x_1\succeq_1^{sing} x_2\succeq_1^{sing}\cdots\succeq_1^{sing}x_{2k+1}\). 此时按照如下方法进行选择： \(x_1\) 加入集合 \(T\)； 在 \((x_2,x_3),(x_4,x_5),\cdots,(x_{2k},x_{2k+1})\) 中，每一对都选取 \(2\) 更喜欢的那个，加入集合 \(T\). 这样选择得到的集合 \(T\) 显然对 \(\forall j=1,\cdots,m\) 都满足 \(|T\cap I_j|\geqslant j/2\)，因此由 Prop 1 可知 \(T\) 对 \(1\) 是necessarily agreeable的. 进一步，由于算法的第2步在每一对中都选择了 \(2\) 更喜欢的物品，所以同样可由 Prop 1 知，\(T\) 对 \(2\) 是necessarily agreeable的. 当 \(m=2k\) 时，令 \(S&#39;=S\backslash\{x_1\}\). 则由奇数的结果可知，\(S&#39;\) 中可以取出一个子集 \(T\)，s.t. \(|T|=k\)，且 \(T\) 对两位代理人都是necessarily agreeable的. 此时只需将 \(x_1\) 也添加进集合，即有 \(|T\cup\{x_1\}|=k+1=\lfloor\frac{m+2}{2}\rfloor\)，且对二者都是necessarily agreeable的. 综上，命题得证. 一组偏好，使得界是紧的 先不写了，有空再补. 三人情形 三人情形下，无法只使用单物品偏好得到最坏上界的necessarily agreeable set. 以下是一个例子： Ex. 1. 令 \(m=6\)，三个人的单物品偏好如下： \(x_1\succ_1^{sing} x_4\succ_1^{sing} x_5\succ_1^{sing} x_6\succ_1^{sing} x_2\succ_1^{sing} x_3\); \(x_2\succ_2^{sing} x_5\succ_2^{sing} x_6\succ_2^{sing} x_4\succ_2^{sing} x_3\succ_2^{sing} x_1\); \(x_3\succ_3^{sing} x_6\succ_3^{sing} x_4\succ_3^{sing} x_5\succ_3^{sing} x_1\succ_3^{sing} x_2\). 若 \(T\subset S\) 对三人都是necessarily agreeable的，则必须包含 \(\{x_1,x_2,x_3\}\) 以及 \(\{x_4,x_5,x_6\}\) 中的至少两个，这样有 \(|T|\geqslant 5\). 但是，若知道完整的偏好，由 Th 1 可知，\(|T|\leqslant 4\) 即可. 于是三人的情形不能再只使用单物品偏好，需要访问其完整偏好. 考虑到单单是读取完整偏好就已不能在多项式时间内完成，故认为存在一个偏好数据库，我们的多项式时间算法实际上是对该数据库进行多项式次数的访问，每次获取两个集合对于某个代理人的好坏关系. Th 3. （三人情形）假设存在三个代理人，在 \(\mathcal{S}\) 上的偏好分别为 \(\succeq_1\)，\(\succeq_2\)，\(\succeq_3\). 则存在多项式算法，在多项式时间内可以求得一个 \(T\subset S\)，s.t. \(|T|\leqslant \lfloor\frac{m+3}{2}\rfloor\)，且 \(T\) 对三个人都是agreeable的. Proof 仍然分奇偶性来讨论： 当 \(m=2k\) 为偶数：我们的目标是找到一个大小为 \(\lfloor\frac{m+3}{2}\rfloor=k+1\) 的集合 \(T\)，使其对三个代理人都是agreeable的. 不妨设 \(x_{2k-1}\) 是 \(1\) 最喜欢的，\(x_{2k}\) 是 \(2\) （除 \(x_{2k-1}\) 外）最喜欢的，且对于剩下的 \(2k-2\) 个元素，有 \(x_1\succeq_1\cdots\succeq_1 x_{2k-2}\). （按 \(1\) 排序） 记 \(A=\{x_1,\cdots,x_{2k-2}\}\)，考虑 \((x_1,x_2),(x_3,x_4),\cdots,(x_{2k-3},x_{2k-2})\). 令 \(B\) 为上述二元组中 \(2\) 不喜欢的元素所构成的 \(k-1\) 元集合，则由responsive可知，\(A\backslash B\succeq_2 B\). 现考虑一个过程： 只要 \(A\backslash B\succeq_2 B\)，就取 \(B\) 中的一个元素以及 \(A\backslash B\) 中与其曾在同一个二元组中的元素，二者交换，形成新的 \(B\) 和 \(A\backslash B\). 在这个操作中，我们至多进行 \(k-1\) 步，就一定能得到一个 \(B\succeq_2 A\backslash B\) 的状态. 此时有两种情况，分述如下： 我们根本无需进行任何操作：即 \(B\sim_2 A\backslash B\)，于是由单调性，可得 \((A\backslash B)\cup\{x_{2k}\}\succeq_2 B\)，以及 \(B\cup\{x_{2k}\}\succeq_2 A\backslash B\). 我们进行了至少一步的操作：此时，不妨设我们的最后一步操作是将 \(x_{2i-1}\) 插入 \(B\)，并将 \(x_{2i}\) 移出 \(B\). 令 \(C=(A\backslash B\backslash \{x_{2i}\})\cup\{x_{2i-1}\}\)，\(D=(B\backslash \{x_{2i-1}\})\cup\{x_{2i}\}\)，则我们有 \(C\succ_2 D\)，且 \(B\succeq_2 A\backslash B\)，并由单调性可得 \(C\cup\{x_{2k}\}\succeq_2 D\)，且 \(B\cup\{x_{2k}\}\succeq_2 A\backslash B\). 至此，我们断言 \(D\cup\{x_{2k}\}\succeq_2 C\) 和 \((A\backslash B)\succeq_2 B\cup\{x_{2k}\}\) 中至少有一个成立. 断言的正确性：事实上，若 \(C\succ_2 D\cup\{x_{2k}\}\)，且 \(B\succ_2 (A\backslash B)\cup\{x_{2k}\}\)，则 \[C\succ_2 D\cup\{x_{2k}\}\succeq_2 B\succ_2 (A\backslash B)\cup\{x_{2k}\} \succeq_2 C.\] 矛盾！于是断言成立. 至此，两种情况我们都在多项式时间内找到了一个集合 \(E\in \begin{bmatrix} A \\ k-1 \end{bmatrix}\)，s.t. 包含 \((x_1,x_2),(x_3,x_4),\cdots,(x_{2k-3},x_{2k-2})\) 每个二元组中的恰好一个元素，且满足 \[E\cup \{x_{2k}\}\succeq_2 A\backslash E,~(A\backslash E)\cup\{x_{2k}\}\succeq_2 E.\] （用 \(2\) 的偏好调节平衡） 我们即可以如下选取 \(k+1\) 元的agreeable set： 选取 \(x_{2k-1}\) 和 \(x_{2k}\). 按照 \(3\) 的喜好选择 \(E\) 和 \(A\backslash E\) 中较好的那个. （让 \(3\) 来选取） 以下证明如此选出的集合 \(T\) 对三个代理人都是agreeable的： \(\forall j=1,2,\cdots,m\)，\(T\) 在 \(1\) 最喜欢的前 \(j\) 个物品中都至少包含了 \(j/2\) 个，故 \(T\) 对 \(1\) 来说是necessarily agreeable的； 由于 \(E\cup\{x_{2k}\}\succeq_2 A\backslash E\)，\(A\backslash E\cup\{x_{2k}\}\succeq_2 E\)，且 \(x_{2k-1},x_{2k}\in T\)，故 \(T\) 对 \(2\) 是agreeable的； 由于在 \(E\) 和 \(A\backslash E\) 中我们选择了 \(3\) 偏爱的那个，同时我们选择了剩余的所有元素（\(x_{2k-1}\) 和 \(x_{2k}\)），故 \(T\) 对 \(3\) 也是agreeable的. 当 \(m=2k+1\) 为奇数：此时 \(\lfloor\frac{m+3}{2}\rfloor=k+2\)，于是只需考虑 \(S&#39;=S\backslash\{x_1\}\)，利用偶数情形的结果求得满足条件的 \(T\subset S&#39;\)，此时 \(|T|=k+1\). 于是只需取 \(T\cup \{x_1\}\) 即可. 综上，命题得证. 求necessarily agreeable的集合 又到了我不喜欢但绕不开的估计和逼近...一大波不等式即将来袭Orz 在此处的讨论中，只需访问每个代理人的单物品偏好即可. Th 4. 对任意常数个代理人，存在 \(T\in\begin{bmatrix}S\\ \frac{m}{2}+O(\log m)\end{bmatrix}\)，s.t. \(T\) 对所有代理人都是necessarily agreeable的. 这样的集合可在多项式时间内找出. 要证明这个定理，需要一个引理做支持： Lemma 2. 令 \(\sigma_1,\cdots,\sigma_n\) 是集合 \(M=\{1,\cdots,m\}\) 的排列. 则存在函数 \(f:M\to \{-1,1\}\)，.s.t. \[\left| \sum\limits_{i=p}^q f(\sigma_j(i)) \right|\leqslant 8n\log m,~~\forall 1\leqslant p\leqslant q\leqslant m~and~1\leqslant j\leqslant n.\] 进一步，这样的函数可以在多项式时间内被找到. 有了这个引理，即可证明 Th 4. Proof to Th 4. 设代理人 \(j\) 的单物品偏好为 \(x_{\sigma_j(1)}\succeq_j^{sing}x_{\sigma_j(2)}\succeq_j^{sing}\cdots\succeq_j^{sing}x_{\sigma_j(m)}\). 由 Lemma 2，我们可以在多项式时间内找到一个函数 \(f:S\to\{-1,1\}\)，s.t. \[\left| \sum\limits_{i=1}^q f(x_{\sigma_j(i)}) \right|\leqslant 8n\log m,~~\forall q=1,\cdots,m~and~j=1,\cdots,n.\] 现按照如下方法建立一个集合： 将所有满足 \(f(x_i)=1\) 的 \(x_i\) 加入集合\(T\)； 剩余物品中，将每个代理人偏好中的前 \(\lceil 4n\log m \rceil\) 也加入集合\(T\)（若某个代理人的偏好中，剩余物品已不足，则全加入集合）. 对 \(i=1,\cdots,m\)，令 \(X_i\) 为指示变量：\(X_i=\begin{cases}1, &amp; x_i\in T \\ -1, &amp; x_i\notin T\end{cases}\)，则对任意代理人 \(j\) 和 \(\forall i=1,2,\cdots,m\)，有： \[X_{\sigma_j(1)}+X_{\sigma_j(2)}+\cdots+X_{\sigma_j(i)}\geqslant \min\{i, -8n\log m+2\cdot\lceil 4n\log m \rceil\}\geqslant 0.\] 上式意味着：前 \(i\) 个物品中在 \(T\) 内的个数 \(-\) 前 \(i\) 个物品中不在 \(T\) 内的个数 \(\geqslant 0\)，即 \(\forall i\)，\(|T\cap I_i|\geqslant i/2\)，故由 Prop 1. 可知，\(T\) 对 \(\forall j\) 都是necessarily agreeable的. 进一步，集合 \(T\) 的规模至多为： \[\frac{m}{2}+(n+1)\cdot \lceil 4n\log m \rceil = \frac{m}{2}+O(\log m).\] 综上，命题得证. 进一步，这个界是渐进紧的： Th 5. 假设 \(m=3^k\)，\(k&gt;0\)，则存在三个代理人的单物品偏好，s.t. 所有对三个人都necessarily agreeable的集合都至少具有 \(\frac{m}{2}+\Omega(\log m)\) 的规模. 要证明该定理，需要一个引理. Lemma 3. 给定 \(k\in\mathbb{R}^+\)，令 \(m=3^k\)，\(M=\{1,2,\cdots,m\}\). 存在三个排列 \(\sigma_1,\sigma_2,\sigma_3\)，s.t. \(\forall f:M\to \{-1,1\}\)，记 \(\Delta =\sum\nolimits_{i\in M} f(i)\geqslant 1\)，则存在 \(1\leqslant q\leqslant m\) 和 \(1\leqslant j\leqslant 3\)，s.t. \[\sum\limits_{i=1}^q f(\sigma_j(i))\leqslant \frac{-k+2\Delta-2}{3}.\] 有了这个引理，即可证明 Th 5： Proof to Th 5. 设 \(\sigma_1,\sigma_2,\sigma_3\) 是 \(S=\{x_1,\cdots,x_m\}\) 满足 Lemma 3 的三个排列，对于 \(\forall j=1,2,3\)，设代理人 \(j\) 的偏好是 \(x_{\sigma_j(1)}\succeq_j^{sing}x_{\sigma_j(2)}\succeq_j^{sing}\cdots\succeq_j^{sing}x_{\sigma_j(m)}\). 考虑 \(\forall T\subset\)，s.t. \(|T|\leqslant m/2+k/4\). 以下证明 \(T\) 不可能同时对三个都是necessarily agreeable的： 构造指示器函数 \(f_T:S\to\{-1,1\}\)，\(f_T(x_i)=\begin{cases}1, &amp; x_i\in T \\ -1, &amp; x_i\notin T\end{cases}\)，由于 \(|T|\leqslant m/2+k/4\)，故 \(\Delta_T=\sum\limits_{i=1}^m f(x_i)=|T|-|S\backslash T|\leqslant k/2\). 若 \(\Delta_T&lt;0\)，则 \(T\) 显然不是necessarily agreeable的； 若 \(\Delta_T\geqslant 0\)，由 \(T\) 是奇数且 \(\Delta\in\mathbb{Z}\)，可知 \(\Delta_T\geqslant 1\). 此时由 Lemma 3 可知，\(\exists 1\leqslant q\leqslant m\) 和 \(1\leqslant j\leqslant 3\)，s.t. \[\sum\limits_{i=1}^q f_T(\sigma_j(x_i))\leqslant \frac{-k+2\Delta-2}{3}\leqslant \frac{-k+k-2}{3}&lt;0.\] 即此时 \(T\) 也不是necessarily agreeable的. 综上，\(T\) 不是necessarily agreeable的. 又由于 \(k=\log_3 m\)，故necessarily agreeable的集合至少具有 \(m/2+\Omega(\log m)\) 的规模. 命题得证. 计算necessarily agreeable set的随机算法 该算法的分析和证明将用到概率论中著名的 Chernoff bound 和 Levy's inequality： Lemma 4. (Chernoff bound) 令 \(X_1,X_2,\cdots,X_r\) 是 i.i.d. 的随机变量，都服从 \({\rm Pr}[X_i=1]={\rm Pr}[X_i=-1]=1/2\) 的两点分布，记 \(X=X_1+\cdots+X_r\)，则有： \[{\rm Pr}[|X|\geqslant a]\leqslant \exp(-\frac{a^2}{2r}),~~\forall a\geqslant 0.\] Lemma 5. (Levy 不等式) 令 \(X_1,X_2,\cdots,X_r\) 是 i.i.d. 的随机变量，都服从 \({\rm Pr}[X_i=1]={\rm Pr}[X_i=-1]=1/2\) 的两点分布，记 \(Y_i=X_1+\cdots+X_i\)，\(\forall i\). 则有： \[{\rm Pr}\left[ \max\limits_{1\leqslant i\leqslant r}|Y_i|\geqslant x \right]\leqslant 2{\rm Pr}[|Yr|\geqslant x],~~\forall x\in\mathbb{R}.\] 具体的算法由下述的 Th 6 给出： Th 6. 假设代理人的数目是常数，取常数 \(\epsilon\in (0,1)\)，\(c&gt;0\)，s.t. \(\exp(-\frac{c^2}{2})\leqslant \frac{\epsilon}{2n}\)（我认为这只是个技术性的条件，用来调节平衡）. 考虑下述的多项式时间算法： FOR 每个元素，每个元素都有 \(1/2\) 概率加入集合 \(T\)，\(1/2\) 概率不加入. 并且当前元素是否加入与其他元素无关； 对每个代理人，将剩余物品中，他们偏好的前 \(\lfloor c\sqrt{m}\rfloor\) 位加入集合 \(T\). 上述算法至少能以 \(1-\epsilon\) 的概率求出一个规模为 \(m/2+O(\sqrt{m})\) 的necessarily agreeable的集合. 一点粗浅的理解： 1. 第一步借用 Lemma 4,5 构造一个集合； 2. 第二步补一些元素，把元素个数凑够，满足 Prop 1 的要求. Proof. 设 \(X_1,\cdots,X_m\) 分别是 \(x_1,\cdots,x_m\) 的指示变量，\(X_i=\begin{cases}1, &amp; x_i\in T\\ -1, &amp; x_i\notin T\end{cases}\)，则 \(X_1,\cdots,x_m\) 是 i.i.d. 的变量，且都服从 \((1/2,1/2)\) 的两点分布. 对于 \(j=1,\cdots,m\)，记代理人 \(j\) 的单物品偏好为 \(x_{\sigma_j(1)}\succeq^{sing}_jx_{\sigma_j(2)}\succeq^{sing}_j\cdots \succeq^{sing}_jx_{\sigma_j(m)}\). 令 \(Y_i^j=X_{\sigma_j(1)}+\cdots+X_{\sigma_j(i)}\)，\(i\in\{1,2,\cdots,n\}\). 取 \(a=c\sqrt{m}\)，由 Lemma 4，有： \[{\rm Pr}\left[ |Y_m^j|\geqslant c\sqrt{m} \right]\leqslant \exp(-\frac{c^2}{2}).\] 又由 Lemma 5，\(X_{\sigma_j(i)}\) 满足：（给 \(|T\cap I_i|-|T^c\cap I_i|\) 估界） \[{\rm Pr}\left[ \max\limits_{1\leqslant i\leqslant m} |Y_i^j|\geqslant c\sqrt{m} \right]\leqslant 2\exp(-\frac{c^2}{2}).\] 由于一共有 \(n\) 个代理人，每个代理人都满足以上式子，故 \[{\rm Pr}\left[\exists j,~\max\limits_{1\leqslant i\leqslant m} |Y_i^j| \right]\leqslant 2n\cdot c\sqrt{m}\leqslant \epsilon.\] 于是，至少有 \(1-\epsilon\) 的概率 \(\forall i,j\)，\(Y_i^j\in [-\lfloor c\sqrt{m}\rfloor,\lfloor c\sqrt{m}\rfloor]\). 考虑到我们在算法的第二步中将所有代理人偏好的前 \(\lfloor c\sqrt{m}\rfloor\) 个物品都加入了集合 \(T\) 中，这使得 \(Y_i^j\geqslant\)，\(\forall j\). 结合 Prop 1 可知，\(T\) 对于所有代理人都是necessarily agreeable的. 由于我们在第一步至多加入了 \(m/2+c\sqrt{m}\) 个物品，第二步每个代理人至多加入了 \(c\sqrt{m}\)，即集合 \(T\) 的规模至多是 \[\frac{m}{2}+(n+1)\cdot c\sqrt{m}=\frac{m}{2}+O(\sqrt{m}).\] 命题得证~ 一般情形 一般情形下的近似 前文讨论的全部都是一个对所有情况普适的结果，这里我们开始讨论一般的情形. 即，具体的一组偏好，如何找到规模最小的agreeable set？事实上，这个问题可能是困难的，因此这里只提供了一个近似的解. 要解决这个问题，我们首先要处理的就是偏好的问题. 对于给定的 \(S\)，其子集数量是指数级别，故我们也需要指数级别的空间来存储偏好. 因而任何多项式的算法都无法读取完整的效用函数. 在这里使用value oracle model，即算法可以在确定了 \(T\subset S\) 以及 \(i=1,2,\cdots,n\) 的情况下，查询 \(u_i(T)\) 的值. 文章给出的结果是一个多项式时间的算法，能够计算出近似比为 \(O(m/\log m)\) 的近似最优解. 尽管看起来并不好（前文所述的普适上界只有 \(O(m)\)，此处只优化了 \(\Omega(\log m)\)），但文章认为这已是多项式时间内可达到的最好情况. 具体的算法分析由以下定理给出： Th 7. 存在一个多项式时间的 \(O(m/\log m)\) 近似算法，能在value oracle model下求出近似最小的agreeable set. Proof. 将 \(S\) 分为 \(\lceil\log m\rceil\) 组（注意是不交并），记为 \(S_1,\cdots,S_{\lceil\log m\rceil}\)，每个组的大小不超过 \(\lceil m/\log m \rceil\). 对于每个 \(A\subset \{1,2,\cdots,\lceil\log m\rceil\}\)，判断 \(\bigcup_{i\in A} S_i\) 是否是agreeable的（与其补集比较即可）， 最后算法输出上述步骤所得到的规模最小的agreeable set. 由于算法中 \(A\) 的选取只有 $ m$ 的指数，即 \(m\) 的多项式种可能，于是整个算法复杂度是关于 \(m,n\) 的多项式. 以下证明算法的近似比是 \(O(m/\log m)\)： 记最小的agreeable set为 \(S^*\)，其规模为 \(k\). 构造集合 \(T=\bigcup_{x\in S^*} (S_i:x\in S_i)\)（把 \(S^*\) 中所有元素所属的 \(S_i\) 并起来），则 \(T\) 是我们在算法中检查过的集合，故算法输出的集合规模一定不大于 \(T\). 由单调性，\(T\) 显然是agreeable的，结合 \(|T|\leqslant k\cdot \lceil\log m\rceil\)，可知算法输出的集合的规模不会超过最小集合的 \(O(m/\log m)\). 得证！ Th 8. 对于每个常数 \(c&gt;0\)，\(\exists m_0\)，s.t. \(\forall m&gt;m_0\)，不存在：只进行不超过 \(m^{c/8}\) 次询问，却能得到规模至多是最优解 \(m/(c\log m)\) 倍的agreeable set的算法. 即使只有一个代理人，也不行！ Proof. 构造函数 \(g(T)=\begin{cases}1,&amp; |T|\geqslant \frac{m}{2};\\ 0,&amp; otherwise.\end{cases}\)，进一步，定义 \(f_{T^*}(T)=\begin{cases}1, &amp; |T|\geqslant\frac{m}{2}~or~T^*\subset T， \\ 0, &amp; otherwise.\end{cases}\). 考虑只能进行至多 \(m^{c/8}\) 次询问的算法 \(\mathcal{A}\)（暂时假定 \(A\) 是确定性的算法），进行如下讨论： 当 \(g\) 作为效用函数：设 \(\mathcal{A}\) 在运算中查询的所有集合为 \(T_1,T_2,\cdots,T_{\lfloor m^{c/8} \rfloor}\)； 当 \(f_{T^*}\) 作为效用函数：在 \(S\) 中随机取一个含 \(\lfloor c\log m/4 \rfloor\) 个元素的子集作为 \(T^*\)，设 \(\mathcal{A}\) 在运算中查询的所有集合为 \(T&#39;_1,T&#39;_2,\cdots,T&#39;_{\lfloor m^{c/8} \rfloor}\). 考虑任意的 \(j=1,2,\cdots,\lfloor m^{c/8} \rfloor\)，若 \(T_i=T_i&#39;\) 且 \(g(T_i)=f_{T^*}(T_i&#39;)\)，\(\forall i=1,\cdots,j-1\)，则 \(\mathcal{A}\) 在两种效用函数下的计算路径是一样的，因此有 \(T_j=T_j&#39;\)（？） 进一步，若目前为止，两种情况下算法的计算路径相同且 \(T_j=T_j&#39;\)，我们对 \({\rm Pr}[g(T_j)\neq f_{T^*}(T_j&#39;)]\) 有如下估计： 首先，若 \(|T_j|\geqslant m/2\)，则 \(g(T_j)\) 显然与 \(f_{T^*}(T_j&#39;)\) 相等； 若不然，有： \[{\rm Pr}[g(T_j)\neq f_{T^*}(T_j&#39;)]=Pr[T^*\subset T_j].\] 若 \(|T_j|&lt;|T^*|\)，这个概率显然为 \(0\). 若不然，由于 \(T_j\) 与 \(T^*\) 无关，故有： \[\begin{align} {\rm Pr}[T^*\subset T_j] &amp;= \frac{ \binom{|T_j|}{\lfloor c\log m/4 \rfloor} }{ \binom{m}{\lfloor c\log m/4 \rfloor} } \\ &amp;= \left(\frac{|T_j|}{m}\right)\left(\frac{|T_j|-1}{m-1}\right)\cdots\left(\frac{|T_j|-\lfloor c\log m/4 \rfloor+1}{m-\lfloor c\log m/4 \rfloor+1}\right) \\ &amp;\leqslant \frac{|T_j|}{m}^{\lfloor c\log m/4 \rfloor} \\ &amp;\leqslant 2^{-\lfloor c\log m/4 \rfloor} \\ &amp;\leqslant 2m^{-c/4}. \end{align}\] 由 Boole 不等式（union bound），两个序列不完全相同的概率至多是 \((2m^{-c/4})\cdot m^{c/8}\)，当 \(m\) 较大时显然小于 \(1/2\). 进一步，当序列完全相同时，考虑算法 \(\mathcal{A}\) 的输出应当是一个在效用函数 \(g\) 下也agreeable的集合（？），而由 \(g\) 定义即知这样的集合规模至少为 \(m/2\). 因此，\(\mathcal{A}\) 在效用函数 \(f_{T^*}\) 下所输出的集合的规模的期望也至少是 \(m/2\cdot 1/2=m/4\). 然而，在 \(f_{T^*}\) 下的最优解规模只有 \(\lfloor c\log m/4 \rfloor\). 于是，\(\mathcal{A}\) 的近似比要大于 \(m/(c\log m)\). 最后，当 \(\mathcal{A}\) 是随机算法时，也可以对每依次选择的随机性和所有选择的平均值使用以上的方法，并得到类似的结果. 事实上，即使我们要求效用函数是次模函数或次可加函数，上述结果仍然保持. 证明思路类似. 可加效用函数下的情形 是否存在给定大小的agreeable set是NP问题； 当 \(n\geqslant 2\) 时：是NP完全的； 当 \(n=1\) 时：贪心即可... \(n\geqslant 2\) 时的证明思路：规约到问题 BALANCED 2-PARTITION. BALANCED 2-PARTITION：给定一个多重集非负整数 \(A\)，判断是否存在 \(B\subset A\)，s.t. \[|B|=|A\backslash B|=|A|/2,~且~\sum\limits_{x\in B} x=\sum\limits_{x\in A\backslash B}x=\frac{\sum\limits_{x\in A} x}{2}.\] Lemma 6. BALANCED 2-PARTITION 是NP完全的. Proof. 从 2-PARTITION 进行规约. （思路：补 \(0\)） 2-PARTITION 实例：考虑可重集合 \(B\)，求 \(T\subset B\)，s.t. \(\sum_{x\in T}x=\sum_{x\in B\backslash T} x\). BALANCED 2-PARTITION 实例：给 \(B\) 补 \(|B|\) 个 \(0\)，构成重集 \(A\)，求 \(A\) 的 BALANCED 2-PARTITION. \(\Rightarrow\)：设存在 \(B\) 的一个 2-PARTITION 解 \(T\)，则给 \(T\) 补上 \(|B|-|T|\) 个 \(0\)，构成集合 \(S\subset A\)，显然 \(S\) 是 \(A\) 的一个 BALANCED 2-PARTITION. \(\Leftarrow\)：同样，设存在 \(A\) 的一个 BALANCED 2-PARTITION 解 \(S\)，将 \(S\) 中原本不在 \(B\) 中的元素扔掉（显然都是 \(0\)），得到 \(T\subset B\)，则 \(T\) 是 \(B\) 的一个 2-PARTITION. Th 9. 设有两个代理人，其偏好都以可加效用函数给出，则“找到一个大小恰好为 \(m/2\) 的agreeable set”的问题是NP的. Proof 从 BALANCED 2-PARTITION 进行规约. BALANCED 2-PARTITION 实例：\(A=\{a_1,\cdots,a_{|A|}\}\). 寻找agreeable set的实例：\(S=\{x_1,\cdots,x_{|A|}\}\)，\(\forall i\)，\(u_1(x_i)=a_i\)，\(u_2(x_i)=M-a_i\)，其中 \(M=\sum_{a\in A}a\). \(\Rightarrow\)：若存在 \(B\subset A\)，s.t. \(\sum_{x\in B}x=\frac{\sum_{x\in A} x}{2}\) 且 $|B|=|A|/2. 取 \(T=\{x_i:i\in B\}\)，则 \(T\) 是一个agreeable set（\(u_1(T)=u_1(T^c),~u_2(T)=u_2(T^c)\)） 且 \(|T|=|S|/2\). \(\Leftarrow\)：设存在一个规模为 \(m/2\) 的agreeable set \(T\)，令 \(B\) 为 \(T\) 中元素下标所构成的集合. 由于 \(T\) 是agreeable set，故 \(\sum_{x\in T}u_i(x)\geqslant \sum_{x\in S\backslash T} u_i(x)\)，\(i=1,2\). \(i=1\)时，上式意味着 \(\sum_{a\in B}a\geqslant \frac{\sum_{a\in A}a}{2}\). \(i=2\) 时，上式意味着 \(\sum_{a\in B}a\leqslant \frac{\sum_{a\in A}}{2}\). 又易知 \(B\) 元素个数为 \(A\) 的一半，故 \(B\) 是 \(A\) 的一个 BALANCED 2-PARTIION. Th 10. 对任意常数个代理人，其偏好都以可加效用函数给出，则存在一个伪多项式时间的算法（pseudo-polynomial time algorithm），能够求得规模最小的agreeable set. Proof 用动态规划来解决： 记代理人 \(i\) 对所有物品的效用总和为 \(\sigma_i\)，用 \(\Sigma(m&#39;,y_1,\cdots,y_n)\) 表示前 \(m&#39;\) 个物品 \(\{x_1,\cdots,x_{m&#39;}\}\) 中，要使代理人 \(i\) 的效用恰好达到 \(\y_i\) 的最小所需物品数，其中 \(0\leqslant m&#39;\leqslant m\)，\(0\leqslant y_i\leqslant \sigma_i\)，\(\forall i\). 初值： \(\Sigma(m&#39;,y_1,\cdots,y_n)=\begin{cases} 0, &amp; m&#39;=y_1=\cdots=y_n=0 \\ \infty, &amp; Otherwise \end{cases}\)； 转移： 若 \(\forall i\)，\(u_i(x_{m&#39;})\leqslant y_i\)，且 \(1+\Sigma(m&#39;-1,y_1-u_1(x_{m&#39;}),\cdots,y_n-u_n(x_{m&#39;}))&lt;\Sigma(m&#39;-1,y_1,\cdots,y_n)\)，则（选了 \(x_{m&#39;}\)） \[\Sigma(m&#39;,y_1,\cdots,y_n)=1+\Sigma(m&#39;-1,y_1-u_1(x_{m&#39;}),\cdots,y_n-u_n(x_{m&#39;}))\] 否则，（不选 \(x_{m&#39;}\)）\[\Sigma(m&#39;,y_1,\cdots,y_n)=\Sigma(m&#39;-1,y_1,\cdots,y_n).\] 最终，我们查找在 \(\sigma(...)\) 中是否存在对 \(\forall i\) 都有 \(y_i\geqslant \sigma_i/2\) 的项，若存在多个，取值最小者即可. 算法复杂度 \(O(m\sigma_1\cdots\sigma_n)\). Th 11. 若代理人数量不是常数，判断是否存在规模为 \(\frac{m+1}{2}\) 的agreeable set 的问题是强NP完全的. （强NP完全指不存在伪多项式时间算法，除非 \(P=NP\).） Proof 从 3SAT 进行规约. 3SAT 实例 \(\phi\)：\(n&#39;\) 个变量 \(y_1,\cdots,y_{n&#39;}\)，\(m&#39;\) 个约束 \(C_1,\cdots,C_{m&#39;}\). 判断agreeable set存在性的实例： \(n=m&#39;+n&#39;\) 个代理人，记为 \([n]=\{C_1,\cdots,C_{m&#39;},y_1,\cdots,y_{n&#39;}\}\)； \(m=2n&#39;+1\) 个物品： 只有涉及到的代理人才会喜欢的 \(\{y_i,\lnot y_i:1\leqslant i\leqslant n&#39;\}\) （共 \(2n&#39;\) 个）； 人见人爱的 \(a\) （\(1\) 个）. 效用函数： \(u_{C_i}(b)=\begin{cases} 1, &amp; b=a~或~b~在~C_i~中出现\\ 0, &amp; otherwise \end{cases}\) \(u_{y_i}(b)=\begin{cases} 1, &amp; b=y_i~或~\lnot y_i~或~a \\ 0, &amp; otherwise \end{cases}\) \(\Rightarrow\)：设 \(\phi\) 是可满足的，存在一个解，其中 \(y_i\) 的值为 \(b_i\). 考虑集合 \(T=\{a,b_1,\cdots,b_{n&#39;}\}\). 则对于 \(\forall C_j\)，\(T\) 包含了 \(C_j\) 所喜欢的 \(y_i\) 的一半，以及 \(a\)，因而对 \(C_j\) 是agreeable的. 另一方面，对 \(y_j\) 来说，全集的效用也只有 \(3\)，而 \(u_{y_j}(T)=2\)，因而也是agreeable的. 综上，\(T\) 是一个规模为 \(\frac{m+1}{2}\) 的agreeable set. \(\Leftarrow\)：设 \(T\) 是一个 \(\frac{m+1}{2}\) 元agreeable set. 则 \(a\in T\)，若不然，可用 \(a\) 替换其中任一元素，集合仍是agreeable的. 由于 \(T\) 对 \(\forall y_i\) 是agreeable的，故对每个 \(i\)，\(T\) 至少包含 \(y_i\) 和 \(\lnot y_i\) 中至少一者，又由于 \(T\) 只有 \(n&#39;+1\) 元，故只能对每个 \(i\) 恰好包含一者，记为 \(b_i\). 现令 \(b_i\) 全为真. 又由于 \(T\) 对 \(\forall C_j\) 是agreeable的，且 \(C_j\) 至少涉及到两个 \(y_i\)，这两个 \(y_i\) 至少有一个被设置为真，因此 \(\phi\) 被满足. 至此，求最小的agreeable set已经是一个NP问题，因此一个很自然的想法就是求近似解： Lemma 7. 对任意常数 \(\epsilon&gt;0\)，存在一个从 任意3-SAT条件 \(\phi\) 到一个 SET-COVER问题 的多项式时间规约 \((U,\mathcal{C}\)，以及一个关于 \(|U|\) 的多项式函数 \(f(U)\)，s.t. (完全性) 若 \(\phi\) 是可满足的，则 \((U,\mathcal{C})\) 的最佳值至多为 \(f(U)\)； (稳定性) 若 \(\phi\) 是不可满足的，则 \((U,\mathcal{C}\) 的最佳值至少为 \(((1-\epsilon)\ln|U|)f(U)\). Th 12. 对任意常数 \(\delta&gt;0\)，寻找一个规模不大于最优解 \((1-\delta)\ln n\) 倍的agreeable set 的问题 是NP完全的. Th 13. 在偏好函数是可加函数的情形下，求规模不大于最优解 \(O(\log n)\) 倍的agreeable set是存在多项式时间解法的.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>数学</tag>
        <tag>计算机</tag>
        <tag>北大</tag>
        <tag>组合数学</tag>
        <tag>社会计算</tag>
        <tag>论文笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[来自雁栖湖的最大流问题]]></title>
    <url>%2F2019%2F01%2F14%2F%E6%9D%A5%E8%87%AA%E9%9B%81%E6%A0%96%E6%B9%96%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[\(n\times n\) 的棋盘，有一些障碍物，在没有障碍物的格子上最多放多少个国际象棋的马，使之两两不攻击？ 一个和卜凡约饭的中午，突然接到春哥求助这个题. 卜凡瞟了一眼，想都没想，淡定开口：“爆搜.” 一看数据立刻傻了眼：\(200\times 200\)，爆搜必定 TLE... 场面一度十分尴尬（ 饭后看手机，发现春哥补刀：有人说是最大独立集，我没搞懂. 于是立刻想明白了...然而春哥自己没有写过. 吃完晚饭突然感到手痒，于是上手写了一发，测过样例直接自信提交，70分！（太菜了吧） 前七个点 AC 了，后三个点竟然是 RE？ 想来想去没有别的地方可能 RE 了，开大边数，直接100分 AC 了. 所以，容我bb一下这道题... 题面 Description Given a \(N\times N\) chessboard. There are \(M\) obstacles in the chessboard and the position of \(i\)-th obstacle is \((X_i,Y_i)\). You are asked to find the maximum number of knights which can be placed in the chessboard at the same time, satisfied that, No two knights can attack each other. Knights can't be placed in obstacle. There can be at most one knight in a grid. (A Knight in chess can attack 8 positions, as shown in following figure) Input Input is given from Standard Imput in the following format: \(N~M\\ X_1~Y_1\\ X_2~Y_2\\ \cdots\\ X_M~Y_M\) Output Print the maximum number of knights. Sample Input 1 1233 21 13 3 Sample Output 1: 15 Test 1: exactly same as sample input 1 Test 2-4: \(1\leqslant N\leqslant 4\) Test 5-6: \(1\leqslant N\leqslant 6\) Test 7-10: \(1\leqslant N\leqslant 200\) For all tests, \(0\leqslant M\leqslant N^2-1\), \(1\leqslant X_i\leqslant N\), \(1\leqslant Y_i\leqslant N\). 思路 一般来说棋盘上“马”的走法用横纵坐标分别来表示： 12const int dx[] = &#123;1, -1, 1, -1, 2, -2, 2, -2&#125;;const int dy[] = &#123;2, -2, -2, 2, 1, -1, -1, 1&#125;; 考虑格子的纵坐标之和：马每跳一次，其奇偶性会改变. 用更“组合”的方式说，给棋盘黑白染色后，马每次跳跃的起点和终点格子颜色一定是不同的. 于是考虑按照如下方法建图： 所有没有障碍物的格子视为结点，若马可以从格子 \(a\) 跳到格子 \(b\)，则 \(a,b\) 之间存在一条双向边. 现将所有黑格（\(x+y\) 为偶数）视为一个集合 \(X\)，所有白格（\(x+y\) 为奇数）视为一个集合，则所有的跳跃都发生在 \(X,Y\) 之间，不会发生在 \(X,Y\) 各自的内部，于是这个图是一个二分图. 现在问题所求的是“最多能放多少个马”，即该图最大独立集的大小. 对于二分图，我们有 \[|最大独立集|=总点数-最大匹配数\] 所以只需求其最大匹配. 一般来说有利用匈牙利算法直接求解和利用最大流求解两种方法. 直接用匈牙利算法求解. 最大流方法：（我觉得我不应该说这么详细） \(X\) 左侧增加一个源点 \(S\)，向 \(X\) 中每一点都连入容量为 \(1\) 的边； \(Y\) 右侧增加一个汇点 \(T\)，\(Y\) 中每一点都向其连入容量为 \(1\) 的边； \(X,Y\) 之间的边容量也为 \(1\)（无穷大应该也是有道理的，毕竟源点最多出来 \(1\)）； 跑一遍最大流（比如dinic），结果即为最大匹配. 代码 第一次因为错误估计了边的数量而 RE 了后三个点，只得70分...后来实在想不到 RE 的点，就开大了很多边数，直接就 AC 了… 细想一下，确实是低估了边数. 这里简单说一下正确的边数估计： 棋盘边长是 \(N\)，所以点数大约是 \(N^2\) 级别，考虑到每个点最多 \(8\) 条边，所以总边数绝不超过 \(8N^2\). 带入 \(N\leqslant 200\)，边数至多是 \(8\times 200\times 200=3.2\times 10^5\). 开 maxm = 4e5 就足够了. 最后，因为这是最大流的题目，所以只用了最大流，其实匈牙利算法更短. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 205; // 注意点数其实是 maxn^2 级别const int maxm = 1e6; // 所以这里一定要足够大，4e5就够const int inf = 0x7f7f7f7f;const int dx[] = &#123;1, -1, 1, -1, 2, -2, 2, -2&#125;;const int dy[] = &#123;-2, 2, 2, -2, 1, -1, -1, 1&#125;;int n, m, tot, Source, Dest;int dist[maxm], head[maxm];bool obstacle[maxn][maxn];struct Edge&#123; int to, nxt, capa; Edge() &#123;&#125; Edge(int a, int b, int c): to(a), nxt(b), capa(c) &#123;&#125;&#125; e[maxm];void addedge(int u, int v, int capa) &#123; e[tot] = Edge(v, head[u], capa); head[u] = tot++; e[tot] = Edge(u, head[v], 0); head[v] = tot++;&#125;bool bfs() &#123; memset(dist, -1, sizeof(dist)); std::queue&lt;int&gt; Q; Q.push(Source); dist[Source] = 0; while (!Q.empty()) &#123; int x = Q.front(); Q.pop(); for (int i = head[x]; i != -1; i = e[i].nxt) &#123; int y = e[i].to; if (e[i].capa &amp;&amp; dist[y] == -1) &#123; dist[y] = dist[x] + 1; Q.push(y); if (y == Dest) return true; &#125; &#125; &#125; return false;&#125;int dfs(int x, int exp) &#123; if (x == Dest || !exp) return exp; int ret(0), tmp; for (int i = head[x]; i != -1; i = e[i].nxt) &#123; int y = e[i].to; if (dist[x] + 1 == dist[y] &amp;&amp; e[i].capa) &#123; ret += (tmp = dfs(y, min(exp - ret, e[i].capa))); e[i].capa -= tmp; e[i ^ 1].capa += tmp; &#125; &#125; if (!ret) dist[x] = -1; return ret;&#125;int dinic()&#123; int ret(0); while (bfs()) ret += dfs(Source, inf); return ret; &#125;// 以上全部是模板void init(int s, int t)&#123; Source = s; Dest = t; memset(head, -1, sizeof(head));&#125;bool judge(int x, int y) // 判定(x, y) 格子是否可以放马&#123; if(x &lt; 1 || x &gt; n) return false; // x 不能越界 if(y &lt; 1 || y &gt; n) return false; // y 不能越界 return !obstacle[x][y]; // 不能有障碍物&#125;int f(int x, int y) // 二维变一维&#123; return (x - 1) * n + y;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; // 懒，用了cin cout for(int i = 0; i &lt; m; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; // 还是懒... obstacle[x][y] = true; &#125; init(0, n * n + 1); for (int x = 1; x &lt;= n; x++) &#123; for (int y = 1; y &lt;= n; y++) &#123; if (obstacle[x][y]) continue; if ((x + y) &amp; 1) &#123; addedge(Source, f(x, y), 1); for (int _ = 0; _ &lt; 8; _++) &#123; int xx = x + dx[_]; int yy = y + dy[_]; if (judge(xx, yy)) addedge(f(x, y), f(xx, yy), 1); // 边权为inf亲测也没问题 &#125; &#125; else &#123; addedge(f(x, y), Dest, 1); &#125; &#125; &#125; printf("%d", n * n - m - dinic()); // 输出不懒了！ return 0;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[差分隐私[1]——初窥门径]]></title>
    <url>%2F2018%2F10%2F29%2F%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81-1-%E2%80%94%E2%80%94%E5%88%9D%E7%AA%A5%E9%97%A8%E5%BE%84%2F</url>
    <content type="text"><![CDATA[暑假以来一直在读一本书《Differential Privacy and Applications》1，做一点简单的记录. 何为差分隐私 乱谈隐私 真·乱谈... 如有错误之处请留言指正，Orz. 什么是隐私呢？我们通常把某一特定个体的一些个人信息称为是隐私，比方说我代数做了几个题，泛函考了多少分，大学挂了几门课，最喜欢听哪个老师讲课等等... 那么在以上信息不能直接查询到，并且我们也不透露这些信息的前提下，我们的上述隐私是否会泄露？ 答案是会. 为了说明这些隐私是如何丢掉的，我们就先来谈谈查询的问题. 查询一般是针对某一数据库的，比方说学校的教务网就是一个很好的例子. 那么，数据库如何从最简单的方面来保护隐私呢？一般有发布数据集和提供查询两种场合，分述如下. 数据集的匿名化 姓名 学号 数学分析 高等代数 微分几何 泛函分析 郭犇 201401 100 100 100 100 丁丁 201402 100 90 90 100 小兔子 201403 90 90 90 90 数分哥 201404 100 90 90 90 代数哥 201405 90 100 90 90 几何哥 201406 90 90 100 90 泛函哥 201407 90 90 90 100 LZC 201408 90 90 0 90 成绩数据示例 我们都知道数据库中，有“主键”的概念，它能唯一地标识数据库中的某一条记录（比如学号）. 那么保护隐私最直接的办法，就是在给人看数据的时候，将具有标识功能的属性全部删掉，比如在成绩单中将姓名学号删掉，只留下成绩，即得到如下的表格. 序号 数学分析 高等代数 微分几何 泛函分析 1 100 100 100 100 2 100 90 90 100 3 90 90 90 90 4 100 90 90 90 5 90 100 90 90 6 90 90 100 90 7 90 90 90 100 8 90 90 0 90 去掉姓名学号的成绩单 如果攻击者本人什么都不知道，那么这帮人的隐私就算是得到了保护——攻击者无法得知某一学生（如“丁丁”）的具体成绩信息. 但隐私保护显然不能建立在如此侥幸的情形之上. 比如某一攻击者已知郭犇数分，代数和微分几何都考了100分，想知道他的泛函成绩，那么就可以从表中轻松获取该信息，因为表中只有郭犇一个人在这三门课都拿到100分. 又如某一攻击者已知LZC挂了一科，同样可以查询到关于LZC的更多隐私信息. 但这样的保护机制也不能说是毫无作用——它成功保护了“小兔子”的所有成绩信息：即便你知道小兔子的三科成绩，也无法确定她的第四科成绩. 那么如何改进这种匿名化方法呢？答案就是时下颇为流行的k-匿名算法. k-匿名算法将一些属性概化，以保证：任一条数据库中的记录，任取其一属性，在库中都有k条记录的该属性值与其相同. 比如我们要保护LZC的泛函分析成绩，那么我们将7号和8号的微分几何成绩凑成一个元组，统一写为[0-90]，攻击者即无法分辨二者的区别. 以上的匿名化过程看起来很美好，但k-匿名算法仍有缺陷，可能会遭受同质化攻击和背景知识攻击的挑战，所以需要更多的隐私化处理，不再详谈. 查询中的差分攻击与差分隐私 我们现在抛掉匿名性的问题，考虑数据库的查询问题. 此时我们不会把整个数据集暴露给攻击者，而是给攻击者提供一些查询的机会. 在查询的同时，保护单条记录的敏感属性值（比如在此处设定为保护“泛函”的成绩隐私）. 如果我们的数据库管理员总是说实话，那么我们必须拒绝单条记录的查询. 比如，你不能询问“丁丁的泛函成绩是多少”，因为我们要保护的正是泛函的成绩. 那么，阻止单条记录的查询是否就能很好地保护隐私？答案是不能. 这种攻击的手法就称为差分攻击. 攻击者想知道LZC的泛函成绩，于是进行了两步查询： 求1-8所有人的泛函成绩之和. SUM(1, 8). 求1-7所有人的泛函成绩之和. SUM(1, 7). 然后做差，就得到了LZC的泛函成绩. SUM(1, 8) - SUM(1, 7). 隐私泄露了！这种局面当然不是我们希望看到的，于是我们需要一些机制来抵御这种“差分攻击”. 差分攻击的核心做法就是找两个只差一条记录的数据集，分别做查询，再比较结果的差异，来获取两个集合所相差的记录的敏感信息. 所以我们最直接的想法也就是，通过随机化的查询（即管理员不能总说实话），使得攻击者无法区分只差一条记录的两个集合. 这便是差分隐私. 差分隐私的数学框架 DEFINITION 差分隐私：若机制 \(M\) 对于任一输出集合 \(S\) 和任意邻近集 \(D,D&#39;\) 总有： \[Pr[M(D)\in S] \leqslant e^{\varepsilon}\cdot Pr[M(D&#39;)\in S] + \delta\] 则称 \(M\) 满足 \((\varepsilon,\delta)\)-(近似)差分隐私. 当 \(\delta=0\) 时，称为 \(\varepsilon\)-差分隐私. 其中 \(\varepsilon\) 称为隐私预算. 记号说明： 数据集：数据全体记作 \(\mathscr{X}\)，其子集 \(D\subset\mathscr{X}\) 称为数据集. 邻近集：只相差一条记录的一对数据集. 即 \(|D\triangle D&#39;|=1\). 查询：映射 \(f:D\to\mathbb{R}\). 全体查询记作 \(F\). 查询的敏感度： 局部敏感度：\(\Delta f_{LS}=\max\limits_{D&#39;}\Vert f(D)-f(D&#39;)\Vert_1\). 全局敏感度：\(\Delta f_{LS}=\max\limits_{D,D&#39;}\Vert f(D)-f(D&#39;)\Vert_1\). 容易看出，局部敏感度会与数据分布有很强的关联，但全局敏感度一般较大. 故在需要使用局部敏感度时，常采用局部敏感度的平滑上界. 如何实现差分隐私 差分隐私是通过随机化的方式来干扰正常的查询，或是对数据集做一些处理. 那么最常规的干扰查询/处理数据的手法，就是加噪音. 一般情况下，数据库的查询可分为两类：数值查询和非数值查询. 数值查询：小兔子的微分几何考了多少分？ 非数值查询：LZC分最高的是哪一门课？ 应对这两种查询，分别有Laplace机制和指数机制. Laplace机制 Laplace分布：这里只考虑均值为 \(0\) 的Laplace分布. 尺度参数为 \(b\) 的Laplace分布记为 \(Lap(b)\)，其密度函数为： \[p(x) = \frac{1}{2b}\exp(-\frac{|x|}{b}).\] Laplace机制就是给查询结果添加服从Laplace分布的噪声，即： \[M(D) = f(D)+\xi\] 若 \(\xi\sim Lap(\frac{\Delta f}{\varepsilon})\)，则该算法可提供 \(\varepsilon\)-差分隐私保护. 从过程即可知道，Laplace机制只适合数值查询. 指数机制 对于非数值查询，需要用指数机制来干扰. 具体的办法是（以查询LZC分最高的课程为例）： 先给所有可能的答案一个打分，称为效用函数 \(q\)，\(q\) 越大表示这个答案越接近真实答案. 此处可能的答案为：数学分析、高等代数、微分几何、泛函分析. 此处的效用可以用成绩表示：90，90，0，90. 给所有可能答案分别分配一个概率，规则为： \[Pr[\text{return }\phi] \propto \exp(\frac{\varepsilon q(D,\varphi)}{2\Delta q}).\] 此时算法提供 \(\varepsilon\)-差分隐私保护. 网上关于指数机制有非常多的例子，不多赘述. 可用性评估 给数据加噪声必定会降低数据的可用性，对可用性的评估一般有以下几种： 直接看噪声大小：噪声 \(\downarrow\)，可用性 \(\uparrow\). 对误差进行度量：单次查询误差为 \(\Vert f(D)-\hat{f}(D)\Vert\). （\(\hat{f}\) 表示加了噪音的 \(f\).） \((\alpha,\beta)\)-可用性：当 \(F\) 满足 \[Pr[\max\limits_{f\in F}|f(D)-\hat{f}(D)| \leqslant \alpha] &gt; 1-\beta\] 称 \(D\) 是 \((\alpha,\beta)\)-可用的. 数据发布 数据发布所指的，就是数据库中的数据对于外界访问的支持. 一般有两种情形： 交互式发布：一问一答. 非交互式发布：问完再答/发布处理过的数据集. 交互式数据发布 给定预算 \(\varepsilon\)，然后进行一问一答，直至预算耗尽. Laplace机制 能回答问题的数较少，与数据库大小成次线性关系. 时间复杂度低，算法简单. K-norm：将查询结果转为高维多面体研究 能回答指数级别的问题. 时间复杂度高. 中位数：将查询分为难易两类，简单问题的结果可由难问题的答案确定. 困难的查询大约只有 \(O(\log |F|\log|\mathscr{X}|)\) 个，故能回答指数级别个问题. 时间复杂度高，样本复杂度也很高. PMW，IDC：将数据集视为直方图进行迭代查询 能回答指数级别的问题. 只能处理计数类查询. 基于直方图的数据发布 将数据集 \(D\) 视为 \(\mathscr{X}\) 上的直方图 \(x\in N^{|\mathscr{X}|}\)，其中 \(N\) 为所有可能的属性值组合. 主要手段： Laplace机制：每次查询都给涉及到的所有格子添加噪声. 格子较多会累积大量噪声 将格子分为若干区域，区域内部取平均，再给每个区域分别添加噪声，减少添加噪声的次数. （分区可借助kd-tree） 会面临一致性的问题：可能不能维持原先的大小关系. 流数据的差分隐私 流数据是用一个0-1串来表示的数据，每一位代表一个时间节点，0表示这个时刻没有事情发生，1表示这个时刻有事情发生. 这里输出的数据主要是某一段的1的个数，于是有两种隐私的级别： 用户层面（user-level）：将与单个用户相关的所有事件隐藏起来. 事件层面（event-level）：将单个事件隐藏起来. 由于用户层面的隐私会导致查询的敏感度过高，故一般只考虑事件层面的隐私. 在预算一定的前提下尽可能提高任一时间节点 \(t_k\) 的前缀 \(D(t_k)\) 中的事件计数 \(\hat{\iota}(t_k)\) 的精确度. 主要手段如下： Laplace机制：给每个时间步都添加噪声. 噪声过大 分割数据集：p-sum机制. 迭代 图数据的差分隐私 边的差分隐私：将边藏起来 主要解决的问题：与子图相关的问题. 参考：Nissim K, Raskhodnikova S. Smooth sensitivity and sampling in private data analysis. 点的差分隐私：将点藏起来 参考： J. Blocki, A. Blum, A. Datta, and O. Sheffet. Differentially private data analysis of social networks via restricted sensitivity. 非交互式数据发布 非交互式的数据发布要比交互式的更困难，因为需要考虑多个问题之间的联系. 发布处理后的数据集则更为困难，在隐私预算固定的情况下，常常需要加入巨量的噪声来保证安全性. 批查询 批查询：给出多个查询，然后一并回答. 面对的挑战：查询之间的相关性会导致敏感度升高，进而导致噪声过大. 处理的手段：一般是对查询做一些变换，或是一些迭代的方法. 列联表 列联表：对数据集按照属性分类时列出的频数表. 注意和直方图并不太一样，一个是列频数，一个是列属性. 最直接的Laplace机制 直接向每个格子添加Laplace噪声，再求边缘频数 缺点：噪声过大 改进的Laplace机制 先求边缘频数，再向边缘频数添加Laplace噪声，减少噪声添加次数 缺点：不能维持一致性 Fourier变换： 先进行Fourier变换，再添加噪声 由于Fourier变换后的每一个系数都对应一个满足一致性的列联表，故不会破坏一致性，同时还能减小噪声. 匿名化数据集发布 这是一种发布处理过的数据集的非交互式数据发布方法. 在最初的“乱谈隐私”中提到了匿名化数据集的方法，由于最终发布的数据集中的一些记录，会包含有与原数据集完全相同的部分属性信息，故可能会泄露用户的隐私. 所以我们需要将传统的匿名化方法进行处理，使其满足差分隐私的要求. 根据差分隐私的串行组合性质，我们知道如果算法的每一步都能够满足差分隐私的要求，则整个算法也能够提供差分隐私保护. 于是我们只需要将传统的匿名化方法的每一步都变得满足差分隐私要求. DiffGen算法. 不详细解释. 差分隐私PAC学习 这也是一种发布处理过的数据集的非交互式数据发布方法. PAC学习：设有 \(\mathscr{X}\) 上的概念类 \(\mathscr{C}\) 上的算法 \(\mathscr{A}\)，使用假设空间 \(H\). 若 \(\mathscr{A}\) 对所有概念 \(c\in\mathscr{C}\) 和所有 \(\mathscr{X}\) 上的分布 \(D\)，给定 \(D\) 中 \(n\) 个 i.i.d. 样本作为输入，算法 \(\mathscr{A}\) 输出假设 \(h\in H\)，s.t. \[Pr[error_D (c,h)\leqslant\alpha]\geqslant 1 − \beta.\] 则称算法 \(\mathscr{A}\) 是一个 \(\mathscr{X}\) 上概念类 \(\mathscr{C}\) 上的 PAC 学习算法. 如果一个概念类别在无隐私保护要求和多项式样本复杂度下是可学习的，那么在差分隐私保护条件下就是可学习的. 差分隐私PAC学习的效率比较低下，且只适用于离散情形. 隐私性算法 传统的数据挖掘/数据分析算法都有可能泄露用户隐私，若我们将其每一个步骤都视为一次查询，然后改进之使其满足差分隐私要求，则整个算法也可满足差分隐私要求. Laplace与指数机制的直接应用：SuLQ与PINQ接口 提供接口来满足数据挖掘和分析的需求. SuLQ 框架：以 SuLQ 原语为基本单元，设计隐私化的复杂算法. SuLQ 原语：单属性布尔查询 → 连续值. PINQ 框架：在数值询问使用 Laplace，选择操作使用指数机制. Partition：对数据集进行分割 ⇒ 可利用并行组合提高预算利用率. 以上接口不考虑算法的目标和性能，故分析效果可能不理想. 适用情形：监督学习，无监督学习，频繁项集挖掘. 监督学习：决策树 SuLQ-based ID3：在计算信息增益时，加入噪声. 缺点：噪声过大，可用性很差. SuLQ-based ID3-PINQ 改进：利用 Partition. 利用 Partition 减少不必要的预算损耗. 但由于每次查询都需要提供预算来进行计数，故分配的预算仍然较少，无法显著减少噪声. DiffID3：利用指数机制，一次运算评估所有属性. 指数机制的优越性：决策树分裂一次只需要一次运算. 提高了单次查询分配的预算，有效提高精确度. 无监督学习：聚类 以k-means为例，计算每个元素到质心的距离可能会泄露隐私. SuLQ k-means：发布质心和元素数量的估计值 缺点：查询质心的敏感度为聚类的最大直径，噪声过大. 有更好的框架，此处不再详谈. 频繁项集挖掘 频繁项集定义不清楚的自觉面壁... 基于截断支持度的 FIM 算法：求长度为 \(l\) 的前 \(k\) 频繁项集. 预处理：挖掘到所有 \(l\)-项集，计算其截断支持度. 求前 k 频繁项集. Laplace-FIM：为每个截断支持度添加噪声，再取前 \(k\) 个项集. 指数 FIM：以截断支持度为效用函数用指数机制选出 \(k\) 个项集. 输出：上一步得到的项集，以及加噪声后的真实支持度. 完全访问：差分隐私与机器学习 用原始数据集来做机器学习显然有可能会泄露用户的隐私，所以我们要在传统的机器学习算法上进行改进，使其满足差分隐私的要求. 一般有两种实现方法：在输出时加噪声，以及在损失函数上加噪声. 更多复杂的内容不再详谈. 作者水平有限且落笔仓促，如有错误之处，恳请指正. Zhu, T., Li, G., Zhou, W., &amp; Yu, P. S. (2017). Differential Privacy and Applications. （其实这本书很难看...） &gt; 空口无凭...请看这个句子：In addition, for a dataset with size n, the Laplace mechanism can only answer, at most, sub-linear in n number of queries to a certain level of accuracy. &gt; 小子不才，初次看到这句话是暑假，10月份才明白其意思... Orz.↩]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>计算机</tag>
        <tag>差分隐私</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode配置：插件与设置]]></title>
    <url>%2F2018%2F10%2F28%2Fvscode%E9%85%8D%E7%BD%AE%EF%BC%9A%E6%8F%92%E4%BB%B6%E4%B8%8E%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[主要是写给自己看的...方便自己什么时候搞出什么意外来重新配置. 其次是在网上翻vscode插件，都是关于前端开发者的...太气了吧，我不干前端，我就想写写我这样的人所需要的插件. 插件选择 编程语言支持 C/C++ Language Support for Java(TM) by Red Hat Python LaTeX Workshop 强大的 \(\LaTeX\) 插件，需要配置. Markdown All in One 自称写markdown用这一个插件就够了. 可以在markdown里面显示数学公式（感觉效果不是很好，有些公式渲染不出来） 提高效率的插件 Sublime Text Keymap and Settings Importer 在VSCode里使用Sublime快捷键，对Sublime老用户很有用（是我转战vscode的重要原因） Bracket Pair Colorizer 给成对匹配的括号着色，非常实用 Code Runner 跑代码的插件 TODO Highlight 在注释中加 TODO 或者 FIXME 会被高亮显示，做标记方便. 提升颜值的插件 Chinese (Simplified) Language Pack for Visual Studio Code 汉化包 VSCode Great Icons 一套比较好看的文件图标 Output Colorizer 给输出着色的插件 C/C++环境搭建 安装MinGW-w64 官网：https://mingw-w64.org/ 可在SourceForge下载. 下载完毕后安装，其中的Settings解释如下： Version：版本...不废话了 Architecture：系统架构 i686:32位 x86_64:64位 Threads：接口协议 posix：除了windows的系统，都服从posix协议 win32：当然windows得选这个.. Exception：异常处理(按照教程，若架构选择了 i686，则此处应选择 dwarf) seh：不太懂是什么..根据我看的教程选了这个，好像性能更好. sjlj：同样不太懂... Build revision：不知道是啥...乱选的. 然后啪啪啪啪一路顺下就安装好了. 环境变量 在 Path 中添加 \mingw64\bin 的地址. 在命令行运行 gcc -v 可验证是否成功. 有一些教程里面会添加一些其他的看起来很骚的环境变量...感觉...是不是没啥用？ VSCode配置 https://code.visualstudio.com/docs/languages/cpp 忽然发现好像很简单...装好 Code Runner 插件，配置中勾选 Run In Terminal 和 Save File Before Run 两项即可运行.. VSCode的默认快捷键是 Ctrl+Alt+n. LaTeX环境搭建 安装TeXLive和SumatraPDF 不多废话... 环境变量 将TexLive安装目录加入Path. 将SumatraPDF目录加入Path. 终端输入 sumatrapdf 即可验证. VSCode配置 首先肯定要安装LaTeX Workshop... 参考：http://www.latexstudio.net/archives/12260.html 在tools中添加xelatex和bibtex 在 settings.json 中添加如下字段： 1234567891011121314151617181920212223242526272829"latex-workshop.latex.tools": [ &#123; "name": "xelatex", "command": "xelatex", "args": [ "-synctex=1", "-interaction=nonstopmode", "-file-line-error", "%DOC%" ] &#125;, &#123; "name": "pdflatex", "command": "pdflatex", "args": [ "-synctex=1", "-interaction=nonstopmode", "-file-line-error", "%DOC%" ] &#125;, &#123; "name": "bibtex", "command": "bibtex", "args": [ "%DOCFILE%" ] &#125; ], 在recipe中添加xelatex与bibtex的组合 在 settings.json 中添加如下字段： 1234567891011121314151617181920212223242526272829303132333435363738394041424344"latex-workshop.latex.recipes": [ &#123; "name": "PDFLaTeX", "tools": [ "pdflatex" ] &#125;, &#123; "name": "XeLaTeX", "tools": [ "xelatex" ] &#125;, &#123; "name": "latexmk", "tools": [ "latexmk" ] &#125;, &#123; "name": "BibTeX", "tools": [ "bibtex" ] &#125;, &#123; "name": "pdflatex -&gt; bibtex -&gt; pdflatex*2", "tools": [ "pdflatex", "bibtex", "pdflatex", "pdflatex" ] &#125;, &#123; "name": "xelatex -&gt; bibtex -&gt; xelatex*2", "tools": [ "xelatex", "bibtex", "xelatex", "xelatex" ] &#125; ], SumatraPDF配置 参考：https://zhuanlan.zhihu.com/p/38178015 预览设置：在 settings.json 添加如下字段： 12345678"latex-workshop.view.pdf.viewer": "external","latex-workshop.view.pdf.external.command": &#123; "command": "SumatraPDF.exe的完整路径", "args": [ "%PDF%" ]&#125;, 正向搜索：在 settings.json 添加如下字段：（没有成功。。。） 123456789"latex-workshop.view.pdf.external.synctex": &#123; "command": "SumatraPDF.exe的完整路径", "args": [ "-forward-search", "%TEX%", "%LINE%", "%PDF%" ]&#125;, 反向搜索：在SumatraPDF的 设置-&gt;选项 中，在最下面填入：（双击即可反向搜索） 1Code.exe的完整路径 -g &quot;%f:%l&quot; 参考资料 https://code.visualstudio.com/docs/languages/cpp https://zhuanlan.zhihu.com/p/38178015]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>软件配置</tag>
        <tag>Visual Studio Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调教Hexo[5]——Hexo网站迁移中一些遗漏的问题]]></title>
    <url>%2F2018%2F10%2F27%2FHexo%E7%BD%91%E7%AB%99%E8%BF%81%E7%A7%BB%E4%B8%AD%E4%B8%80%E4%BA%9B%E9%81%97%E6%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[笔记本屏幕坏掉了...正式宣告我本学期开学前后在修南桥芯片上花的将近300几乎打了水漂... 一怒之下搞了个新笔记本，原先的笔记本放在寝室当主机用吧... 于是问题来了，我又双叒叕得迁移一次网站，然后又双叒叕遇到一系列问题. 在此记录，权当之前《迁移》一文的补充. 环境配置与文件同步 感觉不需要多废话...我使用了坚果云来进行同步. 换行符：LF与CRLF之争 将文件迁移好之后，如果贸然 hexo g, d 二连，在部署时会有如下信息： 12warning: LF will be replaced by CRLF in ..... The file will have its origional line endings in your working directory. 解决方案 只需要运行如下命令： 1git config --global core.autocrlf false 再运行 hexo d 即可. github ssh key的完整配置 首先肯定是要创建 ssh key： 1$ ssh-keygen -t rsa -C &quot;你的邮箱&quot; 需要输入的地方全都直接回车确认，会在 /.ssh 目录下生成两个文件 id_rsa 和 id_rsa.pub，然后在github上把 id_rsa.pub 添加到ssh key即可. 我做完这些之后就直接开始运行 g 和 d，然而有如下报错： 12Error: ssh: connect to host github.com port 22: Connection timed outfatal: Could not read from remote repository. 在网上查了一会儿，感觉那些方法看起来都不太适合我的情况. 于是上github的ssh key页面看了一眼，发现github认为我还没有使用过这个key... 此时我想到，这是否是因为我没有验证ssh key... 于是验证了一下： 12345$ ssh -T git@github.com&gt; The authenticity of host &apos;github.com (192.30.253.112)&apos; can&apos;t be established.RSA key fingerprint is SHA256:xxxxxxxxxxxxxxxxxx.Are you sure you want to continue connecting (yes/no)? 看到这个信息我有点迷。。。不过还是输了 yes...，随后得到如下提示： 12&gt; Warning: permanently added &apos;github.com,192.30.253.112&apos; (RSA) to the list of known hosts.Hi lzcwr! You&apos;ve successfully authenticated, but Github does not provide shell access. 此时再运行 hexo d 就不再报错了.]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>计算机</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调教Hexo[4]——记一次费劲的改版...]]></title>
    <url>%2F2018%2F10%2F04%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%94%B9%E7%89%88%2F</url>
    <content type="text"><![CDATA[其实大概是因为我太笨Orz... 又双叒叕是一篇没有营养的文章. 很早就发现之前用的 yelee 主题中的 git 图标不能用了，前几日又发现无序列表的符号也挂掉了？？ 这可不能忍... 然而我又不想花时间折腾主题本身，加上搜索功能一直没有配好的积怨，决定干脆换一个主题. 这个 NexT 主题好像看起来不错！就是它了！ 随后就是很多问题...佛了. 所以在这里把一些（能想起来的）问题简单记一下。 Tags和Categories页面无法正常显示的问题 在最初更换主题后，tags 和 categories 页面只有一个光秃秃的标题，下面的链接全部消失了... 我以为是页面没有生成好的问题，于是先运行 hexo clean 再运行 hexo g，然后重新 hexo s. 然而并没有什么效果！吓尿的我赶紧 重试了n发 Google了一下，大概是搜索姿势问题，这个问题不太容易准确描述... 费了一通劲，终于查明白了：只需要在这两个页面中分别加入一句话就可以了. 完整的构建过程如下（只以 tags 为例，categories 同理）： 先在终端中键入 1hexo new page tags 然后在 /source 目录下会生成一个 /tags 子目录，内含一个 index.md 文件，其初始内容为： 1234---title: tagsdate: yyyy-mm-dd hh:mm:ss--- 只需添加一行 type: tags 即可. 即改为： 12345---title: 标签type: tagsdate: yyyy-mm-dd hh:mm:ss--- 如此操作后，tags 页面即可正常显示. categories 页面也是同理. Mathjax显示问题 这个问题我认为是 NexT 主题的锅. 像我这样的一个网站，mathjax 的重要性不言而喻... 没有 mathjax 我这个网站简直可以直接关掉了. 于是这是我刚换了主题就立刻着手配置的东西. 在 NexT 主题的配置文件 _config.yml 中关于 mathjax 的内容如下： 123456789# ---------------------------------------------------------------# Third Party Services Settings# ---------------------------------------------------------------# MathJax Supportmathjax: enable: false per_page: false cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML 按照其文档所描述，只需将 enable: false 改为 enable: true 即可. 然而我照做后，发现文档中的 mathjax 公式只能短暂地正常显示几秒，就会变成一堆不知道是什么的小方块... 看到这个情况以后我很慌张... 冷静了一会儿之后开始思考这个问题的成因... 最初没有想到是 NexT 主题的问题，感觉可能性比较大的也就是这么几个： 是 Google Chrome 浏览器的问题，辣鸡 Chrome 无法正常显示 mathjax 公式. 检查方案：换个浏览器打开 localhost:4000 试试； 检查结果：其他浏览器显示的也是一堆小方块...GG！ 既然不是 Chrome 的锅，那就是我配错了！ 检查方案：找找其他用了 NexT 主题的网站，看看是否有同样问题； 检查结果：找这个有 LaTeX 公式的 NexT 网站就费了老鼻子劲... 然后发现也是一堆小方块... GG again！ 和卜凡大神讨论了一下，可能是 mathjax 被墙了？ 检查方案：墙个屁啊...可能么？链接都能打开怎么可能是墙了... one more GG！ 三个我认为比较可能的问题都不存在... 这让我陷入了短暂的蒙蔽... 回过神来以后，我感到我对于我最初做的假设“主题本身没有错”产生了一丝怀疑，联想到 yelee 主题仍然能正常显示 LaTeX 公式，我查了一发 mathjax 的配置方法，然后发现 cdn 和这里的不一样... 于是我在某篇文章中加了另一个 cdn，这篇文章便能正确加载 mathjax 了... 我简直佛了，于是进行了如下修改，mathjax 即能正确加载. 12345# MathJax Supportmathjax: enable: true per_page: false cdn: //cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML 动画特效canvas-nest配置 文档中提供的方法为：在配置文件中将 canvas_nest 一项改为 true ，我照做了，然而并没有什么效果. 单页的配置方法很简单：在文章中加入以下字段即可： 1&lt;script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"&gt;&lt;/script&gt; 若想在所有页面均启用该特效，则须修改 _layout.swig 文件： 在_layout.swig 的 body 中添加如下字段： 123&#123;% if theme.canvas_nest %&#125; &lt;script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 然后依次运行 hexo clean, hexo g 和 hexo s / hexo d 即可看到特效. 搜索功能的配置 按照文档中的方法进行操作即可成功配置，治好了我多时没有在 yelee 中配好搜索功能的心病... 注意：不需要在 _config.yml 中添加 search 项，否则侧栏中将会出现两个“搜索”. 评论功能的配置 Gitment 之前的版本配置了多说评论，然而不久多说就GG了，加上 disqus 疑似被墙... 之后一直没有再弄评论. 既然改版了，顺手配了一个 gitment 评论，如有错误欢迎批评. 配置很简单： 在 https://github.com/settings/developers 申请一个 application, 按照如下内容填写申请即可： 1234Application name：GitmentHomepage URL：https://网站地址/Application description：Blog comment systemAuthorization callback URL：https://网站地址/ 然后在 github 新建一个仓库用来存评论，比如叫做 gitment-comments. 在主题配置文件 _config.yml 中填写 gitment 相关内容即可完成配置. 12345678910111213gitment: enable: true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide 'Powered by ...' on footer, and more language: zh-Hans # Force language, or auto switch by theme github_user: lzcwr # MUST HAVE, Your Github ID github_repo: gitment-comments # MUST HAVE, The repo you use to store Gitment comments client_id: 在申请好application的页面中有 # MUST HAVE, Github client id for the Gitment client_secret: 在申请好application的页面中有 # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled 又双叒叕失败了！ 正当我满心欢喜意为自己配好了 Gitment 的时候，突然感到事情太顺利了（？）于是决定测试一下评论. hexo d 部署完毕以后，我在本文的后面尝试了一下用 github 账号登录. 然而！报错了！报错信息为 [object ProgressEvent]. 我赶紧去 gitment 的 issue （参见https://github.com/imsun/gitment/issues/170） 里翻了一下，果然很多人有这样的问题... 大致阅读了一下，原因应该是 gitment 作者自己的网站的证书到期了，而 gitment 需要以此为接口，故会报错... 按照里面的一些方法进行了修改，但是似乎没有什么效果... 怎么办！换吧... Gitalk 换什么呢... 开始自闭... 对哦！然想起来 望望同学的博客 里面用的好像是 github issues 评论！ 赶紧去翻翻是不是 gitment... 噢，原来是 gitalk... OK！就是它了！ 配置方法 附一个 gitalk 的官方demo：https://gitalk.github.io/ 官方 github 仓库：https://github.com/gitalk/gitalk NexT 主题中并没有集成 gitalk 功能，需要自己手动添加. 首先肯定还是要在 github 上申请一个 application，具体步骤见上. 其次肯定还是要在 github 上建立一个 repository，具体步骤不多啰嗦. 在 /layout/_third-party/comments/ 目录下新建 gitalk.swig 文件，内容如下： 12345678910111213141516&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125; &lt;link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"&gt; &lt;script src="https://unpkg.com/gitalk/dist/gitalk.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var gitalk = new Gitalk(&#123; clientID: '&#123;&#123; theme.gitalk.ClientID &#125;&#125;', clientSecret: '&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;', repo: '&#123;&#123; theme.gitalk.repo &#125;&#125;', owner: '&#123;&#123; theme.gitalk.owner &#125;&#125;', admin: ['&#123;&#123; theme.gitalk.adminUser &#125;&#125;'], id: location.pathname, distractionFreeMode: '&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;' &#125;) gitalk.render('gitalk-container') &lt;/script&gt;&#123;% endif %&#125; 修改 /layout/_partials/comments.swig，在最后一个 elseif 后添加如下字段： 12&#123;% elseif theme.gitalk.enable %&#125; &lt;div id="gitalk-container"&gt;&lt;/div&gt; 添加后的 comments.swig 应如下所示： 1234567891011121314151617181920 &#123;% elseif theme.gitment.enable %&#125; &lt;div class="comments" id="comments"&gt; &#123;% if theme.gitment.lazy %&#125; &lt;div onclick="showGitment()" id="gitment-display-button"&gt;&#123;&#123; __('gitmentbutton') &#125;&#125;&lt;/div&gt; &lt;div id="gitment-container" style="display:none"&gt;&lt;/div&gt; &#123;% else %&#125; &lt;div id="gitment-container"&gt;&lt;/div&gt; &#123;% endif %&#125; &lt;/div&gt; &#123;% elseif theme.valine.appid and theme.valine.appkey %&#125; &lt;div class="comments" id="comments"&gt; &lt;/div&gt; &#123;% elseif theme.gitalk.enable %&#125; &lt;div id="gitalk-container"&gt;&lt;/div&gt; &#123;% endif %&#125;&#123;% endif %&#125; 修改 /layout/_third-party/comments/index.swig，在其末尾添加如下字段： 1&#123;% include 'gitalk.swig' %&#125; 设置 gitalk 的样式，参考1： 在 /source/css/_common/components/third-party/ 目录下新建 gitalk.styl 文件，内容如下： 1234.gt-header a, .gt-comments a, .gt-popup a border-bottom: none;.gt-container .gt-popup .gt-action.is--active:before top: 0.7em; 修改 /source/css/_common/components/third-party/third-party.styl 文件，在末尾添加如下字段： 1@import "gitalk"; 最后在主题配置文件 _config.yml 中添加如下项： 12345678gitalk: enable: true owner: 你的github帐号 # lzcwr repo: 存放评论的仓库名称 # Gitalk-comments ClientID: 在申请好application的页面中有 ClientSecret: 在申请好application的页面中有 adminUser: 你的github帐号 # 可初始化评论的账户 distractionFreeMode: true 完整无误地完成上述步骤后，在本地即可看到 gitalk 的按钮. 但本地不能用，必须要 hexo d 部署完毕后才能使用. 你以为这样就完了吗？那可未必... Error: Validation Failed 解决方案 参考了：处理Gitalk中由于文章URL过长导致的Validation-Failed(422) 部署完毕后我试了一下，又gg了！又双叒叕翻了一下 issues，发现是文章 URL 过长导致的（坏习惯，用中文做标题Orz... 中文会被编码成很长的串...）. gitalk 支持的长度只有50，难道我要一个一个改标题么？不能忍... 于是 google 了一大通，最终受到上述文章启发，决定用其 md5 码代替文章标题. 注意到前文所添加的 gitalk.swig 文件中的段落： 123456789101112&lt;script type="text/javascript"&gt; var gitalk = new Gitalk(&#123; clientID: '&#123;&#123; theme.gitalk.ClientID &#125;&#125;', clientSecret: '&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;', repo: '&#123;&#123; theme.gitalk.repo &#125;&#125;', owner: '&#123;&#123; theme.gitalk.owner &#125;&#125;', admin: ['&#123;&#123; theme.gitalk.adminUser &#125;&#125;'], id: location.pathname, distractionFreeMode: '&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;' &#125;) gitalk.render('gitalk-container') &lt;/script&gt; var gitalk 中有一项为： 1id: location.pathname, 这里正是索引的地方，我们只需要添加一个 md5 的函数，然后将其改为 md5(...) 即可. 我用的是 https://github.com/blueimp/JavaScript-MD5/blob/master/js/md5.min.js，更改完毕之后的 gitalk.swig 文件如下： 1234567891011121314151617&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125; &lt;link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"&gt; &lt;script src="/js/md5.min.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/gitalk/dist/gitalk.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var gitalk = new Gitalk(&#123; clientID: '&#123;&#123; theme.gitalk.ClientID &#125;&#125;', clientSecret: '&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;', repo: '&#123;&#123; theme.gitalk.repo &#125;&#125;', owner: '&#123;&#123; theme.gitalk.owner &#125;&#125;', admin: ['&#123;&#123; theme.gitalk.adminUser &#125;&#125;'], id: md5(location.pathname), distractionFreeMode: '&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;' &#125;) gitalk.render('gitalk-container') &lt;/script&gt;&#123;% endif %&#125; 这样好像就彻底搞好了？我这乌鸦嘴可还行== 关闭评论的页面 在需要关闭评论的页面加一句 comments: false 即可. PDF插件配置 不多说了，参见 https://pdfobject.com/ 官方 github 仓库：https://github.com/pipwerks/PDFObject https://asdfv1929.github.io/2018/01/20/gitalk/↩]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>计算机</tag>
        <tag>Hexo</tag>
        <tag>Mathjax</tag>
        <tag>Gitalk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习[1]——时间序列分析]]></title>
    <url>%2F2018%2F09%2F26%2FPython%E5%AD%A6%E4%B9%A0-1-%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[做了一个数据预测的东西, 对这方面的内容过于生疏, 顺手简单学习了一波Orz... tsa 的官方文档：http://www.statsmodels.org/dev/tsa.html 面向乱搞的程序设计？ 序列的分析 序列的平稳性 如果时间序列 \(x_t\) 在某一常数附近波动并且范围不大，方差和均值为常数，且延迟 \(k\) 期的子自协方差和自相关系数是相等的，则称 \(x_t\) 是平稳序列. 1 自协方差和自相关系数的定义如下： 自协方差：\(\gamma(t,s) = \mathbb{E}[(x_t-\mu_t)(x_s-\mu_s)]\) 自相关系数：\(\rho(t,s) = \frac{cov(x_t, x_s)}{\sigma_t\sigma_s}\) 平稳序列的判定：平稳性检验 一般有以下两种方法： 时序图检验：根据平稳序列的均值和方差都为常数的性质，平稳时间序列的时序图应当显示该序列始终在一个常数附近随机波动，且波动范围有限； 自相关检验：平稳时间序列具有短期相关性，故平稳时间序列通常只有近期的项才对当前值的影响较为明显。随着间隔 \(k\) 的增大，平稳序列的自相关系数会不断衰减至 \(0\)，而非平稳序列的衰减较慢。 白噪声序列 白噪声序列指的是纯随机序列，序列的各项之间毫无关系，从中无法获取任何有用的信息。 白噪声序列的判定：纯随机性检验 纯随机序列满足 \(\gamma(k) = 0\)，其样本自相关系数很接近零，并且在零附近随机扰动。一般构造 \(Q\) 统计量和 \(LB\) 统计量来进行检验. 在 Python 中可以使用 acorr_ljungbox 方法来检验. 直接 print(acorr_ljungbox(ts, lags = 1)). 常用的模型原理 时间序列趋势主要受到总体趋势 \(T\)、季节性因素 \(S\)、周期性波动 \(C\) 和随机扰动 \(\varepsilon\) 的影响，一般来说有加法和乘法两种模型。 加法模型(additive model): \(x_t = T_t+S_t+C_t+\varepsilon_t\); 乘法模型(multiplicative model): \(x_t = T_t\times S_t\times C_t\times\varepsilon_t\). 在作分析时，常常采用的是AR-MA模型： AR模型 \(AR(p)\)：每一项都与前 \(p\) 项线性相关, 与随机扰动项无关. \[x_t=\varphi_0 + \varphi_1 x_{t-1}+\varphi_2 x_{t-2}+\cdots+\varphi_p x_{t-p}+\varepsilon_t = \varphi_0+ \sum\limits_{k=1}^p \varphi_k x_{t-k}+\varepsilon_t\] 其中随机扰动项 \(\varepsilon_t\) 为均值为 \(0\) 的白噪声序列. 均值方差均为常数，ACF拖尾，PACF \(q\) 阶截尾. MA模型 \(MA(q)\)：每一项都与前 \(q\) 项的随机扰动线性相关, 与真实值无关. \[x_t = \mu + \varepsilon_t-\theta_1 \varepsilon_{t-1}-\theta_2\varepsilon_{t-2}-\cdots-\theta_q \varepsilon_{t-q} = \mu + \varepsilon_t - \sum\limits_{k=1}^q \theta_k\varepsilon_{t-k}\] 其中随机扰动项 \(\varepsilon_t\) 为均值为 \(0\) 的白噪声序列，\(\mu\) 为序列均值. 均值方差为常数，ACF为 \(q\) 阶截尾，PACF拖尾. ARMA模型 \(ARMA(p,q)\)：每一项都与前 \(p\) 项线性相关, 同时与前 \(q\) 项的随机扰动有关. \[ \begin{align} x_t &amp;= \varphi_0 + \varphi_1 x_{t-1}+\varphi_2 x_{t-2}+\cdots+\varphi_p x_{t-p} + \varepsilon_t-\theta_1 \varepsilon_{t-1}-\theta_2\varepsilon_{t-2}-\cdots-\theta_q \varepsilon_{t-q} \\ &amp;= \varphi_0 + \sum\limits_{i=1}^p \varphi_i x_{t-i} + \varepsilon_t - \sum\limits_{j=1}^q \theta_j\varepsilon_{t-j} \end{align} \] 其中随机扰动项 \(\varepsilon_t\) 为均值为 \(0\) 的白噪声序列，\(\mu\) 为序列均值. 均值方差为常数，ACF为 \(q\) 阶截尾，PACF \(p\) 阶截尾. 容易看出AR模型和MA模型分别是ARMA在 \(p=0\) 和 \(q=0\) 时的特例. 一般在分析时分析的多是平稳序列，可以考虑用ARMA模型。有一些序列本身不是平稳序列，但做一阶差分之后成为平稳序列，这种序列被称为差分平稳序列，可以使用ARIMA模型进行拟合. Python中的AMRA模型 导入库 1234567891011import pandas as pdimport numpy as npimport matplotlib.pyplot as pltfrom datetime import datetimefrom statsmodels.graphics.tsaplots import plot_acf # 自相关图from statsmodels.graphics.tsaplots import plot_pacf # 偏自相关图from statsmodels.stats.diagnostic import acorr_ljungbox # 白噪声检验from statsmodels.tsa.stattools import adfuller # 平稳性检测from statsmodels.tsa.seasonal import seasonal_decompose # 季节性分解from statsmodels.tsa.arima_model import ARMAfrom statsmodels.tsa.arima_model import ARIMA 乱码问题处理 12plt.rcParams['font.sans-serif'] = ['SimHei'] # 显示中文标签plt.rcParams['axes.unicode_minus'] = False # 显示负号 数据读取与处理 按照我的习惯会将日期一列命名为 date. 数据读取 一般数据的格式为 XLS 或者 CSV. 数据为CSV格式 1df = pd.read_csv('文件地址', encoding = 'utf-8', index_col = 'date') 数据为XLS格式 1df = pd.read_excel('文件地址', encoding = 'utf-8', index_col = 'data') 若数据为数据库形式(如 MySQL), 则可以直接用 SQL 语句从数据库中提取. 数据格式的处理 以上读取数据的函数只会将读入的数据保存为 DataFrame 对象，但我们做预测所需要的数据类型是 Series，故需要将其转换为该格式，并将 date 指定为索引.2 12df.index = pd.to_datetime(df.index) # 指定 date 为索引ts = df['x'] # 生成Series对象 注意此处数据文件中的日期必须为日期格式. 如 (yyyy/mm/dd) 是合法的，但 &quot;20080808&quot; 就是不合法的，必须进行处理.3 如此得到的 ts 即为一个可用的时间序列，不仅可以用类似于 2014-1-1 的字符串进行访问，也可以用时间对象 datetime(2014, 1, 1) 进行访问. 即以下两种访问方式都是可行的： 123ts['2014-1-1']ts[datetime(2014, 1, 1)]ts['2014-1-1' : '2014-5-1'] # 切片操作. 注意此处的切片为闭区间, 端点都包括. 关于 Series 的更多内容参见 https://blog.csdn.net/zutsoft/article/details/51482573 数据的趋势分析 平稳性检验 可以进行 ADF 检验. 弱鸡还不理解其原理...暂且放在这里. 直接 print(adfuller(ts)) ，输出有一大串. 第一个值比后面带百分号的都小说明比较平稳. 平稳性处理：季节性分解 为了使序列更平稳，在做计算时经常对其取对数: 1ts_log = np.log(ts) 若原始数据有很强的周期性，则可以考虑对其进行季节性的分解，即将元素数据分离为总体趋势，季节性趋势以及残差三部分. 1234decomposition = seasonal_decompose(ts_log, model="additive")trend = decomposition.trendseasonal = decomposition.seasonalresidual = decomposition.resid 将三种因素分离后，即可分别做预测，再相加. statsmodels 中还提供了乘法模型，只需将上述代码中的 additive 改为 multiplicative 即可. 模型识别 只需要对所要拟合的数据集绘制其 ACF(自相关) 与 PACF(偏自相关) 图，观察其截尾与拖尾性质即可确定模型阶数. 相关图的绘制代码如下： 12plot_acf(ts_log).show()plot.pacf(ts_log).show() 例如最终识别为 \(p=q=1\)，则预测模型为 \(ARMA(1,1)\)，实现代码如下： 12model = ARMA(ts_log, order = (1,1))result = model.fit(disp = -1, method = 'css') 随后用以下代码即可预测： 12predict = result.predict(begin, end) # begin 和 end 表示所需预测的起点与终点predict = np.exp(predict) # 若之前取了对数 or 做了差分, 预测之后应还原 Python中的ARIMA模型 没有什么卵用的模型... 多了个参数表示差分的阶数. 手动差分效果应当完全没差. 参见 https://zhuanlan.zhihu.com/p/35128342↩ python时间序列分析: https://www.cnblogs.com/foley/p/5582358.html↩ 将 &quot;yyyymmdd&quot; 转换为 &quot;yyyy/mm/dd&quot; 的方法很简单，以下给出 C++ 代码： date_format.cpp 处理日期格式12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;int f(char c)&#123; return c - '0';&#125;int main()&#123; freopen("out.txt", "w", stdout); // 输入到文件里, 方便使用 std::string s; // 输入格式为 yyyymmdd 字符串 while(std::cin &gt;&gt; s) &#123; int y = 1000 * f(s[0]) + 100 * f(s[1]) + 10 * f(s[2]) + f(s[3]); int m = 10 * f(s[4]) + f(s[5]); int d = 10 * f(s[6]) + f(s[7]); printf("%d/%d/%d\n", y, m, d); &#125; return 0;&#125;↩]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>计算机</tag>
        <tag>统计学</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下用Shell——Cmder配置]]></title>
    <url>%2F2018%2F09%2F23%2FCmder%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[平时免不了会用到windows下的命令行, 但是 cmd 使用体验非常差... 后来开始用 PowerShell, 比起 cmd 来说确实有了一些改善, 但是仍然不是很友好Orz. 再后来发现了 Cmder, 对 Shell 的支持更为友好, 界面也很美观, 于是就彻底放弃了 PowerShell... 这里记录一下 Cmder 的配置, 主要是给自己看的. 中文支持 环境变量添加 右键菜单配置 提示符修改 中文支持 在 Settings -&gt; Startup -&gt; Environment 里面加如下的语句即可: 1set LANG=zh_CN.UTF8 环境变量添加 将 Cmder 的安装目录添加到 PATH 中. 例如我的安装目录是 D:\Cmder, 直接将其添加到 PATH 的开头即可. 成功添加环境变量后, 在 Win+R 调出的“运行”窗口中键入 Cmder 即可直接在用户目录下打开 Cmder. 右键菜单配置 添加好环境变量后, 在 cmd 或 PowerShell 中运行如下语句即可. 1Cmder.exe /REGISTER ALL 成功后在任意文件夹空白处右击鼠标, 即可在快捷菜单中找到 Cmder Here, 即在该目录下运行 Cmder. 提示符修改 这个在网上查了很多东西都不能直接用, 需要自己多尝试. Cmder 的默认输出提示符是 \(\lambda\), 多少看着有点别扭, 按照 Linux 的习惯可以将其改为美元符号 \(\$\). 网上的教程大多是修改 /vendor 目录下的 init.bat, clink.lua 或 profile.ps1 来达到修改提示符的目的, 但是具体方法大多是不可行的. 我目前所使用的版本可以通过修改 clink.lua 来实现, 具体做法是将该文件第43行的 local lambda = &quot;λ&quot; 修改为 local lambda = &quot;$&quot; 即可... 观众用完之后（如果无效）, 不能骂我== 因为我...根本没有头发（1 Linux命令速查表 顺手放一个表在这里方便查阅..2 /* Only resize the element if PDF is embedded */ .pdfobject-container { width: 800px; height: 900px; } PDFObject.embed("https://i.linuxtoy.org/files/pdf/fwunixref.pdf", "#my-container"); 该梗的出处见《【成龙】我的洗发液》: https://www.bilibili.com/video/av2023391↩ 转载自 https://linuxtoy.org/archives/unix-linux-command-cheat-sheet.html↩]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>软件配置</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合数学[1]——球放入盒子的方案数]]></title>
    <url>%2F2018%2F09%2F17%2F%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E2%80%94%E2%80%94%E7%90%83%E6%94%BE%E5%85%A5%E7%9B%92%E5%AD%90%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0%2F</url>
    <content type="text"><![CDATA[近日观室友做面试题有感, 恰好遇到了球装盒子的问题, 顺手整理一波. \(n\) 个球放入 \(m\) 个盒子, 共有多少种不同的方案? 球 盒 允许空 方案数 不同 不同 是 \(m^n\) 不同 不同 否 \(m!\cdot S(n,m)\) 不同 相同 是 \(\sum\limits_{k=0}^m S(n,k)\) 不同 相同 否 \(S(n,m)\) 相同 不同 是 \(\binom{n+m-1}{m-1}\) 相同 不同 否 \(\binom{n-1}{m-1}\) 相同 相同 是 \(dp(n,m)\) 相同 相同 否 \(dp(n-m,m)\) 球不同 盒子不同 不允许有空盒子 可以先视盒子为相同, 方案数为 \(S(n,m)\)（参见下文）, 再考虑盒子的全排列. \(n\) 个不同的球放入 \(m\) 个不同的盒子, 盒子不允许为空, 方案数为 \(m!\cdot S(n,m)\). 允许有空盒子 最简单的情况没有之一: \(n\) 个不同的球放入 \(m\) 个不同的盒子, 盒子允许为空, 方案数为 \(m^n\). 盒子相同 不允许有空盒子 \(n\) 个不同的球放入 \(m\) 个相同的盒子, 盒子不允许为空, 方案数为第二类Stirling数 \(S(n,m)\). 简略证明: 对于第 \(n\) 个球, 有且仅有如下两种情况: 前 \(n-1\) 个球的放法已经保证了 \(m\) 个盒子都不空: 此时只需将 \(n\) 号球随意放即可, 方案数为 \(mS(n-1,m)\); 前 \(n-1\) 个球放好后有且仅有一个盒子是空的: 此时必须将 \(n\) 号球放入空盒中, 方案数为 \(S(n-1,m-1)\). 于是, 此时的方案数递推式为 \[S(n,m)=mS(n-1,m)+S(n-1,m-1)\] 初值为: \(S(0,m)=1\). (没球的方案只有一种) \(S(n,1)=1\). (一个盒子的方案只有一种) 一段计算该种方案数的代码如下（递归版本）: 球不同, 盒相同, 不许空123456int dp(int n, int m)&#123; if(n &lt; m) return 0; // 球比盒子还少, 无法满足盒子非空 if(n == 0 || m == 1) return 1; // 没球 or 一个盒子 return m * dp(n - 1, m) + dp(n - 1, m - 1);&#125; 允许有空盒子 \(n\) 个不同的球放入 \(m\) 个相同的盒子, 盒子允许为空, 方案数为 \(\sum\limits_{k=0}^m S(n,k)\). 只需要枚举非空箱子的个数, 然后按照上一种情况的方法来计算, 求和即可. 在计算时最好先预处理出 \(S(n,m)\) 的值. 球相同 盒子不同 不允许有空盒子 \(n\) 个相同的球放入 \(m\) 个不同的盒子, 盒子不允许为空, 方案数为 \(\binom{n-1}{m-1}\). 简略证明: 将 \(n\) 球装入 \(m\) 个盒子, 相当于插 \(m-1\) 个板. 由于不允许为空, 故在 \(n-1\) 个空中选出 \(m-1\) 个插板即可. 允许有空盒子 \(n\) 个相同的球放入 \(m\) 个不同的盒子, 盒子允许为空, 方案数为 \(\binom{n+m-1}{m-1}\). 简略证明: \(n\) 个球放完之后, 在每个盒子中都加一个球, 此时一定无空箱. 这说明此时的方案数不多于 \(n+m\) 个相同的球放入 \(m\) 个不同盒子的方案数. 反过来也可证明另一边的不等式, 于是此时的方案数就是\(n+m\) 个相同的球放入 \(m\) 个不同盒子的方案数. 盒子相同 不允许有空盒子 \(n\) 个相同的球放入 \(m\) 个相同的盒子, 盒子不允许为空, 方案数为 \(dp(n-m,m)\). 其中 \(dp(n,m)\) 为下一种情况的方案数. 允许有空盒子 \(n\) 个相同的球放入 \(m\) 个相同的盒子, 盒子允许为空, 方案数为 \(dp(n,m)\). 计算思路:: 在放置 \(n\) 个球的时候, 有且仅有如下两种策略: 给每个盒子放一个球: 还剩下 \(n-m\) 个球, 故此时的方案数为 \(dp(n-m,m)\); 至少一个盒子不放球: 可以扔掉一个空盒子, 故此时的方案数为 \(dp(n,m-1)\). 于是此种情况的递推式为: \[dp(n,m)=dp(n-m,m)+dp(n,m-1)\] 边界值为: \(S(0,m)=1\). (没球的方案只有一种) \(S(n,1)=1\). (一个盒子的方案只有一种) 上述推导过程中我们做了 \(n\geqslant m\), 即&quot;球不少于盒子&quot;的假设. 当该假设不成立时, \(n\) 个苹果至多放满 \(n\) 个盘子, 故此时方案数实际上为 \(dp(n,n)\). 一段计算该情况方案数的代码如下（递归版本）: 球相同, 盒相同, 允许空 123456int dp(int m, int n)&#123; if(n == 1 || m == 0) return 1; if(m &lt; n) return dp(m, m); return dp(m, n - 1) + dp(m - n, n);&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>算法</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018北京马拉松小记]]></title>
    <url>%2F2018%2F09%2F16%2F2018%E5%8C%97%E4%BA%AC%E9%A9%AC%E6%8B%89%E6%9D%BE%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本次北马, 我幸运地以志愿者身份参与了赛前的筹备工作. 9.13-9.15三天里结识了很多有趣的人, 总算不虚此行. 三天三个师弟, 还有丢手机的小姐姐及其大师兄, 77岁仍然坚持跑步的老奶奶, 还有一起工作的志愿者董跃、王超、王辰, 以及二位负责人. 很高兴认识各位. 一句废话 这事实上是一篇流水账都不算的东西== DAY 0: 9.12 几日前接到通知, 12日下午要去领志愿者物资并进行简单岗前培训. 我和孙李师弟都被分在换票组, 师弟正是组长. 11日晚才了解到, 孙李师弟前两天不能如期到岗, 故负责人生哥将组长换为了我. (一脸蒙蔽) 12日中午记错了地点...有点蠢...还以为地点是在人大, 看到群里大家发位置才明白是在农展馆Orz 匆忙坐公交前往, 但仍然迟到20m... 太蠢了. 志愿者感觉很大一部分是北航和人大的. Orz, Orz. 换票组喊了很久没人到...最终也只有我和董跃到了Orz. DAY 1: 9.13 きょうの後輩: 李嘉民！ 按照通知7:30就要赶到, 6:20匆匆在学五吃过早饭直接赶往场地. 基本准时赶到后, 竟然被通知为9:15开始入场... 这里必须得吐槽一下.. 本来被安排的换票小屋被大妈带领一群小妹妹占领了（？？？ 于是在手环处前面做疏导工作（我总觉得是无用功）... 中午给大家发饭吃, 至此, 换票组已彻底沦为机(打)动(杂)组. 第一天下午真的什么事情也没有, 人流量较小, 手环处前面根本不需要疏导, 和师弟还有董跃到处摸鱼, 最后提前1h撤了... 在马拉松博览会场馆内留了个影 DAY 2: 9.14 きょうの後輩: 冶文斌！ 直白地讲: 这！一！整！天！都！什！么！事！情！也！没！有！ 上午: 摸鱼. 中午: 找了个长凳睡了一觉？？被蚊子叮了俩包很气.. 下午: 摸鱼. 偶遇丢手机的小姐姐及其大师兄 我本来以为人家俩是爷爷和孙女...囧, 帮二位联系咨询台和广播台...总而言之绕了一大圈, 最后轻松找到了. 被小姐姐安利了几发跑步...其实自己也有一点这样的想法, 所以顺便也了解了一下. 找手机期间小姐姐还以为我志愿工作忙...其实啥事儿也没有...有点惭愧. 找完手机送走二位果断找到师弟继续开始摸鱼...说好的惭愧呢 附一张和二位的合影（才发现小姐姐比大师兄高） DAY 3: 9.15 きょうの後輩: 孙李本尊！ 起得/到得比D1还早Orz... 听说这一天要入场1w7的选手Orz. 早上所有生哥这里的志愿者来了一发大合影... 和师弟+董跃一起换到了刷身份证的岗位, 真·坐了一天... 很简单很机械很没有技术含量的岗位...竟然被一个妹子（大概是什么负责人 or 组委会的人吧）说成是很困难很有技术含量很需要学习的工作？？？还把虚拟机称为“在一个电脑中打开另一个电脑”？？？因此对生哥把人调走表示非常不满, 还顺手打了一波小报告？？敝人见识短浅, 表示不解... 全程不涉及任何虚拟机操作...点点鼠标就完事...相当无聊的工作. 偶遇太原老乡王辰, 很开朗健谈的妹子（ 仅有的慰藉就是和周围志愿者谈笑风生 &amp; 偶尔会遇到外国选手, 听到了各种口音的英语（ 上午人很多, 直到中午, 几乎一刻不得闲. 下午人渐少, 晚饭后基本和第一日下午一样了, 加上晚上有事, 就带着师弟和董跃一起撤了. 晚饭后在会场闲逛, 顺手和啦啦队小姐姐合了一张影（ 临走和二位负责人合影]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>志愿</tag>
        <tag>运动</tag>
        <tag>马拉松</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018毕业季留念]]></title>
    <url>%2F2018%2F07%2F30%2F2018%E6%AF%95%E4%B8%9A%E5%AD%A3%E7%95%99%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[毕业季前后忙着夏令营和期末等各种事情, 来不及整理照片. 最近终于有空, 稍做整理. 没有进行什么排版, 都是高清大图（ 本来想用JS搞一些bling-bling的特效, 但是搞了一个小时宣告失败... 我耐心很有限[手动再见] 时间仓促, 很多朋友们没有来得及合影.. 小小的抱歉一下, 我没有忘记大家Orz. 野鸡115 第一个要讲的当然就是野鸡115, 一群野鸡的四年. 野鸡115的摆拍 展板前 是时候欣赏大家的蹲♂姿了. 骚犇以绝对优势胜出. 第一张郭犇在蜜汁抓♂胸？ 第二张我看起来非常像是闭眼了. 虽然放大会发现没有完全闭上. 第三张我和郭犇正常了, 可丁丁已经睡着了. 电子楼 大家都是信科走出来的, 当然要和电子楼来两张. 主楼和校训碑 算是师大的两个标志性建筑物. 科技楼前 散伙前的最后一张 郭犇惺忪的睡眼是此张照片的最大看点. 野鸡115与乱入的兄弟们 乱入的朱彦丞 无孔不入（ 其实最开头的一张也有他. 电子楼 主楼 乱入的小boo 里面仍然有朱神, Orz. 与117的合影 乱入117寝室合照 与泽坤+丁丁合影 事实上这是第一波合影. 感谢摄影师邱哥. 三人合影 全部都是在教九小花园拍的. 丁丁是115最胖, 石锤了. 与泽坤单独合影 容易看出, 仍然是在教九小花园. 14信科男篮黄金一代 轮到我装逼了! 四年三座奖杯, 两进总决赛. 照片比较多, 分类比较细. 单人照 抱着奖杯装逼的时刻, 四年仅此一回. 侯彦丞 贾鑫 李喆琛 王唯 王伟程 邱季端北合影 这里必须恭喜一下lzc同学C位出道. 带奖杯版本 唯神和鑫神有点gay（ 果然分开就没那么gay了. 无奖杯版本 唯神又和王队有点gay! 分开之后果然没那么gay了. 鑫神-唯神-王队! 唯神选择了和鑫神gay. 在篮球场的合影 站版本 分的比较开, 显得略有零散. 站成一团果然紧凑多了. 重要的是这次一点也不gay? 坐版本 有点……喜感? 大家一起抬头看狂, 侯老大不禁感叹: 篮筐像大海一样广阔. 大家都转过来了, 好像有一丢丢不对称? 大家忽然又转过去了? 诶, 等等我... 与师弟们的合影 这是将荣誉和使命交给师弟们（严肃点不许笑） 恭喜李家和小同学C位出道. 这个角度有点刁, 后排都被挡了一半脸. 各种旧相识 16年同校的妹子 小学 + 初中 + 高中 + 大学 = 16年同校. Orz. 可惜研究生不能继续同校了_(:з」∠)_ 第一张很正常对吧. 但是好像难逃两张照片必有一张表情蠢的魔咒? 师大唯一高中同班同学 这个身高在我们寝室也是准前三水平 —— 大概就是吓坏我室友的水平. 感谢路人赠送的蜜汁气球. 我这个表情好像有点蠢. 小学课外班相识的鸡哥 按次序应当是师大第二个和我认识的人. 妹子也是高中同学Orz （同志, 你听说过学霸情侣么? ） &quot;乒乓球师兄&quot; 在师兄离校前夕和丁丁约到了师兄打球, 幸运地碰到了屈老师. Orz. 师兄的身高是我和丁丁的等差中项. 希望我像屈老师这个年龄也能身体这么好Orz. 牛b的想爷 想爷太强了, 只有Orz. 一起打铁的兄弟 四年前一起打铁, 四年后一起合影. Orz一下优秀的前队友们.]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>毕业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[保研二三事]]></title>
    <url>%2F2018%2F07%2F28%2F%E4%BF%9D%E7%A0%94%E5%A4%8F%E4%BB%A4%E8%90%A5%E4%BA%8C%E4%B8%89%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[只是随便写写3月份以来的各种经历. 按时间顺序是北大数科, 软件所, 北大信科. 第一站：北大数科 只是大概谈一下过程吧. 接到通知 按照飞机童鞋的说法, 考试时间应在4月10日前后, 但实际上的考试时间是在3.31, 略有意外. 经查, 去年的考试时间好像是4.8. 通知链接: 直博生摸底考试通知 初审及考试 初审 3.23前后接到初审通过的短信, 北大的考试在师大设有考点. 在北大官网也出了通知: 直博生摸底考试初审结果通知 初审要求感觉非常松, 有广撒网的意思. 考试 考试时间是一上午, 北大派老师来监考, 之后会介绍北大的大概情况. 3.31 正式考试, 满分200分, 数分代数几何各占100, 70, 30. 我几何学的非常差, 尽管几何题看起来不是很难, 我仍然没有做出来. 并且对题目没有印象了. 数分题目思路清奇, 当然题目也很清奇... 将一个五元店视作一个超市物品到 \(\mathbb{R}\) 的函数, 该函数是否可微? 构造一个夹在 \(|x|\) 与 \(|x|+1\) 之间的严格下凸函数. 并证明. 好像有一个类似函数方程/微分方程的东西, 记不起来了. 题目不能全部记起Orz. 代数题目总共有三道, 其中有30分很简单. 30分超级简单的题目, 是一些求子空间交并和维数的题目, 其实就是矩阵瞎搞搞. 一个分块矩阵的题目, 很好玩, 可是不会做Orz. 还有一个记不得了. 结果 考完感觉一般般, 通过概率应该不大, 但还是和之前联系的xbc老师见了一面. 夏老师做的是符号计算, 具体来说是可满足性问题SAT/SMT. 夏老师最后表示我的背景适合学习他的方向, 若此次考试未能通过, 9月份可以继续联系. 我仔细了解了SAT/SMT问题以及夏老师所提及的Z3求解工具, 其实是很有意思的问题, 但是考试未能通过, 我也不可能把未来押到9月份, 故没有继续联系. 考试结果应该是一个月内就除了, 我只考了60+, 未能通过Orz. 太菜了. 当然就没有后续了. 非常感谢复习期间飞机童鞋(张骏达)给我的一些帮助. 非常感谢xbc老师给我等菜鸡一个机会. 其实在北大信科夏令营之后仍然联系过, 在此不多讨论. 自此开始联系其他老师, 主要是yms老师和cyz老师. 后续的其他尝试 按照时间顺序, 是cyz老师-&gt;yms老师. 我联系老师主要是看方向, 能看懂的话也可以找一篇论文看? 时间仓促, 我没怎么看懂二位的论文... 要想清楚找老师时要说些什么, 邮件和简历里面捡好听的写. 可以写专业课平均分90+, 但是公选课得61分什么的别写. 要有自信, 老师看不上自己的话别气馁( cyz老师：社会计算 曹老师以前是师大数科的博士, 聊起来气氛大概也比较轻松愉快. 和老师聊天的内容不外乎几条: 个人情况, 无须多讲. 老师情况, 也无须多讲. 方向细节, 曹老师有几个方向, 其中我兴趣高一点的是社会计算. 后续操作, 在曹老师的建议下, 开始参加曹老师的讨论班. yms老师：量子计算 我最初联系yms老师是在清华网站上找的, 应老师回信中表示欢迎到软件所的办公室聊一聊. 最初以为应老师仍然在做逻辑等方向, 但应老师表示现在只做量子计算. 应老师本人非常随和, 我聊得还挺愉快的? (就是不知道应老师愉快不愉快Orz毕竟我太菜). 最后应老师表示虽然你成绩差, 但是你这个背景还算合适, 并且我也不是非常看重排名的老师, 所以你可以试试. 最后给了我两本书看. 接下来一段时间没有太多联系, 主要是在看应老师的书. 最初看 Nielsen 的书, 结果有点看不进去, 可能是废话有点多. 之后开始读应老师自己写的 Foundations... 一书, 比较精炼, 有数学教材的味道. 从此就开始读这本书. 对量子计算有一个大概了解后, 再次与应老师联系, 应老师表示做做习题发给他看. 大概做了第二章的大部分习题之后, 到了夏令营报名时间. 再次见到应老师就是夏令营了. 第二站：科学院软件所 按时间顺序, 这是我的第一个夏令营. 准备材料 根据在官网上挂出的通知, 需要准备如下材料: 夏令营申请表, 须签字; 成绩单 + 排名证明; 这个吐槽一下, 学院开的貌似是所有成绩都算的那个排名. 英语水平证明材料; 四六级/TOEFL/IELTS/GRE 等. 论文/获奖证书等; 社会工作奖这样没有说服力的东西可以不要. 推免申请表, 须签字; 同时须在其申请系统中报名, 详见具体通知. 其他几点: 材料不需要寄送, 只需要在开营的时候带着就可以了. 成绩单在主楼可以打印. 需要盖章的地方找学院盖章即可, 我不记得软件所有没有要盖章的地方了. 面试? 笔试? 只有一道题的考核. 夏令营一共五天, 具体安排如下: D1: 白天报到, 晚上开营+班会. 班会按照姓氏拼音分组, 与师兄师姐交流夏令营相关的问题, 时长大约2h. D2: 一个很长的报告+整整一下午的方向介绍, 晚上有鸟巢游览, 没有去. D3: 上午仍然是实验室方向介绍, 下午组织考核. 中午吃完饭直接去找应老师, 下午三点就结束了. 也不知道应老师感觉如何. D4: 按照安排应是一天考试, 但国重全看老师, 应老师表示不用过来. 自我介绍的slides其实白做了哈哈. D5: 体检+退卡. 中午和郭犇吃饭, 偶遇应老师, 应老师给一篇文章读. 在开营的前一两天, 国重的xmj老师电话联系我, 当时在图书馆的我有点emmm 受宠若惊. 聊了一下方向, 表示了招收我的意向. 夏老师做的也是理论计算机, 似乎是复杂性理论和一些组合相关的东西. 曾经也是我非常想学的东西Orz. 夏老师非常热情, 问我是否联系过老师之类的问题, 我表示联系了yms老师, 场面一度有点尴尬... 我肥肠感谢夏老师的欣赏Orz. 了解了一下夏老师的研究, 非常佩服夏老师的学术水平. 简单谈一下考核的事情: 整体的考核流程应该是 D3下午笔试/机试 + D4全天继续考核, 包括面试. 国重的考核全听老师的意思, 比方说yms老师只考了我一个题目, 大概2-3h就结束了. D4我完全不用去, 自我介绍slides完全白做了. 好像应老师在与不在完全不是两种考核方式... 听说去年是四个数学题+一个算法题, 主要包括代数数分和概率论. 还有包括英文自我介绍在内的N对1面试. 今年应老师亲自面试我, 出了一个拓扑题目(敲黑板划重点, 拓扑! 我也很意外.) 证明Kuratowski十四集定理, 并在 \(\mathbb{E}^1\) 中构造一个能生成14个集合的例子. 这是一个很有意思的题目, 据说在凯莱《一般拓扑学》中有此题目, 我没有读过该书. 考核之后应老师给我发了一封邮件, 然而我没有及时查看Orz... 最后一日在软件所用卡里剩下的钱请郭犇在软件所吃饭, 吃饭时偶遇应老师, 向我提及了邮件的事情, 表示让我发成绩单, 并且读一读论文, 有空时给他讲. 然而因为16-18日就是北大夏令营, 故论文只读了一小部分, 很惭愧... 夏令营期间去自动化所找郭犇蹭饭, 偶然抓拍到nb的郭犇Orz. 话不多说, 先Orz为敬. 关于结果 听说, 除国重外的实验室, 不会立刻知道结果. 国重应该全看老师, 但我最终没有全部完成yms老师的考核流程, 所以不太清楚. 软件所研究生部会给国重老师一个提供自己优秀营员名单的截止日期, 国重的老师须在截止日期之前提交自己的优秀营员名单. 软件所有一个人性化的双向选择机制, 优秀营员公布后不会直接分派名额. 应充分考虑和尝试后, 再决定是否最终来软件所. 故软件所会给优秀营员长约一个月的缓冲时间, 来尝试其他夏令营 &amp; 做最终决定. 非常感谢yms老师给我的机会以及xmj老师对我的赏识, 虽然我最后浪费掉了这个机会Orz. 希望自己有朝一日能成为yms老师这样的大家. 非常感谢应老师的学生方望老哥, 非常感谢. 非常感谢. 在我读应老师的书时给予了我非常大量, 真的是非常大量的帮助. 在下感激不尽. 同时也非常感谢国重的李页霆师兄在夏令营期间的照顾. 非常感谢. 第三站：北大信科 按时间顺序, 这是我的最后一个夏令营. 当然 总共就俩. 准备材料 + 等待初审 北大在4月底挂出了夏令营的通知, 原定6.30出入营名单, 但种种原因导致推迟到了7.5前后. (附: 北大信科参营通知) 主要谈谈申请流程. 首先是在网上填写申请材料. 按照通知, 还应准备如下材料: 申请表, 应该是要签字盖章; 个人陈述, 应该也要签字; 推荐信, 博士需要找三个副教授以上的老师签推荐信, 我分别找了冯速, 何青, 以及李俊峰老师(此处按年龄排序哈哈哈), 需要骑缝处签字; 成绩单 + 排名证明; 英语水平证明材料; 四六级/TOEFL/IELTS/GRE 等. 论文/获奖证书等. 社会工作奖这样没有说服力的东西可以不要. 所有材料需在指定日期前自己送/邮寄至北大. 机试 + 面试 夏令营时间是7.16-7.18, 活动大致安排如下: D1: 上午报到+下午讲座, 实验室方向介绍. 晚上机试热身赛, 各种IDE非常齐全, OpenJudge环境也相当不错. D2: 上午讲座+下午座谈会. 上午讲座翘掉了, 座谈会就是和老师聊天. 理论和软工在一起, 满屋子全是软工. 晚上机试, 打得非常崩, 前几天敲了很多题但手还是很生&amp;复习方向有误... D3: 按照安排上午8.30开始面试, 事实上理论组下午1.30开始. 和信安+图形学一起, 三个方向加起来才十个人... 面试发挥还凑合, 题目大都答得上来, 但是似乎老师们觉得我成绩一般... 虽然好像确实如此... 但我从不质疑自己的能力, 尽管机试打得非常崩. 晚些时候, 大概吃晚饭时, 最终得到了曹老师的口头承诺, 准备参加曹老师联系的暑期课程. 北大的活动安排十分紧凑. 这里还是主要说说考核. 机试热身赛据说是去年的题目, 不算难吧.. 随便写了写. 主要是测环境嘛. OpenJudge环境很好, 比poj.org强百倍. 支持 #include &lt;bits/stdc++.h&gt;; 支持 C++11; 没试过, 应该也支持 rope 吧? 本地编译器非常齐全. 按照习惯 我仍然用了 Sublime+命令行. 但是命令行好像有时会有一种奇怪的问题, 连接不上输入的接口. Code::Blocks, Dec-C++ 好像都有. 正式赛用的是codeblocks. 总之环境很好, 各种环境不背锅. 完全是自己太菜. 正式赛题目我觉得选的一般, 区分度不太好. 长时间不摸键盘, 两个水题半个多小时才过, 并且还挂了几次. 一道线段树/树状数组求逆序, 按理来说是裸题, 可是怎么也写不上来... 完全没想过会考这种东西??? 打比赛的时候哥也是经常写线段树的人, 现在太菜了Orz 一道带权并查集, GGGGGGG. 复习的时候完全没想过会考带权的??? 以上四个是中文题... 本菜鸡就这样, 中文题卡全场... 英文题几乎都没有细读, 看出来好像有一个搜索, 然而没怎么搞... 赛前主要是在补动态规划的内容... 没想到中文题一个也没有??? 太难过了. 复习方向完全偏离, 很难受. 打得实在太崩, 细节不想多谈. 最后谈一下面试: 一般是自己所报方向的老师主面, 我是比较幸运, 是曹老师主面. 不清楚自我介绍环节是否必须, 反正我没有自我介绍.. 开头是念一段英文的论文, 并翻译. 文段不是很长, 生词也不会多, 就是典型的论文. 然后就聊一些专业课的内容. 之后是学习的一些情况, 在此期间被一些老师嫌弃成绩差Orz. 其实是很多公共课成绩差( 最后一个老师问了一个算法题, 比较简单. 其实面试略有尴尬的原因, 就是机试打得太菜. 如果机试多过题, 面试会非常有底气. 最终算是涉险过关. 开始参加xlr老师的暑期课程. 非常巧, xlr老师和cyz老师以前都是yms老师的学生. 关于结果 今年出结果非常快, 面试当晚就有很多人得到了结果. 如果提前联系过老师, 可以直接询问. 官网挂通知是夏令营结束后的第二天 (周三面试完毕, 周五晚上挂通知). 由于今年硕士名额大幅减少, 很多方向竞争非常激烈. 两波夏令营期间蹭了几顿饭, 感谢郭犇某天中午的收留. 非常感谢. 上课期间也蹭了几顿饭, 感谢曹老师的学生王海滨老哥以及郭晓熙老哥. 同样非常感谢. 也要感谢冯速, 何青, 李俊峰三位老师给我签推荐信. 当然也要感谢曹老师和夏老师. 课程非常有趣, 收获良多. 夏令营事后 北大官网出优秀营员名单后, 自然是与xbc老师, yms老师, 以及xmj老师发邮件联系, 告知三位老师自己大致定了北大信科的事情. 三位老师都很友好, 我非常感激三位老师的认可. 其实加上曹老师, 四位老师的方向我都很喜欢, 但已经定了曹老师这里, 不可得兼. 当然, 更要感谢曹老师的认可了Orz... 希望自己能真正做出自己的成果. 尾声 2018.9.28 最终在学信网上填写了个人信息并进行了报名和确认. 保研之路终于算是走完了.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>数学</tag>
        <tag>计算机</tag>
        <tag>北大</tag>
        <tag>软件所</tag>
        <tag>保研</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点估计——最大似然估计、最大后验概率估计和贝叶斯估计]]></title>
    <url>%2F2018%2F07%2F26%2F%E7%82%B9%E4%BC%B0%E8%AE%A1%E2%80%94%E2%80%94%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1%E3%80%81%E6%9C%80%E5%A4%A7%E5%90%8E%E9%AA%8C%E4%BC%B0%E8%AE%A1%E5%92%8C%E8%B4%9D%E5%8F%B6%E6%96%AF%E4%BC%B0%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[在北大听xlr老师的《经济与计算》课程时有一个小问题没有搞明白, 课后花了一些时间, 算是复习了之前数理统计学的MLE, 顺便研究了一下MAP和Bayes估计. 一枚硬币，掷14次，有10次正面向上. 请估计接下来两次都出现正面向上的概率. (如下图所示) 简短分析 一些显而易见的信息： 参数: 题目中只有一个参数, 那就是单次实验中正面向上的概率 \(\theta\), 这个 \(\theta\) 实际上是由硬币本身决定的. 参数空间: 显然 \(\Theta=[0,1]\). 样本空间: 显然 \(n\) 次试验的样本空间为 \(\{H,T\}^n\), \(H\) for head, \(T\) for tail. 题目所需要估计的值并不是 \(\theta\) 的值, 而是 \(\theta^2\) 的值. 请注意 \(\hat{\theta}^2\) 未必会与 \(\hat{\theta^2}\) 相等. 最大似然估计 题目的做法 似然函数为: \[L(\theta)=\mathbb{P}(D|p)=\binom{14}{4}\theta^{10}(1-\theta)^4.\] 求其取最大值时 \(\theta\) 的取值: \[\theta_{MLE}=\arg\max_\theta\{L(\theta)\}=\frac{5}{7}.\] 与老师slides中的结果相吻合. 一般情形 一般情况下, 选取的样本 \(x_1,\cdots,x_n\) 都是i.i.d.样本, 于是似然函数只需要将其密度函数乘起来: \[L(x_1,\cdots,x_n|\theta)=\prod_{i=1}^nf(x_i|\theta)\] 然后求 \(\theta\), s.t. \(L(x_1,\cdots,x_n|\theta)\) 取最大即可, 一般只需解方程 \[\frac{\partial L}{\partial \theta}=0\] 有些情况下求对数似然函数 \(l(x_1,\cdots,x_n|\theta)=\ln L(x_1,\cdots,x_n|\theta)\) 的最大值计算起来更方便, 如正态分布. 维基百科上有详细讨论, 此处略去细节. 维基百科：最大似然估计 Wiki: Maximum likelihood estimation 最大后验概率估计 题目的做法 此处假设的先验分布是 \(\theta\sim U(0,1)\). 分布函数CDF: \(F(x)=x\); 密度函数PDF: \(f(x)=1\). 由Bayes公式, 可得后验概率为：\[\begin{align} \mathbb{P}(\theta|D)&amp;=\frac{\mathbb{P}(D|\theta)\mathbb{P}(\theta)}{\mathbb{P}(D)} \\ &amp;= \frac{\binom{14}{4}\theta^{10}(1-\theta)^4\cdot f(\theta)}{\int_0^1\binom{14}{4}\theta^{10}(1-\theta)^4{\rm d}F(\theta)} \\ &amp;= \frac{\theta^{10}(1-\theta)^4}{\int_0^1\theta^{10}(1-\theta)^4}. \end{align}\] 最大化这个概率, 可得MAP对 \(\theta\) 的估计值为: \[\begin{align}\theta_{MAP}&amp;=\arg\max_\theta\{\mathbb{P}(\theta|D)\}\\ &amp;=\arg\max_\theta\{\theta^{10}(1-\theta)^4\}\\ &amp;=\frac{5}{7}\end{align}.\] 实际上MAP的结果在 \(\theta\sim U(0,1)\) 时与MLE没有任何区别. 一般情形 已知先验分布, 及其CDF \(F(x)\) 和PDF \(f(x)\). 在做实验得到数据 \(D\) 后, 利用MAP估计 \(\theta\) 的值. 由Bayes公式有: \[\mathbb{P}(\theta|D)=\frac{\mathbb{P}(D|\theta)\mathbb{P}(\theta)}{\mathbb{P}(D)}\] 逐项计算等号右边各项: \(\mathbb{P}(D|\theta)\) 为: 单次实验结果为 \(H\) 的概率, 直接用概率论/组合数学/统计学知识计算即可. \(\mathbb{P}(\theta)\) 为: \(\theta\) 的先验概率, 即先验分布的PDF \(f(\theta)\). \(\mathbb{P}(D)\) 为: 样本空间中出现 \(D\) 的总概率, 等于后验概率 \(\mathbb{P}(D|\theta)\) 对 \(\theta\) 的分布积分, 即 \[\mathbb{P}(D)=\int_\theta \mathbb{P}(D|\theta)~{\rm d}F(\theta)\] 简单整理一下, 可得: \[\mathbb{P}(\theta|D)=\frac{\mathbb{P}(D|\theta)f(\theta)}{\int_\theta \mathbb{P}(D|\theta)~{\rm d}F(\theta)}\] 事实上, \(\theta\) 对于 \(D\) 的后验分布其实就是 \(\theta\) 对 \(D\) 的条件分布. 得到上式之后, 求使得该式最大的 \(\theta\) 即可. 由于分母是一个常数, 故: \[\theta_{MAP}=\arg\max_\theta\{\mathbb{P}(D|\theta)f(\theta)\}.\] 容易看出, 当 \(\theta\sim U(0,1)\) 时, 因 \(f(\theta)=1\) 有 \(\theta_{MAP}=\theta_{MLE}\). 但一般情况下二者并不相等. 贝叶斯估计 题目的做法 此处假设的先验分布是 \(\theta\sim U(0,1)\). 分布函数CDF: \(F(x)=x\); 密度函数PDF: \(f(x)=1\). 由Bayes公式, 可得后验概率为：\[\begin{align} \mathbb{P}(\theta|D)&amp;=\frac{\mathbb{P}(D|\theta)\mathbb{P}(\theta)}{\mathbb{P}(D)} \\ &amp;= \frac{\binom{14}{4}\theta^{10}(1-\theta)^4\cdot f(\theta)}{\int_0^1\binom{14}{4}\theta^{10}(1-\theta)^4{\rm d}F(\theta)} \\ &amp;= \frac{\theta^{10}(1-\theta)^4}{\int_0^1\theta^{10}(1-\theta)^4}. \end{align}\] \(\theta\) 的Bayes估计值即为后验概率的期望: \[\begin{align} \hat{\theta}=\mathbb{E}(\theta|D)&amp;= \int_0^1\theta~\mathbb{P}(\theta|D){\rm d}\theta \\ &amp;= \int_0^1\frac{\theta^{11}(1-\theta)^4{\rm d}\theta}{\int_0^1\theta^{10}(1-\theta)^4}=\frac{11}{16}. \end{align}\] 题目中要求估计两次正面向上, 就是要估计 \(\theta^2\): \[\begin{align} \hat{\theta^2}=\mathbb{E}(\theta|D)&amp;= \int_0^1\theta^2~\mathbb{P}(\theta|D){\rm d}\theta \\ &amp;= \int_0^1\frac{\theta^{13}(1-\theta)^4{\rm d}\theta}{\int_0^1\theta^{10}(1-\theta)^4} \\ &amp;= \frac{33}{68}\approx 0.485. \end{align}\] 这个答案恰好和老师的slides中给出的答案相符. 同时也作为一个例子说明了 \(\hat{\theta^2}\neq\hat{\theta}^2\). 一般情形 已知先验分布, 及其CDF \(F(x)\) 和PDF \(f(x)\). 在做实验得到数据 \(D\) 后, 利用Bayes估计来估计 \(\theta\) 的值. Bayes估计的估计值实际上是参数 \(\theta\) 关于试验数据 \(D\) 的条件期望: \[\hat{\theta}=\mathbb{E}(\theta|D)\] 条件分布的密度函数与MAP中得到的相同: \[\mathbb{P}(\theta|D)=\frac{\mathbb{P}(D|\theta)f(\theta)}{\int_\theta \mathbb{P}(D|\theta)~{\rm d}F(\theta)}\] 得到上式之后, 积分求期望即可. 即: \[\begin{align} \hat{\theta}&amp;=\mathbb{E}(\theta|D) \\ &amp;= \int_\theta \mathbb{P}(D|\theta)\theta{\rm d}\theta \\ &amp;= \frac{\int_\theta \mathbb{P}(D|\theta)f(\theta)\theta~{\rm d}\theta}{\int_\theta \mathbb{P}(D|\theta)~{\rm d}F(\theta)}. \end{align}\]]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>北大</tag>
        <tag>概率论</tag>
        <tag>统计学</tag>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法拾遗[5]——Java大数]]></title>
    <url>%2F2018%2F07%2F17%2F%E7%AE%97%E6%B3%95%E6%8B%BE%E9%81%97-5-%E2%80%94%E2%80%94Java%E5%A4%A7%E6%95%B0%2F</url>
    <content type="text"><![CDATA[比较重要的几条是: add, subtract, multiply, divide, mod, remainder 加减乘除取模取余---注意取模中 \(b\) 必须为正! a.compareTo(b) \(a=b\) 返回 \(0\), 否则返回 \(a&gt;b\) 的值. a.toString(b) 将 \(a\) 转换为 \(b\) 进制字符串. 另外注意 Scanner 的写法: 输入接口: Scanner cin = new Scanner(System.in); EOF写法: while(cin.hasNext()) {} 输入:BigInteger a = cin.nextBigInteger(); 以及变量的声明(注意 new): 单个变量: BigInteger a = new BigInteger(&quot;0&quot;); 声明数组: BigInteger a[] = new BigInteger[size]; 静态方法: BigInteger a = BigInteger.valueOf(x); 完整版本如下: 来源: https://blog.csdn.net/qq644262163/article/details/53116713 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189import java.util.*; import java.math.*; public class Main &#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); // 读到EOF while(cin.hasNext())&#123;&#125; // 读入BigInteger BigInteger a = cin.nextBigInteger(); // 赋值 // 将十进制字符串转化为BigInteger // public BigInteger(String val) BigInteger a = new BigInteger("3"); // 将radix进制的字符串转化为BigInteger // public BigInteger(String val, int radix) BigInteger a = new BigInteger("3", 2); // 将整数赋给BigInteger BigInteger a = BigInteger.valueOf(100); // 常量 a = BigInteger.ZERO; a = BigInteger.ONE; a = BigInteger.TEN; // 值等于val的值 // public static BigInteger valueOf(long val) BigInteger.valueOf(10); a.add(b); a.subtract(b); a.multiply(b); a.divide(b); // 取模a%b b需大于0 5mod3=2 -5mod3=1 a.mod(b); // 求余 5rem3=2 -5rem3=-2 5rem-3=2 -5rem-3=-2 // public BigInteger remainder(BigInteger val) a.remainder(b); // [0]为a/b [1]为a%b // public BigInteger[] divideAndRemainder(BigInteger val) a.divideAndRemainder(b); // a==b? // public boolean equals(Object x) a.equals(b); // a的正负 正为1 0为0 负为-1 // public int signum() a.signum(); // 绝对值|a| // public BigInteger abs() a.abs(); // 比较a&gt;b返回1 a==b返回0 a&lt;b返回-1 // public BigInteger andNot(BigInteger val) a.compareTo(b); // 相反数-a // public BigInteger negate() a.negate(); // max(a,b) // public BigInteger max(BigInteger val) a.max(b); // min(a,b) // public BigInteger min(BigInteger val) a.min(b); // 乘方 // public BigInteger pow(int exponent) a.pow(3); // a模b的逆元 // public BigInteger modInverse(BigInteger m) a.modInverse(b); // 乘方取模 a^b%c // public BigInteger modPow(BigInteger exponent,BigInteger m) a.modPow(b, c); // 位运算 // ~a // public BigInteger not() a.not(); // a^b // public BigInteger xor(BigInteger val) a.xor(b); // a|b // public BigInteger or(BigInteger val) a.or(b); // a&amp;b // public BigInteger divide(BigInteger val) a.and(b); // a左移n位 (a &lt;&lt; n) // public BigInteger shiftLeft(int n) a.shiftLeft(10); // a右移n位 (a &gt;&gt; n) // public BigInteger shiftRight(int n) a.shiftRight(10); // a&amp;(~b) // public BigInteger andNot(BigInteger val) a.andNot(b); // 二进制形式中把第n位二进制设为0 (a &amp; ~(1&lt;&lt;n)) // public BigInteger clearBit(int n) a.clearBit(10); // 二进制形式中把第n位二进制设为1 (a | (1&lt;&lt;n)) // public BigInteger setBit(int n) a.setBit(10); // 二进制形式中第n位二进制是否为1 (a &amp; (1&lt;&lt;n)) != 0) // public boolean testBit(int n) a.testBit(10); // 二进制形式中把第n位二进制翻转 (a ^ (1&lt;&lt;n)) // public BigInteger flipBit(int n) a.flipBit(10); // 二进制形式中最低位1后面0的个数 (a == 0? -1 : log2(a &amp; -a)) // public int getLowestSetBit() a.getLowestSetBit(); // 二进制形式中与符号不同的位的数量 7为3 -7为2 // public int bitCount() a.bitCount(); // 二进制形式中不包括符号位的长度 // public int bitLength() a.bitLength(); // a和b的最大公约数 // public BigInteger gcd(BigInteger val) a.gcd(b); // a可能为素数返回true a一定为合数返回false 素数可能性大于(1-1/(2的certainty次方)) // public boolean isProbablePrime(int certainty) a.isProbablePrime(10); // 大于a的可能为素数的第一个整数。 // public BigInteger nextProbablePrime() a.nextProbablePrime(); // a的哈希码 // public int hashCode() a.hashCode(); // a的二进制补码形式 // public byte[] toByteArray() a.toByteArray(); // a的十进制字符串形式 // public String toString() a.toString(); // a的radix进制字符串形式 // public String toString(int radix) a.toString(2); // 将a转换为int // public int intValue() a.intValue(); // 将a转换为long // public long longValue() a.longValue(); // 将a转换为float // public float floatValue() a.floatValue(); // 将a转换为double // public double doubleValue() a.doubleValue(); // JAVA 1.8 a.byteValueExact(); a.intValueExact(); a.longValueExact(); a.shortValueExact(); // 从类 java.lang.Number 继承的方法 // 将a转换为short // public short shortValue() a.shortValue(); // 将a转换为byte // public byte byteValue() a.byteValue(); // 从类 java.lang.Object 继承的方法 // public final Class&lt;?&gt; getClass() a.getClass(); // public final void notify() a.notify(); // public final void notifyAll() a.notifyAll(); try &#123; // public final void wait() throws InterruptedException a.wait(); // public final void wait(long timeout) throws InterruptedException a.wait(10); // public final void wait(long timeout, int nanos) throws InterruptedException a.wait(10, 10); &#125; catch (Exception exception) &#123; &#125; &#125; &#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>保研复习</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法拾遗[4]——STL用法]]></title>
    <url>%2F2018%2F07%2F17%2F%E7%AE%97%E6%B3%95%E6%8B%BE%E9%81%97-4-%E2%80%94%E2%80%94STL%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[主要bb一下优先队列和字符串吧. 哦还有 bitset. 优先队列 定义很容易: priority_queue&lt;int&gt; pq; 内部是一个堆. 基本操作 pq.top() 取堆顶元素; (没有 front() 方法!) pq.push(x) 插入; pq.pop() 删除(删除堆顶); pq.empty() 判断是否为空. 自定义优先级 最大堆: priority_queue&lt;int&gt; pq; 最小堆: priority_queue&lt; int, vector&lt;int&gt;, greater&lt;int&gt; &gt; pq; 事实上还有自定义优先级 cmp 的方法(优先级最大的最先出队): 12345678struct cmp&#123; bool operator() (const int a, const int b) const &#123; // a优先级较小时返回true. return a &gt; b; &#125;&#125;;priority_queue&lt;int, vector&lt;int&gt;, cmp&gt; pq; // 此时也是最小堆 例题 百练 4078: http://bailian.openjudge.cn/practice/4078/ 字符串 定义更容易: string s; 基本操作 s.size() 串长度(下标从0 开始)； s.substr(a, n) 构造子串, a为第一个字符的下标, n为子串字符长度; s'find(it1, it2, x) 在指针 it1 和 it2 中间查找字符 x; (s.find(x) 为整个 s 中查找 x) s.erase(a) 删除元素, a貌似是指针, 可以和 find 合用去除指定字符, 如 s.erase(std::find(s.begin(), s.end(), ' ')); 去掉所有空格; s.empty() 判断是否为空; 支持 push_back 和 pop_back; 支持 +, = 和 == 运算. 遍历操作 可以用 auto it = s.begin(); it != s.end(); it++ 遍历; 但我一般都用 int i = 0; i &lt; s.size(); i++ 遍历. 和数字的转换 字符串转数字 stoi, stol, stoll: 字符串转整数; stof, stod, stold: 字符串转浮点数; 数字转字符串 to_string 直接转成 std::string. 位向量 定义: bitset&lt;length&gt; b(value); 基本操作 支持位运算 &amp;, ^, &lt;&lt;, &gt;&gt;等; to_string() 转化为字符串; to_ulong(), to_ullong() 转化为无符号整数; flip(i) 第i位取反, 下标从0开始. flip() 全部按位取反.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>保研复习</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法拾遗[3]——图论算法]]></title>
    <url>%2F2018%2F07%2F16%2F%E7%AE%97%E6%B3%95%E6%8B%BE%E9%81%97-3-%E2%80%94%E2%80%94%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[夏令营复习算法, 感到自己对之前学过的算法略有生疏, 写篇流水账, 权当复习. 并查集 Dijkstra 算法 Floyd 算法 Kruskal 算法 并查集 处理连通关系的一种手段. 查询所属连通分支 123456789// fa[i] 表示i 所属的连通分支的代表元// rnk[j] 表示j 号连通分支的结点个数, 注意这里的j 必须是所取的代表元(根结点)// 使用前注意fa[] 的初始化, rnk[] 初始为1.int fa[maxn], rnk[maxn];int Find(int x)&#123; if (fa[x] == -1) return x; else return fa[x] = Find(fa[x]);&#125; 合并操作 12345678910void Union(int x, int y)&#123; int t1 = Find(x); int t2 = Find(y); if(t1 != t2) &#123; fa[t1] = t2; rnk[t2] += rnk[t1]; &#125;&#125; Dijkstra 算法 单源最短路, 适用于权值非负的图. 实现代码 123456789101112131415161718192021222324252627282930313233343536// g 需要初始化, 下标从0 开始.const int maxn = 1005;const int inf = 0x3f3f3f3f;int pre[maxn], d[maxn];int g[maxn][maxn];bool vis[maxn];void Dijkstra(int g[][maxn], int d[], int n, int s)&#123; for (int i = 0; i &lt; n; i++) &#123; pre[i] = -1; vis[i] = false; d[i] = inf; &#125; d[s] = 0; for (int j = 0; j &lt; n; j++) &#123; int k = -1, Min = inf; for (int i = 0; i &lt; n; i++) if (!vis[i] &amp;&amp; d[i] &lt; Min) &#123; Min = d[i]; k = i; &#125; if (k == -1) break; vis[k] = true; for (int i = 0; i &lt; n; i++) if (!vis[i] &amp;&amp; d[k] + g[k][i] &lt; d[i]) &#123; d[i] = d[k] + g[k][i]; pre[i] = k; &#125; &#125;&#125; HDU 2544: 最短路 Problem Description 在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？ Input 输入包括多组数据。每组数据第一行是两个整数N、M（N&lt;=100，M&lt;=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1&lt;=A,B&lt;=N,1&lt;=C&lt;=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。 输入保证至少存在1条商店到赛场的路线。 Output 对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间 Sample Input 2 1 1 2 3 3 3 1 2 5 2 3 5 3 1 2 0 0 Sample Output 3 2 大致思路 注意题目中下标从 1 开始. AC代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1005;const int inf = 0x3f3f3f3f;int pre[maxn], d[maxn];int g[maxn][maxn];bool vis[maxn];void Dijkstra(int g[][maxn], int d[], int n, int s)&#123; for (int i = 0; i &lt; n; i++) &#123; pre[i] = -1; vis[i] = false; d[i] = inf; &#125; d[s] = 0; for (int j = 0; j &lt; n; j++) &#123; int k = -1, Min = inf; for (int i = 0; i &lt; n; i++) if (!vis[i] &amp;&amp; d[i] &lt; Min) &#123; Min = d[i]; k = i; &#125; if (k == -1) break; vis[k] = true; for (int i = 0; i &lt; n; i++) if (!vis[i] &amp;&amp; d[k] + g[k][i] &lt; d[i]) &#123; d[i] = d[k] + g[k][i]; pre[i] = k; &#125; &#125;&#125;int main()&#123; int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; if (n == 0 &amp;&amp; m == 0) break; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) g[i][j] = (i == j) ? 0 : inf; while (m--) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g[u - 1][v - 1] = g[v - 1][u - 1] = w; &#125; Dijkstra(g, d, n, 0); cout &lt;&lt; d[n - 1] &lt;&lt; endl; &#125; return 0;&#125; Floyd 算法 我所知道的唯一的全源最短路. 复杂度略高, 约 \(O(n^3)\). 可以视为动态规划. 简单好写. 实现代码 12345678910111213// 初始化仍然是i == j时d[i][j]为0, 其余为inf.// 注意下标从0 开始, 以及k-&gt; i-&gt; j 的顺序.// 想压行可以把最后的if 写成min.int d[maxn][maxn];void floyd(int n)&#123; for (int k = 0; k &lt; n; k++) // 一定要注意第一层是k for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) if (d[i][k] + d[k][j] &lt; d[i][j]) d[i][j] = d[i][k] + d[k][j];&#125; HDU 2544: 最短路 Problem Description 在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？ Input 输入包括多组数据。每组数据第一行是两个整数N、M（N&lt;=100，M&lt;=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1&lt;=A,B&lt;=N,1&lt;=C&lt;=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。 输入保证至少存在1条商店到赛场的路线。 Output 对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间 Sample Input 2 1 1 2 3 3 3 1 2 5 2 3 5 3 1 2 0 0 Sample Output 3 2 大致思路 还是这道裸题...除了注意题目中下标从 1 开始我都不知道还有什么可说的. AC代码 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1005;const int inf = 0x3f3f3f3f;int d[maxn][maxn];void floyd(int n)&#123; for (int k = 0; k &lt; n; k++) for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) if (d[i][k] + d[k][j] &lt; d[i][j]) d[i][j] = d[i][k] + d[k][j];&#125;int main()&#123; int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; if (n == 0 &amp;&amp; m == 0) break; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) if (i == j) d[i][j] = 0; else d[i][j] = inf; while (m--) &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; d[a - 1][b - 1] = d[b - 1][a - 1] = c; &#125; floyd(n); cout &lt;&lt; d[0][n - 1] &lt;&lt; endl; &#125; return 0;&#125; Kruskal 算法 所有边排序, 逐条加边, 用并查集判连通, 求最小生成树. 实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 并查集初始化为-1, 不需要在main函数里单独初始化// tol 需要在main里单独初始化为0const int maxn = 1005;struct Edge&#123; int u, v, w; Edge()&#123;&#125; Edge(int a, int b, int c): u(a), v(b), w(c)&#123;&#125;&#125; e[maxn];int tol; // 存总边数void addedge(int u, int v, int w)&#123; e[tol++] = Edge(u, v, w);&#125;bool cmp(Edge a, Edge b) // 按权值排序&#123; return a.w &lt; b.w;&#125;int fa[maxn]; // 并查集int Find(int x)&#123; if(fa[x] == -1) return x; else return fa[x] = Find(fa[x]);&#125;int Kruskal(int n)&#123; memset(fa, -1, sizeof(fa)); sort(e, e + tol, cmp); int cnt(0), res(0); for (int i = 0; i &lt; tol; i++) &#123; int u = e[i].u; int v = e[i].v; int w = e[i].w; int t1 = Find(u); int t2 = Find(v); if (t1 != t2) &#123; fa[t1] = t2; res += w; cnt++; &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; // 不连通 else return res; // 连通返回最小生成树权值&#125; HDU 1863: 畅通工程 Problem Description 省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可）。经过调查评估，得到的统计表中列出了有可能建设公路的若干条道路的成本。现请你编写程序，计算出全省畅通需要的最低成本。 Input 测试输入包含若干测试用例。每个测试用例的第1行给出评估的道路条数 N、村庄数目M ( &lt; 100 )；随后的 N 行对应村庄间道路的成本，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间道路的成本（也是正整数）。为简单起见，村庄从1到M编号。当N为0时，全部输入结束，相应的结果不要输出。 Output 对每个测试用例，在1行里输出全省畅通需要的最低成本。若统计数据不足以保证畅通，则输出“?”。 Sample Input 3 3 1 2 1 1 3 2 2 3 4 1 3 2 3 2 0 100 Sample Output 3 ? 大致思路 裸题, 没什么好说的, 一定要注意 tol 的初始化. AC代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1005;struct Edge&#123; int u, v, w; Edge() &#123;&#125; Edge(int a, int b, int c): u(a), v(b), w(c) &#123;&#125;&#125; e[maxn]; // 一般情况下完全可以考虑用 vector 存边int tol;void addedge(int u, int v, int w)&#123; e[tol++] = Edge(u, v, w);&#125;bool cmp(Edge a, Edge b)&#123; return a.w &lt; b.w;&#125;int fa[maxn];int Find(int x)&#123; while (fa[x] != x) x = fa[x]; return x;&#125;int Kruskal(int n)&#123; for(int i = 0; i &lt; n; i++) // 需要注意下标是从0还是1开始 fa[i] = i; sort(e, e + tol, cmp); int cnt(0), res(0); for (int i = 0; i &lt; tol; i++) &#123; int u = e[i].u; int v = e[i].v; int w = e[i].w; int t1 = Find(u); int t2 = Find(v); if (t1 != t2) &#123; fa[t1] = t2; res += w; cnt++; &#125; if(cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; else return res;&#125;int main()&#123; int n, m; while (cin &gt;&gt; m &gt;&gt; n) &#123; if (m == 0) break; tol = 0; // 初始化!!! while (m--) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; addedge(u, v, w); &#125; int ans = Kruskal(n); if (ans == -1) printf("?\n"); else printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>计算机</tag>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>保研复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法拾遗[2]——数论算法]]></title>
    <url>%2F2018%2F07%2F15%2F%E7%AE%97%E6%B3%95%E6%8B%BE%E9%81%97-2-%E2%80%94%E2%80%94%E6%95%B0%E8%AE%BA%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[夏令营复习算法, 感到自己对之前学过的算法略有生疏, 写篇流水账, 权当复习. 素数筛法 快速幂取模 扩展欧几里得/求逆元 素数筛法 一种用已知的小素数 \(p\) 来筛掉更大的合数, 最终留下素数的算法. 实践复杂度 \(O(n\log\log n)\). 实现代码 1: 打标记 1234567891011121314151617const int maxn = 1e6 + 5;bool notprime[maxn];void init()&#123; memset(notprime, false, sizeof(notprime)); notprime[0] = notprime[1] = true; for(int i = 2; i &lt; maxn; i++) &#123; if(!notprime[i]) &#123; if(i &gt; maxn / i) continue; // 防止i * i 溢出 for(int j = i * i; j &lt; maxn; j += i) notprime[j] = true; &#125; &#125;&#125; 实现代码 2: 直接存素数 12345678910111213141516const int maxn = 1e6 + 5;int prime[maxn];void getPrime()&#123; memset(prime, 0, sizeof(prime)); for(int i = 2; i &lt; maxn; i++) &#123; if(!prime[i]) prime[++prime[0]] = i; for(int j = 1; j &lt;= prime[0] &amp;&amp; prime[j] &lt;= maxn / i; j++) &#123; prime[prime[j] * i] = 1; if(i % prime[j] == 0) break; &#125; &#125;&#125; 事实上也可以先打标记, 再 for 一遍把素数拿出来. 百练 3177: 判决素数个数 总时间限制: 1000ms 内存限制: 65536kB 描述 输入两个整数X和Y，输出两者之间的素数个数（包括X和Y）。 输入 两个整数X和Y（1 &lt;= X,Y &lt;= 105）。 输出 输出一个整数，表示X，Y之间的素数个数（包括X和Y）。 样例输入 1 100 样例输出 25 大致思路 有个坑点... 题目没有保证 \(x\leqslant y\).. 所以需要 swap 一下. AC代码 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6 + 5;bool notprime[maxn];void init()&#123; memset(notprime, false, sizeof(notprime)); notprime[0] = notprime[1] = true; for(int i = 2; i &lt; maxn; i++) &#123; if(!notprime[i]) &#123; if(i &gt; maxn / i) continue; for(int j = i * i; j &lt; maxn; j += i) notprime[j] = true; &#125; &#125;&#125;int main()&#123; int x, y; init(); while(cin &gt;&gt; x &gt;&gt; y) &#123; int ans = 0; if(x &gt; y) swap(x, y); for(int i = x; i &lt;= y; i++) if(!notprime[i]) ans++; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 扩展欧几里得算法 求解 \(ax+by=d\) 中的 \(x, y\), 其中 \(\gcd(a, b)~|~d\) 才有解. 实现代码 123456789101112131415// 返回d = gcd(a, b); 和对应于等式ax + by = d 中的x, ylong long extend_gcd(long long a, long long b, long long &amp;x, long long &amp;y)&#123; if (a == 0 &amp;&amp; b == 0) return -1; // 无最大公约数 if (b == 0) &#123; x = 1; y = 0; return a; &#125; long long d = extend_gcd(b, a % b, y, x); y -= a / b * x; return d;&#125; 快速幂取模 在 \(O(\log n)\) 时间内求 \(a^n~\%m\) 的值. 实现代码 123456789101112long long pow_mod(int a, int b)&#123; long long ret = 1; while(b) &#123; if(b &amp; 1) ret = ret * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return ret;&#125; 求逆元 求 \(x\), s.t. \(ax=1~({\rm mod}~m)\). 实现代码 1: 利用扩展欧几里得 12345678910// ax = 1 (mod n)long long mod_reverse(long long a, long long n)&#123; long long x, y; long long d = extend_gcd(a, n, x, y); if (d == 1) return (x % n + n) % n; else return -1;&#125; 实现代码 2: 利用费马小定理 由于模数 \(m\) 一般为素数, 当 \((a,m)=1\) 时, 由费马小定理有: \[a^{m-1}=1~({\rm mod}~m)\Rightarrow a^{-1}=a^{m-2}.\] 1234long long inv(int a)&#123; return pow_mod(a, mod - 2);&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>计算机</tag>
        <tag>算法</tag>
        <tag>保研复习</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法拾遗[1]——动态规划]]></title>
    <url>%2F2018%2F07%2F14%2F%E7%AE%97%E6%B3%95%E6%8B%BE%E9%81%97-1-%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[夏令营复习算法, 感到自己对之前学过的算法略有生疏, 写篇流水账, 权当复习. 最长上升子序列 最长公共子序列 最大子段和与最大子矩阵 背包问题 合并石子/矩阵链乘 一些其他的题目 最长上升子序列 简单来说, 是通过讨论原序列的当前位 \(a_i\) 与子序列 \(b\) 的末尾 \(b_{len-1}\) 的大小关系进行递推/动态规划的一类问题. 具体思路暂不详述. 实现代码 给定数组 \(a\), 求 \(a\) 某一段 \(a[l, r]\) 的LIS的代码如下: 不严格的情形有两处需要修改, 请仔细查看注释. 12345678910111213141516171819// 数组int a[] 的下标从 0 ~ n-1, 函数可求解 [l, r] 闭区间的LIS长度.// a[l, r] 的LIS存储在b[0, len-1] 中. 函数返回值为其元素个数.int lis(int l, int r)&#123; memset(c, 0, sizeof(c)); int len = 0; c[0] = a[l]; for (int i = l + 1; i &lt;= r; i++) &#123; if (a[i] &gt; c[len]) // 不严格递增情形改为&gt;= c[++len] = a[i]; else &#123; // 不严格递增情形改为upper_bound() int pos = lower_bound(c, c + len, a[i]) - c; c[pos] = a[i]; &#125; &#125; return len + 1; // 下标从0 开始, 故需要+1.&#125; 如需求解最长下降子序列, 一个偷懒的办法是将原数组逆序存储, 再求解其逆序的LIS. 同时也有 lower_bound(c, c + len, a[i], greater&lt;int&gt;()) 的用法, 非常方便. 百练 2945: 拦截导弹 总时间限制: 1000ms 内存限制: 65536kB 描述 某国为了防御敌国的导弹袭击，开发出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭，并观测到导弹依次飞来的高度，请计算这套系统最多能拦截多少导弹。拦截来袭导弹时，必须按来袭导弹袭击的时间顺序，不允许先拦截后面的导弹，再拦截前面的导弹。 输入 输入有两行， 第一行，输入雷达捕捉到的敌国导弹的数量k（k&lt;=25）， 第二行，输入k个正整数，表示k枚导弹的高度，按来袭导弹的袭击时间顺序给出，以空格分隔。 输出 输出只有一行，包含一个整数，表示最多能拦截多少枚导弹。 样例输入 8 300 207 155 300 299 170 158 65 样例输出 6 思路 很裸, 直接做非严格最长下降子序列. 5min内不AC自觉面壁... AC代码 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 30;int a[maxn], b[maxn], c[maxn];int lis(int l, int r)&#123; memset(c, 0, sizeof(c)); int len = 0; c[0] = a[l]; for (int i = l + 1; i &lt;= r; i++) &#123; if (a[i] &lt;= c[len]) c[++len] = a[i]; else &#123; int pos = upper_bound(c, c + len, a[i], greater&lt;int&gt;()) - c; c[pos] = a[i]; &#125; &#125; return len + 1;&#125;int main()&#123; int n; while (cin &gt;&gt; n) &#123; for (int i = 0; i &lt; n; i++) scanf("%d", &amp;a[i]); cout &lt;&lt; lis(0, n - 1) &lt;&lt; endl; &#125; return 0;&#125; 百练 2711: 合唱队形 题目链接: http://bailian.openjudge.cn/practice/2711/ 总时间限制: 1000ms 内存限制: 65536kB 描述 N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学不交换位置就能排成合唱队形。 合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1, 2, …, K，他们的身高分别为T1, T2, …, TK，则他们的身高满足T1 &lt; T2 &lt; … &lt; Ti , Ti &gt; Ti+1 &gt; … &gt; TK (1 &lt;= i &lt;= K)。 你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。 输入 输入的第一行是一个整数N（2 &lt;= N &lt;= 100），表示同学的总数。第一行有n个整数，用空格分隔，第i个整数Ti（130 &lt;= Ti &lt;= 230）是第i位同学的身高（厘米）。 输出 输出包括一行，这一行只包含一个整数，就是最少需要几位同学出列。 样例输入 8 186 186 150 200 160 130 197 220 样例输出 4 思路 枚举递增和递减中间分叉的位置（令其位于 \(a_i\) 和 \(a_{i+1}\) 之间, 对 \(i\) 做 for 循环）, 分别对两边做正序和逆序的LIS, 长度相加取最大, 最后再用 \(n\) 减去即可. 注意一个特殊情况, 就是前半段上升的最高点可能和后半段下降的最高点数值相等, 需要特判一下, 然后总长度-1. AC代码 特意用逆序来做的下降序列, 写的有一点丑, 不想细改了. 代码应该是没问题的. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 数组a[] 存储原数据, b[] 存储a 的逆序, 用两个函数分别求LIS.#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;int n;int a[maxn], b[maxn], c[maxn];int lis(int l, int r)&#123; memset(c, 0, sizeof(c)); int len = 0; c[0] = a[l]; for (int i = l + 1; i &lt;= r; i++) &#123; if (a[i] &gt; c[len]) c[++len] = a[i]; else &#123; int pos = lower_bound(c, c + len, a[i]) - c; c[pos] = a[i]; &#125; &#125; return len + 1;&#125;int lis_reverse(int l, int r)&#123; memset(c, 0, sizeof(c)); int len = 0; c[0] = b[l]; for (int i = l + 1; i &lt;= r; i++) &#123; if (b[i] &gt; c[len]) c[++len] = b[i]; else &#123; int pos = lower_bound(c, c + len, b[i]) - c; c[pos] = b[i]; &#125; &#125; return len + 1;&#125;int main()&#123; int n; while (cin &gt;&gt; n) &#123; for (int i = 0; i &lt; n; i++) scanf("%d", &amp;a[i]); for (int i = 0; i &lt; n; i++) b[i] = a[n - 1 - i]; int ans = max(lis(0, n - 1), lis_reverse(0, n - 1)); for(int i = 1; i &lt; n - 1; i++) &#123; int x = lis(0, i); int tmpx = c[x - 1]; int y = lis_reverse(0, n - i - 2); int tmpy = c[y - 1]; if(tmpx == tmpy) ans = max(ans, x + y - 1); else ans = max(ans, x + y); &#125; printf("%d\n", n - ans); &#125; return 0;&#125; 最长公共子序列 大致算法 记串 \(a\) 和串 \(b\) 的以 \(i\) 和 \(j\) 结尾的前缀分别为 \(A_i\) 和 \(B_j\), 令 \(dp[i, j]\) 表示 \(A_i\) 与 \(B_j\) 的LCS长度, 则有: \[dp[i,j] = \begin{cases} 0 &amp; i = 0~\text{or}~ j=0 \\ dp[i-1,j-1]+1 &amp; i, j&gt;0,~a_i=b_j \\ \max\{dp[i-1, j], dp[i, j-1]\} &amp; i, j&gt;0,~a_i\neq b_j \end{cases}\] 实现代码 12345678910111213// 注意下标, 从1 开始, 输入时也要注意.// 答案为 dp[n][m].int dp[maxn][maxn];char a[maxn], b[maxn];void init(int n, int m)&#123; memset(dp, 0, sizeof(dp)); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) if(a[i] == b[j]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);&#125; POJ 1458: Common Subsequence Description A subsequence of a given sequence is the given sequence with some elements (possible none) left out. Given a sequence X = &lt; x1, x2, ..., xm &gt; another sequence Z = &lt; z1, z2, ..., zk &gt; is a subsequence of X if there exists a strictly increasing sequence &lt; i1, i2, ..., ik &gt; of indices of X such that for all j = 1,2,...,k, xij = zj. For example, Z = &lt; a, b, f, c &gt; is a subsequence of X = &lt; a, b, c, f, b, c &gt; with index sequence &lt; 1, 2, 4, 6 &gt;. Given two sequences X and Y the problem is to find the length of the maximum-length common subsequence of X and Y. Input The program input is from the std input. Each data set in the input contains two strings representing the given sequences. The sequences are separated by any number of white spaces. The input data are correct. Output For each set of data the program prints on the standard output the length of the maximum-length common subsequence from the beginning of a separate line. Sample Input abcfbc abfcab programming contest abcd mnp Sample Output 4 2 0 AC代码 一定要注意输入和下标!!! 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt; // poj不支持这个头文件using namespace std;const int maxn = 1005;int dp[maxn][maxn];char a[maxn], b[maxn];void init(int n, int m)&#123; memset(dp, 0, sizeof(dp)); // 应该没必要全都初始化 for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) if(a[i] == b[j]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);&#125;int main()&#123; while(scanf("%s%s", a + 1, b + 1) != EOF) &#123; int n = strlen(a + 1); int m = strlen(b + 1); init(n, m); printf("%d\n", dp[n][m]); &#125; return 0;&#125; 最大子段和与最大子矩阵 最大子段和 最大子段和问题：求解给定数组 \(a\) 的所有子段中, 和最大的一个. 根据问题, 显然有如下的暴力方法: 12345// 给定原数组int a[], 元素个数 n.int ans = a[0];for(int i = 0; i &lt; n; i++) for(int j = i; j &lt; n; j++) ans = max(ans, SUM(a[i]...a[j])); 考虑上求和的 \(O(n)\), 该算法的复杂度为 \(O(n^3)\). 如果优化掉求和的 \(O(n)\), 可优化为 \(O(n^2)\), 具体优化不在此赘述, 毕竟优化完了也很慢... 如使用 \(dp[i]\) 表示以第 \(i\) 位结尾的最大子段和, 则可以使问题得到极大的简化: \[dp[i]=\max(dp[i - 1] + a[i], a[i]),\] \[ans = \max\limits_{0\leqslant i\leqslant n-1}(dp[i]).\] 根据该递推式很容易就可以写出如下代码: 123456789101112// 给定原数组int a[], 元素个数 n. 下标从0 开始.// 中间变量int dp[], dp[i]表示以第i 位结尾的最大子段和int solve(int n)&#123; dp[0] = a[0]; for(int i = 1; i &lt; n; i++) dp[i] = max(dp[i - 1] + a[i], a[i]); int res = a[0]; for(int i = 0; i &lt; n; i++) res = max(res, b[i]); return res&#125; 容易得出该算法的复杂度为 \(O(n)\). 是最快的求解算法. 同时不难想到, 最大子段和还有递归的求解方法, 时间复杂度为 \(O(n\log n)\), 不再赘述. 最大子矩阵 最大子段和的求解方式可直接应用于求解最大子矩阵问题: 先将矩阵的行求和压缩: 对每行的第 \(i\) 到第 \(j\) 求和. 再对压缩后的 \(sum\) 数组做最大子段和. 变换 \(i\), \(j\), 取最大值. 求和数组 \(sum\) 的转移方式也就是上文中暴力求最大子段和中求和时间的优化, 其实相当简单: 12345678910// 给定原矩阵int a[][maxn], 行数m, 列数n. a[i][j] 表示第i 行第j 个, 下标从0 开始.// 列和数组int sum[], sum[r] 表示第r 行的状态.for(int i = 0; i &lt; n; i++) // 枚举起点&#123; for(int r = 0; r &lt; m; r++) // 初始化 sum[r] = a[r][i]; for(int j = i + 1; j &lt; n; j++) // 枚举终点 for(int r = 0; r &lt; m; r++) // 更新每一行的和 sum[r] += a[r][j];&#125; 显然我们只需要对每次处理好的 \(sum\) 数组做最大子段和, 然后取最大值. 时间复杂度应为 \(O(n^3)\). 代码如下: 1234567891011121314151617181920212223242526int solve(int m, int n)&#123; int res = a[0][0]; for(int i = 0; i &lt; n; i++) &#123; for(int r = 0; r &lt; n; r++) sum[r] = a[r][i]; dp[0] = sum[0]; for(int r = 1; r &lt; m; r++) dp[r] = max(dp[r - 1] + sum[r], sum[r]); for(int r = 0; r &lt; m; r++) res = max(res, dp[r]); for(int j = i + 1; j &lt; n; j++) &#123; for(int r = 0; r &lt; m; r++) sum[r] += a[r][j]; dp[0] = sum[0]; for(int r = 1; r &lt; m; r++) dp[i] = max(dp[i - 1] + sum[i], sum[i]); for(int r = 0; r &lt; m; r++) res = max(res, dp[r]); &#125; &#125; return res;&#125; 把最大子段和的函数封装一下可能会更好看, 我懒的搞... 百练 2766: 最大子矩阵 总时间限制: 1000ms 内存限制: 65536kB 描述 已知矩阵的大小定义为矩阵中所有元素的和。给定一个矩阵，你的任务是找到最大的非空(大小至少是1 * 1)子矩阵。 比如，如下4 * 4的矩阵 \[\begin{bmatrix} 0 &amp; -2 &amp; -7 &amp; 0 \\ 9 &amp; 2 &amp; -6 &amp; 2 \\ -4 &amp; 1 &amp; -4 &amp; 1 \\ -1 &amp; 8 &amp; 0 &amp; -2 \end{bmatrix}\] 的最大子矩阵是 \[\begin{bmatrix} 9 &amp; 2 \\ -4 &amp; 1 \\ -1 &amp; 8 \end{bmatrix}\] 这个子矩阵的大小是15。 输入 输入是一个N * N的矩阵。输入的第一行给出N (0 &lt; N &lt;= 100)。再后面的若干行中，依次（首先从左到右给出第一行的N个整数，再从左到右给出第二行的N个整数……）给出矩阵中的N2个整数，整数之间由空白字符分隔（空格或者空行）。已知矩阵中整数的范围都在[-127, 127]。 输出 输出最大子矩阵的大小。 样例输入 4 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 样例输出 15 思路 有啥好说的么...很裸. 这题机试要是过不去的话我觉得我可以去死了.. AC代码 懒, 用了 cin, cout. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;int a[maxn][maxn], dp[maxn], sum[maxn];int solve(int m, int n)&#123; int res = a[0][0]; for (int i = 0; i &lt; n; i++) &#123; for (int r = 0; r &lt; m; r++) sum[r] = a[r][i]; dp[0] = sum[0]; for (int r = 1; r &lt; m; r++) dp[r] = max(dp[r - 1] + sum[r], sum[r]); for (int r = 0; r &lt; m; r++) res = max(res, dp[r]); for (int j = i + 1; j &lt; n; j++) &#123; for (int r = 0; r &lt; m; r++) sum[r] += a[r][j]; dp[0] = sum[0]; for (int r = 1; r &lt; m; r++) dp[r] = max(dp[r - 1] + sum[r], sum[r]); for (int r = 0; r &lt; m; r++) res = max(res, dp[r]); &#125; &#125; return res;&#125;int main()&#123; int n; while (cin &gt;&gt; n) &#123; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) cin &gt;&gt; a[i][j]; cout &lt;&lt; solve(n, n) &lt;&lt; endl; &#125; return 0;&#125; 背包相关问题 背包相关的问题的背景大都是往容量有限的背包中装一些给定的物品, 使得总价值尽可能大. 感觉机试中比较多的就是0-1背包. 0-1背包 有 \(n\) 件物品和一个容量为 \(V\) 的背包. 放入第 \(i\) 件物品耗费的费用是 \(c_i\), 得到的 价值是 \(w_i\). 求解将哪些物品装入背包可使价值总和最大. 实现代码如下: 123456789101112// maxc 表示cost 最大值, maxn 表示n 最大值.// dp[cost] 即为答案.int n, cost;int dp[maxc], c[maxn], w[maxn];void init()&#123; memset(dp, 0, sizeof(dp)); for (int i = 0; i &lt; n; i++) for (int j = cost; j &gt;= c[i]; j--) dp[j] = max(dp[j], dp[j - c[i]] + w[i]);&#125; 百练 3714: 点菜问题 题目链接: http://bailian.openjudge.cn/practice/3714/ 总时间限制: 1000ms 内存限制: 65536kB 描述 北大网络实验室经常有活动需要叫外买，但是每次叫外买的报销经费的总额最大为C元，有N种菜可以点 ，经过长时间的点菜，网络实验室对于每种菜i都有一个量化的评价分数（表示这个菜可口程度），为Vi，每种菜的价格为Pi, 问如何选择各种菜，使得在报销额度范围内能使点到的菜的总评价分数最大？ 注意：由于需要营养多样化，每种菜只能点一次。 输入 输入的第一行有两个整数C（1 &lt;= C &lt;= 1000）和N（1 &lt;= N &lt;= 100），C代表总共能够报销的额度，N&gt;代表能点菜的数目。接下来的N行每行包括两个在1到100之间（包括1和100）的的整数，分别表示菜的&gt;价格和菜的评价分数。 输出 输出只包括一行，这一行只包含一个整数，表示在报销额度范围内，所点的菜得到的最大评价分数。 样例输入 90 4 20 25 30 20 40 50 10 18 40 2 25 30 10 8 样例输出 95 38 AC代码 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;const int maxc = 1005;int n, cost;int dp[maxc], c[maxn], w[maxn];void init()&#123; memset(dp, 0, sizeof(dp)); for (int i = 0; i &lt; n; i++) for (int j = cost; j &gt;= c[i]; j--) dp[j] = max(dp[j], dp[j - c[i]] + w[i]);&#125;int main()&#123; while (cin &gt;&gt; cost &gt;&gt; n) &#123; for (int i = 0; i &lt; n; i++) cin &gt;&gt; c[i] &gt;&gt; w[i]; init(); cout &lt;&lt; dp[cost] &lt;&lt; endl; &#125; return 0;&#125; 百练 2773: 采药 总时间限制: 1000ms 内存限制: 65536kB 描述 辰辰是个很有潜能、天资聪颖的孩子，他的梦想是称为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。” 如果你是辰辰，你能完成这个任务吗？ 输入 输入的第一行有两个整数T（1 &lt;= T &lt;= 1000）和M（1 &lt;= M &lt;= 100），T代表总共能够用来采药的时间，M代表山洞里的草药的数目。接下来的M行每行包括两个在1到100之间（包括1和100）的的整数，分别表示采摘某株草药的时间和这株草药的价值。 输出 输出只包括一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。 样例输入 70 3 71 100 69 1 1 2 样例输出 3 AC代码 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;const int maxc = 1005;int n, cost;int dp[maxc], weight[maxn], value[maxn];void init()&#123; memset(dp, 0, sizeof(dp)); for (int i = 0; i &lt; n; i++) for (int c = cost; c &gt;= weight[i]; c--) dp[c] = max(dp[c], dp[c - weight[i]] + value[i]);&#125;int main()&#123; while (cin &gt;&gt; cost &gt;&gt; n) &#123; for (int i = 0; i &lt; n; i++) cin &gt;&gt; weight[i] &gt;&gt; value[i]; init(); cout &lt;&lt; dp[cost] &lt;&lt; endl; &#125; return 0;&#125; 合并石子/矩阵链乘 algorithm.openjudge 合并石子 描述 在一个操场上一排地摆放着Ｎ堆石子。现要将石子有次序地合并成一堆。规定每次只能选相邻的２堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的得分。 试设计一个程序，计算出将Ｎ堆石子合并成一堆的最小得分。 输入 第一行为一个正整数\(N\) \((2\leqslant N\leqslant 100)\)； 以下Ｎ行,每行一个正整数，小于$10000，分别表示第 \(i\) 堆石子的个数 \((1≤i≤N)\)。 #### 输出 为一个正整数，即最小得分。 #### 样例输入 7 13 7 8 16 21 4 18 #### 样例输出 239 最大上升子序列和 牛客网: 最大上升子序列和 题目链接: https://www.nowcoder.com/practice/dcb97b18715141599b64dbdb8cdea3bd?tpId=40&amp;tqId=21409&amp;tPage=4&amp;rp=4&amp;ru=/ta/kaoyan&amp;qru=/ta/kaoyan/question-ranking 题目描述 一个数的序列bi，当b1 &lt; b2 &lt; ... &lt; bS的时候，我们称这个序列是上升的。对于给定的一个序列(a1, a2, ...,aN)，我们可以得到一些上升的子序列(ai1, ai2, ..., aiK)，这里1 &lt;= i1 &lt; i2 &lt; ... &lt; iK &lt;= N。比如，对于序列(1, 7, 3, 5, 9, 4, 8)，有它的一些上升子序列，如(1, 7), (3, 4, 8)等等。这些子序列中序列和最大为18，为子序列(1, 3, 5, 9)的和. 你的任务，就是对于给定的序列，求出最大上升子序列和。注意，最长的上升子序列的和不一定是最大的，比如序列(100, 1, 2, 3)的最大上升子序列和为100，而最长上升子序列为(1, 2, 3)。 输入描述 输入包含多组测试数据。 每组测试数据由两行组成。第一行是序列的长度N (1 &lt;= N &lt;= 1000)。第二行给出序列中的N个整数，这些整数的取值范围都在0到10000（可能重复）。 输出描述 对于每组测试数据，输出其最大上升子序列和。 样例输入 7 1 7 3 5 9 4 8 样例输出 18 大致思路 仍然是经典的子段/子序列dp的思路, 设原数组为 \(a\), 记 \(dp[i]\) 为以第 \(i\) 位结尾的最大上升子序列和, 则考虑 \(i&lt;j\), 若 \(a[j] &lt; a[i]\), 则 \(a[i]\) 接在以 \(a[j]\) 结尾的最大和子序列后可以构成一个以 \(a[i]\) 结尾的子序列, 可用该子序列的和去更新 \(dp[i]\) 的值, 即: \[dp[i] = \max \left( \max_{0&lt;j&lt;i\atop a[j]&lt;a[i]} ( dp[j]+a[i] ), a[i] \right).\] AC代码 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1005;int a[maxn], dp[maxn];int solve(int n)&#123; memset(dp, 0, sizeof(dp)); for (int i = 0; i &lt; n; i++) &#123; dp[i] = a[i]; for (int j = 0; j &lt; i; j++) if (a[j] &lt; a[i]) dp[i] = max(dp[i], dp[j] + a[i]); &#125; int res = a[0]; for (int i = 0; i &lt; n; i++) res = max(res, dp[i]); return res;&#125;int main()&#123; int n; while (cin &gt;&gt; n) &#123; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; cout &lt;&lt; solve(n) &lt;&lt; endl; &#125; return 0;&#125; 组合数的递推 这是一个很蠢的东西, 勉强算作动态规划吧.. 但实际只应算作递推. 原理 根本不用细说...就这一个式子, 叫做pascal公式. \[\binom{n}{k}=\binom{n-1}{k}+\binom{n-1}{k-1}.\] 实现代码 1234567891011// c[n][k] 表示n 中取k.int c[205][205]; // 这样的组合数已经大到天上了void getBinom()&#123; for (int i = 0; i &lt; 205; i++) &#123; c[i][i] = 1; for (int j = i + 1; j &lt; 205; j++) c[j][i] = (c[j - 1][i] + c[j - 1][i - 1]) % mod; &#125; // 数字比较小的时候 大概30以下 可以不取模&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>计算机</tag>
        <tag>算法</tag>
        <tag>保研复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北京师范大学组合数学试卷]]></title>
    <url>%2F2018%2F06%2F28%2FBNU-Combinatorics-Exam%2F</url>
    <content type="text"><![CDATA[组合数学 期末 张秀平. 试题 在边长为 \(1\) 的正方形中至少放入几个点, 才能保证至少有两点的距离不大于 \(\frac{1}{3}\)? 化简组合恒等式 \[\sum\limits_{k=0}^n \binom{\alpha+k}{p+k}\binom{p+k}{k}.\] 记初始排列为 \(1,2,\cdots,n\), 将其重排后为 \(a_1,\cdots,a_n\), s.t. \(a_{i+1}\neq a_i+1\) \((i=1,2,\cdots,n-1)\), 令其方案数为 \(Q_n\): 利用组合方法推导 \(Q_n\) 的递推关系; 利用容斥原理推导 \(Q_n\) 的递推关系. 用延迟认可算法求下面优先矩阵的稳定完备婚姻匹配(男选女, 女选男各做一次), 并给出简单评价: \(a\) \(b\) \(c\) \(d\) \(e\) \(f\) \(A\) \((1,4)\) \((2,3)\) \((3,6)\) \((4,2)\) \((5,5)\) \((6,1)\) \(B\) \((3,1)\) \((5,2)\) \((6,5)\) \((2,6)\) \((1,3)\) \((4,4)\) \(C\) \((5,5)\) \((3,6)\) \((6,1)\) \((4,4)\) \((2,2)\) \((1,3)\) \(D\) \((6,6)\) \((5,5)\) \((4,4)\) \((3,3)\) \((2,1)\) \((1,2)\) \(E\) \((1,3)\) \((3,1)\) \((5,2)\) \((2,5)\) \((4,4)\) \((6,6)\) \(F\) \((4,2)\) \((5,4)\) \((6,3)\) \((1,1)\) \((2,6)\) \((3,5)\) 设数列满足 \(\{f_n\}\) 满足 \(f_0=1\), \(f_1=1\), \(f_n=f_{n-1}+f_{n-2}~(n\geqslant 2)\), 令 \(g_n=f_{2n}\), \(h_n=f_n^2\). 分别求 \(f\), \(g\), \(h\) 的通项公式; 求 \(g_n\) 与 \(h_n\) 的生成函数. 构造一个指标为 \(1\) 的 \(9\) 元素 \(STS\), 判断它是否可解, 并给出理由.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>数学</tag>
        <tag>各种试卷</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[荒野行动回忆录]]></title>
    <url>%2F2018%2F04%2F24%2F%E8%8D%92%E9%87%8E%E8%A1%8C%E5%8A%A8%E5%9B%9E%E5%BF%86%E5%BD%95%2F</url>
    <content type="text"><![CDATA[偶然在桌面的角落发现了许久没有打开的荒野行动, 顺手打了一盘之后狠下心点了卸载. 游戏结束后看着空荡荡的在线好友列表, 不禁想起每天晚上十点准时吃鸡的日子. 竟有些怀念. 初识吃鸡 这是一个吃鸡全靠运气的时期. 最初开始玩荒野行动大致在2017.12-2018.01这段时间. 尽管以前玩过CS一类的FPS游戏, 在刚上手吃鸡时还是被打得找不着北. 第一次吃鸡是被翊坤和白旭阳舔空投带吃鸡的, 那时我还摸不清游戏的节奏. 慢慢摸清游戏节奏之后, 终于偶尔有了好的表现, 但大多数时间都是躺赢躺输. 成长之路 秋田小队 这段时间可能是荒野行动在我们当中最火的时期. 时间长了, 我们渐渐形成了稳定的开黑车队: 我+贾鑫mvp+社会我丁哥+向思忆+猴子+曾邱. 因为大家开黑时都会穿游戏中的&quot;秋田犬&quot;时装, 故称为秋田小队. 秋田小队开黑的大部分时间是靠贾鑫mvp带飞的. 在此期间, 我从未在打出好数据的局中吃鸡. 这实际上意味着我虽然对游戏节奏有了更好的理解, 但仍然不能带队吃鸡. 假期开黑 终于有了自己对游戏节奏的理解. 随着时间的推移, 我找回了些许从前玩CS的感觉, 终于也能在吃鸡局中打出不俗的数据. 正是此时有了第一次不坑的吃鸡: 后来把兔子拉入了坑, 加上贾鑫mvp回家以后, 秋田小队名存实亡. 此时的开黑车队变为了: 我+兔子+社会我丁哥+猴子. 从此开始了和兔子天天窝在309吃鸡的生活: 因为兔子不熟悉游戏, 打法以打野为主. 自此开发了右下角野区的&quot;吃鸡路线&quot;. 第一次带兔子吃鸡: 完全是带兔子和社会我丁哥躺鸡, 两个人都是零输出有没有. 第二次带兔子吃鸡: 这次是和猴子势力开黑吃鸡, 这人头都让猴子抢去了. 和兔子吃5km毒的故事: 值得一提的一场比赛. 扛毒杀人最为致命. 可惜一进圈就被阴Orz. 日常吃鸡 这时对游戏节奏已经非常清楚, 几乎天天都能吃鸡. 以和社会我丁哥双排为主. 值得纪念的是第一次带社会我丁哥双排吃鸡, 从此拉开了天天吃鸡的序幕. 一般吃鸡的情况有以下几种: 策略鸡, 刚枪鸡, 躺鸡. 其中以策略鸡最多. 策略鸡 前期避战, 合理转移, 保存实力一波吃鸡的打法. 经典战例如下: 海上绕圈避战 这盘装备一般, 但中期的时候, 观察到圈的特殊性, 直接找船绕了大半圈跑到无人地带, 最后决赛圈一波得手. 天命鸡 这一类很特别: 这一盘因为AI的存在, 数据看起来很像刚枪鸡. 但实际上就是在滨海镇蹲了20分钟杀了1w个AI舔了1w个空投决战圈刷在脸上刚一波成功吃鸡. 其他策略鸡记录 刚枪鸡 见人就锤, 来车就扫, 杀出一条血路吃鸡的打法. 伤害第一次破千 这是一局值得纪念的比赛Orz. 毕竟我很菜, 破千这事情干得不多. 其他刚枪鸡记录 都算是打架比较多的局. 躺鸡 搜完房区, 一路无人, 莫名其妙也能吃鸡的打法. AI鸡 躺鸡也有一种AI的情况, 就是杀了几个AI然后没打架就吃鸡. 看数据很容易与策略鸡混淆. 其他躺鸡记录 可以看得出, 都很躺.]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>荒野行动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图说农药]]></title>
    <url>%2F2018%2F04%2F18%2F%E5%86%9C%E8%8D%AF%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[时间过得真快, 不知不觉农药已经玩了快一年了. 翻相册时无意翻到了这些图片, 决定开坑保存一下. 只是一个无聊透顶的记录... 农药大事记 排位足迹 各个赛季的段位情况如下: S7赛季 初识农药: 最早玩的是后羿, 简单暴力. 后来因为兔子玩后羿, 改玩安琪拉. 在低端局日常超神. 组队上分: 后来结识了小boo, 加入了新乐群战队, 开始了五排上分. 主要玩射手, 很容易看出, 我可能是射手狂魔. 这时鲁班非常强, 加上段位不高, 故多玩鲁班, 偶尔玩狄仁杰. S8赛季 组队上分: 初期仍然维持着组队上分的节奏. 疯狂排位: 放假后大家时间并不统一, 于是开始了单排上分. 不过假期还是常打战队赛攒铭文碎片的哈哈. 虽然开发出了吕布, 但主要还是玩射手, 但主要玩的英雄变成了马可. 后来又学会了孙尚香. 冲上王者: 在开学后, 比较艰难地冲上了王者Orz. 上王者之后, 由于开黑的兄弟们段位都比较低, 加上战队赛打不赢的问题, 掉了一波分. S9赛季 掉分带人: 由于已经上过王者, 我便懒得冲分, 很少打排位. 只是偶尔带一带贾鑫mvp或者其他人. 可惜贾鑫mvp本赛季没有成功冲上王者Orz. 此时的英雄池深了很多, 可以看出英雄的使用场次都不多. 给兔子上分: 兔子想追上我的段位, 未果. 于是我偶尔用兔子的号上分. 也带带王队. 我所经历过貂蝉最强的一个赛季, 用貂蝉给兔子上了几个星. 然而效果并不理想Orz. 我好菜_(:з」∠)_ S10赛季 沉迷吃鸡: 由于吃鸡的影响, 不论是匹配还是排位都打得少了一些. 莫名其妙学会了花木兰, 尽管胜率感人. 打折期间剁手了嬴政Orz. 对黑王队: 王队的加入及其室友的回归壮大了农药玩家的队伍, 于是有一段时间经常开房间5v5对黑. 战绩嘛emmmmm, 宝宝自然是没怎么输过. 勉强上钻: 兔子卸掉了一段时间农药, 我便觉得暂时没有必要停留在铂金. 用上RMB英雄嬴政, 一波七连胜轻松冲上了钻石. 上钻之后便基本没有再打. 可能带过贾鑫mvp几盘. 贾鑫mvp在本赛季成功冲上了王者Orz. 赛季末兔子又下回了农药, 不过上钻已来不及. S11赛季 在济南的时候开始了S11赛季, 宾馆排位, 最为致命. 妈的第一天就四连败. 肥肠生气.. 基本只玩打野和上单的一个赛季. 基本只玩强势英雄的一个赛季. 疯狂掉胜率的一个赛季. 用兔子号带王队上分Orz 莫名其妙就会玩貂蝉了, 输出过半碾压铂金局 其实自己用芈月这种弱势英雄也打出过类似的数据 还有大家眼中的废物英雄弈星. 还用孙膑打出过这种级别的数据, 虽然输了== 但是我服我自己哈哈哈 再补一个后羿... 来个李信 还有东皇 伽罗瓦 马可波罗 橘子 干将 嬴政 蒙犽 圣诞老人皮肤 S12的第一天六盘排位之后, 和兔子的师徒等级到了6级, 得到了圣诞老人皮肤. 肥肠开心, yeah! 2019.05 白嫖冰冠公主！ 圣诞节，超级膀胱局 李白挂机，四打五大翻盘…农药送给我的圣诞礼物？？？ 扯淡的训练营 训练营也是需要技运气术的好吧( 轮盘方向：40.13s，击败99.92% 区域施法：40.66s，击败99.90% 穿墙移动：48.05s，击败99.99% 全英雄金牌进度: 96/98 [ ] 蒙犽 [x] 鲁班大师 [x] 西施 [x] 马超 [x] 曜 [x] 云中君 [x] 瑶 [x] 盘古 [ ] 猪八戒 还没达成金牌…… [x] 嫦娥 其实这英雄有点迷…… [x] 上官婉儿 一顿乱秀的英雄 [x] 李信 无脑猛的英雄 [x] 沈梦溪 [x] 伽罗 [x] 盾山 这个分数按理来说应该是金牌了 [x] 司马懿 [x] 孙策 [x] 元歌 [x] 米莱狄 （对金牌系统表示质疑） [x] 狂铁 [x] 弈星 这废物英雄就这样吧 [x] 裴擒虎 [x] 杨玉环 [x] 公孙离 （按时间顺序第二次对金牌系统表示质疑） [x] 明世隐 [x] 女娲 [x] 梦奇 [x] 苏烈 [x] 百里玄策 [x] 百里守约 [x] 铠 [x] 鬼谷子 鬼谷子都这样了不是金牌…很无奈Orz 就这样了. 然后按照时间顺序第三次对金牌判定提出质疑== [x] 干将莫邪 [x] 东皇太一 [x] 大乔 功能型英雄...套路打出来很脏 [x] 黄忠 [x] 诸葛亮 [x] 哪吒 [x] 太乙真人 [x] 蔡文姬 [x] 雅典娜 [x] 杨戬 对雷达图提出小小的质疑 [x] 成吉思汗 [x] 钟馗 [x] 虞姬 [x] 李元芳 [x] 张飞 [x] 刘备 [x] 后羿 [x] 牛魔 [x] 孙悟空 再放一个分更高的...输出将近一半 [x] 亚瑟 [x] 橘右京 [x] 娜可露露 [x] 不知火舞 [x] 张良 [x] 花木兰 [x] 兰陵王 [x] 王昭君 [x] 韩信 其实有一次13+的...忘了截图Orz [x] 刘邦 [x] 姜子牙 [x] 露娜 [x] 程咬金 [x] 安琪拉 [x] 貂蝉 [x] 关羽 [x] 老夫子 [x] 武则天 2018.10.28趁限免超一波神... [x] 项羽 [x] 达摩 [x] 狄仁杰 [x] 马可波罗 有了更高分，但是旧图懒得删了 [x] 李白 [x] 宫本武藏 [x] 典韦 [x] 曹操 [x] 甄姬 [x] 夏侯惇 [x] 周瑜 [x] 吕布 [x] 芈月 [x] 白起 [x] 扁鹊 [x] 孙膑 [x] 钟无艳 [x] 阿轲 [x] 高渐离 [x] 刘禅 [x] 庄周 食人鱼上线.. [x] 鲁班七号 [x] 孙尚香 [x] 嬴政 [x] 妲己 [x] 墨子 [x] 赵云 [x] 小乔 [x] 廉颇 边境突围吃鸡小记录 S12赛季农药开发了新模式边境突围, 玩法类似于吃鸡, 但是感觉emmmmm... 不如吃鸡有意思, 而且有点卡. 按照惯例, 还是进行一些琐碎且无聊的记录: 初入吃鸡坑 第一次吃鸡: 不谦虚地讲, 第一次玩就吃鸡了, 还是单人打双排... 感觉马可在这里边近乎无敌. 第一次带兔子吃鸡 体验一盘以后就立刻带兔子吃了一盘鸡. 其实这盘体验极差, 开始因为网络原因掉线, 于是和兔子距离过远, 导致兔子死掉了... 背一波锅. 体检前一晚上睡不着, 于是偷偷吃了一把鸡 于是体检当天连跪之后拉兔子吃鸡 这盘和上一盘最后都是一波极限一打二... 吹一波自己哈哈哈. 这盘应该算是兔子体验比较好的? 冲2k分之旅 随着分数变高, 吃鸡开始困难了Orz, 大家操作和策略有些提升. 目前打上了2k分, 应该还能上 这一盘战斗力高到天上...我都不记得是怎么做到的.]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>王者荣耀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文笔记[2]——AKS素性测试]]></title>
    <url>%2F2018%2F04%2F15%2F%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-2-%E2%80%94%E2%80%94PRIMES-Is-in-P%2F</url>
    <content type="text"><![CDATA[文章: Agrawal M, Kayal N, Saxena N. PRIMES Is in P[J]. Annals of Mathematics, 2004, 160(2):781-793. 太长不看版 文章分为正确性和复杂度两部分: 正确性: 素数显然会返回 PRIME, 只需证返回 PRIME 的是素数. 返回素数的地方只有 Step 2 和 Step 6, 分别讨论之. Step 4: 若 \(n\) 是合数则会在 Step 3 中返回, 矛盾. Step 6: 分段考虑. 先考虑 Step 2 中 \(r\) 的范围, 可得 \(r\leqslant\lceil\log^5n\rceil\). 定义多项式之间的关系introspective: \([f(x)]^m=f(x^m)~({\rm mod}~x^r-1,p)\), 则该性质对 \(m\) 和 \(f\) 都满乘积性质. 由于在 Step 5 没有返回 COMPOSITE, 故 \(\frac{n}{p},p\) 对 \(x+a\) 是introspective的. 故 \(\frac{n}{p}\) 与 \(p^j\) 的任意乘积对 \(x+a~(0\leqslant a\leqslant l)\) 的任意乘积是introspective的. 进一步, 通过建立两个群 \(G\) 和 \(\mathcal{G}\), 可得到 \(|\mathcal{G}|\) 的下界和一个由条件的上界. 并可最终得到 \(n=p\), 即 \(n\) 是素数. 至此算法正确性得证. 复杂度: 逐步分析可知 Step 5 复杂度最高, 为 \(O^\sim(\log^\frac{21}{2}n)\). 以下是详细的版本 记号说明和准备工作 记号列表 文中出现的记号记录如下: \(P\): 图灵机在多项式时间内可以解决的问题; \(F_p\) 表示阶为 \(p\) 的有限域, 其中 \(p\) 是素数; \(f(x)=g(x)~({\rm mod}~h(x),n)\): 表示 \(f(x)=g(x)\) 在 \(\mathbb{Z}_n[x]/\langle h(x)\rangle\) 中成立; \(O^\sim (t(n))\): 表示 \(O(t(n))\cdot {\rm poly}(\log t(n))\). 其中 \(\log\) 表示以 \(2\) 为底的对数; \(o_r(a)\): 表示 \(a\) 模 \(r\) 的指数. 即最小的 \(k\), s.t. \(a^k=1~({\rm mod}~r)\). 为不影响思路的连贯性, 长一点的证明细节都补在最后. 准备工作 LEMMA 1. 设 \(a\in\mathbb{Z}\), \(n\geqslant 2\in\mathbb{N}\), 且 \((a,n)=1\), 则 \(n\) 是素数当且仅当 \[(x+a)^n=x^n+a~({\rm mod~n}).\] Proof. 直接讨论, 利用二项式系数的性质即可. PRELIMINARY 1. 若 \(h(x)\) 是 \(F_p[x]\) 中的 \(d\) 次不可约多项式, 则 \(F_p[x]/\langle h[x]\rangle\) 是阶为 \(p^d\) 的有限域. Proof. 设 \(F(\alpha)=0\), 考虑映射 \(\varphi:~F[\alpha]\to F[x],~f(\alpha)\mapsto f(x)\), 则由环同态基本定理可得 \[F(\alpha)=F[\alpha]\simeq F[x]/\langle p(x)\rangle.\] 由此即可证得结论. PRELIMINARY 2. 对于 \(\forall a,r\in\mathbb{N}\) 满足 \((a,r)=1\), 都有 \(o_r(a)~\vert~\phi(r)\). Proof. 若不满足上式, 与 \(o_r(a)\) 的最小性矛盾. LEMMA 2. 令 \({\rm LCM}(n)\) 表示前 \(n\) 个数的lcm, 则对 \(n\geqslant 7\) 有: \({\rm LCM}(n)\geqslant 2^n\). Proof. Nair M. On Chebyshev-type inequalities for primes[J]. American Mathematical Monthly, 1982, 89(2):126-129. 算法正确性 需要证明以下两条: \(n\) 是素数\(\to\)算法返回 PRIME ; 算法返回 PRIME \(\to\)\(n\) 是素数. 事实上第一条是显然的, 主要部分是第二条的证明. \(n\) 是素数\(\to\)算法返回 PRIME LEMMA 3. 若 \(n\) 是素数, 则算法返回 PRIME. Proof. 这一条其实是很显然的. 证明全是废话, 略掉. 算法返回 PRIME \(\to n\) 是素数 算法返回 PRIME 的地方只有两处, 分别为 Step 4 和 Step 6. 以下分别讨论之. Step 4 返回 PRIME \(\to n\) 是素数 证明很容易: 如果 \(n\) 是合数且 \(n\leqslant r\), 则在Step3 中一定可找到 \(n\) 的一个非平凡因子. 故在 Step 3 一定会返回 COMPOSITE, 矛盾! 故 Step 4 返回 PRIME \(\Rightarrow n\) 是素数. Step 6 返回 PRIME \(\to n\) 是素数 算法的核心步骤是 Step 2 和 Step 5. 算法在 Step 2 中取了一个 \(r\) 值, 所以我们从 \(r\) 的大致取值开始考虑. LEMMA 4. \(\exists r\leqslant\max\{3,\lceil\log^5 n\rceil\}\), s.t. \(o_r(n)&gt;\log^2n\). Proof. 单独讨论 \(n=2\) 情况, 即可设 \(n&gt;2\), 此时可利用 LEMMA 2 进行证明. 由于 \(o_r(n)&gt;1\), 故存在 \(n\) 的素因子 \(p\), s.t. \(o_r(p)&gt;1\) (否则容易得到 \(o_r(n)=1\), 矛盾). 进一步应有 \(p&gt;r\), 否则在 Step 3 和 Step 4 就已经判断了 \(n\) 的素性. 又由于 \((n,r)=1\)(否则在 Step 3 和 Step 4 会判定 \(n\) 素性), 故 \(p,n\in\mathbb{Z}_r^*\). \(p\) 和 \(r\) 在后文中将被固定, 再令 \(l=\lfloor\sqrt{\phi(r)}\log n\rfloor\). 由于算法执行到了 Step 6, 故在 Step 5 没有返回 COMPOSITE. 即: \[(x+a)^n=x^n+a~({\rm mod}~x^r-1,n)\quad\forall a,0\leqslant a\leqslant l.\] 于是 \[(x+a)^n=x^n+a~({\rm mod}~x^r-1,p)\quad\forall a,0\leqslant a\leqslant l.\] 由以上两式可得: \[(x+a)^\frac{n}{p}=x^\frac{n}{p}+a~({\rm mod}~x^r-1,p)\quad\forall a,0\leqslant a\leqslant l.\] 结合 LEMMA 1, 此时的 \(n\) 和 \(\frac{n}{p}\) 都满足 LEMMA 1 的条件, 将该性质定义如下: DEFINITION 1. 对于多项式 \(f(x)\) 和 \(m\in\mathbb{N}\), 称 \(m\) 是instropective的, 如果 \[[f(x)]^m=f(x^m)~({\rm mod}~x^r-1,p).\] 很容易证明instropective有如下性质: LEMMA 5. 若 \(m\) 和 \(m&#39;\) 对 \(f(x)\) 都是instropective的, 则 \(m\cdot m&#39;\) 对 \(f(x)\) 也是instropective的. LEMMA 6. 若 \(m\) 对 \(f(x)\) 和 \(g(x)\) 都是instropective的, 则 \(m\) 对 \(f(x)\cdot g(x)\) 也是instropective的. 于是可以得到如下事实: 由前文的三个等式可知 \(\frac{n}{p}\) 和 \(p\) 对 \(x+a\) 是instropective的, \(\forall 0\leqslant a\leqslant l\). 进一步, 集合 \(I=\{(\frac{n}{p})^i\cdot p^j~\vert~ i,j&gt;0\}\) 中的每个数对集合 \(P=\{\prod\limits_{a=0}^l(x+a)^{e_a}~\vert~ e_a\geqslant 0\}\) 中的每个多项式都是introspective的. 进一步可在上述集合的基础上如下定义两个群: \(G\): \(I\) 中所有的数模 \(r\) 的余数构成一个群. 设 \(\vert G\vert=t\). 显然 \(G\subset \mathbb{Z}_r^*\)(生成元都在 \(\mathbb{Z}_r^*\) 中). 由 \(o_r(n)&gt;\log^2n\) 可知, \(t&gt;\log^2n\). \(\mathcal{G}\): 由 \(x,x+1,\cdots,x+l\) 在域 \(F=F_p[x]/\langle h(x)\rangle\) 中生成的群. 显然 \(\mathcal{G}\) 是 \(F\) 乘法群的子群. \(P\) 中所有多项式在模 \(h(x)\) 和 \(p\) 的意义下关于乘法构成一个群. \(\vert\mathcal{G}\vert\) 的范围由如下引理给出(证明细节见后文): LEMMA 7. 下界: (Hendrik Lenstra Jr.) \(\vert\mathcal{G}\vert\geqslant\binom{t+l}{t-1}\). LEMMA 8. 上界: 若 \(n\) 不是 \(p\) 的方幂, 则 \(\vert\mathcal{G}\vert\leqslant n^{\sqrt{t}}\). 进一步即可得到最终的结果: LEMMA 9. 若算法返回 PRIME, 则 \(n\) 是素数. Proof. 由 LEMMA 7, 有: \[ \begin{align} \vert\mathcal{G}\vert &amp;\geqslant \binom{t+l}{t-1} &amp; \\ &amp;\geqslant \binom{l+1+\lfloor\sqrt{t}\log n\rfloor}{\lfloor\sqrt{t}\log n\rfloor} &amp;\quad (由于~t&gt;\sqrt{t}\log n) \\ &amp;\geqslant \binom{2\lfloor\sqrt{t}\log n\rfloor+1}{\lfloor\sqrt{t}\log n\rfloor} &amp;\quad (由于~l\geqslant \lfloor\sqrt{t}\log n\rfloor) \\ &amp;\geqslant 2^{\lfloor\sqrt{t}\log n\rfloor+1} &amp;\quad (由于~\lfloor\sqrt{t}\log n\rfloor&gt;\lfloor\log^2n\rfloor\geqslant 1) \\ &amp;\geqslant n^{\sqrt{t}}. \end{align} \] 由 LEMMA 8, 当 \(n\) 不是 \(p\) 的方幂时, 有\(\vert\mathcal{G}\vert\leqslant n^\sqrt{t}\). 故 \(\exists k\), s.t. \(n=p^k\). 若 \(k&gt;1\), 则在 Step 1 就会返回 COMPOSITE. 故只有 \(k=1\), 即 \(n=p\), 即 \(n\) 为素数. 至此, 算法正确性已经证明完毕. 可归纳为如下定理: THEOREM 1. 算法返回 PRIME 当且仅当 \(n\) 是素数. 复杂度证明 首先做如下假定: \(m\) 位数的四则运算耗时均为 \(O^\sim(m)\); 两个系数为 \(m\) 位整数的 \(d\) 次多项式的四则运算耗时为 \(O^\sim(d\cdot m)\). \(n\) 的位数大致为 \(O(\log n)\). 对于算法的复杂度, 我们将证明如下定理: THEOREM 2. 算法的渐进时间复杂度为 \(O^\sim(\log^{\frac{21}{2}}n)\). Proof. 按照算法步骤逐个讨论: Step 1: 判断是否整数的幂. 时间复杂度 \(O^\sim(\log^3n)\), 参见 Mordern Computer Algebra. Cambridge Univ.; Step 2: 求一个 \(r\), s.t. \(o_r(n)&gt;\log^2n\). 1. 取 \(r\), s.t. \(o_r(n)&gt;\log^2n\). 只需枚举 \(k\leqslant\log^2n\), 故至多需要 \(O(\log^2n)\). 2. 取定一个 \(r\) 后, 至多进行 \(O(\log^2n)\) 次模 \(r\) 乘法, 开销至多 \(O^\sim(\log^2n\log r)\). 3. 由 LEMMA 4, 至多需要测试 \(O(\log^5n)\) 个不同的 \(r\). 综上, Step 2 复杂度至多 \(O^\sim(\log^7n)\). Step 3: 需要求 \(r\) 次gcd. 1. 每次 gcd 的开销为 \(O(\log n)\). 2. \(r\) 的开销为 \(O(\log^5n)\). 综上, Step 3 的复杂度为 \(O(r\log n)=O(\log^6n)\). Step 4: 只需要比较 \(n\) 和 \(r\) 大小. 时间复杂度 \(O(\log n)\). Step 5: 验证 \(\lfloor\sqrt{\phi(r)}\log n\rfloor\) 个多项式等式. 1. 每个等式次数都是 \(r\), 故单次验证的开销为 \(O^\sim(r\log^2 n)\). 2. 总复杂度为 \(O^\sim(r\sqrt{\phi(r)}\log^3n)\). 综上, Step 5 的复杂度为 \(O^\sim(r\sqrt{\phi(r)}\log^3n)=O^\sim(r^\frac{3}{2}\log^3n)=O^\sim(\log^\frac{21}{2}n)\). Step 6: 这步啥也没干, 就返回了一个 PRIME. 时间复杂度 \(O(1)\). 综上, 算法的时间复杂度为 \(O(\log^\frac{21}{2}n)\). 至此, 算法复杂度证明完毕. 貌似还有一些改进, 有点麻烦, 以后再说. 一些引理的证明细节 LEMMA 1 Proof. \(\forall 0&lt;i&lt;n\), \(x^i\) 在 \(((x+a)^n-(x^n+a))\) 中的系数为 \(\binom{n}{i}a^{n-i}\). - 若 \(n\) 为素数, 则 \(\binom{n}{i}=0~({\rm mod~n})\), 故 \(\forall 0&lt;i&lt;n\), \(x^i\) 系数均为 \(0\), 即原式成立. - 若 \(n\) 为合数, 取 \(q~\vert~n\), 且 \(q^k~||~n\). 则 \(q^k\) 不能整除 \(\binom{n}{q}\), 且 \((q,a^{n-q})=1\). 故 \(x^q\) 系数不为 \(0\). 故原式不成立. 综上, 原式成立当且仅当 \(n\) 是素数. LEMMA 2 Proof. 考虑积分 \[I(m,n)=\int_0^1 x^{m-1}(1-x)^{n-m}{\rm d}x\quad (1\leqslant m\leqslant n).\] 一方面, 由 \((1-x)^{n-m}\) 的展式可知 \(I(m,n)\) 是分母整除 \({\rm LCM}(n)\) 的有理数: \[I(m,n)=\sum\limits_{0\leqslant j\leqslant n-m}(-1)^j\binom{n-m}{j}\frac{1}{m+j}\in\frac{1}{d_n}\mathbb{Z}.\] 另一方面, 注意到 \(\forall 0\leqslant y\leqslant 1\), 有 \[\sum\limits_{1\leqslant m\leqslant n}\binom{n-1}{m-1}y^{m-1}I(m,n)=\int_0^1(1-x+xy)^{n-1}{\rm d}x=\frac{1}{n}\sum\limits_{1\leqslant m\leqslant n}y^{m-1}.\] 从而 \[I(m,n)=\frac{1}{n}\binom{n-1}{m-1}=\frac{1}{m}\binom{n}{m}\quad (1\leqslant m\leqslant n).\] 这说明对 \(1\leqslant m\leqslant n\), 有 \(m\binom{n}{m}~\vert~d_n\). 于是有 \[\left.\left.n\binom{2n}{n}~\right|~{\rm LCM}(2n)~\right|~{\rm LCM}(2n+1)~~且~~\left.(n+1)\binom{2n+1}{n}=(2n+1)\binom{2n}{n}~\right|~{\rm LCM}(2n+1).\] 由于 \((n,2n+1)=1\), 故 \[\left.n(2n+1)\binom{2n}{n}~\right|~{\rm LCM}(2n+1).\] 由于 \(\binom{2n}{n}\) 是 \((1+x)^{2n}\) 系数中最大的一项, 故 \[{\rm LCM}(2n+1)\geqslant n4^n\quad (n\geqslant 1).\] 从而 \[{\rm LCM}(2n+1)\geqslant 2\cdot 4^n=2^{2n+1}\quad (n\geqslant 2).\] 且 \[{\rm LCM}(2n+2)\geqslant {\rm LCM}(2n+1)\geqslant 4^{n+1}\quad (n\geqslant 4).\] 以上已经证明了对于 \(n\geqslant 9\) 有 \({\rm LCM}(n)\geqslant 2^n\). 经验证 \(n=7,8\) 也成立, 于是原式对 \(\forall n\geqslant 7\) 成立. LEMMA 4 Proof. 当 \(n=2\) 时, 取 \(r=3\) 即可. 故以下假设 \(n&gt;2\), 即有 \(\lceil\log^5n\rceil&gt;10\) 且 LEMMA 2 适用. 先证存在 \(r\leqslant m\), s.t. \(r\not| N\), 其中 \[N=n^{\lfloor \log m\rfloor}\cdot\prod\limits_{i=1}^{\lfloor\log^2n\rfloor}(n^i-1).\] 假设 \(r~\vert~N\), \(\forall 1\leqslant r\leqslant m\), 则有 \({\rm LCM}(m)\leqslant N\). 注意到 \[ \begin{align} N &amp;= n^{\lfloor \log m\rfloor}\cdot\prod\limits_{i=1}^{\lfloor\log^2n\rfloor}(n^i-1) \\ &amp;&lt; n^{\lfloor \log m\rfloor}\cdot\prod\limits_{i=1}^{\lfloor\log^2n\rfloor}n^i \\ &amp;= n^{\lfloor\log m\rfloor+1+2+\cdots+\log^2n} \\ &amp;= n^{\lfloor\log m\rfloor+\frac{1}{2}[\log^2n(\log^2n+1)]} \\ &amp;= n^{\lfloor\log m\rfloor+\frac{1}{2}[\log^4n+\log^2n]} \\ &amp;&lt; n^{\log^4n} \\ &amp;= (2^{\log n})^{\log^4n} \\ &amp;= 2^{\log^5n} \leqslant 2^m. \end{align} \] 故 \(N&lt;2^m\), 这与 \({\rm LCM}(m)\geqslant 2^m\) 矛盾. 故集合 \(\{r~|~1\leqslant r\leqslant m,~r\not| N\}\) 非空. 设 \(r\) 为其中的最小值. 至此我们已经找到了 \(r\leqslant m\), 以下只需证明 \(o_r(n)\) 存在, 且 \(o_r(n)&gt;\log^2n\). 由于 \(o_r(n)\) 存在当且仅当 \((r,n)=1\), 故只需证明 \(r\) 与 \(n\) 互素. 设 \(r=ab\), 其中 \(a\) 由 \((n,r)\) 的所有素因子组成, \(b\) 由其他素因子组成, 即 \((a,b)=1\). 显然有 \((b,n)=1\). 注意到 \(a\) 的任意素因子在 \(a\) 中的最高幂次都不会超过 \(\lfloor\log m\rfloor\), 否则 \(a\leqslant r\) 会超过 \(m\). 故 \(a\) 的任意素因子在 \(a\) 中的幂次都不超过在 \(n^{\lfloor\log m\rfloor}\) 中的幂次, 故 \(a~|~n^{\lfloor\log m\rfloor}\). 另一方面, 有 \(b\not|n^{\lfloor \log m\rfloor}\cdot\prod\limits_{i=1}^{\lfloor\log^2n\rfloor}(n^i-1)\) 且由 \((b,n)=1\) 可知 \(b\not| n^{\lfloor\log m\rfloor}\). 故 \(b\not| N\). 然而由 \(r\) 的定义可知, \(r\leqslant b\), 于是有 \(r=b\). 故 \((r,n)=1\), 故 \(o_r(n)\) 存在. 最后证明 \(o_r(n)&gt;\log^2n\): 假设 \(d=o_r(n)\leqslant\log^2n\), 则由定义有 \(n^d=1~({\rm mod}~r)\), 即 \(n^d-1=0~({\rm mod}~r)\), 故 \(n~|~(n^d-1)\). 即 \(r\) 整除 \(N\) 的一个因子 \(n^d-1\), 因而 \(r~|~N\), 矛盾! 于是有 \(o_r(n)&gt;\log^2n\). 至此, 引理得证. LEMMA 7 Proof. 注意到 \(h(x)\) 是 \(r\) 次分圆多项式 \(Q_r(x)\) 的一个因式, \(x\) 为 \(F\) 上的 \(r\) 次本原单位根. 以下证明: \(P\) 中任意两个不同的次数不超过 \(t\) 的多项式在 \(\mathcal{G}\) 中会对应到不同的元素. 设 \(f(x),g(x)\in P\) 是这样的两个多项式. 假设 \(f(x)=g(x)\) 在 \(F\) 上成立. 取 \(m\in I\), 则在 \(F\) 中有 \([f(x)]^m=[g(x)]^m\). 由于 \(m\) 对 \(f\) 和 \(g\) 都是introspective的, 且 \(h(x)~\vert~x^r-1\), 故 \[f(x^m)=g(x^m)\quad\text{in}~F.\] 这说明 \(\forall m\in G\), \(x^m\) 总是多项式 \(Q(y)=f(y)-g(y)\) 的根. 由于 \(m\in G\subset\mathbb{Z}_r^*\), 故 \((m,r)=1\), 故每个这样的 \(x^m\) 都是 \(r\) 次本原单位根. 故这样得到了 \(Q(y)\) 的 \(\vert G\vert=t\) 个不同的根. 然而 \(Q(y)\) 的次数小于 \(t\), 故根也少于 \(t\) 个. 矛盾! 故在 \(F\) 上有 \(f(x)\neq g(x)\). 注意到 \(l=\lfloor\sqrt{\phi(r)}\log n\rfloor&lt;\sqrt{r}\log n&lt;r\) 且 \(p&gt;r\), 故 \(x,x+1,\cdots,x+l\) 在 \(F\) 中两两不等. 同时, 由 \(h(x)\) 的次数大于 \(1\) 可知, \(x+a\neq 0\), \(\forall 0\leqslant a\leqslant l\). 于是 \(\mathcal{G}\) 中存在至少 \(l+1\) 个一次多项式. 故 \(\mathcal{G}\) 中至少存在 \(\binom{t+l}{t-1}\) 个次数小于 \(t\) 的多项式. LEMMA 8 Proof. 考虑 \(I\) 的以下子集: \[\hat{I}=\{(\frac{n}{p})^i\cdot p^j~\vert~0\leqslant i,j\leqslant\lfloor\sqrt{t}\rfloor\}.\] 若 \(n\) 不是 \(p\) 的方幂, 则 \(\hat{I}\) 有 \((\lfloor\sqrt{t}\rfloor+1)^2&gt;t\) 个不同元素. 由于 \(|G|=t\), 故由抽屉原理可知 \(\hat{I}\) 中至少存在 \(2\) 个元素模 \(r\) 同余. 令其为 \(m_1,m_2\), 不妨设 \(m_1&gt;m_2\). 则有: \[x^{m_1}=x^{m_2}~({\rm mod}~x^r-1).\] 令 \(f(x)\in P\), 则 \[ \begin{align} [f(x)]^{m_1} &amp;= f(x^{m_1})~({\rm mod}~x^r-1,p) \\ &amp;= f(x^{m_2})~({\rm mod}~x^r-1,p) \\ &amp;= [f(x)]^{m_2}~({\rm mod}~x^r-1,p). \end{align} \] 即在 \(F\) 上有 \([f(x)]^{m_1}=[f(x)]^{m_2}\). 于是 \(f(x)\in\mathcal{G}\) 是多项式 \(Q&#39;(y)=y^{m_1}-y^{m_2}\) 在 \(F\) 中的一个根. 由于 \(f(x)\) 是 \(\mathcal{G}\) 中的任意一个元素, 故 \(Q&#39;(y)\) 在 \(F\) 中至少有 \(|\mathcal{G}|\) 个不同的根. 而 \[{\rm deg}~Q&#39;(y)=m_1\leqslant (\frac{n}{p}\cdot p)^{\lfloor\sqrt{t}\rfloor}.\] 即 \(|\mathcal{G}|\leqslant n^{\lfloor\sqrt{t}\rfloor}.\)]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>数学</tag>
        <tag>计算机</tag>
        <tag>北大</tag>
        <tag>抽象代数</tag>
        <tag>论文笔记</tag>
        <tag>保研</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复变函数拾遗[2]——多值函数的解析分支]]></title>
    <url>%2F2018%2F04%2F12%2F%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E6%8B%BE%E9%81%97-2-%E2%80%94%E2%80%94%E5%A4%9A%E5%80%BC%E5%87%BD%E6%95%B0%E7%9A%84%E8%A7%A3%E6%9E%90%E5%88%86%E6%94%AF%2F</url>
    <content type="text"><![CDATA[大致分为两部分: 多值函数解析分支的定义; 多值函数解析分支的讨论. 多值函数解析分支的定义 解析分支定义 DEFINITION 1. 设 \(\Omega\) 为区域, \(\mathbf{F}(z)\) 为 \(\Omega\) 上的多值函数, 如果 \(f(z)\) 在 \(\Omega\) 解析, 且对 \(\forall z\in\Omega\), 有 \(f(z)\in\mathbf{F}(z)\), 则称 \(f\) 为 \(\mathbf{F}\) 在 \(\Omega\) 上的解析分支. 多值函数的本质 这里的论述可能不太严格. 考虑复数的三角式: \[z=\vert z\vert e^{i~{\rm arg}~z}.\] 由于 \(e^{2\pi i}=1\), 故 \(\vert z\vert e^{i~{\rm arg}~z}=\vert z\vert e^{i~({\rm arg}~z+2k\pi)}\). 即 \(z\) 的辐角 \(\mathbf{Arg}~z\) 是一个多值函数. 由于辐角函数是一个多值函数, 这就导致了多值函数的存在. 多值函数的不同解析分支实际上也对应了 \(\mathbf{Arg}~z\) 的不同取值. 辐角函数的连续分支 PROPOSITION 1. 设 \(\Omega\) 为单连通区域, \(z_0\notin\Omega\), 则 \(\mathbf{Arg}~(z-z_0)\) 在区域 \(\Omega\) 上有连续分支 \({\rm arg}~(z-z_0)\), 且 \(\mathbf{Arg}~(z-z_0)\) 在 \(\Omega\) 上的所有连续分支如下: \[\mathbf{Arg}~(z-z_0)=\{ {\rm arg}~(z-z_0)+2k\pi:k\in\mathbb{Z}\}.\] 于是 \(\mathbf{Arg}~(z-z_0)\) 在 \(\Omega\) 内有无穷多个连续分支. 几个解析分支的例子 对数函数的解析分支 THEOREM 1. 设 \(\Omega\) 为单连通区域, \(f(z)\) 在 \(\Omega\) 中解析且处处不为零, 则 \(\mathbf{Ln}~f(z)\) 在 \(\Omega\) 有解析分支 \(g(z)\), s.t. \[e^{g(z)}=f(z),\] 且 \(\mathbf{Ln}~f(z)\) 在 \(\Omega\) 上所有的解析分支都具有形式 \(g(z)+2k\pi i\), 即: \[\mathbf{Ln}~f(z)=\{g(z)+2k\pi i:k\in\mathbb{Z}\}.\] 即 \(\mathbf{Ln}~f(z)\) 在 \(\Omega\) 有无穷多个解析分支. 简略证明: 从三角式的角度考虑非常显然: \[\begin{align} {\bf Ln}~(z) &amp;= \{\ln~(\vert z\vert e^{i~({\rm arg}~z+2k\pi)})\} \\ &amp;= \{\ln~\vert z\vert+ i({\rm arg}~z+2k\pi)\} \\ &amp;= \{\ln\vert z\vert +i~{\rm arg}~z+2k\pi i:k\in\mathbb{Z}\}. \end{align}\] 幂函数的解析分支 解析函数 \(n\) 次方根的解析分支 THEOREM 2. 设 \(n\geqslant 2\in\mathbb{N}\), \(\Omega\) 为单连通区域, \(z_0\notin\Omega\), \(f(z)\) 在 \(\Omega\) 中解析且处处不为零, 则 \((f(z))^\frac{1}{n}\) 在 \(\Omega\) 上有解析分支 \(g(z)\), 其所有解析分支为 \(g(z)e^{\frac{2k\pi i}{n}}\). 即: \[(f(z))^\frac{1}{n}=\{g(z)e^{\frac{2k\pi i}{n}}: k=0,1,\cdots,n-1\}.\] 即 \((f(z))^\frac{1}{n}\) 在 \(\Omega\) 有 \(n\) 个解析分支. 简略证明: 从三角式的角度考虑也是非常显然的. 细节略去. 解析函数 \(n\) 次方根的解析分支可进一步推广为幂函数的解析分支. 懒得细写了, 以后再说. 幂函数的解析分支 再说吧.. 三角函数 三角函数 只讨论 \(\sin\) 和 \(\cos\): \(2i\sin z=e^{iz}-e^{-iz}\), \(2\cos z=e^{iz}+e^{-iz}\). \(\sin\), \(\cos\) 在复平面上都是解析的. 更一般地, 所有三角函数在有意义的点都是解析的. \(\sin\) 和 \(\cos\) 都以 \(2\pi\) 为周期. \(\sin z\) 的零点为 \(z=n\pi~n\in\mathbb{Z}\). \(\cos z\) 的零点为 \(z=(n+\frac{1}{2})\pi~n\in\mathbb{Z}\). 大部分实数中的结论(如导数, 三角恒等式)都仍然适用. 双曲函数 只讨论 \(\sinh z\) 和 \(\cosh\): \(\sinh z=\frac{e^{z}-e^{-z}}{2}\), \(\cosh z=\frac{e^{z}+e^{-z}}{2}\); 由 \(e^{z}\) 的周期性, 二者都以 \(2\pi i\) 为周期. 反三角函数 反三角函数是多值函数. DEFINITION 2. 反三角函数定义如下: 反正弦函数: \[{\bf Arcsin}~z=\{w\in\mathbb{C}:\sin w=z\};\] 反余弦函数: \[{\bf Arccos}~z=\{w\in\mathbb{C}:\cos w=z\};\] 反正切函数: \[{\bf Arctan}~z=\{w\in\mathbb{C}:\tan w=z\};\] 有如下表示: PROPOSITION 2. 反三角函数有如下表示: \[ \begin{align} {\bf Arcsin}~z &amp;= -i{\bf Ln}(iz+(1-z^2)^\frac{1}{2}), \\ {\bf Arccos}~z &amp;= -i{\bf Ln}(z+(1-z^2)^\frac{1}{2}), \\ {\bf Arctan}~z &amp;= \frac{1}{2i}{\bf Ln}~\frac{1+iz}{1-iz}. \end{align} \]]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>复变函数</tag>
        <tag>保研</tag>
        <tag>保研复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复变函数拾遗[1]——Cauchy定理与最大模原理]]></title>
    <url>%2F2018%2F04%2F11%2F%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E6%8B%BE%E9%81%97-1-%E2%80%94%E2%80%94Cauchy%E9%AB%98%E9%98%B6%E6%B1%82%E5%AF%BC%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[解析函数的积分与Cauchy高阶求导公式. 单连通情形的Cauchy定理 Goursat定理 THEOREM 1. 设 \(\Omega\) 是一个单连通区域, \(f(z)\) 在其中解析, 则 \(f(z)\) 在 \(\Omega\) 中有原函数且对全在 \(\Omega\) 中的任意Jordan闭分段光滑曲线, 都有 \[\int_Cf(z){\rm d}z=0.\] Cauchy高阶求导公式 THEOREM 2. 设 \(\Omega\) 是一个单连通区域, \(C\) 是全在 \(\Omega\) 中的闭Jordan分段光滑曲线, \(C\) 所围区域是 \(\omega\). 如果 \(f(z)\) 在 \(\Omega\) 内解析, 则如下Cauchy公式 \[f(z_0)=\frac{1}{2\pi i}\int_C\frac{f(z){\rm d}z}{z-z_0}\quad (z_0\in\omega).\] 成立, 且对 \(\forall m\in\mathbb{Z}^+\), \(f\) 的 \(m\) 阶复导数 \(f^{(m)}(z)\) 在 \(\Omega\) 内存在并解析, 且如下Cauchy求导公式成立 \[f^{(m)}(z_0)=\frac{1}{2\pi i}\int_C\frac{f(z){\rm d}z}{(z-z_0)^{m+1}}\quad (z_0\in\omega,~m\in\mathbb{Z}^+).\] 简略证明: 只证第一式. 设 \(z_0\in\omega\), 则 \(\exists\epsilon_0&gt;-\), s.t. \(\overline{D(z_0,\epsilon_0)}\subset\omega\), 对 \(\forall\epsilon\in(0,\epsilon_0)\), \(\exists\) 有向线段 \([a,b]\in\overline{\omega}\), 其中 \(a\in\partial D(z_0\epsilon_0)\), \(b\in\partial\omega\). 假设 \(b\) 为 \(C\) 的起点和终点, 则 \[[b\to a]\to\partial D(z_0,\epsilon_0)\to[a\to b]\to[C:b\to b]\] 首尾相接构成一条分段光滑曲线. 由于 \(\frac{f(z)}{z-a}\) 在 \(\Omega\backslash\{z_0\}\) 解析, 故 \[\int_C\frac{f(z)}{z-z_0}{\rm d}z+\int_{[a,b]}\frac{f(z)}{z-z_0}{\rm d}z+\int_{[b,a]}\frac{f(z)}{z-z_0}{\rm d}z-\int_{\partial D(z_0,\epsilon_0)}\frac{f(z)}{z-z_0}{\rm d}z=0.\] 从而 \[\int_C \frac{f(z)}{z-z_0}{\rm d}z=\int_{\partial D(z_0,\epsilon_0)}\frac{f(z)}{z-z_0}{\rm d}z=\int_0^{2\pi} f(z_0+\epsilon e^{i\theta})i{\rm d}\theta\to 2\pi if(z_0)~~(\epsilon\to 0).\] 第二式可由数学归纳法证得. Cauchy积分定理的推广 THEOREM 3. 设 \(C\) 为一条Jordan闭分段光滑曲线, \(\Omega={\rm int}~C\), \(f(z)\) 在闭域 \(\overline{\Omega}=\Omega\cup C\) 解析, 则 \[\int_C f(z){\rm d}z=0.\] 多连通情形的Cauchy定理 多连通情形的Cauchy定理 多连通的情况下, 仍然有如下的Cauchy定理: THEOREM 4. 设 \(\Omega\) 是由复围线(大圈 \(C_0\) 挖掉 \(n\) 个不相交小圈 \(C_i\)) \[\partial\Omega=C_0+C_1^-+\cdots+C_n^-\] 所围成的有界多连通区域, \(f(z)\) 在 \(\overline{\Omega}\) 中解析, 则 \[\int_{\partial\Omega}f(z){\rm d}z=0.\] 多连通情形的Cauchy求导公式 THEOREM 5. 设 \(\Omega\) 是由复围线(大圈 \(C_0\) 挖掉 \(n\) 个不相交小圈 \(C_i\)) \[\partial\Omega=C_0+C_1^-+\cdots+C_n^-\] 所围成的有界多连通区域, \(f(z)\) 在 \(\overline{\Omega}\) 中解析, 则 \[f^{(n)}(z)=\frac{n!}{2\pi i}\int_{\partial\Omega}\frac{f(\zeta){\rm d}\zeta}{(\zeta-z)^{n+1}}\quad (z\in\Omega,~n\in\mathbb{N}).\] Cauchy定理的应用 解析函数均值定理 THEOREM 6. 若函数 \(f(z)\) 在圆盘 \(\vert z-z_0\vert&lt;R\) 中解析, 在闭圆盘 \(\vert z-z_0\vert\leqslant R\) 连续, 则 \[f(z_0)=\frac{1}{2\pi}\int_0^{2\pi} f(z_0+Re^{i\theta}){\rm d}\theta.\] 即在圆心 \(z_0\) 的值为圆周上的平均. 简略证明: 由Cauchy公式, 有 \[f(z_0)=\frac{1}{2\pi i}\int_{\partial D(z_0,r)} \frac{f(z){\rm d}z}{z-z_0}.\] 其中 \(0&lt;r&lt;R\), 而 \(\partial D(z_0,r)\) 的方程为 \(z=z_0+re^{i\theta},~0\leqslant\theta\leqslant\pi\), 从而 \[f(z_0)=\frac{1}{2\pi i}\int_0^{2\pi}\frac{f(z_0+re^{i\theta})rie^{i\theta}{\rm d}\theta}{re^{i\theta}}.\] 由于 \(f(z)\) 在 \(\overline{D(z_0,R)}\) 一致连续, 故令 \(r\to R\) 即可. 推论: Cauchy不等式 THEOREM 7. 设 \(f(z)\) 在 \(\Omega\) 内解析, \(a\in\Omega\), 若 \(\overline{D(a,R)}=\{z:\vert z-a\vert\leqslant R\}\subset\Omega\), 则有 \[\vert f^{(n)}(a)\vert\leqslant\frac{n!M(R)}{R^n}\quad (n\in\mathbb{N}),\] 其中 \[M(R)=\max\{\vert f(z)\vert:\vert z-a\vert=R\}.\] 简略证明: 由TH 2. 有: \[ \begin{align} \vert f^{(n)}(a)\vert &amp;= \left|\frac{n!}{2\pi i}\int_{\partial D(a,R)}\frac{f(z){\rm d}z}{(z-a)^{m+1}}\right| \\ &amp;= \left| \frac{n!}{2\pi}\int_0^{2\pi}\frac{f(a+re^{i\theta}){\rm d}\theta}{r^ne^{in\theta}} \right| \\ &amp;\leqslant \frac{n!M(R)}{R^n}. \\ \end{align} \] Liouville定理 THEOREM 8. 有界整函数必定是常函数. 简略证明: 设 \(f(z)\) 是有界整函数, 则 \(\exists M&gt;0\), s.t. \[\vert f(z)\vert\leqslant M.\] 任取 \(a\in\mathbb{C}\), 则对 \(\forall R&gt;1\), 由Cauchy不等式有: \[\vert f&#39;(a)\vert\leqslant\frac{M}{R^n}.\] 令 \(R\to\infty\), 则 \(f&#39;(a)=0\), 从而 \(f\) 在 \(\mathbb{C}\) 中为常数. 最大模原理 THEOREM 9. 设函数 \(f(z)\) 在有界区域 \(\Omega\) 解析, 并连续到边界 \(\partial\Omega\) 上. 设 \(M=\max\{\vert f(z)\vert: z\in\overline{\Omega}\}\), 则在 \(\Omega\) 内有 \(\vert f(z)\vert&lt;M\), 除非 \(f(z)=Me^{i\alpha}\). 此处 \(M\), \(a\) 为常数. 最大模原理实际上是说: 解析函数必定在边界取最大模.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>复变函数</tag>
        <tag>保研</tag>
        <tag>保研复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文笔记[1]——随机分配问题的PS算法和依次有效性]]></title>
    <url>%2F2018%2F04%2F05%2F%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-1-%E2%80%94%E2%80%94A%20New%20Solution%20to%20the%20Random%20Assignment%20Problem%2F</url>
    <content type="text"><![CDATA[文章: Bogomolnaia A, Moulin H. A New Solution to the Random Assignment Problem[J]. Journal of Economic Theory, 2001, 100(2):295-328. \(n\) 个物品被分配给 \(n\) 个人的问题, 称为分配问题. 生活中此类问题常采取抽签方式解决. 在此基础上可归纳出一种RP算法. 文章对已有的RP算法进行了讨论, 并提出了一种新的分配方法, PS算法. 分配问题 分配问题: \(n\) 个物品被分配给 \(n\) 个人的问题, 称为分配问题. 分配中, 每个人都对这 \(n\) 个东西有一个偏好顺序. 此处假定每个人的偏好关系是严格的, 即每个人对任何两个物品都有一个严格的排序. 随机优先(RP)算法 RP \(n\) 个人随机选定一个选择的顺序, 按照顺序在 \(n\) 个物品中选择. 很容易发现RP算法有以下两点好处: RP算法看起来是比较公平的; RP算法是无操作(Strategyproofness)的, 即大家都会选择说真话. 但用VNM效用函数去分析时, RP算法存在缺陷. VNM效用 设某人得到物品 \(x_i\) 的概率为 \(P_i\), 在得到 \(x_i\) 时的效用为 \(u(x_i)\), 则其VNM效用为 \[U(X)=\sum_i P_i u(x_i)\] 分析可知: 在使VNM效用最大化的意义下, RP算法并不总是最优的. 但RP算法具有如下两个优势: 事后有效 (ex post efficient): 每次分配确定的方案都是Pareto最优的. 即增大某人利益的同时一定会损害其他人的利益. 算法简单: RP算法在分配时, 每一轮只需要考虑一个人的偏好. 概率序列(PS)算法 考虑一个例子: 参与者1, 2: \(a\succ b\succ c\succ d\); 参与者3, 4: \(b\succ a\succ d\succ c\). 则RP算法的概率矩阵为 \(A\)(每行代表一个人, 每列代表一样物品). 然而考虑 \(B\) 可知, 无论效用函数的形式如何, 概率矩阵 \(B\) 都比RP算法得到的结果要好. \[A=\begin{bmatrix}\frac{5}{12}&amp;\frac{1}{12}&amp;\frac{5}{12}&amp;\frac{1}{12}\\ \frac{5}{12}&amp;\frac{1}{12}&amp;\frac{5}{12}&amp;\frac{1}{12}\\ \frac{1}{12}&amp;\frac{5}{12}&amp;\frac{1}{12}&amp;\frac{5}{12}\\ \frac{1}{12}&amp;\frac{5}{12}&amp;\frac{1}{12}&amp;\frac{5}{12}\\ \end{bmatrix},~B=\begin{bmatrix}\frac{1}{2}&amp;0&amp;\frac{1}{2}&amp;0\\ \frac{1}{2}&amp;0&amp;\frac{1}{2}&amp;0\\ 0&amp;\frac{1}{2}&amp;0&amp;\frac{1}{2}\\ 0&amp;\frac{1}{2}&amp;0&amp;\frac{1}{2}\\ \end{bmatrix}\] \(B\) 矩阵的获取可从如下角度考虑: 在分配中, 将每个物品都视为一种食物, 偏好关系表示对食物的喜好. 所有的人同时开始以相同速率(不妨设为1)吃东西. 每个人都会优先吃自己最喜欢的食物. 当一样食物被吃完时, 该食物即被分配给吃该食物量最多的人. PS算法的有效性 形式化定义 设参与者的集合为 \(N\), 物品集合为 \(A\), 集合大小为 \(\vert N\vert=\vert A\vert=n\). 确定性分配与随机性分配 Deterministic Assignment: \(N\to A\) 的一一映射, 可用 \(n\times n\) 的置换矩阵表示. 记这样的分配构成的集合为 \(\mathscr{D}\); Random Allocation: \(A\) 上的概率分布, 可用各个分量和为1的 \(n\) 维向量表示. 记这样的分配构成的集合为 \(\mathscr{L}(A)\); Random Assignment: \(\mathscr{D}\) 上的概率分布, 可用一个 \(n\times n\) 的双随机矩阵(Bistochastic)表示. 即: \[P=[p_{ia}]_{i\in N,a\in A}~~其中~~P=\sum\limits_{\Pi\in D}\lambda_\Pi\cdot\Pi,~\lambda_\Pi\geqslant 0,~\sum_\Pi\lambda_\Pi=1\]矩阵的第 \(i\) 行 \(P_i\) 对应第 \(i\) 个人的Random Allocation. \(p_{ia}\) 表示 \(i\) 得到物品 \(a\) 的概率. 双随机矩阵构成的集合记为 \(\mathscr{R}\). 双随机矩阵可定义为: 每行每列和都为 \(1\) 的矩阵. 如此可得到以下结论: 1. 第 \(i\) 行可视为编号为 \(i\) 的人对于 \(A\) 中物品的效用分布; 2. 第 \(j\) 列可视为 \(N\) 中的每个人得到编号为 \(j\) 的物品的可能性. 效用函数与偏好关系 Preference: 每个参与者对物品都存在一个严格的偏好关系, 即对应于 \(A\) 上的一个序关系 \(\succ_i\). 记所有这样的偏好关系构成的集合为 \(\mathscr{A}\); VNM Utility: 每个参与者拿到 \(A\) 中的一件物品时, 产生的效用可视作 \(A\to\mathbb{R}\) 的函数, 记作 \(u_i\). 效用函数实际上是偏好程度的量化. 称效用函数 \(u_i\) 和偏好关系 \(\succ_i\) 是相容(compatible)的, 如果 \[u_i(a)&gt;u_i(b)\iff a\succ_ib,~\forall a,b\in A.\] 确定性分配的有效性 Priority Assignment: 考虑偏好关系 \(\succ=\{\succ_i\}_{i\in N}\), 设 \(\sigma\) 是 \(N\) 的一个排列, 则按 \(\sigma\) 的顺序进行分配即可得到一个分配方案, 即Priority Assignment. 记作 \(Prio(\sigma,\succ)\); 以下记 \(N\) 的所有排列构成的集合为 \(\theta\). 一个Deterministic Assignment \(\Pi\) 称为有效的, 如果\[\exists\sigma\in\theta,~ \text{s.t.}~ \Pi=Prio(\sigma,\succ).\] 关于确定性分配的有效性, 很容易得到下述引理: LEMMA 1. 给定偏好关系 \(\succ\in\mathscr{A}^N\) 和确定性分配 \(\Pi\), 则下列命题等价: 1. \(\Pi\) 在 \(\mathscr{D}\) 中是Pareto最优的; 2. \(\forall\) 效用函数组 \(u=\{u_i\}\), \(\Pi\) 在 \(\mathscr{R}\) 中对 \(u\) 是Pareto最优的; 3. \(\exists\sigma\in\theta\), s.t. \(\Pi=Prio(\sigma,\succ)\). 随机性分配的有效性 首先定义事前评估有效(ex ante efficient)和事后评估有效(ex post efficient): Definition 1. 给定随机性分配 \(P\in\mathscr{R}\), 偏好关系组 \(\succ\in\mathscr{A}^N\) 和VNM效用函数组 \(u\), 则有定义: 1. \(P\) 对 \(u\) 是事前评估有效的, iff \(P\) 在 \(\mathscr{R}\) 中对 \(u\) 是Pareto最优的; 2. \(P\) 对 \(\succ\) 是事后评估有效的, iff \(P\) 可被表示为有效的deterministic assignments上的概率分布, 即 \(P\) 满足\[P=\sum_{\sigma\in\theta}\mu_\sigma\cdot Prio(\sigma,\succ),~~~\mu_\sigma\geqslant 0,~\sum_{\sigma\in\theta}\mu_\sigma=1.\] 根据上式可知, 所有事后评估有效的分配方案存在一个中心点(natural central point). 这个中心点就是随机优先分配(Random Priority), 即 \[RP(\succ)=\frac{1}{n!}\sum_{\sigma\in\theta}Prio(\sigma,\succ).\] 随机占优关系 考虑 \(A\) 上的序关系 \(\succ_i\), 假设 \(a_1\succ_ia_2\succ_i\cdots\succ_ia_n\). 可如下定义 \(\mathscr{L}(A)\) 上的一个偏序关系 \(sd(\succ_i)\): \[P_i~sd(\succ_i)~Q_i\iff\left\{\sum\limits_{k=1}^tp_{ia_k}\geqslant\sum\limits_{k=1}^tq_{ia_k},~\forall t=1,\cdots,n\right\},~P_i,Q_i\in\mathscr{L}(A).\] 该偏序关系称作随机占优(stochastic dominance). 关于随机占优, 容易得到如下结论: \(\forall P_i,Q_i\in\mathscr{L}(A)\), \(P_i~sd(\succ_i)~Q_i\) iff \(\forall\) 与 \(\succ_i\) 相容的 \(u_i\), 总有 \[u_i\cdot P_i\geqslant u_i\cdot Q_i.\] 进一步可以将随机占优关系推到 \(\mathscr{R}\) 上: DEFINITION 2. 给定偏好 \(\succ\), \(P,Q\in\mathscr{R}\), 称 \(Q\) 随机占优于 \(P\)(\(P\) is stochastically dominated by \(Q\)), 如果 \[Q_i~sd(\succ_i)~P_i,~\forall i~且~Q\neq P\] 依次有效性 给定偏好关系 \(\succ\), 称 \(P\in\mathscr{R}\) 是依次有效的, 如果不存在 \(Q\in\mathscr{R}\), s.t. \(Q\) 随机占优于 \(P\). 依次有效性与事前/事后评估有如下关系: LEMMA 2. 给定一个Random Assignment \(P\in\mathscr{R}\), 一个偏好关系 \(\succ\), 和一组与 \(\succ\) 相容的效用函数 \(u\), 则有: 1. 若 \(P\) 对 \(u\) 是事前评估有效的, 则 \(P\) 对 \(\succ\) 是依次有效的. (逆命题在 \(n=2\) 时成立, \(n\geqslant 3\) 时可能失效); 2. 若 \(P\) 对 \(\succ\) 是依次有效的, 则 \(P\) 对 \(\succ\) 是事后评估有效的. (逆命题在 \(n\leqslant 3\) 时成立, \(n\geqslant 4\) 时可能失效). 进食算法 在PS算法处已经实际上介绍了进食算法: SIMULTANEOUS EATING ALGORITHM 给定偏好关系 \(\succ\) 和一组函数 \(\{\omega_i(t)\}_{i\in N}\), s.t. \(\omega_i(t)\geqslant 0\), 且 \(\int_0^1\omega_i(t){\rm d}t=1\), 表示进食的速度. 所有的人按照自己的偏好关系开始进食, 并且在每个时刻, 每个参与者都吃自己当前最想吃并且有剩余的物品. 进食算法的依次有效性 依次有效的条件 在 \(\mathscr{R}\) 上可如下定义一个二元关系 \(\tau\): DEFINITION 2. 给定一个 Random Assignment \(P\in\mathscr{R}\) 和偏好关系 \(\succ\), 如下定义 \(\tau\): \[a\tau(P,\succ)b\iff \exists i\in N,~s.t.~a\succ_ib,~p_{ib}&gt;0.\] \(a\tau b\) 其实表示的是: 存在一个 \(i\), 比起 \(b\) 更喜欢 \(a\), 但有可能会得到 \(b\). 根据二元关系 \(\tau\) 可得到依次有效的等价条件: LEMMA 3. 一个Random Assignment \(P\in\mathscr{R}\) 是依次有效的, iff \(\tau(P,\succ)\) 无环(acyclic). 其证明并不困难: 充分性: 假设有一个环, 沿着环转一圈即可得到一个随机占优于 \(P\) 的Assignment. 必要性: 假设存在 \(Q\) 随机占优于 \(P\), 则可直接得到一个 \(\tau\) 的环. 进食算法的依次有效性 进食算法是依次有效的. 其证明也很简单, 直接利用引理 1即可. 假设进食算法不是依次有效的, 则 \(\tau\) 存在环: \[a_0\tau a_1\tau\cdots \tau a_k\tau a_0.\] 于是按照算法, 有如下命题: \(i_0\) 开始吃 \(a_1\) 的时候, \(a_0\) 已经被吃完, 故 \(a_0\) 比 \(a_1\) 更早被开始吃; \(i_1\) 开始吃 \(a_2\) 的时候, \(a_1\) 已经被吃完, 故 \(a_1\) 比 \(a_2\) 更早被开始吃; \(\cdots\cdots\) \(i_k\) 开始吃 \(a_0\) 的时候, \(a_k\) 已经被吃完, 故 \(a_k\) 比 \(a_0\) 更早被开始吃. 这显然是一个矛盾. 进食算法的有效性由下列定理给出: THEOREM 1. 给定偏好关系 \(\succ\in\mathscr{A}^N\), 对于任一组进食速率函数 \(\omega=\{\omega_i\}_{i\in N}\), Random Assignment \(P_\omega(\succ)\) 总是依次有效的. 反过来, 对于任一个对 \(\succ\) 依次有效的Random Assignment \(P\), 存在一组进食速率函数 \(\omega=\{\omega_i\}_{i\in N}\), s.t. \(P=P_\omega(\succ)\). PS算法 至此我们可以严格地定义PS算法: DEFINITION 4. 满足 \(\omega_i(t)\equiv 1,~\forall t\in[0,1],~\forall i\in N\) 的进食算法即为PS算法. 记作 \(PS(\succ)\). PS算法有如下两条性质: PS算法是依次有效的, 由定理1即得; PS算法是匿名的, 即对于 \(n\) 个人的身份对称. 关于以上的(2), 有如下引理: LEMMA 4. 给定一组进食速率函数 \(\omega=(\omega_1,\cdots,\omega_n)\), \(P\) 是由 \(\omega\) 生成的分配机制(mechanism). 则 \(P\) 是匿名的当且仅当 \(P\) 是PS算法. RP算法与PS算法的比较 略去文中的例子, 直接不加证明地给出文中的结论: 无嫉妒性 无嫉妒性(envy-free)定义如下: DEFINITION 4. 称Random Assignment \(P\in\mathscr{R}\) 是无嫉妒/弱无嫉妒(envy-free/weak envy-free)的, 当且仅当对 \(\forall i,j\in N\), 总有: 无嫉妒 \(P_i~sd(\succ_i)~P_j\) 弱无嫉妒 \(P_j~sd(\succ_i)~P_j\Rightarrow P_i=P_j\) 无操作性 无操作性(strategyproofness)定义如下: DEFINITION 5. 称一个分配机制 \(P(\cdot)\) 是无操作/弱无操作(strategyproofness/weak strategyproofness)的, 当且仅当对 \(\forall i,j\in N\), 总有: 无操作 \(P_i(\succ)~sd(\succ_i)~P_i(\succ\vert^i\succ_i^*)\) 弱无操作 \(P_i(\succ\vert^i\succ_i^*)~sd(\succ_i)~P_i(\succ)\Rightarrow P_i(\succ)=P_i(\succ\vert^i\succ_i^*)\) PS与RP的比较 对任意的偏好关系 \(\succ\in\mathscr{A}^N\), PS与RP的关系如下: 无嫉妒性 无操作性 RP 弱无嫉妒 无操作 PS 无嫉妒 弱无操作]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>数学</tag>
        <tag>北大</tag>
        <tag>论文笔记</tag>
        <tag>保研</tag>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北京大学数学科学学院2018年直博生考试题目]]></title>
    <url>%2F2018%2F04%2F01%2F%E5%8C%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E6%95%B0%E5%AD%A6%E7%A7%91%E5%AD%A6%E5%AD%A6%E9%99%A22018%E5%B9%B4%E7%9B%B4%E5%8D%9A%E7%94%9F%E8%80%83%E8%AF%95%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[分为分析, 代数, 几何三部分. 满分200分. 分析部分 四题. 共100分. (1.1) (10分) 证明隐函数 \[y+\sin(xy)-x=0\] 在 \(x=0\) 附近可以确定一个函数关系 \(y=f(x)\). (1.2) (5分) 试简单回答该函数的光滑度(不必证明). (1.3) (10分) 求 \(f(x)\) 在 \(x=0\) 处的三阶导数 \(f&#39;&#39;&#39;(0)\). (2.1) (10分) 叙述积分第一中值定理并给出一个几何解释. (2.2) (10分) 叙述一个函数 \(g(x)\equiv 1\) 另一个函数 \(f(x)\) 单调时的积分第二中值定理(三种情况), 并给出一个几何解释. (2.3) (5分) 请问上问中函数 \(f(x)\) 的单调性是实质性条件还是技术性条件. 如果是实质性的, 其本质是什么? 如果是技术性的, 在哪些方面提供了方便. (25分) 在考虑函数 \(f(x)\) 在给定区间上的Fourier级数 \[\sum a_n\sin nx+b_n\cos nx\] 的收敛性时, \(f(x)\) 的光滑性与级数的收敛速度之间有没有一定的关系? 给出自己的理解和描述. (4.1) (10分) 试讨论广义积分 \[\int_\mathbb{R}\frac{\sin x}{x}{\rm d}x\] 的收敛性. (4.2) (10分) 试讨论广义重积分 \[\iint_D\frac{\sin x}{x}{\rm d}x{\rm d}y,\quad D=\{\mathbb{R}\times[0,1]\}\] 的敛散性. (4.3) (5分) 请对上述结果做出一个你认为合理且本质的解释. 代数部分 三题, 共70分. (20分) 求集合 \[\{A\in M_{7\times 7}(\mathbb{R}): A^3=0\}\] 中矩阵秩的最大值. (30分) 设 \(V\) 是有限维实内积空间, \(\alpha_1,\cdots,\alpha_r,\beta_1,\cdots,\beta_r\in V\), 假设存在非零向量 \(\alpha\in V\), s.t. \[\sum\limits_{i=1}^r\langle\alpha,\alpha_i\rangle\beta_i=0.\]证明存在非零向量 \(\beta\in V\), s.t. \[\sum\limits_{i=1}^r\langle\beta,\beta_i\rangle\alpha_i=0.\] (30分) 证明对任意 \(3\times 3\) 复矩阵 \(A\), 存在 \(3\times 3\) 酉矩阵 \(U\), s.t. \(UAU^{-1}\) 为形如 \[\begin{bmatrix}*&amp;0&amp;*\\ *&amp;*&amp;0\\ *&amp;0&amp;*\\ \end{bmatrix}\] 的矩阵. 几何部分 一题, 共30分 (30分) 对于空间仿射坐标系中的马鞍面 \(S: z=xy\), 记 \(G\) 为所有保持 \(S\) 作为点集不变的空间仿射变换构成的群, 试决定空间中所有的直线 \(L\), s.t. 对于任意 \(G\) 中的变换 \(g\), \(g(L)\) 都与 \(L\) 平行或重合.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>数学</tag>
        <tag>北大</tag>
        <tag>各种试卷</tag>
        <tag>数学分析</tag>
        <tag>线性代数</tag>
        <tag>保研</tag>
        <tag>解析几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北京大学数学科学学院2016年直博生考试题目]]></title>
    <url>%2F2018%2F04%2F01%2F%E5%8C%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E6%95%B0%E5%AD%A6%E7%A7%91%E5%AD%A6%E5%AD%A6%E9%99%A22016%E5%B9%B4%E7%9B%B4%E5%8D%9A%E7%94%9F%E8%80%83%E8%AF%95%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[分为分析, 代数, 几何三部分. 满分200分. 分析部分 (30分, 每小题15分) 若 \(f(x)\) 在实轴可导且 \(f&#39;(x)&gt;f(x)\), \(\forall x\in\mathbb{R}\), 则 \(f\) 至多有一个零点. 若 \(f(x)\) 在实轴可导且 \(f&#39;&#39;(x)&gt;f(x)\), \(\forall x\in\mathbb{R}\), 则 \(f\) 至多有两个零点. (30分) 假设 \(\phi(x,y,z)\) 是原点 \(O\) 某个邻域的 \(C^\infty\) 函数, 且 \(\phi\), \(\phi_x\), \(\phi_y\), \(\phi_{xz}\), \(\phi_{yz}\) 在原点为 \(0\), \(\phi_{xx}\), \(\phi_{yy}\) 在原点为 \(1\), \(\phi_{xy}(O)=\frac{1}{2}\), \(\phi_z(O)=-\frac{1}{2}\). \(\phi(x,y,z)=0\) 确定的的隐函数记为 \(z=z(x,y)\) (已知 \(z(0,0)=0\)). 请讨论 \(z=z(x,y)\) 在 \((0,0)\) 附近的极值问题. (40分) 设 \(z=z(x,y)\) 是上题中的隐函数, \(\Omega_\delta\) 是 \((0,0)\) 点的 \(\delta\) 邻域, 当 \(\delta\) 充分小时, 证明下列极限存在并求值: \[\lim\limits_{t\to+\infty} t\iint_{\Omega_\delta}e^{-tz(x,y)}{\rm d}x{\rm d}y.\] 代数部分 (20分) 设 \(A\) 是一个 \(2\) 阶复方阵, 考虑二阶复方阵的线性空间 \(M_2(\mathbb{C})\) 上的线性变换 \[\phi_A: M_2(\mathbb{C})\to M_2(\mathbb{C}),~X\mapsto AX-XA.\]试确定 \(\dim({\rm Ker}(\phi_A))\) 的所有可能值. (20分) 对于有理数域 \(\mathbb{Q}\) 上的两个 \(n\) 阶方阵 \[A=\begin{bmatrix}0&amp;1&amp;\cdots&amp;1\\ 0&amp;0&amp;\ddots&amp;\vdots\\ \vdots&amp;\ddots&amp;\ddots&amp;1\\ 0&amp;\cdots&amp;0&amp;0\\ \end{bmatrix},~B=\begin{bmatrix}0&amp;0&amp;\cdots&amp;0\\ 1&amp;0&amp;\ddots&amp;\vdots\\ \vdots&amp;\ddots&amp;\ddots&amp;0\\ 1&amp;\cdots&amp;1&amp;0\\ \end{bmatrix}\]证明二者相似, 并求矩阵 \(T\), s.t. \(A=T^{-1}BT\). (20分) \(\mathbb{R}[x]\) 中有多项式 \[f(x)=x^4+a_1x^3+a_2x^2+a_3x+a_4,\] 试用系数 \(a_1\sim a_4\) 的关系式给出 \(f(x)\) 能表达成某不可约二次多项式 \(g(x)\) 平方的充要条件. 几何部分 (30分) 欧式平面上保定向的等距变换群的一个子群 \(G\), 其中每一个非恒同的变换 \(g\) 都没有不动点, 且每一个平面上的点 \(p\) 在 \(G\) 作用下的轨道在平面上都没有聚点. 试证明 \(G\) 可由一个或两个平移变换生成.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>数学</tag>
        <tag>北大</tag>
        <tag>各种试卷</tag>
        <tag>数学分析</tag>
        <tag>线性代数</tag>
        <tag>保研</tag>
        <tag>解析几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学分析拾遗[5]——多元函数的极值]]></title>
    <url>%2F2018%2F03%2F28%2F%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E6%8B%BE%E9%81%97-5-%E2%80%94%E2%80%94%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%81%E5%80%BC%2F</url>
    <content type="text"><![CDATA[多元函数的极值问题: 通常极值与条件极值 通常极值 定理 设函数 \(f(\boldsymbol{x})=f(x_1,\cdots,x_n)\) 在区域 \(D\subset\mathbb{R}^n\) 内具有二阶连续偏导数, 且 \(f&#39;(\boldsymbol{x}_0)\) \((\boldsymbol{x}_0\in D)\), 再设 \(f(\boldsymbol{x})\) 在 \(\boldsymbol{x}_0\) 处的Hessi矩阵满秩, 则 (1) 当 \(\boldsymbol{H}_f(\boldsymbol{x}_0)\) 正定时, \(f(\boldsymbol{x})\) 在 \(\boldsymbol{x}_0\) 取极小值; (2) 当 \(\boldsymbol{H}_f(\boldsymbol{x}_0)\) 负定时, \(f(\boldsymbol{x})\) 在 \(\boldsymbol{x}_0\) 取极大值; (3) 当 \(\boldsymbol{H}_f(\boldsymbol{x}_0)\) 不定时, \(f(\boldsymbol{x})\) 在 \(\boldsymbol{x}_0\) 不是极值; Hessi矩阵定义如下: \[\boldsymbol{H}_f(\boldsymbol{x}_0)=\begin{bmatrix}\frac{\partial f(\boldsymbol{x}_0)}{\partial x_1^2} &amp; \frac{\partial f(\boldsymbol{x}_0)}{\partial x_1\partial x_2} &amp; \cdots &amp; \frac{\partial f(\boldsymbol{x}_0)}{\partial x_1\partial x_n}\\ \frac{\partial f(\boldsymbol{x}_0)}{\partial x_2\partial x_1} &amp; \frac{\partial f(\boldsymbol{x}_0)}{\partial x_2^2} &amp; \cdots &amp; \frac{\partial f(\boldsymbol{x}_0)}{\partial x_2\partial x_n}\\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\ \frac{\partial f(\boldsymbol{x}_0)}{\partial x_n\partial x_1} &amp; \frac{\partial f(\boldsymbol{x}_0)}{\partial x_n\partial x_1} &amp; \cdots &amp; \frac{\partial f(\boldsymbol{x}_0)}{\partial x_n^2}\\ \end{bmatrix}.\] 条件极值 定理 设函数 \(f(\boldsymbol{x})\), \(\boldsymbol{\varphi}(\boldsymbol{x})=(\varphi_1(\boldsymbol{x}),\cdots,\varphi_m(\boldsymbol{x}))\) 在区域 \(D\subset\mathbb{R}^n~(m&lt;n)\) 内具有各个连续偏导数, 再设 \(\boldsymbol{x}_0=(x_1^0,\cdots,x_n^0)\in D\) 为 \(f(\boldsymbol{x})\) 在约束条件 \[\begin{cases}\varphi_1(\boldsymbol{x})=0,\\ \varphi_2(\boldsymbol{x})=0,\\ \cdots\cdots\\ \varphi_m(\boldsymbol{x})=0.\end{cases}\] 下的极值点, 且 \(\boldsymbol{\varphi}&#39;(\boldsymbol{x}_0)\) 的秩为 \(m\), 则存在常数 \(\lambda_1,\cdots,\lambda_m\in\mathbb{R}\), s.t. 在 \(\boldsymbol{x}_0\) 处有如下等式成立: \[\begin{cases} \frac{\partial f(\boldsymbol{x}_0)}{\partial x_i}+\sum\limits_{j=1}^m \lambda_j\frac{\partial \varphi_j(\boldsymbol{x}_0)}{\partial x_i}=0, &amp; i=1,2,\cdots,n, \\ \varphi_j(\boldsymbol{x}_0)=0, &amp; j=1,2,\cdots,m. \end{cases}\] Lagrange乘数法 构造函数 \[F(x_1,\cdots,x_n,\lambda_1,\cdots,\lambda_m)=f(\boldsymbol{x})+\sum_{j=1}^m\lambda_j\varphi_j(\boldsymbol{x}),\] 则 \(\boldsymbol{x}_0\) 是极值点的必要条件如下: \[\begin{cases}\frac{\partial F(\boldsymbol{x}_0)}{\partial x_i}=0 &amp; (i=1,2,\cdots,n),\\ \frac{\partial F(\boldsymbol{x}_0)}{\partial\lambda_j}=0 &amp; (j=1,2,\cdots,m).\\ \end{cases}\]]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数学分析</tag>
        <tag>保研</tag>
        <tag>保研复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学分析拾遗[4]——含参广义积分的一致收敛]]></title>
    <url>%2F2018%2F03%2F27%2F%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E6%8B%BE%E9%81%97-4-%E2%80%94%E2%80%94Abel%E5%88%A4%E5%88%AB%E6%B3%95%E4%B8%8EDirichlet%E5%88%A4%E5%88%AB%E6%B3%95%2F</url>
    <content type="text"><![CDATA[含参广义积分一致收敛性的常用判断方法是M判别法, 但M判别法太强, 适用面窄. 故在被积函数取绝对值后不一致收敛时, 常用以下的两种判别法: Abel判别法; Dirichlet判别法. M判别法 定理 若 \(\exists M(x)\), s.t. (1) \(\int_a^{+\infty}M(x){\rm d}x\) 一致收敛. (2) \(M\) 有界, 即 \[\vert f(x,y)\vert\leqslant M(x)~~~(\forall x\geqslant a,~\forall y\in I),\] 则 \(\int_a^{+\infty} f(x,y){\rm d}x\) 在 \(I\) 绝对一致收敛. Abel判别法 定理 若 \(\exists g,h\), s.t. (1) \(\int_a^{+\infty} g(x,y){\rm d}x\) 对 \(y\in I\) 一致收敛; (2) \(h(x,y)\) 当 \(y\) 固定时, 对 \(x\) 单调, 且一致有界, 即 \(\exists M\)&gt;0, s.t. \[\vert h(x,y)\vert\leqslant M~~(\forall x\geqslant a, \forall y\in I).\] 则 \(\int_a^{+\infty}f(x,y){\rm d}x\) 在 \(I\) 一致收敛. Dirichlet判别法 定理 若 \(\exists g,h\), s.t. (1) \(\int_a^{A} g(x,y){\rm d}x\) 一致有界, 即 \(\exists M&gt;0\), s.t. \[\left|\int_a^A g(x,y){\rm d}x\right|\leqslant M~~~(\forall A\geqslant a, \forall y\in I);\] (2) \(h(x,y)\) 当 \(y\) 固定时, 对 \(x\) 单调, 且当 \(x\to +\infty\) 时, \[h(x,y)\rightrightarrows0.\] 则 \(\int_a^{+\infty}f(x,y){\rm d}x\) 在 \(I\) 一致收敛.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数学分析</tag>
        <tag>保研</tag>
        <tag>保研复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性代数拾遗[2]——Jordan标准形]]></title>
    <url>%2F2018%2F03%2F22%2F%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%8B%BE%E9%81%97-2-%E2%80%94%E2%80%94Jordan%E6%A0%87%E5%87%86%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Jordan标准形相关理论: \(\lambda\) 矩阵, 初等因子, 不变因子. 默认已经了解了Jordan标准形的相关定义. Jordan标准形定理 Jordan标准形定理是线性代数里最深刻的结果 定理 复数域上任意一个 \(n\) 阶方阵 \(A\) 都相似于一个Jordan标准形. 即 \(\forall A\in\mathbb{C}^{n\times n}\), \(\exists\) 可逆阵 \(P\), s.t. \[P^{-1}AP=\begin{bmatrix}J_{m_1}(\lambda_1)&amp;&amp;\\ &amp;\ddots&amp;\\ &amp;&amp;J_{m_s}(\lambda_s)\end{bmatrix},\] 其中 \(J_{m_t}(\lambda_t)\) \((t=1,\cdots,s)\) 为 \(A\) 的特征\(\lambda\)矩阵 \(\lambda I-A\) 的初等因子 \((\lambda-\lambda_t)^{m_t}\) 所对应的 \(m_t\) 阶Jordan块 \[\begin{bmatrix}\lambda_t&amp;1&amp;0&amp;\cdots&amp;0\\ &amp;\lambda_t&amp;1&amp;\ddots&amp;\vdots\\ &amp;&amp;\ddots&amp;\ddots&amp;0\\ &amp;&amp;&amp;\lambda_t&amp;1\\ &amp;&amp;&amp;&amp;\lambda_t\\ \end{bmatrix}_{m_t\times m_t}.\] 在不考虑Jordan块顺序的情况下, Jordan标准形是唯一的. \(\lambda-\) 矩阵 \(\lambda-\) 矩阵 定义 设 \(F\) 是一个数域, \(\lambda\) 是一个未定元, \(f_{ij}(\lambda)\in F[\lambda]\), \(i=1,\cdots,m\), \(j=1,\cdots,n\). 一元多项式环 \(F[\lambda]\) 上的矩阵 \[\begin{bmatrix}f_{11}(\lambda)&amp;f_{12}(\lambda)&amp;\cdots&amp;f_{1n}(\lambda)\\ f_{21}(\lambda)&amp;f_{22}(\lambda)&amp;\cdots&amp;f_{2n}(\lambda)\\ \vdots&amp;\vdots&amp;&amp;\vdots\\ f_{m1}(\lambda)&amp;f_{m2}(\lambda)&amp;\cdots&amp;f_{mn}(\lambda)\\ \end{bmatrix}\] 是一个 \(\lambda-\) 矩阵. \(\lambda-\) 矩阵的初等变换 交换两行/两列; 用一个非零常数乘某行/某列; 用一个多项式 \(g(\lambda)\) 乘以某一行/列加到另一行/列上. \(\lambda-\) 矩阵的等价标准形 定理 任一个非零的 \(m\times n\) 的 \(\lambda-\) 矩阵 \(A(\lambda)\) 都可以变换成以下形式的一个矩阵 \[\begin{bmatrix}D(\lambda)_{r\times r}&amp; \\ &amp;0\\ \end{bmatrix}\] 其中 \[D(\lambda)_{r\times r}=\begin{bmatrix}d_1(\lambda)&amp;&amp;&amp;\\ &amp;d_2(\lambda)&amp;&amp;\\ &amp;&amp;\ddots&amp;\\ &amp;&amp;&amp;d_r(\lambda)\\ \end{bmatrix}\] 其中 \(r={\rm rank}A(\lambda)\), \(d_i\) 是首一多项式, 且满足 \[d_i(\lambda)\vert d_{i+1}(\lambda),~i=1,2,\cdots,r-1.\] 这样的矩阵被称为 \(A(\lambda)\) 的等价标准形. 不变因子和初等因子 行列式因子 定义 定义 设 \(A(\lambda)\) 是 \(m\times n\) 的 \(\lambda-\) 矩阵. 对于 \(k\leqslant \min\{m,n\}\), \(A(\lambda)\) 的所有 \(k\) 阶子式的首一最大公因式 \(D_k(\lambda)\) 称为 \(A(\lambda)\) 的 \(k\) 阶行列式因子. 性质 行列式因子在 \(\lambda-\) 矩阵的初等变换下不变. 上条可直接推出 \(\lambda-\) 矩阵的等价标准形是唯一的. 不变因子 定义 定义 \(\lambda-\) 矩阵 \(A(\lambda)\) 对角线的非零元素 \(d_i(\lambda)\), \((i=1,\cdots,r)\) 称为 \(A(\lambda)\) 的不变因子. 与行列式因子的关系 不变因子与行列式因子有如下关系: \[d_1(\lambda)=D_1(\lambda),d_2(\lambda)=\frac{D_2(\lambda)}{D_1(\lambda)},\cdots,d_r(\lambda)=\frac{D_r(\lambda)}{D_{r-1}(\lambda)}\] 初等因子 定义 设 \(n\) 阶 \(\lambda-\) 矩阵 \(A(\lambda)\) 的不变因子 \(d_1,\cdots,d_r\) 的标准分解为 \[d_1(\lambda)=p_1(\lambda)^{k_{11}}p_2(\lambda)^{k_{12}}\cdots p_s(\lambda)^{k_{1s}},\] \[d_2(\lambda)=p_1(\lambda)^{k_{21}}p_2(\lambda)^{k_{22}}\cdots p_s(\lambda)^{k_{2s}},\] \[\cdots\cdots\cdots\cdots\] \[d_r(\lambda)=p_1(\lambda)^{k_{r1}}p_2(\lambda)^{k_{r2}}\cdots p_s(\lambda)^{k_{rs}},\] 其中 \(r={\rm rank}A(\lambda)\), \(p_i(\lambda)\) 是两两不同的首一不可约多项式, 且 \[0\leqslant k_{1i}\leqslant k_{2i}\leqslant \cdots\leqslant k_{ri},~i=1,2,\cdots,s.\] 分解式中的 \(p_i(\lambda)\) 的非零次幂, 叫做 \(A(\lambda)\) 的初等因子. 当 \(F=\mathbb{C}\) 时, \(p_i(\lambda)\) 都是形如 \(\lambda-\lambda_i\) 的一次因式. Jordan标准形的求法: \(\lambda-\) 矩阵 \(\lambda-\) 矩阵法 按照以下步骤进行: 1. 求出\(A\) 的特征 \(\lambda-\) 矩阵 直接求 \(\lambda I-A\) 即可. 2. 求 \(\lambda I-A\) 的等价标准形 利用 \(\lambda-\) 矩阵的初等变换求出 \(\lambda I-A\) 的等价标准形, 记为 \[\begin{bmatrix}d_1(\lambda)&amp;&amp;&amp;\\ &amp;d_2(\lambda)&amp;&amp;\\ &amp;&amp;\ddots&amp;\\ &amp;&amp;&amp;d_n(\lambda)\\ \end{bmatrix}\] 则 \(d_i(\lambda)\) 是 \(A\) 的不变因子. 3. 根据初等因子求Jordan块 对 \(d_i(\lambda)\) 进行标准分解\[d_i(\lambda)=(\lambda-\lambda_{i_1})^{m_{i_1}}(\lambda-\lambda_{i_2})^{m_{i_2}}\cdots (\lambda-\lambda_{i_t})^{m_{i_t}}\] 其中 \(\lambda_{i_j}\) 互不相等, 则在 \(A\) 的Jordan标准形中, \(d_i(\lambda)\) 所对应的 \(t\) 个Jordan块分别为 \[J_{m_{i_1}}(\lambda_{i_1}),J_{m_{i_2}}(\lambda_{i_2}),\cdots,J_{m_{i_t}}(\lambda_{i_t}).\] 一个例子 题目内容 题目 求 \[\begin{bmatrix}-1&amp;-2&amp;6\\ -1&amp;0&amp;3\\ -1&amp;-1&amp;4\\ \end{bmatrix}\] 的Jordan标准形. 简略解答 特征 \(\lambda-\) 矩阵为 \[\lambda I-A=\begin{bmatrix}\lambda+1&amp;2&amp;-6\\ 1&amp;\lambda&amp;-3\\ 1&amp;1&amp;\lambda-4\\ \end{bmatrix}\] 初等变换得到其等价标准形为 \[\begin{bmatrix}1&amp;0&amp;0\\ 0&amp;\lambda-1&amp;0\\ 0&amp;0&amp;(\lambda-1)^2\\ \end{bmatrix}\] 不变因子为 \(\lambda-1\), \((\lambda-1)^2\), 于是初等因子为 \(\lambda-1\), \((\lambda-1)^2\), 故 \(A\) 有一个一阶块, 一个二阶块. 其Jordan标准形为 \[\begin{bmatrix}1&amp;0&amp;0\\ 0&amp;1&amp;1\\ 0&amp;0&amp;1\\ \end{bmatrix}.\] Jordan标准形的求法: 空间分解 累死, 以后再写== 参考资料 王卿文. 线性代数核心思想及应用[M]. 科学出版社, 2012. 丘维声. 高等代数-第2版[M]. 高等教育出版社, 2002. 王萼芳. 高等代数教程.下册[M]. 清华大学出版社, 1997. 霍元极. 高等代数[M]. 北京师范大学出版社, 2009.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
        <tag>保研</tag>
        <tag>保研复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性代数拾遗[1]——分块矩阵]]></title>
    <url>%2F2018%2F03%2F22%2F%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%8B%BE%E9%81%97-1-%E2%80%94%E2%80%94%E5%88%86%E5%9D%97%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[分块矩阵的几个应用: 特征多项式降阶定理(Sylvester公式); 秩的第一和第二降阶定理; Sylvester不等式和Frobenius不等式. 一个例子 特征多项式降阶定理 定理内容 定理 设 \(A\) 是 \(m\times n\) 矩阵, \(B\) 是 \(n\times m\) 矩阵, 且 \(m\geqslant n\), 则 \[\vert\lambda I_m-AB\vert=\lambda^{m-n}\vert\lambda I_n-BA\vert.\] 简略证明 考虑到等式左右的行列式形式, 构造分块矩阵 \[\begin{bmatrix}\lambda I_m &amp; A \\ B &amp; I_n \\ \end{bmatrix},\] 然后构造广义初等矩阵: \[\begin{bmatrix}I_m &amp; -A \\ 0 &amp; I_n\\ \end{bmatrix},\begin{bmatrix}I_m &amp; -\frac{1}{\lambda}A \\ 0 &amp; I_n \\ \end{bmatrix}.\] 则有 \[\begin{bmatrix}I_m &amp; -A \\ 0 &amp; I_n\\ \end{bmatrix}\begin{bmatrix}\lambda I_m &amp; A \\ B &amp; I_n \\ \end{bmatrix}=\begin{bmatrix}\lambda I_m-AB &amp; 0 \\ B &amp; I_n \\ \end{bmatrix}\] \[\begin{bmatrix}\lambda I_m &amp; A \\ B &amp; I_n \\ \end{bmatrix} \begin{bmatrix}I_m &amp; -\frac{1}{\lambda}A \\ 0 &amp; I_n \\ \end{bmatrix}=\begin{bmatrix}\lambda I_m &amp; 0 \\ B &amp; I_n-\frac{1}{\lambda}BA \\ \end{bmatrix}\] 取行列式, 即有: \[\vert \lambda I_m-AB\vert=\begin{vmatrix}\lambda I_m &amp; A \\ B &amp; I_n \\ \end{vmatrix}=\vert\lambda I_m\vert\vert I_n-\frac{1}{\lambda}BA\vert.\] 其他形式 为了应用上的方便, 常写为 \[\vert\lambda I_m+AB\vert=\lambda^{m-n}\vert\lambda I_n+BA\vert.\] 秩的第一降阶定理 定理内容 定理 设 \(A\) 可逆, \(\begin{bmatrix}A&amp;B\\C&amp;D\\\end{bmatrix}\) 是 \(m\times n\) 矩阵, 则 \[r\begin{bmatrix}A&amp;B\\C&amp;D\\\end{bmatrix}=r(A)+r(D-CA^{-1}B).\] 简略证明 构造广义初等矩阵: \[\begin{bmatrix}I&amp;0\\ -CA^{-1}&amp;I\\ \end{bmatrix},\begin{bmatrix}I&amp;-A^{-1}B\\ 0&amp;I\\ \end{bmatrix}.\] 则 \[\begin{bmatrix}I&amp;0\\ -CA^{-1}&amp;I\\ \end{bmatrix} \begin{bmatrix}A&amp;B\\C&amp;D\\\end{bmatrix} \begin{bmatrix}I&amp;-A^{-1}B\\ 0&amp;I\\ \end{bmatrix}=\begin{bmatrix}A&amp;0\\ 0&amp;D-CA^{-1}B\\ \end{bmatrix}\] 于是 \[r\begin{bmatrix}A&amp;B\\C&amp;D\\\end{bmatrix}=r\begin{bmatrix}A&amp;0\\ 0&amp;D-CA^{-1}B\\ \end{bmatrix}=r(A)+r(D-CA^{-1}B).\] 秩的第二降阶定理 定理内容 定理 设 \(A\), \(D\) 分别是 \(m\) 阶与 \(n\) 阶可逆矩阵, \(B\), \(C\) 分别是 \(m\times n\) 和 \(n\times m\) 矩阵, 则 \[r(D-CA^{-1}B)=r(D)-r(A)+r(A-BD^{-1}C).\] 简略证明 思路与第一降阶定理完全相同, 略去. Sylverster不等式 \[\min\{r(A),r(B)\}\geqslant r(AB)\geqslant r(A)+r(B)-n.\] 定理内容 定理 设 \(A\), \(B\) 分别是 \(m\times n\) 和 \(n\times l\) 矩阵, 则 \[r(AB)\geqslant r(A)+r(B)-n.\] 简略证明 证法一 由第一降阶定理, 有: \[\begin{align} r(AB) &amp;= r(0+AI_n^{-1}B)=r\begin{bmatrix}I_n&amp;B\\ -A&amp;0\\ \end{bmatrix}-r(I_n) \\ &amp;= r\begin{bmatrix}I_n&amp;B\\ -A&amp;0\\ \end{bmatrix}-n \\ &amp;\geqslant r(A)+r(B)-n. \end{align}\] 证法二 构造分块矩阵: \[\begin{bmatrix}A&amp;0\\ I&amp;B\\ \end{bmatrix},\] 则有 \[\begin{align} r(A)+r(B) &amp;\leqslant r\begin{bmatrix}A&amp;0\\ I&amp;B\\ \end{bmatrix}=r\begin{bmatrix}0&amp;-AB\\ I&amp;0\\ \end{bmatrix}\\ &amp;= r(I)+r(AB). \end{align}\] Frobenius不等式 定理内容 定理 \[r(ABC)\geqslant r(AB)+r(BC)-r(B).\] 简略证明 考虑变换: \[\begin{bmatrix}ABC&amp;0\\ 0&amp;B\\ \end{bmatrix}\to\begin{bmatrix}ABC&amp;AB\\ 0&amp;B\\ \end{bmatrix}\to\begin{bmatrix}0&amp;AB\\ -BC&amp;B\\ \end{bmatrix}\] 故有: \[r(ABC)+r(B)=r\begin{bmatrix}0&amp;AB\\ -BC&amp;B\\ \end{bmatrix}\geqslant r(AB)+r(BC).\] 一个例子 题目内容 设 \(A\in F^{n\times n}\), \(f(x),g(x)\in F[x]\) 且 \((f(x),g(x))=1\), 求证 \[f(A)g(A)=0\iff r(f(A))+r(g(A))=n.\] 简略证明 由 \((f(x),g(x))=1\), 可知 \(\exists u(x),v(x)\in F[x]\), s.t. \[u(x)f(x)+v(x)g(x)=1.\] 故 \[u(A)f(A)+v(A)g(A)=I.\] 故有如下变换: \[\begin{bmatrix}f(A)&amp;0\\ 0&amp;g(A)\\ \end{bmatrix}\to\begin{bmatrix}f(A)&amp;0\\ I&amp;g(A)\\ \end{bmatrix}\to\begin{bmatrix}0&amp;-f(A)g(A)\\ I&amp;0\\ \end{bmatrix}\] 同时取秩, 可得 \[f(A)g(A)=0\iff r(f(A))+r(g(A))=n.\] 一个变形 设 \(A\) 为 \(n\) 阶方阵, 则 \[A^2=A\iff r(A)+r(I-A)=n.\] 参考资料 王卿文. 线性代数核心思想及应用[M]. 科学出版社, 2012.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
        <tag>保研</tag>
        <tag>保研复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调教Hexo[3]——Hexo网站的傻瓜式迁移]]></title>
    <url>%2F2018%2F03%2F20%2Fhexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[在网上搜索&quot;hexo 迁移&quot;, 得到的方案大多是在 git 上开辟一个仓库或者分支来存储博客的源码. 但是对于那些对 git 不是很熟悉的人来说, 这种方案操作难度稍大, 容易出岔子. 本文提供了只保存主题 \themes 和文章 \source 两个文件夹, 重新配置环境的方法和细节. 几句废话 前两天脑抽重装了一发系统, 再重装我就是狗. 由于对 git 操作不够熟悉, 所以在迁移博客时出了一些小问题. 出现的问题 为了备份博客, 我在搭建之初将整个文件夹同步到了git的仓库中. 但一个很蠢的地方就是 /theme/yelee 中的内容没有被同步上来, 一直是一个空文件夹. 这个错误一直到我重装完系统后, 将该仓库clone到本地以后, 运行 hexo server 时才发现. 但此时已经来不及了==幸亏 \source 中的内容得以保留. 所以, 本文将提供一种重新配置网站的方案细节. 配置细节 环境配置 安装 git-for-windows; 安装 node.js; 配置git相关信息: user.name, user.email, ssh. hexo相关组件 hexo-deployer-git 在 git 上部署网站需要安装该插件, 安装命令如下: 1npm install hexo-deployer-git --save hexo-server 在本地 hexo s 无法预览时需要安装该插件, 安装命令如下: 1npm install hexo-server --save hexo-renderer-pandoc 详见Hexo与Mathjax的冲突及（部分）解决. 安装命令如下: 12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-pandoc --save 后续操作 文章迁移 在空文件夹中运行 hexo init, 即可在文件夹中添加所需要的组件. 将其中的 /source 和 /themes 替换即可. 搜索配置 安装 search 插件, 在主题中配置好即可. 安装命令: 1npm install hexo-generator-search --save]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>计算机</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学分析拾遗[3]——隐函数定理]]></title>
    <url>%2F2018%2F03%2F18%2F%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E6%8B%BE%E9%81%97-3-%E2%80%94%E2%80%94%E9%9A%90%E5%87%BD%E6%95%B0%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[单个方程的隐函数定理 二元情形 定理内容 定理 设二元函数 \(F(x,y)\) 在 \(U((x_0,y_0),\delta)\) 内满足以下条件: (1) \(F(x_0,y_0)=0\), \(F_y&#39;(x_0,y_0)\neq 0\); (2) \(F(x,y)\), \(F_y&#39;(x,y)\) 在 \(U((x_0,y_0),\delta)\) 内连续. 则 \(\exists\delta_0&gt;0~(0&lt;\delta_0&lt;\delta)\), s.t. 在 \(U(x_o,\delta_0)\) 内存在唯一满足下列条件的连续函数 \(f(x)\): (a) \(y_0=f(x_0)\); (b) \(F(x,f(x))=0\), \(\forall x\in U(x_0,\delta_0)\); (c) 如果 \(F_x&#39;(x,y)\) 在 \(U((x_0,y_0),\delta)\) 内连续, 则 \(f(x)\) 在 \(U(x_0,\delta_0)\) 存在连续导数并且有 \[f&#39;(x)=-\frac{F_x&#39;(x,f(x))}{F_y&#39;(x,f(x))}.\] 简略证明 不妨设 \(F_y&#39;(x_0,y_0)&gt;0\). 由 \(F_y&#39;\) 的连续性与极限的保号性, \(\exists 0&lt;\delta_1,\delta_2&lt;\delta\), s.t. \(\forall (x,y)\in U(x_0,\delta_1)\times U(y_0,\delta_2)\), 有 \[F_y&#39;(x,y)&gt;0.\] 特别地, 若固定 \(x=x_0\), 则 \(\forall y\in U(y_0,\delta_2)\), 有 \(F_y&#39;(x_0,y)&gt;0\). 故 \(F(x_0,y)\) 在 \(U(y_0,\delta_2)\) 对 \(y\) 严格递增. 由于 \(F(x_0,y_0)=0\), 故 \[F(x_0,y_0-\delta_2)&lt;0,~F(x_0,y_0+\delta_2)&gt;0.\] 由 \(F\) 的连续性, \(\exists\delta_0\in (0,\delta_1)\), s.t. \(\forall x\in U(x_0,\delta_0)\), 总有 \[F(x,y_0-\delta_2)&lt;0,~F(x,y_0+\delta_2)&gt;0.\] \(\forall \tilde{x}\in U(x_0,\delta_0)\), 考虑到 \(F_y&#39;(\tilde{x},y)&gt;0\), 由零点定理可知, 存在唯一的 \(\tilde{y}\in U(y_0,\delta_2)\), s.t. \[F(\tilde{x},\tilde{y})=0.\] 这说明了隐函数在 \(U((x_0,y_0),\delta_0)\) 的存在性. 连续性和导数的存在性略去. 多元情形 定理 记 \(\boldsymbol{x}=(x_1,\cdots,x_n)\), \(\boldsymbol{x}^0=(x_1^0,\cdots,x_n^0)\in\mathbb{R}^n\), 设函数 \(F(\boldsymbol{x},y)=F(x_1,\cdots,x_n,y)\) 在 \(U(\boldsymbol{x}_0,\delta)\times U(y_0,\delta)~(\delta&gt;0)\) 内由定义, 且满足 (1) \(F(\boldsymbol{x}_0,y_0)=0\), \(F_y&#39;(\boldsymbol{x}_0,y_0)\neq 0\); (2) \(F(\boldsymbol{x},y)\), \(F_y&#39;(\boldsymbol{x},y)\) 在 \(U((\boldsymbol{x}_0,y_0),\delta)\) 内连续. 则 \(\exists\delta_0&gt;0~(0&lt;\delta_0&lt;\delta)\), s.t. 在 \(U(\boldsymbol{x}_o,\delta_0)\) 内存在唯一满足下列条件的连续函数 \(f(\boldsymbol{x})\): (a) \(y_0=f(\boldsymbol{x}_0)\); (b) \(F(\boldsymbol{x},f(\boldsymbol{x}))=0\), \(\forall \boldsymbol{x}\in U(\boldsymbol{x}_0,\delta_0)\); (c) 如果 \(F_x&#39;(\boldsymbol{x},y)\) 在 \(U(\boldsymbol{x}_0,\delta)\times U(y_0,\delta)\) 内连续, 则 \(f(\boldsymbol{x})\) 在 \(U(\boldsymbol{x}_0,\delta_0)\) 存在各个连续偏导数并且有 \[\frac{\partial f(\boldsymbol{x})}{\partial x_i}=-\frac{F_{x_i}&#39;(x_1,\cdots,x_n,y)}{F_y&#39;(x_1,\cdots,x_n,y)},~\forall i=1,\cdots,n,~\forall\boldsymbol{x}\in U(\boldsymbol{x}_0,\delta).\] 其中 \(y=f(\boldsymbol{x})\). 方程组的隐函数(组)定理 待补 反函数存在性定理 定理 设 \(\boldsymbol{y}=(y_1,\cdots,y_n)=(f_1(\boldsymbol{x}),\cdots,f_n(\boldsymbol{x}))\) 是区域 \(D\subset\mathbb{R}^n\to\Omega\subset\mathbb{R}^n\) 的一个 \(C^1\) 映射, 且在 \(\boldsymbol{x}_0\in D\) 处有 \[\frac{\partial (f_1,\cdots,f_n)}{\partial (x_1,\cdots,x_n)}\Bigg|_{\boldsymbol{x}_0}\neq 0.\] 记 \(\boldsymbol{y}=\boldsymbol{f}(\boldsymbol{x}_0)\), 则存在 \(\boldsymbol{x}_0\) 的邻域 \(U(\boldsymbol{x}_0,\delta_0)\), s.t. \(\boldsymbol{y}=\boldsymbol{f}(\boldsymbol{x})\) 是 \(U(\boldsymbol{x}_0,\delta_0)\to \boldsymbol{f}(U)\) 的 \(C^1\) 同胚映射. 其中 \(\boldsymbol{f}(U)\) 是包含 \(\boldsymbol{y}_0\) 的一个区域.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数学分析</tag>
        <tag>保研</tag>
        <tag>保研复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学分析拾遗[2]——积分的中值定理]]></title>
    <url>%2F2018%2F03%2F13%2F%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E6%8B%BE%E9%81%97-2-%E2%80%94%E2%80%94%E7%A7%AF%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[积分第一中值定理 定理内容 积分第一中值定理 设函数 \(f(x)\in C[a,b]\), \(g(x)\in R[a,b]\) 且在 \([a,b]\) 不变号, 则 \(\exists\xi\in[a,b]\), s.t. \[\int_a^b f(x)g(x){\rm d}x=f(\xi)\int_a^b g(x){\rm d}x.\] 几何意义的探讨 \(g(x)\equiv 1\) 且 \(f(x)\geqslant 0\) 时, 其形式变为: \[\int_a^b f(x){\rm d}x=f(\xi)(b-a).\] 此时几何意义是很显然的: 由 \(x=a\), \(x=b\), \(y=f(x)\) 所围成的曲边梯形的面积与由 \(x=a,\), \(x=b\), \(y=f(\xi)\) 围成的矩形面积相等, 如图所示: 积分第二中值定理 定理内容 积分第二中值定理 设函数 \(g(x)\in R[a,b]\), 有以下三种情况: (1) 若函数 \(f(x)\) 在 \([a,b]\) 单调增, 且对于 \(\forall x\in[a,b]\), 有 \(f(x)\geqslant 0\), 则 \(\exists\xi_1\in[a,b]\), s.t. \[\int_a^b f(x)g(x){\rm d}x=f(b)\int_{\xi_1}^b g(x){\rm d}x.\] (2) 若函数 \(f(x)\) 在 \([a,b]\) 单调减, 且对于 \(\forall x\in[a,b]\), 有 \(f(x)\geqslant 0\), 则 \(\exists\xi_2\in[a,b]\), s.t. \[\int_a^b f(x)g(x){\rm d}x=f(a)\int_a^{\xi_2} g(x){\rm d}x.\] (3) 若函数 \(f(x)\) 在 \([a,b]\) 单调, 则 \(\exists\xi\in[a,b]\), s.t. \[\int_a^b f(x)g(x){\rm d}x=f(a)\int_a^\xi g(x){\rm d}x+f(b)\int_\xi^b g(x){\rm d}x.\] 参考文献 伍胜建. 数学分析.第2册[M]. 北京大学出版社, 2010. 裴礼文. 数学分析中的典型问题与方法-第2版[M]. 高等教育出版社, 2006.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数学分析</tag>
        <tag>保研</tag>
        <tag>保研复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学分析拾遗[1]——一些不等式]]></title>
    <url>%2F2018%2F03%2F13%2F%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E6%8B%BE%E9%81%97-1-%E2%80%94%E2%80%94%E4%B8%80%E4%BA%9B%E4%B8%8D%E7%AD%89%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[均值不等式 平方 \(\geqslant\) 算数 \(\geqslant\) 几何 \(\geqslant\) 调和 定理内容 均值不等式 \(\forall a_1,\cdots,a_n\geqslant 0\), 有 \[\frac{n}{\sum\nolimits_{i=1}^n\frac{1}{a_i}}\leqslant \sqrt[n]{\prod\nolimits_{i=1}^n a_i}\leqslant \frac{\sum\nolimits_{i=1}^n a_i}{n}\leqslant \sqrt{\frac{\sum\nolimits_{i=1}^n a_i^2}{n}}.\]取等号当且仅当 \(a_1=\cdots=a_n\). 简略证明 只证算术 \(\leqslant\) 几何部分: 1. 先证对于 \(n=2^k\) 成立: 由二元均值不等式可得\[\begin{align} \sqrt[2^k]{a_1\cdots a_{2^k}} &amp;\leqslant \sqrt[2^{k-1}]{\frac{a_1+a_2}{2}+\frac{a_3+a_4}{2}+\cdots+\frac{a_{2^k-1}+a_{2^k}}{2}} \\ &amp;\leqslant \cdots\leqslant \frac{a_1+\cdots+a_{2^k}}{2^k}. \end{align}\] 2. 反向归纳: 记 \(A=\frac{a_1+\cdots+a_n}{n}\), 则 \(nA=\sum a_i\). 设 \(n+1\) 时不等式成立, 下证 \(n\) 时成立: \[\begin{align} A=\frac{nA+A}{n+1} &amp;= \frac{a_1+\cdots+a_n+A}{n+1} \\ &amp;\geqslant \sqrt[n+1]{a_1\cdots a_n A}. \end{align}\] 于是 \(A^{n+1}\geqslant a_1\cdots a_nA\), 即 \[A\geqslant \sqrt[n]{a_1\cdots a_n}.\] Hölder不等式 定理内容 \[a\cdot b\leqslant \Vert a\Vert_p\cdot\Vert b\Vert_q,~\frac{1}{p}+\frac{1}{q}=1\] Hölder不等式 设 \(a_i,b_i\geqslant 0\), \(\frac{1}{p}+\frac{1}{q}=1\), 则 (1) 当 \(p&gt;1\) 时, \[\sum\limits_{i=1}^n a_ib_i\leqslant (\sum\limits_{i=1}^n a_i^p)^{1/p}(\sum\limits_{i=1}^n a_i^q)^{1/q}.\] (2) 当 \(p&lt;1\) 时, \[\sum\limits_{i=1}^n a_ib_i\geqslant (\sum\limits_{i=1}^n a_i^p)^{1/p}(\sum\limits_{i=1}^n a_i^q)^{1/q}.\] 等号当且仅当 \(a_i\) 和 \(b_i\) 成比例时取得. 简略证明 只证 (1): 当 \(p&gt;1\) 时, 易有 \(q&lt;1\). 此时有 \[\begin{align} \frac{a\cdot b}{\Vert a\Vert_p\cdot\Vert b\Vert_q} &amp;= \sum \left(\frac{a_i^p}{\sum a_i^p}\right)^{1/p}\left(\frac{b_i^q}{\sum b_i^q}\right)^{1/q} \\ &amp;\leqslant \sum \left[\frac{1}{p}\left(\frac{a_i^p}{\sum a_i^p}\right)+\frac{1}{q}\left(\frac{b_i^q}{\sum b_i^q}\right)\right] \\ &amp;= \frac{1}{p}\sum\frac{a_i^p}{\sum a_i^p}+\frac{1}{q}\sum\frac{b_i^q}{\sum b_i^q} \\ &amp;= \frac{1}{p}+\frac{1}{q} =1. \end{align}\] Minkowski不等式 定理内容 \[\Vert a+b\Vert_p\leqslant \Vert a\Vert_p\cdot\Vert b\Vert_p\] Minkowski不等式 对于 \(\forall r\neq 0,1\in\mathbb{R}\), 以及 \(a_i,b_i\geqslant 0\), 有 (1) 当 \(r&gt;1\) 时, \[(\sum\limits_{i=1}^n(a_i+b_i)^r)^{1/r}\leqslant (\sum\limits_{i=1}^n a_i^r)^{1/r}+(\sum\limits_{i=1}^n b_i^r)^{1/r}\] (2) 当 \(r&lt;1\) 时, \[(\sum\limits_{i=1}^n(a_i+b_i)^r)^{1/r}\geqslant (\sum\limits_{i=1}^n a_i^r)^{1/r}+(\sum\limits_{i=1}^n b_i^r)^{1/r}\] 简略证明 只证 (1): 当 \(r&gt;1\) 时, 令 \(s_i=a_i+b_i\), 则有 \[\begin{align} \sum s_i^r &amp;= \sum (a_i+b_i)^r \\ &amp;= \sum (a_i+b_i)(a_i+b_i)^{r-1} \\ &amp;= \sum a_is_i^{r-1}+\sum b_is_i^{r-1}. \end{align}\] 令 \(p=r\), \(q=\frac{r}{r-1}\), 则 \(\frac{1}{p}+\frac{1}{q}=1\), 由Hölder不等式可得: \[\begin{align} \sum s_i^r &amp;\leqslant (\sum a_i^r)^{\frac{1}{r}}(\sum s_i^r)^{\frac{r-1}{r}}+(\sum b_i^r)^{\frac{1}{r}}(\sum s_i^r)^{\frac{r-1}{r}} \\ &amp;= [(\sum a_i^r)^{\frac{1}{r}}+(\sum b_i^r)^{\frac{1}{r}}]\cdot (\sum s_i^r)^{1-\frac{1}{r}}. \end{align}\] 两边同乘 \((\sum s_i^r)^{1-\frac{1}{r}}\) 即可得到Minkowski不等式. Young不等式 定理内容 Young不等式 设 \(f(x)\in[0,+\infty)\) 单调增, \(f(0)=0\), \(a,b&gt;0\), 则 \[ab\leqslant \int_0^a f(x){\rm d}x+\int_0^b f^{-1}(x){\rm d}x.\] 等号当且仅当 \(f(a)=b\) 时成立. 简略证明 从几何上看十分直观. 参考文献 裴礼文. 数学分析中的典型问题与方法-第2版[M]. 高等教育出版社, 2006. 伍胜建. 数学分析.第2册[M]. 北京大学出版社, 2010.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数学分析</tag>
        <tag>保研</tag>
        <tag>保研复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[范畴论学习笔记]]></title>
    <url>%2F2018%2F03%2F02%2F%E8%8C%83%E7%95%B4%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[何为范畴 范畴: category 范畴的定义 一个范畴 \(\mathscr{C}\) 包含一些对象和一些箭头: 对象(Objects): 记作 \(A,B,C,\cdots\); 箭头(Morphism): 记作 \(f,g,h,\cdots\). 这些对象和箭头需要满足以下几个条件: 箭头有唯一的源和目标: \(\forall f\in\mathscr{C}\), \(\exists\) 唯一 \({\rm src}f,{\rm tar} f\in\mathscr{C}\). 若 \({\rm scr}f = A\), \({\rm tar}f = B\), 则可以记为 \(f:A\to B\). 箭头可以复合: \(\forall f,g\in\mathscr{C}\), 设 \(f:A\to B\), \(g:B\to C\), \(\exists h=g\circ f:A\to C\). 称为 &quot;\(g\) following \(f\)&quot;, 即二者的复合. 每个对象必须有单位箭头: \(\forall A\in\mathscr{C}\), \(\exists {\rm id}_A:A\to A\in\mathscr{C}\). 箭头还满足以下两条性质: \(\circ\) 的结合律: \(\forall f:A\to B,~g:B\to C,~h:C\to D\), 有 \[h\circ(g\circ f)=(h\circ g)\circ f.\] \({\rm id}_A\) 是 \(\circ\) 运算的单位元: \(\forall f:A\to B\), 有 \[f\circ {\rm id}_A=f={\rm id}_B\circ f.\] 范畴的例子 幺半群 Monoid 幺半群 \((M,\cdot)\) 指不满足“所有元素可逆”的群: 存在单位元: \(\exists e\), s.t. \(\forall a\in M\), \(a\cdot e=a=e\cdot a\); 乘法结合律: \(\forall a,b,c\in M\), \((a\cdot b)\cdot c=a\cdot (b\cdot c)\). 在幺半群 \(M\) 的基础上, 可定义范畴 \(\mathscr{M}\) 如下: \(\mathscr{M}\)-对象: 任取一个集合 \(S\) 作为 \(\mathscr{M}\) 的对象; \(\mathscr{M}\)-箭头: 用 \(M\) 中的元素表示 \(\mathscr{M}\) 上的箭头: 箭头的复合定义为元素的乘积: \[(a\circ b)_\mathscr{M}=(a\cdot b)_M;\] 单位箭头定义为 \(M\) 的单位元: \[{\rm id}_\mathscr{M}=e_M.\] 幺半范畴 考虑所有幺半群组成的集合, 可如下定义范畴 \(\mathscr{M}\): \(\mathscr{M}\)-对象: 幺半群全体作为 \(\mathscr{M}\) 的对象; \(\mathscr{M}\)-箭头: 所有的幺半群同态作为 \(\mathscr{M}\) 的箭头. 该范畴称为幺半范畴, 记作 \({\tt Mon}\). 偏序集 在一个集合 \(S\) 上, 一个偏序 \(\leqslant\) 的定义如下: 自反性: \(\forall x\in S\), \(x\leqslant x\); 反对称性: \(x\leqslant y~\text{且}~y\leqslant x\iff x=y\); 传递性: \(x\leqslant y,~y\leqslant z\Longrightarrow x\leqslant z\). 集合 \(S\) 定义了偏序后, 就称为一个偏序集. 在偏序集 \(S\) 的基础上可以如下定义范畴 \(\mathscr{C}\): \(\mathscr{C}\)-对象: \(S\) 中的元素作为 \(\mathscr{C}\) 的对象; \(\mathscr{C}\)-箭头: 若 \(A\leqslant B\in S\), 则存在唯一的箭头 \(f:A\to B\). 容易验证这样定义的 \(\mathscr{C}\) 是一个范畴. 偏序范畴 考虑所有偏序集组成的集合, 可如下定义范畴 \(\mathscr{C}\): \(\mathscr{C}\)-对象: 偏序集全体作为 \(\mathscr{C}\) 的对象; \(\mathscr{C}\)-箭头: 所有的保序映射作为 \(\mathscr{C}\) 的箭头. 如此定义的范畴, 称为偏序范畴, 记作 \({\tt Pos}\). 几个特殊的范畴 空范畴: empty category 没有对象也没有箭头的范畴, 称为空范畴. 一元范畴: \(1\) 只有一个单位对象和一个单位箭头的范畴, 记作 \(1\). 二元范畴: von Neumann ordinal \(2\) 集合 \(\{\varnothing,\{\varnothing\}\}\) 上赋予单位箭头以及 \(\varnothing\to\{\varnothing\}\) 箭头的范畴. 集合范畴 考虑如下范畴 \({\tt Set}\): 对象: 所有集合(注意所有集合全体不是一个集合); 箭头: 集合间的映射(原文为set-function) \(f:X\to Y\). 单位箭头是恒等映射, 显然存在且唯一; 箭头的复合也是很自然的. 该范畴被称为集合范畴. 逻辑范畴 在形式语言 \(T\) 中考虑如下范畴 \({\tt Proof}_T\): 对象: 所有 \(T\) 中的语句; 箭头: \(\forall\varphi,\psi\in T\), 存在箭头 \(\varphi\to\psi\iff\varphi\vdash\psi\). 单位箭头是恒等映射, 显然存在且唯一; 箭头的复合根据 \(\vdash\) 的定义显然. 该范畴称为 \(T\) 上的逻辑范畴. 一些常见范畴的定义和记号 如下表所示, 整理自Category Theory: A Gentle Introductio. 范畴 记号 对象 箭头 群范畴 \({\tt Grp}\) 所有的群 群同态 交换群范畴 \({\tt Ab}\) 所有的交换群 群同态 环范畴 \({\tt Rng}\) 所有的环 环同态 布尔范畴 \({\tt Bool}\) 所有的布尔代数 结构保存映射 偏序/全序范畴 \({\tt Pos/Tot}\) 所有的偏序/全序集 保序映射 拓扑/度量空间范畴 \({\tt Top/Met}\) 所有的拓扑/度量空间 连续映射 场 \(K\) 上的向量空间范畴 \({\tt Vect}_K\) 所有的向量空间 线性映射 集合/有限集范畴 \({\tt Set/FinSet}\) 所有的集合/有限集 集合映射 \(f:X\to Y\) 逻辑范畴 \({\tt Proof}_T\) \(T\) 中的所有语句 按照逻辑推出关系 \(\vdash\) 定义箭头 范畴生范畴 从已有的一个范畴可以构建出新的范畴, 有以下的一些方法 逆范畴: opposite category 一个范畴 \(\mathscr{C}\) 的逆范畴 \(\mathscr{C}^{op}\) 定义如下: \(\mathscr{C}^{op}\)-对象: \(\mathscr{C}\) 的对象; \(\mathscr{C}^{op}\)-箭头: \(f:B\to A~\text{in}~\mathscr{C}^{op}\iff f:A\to B~\text{in}~\mathscr{C}\) 单位箭头: \({\rm id}_A^{op}={\rm id}_A\), \(\forall A\); 复合箭头: \(f\circ^{op}g=g\circ f\). 根据定义可知: 每个范畴 \(\mathscr{C}\) 都存在一个对偶 \(\mathscr{C}^{op}\); 对偶的对偶就是自身: \((\mathscr{C}^{op})^{op}=\mathscr{C}\). 子范畴: subcategory 对于一个范畴 \(\mathscr{C}\), 若 \(\exists\) 范畴 \(\mathscr{S}\), s.t. \(\mathscr{S}\) 的对象全部都是 \(\mathscr{C}\) 的(全部或部分)对象; \(\mathscr{S}\) 的箭头全部都是 \(\mathscr{C}\) 的(全部或部分)箭头. 且满足: \(\mathscr{S}\) 继承 \(\mathscr{C}\) 中的单位箭头; \(\mathscr{S}\) 继承 \(\mathscr{C}\) 的结合律. 则称 \(\mathscr{S}\) 是 \(\mathscr{C}\) 的一个子范畴. 由定义立即得到: \({\tt FinSet}\) 是 \({\tt Set}\) 的子范畴; \({\tt Ab}\) 是 \({\tt Grp}\) 的子范畴. 特别地, 若对于 \(\forall\mathscr{S}\) 对象 \(A,B\), \(\mathscr{S}\) 中包含了 \(\mathscr{C}\) 中所有的 \(A\to B\) 的箭头, 则称 \(\mathscr{S}\) 是 \(\mathscr{C}\) 的一个满子范畴. 积范畴: product category 设 \(\mathscr{C}\) 和 \(\mathscr{D}\) 是范畴, 如下定义二者的积范畴 \(\mathscr{C}\times\mathscr{D}\): \(\mathscr{C}\times\mathscr{D}\)-对象: \((C,D)\), 其中 \(C,D\) 分别是 \(\mathscr{C},\mathscr{D}\) 的对象; \(\mathscr{C}\times\mathscr{D}\)-箭头: \((f,g):(C_1,D_1)\to (C_2,D_2)\iff f:C_1\to C_2~\text{in}~\mathscr{C},g:D_1\to D_2~\text{in}~\mathscr{D}\) 单位箭头: \({\rm id}_{(C,D)}=({\rm id}_C,{\rm id}_D)\); 复合箭头: \((f_1,g_1)\circ (f_2,g_2)=(f_1\circ_\mathscr{C} f_2,g_1\circ_\mathscr{D} g_2)\). 商范畴: quotient category 设 \(\mathscr{C}\) 是一个范畴, \(\sim\) 是其上的一个同余关系, 则 \(\mathscr{C}/\sim\) 是一个以 \(\mathscr{C}\) 对象为对象, \(\sim\) 等价类为箭头的一个范畴. 例如对于拓扑范畴 \({\tt Top}\), 考虑其上的同伦关系, 所得的商空间 \({\tt Top}/\sim\) 称为同伦拓扑范畴, 记作 \({\tt hTop}\). 箭头范畴: arrow category 设 \(\mathscr{C}\) 是一个范畴, 其箭头范畴 \(\mathscr{C}^\to\) 定义如下: \(\mathscr{C}^\to\)-对象: \(\mathscr{C}\) 中的箭头; \(\mathscr{C}^\to\)-箭头: 对于两个 \(\mathscr{C}^\to\) 对象 \(f_1, f_2\), 一个 \(\mathscr{C}^\to\) 箭头 \(f_1\to f_2\) 是一个使得下图交换的一个二元组 \((j,k)\):\[ \begin{matrix} X_1~~ &amp; \xrightarrow{j} &amp; X_2~~ \\ \downarrow \tiny{f_1} &amp; &amp; \downarrow \tiny{f_2} \\ Y_1~~ &amp; \xrightarrow{k} &amp; Y_2~~ \\ \end{matrix} \] 单位箭头: \(f:X\to Y\) 的单位箭头为 \(({\rm id}_X,{\rm id}_Y)\); 复合箭头: \((j_1,k_1):f_1 \to f_2\) 和 \((j_2,k_2):f_2 \to f_3\) 的复合为:\[(j_2\circ j_1,~k_2\circ k_1):f_1\to f_3.\] 切片范畴: slice category 设 \(\mathscr{C}\) 是一个范畴, \(I\) 是 \(\mathscr{C}\) 的一个对象, 则 \(\mathscr{C}\) 在 \(I\) 的切片范畴 \(\mathscr{C}/I\) 定义如下: \(\mathscr{C}/I\)-对象: 二元组 \((A,f)\), 其中 \(A\) 是 \(\mathscr{C}\) 的对象, \(f:A\to I\) 是 \(\mathscr{C}\) 的箭头; \(\mathscr{C}/I\)-箭头: 箭头 \((A,f)\to (B,g)\) 是在 \(\mathscr{C}\) 中满足 \(g\circ j=f\) 的箭头 \(j:A\to B\). 单位箭头: 对象 \((A,f)\) 的单位箭头是 \(\mathscr{C}\) 的单位箭头 \({\rm id}_A\); 复合箭头: 箭头 \(j:(A,f)\to(B,g)\) 和 \(k:(B,g)\to(C,h)\) 的复合为 \[k\circ_{\mathscr{C}/I} j:(A,f)\to(C,h)=k\circ_\mathscr{C} j:A\to C.\] 箭头的种类 用范畴的语言来定义单射和满射. 单态: monomorphism 定义 单态: 设 \(\mathscr{C}\) 是一个范畴, 其中的一个箭头 \(f:B\to C\) 是一个单态当且仅当它满足左消去律. 即对于 \(\forall\) 映射 \(g:A\to B,~h:A\to B\), 有\[f\circ g=f\circ h\iff g=h.\] 例子 \({\tt Set}\) 中的箭头是单态当且仅当其对应的映射是单射; \({\tt Grp}\) 中的箭头是单态当且仅当其对应的同态是单同态; 单位箭头 \({\rm id}_A\) 是单态. 性质 如果 \(f,g\) 是单态, 则 \(f\circ g\) 是单态; 如果 \(f\circ g\) 是单态, 则 \(g\) 是单态. 满态: epimorphism 定义 满态: 设 \(\mathscr{C}\) 是一个范畴, 其中的一个箭头 \(f:B\to C\) 是一个满态当且仅当它满足右消去律. 即对于 \(\forall\) 映射 \(g:C\to D,~h:C\to D\), 有\[g\circ f=h\circ f\iff g=h.\] 例子 \({\tt Set}\) 中的箭头是满态当且仅当其对应的映射是满射; \({\tt Grp}\) 中的箭头是满态当且仅当其对应的同态是满同态; 单位箭头 \({\rm id}_A\) 是满态. 性质 如果 \(f,g\) 是满态, 则 \(f\circ g\) 是满态; 如果 \(f\circ g\) 是满态, 则 \(f\) 是满态.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>范畴论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北京师范大学拓扑学试卷]]></title>
    <url>%2F2018%2F01%2F11%2FBNU-Topology-Exam%2F</url>
    <content type="text"><![CDATA[试题 叙述 \(T_0\), \(T_1\), \(T_2\) 的定义, 并分别举出 \(T_0\) 但不 \(T_1\), 以及 \(T_1\) 但不 \(T_2\) 的空间的例子. 在 \(X\times X\) 上定义映射 \(\Delta: X\rightarrow X\times X,~\Delta(x)=(x,x)\), 证明: \(X\) 是Hausdorff空间当且仅当 \(\Delta(X)\) 是 \(X\times X\) 的闭集. 设 \(\mathcal{T}\) 是 \(\mathbb{R}^1\) 上的余有限拓扑, 讨论其紧性、连通性和道路连通性. 考虑拓扑群作用 \(\mathbb{S}^1\times B^2\to B^2,~(z,w)\mapsto zw\). 求 \(B^2\) 中一点 \(w\) 的迷向群; 证明其轨道空间同构于单位闭区间 \(I\). \(X\) 是道路连通曲面, 证明: 连续映射 \(f: X\to T^2\) 零伦当且仅当 \(f\) 诱导的同态平凡. 简略解答 有差错不负任何责任. 定义参见课本P19: Def 2.28. 例子参见课本 P19: Ex 1, Ex 2. \(T_0\) 但不 \(T_1\): \(X=\{0,1\}\), \(\mathcal{T}=\{\varnothing, \{0\}, X\}\); \(T_1\) 但不 \(T_2\): \(\mathbb{R}^1\) 上的余有限拓扑. 题目参见课本 P35 习题3.2 第5题. 解答参见 Zhechen: 拓扑学题目. 紧致, 连通, 且道路连通. 证明略. 参见课本P47 习题3.4 第7题. 简略证明: 迷向群平凡, 直接按照定义求即可; 考虑映射 \(f: B^2\to I,~re^{i\theta}\mapsto r\). 则 \(f\) 是紧空间到Hausdorff空间的连续满射, 因而是商映射. 于是 \(f/\sim\cong I\). 只需要研究其轨道空间, 说明轨道空间就是 \(X/\sim\) 即可. 题目类似于课本 P125 习题6.2 的 1,2 题. 简略解答: 考虑复叠映射 \(P: \mathbb{E}^2\to T^2\). 若诱导的同态平凡, 则 \(\mathrm{Im}f_*\subset \mathrm{Im}p_*\), 因而 \(f\) 有提升 \(\tilde{f}\). 又由于 \(\mathbb{E}^2\) 是凸集, 故 \(\tilde{f}\) 零伦, 故 \(f=p\circ\tilde{f}\) 零伦. 反方向略.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>数学</tag>
        <tag>各种试卷</tag>
        <tag>拓扑学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北京师范大学泛函分析试题]]></title>
    <url>%2F2018%2F01%2F11%2FBNU-Functional-Analysis-Exam%2F</url>
    <content type="text"><![CDATA[2017 泛函分析 期末 杨大春 2018 泛函分析 期末 杨大春 2019 泛函分析 期末 杨大春 2017 期末试题 7, 8, 9 题目不保证与原文完全一致. 设 \(\mathscr{X}\) 是 \(B^*\) 空间, \(\mathscr{X}_0\) 是 \(\mathscr{X}\) 的子空间, 假定 \(\exists c\in(0,1)\), s.t. \[\inf\limits_{x\in\mathscr{X}_0}\Vert y-x\Vert\leqslant c\Vert y\Vert\quad (\forall y\in\mathscr{X}).\] 求证: \(\mathscr{X}_0\) 在 \(\mathscr{X}\) 中稠. 设 \(M\) 是Hilbert空间 \(\mathscr{H}\) 的子集, 求证: \[(M^\perp)^\perp=\overline{\mathrm{span}M}.\] 设 \(\mathscr{H}\) 是Hilbert空间, \(A\in\mathscr{L}(\mathscr{H})\), 且 \(\exists m&gt;0\), s.t. \[\vert (Ax,x) \vert\geqslant m\Vert x\Vert^2\quad (\forall x\in\mathscr{H}).\] 求证: \(\exists A^{-1}\in\mathscr{L}(\mathscr{H})\). 设 \(\mathscr{X}\) 是复线性空间, \(p\) 是 \(\mathscr{X}\) 上的半模. \(\forall x_0\in\mathscr{X}\), \(p(x_0)\neq 0\). 求证: 存在 \(\mathscr{X}\) 上的线性泛函 \(f\) s.t. \(f(x_0)=1\); \(\vert f(x)\vert\leqslant p(x)/p(x_0)~(\forall x\in\mathscr{X})\). 设 \(\mathscr{X}\) 是 \(B^*\) 空间, \(E\subset\mathscr{X}\) 是非空均衡闭凸集, \(\forall x\in\mathscr{X}\backslash E\). 求证: \(\exists f\in\mathscr{X}^*\) 及 \(\alpha&gt;0\), s.t. \[\vert f(x)\vert&lt;\alpha&lt;\vert f(x_0)\vert\quad (\forall x\in E).\] 求证: \(B\) 空间是自反的当且仅当其共轭空间是自反的. (不保证与原题完全一致) 设 \(\mathscr{X},\mathscr{Y}\) 是Banach空间, 设 \(\mathscr{L}(\mathscr{X},\mathscr{Y})\) 是连续线性算子全体, 证明: 一一映射在其中构成一个开集. 设 \(\mathscr{H}\) 是Hilbert空间, \(A,B\in\mathscr{L}(\mathscr{H})\), 若对 \(\forall x,y\in\mathscr{X}\), 有 \((Ax,y)=(x,By)\), 证明: \(A\) 连续. (不保证与原题完全一致) 设 \(\mathscr{X}\) 是自反空间, \(E\) 是其中的闭凸集, 证明: \[\exists x_0\in E,~\text{s.t.}~\Vert x_0\Vert=\inf\limits_{x\in E}\Vert x\Vert.\] 部分简略解答 7, 8, 9 解答不保证正确性. 用 F.Riesz 引理, 参见习题1.4.13; 参见习题1.6.5; 用 Banach 逆映射定理, 参见习题2.3.3; 用复 Hahn-Banach 定理, 参见习题2.4.3; 用 Ascoli 定理, 参见习题2.4.10; 利用自然映射和共轭算子, 参见习题2.5.5; --这是一个差不多的题目的解答 先证明一个引理： LEMMA 1. \(\mathscr{X}\) 是Banach空间, 设 \(A\in\mathscr{L}(\mathscr{X})\) 且 \(\Vert A\Vert_{\mathscr{L}(\mathscr{X} )}&lt;1\), 则 \((I-A)^{-1}\in\mathscr{L}(\mathscr{X})\) 且 \[\Vert (I-A)^{-1}\Vert_{\mathscr{L}(\mathscr{X})}\leqslant \frac{1}{1-\Vert A\Vert_ {\mathscr{L}(\mathscr{X})}}.\] 证明略...（ 然后仍然是证明开集的正统方法：\(\forall A\), s.t. \(A\in\mathscr{L}(\mathscr{X})\) 且 \(A^{-1}\in \mathscr{L}(\mathscr{X})\)（1. 取集合里的一个元素）, 取 \(\forall T\in\mathscr{L}(\mathscr{X})\), s.t. \(\Vert T-A\Vert_{\mathscr{L}(\mathscr{X})} &lt;\frac{1}{\Vert A^{-1}\Vert_{\mathscr{L}(\mathscr{X})}}\)（2. 取一个半径, 考虑以 \(A\) 为心的开球）, 由 LEMMA, 有： \[ \begin{align} \Vert T^{-1}\Vert_{\mathscr{L}(\mathscr{X})} &amp;= \Vert (T-A+A)^{-1}\Vert_{\mathscr{L} (\mathscr{X})} = \Vert (I+(T-A)A^{-1})^{-1}A^{-1} \Vert_{\mathscr{L}(\mathscr{X})} \\ &amp;\leqslant \Vert A^{-1}\Vert_{\mathscr{L}(\mathscr{X})}\cdot \Vert (I+(T-A)A^{-1})^{-1} \Vert_{\mathscr{L}(\mathscr{X})} \\ &amp;\leqslant \Vert A^{-1}\Vert_{\mathscr{L}(\mathscr{X})}\cdot \frac{1}{1+\Vert (T-A)A^{-1} \Vert_{\mathscr{L}(\mathscr{X})}}\quad （由上述引理可得）\\ &amp;&lt; \infty\quad（这里实际上是在证明~T^{-1}~有界） \end{align} \] 其中, \(\Vert (T-A)A^{-1}\Vert_{\mathscr{L}(\mathscr{X})}\leqslant \Vert T-A\Vert_{\mathscr {L}(\mathscr{X})}\cdot \Vert A^{-1}\Vert_{\mathscr{L}(\mathscr{X})}&lt;1\). 至此, 我们证明了 \(\forall A\in &quot;\mathscr{L}(\mathscr{X})中的连续线性算子集&quot;\), \(A\) 的邻域 \(B (A,\frac{1}{\Vert A^{-1}\Vert_{\mathscr{L}(\mathscr{X})}})\subset&quot;\mathscr{L}(\mathscr{X}) 中的连续线性算子集&quot;\).（3. 证明 \(\forall A\), 开球都包含在集合里, Over.） 因此, \(\mathscr{L}(\mathscr{X})\) 中的连续线性算子构成一个闭集. 由闭图像定理, 只需证明 \(A\) 是闭算子且定义域闭. 考虑到定义域 \(\mathscr{H}\) 显然闭, 只需要证明 \(A\) 是闭算子. 取 \(x_n\to x\in \mathscr{H}\), 设 \(Ax_n\to z\), 则只需证 \(Ax=z\). (由闭算子的定义即可得, 参见课本P96: Def 2.3.9) 一方面, 由内积的连续性, 即有 \((Ax_n,y)\to (z,y)\). 而另一方面又由条件有 \((Ax_n,y)=(x_n,By)\to (x,By)=(Ax,y)\). 于是由极限的唯一性即有 \(Ax=y\), 得证. (瞎写的) 设 \(d=\inf\limits_{x\in E}\Vert x\Vert\), 由定义可取 \(x_n\in E\), s.t. \(d&lt;\Vert x_n\Vert&lt;d+\frac{1}{n}\). 由于自反空间中闭集是弱自列紧的, 取其收敛子列的弱极限即可. 2019.01泛函题目（所以是 2018 下半年的泛函考试） 只有两个附加题, 不保证题目完全一致且没有解答.感谢李菁泽同学供题. 设 \(\mathscr{X}\) 是 \(B^*\) 空间, \(\forall x\in\mathscr{X}\), \(\varepsilon_n\) 为一个极限为 \(0\) 的序列, 且有 \[f_n(x)\leqslant \varepsilon_n\Vert f_n\Vert_{\mathscr{X}^*}+C(x).\] 其中 \(C(x)\) 是一个函数（小李同学表示这个条件很懵B...）, 证明：\(\Vert f_n\Vert_{\mathscr{X}^*}\) 一致有界. \(B^*\) 空间 \(\mathscr{X}\) 上有 \(n\) 个半模 \(p_k(x)~k=1,\cdots,n\), 设线性泛函 \(\varphi(x)\) 满足 \[\vert \varphi(x)\vert\leqslant \sum\limits_{k=1}^n p_k(x),\] 试证：存在线性泛函 \(\varphi_k(x),~(k=1,\cdots,n)\), s.t. \(\varphi(x)=\sum\limits_{k=1}^n\varphi_k(x)\), 且 \(\vert\varphi_k(x)\vert\leqslant p_k(x),~(k=1,\cdots,n)\). 感谢汪玲同学提供上述第 2 题的解答： 2019.12.30 泛函题目（所以是 2019 下半年的泛函考试） 依然是两个附加题, 不保证题目完全一致且没有解答. 感谢汪玲同学供题. 设 \(E\) 是线性空间, 映射 \(p: E\to\mathbb{R}\) 满足： \(p(x+y)\leqslant p(x)+p(y)\)； 固定 \(x\in E\), 映射 \(\varphi: \mathbb{R}\to\mathbb{R},~\lambda\to p(\lambda x)\) 连续； \(\forall \lambda\in\mathbb{R}\), 若 \(p(x_n)\to 0\), 则 \(p(\lambda x_n)\to 0\). 求证： 1. \(p(0)=0\)； 2. \(\{\alpha_n\}\subset\mathbb{R}\) 有极限且 \(p(x_n)\to 0\), 则 \(p(\alpha_n x_n)\to 0\). 设 \(\mathscr{X},\mathscr{X}_1,\mathscr{X}_2\) 是 \(B\) 空间, \(T_i\) 是 \(\mathscr{X}\to \mathscr{X}_i\) 的闭算子, 且有：\[D(T_1)\subseteq D(T_2)\]求证 \(\exists C&gt;0\), s.t. \(||T_2x||_{\mathscr{X}_2}\leqslant c(||x||_{\mathscr{X}}+||T_1x||_{\mathscr{X}_1})\), \(\forall x\in D(T_1)\). 感谢汪玲同学提供上述第 2 题的解答:]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>数学</tag>
        <tag>各种试卷</tag>
        <tag>泛函分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拓扑学复习重点]]></title>
    <url>%2F2018%2F01%2F08%2F%E6%8B%93%E6%89%91%E5%AD%A6%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9%2F</url>
    <content type="text"><![CDATA[点集拓扑 拓扑空间 拓扑空间 拓扑: 包含全集和空集, 对任意并和有限交封闭的集类; 开集: 拓扑中包含的集合为开集. 几个拓扑的例子 平凡拓扑: \(\{\varnothing, X\}\)(最粗拓扑); 离散拓扑: \(\{U: U\subset X\}\)(最细拓扑); 欧式拓扑: \(\{U: x\in U\Leftrightarrow B(x,\delta)\subset U\}\); 余有限拓扑: \(\{U: U=\varnothing 或 U^c 是有限集\}\)(类似有余可数拓扑). 邻域与开集 邻域 对于包含 \(x\) 的集合 \(N\), 若存在开集 \(O\), s.t. \(x\in O\subset N\), 则称 \(N\) 是 \(x\) 的邻域. 命题 设 \(X\) 是拓扑空间, 则 \(W\) 是 \(X\) 的开集当且仅当 \(W\) 是其中每点的邻域. 闭集 开集的补集称为闭集, 由此可以立刻得到: 闭集对任意交和有限并封闭; 全集和空集是闭集; 导集 聚点: 若 \(p\) 的任意邻域都包含 \(A-\{p\}\) 中的至少一点, 则称 \(p\) 为 \(A\) 的聚点; 导集: \(A\) 的聚点全体称为 \(A\) 的导集, 记作 \(A&#39;\); 闭包: \(\overline{A}=A\cup A&#39;\). 一个例子: \[A=\{(x,\sin(\frac{\pi}{x}))~\vert~0&lt;x\leqslant 1\},\quad B=\{(0,y)~\vert~-1\leqslant y\leqslant 1\}\Rightarrow \] 关于闭集, 容易得到下列命题: 命题 \(A\) 闭 \(\iff\) \(\overline{A}=A\). 拓扑基 拓扑基: 设 \(X\) 是拓扑空间, \(\mathcal{B}\) 是一组开集, s.t. \(X\) 中的任意非空开集可以写成 \(\mathcal{B}\) 中集合的并, 则称 \(\mathcal{B}\) 为该拓扑的一组拓扑基; 拓扑基的定义等价于 \(\forall x\in X\) 以及 \(x\) 的开邻域 \(N\), \(\exists B\in\mathcal{B}\), s.t. \(x\in B\subset N\). 关于拓扑基有如下定理: 定理 设 \(\mathcal{B}\) 是集合 \(X\) 的子集构成的子集类, s.t. 1. 设 \(U_1,U_2\in\mathcal{B}\), \(\forall x\in U_1\cap U_2\), \(\exists V\in \mathcal{B}\), s.t. \(x\in V\subset U_1\cap U_2;\) 2. \(\mathcal{B}\) 覆盖 \(X\). 则 \(\mathcal{B}\) 是 \(X\) 中某个拓扑的拓扑基. 子空间拓扑 子空间拓扑: 子空间中的开集是全空间中开集与 \(A\) 的交. 子空间中的闭集也是全空间中闭集与 \(A\) 的交. 子空间中的开集也是全空间中的开集. 连续性 连续性 连续性: 开集的原像是开集. 关于与连续性等价的几个命题 开集的原像是开集; 拓扑基中集合的原像是开集; 闭集的原像是闭集. 连续性的其他结论 连续映射的复合映射连续; 连续映射在子空间的限制连续; 同胚 同胚: 若连续映射 \(f: X\to Y\) 是 \(1-1\) 映射且 \(f^{-1}\) 连续, 则称其为同胚. 关于同胚有以下等价命题: \(f\) 是同胚; \(f\) 是连续的一一映射并且是开映射; \(f\) 是连续的一一映射并且是闭映射. 分离性 分离性 \(T_0\): 任意一点与另一点分离; \(T_1\): 任意两点互相分离 \(\Leftrightarrow\) 单点集是闭集; \(T_2\): 任意两点存在各自的开邻域不相交(Hausdorff); \(T_3\): 任意闭集与其外一点存在开邻域不相交; \(T_4\): 任意两个不相交闭集存在各自开邻域不相交. 一些分离性的例子如下: \(X=\{0,1\}\), \(\mathcal{T}=\{X,\varnothing,\{0\}\}\): 是 \(T_0\) 但不是 \(T_1\); \(\mathbb{R}^1\) 上的余有限拓扑是 \(T_1\) 但不是 \(T_2\). 对于Hausdorff空间还有如下命题: 命题 Hausdorff空间 \(X\) 是 \(T_3\) 的当且仅当对于 \(\forall x\) 以及 \(U_x\), \(\exists V_x\), s.t. \[x\in V\subset\overline{V}\subset U.\] Tietze 扩张定理 Urysohn引理 设 \(X\) 是Hausdorff空间, 则 \(X\) 是 \(T_4\) 的当且仅当对于 \(X\) 内任意不相交的闭集 \(A,B\), 存在 \(X\) 上的连续实函数 \(f\), s.t. \[f\vert_A=1,~f\vert_B=-1,~-1 &lt; f\vert_{X-(A\cup B)} &lt; 1.\] 进一步有 Tietze 扩张定理: Tietze扩张定理 设 \(X\) 是Hausdorff空间, 则 \(X\) 是 \(T_4\) 的当且仅当对于 \(X\) 内任意闭子集 \(A\) 及任意连续函数 \(f: A\to \mathbb{E}^1\), 存在连续函数 \(g: X\to \mathbb{E}^1\), s.t. \(g\vert_A=f\). 进一步, 若在 \(A\) 上有 \(\vert f\vert\leqslant M\), 则可做到 \(\vert g\vert\leqslant M\). 紧致性 紧致性 紧致性: 任意开覆盖含有限子覆盖. Heine-Borel定理 \(\mathbb{E}^1\) 上的闭区间是紧集. 紧致空间的闭子集是紧的. Hausdorff空间中的紧集是闭集. 紧空间到Hausdorff空间的既单又满的连续映射是同胚. Bolzano-Weierstrass定理 紧空间的无穷点集必有聚点. 局部紧致 局部紧致: \(\forall x\in X\), 存在 \(x\) 的紧致邻域. 紧致 \(\Rightarrow\) 局部紧. 乘积空间 乘积拓扑 开集 \(\times\) 开集 构成一组拓扑基 \(\mathcal{B}\); 乘积拓扑: \(\mathcal{B}\) 决定的拓扑称为乘积拓扑. 自然投影 称映射 \[p_1: X\times Y\to X,~(x,y)\to x;\] \[p_2: X\times Y\to X,~(x,y)\to y;\] 为自然投影. \(X\times Y\) 的乘积拓扑是使得自然投影都连续的最粗拓扑; \(f:Z\to X\times Y\) 连续 \(\Leftrightarrow\) \(p_1\circ f\) 和 \(p_2\circ f\) 都连续; \(X\times Y\) 是Hausdorff空间当且仅当 \(X\), \(Y\) 都是Hausdorff空间; \(X\times Y\) 紧致当且仅当\(X\), \(Y\) 都紧致. 连通性 连通性 以下命题等价: \(X\) 连通; \(X\) 内既开又闭的子集只有 \(X\) 和 \(\varnothing\); \(X\) 不能表示为两个不相交的非空开集的并; 不存在从 \(X\) 到多于一点的离散拓扑空间的连续满射. 命题 \(\mathbb{E}^1\) 的非空子集连通当且仅当它是一个区间. 关于连通还有如下命题: 连通空间的连续像连通; \(X\times Y\) 连通当且仅当 \(X\), \(Y\) 都连通; 连通分支 连通分支: 极大连通子集. 有如下例子: 离散拓扑空间的每一个点是一个连通分支; 有理数作为欧氏空间的子空间, 每个点是一个连通分支. 中间值定理 设 \(f: X\to\mathbb{E}^1\) 是一个连续函数, 若 \(f\) 可以取到 \(a,b\), 则 \(f\) 可以取到 \(a,b\) 中间的任何值. 局部连通 局部连通: 任意 \(x\), 任意 \(x\) 的邻域 \(U\), 存在连通邻域 \(V\), s.t. \(x\in V\subset U\). 连通未必局部连通. (例子: \((x,\sin(\frac{\pi}{x}))\)) 道路连通性 道路 道路: 连续映射 \(\alpha: I\to X\): 起点为 \(\alpha(0)\), 终点为 \(\alpha(1)\). 逆道路: \(\overline{\alpha}(t)=\alpha(1-t)\). 道路的乘积: 设 \(\alpha: x\to y\), \(\beta: y\to z\), 定义 \[\gamma(t)=\begin{cases} \alpha(2t), &amp; 0\leqslant t\leqslant\frac{1}{2}, \\\\ s\beta(2t-1), &amp; \frac{1}{2}\leqslant t\leqslant 1, \end{cases}\] 则 \(\gamma\) 为 \(\alpha\) 与 \(\beta\) 的乘积道路. 道路的连续像是道路: \(f: X\to Y\) 连续, 则 \(f\circ \alpha\) 是 \(Y\) 中的道路. 道路连通 道路连通空间: 任意两点都有道路连接的空间; 道路连通空间必定是连通的 (反证法: 若不然, 则与 \(I\) 的连通性矛盾); 连通空间未必道路连通: \(\sin(x,\sin(\frac{\pi}{x}))\) (证明 \((0,0)\) 与 \((1,0)\) 之间无道路); 道路连通分支: 极大道路连通子集. 局部道路连通 局部道路连通: 任意 \(x\), 任意 \(x\) 的邻域 \(U\), 存在道路连通邻域 \(V\), s.t. \(x\in V\subset U\); 道路连通未必局部道路连通. (例子: \((\frac{1}{n},t)\cup (0,t)\cup (t,0)~t\in I\)) 连通+局部道路连通 \(\Rightarrow\) 道路连通. 商空间 商空间 商空间: 设 \(X\) 上有等价关系, 则可定义商空间 \(Y=X/\sim\) (把一个等价类捏成一点); 投影映射: \(\pi: X\to Y\), \(x\mapsto [x]\); 商拓扑: 在商空间 \(Y\) 定义拓扑: \[U\subset Y 是开集 \Leftrightarrow \pi^{-1}(U) 是 X 中的开集\] 则称该拓扑为 \(Y\) 上的商拓扑; 关于商空间, 一个重要的性质如下: 定理 设 \(X\) 是拓扑空间, \(Y\) 是 \(X\) 的商空间, \(Z\) 是任意空间, 则: \[f: Y\to Z ~连续~\Leftrightarrow~f\circ\pi: X\to Z~连续.\] 商空间的例子 \(I^2\) 上商空间的几个例子如下: 平环 \(S^1\times I\): \((0,y)\sim(1,y)\); Mobius带: \((0,y)\sim(1,1-y)\). 球面 \(\mathbb{S}^2\): \((0,y)\sim(1,y)\sim(x,0)\sim(x,1)~\forall x,y\). 粘合两组对边可得环面 \(T^2\) 和Klein瓶: 环面 \(T^2\): \((x,0)\sim (x,1)\), \((0,y)\sim (1,y)\); (\(T^2\cong \mathbb{S}^1\times\mathbb{S}^1\)) Klein瓶: \((x,0)\sim (x,1)\), \((0,y)\sim (1,1-y)\). 在 \(S^n\) 上, 重要的商空间是实投影空间: 实投影空间 \(\mathbb{P}^n\): \(x\sim -x\), \(\forall x\in\mathbb{S}^n\). 商映射 商映射: \(f\) 是连续满射, 且 \(U\subset Y\) 是开集 \(\Leftrightarrow\) \(f^{-1}(U)\subset X\) 是开集, 则称 \(f\) 是商映射. 有如下命题: 定理 设 \(f: X\to Y\) 是商映射, 则 1. 映射 \(g: Y\to Z\) 连续 \(\Leftrightarrow\) \(g\circ f: X\to Z\) 连续; 2. \(Y\cong X/\sim\). 关于商映射的判断, 有如下两条常见的定理: 连续满射若同时是开映射或闭映射, 则是商映射; 紧空间到Hausdorff空间的连续满射是商映射. 拓扑锥与双角锥 拓扑锥: \(X\times I\) 上定义 \[(x,1)\sim (x&#39;,1),~\forall x,x&#39;\in X;\] \[(x,t)\sim(x,t), ~\forall x,\forall t&lt;1.\] 而成的商空间称为 \(X\) 的拓扑锥, 记作 \(CX\). 容易知道 \(C\mathbb{S}^{n-1}\cong B^n\). 双角锥: \(X\times[-1,1]\) 上定义 \[(x,1)\sim(x&#39;,1),~\forall x,x&#39;\] \[(x,-1)\sim(x&#39;,-1),~\forall x,x&#39;\] \[(x,t)\sim (x,t), \text{otherwise}.\] 容易知道 \(S\mathbb{S}^{n-1}\cong \mathbb{S}^n\). 拓扑群与轨道空间 拓扑群 拓扑群: 设 \(G\) 是一个Hausdorff空间, 同时也是一个群. 若 \(G\) 的乘法和求逆都连续, 则称 \(G\) 为拓扑群. 子群: 子空间+子群. 同态: 连续+同态. (同构=同胚+同构). 拓扑群的例子: 四元数空间 \(\mathbb{H}=\mathbb{C}^2\); 一般线性群 \(GL(n,\mathbb{R})\subset \mathbb{E}^{n^2}\). 正交群 \(O(n)\), \(SO(n)\) 和 酉群 \(U(n)\), \(SU(n)\). 拓扑群作用 拓扑群作用: 连续映射 \(\phi: G\times X\to X\), s.t. \(\phi(hg,x)=\phi(h,\phi(g,x))\), \(\forall g,h,x\); \(\phi(e,x)=x\), \(\forall x\) 可以简写为: \((hg)x=h(gx)\); \(ex=x\). 轨道空间 轨道: \(O(x)=\{gx~\vert~g\in G\}\), 显然轨道相交等价于轨道重合; 轨道空间: \(x\sim y: O(x)=O(y)\). 记作 \(X/G\). 可迁作用: \(\forall x,y\in X\), \(\exists g\in G\), s.t. \(gx=y\); 自由作用: \(\forall g\neq h\in G\), \(\forall x\in X\), \(gx\neq hx\). 迷向群: \(G_x=\{g\in G~\vert~gx=x\}\subset G\). \(G\) 是自由作用当且仅当每点的迷向群是平凡群. 关于轨道空间的连通性有如下命题: 命题 设 \(G\) 是拓扑群, 作用于 \(X\) 上. 若 \(G\) 与 \(G/X\) 连通, 则 \(X\) 连通. 反证法: 取开集 \(X=A\cup B\), 则 \(U=\pi(A)\cap\pi(B)\) 非空, 取 \([p]\in U\), 考虑 \(O_p\) 的连通性即可得结论. 代数拓扑 映射与空间的同伦 映射的同伦 映射同伦: 设 \(X,Y\) 是拓扑空间, \(f,g:X\to Y\) 是连续映射, 则 \(f\) 到 \(g\) 的同伦是指连续映射 \[F: X\times I\to Y,~\text{s.t.}~F(x,0)=f(x),~F(x,1)=g(x).\] 此时称 \(f\) 与 \(g\) 同伦, 记作 \(f\underset{F}{\simeq} g\). 相对子集的同伦: 若对于 \(A\subset X\) 有 \[F(a,t)=f(a),~\forall a\in A,t\in I,\] 则称 \(f\) 与 \(g\) 相对于 \(A\) 同伦, 记作 \(f\underset{F}{\simeq} g, rel A\). 线性同伦: \(C\) 是 \(\mathbb{E}^n\) 中的凸集, 映射 \(f,g: X\to C\) 连续, 取 \[F(x,t)=(1-t)f(x)+tg(x),\] 则 \(f\underset{F}{\simeq} g\). 零伦: 同伦于常值映射的映射称为是零伦的. \(X\) 到 \(\mathbb{E}^n\) 中凸集的连续映射是零伦的. 环路: \(\alpha: I\to X\) 是一条道路, 且 \(\alpha(0)=\alpha(1)=p\), 则称 \(\alpha\) 是以 \(p\) 为基点的环路. 保基点同伦: \(\alpha\simeq \beta,~rel\{0,1\}\). 空间的同伦等价 同伦等价: 存在连续映射 \[f: X\to Y,\quad g:Y\to X,\] s.t. \[g\circ f\simeq id_X: X\to X,\quad f\circ g\simeq Y\to Y.\] 则称 \(X\) 与 \(Y\) 同伦等价, 记作 \(X\simeq Y\). 几个例子如下: \(\mathbb{E}^n-\{0\}\simeq\mathbb{S}^{n-1}\), \(f(x)=\frac{x}{\Vert x\Vert}\), \(g(x)=x\); \(CX\simeq \{p(锥顶)\}\), \(f(x)=p\), \(g(p)\) 为包含映射. 收缩 可缩空间: 与单点同伦等价的空间; 收缩核: \(A\subset X\), 若存在连续映射 \(r: X\to A\), s.t. \(r\vert_A=id_A\), 则称 \(A\) 是 \(X\) 的收缩核; 形变收缩: \(A\subset X\), \(i: A\to X\) 是包含映射, \(r\) 是 \(X\) 到 \(A\) 的收缩. 若 \(id_X\underset{F}{\simeq} i\circ r\), 则称 \(F\) 是 \(X\) 到 \(A\) 的形变收缩, \(A\) 是 \(X\) 的形变收缩核; 强形变收缩: 若 \(id_X\underset{F}{\simeq} i\circ r,~rel A\) 则称 \(A\) 是 \(X\) 的强形变收缩核. 命题 \(X\) 可缩 \(\Leftrightarrow\) \(X\) 可形变收缩到其中一点. 几个例子: 1. \(\mathbb{S}^1\) 是平环和Mobius带的强形变收缩核; 2. \(\mathbb{S}^{n-1}\) 是 \(\mathbb{E}^n-\{0\}\) 的强形变收缩核. 基本群 基本群 基本群: 拓扑空间上以 \(p\) 点为基点的环路的保基点同伦类关于同伦类的乘积构成一个群, 称为基本群 \(\pi_1(X,p)\). &gt; 道路连通空间的基本群 若 \(X\) 道路连通, 则 \(\pi_1(X,p)\cong \pi_1(X,q)\), \(\forall p,q\). 基本群的不变性 设 \(f: X\to Y\) 连续, 且 \(f(p)=q\), 则 \(f\) 可以诱导映射 \[g: \pi_1(X,p)\to \pi_1(Y,q),~\langle\alpha\rangle\mapsto \langle f\circ\alpha\rangle.\] 且由 \[g\circ(\alpha\cdot\beta)=(f\circ\alpha)\cdot(f\circ\beta)\] 可知 \(g\) 是同态. 乘积空间的基本群 命题 若 \(X,Y\) 道路连通, 则 \[\pi_1(X\times Y,(x_0,y_0))\cong \pi_1(X,x_0)\times \pi_1(Y,y_0).\] \(\mathbb{S}^n\) 的基本群 道路提升定理 道路提升 \(\alpha\) 是 \(\mathbb{S}^1\) 内以 \(1\) 为起点的道路, 则存在 \(\mathbb{E}^1\) 中唯一一条以 \(0\) 为起点的道路\(\tilde{\alpha}\), s.t. \(\pi\circ\tilde{\alpha}=\alpha\). 同伦提升定理 同伦提升 \(\alpha\), \(\beta\) 是 \(\mathbb{S}^1\) 中的两条道路, 且 \(\exists F:I\times I\to \mathbb{S}^1\), s.t. \(\alpha\underset{F}{\simeq}\beta\), 若 \(\alpha\) 有提升, 则 \(F\) 有唯一提升 \(\tilde{F}: I\times I\to\mathbb{E}^1\), s.t. \(\tilde{F}(0,0)=0\). \(\mathbb{S}^n\) 的基本群 \(\mathbb{S}^1\) 的基本群为 \(\mathbb{Z}\); \(\mathbb{S}^n~(n&gt;2)\) 的基本群为平凡群. 基本群的应用 代数学基本定理: \(\mathbb{C}\) 上的 \(n\) 次多项式存在零点; Brouwer 不动点定理: \(\mathbb{B}^n\) 具有不动点性质(任意到自身的连续映射有不动点). Van Kampen 定理 van kampen 设 \(X\) 可以写成非空开集 \(X_1\), \(X_2\) 的并集且 \(X_0=X_1\cap X_2\neq\varnothing\). 设 \(X\) 与 \(X_0\) 道路连通, 取 \(x_0\in X_0\), 则 \[\pi_1(X,x_0)\cong\pi_1(X_1,x_0)*\pi_1(X_2,x_0)/\sim,\] 其中 \(\sim\) 是等价关系 \[\{i_{1*}(\alpha)=i_{2*}(\alpha)~\vert~\alpha\in\pi_1(X_0,x_0)\}~(i_k~是~X_0\to X_k~的包含映射).\] 两个特殊情形如下: 推论 1 若 \(X_0\) 单连通, 则 \[\pi_1(X,x_0)\cong\pi_1(X_1,x_0)*\pi_1(X_2,x_0).\] 推论 2 若 \(X_2\) 单连通, 则 \[\pi_1(X,x_0)\cong\pi_1(X_1,x_0)/\sim,\] 其中 \(\sim\) 为等价关系 \(\{i_{1*}(\alpha)=e~\vert~\alpha\in\pi_1(X_0,x_0)\}\). 闭曲面分类定理 曲面: 第二可数的Hausdorff空间 \(S\) 称为曲面当且仅当 \(\forall x\in S\), 存在 \(x\) 的邻域 \(U\), s.t. \(U\) 同胚于圆盘 \(D^2\) 或 半圆盘\(D^2_+\); 内部: 存在邻域同胚于圆盘的点称为内点, 内点的全体称为内部; 边界: 存在邻域同胚于半圆盘的点称为边界点, 边界点的全体称为边界. 闭曲面: 紧致无边界的曲面称为闭曲面. 关于曲面还有如下结论: 曲面间的同胚把内点映射到内点, 边界点映射到边界点; 同胚的曲面具有同胚的边界. (由上一条可得到) 如下定义曲面的可定向性: 不可定向曲面: 存在一个同胚于Mobius带的子空间. (否则称为可定向的) 闭曲面分类定理 \(\mathbb{S}^2\), \(nT^2~(n\in\mathbb{N})\), \(m\mathbb{P}^2~(m\in \mathbb{N})\) 是两两不同胚的闭曲面, 且所有的闭曲面都可以归为这三类. 进一步, 1. 可定向曲面必定同胚于 \(\mathbb{S}^2\) 或 \(nT^2~(n\in\mathbb{N})\); 2. 不可定向曲面必定同胚于 \(m\mathbb{P}^2~(m\in \mathbb{N})\). 复叠空间 复叠空间 复叠映射: 设 \(E,B\) 是道路连通且局部道路连通的空间, \(p: E\to B\) 是连续映射. 若对 \(\forall b\in B\), 存在 \(b\) 的开邻域 \(U\), s.t. \(p^{-1}(U)\) 是 \(E\) 中一族两两不交的开集 \(\{V_\alpha\}\) 的并集, 且 \(p\vert_{V_\alpha}: V_\alpha\to U\) 是同胚, 则称 \(p\) 是复叠映射. 复叠空间: \((E,p)\) 称为 \(B\) 上的复叠空间. 基本邻域: 上述定义中的 \(U\) 称为基本邻域. \(U\) 的逆像可以拆成若干与 \(U\) 同胚的集合的不交并. 纤维: \(b\in B\), 称 \(p^{-1}(b)\) 为 \(b\) 的纤维. 其基数称为复叠空间的重数/叶数. 简单来说, 复叠映射就是把一族同胚的不交开集映射到同一开集的映射, 原空间就称为复叠空间. 如果该映射是 \(n\) 对 \(1\) 的, 则该空间是 \(n\) 重的. 复叠空间上的道路提升与同伦提升 道路提升 若 \(\alpha\) 是以 \(b_0\in B\) 为起点的一条道路, \(e_0\in p^{-1}(b_0)\), 则存在 \(E\) 内唯一一条以 \(e_0\) 为起点的道路 \(\tilde{\alpha}\), s.t. \[\alpha=p\circ\tilde{\alpha}.\] 这说明 \(B\) 中以 \(b_0\) 为起点的道路与 \(E\) 中以 \(e_0\) 为起点的道路一一对应. 同伦提升 若 \(\alpha_1,\alpha_2\) 是 \(B\) 内两条道路, 且 \[\alpha_1\underset{F}{\simeq}\alpha_2.\] 设 \(\tilde{\alpha}_1\) 是 \(\alpha_1\) 的提升, 且 \(\tilde{\alpha}_1(0)=e_0\in E\), 则 \(F\) 有唯一提升 \[\tilde{F}: I\times I\to E,~\text{s.t.}~\tilde{F}(0,0)=e_0.\] 推论 若 \(\alpha_1,\alpha_2\) 是 \(B\) 内两条道路, 且 \[\alpha_1\simeq\alpha_2,~rel\{0,1\}.\] 设 \(\tilde{\alpha}_i\) 是 \(\alpha_i\) 的提升, 且 \(\tilde{\alpha_1}(0)=\tilde{\alpha_2}(0)\), 则 \[\alpha_1\simeq\alpha_2,~rel\{0,1\}.\] 这说明道路提升中产生的一一对应能够保持保端点同伦. 复叠空间的基本群 复叠映射 \(p\) 可诱导单同态 \(p_*: \pi_1(E,e_0)\to\pi_1(B,b_0)\), 且 \(p_*(\pi_1(E,e_0))\) 在 \(\pi_1(B,b_0)\) 中的指数等于 \((E,p)\) 的重数. 命题 集合 \(\{p_*(\pi_1(E,e))~\vert~e\in p^{-1}(b_0)\}\) 是 \(\pi_1(B,b_0)\) 的某个子群的共轭类. 这说明复叠空间 \((E,p)\) 决定了 \(\pi_1(B,b_0)\) 中的一个子群共轭类. 映射的提升 映射提升的唯一性 设 \((E,p)\) 是 \(B\) 上的复叠空间, \(X\) 连通, 映射 \(\tilde{f_i}: X\to E\), \(i=1,2\) 都是 \(f: X\to B\) 的提升. 若 \[\exists x_0\in X,~\text{s.t.}~\tilde{f}_1(x_0)=\tilde{f}_2(x_0),\] 则 \(\tilde{f}_1=\tilde{f}_2\). 这说明对于 \(f(x_0)=b_0\), 满足 \(\tilde{f}(x_0)=e_0\) 的提升若存在必唯一. 对于提升的存在性, 有如下定理: 映射提升定理 设 \(X\) 是道路连通且局部道路连通空间, \(f: X\to B\) 连续, \(f(x_0)=b_0\), \(e_0\in p^{-1}(b_0)\), 则: \[\exists~提升~\tilde{f},~\text{s.t.}~\tilde{f}(x_0)=e_0~\Leftrightarrow~f_*(\pi_1(X, x_0))\subset p_*(\pi_1(E,e_0)).\] 复叠空间的分类 复叠空间的同态: \((E_i, p_i)\), \(i=1,2\) 是 \(B\) 上的复叠空间, 若连续映射 \(h: E_1\to E_2\) 满足 \(p_2\circ h=p_1\), 则称 \(h\) 是复叠空间 \((E_1,p_1)\to (E_2,p_2)\) 的同态. 当 \(h\) 是同胚时, 则称 \(h\) 是同构. 定理 \((E_1,p_1)\) 与 \((E_2,p_2)\) 等价 \(\Leftrightarrow\) 它们决定 \(\pi_1(B,b_0)\) 的同一个子群共轭类. 复叠变换 复叠变换: \((E,p)\) 上的自同构; 复叠变换群: \((E,p)\) 上自同构全体关于映射的复合构成一个群, 记作 \(D(E,p)\). 正则复叠空间 以下命题等价: \((E,p)\) 是正则复叠空间; \(\forall b\in B\), \(e\in p^{-1}(b)\), \(p_*(\pi_1(E,e))\) 是 \(\pi_1(B,p(e))\) 的正规子群; \(\forall b\in B\), \(e,e&#39;\in p^{-1}(b)\), \(p_*(\pi_1(E,e))=p_*(\pi_1(E,e&#39;))\); \(\forall b\in B\), \(e,e&#39;\in p^{-1}(b)\), \(\exists h\in D(E,p)\), s.t. \(h(e)=e&#39;\). 万有复叠空间 万有复叠空间: 单连通的复叠空间.(显然正则) 命题 设 \(p:E\to B\) 是复叠空间, \(p&#39;: E&#39;\to B\) 是万有复叠空间, 则有复叠映射 \(\tilde{p}: E&#39;\to E\), s.t. \(p&#39;=p\circ\tilde{p}\).]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>数学</tag>
        <tag>拓扑学</tag>
        <tag>期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数理统计复习重点]]></title>
    <url>%2F2018%2F01%2F06%2F%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9%2F</url>
    <content type="text"><![CDATA[基本概念 \(\chi^2\) 分布 定义 设 \(X_1,\cdots,X_n\) 为来自 \(N(0,1)\) 的iid样本, 则称随机变量 \[\xi=\sum\limits_{i=1}^nX_i^2\] 所服从的分布为自由度为 \(n\) 的 \(\chi^2\) 分布, 记为 \(\xi\sim\chi^2(n)\). 性质 \(E\xi=n\), \({\rm Var}~\xi=2n\); 设 \(\xi\sim\chi^2(m)\), \(\eta\sim\chi^2(n)\), 且二者独立, 则 \(\xi+\eta\sim\chi^2(m+n)\); \((n-1)S_n^2/\sigma^2\sim\chi^2(n-1)\). \(t\) 分布 定义 设 \(\xi\sim N(0,1)\), \(\eta\sim\chi^2(n)\), 且 \(\xi\), \(\eta\) 相互独立, 则称随机变量 \[T=\frac{\xi}{\sqrt{\eta/n}}\] 服从自由度为 \(n\) 的 \(t\) 分布, 记为 \(T\sim t(n)\). 性质 设 \(\xi\sim t(n)\), \(n&gt;2\), 则 \(E\xi=0\), \({\rm Var}~\xi=\frac{n}{n-2}\); \(t(1)\) 分布为Cauchy分布, 期望不存在; \(\frac{\sqrt{n}(\overline{X}-\mu)}{S}\sim t(n-1)\) ; \(F\) 分布 定义 设 \(\xi,\eta\) 是自由度分别为 \(m,n\) 的独立的 \(\chi^2\) 随机变量, 则称随机变量 \[F=\frac{\xi/m}{\eta/n}\] 服从自由度为 \((m,n)\) 的 \(F\) 分布, 记为 \(F\sim F(m,n)\). 性质 \(X\sim F(m,n) \Longleftrightarrow \frac{1}{X}\sim F(n,m)\). \(\Gamma\) 分布族 定义 PDF 为 \[\Gamma(x;\alpha,\lambda)=\frac{\lambda^\alpha}{\Gamma(\alpha)}x^{\alpha-1}e^{-\lambda x},\quad x&gt;0\] 的分布称为 \(\Gamma\) 分布, 记作 \(\Gamma(\alpha,\lambda)\). 性质 \(\Gamma(\frac{n}{2},\frac{1}{2})=\chi^2(n)\); \(\Gamma(1,\lambda)=E(\lambda)\), PDF 为 \(f(x)=\lambda e^{-\lambda x},~x&gt;0\); \(\xi\sim\Gamma(\alpha_1,\lambda)\), \(\eta\sim\Gamma(\alpha_2,\lambda)\), \(\eta\) 与 \(\xi\) 独立 \(\Rightarrow\) \(\xi+\eta\sim\Gamma(\alpha_1+\alpha_2,\lambda)\); \(\xi\sim\Gamma(\alpha,\lambda)\), \(k&gt;0\in\mathbb{R}\) \(\Rightarrow\) \(\xi/k\sim\Gamma(\alpha,k\lambda)\). 充分统计量 因子分解定理 定理 对于参数分布族 \[\mathcal{F}=\{f_\theta(x):\theta\in\Theta\},\] 设 \(X_1,\cdots,X_n\) 是其中一组iid样本, \(T\) 是一统计量, 且其样本分布 \(f_\theta\) 满足 \[f_\theta(x_1,\cdots,x_n)=g_\theta(T(x_1,\cdots,x_n))\cdot h(x_1,\cdots,x_n),\] 其中 \(h(x)\) 不依赖于 \(\theta\). 常见的充分统计量 均匀分布 \(U(0,\theta)\) 中 , \(X_{(n)}\) 为 \(\theta\) 的充分统计量; 正态分布 \(N(\mu,\sigma^2)\) 中, \((\overline{X},\sum\limits_{i=1}^n (X_i-\overline{X})^2)\) 为 \((\mu,\sigma^2)\) 的充分统计量; 均匀分布 \(U(-\frac{1}{2}+\theta, \frac{1}{2}+\theta)\) 中, \((X_{(1)},X_{(n)})\) 为 \(\theta\) 的充分统计量. 点估计 矩估计 矩估计 对于样本 \(X_1,\cdots,X_n\) 和 \(k\in\mathbb{N}\), 称 \[a_k=\frac{1}{n}\sum\limits_{i=1}^n X_i^k,\quad m_k=\frac{1}{n}\sum\limits_{i=1}^n (X_i-\overline{X})^k\] 为 \(k\) 阶中心矩和 \(k\) 阶原点矩. 而总体的原点矩和中心矩分别为 \[\mu_k=\mathbb{E}X^k,\quad \nu_k=\mathbb{E}(X-\mu_1)^k\] 矩估计就是用样本矩来估计总体矩, 即令 \(a_k=\mu_k\), \(m_k=\nu_k\). 几个矩估计的例子 总体均值和总体方差: \[\hat{\mu}=\overline{X},\quad \hat{\sigma}^2=\frac{n-1}{n}S_n^2;\] 正态分布 \(U(0,\theta)\) 中, \(\theta\) 的矩估计为 \(\hat{\theta}=2\overline{X}\);]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>数学</tag>
        <tag>概率论</tag>
        <tag>统计学</tag>
        <tag>期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测度与概率复习重点]]></title>
    <url>%2F2018%2F01%2F02%2F%E6%B5%8B%E5%BA%A6%E4%B8%8E%E6%A6%82%E7%8E%87%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9%2F</url>
    <content type="text"><![CDATA[测度空间 各种集类 半集代数 \(\Omega\in\mathscr{S}\), \(\varnothing\in\mathscr{S}\); 若 \(A,B\in\mathscr{S}\), 则 \(A\cap B\in\mathscr{S}\); 若 \(A,A_1\in\mathscr{S}\), \(A_1\subset A\), 则 \(\exists A_2,\cdots,A_n\subset\mathscr{S}\), \(A_1,\cdots,A_n\) 两两不交, 且 \(A=\bigcup\limits_{k=1}^nA_k\). 集代数 \(\Omega\in\mathscr{A}\); 若 \(A,B\in\mathscr{A}\), 则 \(A\cap B, A\cup B\in\mathscr{A}\); 若 \(A\in\mathscr{A}\), 则 \(A^c\in\mathscr{A}\). 包含半集代数 \(\mathscr{S}\) 的最小集代数为 \(\mathscr{A}(\mathscr{S})=\{\bigcup\limits_{k=1}^n A_k:A_1,\cdots,A_n\in\mathscr{S}\}\). \(\sigma\) 代数 \(\Omega\in\mathcal{F}\); 若 \(A\in\mathcal{F}\), 则 \(A^c\in\mathcal{F}\); 若 \(A_n\in\mathcal{F}~(n\in\mathbb{N})\), 则 \(\bigcup\limits_{n=1}^\infty A_n\in\mathcal{F}\). 任意一族 \(\sigma\) 代数的交仍然是 \(\sigma\) 代数; 所有包含 \(\mathcal{C}\) 的 \(\sigma\) 代数的交称为包含 \(\mathcal{C}\) 的最小 \(\sigma\) 代数, 记作 \(\sigma(\mathcal{C})\). 单调类定理 \(\lambda\) 系 \(\Omega\in\Lambda\); 对真差封闭: \(A,B\in\Lambda\), \(A\subset B\), 则 \(B\backslash A\in\Lambda\); 对不降序列的并封闭: \(\{A_n:n\in\mathbb{N}\} \subset\Lambda\), \(A_n\uparrow\), 则 \(\bigcup\limits_{n=1}^\infty A_n\in\Lambda\). \(\pi\) 系 对交封闭: \(A,B\in\Lambda\), 则 \(A\cap B\in\Lambda\). 单调类定理 定理 设 \(\Omega\) 的子集类 \(\mathcal{C}\) 是 \(\pi\) 系, 则 \(\Lambda(\mathcal{C})=\sigma(\mathcal{C})\). 证明思路: 令 $_A={B():AB()} $; \(\forall A\in\Lambda(\mathcal{C})\), 证明 \(\Lambda_A\) 是 \(\lambda\) 系; \(\forall A\in\mathcal{C}\), 证明 \(\Lambda_A=\Lambda(\mathcal{C})\); \(\forall A\in\Lambda(\mathcal{C})\), 证明 \(\Lambda_A=\Lambda(\mathcal{C})\). 测度的构造 有限可加测度 可加: \(\forall A,B\in\mathcal{C}\), \(A\cup B\in\mathcal{C}\), \(A\cap B=\varnothing\), 有 \(\mu(A\cup B)=\mu(A)+\mu(B)\). 可加测度 \(\Leftrightarrow\) 有限可加测度. \(\sigma\) 可加测度 \(\forall A_n\in\mathcal{C}\), \(n\in\mathbb{N}\) 两两不交且 \(\bigcup\limits_{n=1}^\infty A_n\in\mathcal{C}\), 有 \(\mu(\bigcup\limits_{n=1}^\infty A_n)=\sum\limits_{n=1}^\infty\mu(A_n)\). \(\sigma\) 有限测度 若 \(\forall A\in\mathcal{C}\), \(\exists \{A_n:n\in\mathbb{N}\} \subset\mathcal{C}\), s.t. \(\bigcup\limits_{n=1}^\infty A_n=A\) 且 \(\mu(A_n)&lt;\infty\), \(\forall n\in\mathbb{N}\), 则称其为 \(\sigma\) 有限的. 测度扩张定理 半集代数上的测度 定理 设 \(F\) 为 \(\mathbb{R}\) 上的右连续增函数, 则在半集代数 \[\mathscr{S}:=\{(a,b]:-\infty\leqslant a\leqslant b\leqslant\infty\} \] 上有唯一的测度 \(\mu=\mu_F\), s.t. \[\mu((a,b])=F(b)-F(a),~a\leqslant b\leqslant a,b\in\mathbb{R},\] 并且 \(\mu\) 在有限区间上的值有限(因而 \(\sigma\) 有限). 测度扩张定理 定理 设 \(\mu\) 为 \(\Omega\) 的半集代数 \(\mathscr{S}\) 上的测度, 则 \(\mu\) 在 \(\mathscr{S}\) 生成的 \(\sigma\) 代数 \(\sigma(\mathscr{S})\) 上存在一个扩张. 若 \(\mu\) 是 \(\sigma\) 有限的, 则扩张唯一. 唯一性证明: \(\lambda-\pi\) 系方法. 外测度 \(\mu^*(\varnothing)=0\); 不降性: \(\forall A\subset B\subset\Omega\), 有 \(\mu^*(A)\leqslant \mu^*(B)\); 次 \(\sigma\) 可加性: \(\forall A_n\subset\Omega\), \(n\in\mathbb{N}\), 有 \[\mu^*(\bigcup\limits_{N=1}^\infty A_n)\leqslant \sum\limits_{n=1}^\infty \mu^*(A_n).\] \(\mu^*\) 可测集: \(\mu^*(D)=\mu^*(A\cap D)+\mu^*(A^c\cap D)\). 测度空间 测度空间 \((\Omega,\mathcal{F},\mu)\) 是测度空间当且仅当 \(\mathcal{F}\) 是 \(\sigma\) 代数且 \(\mu\) 是 \(\Omega\) 上的 \(\sigma\) 可加测度. 若 \(\mu(\Omega)=1\) 则称为概率空间, \(\mu\) 即为概率 \(\mathbb{P}\). 可加性的提升 定理 \(\mu\) 为集代数 \(\mathscr{A}\) 上的可加测度, 若 \(\mu\) 还满足以下条件之一: \(\mu\) 下方连续: 即对 \(\forall \{A_n\} \subset\mathscr{A}\), \(A_n\uparrow A\), 总有 \(\lim\limits_ {n\to\infty}\mu(A_n)=\mu(A)\); \(\mu\) 有限且在 \(\varnothing\) 上方连续: 即对 \(\forall \{A_n\} \subset\mathscr{A}\), \(A_n\downarrow\varnothing\), 都有 \(\lim\limits_{n\to\infty}\mu(A_n)=0\). 则 \(\mu\) 为 \(\mathscr{A}\) 上的测度(即有限可加可提升为 \(\sigma\) 可加). 测度的完全化 \(\mu\) 零集: 零测集的子集称为 \(\mu\) 零集; 完全测度: 若每一个 \(\mu\) 零集都属于 \(\mathcal{F}\), 则称 \(\mu\) 为完全测度, 该测度空间为完全测度空间. 定理 设 \((\Omega, \mathcal{F}, \mu)\) 为测度空间, 令 \[\overline{\mathcal{F}}=\{A\triangle N:A\in\mathcal{F}, N 为 \mu 零集\} =\{A\cup N:A\in\mathcal{F}, N 为 \mu 零集\} \] \[\overline{\mu}(A\triangle N)=\mu(A),~A\in\mathcal{F},~N 为 \mu 零集合\] 则 \((\Omega,\overline{\mathcal{F}},\overline{\mu})\) 为一个完全测度空间, 称为原空间的完全化. 可测函数与随机变量 逆像 逆像与集合运算的交换 设 \(f\) 是 \(\Omega\to E\) 的映射, 则 \(f^{-1}\) 有如下性质: \(f^{-1}(E)=\Omega\), \(f^{-1}(\varnothing)=\varnothing\); \(f^{-1}(B^c)=(f^{-1}(B))^c\); \(f^{-1}(\bigcup\limits_{\gamma\in\Gamma}B_\gamma)=\bigcup\limits_{\gamma\in\Gamma}f^{-1}(B_\gamma)\); \(f^{-1}(\bigcap\limits_{\gamma\in\Gamma}B_\gamma)=\bigcap\limits_{\gamma\in\Gamma}f^{-1}(B_\gamma)\); \(f^{-1}(B_1\backslash B_2)=f^{-1}(B_1)\backslash f^{-1}(B_2)\). 逆像与集类 进一步, \(f^{-1}\) 还对集类有相同的作用: \(\mathscr{E}\) 为 \(E\) 的一个 \(\sigma\) 代数 \(\Rightarrow\) \(f^{-1}(\mathscr{E})\) 是 \(\Omega\) 的 \(\sigma\) 代数; \(\mathcal{C}\) 是 \(E\) 的任意非空子集类, 则 \(f^{-1}(\sigma(\mathcal{C}))=\sigma(f^{-1}(\mathcal{C}))\). (证明: \(\lambda-\pi\) 系方法) 随机变量 定理 \(X\) 是 \((\Omega,\mathcal{F})\to (E,\mathscr{E})\) 的可测映射的充要条件是: 存在 \(\mathscr{E}\) 的一个子集类 \(\mathcal{C}\), s.t. 1. \(\sigma(\mathcal{C})=\mathscr{E}\); 2. \(\forall A\in\mathcal{C}\), \(X^{-1}(A)\in\mathcal{F}\). 可测函数的构造 非负简单函数→非负可测函数→可测函数 单调类定理 \(\mathscr{L}\) 系 设 \(\mathscr{L}\) 是定义在 \(\Omega\) 上的广义实函数类, 满足: \(f\in\mathscr{L}\Rightarrow f^+,f^-\in\mathscr{L}\). 函数族 \(L\) 称为 \(\mathscr{L}\), 如果满足: 1. \(1\in L\); 2. \(L\) 中有限个函数的线性组合(如果有意义)属于 \(L\); 3. 若 \(f_n\in L\), \(n\in\mathbb{N}\), \(0\leqslant f_n\uparrow f\), \(f\) 有界或 \(f\in\mathscr{L}\), 则 \(f\in L\). 单调类定理 若 \(\mathscr{L}\) 系 \(L\) 包含一 \(\pi\) 系 \(\mathcal{C}\) 中任意集合的示性函数, 则 \(L\) 包含所有属于 \(\mathscr{L}\) 的 \(\sigma(\mathcal{C})\) 可测函数. 证明: \(\lambda-\pi\) 系方法. 积分与数学期望 非负简单函数→非负可测函数→可测函数 积分的性质 单调收敛 定理 若 \(f_n\), \(n\in\mathbb{N}\) 是非负(可举反例)可测函数列, 且 \(f_n\uparrow f\), 则 \(\lim\limits_{n\to\infty}\int f_n=\int f\). 积分的序性质 若 \(f,g\) 为实函数, \(\int f\), \(\int g\) 存在, 且 \(f\geqslant g\), a.e. 则 \(\int_A f\geqslant \int_A g\), \(\forall A\in\mathcal{F}\). 若 \(\int f\) 存在, 则 \(\vert\int f\vert\leqslant \int\vert f\vert\), \(f\geqslant 0\), 则 \(\int f=0\Leftrightarrow f=0\), a.e.. 可积性质 给定可测函数 \(f,g\) 有: \(f\) 可积 \(\Leftrightarrow\) $f&lt;$; 当 \(f\) 可积时, \(f\) a.e. 有限; 若 \(\vert f\vert\leqslant g\) 可积, 则 \(f\) 可积; 若 \(f,g\) 可积, 则 \(f+g\) 可积. 期望的性质 独立事件类的扩张 独立事件类可以由 \(\pi\) 系扩张至其生成的 \(\sigma\) 代数. 定理 \(\mathcal{C}_k\subset\mathcal{F}\) 为包含 \(\Omega\) 的 \(\pi\) 系, 若 \(\forall A_k\in\mathcal{C}_k\), \(k=1,\cdots,n\), 有 \[\mathbb{P}(\bigcap\limits_{k=1}^n A_k)=\prod\limits_{k=1}^n \mathbb{P}(A_k),\] 则上式对 \(\forall A_k\in\sigma(\mathcal{C}_k)\), \(k=1,\cdots,n\) 成立. 独立随机变量 定理 设 \(X_1,\cdots,X_n\) 为独立r.v., 且 \(\mathbb{E}X_k\) 有限, 则 \[\mathbb{E}(X_1\cdots X_n)=\prod\limits_{k=1}^n \mathbb{E}X_k.\] L-S 积分表示 分布测度 设 \(f\) 是 \((\Omega,\mathcal{F},\mu)\to(E,\mathscr{E})\) 的可测映射, \(\mu\) 是 \(\mathcal{F}\) 上的测度, 定义 \[\mu_f(B)=\mu(f^{-1}(B)),\quad \forall B\in\mathscr{E},\] 则 \(\mu_f\) 是 \(\mathscr{E}\) 上的测度, 也可记作 \(\mu_f=\mu\circ f^{-1}\). 积分变换定理 定理 设 \(f\) 是 \((\Omega,\mathcal{F},\mu)\to(E,\mathscr{E})\) 的可测映射, \(g\) 是 \((E,\mathscr{E})\) 上的可测函数, 则 \[\int_{f^{-1}(B)}(g\circ f){\rm d}\mu=\int_B g{\rm d}\mu_f,\quad \forall B\in\mathscr{E}.~(同时存在,~存在即相等)\] 积分变换 定理 设 \(\mu\) 是 \((\Omega,\mathcal{F})\) 上的测度, \(p\) 是非负 \(\mathcal{F}\) 可测函数, 定义 \[\nu(A)=\int_A p(w)\mu({\rm d}w),\quad A\in \mathcal{F},\] 则 \(\nu\) 是 \(\mathcal{F}\) 上的测度, 且有 \[\int_A g(w)\nu({\rm d}w)=\int_A g(w)p(w)\mu({\rm d}w).~(同时存在,~存在即相等)\] 积分的收敛 单调收敛定理 定理 给定 \((\Omega,\mathcal{F},\mu)\), \(g\) 为实可积函数, \(f_n\), \(n\in\mathbb{N}\) 是实 \(\mathcal{F}\) 可测函数, 若 \(g\leqslant f_n\uparrow f\), a.e. 则 \[\lim\limits_{n\to\infty}\int f_n=\int\lim\limits_{n\to\infty}f_n.\] Fatou引理 定理 设 \(g,h\) 是可积实函数, ${f_n:n} $ 是实可测函数列, 有 1. \(\forall n\in\mathbb{N}\), \(f_n\geqslant g\), a.e., 则 \[\int\varliminf\limits_{n\to\infty} f_n\leqslant \varliminf\limits_{n\to\infty}\int f_n.\] 2. \(\forall n\in\mathbb{N}\), \(f_n\leqslant h\), a.e., 则 \[\int\varlimsup\limits_{n\to\infty} f_n\geqslant \varlimsup\limits_{n\to\infty}\int f_n.\] 控制收敛定理 定理 设 \(g,h\) 为可积实函数. 1. 若 \(f_n\), \(n\in\mathbb{N}\) 为实可测函数序列, 当 \(g\leqslant f_n\leqslant h\), a.e., \(\forall n\in\mathbb{N}\), \(f_n\to f\), a.e. 时, 有 \(\int f_n\to\int f\). 2. 若 \(f_n\), \(n\in\mathbb{N}\) 为实或复可测函数序列, 当 \(\vert f_n\vert\leqslant g\), a.e., \(\forall n\in\mathbb{N}\), \(f_n\to f\), a.e. 时, 有 \(\int\vert f_n-f\vert\to 0\), 因而 \(\int f_n\to\int f\). 乘积空间 乘积 \(\sigma\) 代数 设 \((\Omega_i,\mathcal{F})\), \(i=1,2\) 是可测空间, 称包含可测矩形 \[\mathcal{C}=\{A_1\times A_2: A_i\in\mathcal{F}, i=1,2\} \] 的最小 \(\sigma\) 代数为 \(\mathcal{F}_1,\mathcal{F}_2\) 的乘积 \(\sigma\) 代数. 可测矩形类 \(\mathcal{C}\) 是一个半集代数; \(\mathscr{B}^2=\mathscr{B}\times\mathscr{B}\). (证明: \(\lambda-\pi\) 系方法) 截集 截集 \(A\subset\Omega_1\times\Omega_2\), \(\omega_i\in\Omega_i\), \(i=1,2\), 称集合 \[A_{\omega_1}=A(\omega_1)=\{\omega_2\in\Omega_2: (\omega_1,\omega_2)\in A\} ,\] \[A_{\omega_2}=A(\omega_2)=\{\omega_1\in\Omega_1: (\omega_1,\omega_2)\in A\} ,\] 分别为 \(A\) 在 \(\omega_1\), \(\omega_2\) 处的截集. 截集的性质 截集与集合的运算可以交换: \(A\cap B=\varnothing\Rightarrow A(\omega_i)\cap B(\omega_i)=\varnothing\); \(A\subset B\Rightarrow A(\omega_i)\subset B(\omega_i)\); \(A=\bigcup\limits_\alpha A^{(\alpha)}\Rightarrow A(\omega_i)=\bigcup\limits_\alpha A^{(\alpha)}(\omega_i)\); \(A=\bigcap\limits_\alpha A^{(\alpha)}\Rightarrow A(\omega_i)=\bigcap\limits_\alpha A^{(\alpha)}(\omega_i)\); \(C=A\backslash B\Rightarrow C(\omega_i)=A(\omega_i)\backslash B(\omega_i)\). 对于截集的可测性有如下定理: 定理 取 \(A\in\mathcal{F}_1\times\mathcal{F}_2\), 则 \(\forall \omega_1\in\mathcal{F}_1\), 有 \(A(\omega_1)\in\mathcal{F}_2\). 证明: \(\lambda-\pi\) 系方法. 截函数 \(f_{\omega_1}=f(\omega_1,\cdot)\) 称为 \(f\) 在 \(\omega_1\) 的截函数; \(f_{\omega_2}=f(\cdot,\omega_2)\) 称为 \(f\) 在 \(\omega_2\) 的截函数; 定理 任意 \(\mathcal{F}_1\times\mathcal{F}_2\) 可测函数的截函数是可测的. 关于截函数还有如下重要定理: 定理 设 \(f\) 是 \(\mathcal{F}_1\times\mathcal{F}_2\) 可测函数, \(\mu_i\) 是 \(\sigma\) 有限测度, 则 \[f^{(2)}=\int_{\Omega_1}f(\omega_1,\cdot)\mu_1({\rm d}\omega_1)\] \[f^{(1)}=\int_{\Omega_2}f(\cdot,\omega_2)\mu_2({\rm d}\omega_2)\] 是非负可测函数. 乘积测度 设 \(\mu_i\) 是 \(\sigma\) 有限测度, 若令 \[\mu(A)=\int_{\Omega_1}\mu_2(A(\omega_1))\mu_1({\rm d}\omega_1),~A\in\mathcal{F}_1\times\mathcal{F}_2,\] 或 \[\mu(A)=\int_{\Omega_2}\mu_1(A(\omega_2))\mu_2({\rm d}\omega_2),~A\in\mathcal{F}_1\times\mathcal{F}_2,\] 则 \(\mu\) 是 \(\mathcal{F}_1\times\mathcal{F}_2\) 上唯一满足 \[\mu(A_1\times A_2)=\mu_1(A_1)\mu_2(A_2),~\forall A_i\in\mathcal{F}_i\] 的 \(\sigma\) 有限测度. 转移测度 映射 \(\lambda:\Omega_1\times\mathcal{F}_2\to [0,\infty]\) 满足下列条件, 就称之为 \((\Omega_1,\mathcal{F}_1)\to(\Omega_2,\mathcal{F}_2)\) 的转移测度: 1. \(\forall B\in\mathcal{F}_2\), \(\lambda(\cdot,B)\) 是 \(\mathcal{F}_1\) 可测函数; 2. \(\forall \omega\in\Omega_1\), \(\lambda(\omega,\cdot)\) 是 \(\mathcal{F}_2\) 上的测度. 若 \(\exists B_{kn}\in\mathcal{F}_k\), \(n\in\mathbb{N}\) 两两不交, \(\Omega_k=\bigcup\limits_{n=1}^\infty B_{kn}\), \(k=1,2\), s.t. \[\sup\limits_{\omega\in B_{1m}}\lambda(\omega,B_{2n})&lt;\infty,~\forall m,n\in\mathbb{N},\] 则称 \(\lambda\) 为 \(\sigma\) 有限转移测度. Fubini定理 定理 设 \(f\) 是非负 \(\mathcal{F}_1\times\mathcal{F}_2\) 可测函数, 则 \[ \begin{align} \int_{\Omega_1\times\Omega_2}f{\rm d}(\mu_1\times\mu_2) &amp;= \int_{\Omega_1}\left(\int_{\Omega_2}f(\omega_1,\omega_2)\mu_2({\rm d}\omega_2)\right)\mu_1({\rm d}\omega_1) \\ &amp;= \int_{\Omega_2}\left(\int_{\Omega_1}f(\omega_1,\omega_2)\mu_1({\rm d}\omega_1)\right)\mu_2({\rm d}\omega_2). \end{align}\] Fubini定理 Fubini 设 \(f\) 是非负 \(\mathcal{F}_1\times\mathcal{F}_2\) 可测函数且 \(\int f{\rm d}(\mu_1\times\mu_2)\) 存在, 则 1. 积分函数存在且可测: - \(g(\omega_1)=\int_{\Omega_2}f(\omega_1,\omega_2)\mu_2({\rm d}\omega_2)\) 存在且 \(\mathcal{F}_1\) 可测; - \(h(\omega_2)=\int_{\Omega_1}f(\omega_1,\omega_2)\mu_1({\rm d}\omega_1)\) 存在且 \(\mathcal{F}_2\) 可测; 2. \(\int_{\Omega_1}g{\rm d}\mu_1\), \(\int_{\Omega_2}h{\rm d}\mu_2\) 存在且 \[\int_{\Omega_1\times\Omega_2}f({\rm d}\mu_1\times\mu_2)=\int_{\Omega_1}g({\rm d}\mu_1)=\int_{\Omega_2}f({\rm d}\mu_2);\] 3. 若 \(f\) 对 \(\mu_1\times\mu_2\) 可积, 则 \(g\), \(h\) 分别对 \(\mu_1\), \(\mu_2\) 可积.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>数学</tag>
        <tag>概率论</tag>
        <tag>测度论</tag>
        <tag>期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛函——复习重点]]></title>
    <url>%2F2017%2F12%2F24%2F%E6%B3%9B%E5%87%BD%E2%80%94%E2%80%94%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9%2F</url>
    <content type="text"><![CDATA[度量空间 基础知识 压缩映像原理 Banach 设 \((\mathscr{X},\rho)\) 是一个完备度量空间, \(T\) 是 \(\mathscr{X}\) 到自身的一个压缩映射, 则 \(T\) 在 \(\mathscr{X}\) 上存在唯一的不动点. 完备化 完备化空间: 包含 \(\mathscr{X}\) 的最小完备度量空间. 关于其存在性有如下定理: 定理 每个度量空间都有一个自身在其中稠的完备化空间. 有界性与列紧性 定理 列紧空间的任意子集都是列紧集. 进一步, 任意闭子集都是自列紧的. 定理 列紧空间必定完备. 反之不成立, 如 \(\mathbb{R}\). 完全有界和列紧 定理 列紧集一定完全有界, 完全有界集必定有界. 定理 有穷维 \(B^*\) 空间的有界集必定完全有界, 完备空间中的完全有界集必定列紧. \(\mathscr{X}\) 中的列紧集、完全有界集、有界集三者的关系如下: \[列紧~\underset{\mathscr{X}~完备}{\rightleftarrows}~完全有界~\underset{有限维B^*}{\rightleftarrows}~有界\] 一致有界和等度连续 一致有界: 设 \(F\subset C(M)\), 若 \(\exists M_1&gt;0\), s.t. \(\vert\varphi(x)\vert\leqslant M~(\forall x\in M,\forall \varphi\in F)\), 则称 \(F\) 一致有界. 等度连续: 设 \(F\subset C(M)\), 若对 \(\forall \epsilon&gt;0\), \(\exists\delta(\epsilon)&gt;0\), s.t. \(\vert\varphi(x_1)-\varphi(x_2)\vert&lt; \epsilon~(\forall x_1,x_2\in M, \rho(x_1,x_2)&lt;\delta,\forall\varphi\in F)\), 则称 \(F\) 等度连续. 关于等度连续, 有如下的Arzela-Ascoli定理: A-A \(F\subset C(M)\) 列紧 \(\Leftrightarrow\) \(F\) 一致有界且等度连续. 准范数与Frechet空间 准范数 线性空间 \(\mathscr{X}\) 上的准范数定义为这个空间上的一个函数 \(\Vert\cdot\Vert:\mathscr{X}\to\mathbb{R}^1\), s.t. \(\Vert x \Vert\geqslant 0\), \(\forall x\in\mathscr{X}\); \(\Vert x\Vert=0\Leftrightarrow x=\theta\); \(\Vert x+y\Vert\leqslant \Vert x\Vert+\Vert y\Vert\), \(\forall x,y\in\mathscr{X}\); \(\Vert -x\Vert=\Vert x\Vert\), \(\forall x\in\mathscr{X}\); \(\lim\limits_{\alpha_n\to 0}\Vert\alpha_n x\Vert=0\), \(\lim\limits_{\Vert x_n\Vert\to 0}\Vert\alpha x_n\Vert=0\), \(\forall x\in\mathscr{X}\), \(\forall\alpha\in\mathbb{K}\). Frechet空间 用准范数 \(\Vert x_n-x\Vert\to 0\) 来定义极限 \(x_n\to x\) 的线性空间 \(\mathscr{X}\), 称为 \(F^*\) 空间. 完备的 \(F^*\) 空间称为Frechet空间. 范数与Banach空间 范数 线性空间 \(\mathscr{X}\) 上的范数 \(\Vert\cdot\Vert\) 是一个非负值函数: \(\mathscr{X}\to\mathbb{R}^1\), s.t. 1. \(\Vert x\Vert\geqslant 0\), \(\forall x\in\mathscr{X}\), 且 \(\Vert x\Vert=0\Leftrightarrow x=\theta\); 2. \(\Vert x+y\Vert\leqslant \Vert x \Vert+ \Vert y\Vert\), \(\forall x,y\in\mathscr{X}\); 3. \(\Vert\alpha x\Vert=\vert\alpha\vert\Vert x\Vert\), \(\forall\alpha\in\mathbb{K}\), \(\forall x\in\mathscr{X}\). Banach空间 具有范数的 \(F^*\) 空间称为 \(B^*\) 空间, 完备的 \(B^*\) 空间称为Banach空间. 范数的等价 范数 \(\Vert\cdot\Vert_1\) 与 \(\Vert\cdot\Vert_2\) 等价是指: \(\Vert x_n\Vert_1\Leftrightarrow \Vert x_n\Vert_2\), \(n\to\infty\). 即: \(\exists C_1,C_2&lt;0\), s.t. \(C_1\Vert x\Vert_1\leqslant\Vert x\Vert_2\leqslant C_2\Vert x\Vert_1\), \(\forall x\in\mathscr{X}\). 定理 有穷维 \(B^*\) 空间的任意范数都等价. 推论 相同维数的有穷维 \(B^*\) 空间代数上同构, 拓扑上同胚. 推论 有穷维 \(B^*\) 空间必定完备, 反之不成立. 半模 半模是 \(P:\mathscr{X}\to\mathbb{R}^1\) 是线性空间 \(\mathscr{X}\) 上的一个函数, s.t. \(P(x)\geqslant 0\), \(\forall x\in\mathscr{X}\); 注意没有要求 \(P(x)=0\Leftrightarrow x=\theta\); \(P(x+y)\leqslant P(x)+P(y)\), \(\forall x,y\in\mathscr{X}\); \(P(\alpha x)=\vert\alpha\vert P(x)\), \(\forall\alpha\in\mathbb{K}\), \(\forall x\in\mathscr{X}\). 有穷维 \(B^*\) 空间 定理 \(B^*\) 空间是有穷维的当且仅当其单位球面是列紧的. 推论 \(B^*\) 空间是有穷维的当且仅当其任意有界集是列紧的. 还有如下的Riesz引理: Riesz 引理 如果 \(\mathscr{X}_0\) 是 \(B^*\) 空间 \(\mathscr{X}\) 的一个真闭子空间, 那么对于 \(\forall 0&lt;\epsilon&lt;1\), \(\exists y\in\mathscr{X}\), s.t. \(\Vert y\Vert=1\), 且 \(\Vert y-x\Vert\geqslant1-\epsilon\), \(\forall x\in\mathscr{X}_0\). 凸集与Minkowski泛函 凸集和凸包 凸集: \(E\) 是凸集 \(\Leftrightarrow\) \(\lambda x+(1-\lambda)y\in E\), \(\forall x,y\in E\), \(\forall 0\leqslant\lambda\leqslant 1\). 凸包: \[co(A)=\{\sum\limits_{i=1}^n\lambda_i x_i ~\vert~ \sum\limits_{i=1}^n \lambda_i=1, \lambda_i\geqslant 0, x_i\in A, i=1,2,\cdots,n, \forall n\in\mathbb{N}\}\]为包含 \(A\) 的最小凸集. Minkowski泛函 \(\mathscr{X}\) 是线性空间, \(C\) 是 \(\mathscr{X}\) 上含有 \(\theta\) 的凸子集, 则如下定义Minkowski泛函: \[P(x)=\inf\{\lambda&gt;0 ~\vert~ \frac{x}{\lambda}\in C\},\quad \forall x\in\mathscr{X}.\] 内积与Hilbert空间 共轭双线性函数 线性空间 \(\mathscr{X}\) 上的双线性函数是指一个二元函数 \(a(\cdot,~\cdot):\mathscr{X}\times\mathscr{X}\to\mathbb{K}\), s.t. \(a(a_1x_1+a_2x_2,y)=a_1a(x_1,y)+a_2a(x_2,y)\); \(a(x,b_1y_1+b_2y_2)=\overline{b_1}a(x,y_1)+\overline{b_2}a(x,y_2)\). 内积 \(\mathscr{X}\) 上的共轭双线性函数 \((\cdot,~\cdot)\) 称为一个内积, 如果满足: \((x,y)=\overline{(y,x)}\); \((x,x)\geqslant 0\), \(\forall x\in\mathscr{X}\), 且 \((x,x)=0\Leftrightarrow x=\theta\). 若去掉 \((x,x)=0\Leftrightarrow x=\theta\) 的要求, 则称为半内积. 定义了内积的空间称为内积空间, 完备的内积空间称为Hilbert空间. Cauchy-Schwarz 不等式 C-S 设 \((\mathscr{X},(\cdot,~\cdot))\) 是内积空间, 取 \(\Vert x\Vert=(x,x)^\frac{1}{2}\), \(\forall x\in\mathscr{X}\), 则有 \[\vert (x,y)\vert\leqslant \Vert x\Vert\Vert y\Vert, \quad \forall x,y\in\mathscr{X}.\]等号当且仅当 \(x=\lambda y\) 取得. 内积空间与 \(B^*\) 空间 内积空间 \(\to\) \(B^*\) 空间 内积空间 \(\mathscr{X}\) 按照 \(\Vert x\Vert=(x,x)^\frac{1}{2}\) 定义范数, 是严格凸的 \(B^*\) 空间, 且内积关于范数连续. \(B^*\) 空间 \(\to\) 内积空间 在 \(B^*\) 空间 \(\mathscr{X}\) 中, 为了引入内积满足上式, 范数必须满足 \[\Vert x+y\Vert^2+\Vert x-y\Vert^2=2\Vert x\Vert^2+2\Vert y\Vert^2,\quad \forall x,y\in\mathscr{X}.\] 正交集 完备正交集: \(S\) 为正交集, 且 \(S^\perp=\{\theta\}\). Bessel 不等式 Bessel设 \(\mathscr{X}\) 是一个内积空间, 若 \(S=\{e_\alpha~\vert~\alpha\in A\}\) 是其中的正交规范基, 那么 \(\forall x\in\mathscr{X}\), 有 \[\sum\limits_{\alpha\in A}|(x,e_\alpha)|^2\leqslant \Vert x\Vert^2.\] 事实上, \(\{\alpha\in A: (x,e_\alpha)\neq 0\}\) 至多可数. Parseval 等式 Parseval 设 \(\mathscr{X}\) 是一个Hilbert空间, \(S\) 是正交规范基, 则 \[S完备\Leftrightarrow \Vert x\Vert^2=\sum\limits_{\alpha\in A}|(x,e_\alpha)|^2,\quad \forall x\in\mathscr{X}.\] 正交分解 定理 设 \(M\) 是Hilbert空间上的一个闭子空间, 则 \(\forall x\in\mathscr{X}\) 存在唯一的正交分解: \[x=y+z\quad (y\in M, z\in M^\perp).\] 线性算子与线性泛函 Riesz定理 Riesz定理 定理 设 \(f\) 是Hilbert空间 \(\mathscr{X}\) 上的一个连续线性泛函, 则存在唯一的 \(y_f\in\mathscr{X}\), s.t. \(f(x)=(x,y_f)\), \(\forall x\in\mathscr{X}\). 该定理直接说明了: 若 \(\mathscr{X}\) 是Hilbert空间, 则 \(\mathscr{X}=\mathscr{X}^*\). 开映像定理 Baire纲定理 Baire 完备度量空间 \((\mathscr{X},\rho)\) 是第二纲集. 开映像定理 定理 设 \(\mathscr{X},\mathscr{Y}\) 都是 \(B\) 空间, 若 \(T\in\mathscr{L}(\mathscr{X},\mathscr{Y})\) 是一个满射, 则 \(T\) 是开映射. 闭图像定理 Bounded Linear Transform B.I.T 设 \(T\) 是 \(B^*\) 空间 \(\mathscr{X}\) 到 \(B\) 空间 \(\mathscr{Y}\) 的连续线性算子, 那么 \(T\) 能唯一地延拓到 \(\overline{D(T)}\) 上称为连续线性算子 \(T_1\), s.t. \(T_1\vert_{D(T)}=T\), 且 \(\Vert T_1\Vert=\Vert T\Vert\). 命题 \(T\) 是闭算子 \(\Leftrightarrow\) \(G_T\) 按照图模 (\(\Vert x\Vert_G=\Vert x\Vert+\Vert Tx\Vert\)) 是闭集. 范数等价定理 定理 设线性空间 \(\mathscr{X}\) 有范数 \(\Vert\cdot\Vert_1\) 和 \(\Vert\cdot\Vert_2\). 若 \(\mathscr{X}\) 关于二者都构成 \(B\) 空间, 且 \(\Vert\cdot\Vert_1\) 比 \(\Vert\cdot\Vert_2\) 强, 则二者等价. 闭图像定理 定理 设 \(\mathscr{X},\mathscr{Y}\) 是 \(B\) 空间. 若 \(T\) 是 \(D(T)\to\mathscr{Y}\) 的闭线性算子, 且 \(D(T)\) 闭, 则 \(T\) 连续. 共鸣定理 共鸣定理 定理 设 \(\mathscr{X}\) 是 \(B\) 空间, \(\mathscr{Y}\) 是 \(B^*\) 空间, 如果 \(W\subset\mathscr{L}(\mathscr{X},\mathscr{Y})\), s.t. \(\sup\limits_{A\in W}\Vert Ax\Vert&lt;\infty~~(\forall x\in\mathscr{X})\), 那么存在常数 \(M\), s.t. \(\Vert A\Vert\leqslant M\), \(\forall A\in W\). 立刻有如下推论: 推论 设 \(\mathscr{X}\) 是Banach空间, \(A\subset\mathscr{X}^*\), 则 \(A\) 有界 \(\Leftrightarrow\) \(\forall x\in\mathscr{X}\), \(\sup\limits_{f\in A}\vert f(x)\vert&lt;\infty\). Banach-Steinhaus定理 B-S 设 \(\mathscr{X}\) 是 \(B\) 空间, \(\mathscr{Y}^*\) 是 \(B^*\) 空间, \(M\) 是 \(\mathscr{X}\) 的稠子集. 取 \(A_n~(n=1,2,\cdots)\in\mathscr{L}(\mathscr{X},\mathscr{Y})\), 则 \(\lim\limits_{n\to\infty}A_n x=Ax~(\forall x)\) 当且仅当: 1. \(\Vert A_n\Vert\) 有界; 2. 对于 \(\forall x\in M\), 有 \(\lim\limits_{n\to\infty}A_n x=Ax\). 该定理实际上说明了算子列的收敛性和有界性很大程度上决定于其在一个稠子集上的情况. Lax-Milgram定理 L-M 设 \(a(x,y)\) 是Hilbert空间 \(\mathscr{X}\) 上的一个共轭双线性函数, s.t. 1. \(\exists M&gt;0\), s.t. \(\vert a(x,y)\vert\leqslant M\Vert x\Vert\Vert y\Vert~~(\forall x,y\in\mathscr{X})\); 2. \(\exists\delta&gt;0\), s.t. \(\vert a(x,y)\vert\geqslant\delta\Vert x\Vert^2~~(\forall x\in\mathscr{X})\). 则存在唯一的有连续逆的线性算子 \(A\in\mathscr{L}(\mathscr{X},\mathscr{Y})\), s.t. \(a(x,y)=(x,Ay)\), \(\forall x,y\in\mathscr{X}\), 且 \(\Vert A^{-1}\Vert\leqslant\frac{1}{\delta^2}\). Hahn-Banach定理 实Hahn-Banach定理 定理 设 \(\mathscr{X}\) 是实线性空间, \(p\) 是定义在 \(\mathscr{X}\) 上的次线性泛函, \(\mathscr{X}_0\) 是 \(\mathscr{X}\) 的实线性子空间, \(f_0\) 是 \(\mathscr{X}_0\) 上的实线性泛函并满足 \(f_0(x)\leqslant p(x)~(\forall x\in\mathscr{X}_0)\). 则 \(\mathscr{X}\) 上存在(未必唯一)一个实线性泛函 \(f\), s.t. 1. \(f(x)\leqslant p(x)~(\forall x\in\mathscr{X})\); 2. \(f(x)=f_0(x)~(\forall x\in\mathscr{X}_0)\). 复Hahn-Banach定理 定理 设 \(\mathscr{X}\) 是复线性空间, \(p\) 是定义在 \(\mathscr{X}\) 上的半模, \(\mathscr{X}_0\) 是 \(\mathscr{X}\) 的线性子空间, \(f_0\) 是 \(\mathscr{X}_0\) 上的线性泛函并满足 \(|f_0(x)|\leqslant p(x)~(\forall x\in\mathscr{X}_0)\). 则 \(\mathscr{X}\) 上存在(未必唯一)一个线性泛函 \(f\), s.t. 1. \(|f(x)|\leqslant p(x)~(\forall x\in\mathscr{X})\); 2. \(f(x)=f_0(x)~(\forall x\in\mathscr{X}_0)\). Hahn-Banach定理 定理 设 \(\mathscr{X}\) 是 \(B^*\) 空间, \(\mathscr{X}_0\) 是 \(\mathscr{X}\) 的线性子空间, \(f_0\) 是定义在 \(\mathscr{X}_0\) 上的有界线性泛函, 则在 \(\mathscr{X}\) 上存在有界线性泛函 \(f\), s.t. 1. \(f(x)=f_0(x)~(\forall x\in\mathscr{X})\) (在 \(\mathscr{X}_0\) 不变); 2. \(\Vert f\Vert=\Vert f_0\Vert_0\) (保范). 由此可以立刻得到推论 推论 1 在 \(B^*\) 空间 \(\mathscr{X}\) 上, \(\forall x_1,x_2\in\mathscr{X}\), \(\exists f\in\mathscr{X}^*\), s.t. \(f(x_1)=f(x_2)\). 推论 2 设 \(\mathscr{X}\) 是 \(B^*\) 空间, \(\forall x_0\in\mathscr{X}\backslash\{\theta\}\), \(\exists f\in\mathscr{X}\), s.t. \(f(x_0)=\Vert x_0\Vert\), 且 \(\Vert f\Vert=1\). 对于 \(B^*\) 空间 \(\mathscr{X}\) 的子空间 \(M\), 有如下结论: 定理 设 \(\mathscr{X}\) 是 \(B^*\) 空间, \(M\) 是其线性子空间. 若 \(x_0\in\mathscr{X}\), 且 \(d:=\rho(x_0,M)&gt;0\), 则 \(\exists f\in\mathscr{X}^*\), s.t. 1. \(f(x)=0~~(\forall x\in M)\); 2. \(f(x_0)=d\); 3. \(\Vert f\Vert=1\). Hahn-Banach定理的几何形式 考虑 \(B^*\) 空间 \(\mathscr{X}\) 中的一个包含 \(\theta\) 的真凸子集 \(E\) 及 \(E\) 外的一点 \(x_0\), 考虑 \(E\) 的Minkowski泛函 \(p(x)\), 则 \(p\) 是 \(\mathscr{X}\) 上的非零连续次线性泛函. 此时考虑Hahn-Banach定理的应用条件, 取子空间 \[\mathscr{X}_0=\{\lambda x_0~\vert~\lambda\in\mathbb{R}^1\}\] 及其上的线性泛函 \(f_0(\lambda x_0)=\lambda p(x_0)\). 则有 \(f_0(x)\leqslant p(x)\). 至此, Hahn-Banach定理的条件已经全部满足. 于是存在实线性泛函 \(f\), s.t. \(f(x)\leqslant p(x)~(\forall x\in\mathscr{X})\), 且 \(f(x)=f_0(x)~(\forall x\in\mathscr{X}_0)\). 又由 \(f_0\) 定义可知 \(f(x_0)\geqslant 0\), 以及 \(f(x)\leqslant 1~(\forall x\in E)\), 故 \(H_f^1\) 分离 \(x_0\) 与 \(E\). 即如下的几何形式的Hahn-Banach定理: 定理 设 \(E\) 是实 \(B^*\) 空间 \(\mathscr{X}\) 上以 \(\theta\) 为内点的真凸子集, 又设 \(x_0\overline{\in}E\), 则必定存在一个超平面 \(H_f^r\) 分离 \(x_0\) 与 \(E\). 由此可得到如下定理: 定理 设 \(E_1\) 和 \(E_2\) 是 \(B^*\) 空间中互不相交的非空凸集, 且 \(E_1\) 有内点, 那么 \(\exists s\in\mathbb{R}^1\) 以及非零线性连续泛函 \(f\), s.t. 超平面 \(H_f^s\) 分离 \(E_1\) 和 \(E_2\). 换言之, 存在非零连续线性泛函 \(f\), s.t. \(f(x)\leqslant s~(\forall x\in E_1)\) 且 \(f(x)\geqslant s~(\forall x\in E_2)\). 进而有如下两条定理: Ascoli定理 Ascoli 设 \(E\) 是实 \(B^*\) 空间 \(\mathscr{X}\) 中的闭凸集, 则 \(\forall x_0\in\mathscr{X}\backslash E\), \(\exists f\in\mathscr{X}^*\) 及 \(a\in\mathbb{R}^1\), s.t. \(f(x)&lt;a&lt;f(x_0)\), \(\forall x\in E\). Mazur定理 Mazur 设 \(E\) 是 \(B^*\) 空间 \(\mathscr{X}\) 上的一个有内点的闭凸集, \(F\) 是 \(\mathscr{X}\) 上的一个线性流形, 又设 \(E\cap F=\varnothing\), 则存在一个包含 \(F\) 的闭超平面 \(L\), s.t. \(E\) 在 \(L\) 的一侧. 共轭空间 设 \(\mathscr{X}\) 是一个 \(B^*\) 空间, \(\mathscr{X}\) 上的所有连续限行泛函全体 \(\mathscr{X}^*\) 按照范数 \(\Vert f\Vert=\sup\limits_{\Vert x\Vert=1} \vert f(x)\vert\) 构成一个 \(B\) 空间, 称为 \(\mathscr{X}\) 的共轭空间. 定理 有 \((L^p[0,1])^*=L^q[0,1]\), \(\frac{1}{p}+\frac{1}{q}=1~(1\leqslant p&lt;\infty)\). 值得注意的是, \((L^\infty[0,1])^*\neq L^1[0,1]\). 第二共轭空间与自反空间 \(\mathscr{X}^*\) 的共轭空间 \(\mathscr{X}^{**}\) 称为 \(\mathscr{X}\) 的第二共轭空间. 自然映射: 对于 \(\forall x\in\mathscr{X}\), 考虑 \(X(f)=f(x)~(\forall f\in\mathscr{X}^*)\), 则 \(X\) 是 \(\mathscr{X}^*\) 上的线性泛函, 且满足 \(\vert X(f)\vert\leqslant \Vert f\Vert\Vert x\Vert\). 因此 \(X\) 是连续的, 满足 \(\Vert X\Vert \leqslant \Vert x\Vert\). 称上文中的映射 \(T:x\mapsto X\) 为自然映射. 容易验证 \(T\) 是一个等距嵌入, 于是有如下定理 定理 \(B^*\) 空间 \(\mathscr{X}\) 与它的第二共轭空间 \(\mathscr{X}^{**}\) 的一个子空间等距同构, 即 \(\mathscr{X}\subset\mathscr{X}^{**}\). 自反空间: 若自然映射 \(T\) 是满射, 则称 \(\mathscr{X}\) 是自反的. 即 \(\mathscr{X}=\mathscr{X}^{**}\) 关于自反空间, 有如下定理: 定理 有限维 \(B^*\) 空间是自反的. 特别地, \(L^p~(1&lt;p&lt;\infty)\) 是自反的. 弱收敛 弱收敛: 设 \(\mathscr{X}\) 是一个 \(B^*\) 空间, \(\{x_n\}\subset\mathscr{X}\), \(x\in\mathscr{X}\). 若对于 \(\forall f\in\mathscr{X}^*\), 均有 \(\lim\limits_{n\to\infty}f(x_n)=f(x)\), 则称 \(\{x_n\}\) 弱收敛于 \(x\), 记作 \(x_n\rightharpoonup x\). 容易得到弱收敛和强收敛有如下关系: 强收敛蕴含弱收敛, 反之不成立(尽管对于 \(\mathbb{R}\) 成立); 当强极限存在时, 强弱收敛等价, 且极限唯一; 弱极限若存在必定唯一(利用Hahn-Banach定理可证). 简单概括如下: \[强收敛 \underset{在 \mathbb{R} 上}{\rightleftarrows}~弱收敛\quad\quad 强极限\underset{强极限存在}{\rightleftarrows}~弱极限\] 在 \(B^*\) 空间上, 有如下的Mazur定理: Mazur 设 \(\mathscr{X}\) 是一个 \(B^*\) 空间, 且 \(x_n\rightharpoonup x_0\)(注意是弱收敛), 则 \(\forall\epsilon&gt;0\), \(\exists \lambda_i&gt;0~(i=1,2,\cdots,n)\), \(\sum\limits_{i=1}^n\lambda_i=1\) s.t. \[\Vert x_0-\sum\limits_{i=1}^n\lambda_i x_i\Vert\leqslant \epsilon.\] \(*\) 弱收敛 \(*\) 弱收敛: 设 \(\mathscr{X}\) 是 \(B^*\) 空间, \(\{f_n\}\subset\mathscr{X}^*\), \(f\in\mathscr{X}^*\). 若 \(\forall x\in\mathscr{X}\), 都有 \(\lim\limits_{n\to\infty}f_n(x)=f(x)\), 则称 \(f_n~*\) 弱收敛于 \(f\), 记作 \(w^*-\lim\limits_{n\to\infty}f_n=f\). \(\mathscr{X}^*\) 上的弱收敛: 设 \(\{f_n\}\subset\mathscr{X}^*\), \(f\in\mathscr{X}^*\). 若对 \(\forall X\in\mathscr{X}^{**}\), 都有 \(X(f_n)\to X(f)\), 则称 \(f_n\) 弱收敛于 \(f\). 可以证明, \(\mathscr{X}^*\) 上的弱收敛 \(\Rightarrow~*\) 弱收敛. 特别地, 当 \(\mathscr{X}\) 是一个自反空间时, 二者等价. 弱列紧与 \(*\) 弱列紧性 对于 \(*\) 弱列紧性, 有如下的定理: 定理: 可分的 \(B^*\) 空间中的有界列必定有 \(*\) 弱列紧的子列. 进一步还有如下的定理: Banach定理: Banach 若 \(\mathscr{X}\) 是 \(B^*\) 空间, 则 \(\mathscr{X}\) 可分 \(\Rightarrow\) \(\mathscr{X}^*\) 可分. Pettis定理: Pettis 自反空间 \(\mathscr{X}\) 的自反空间 \(\mathscr{X}_0\) 也是自反的. 附录 几种范数 范数: 正定性(\(\Vert x\Vert=0\Leftrightarrow x=\theta\))+三角不等式+齐次性. 准范数: 与范数差齐次性; 半范数: 与范数差 \(\Vert x\Vert=0\Leftrightarrow x=\theta\). 几种收敛 \(\mathscr{X}\) 的收敛 强收敛 \(\Rightarrow\) 弱收敛 弱收敛: \(\forall f\in\mathscr{X}^*\), \(f(x_n)\to f(x)\), 记作 \(x_n\rightharpoonup x\); 强收敛: \(\Vert x_n-x\Vert\to 0\), 记作 \(x_n\to x\). \(\mathscr{X}^*\) 的收敛 一致收敛 \(\Rightarrow\) 强收敛 \(\Rightarrow\) 弱收敛 \(\Rightarrow\) \(*\) 弱收敛 一致收敛: \(\Vert f_n-f\Vert\to 0\), 记作 \(f_n\rightrightarrows f\); 强收敛: \(\Vert (f_n-f)x\Vert\to 0~(\forall x\in\mathscr{X})\), 记作 \(f_n\to f\); 弱收敛: \(X(f_n)\to X(f)~(\forall X\in\mathscr{X}^{**})\), 记作 \(f_n\rightharpoonup f\); \(*\)弱收敛: \(\forall x\in\mathscr{X}\), 有 \(f_n(x)\to f(x)\), 记作 \(w^*-\lim\limits_{n\to\infty}f_n=f\); 以上极限若存在必唯一. 几种Banach空间 \(\mathbb{C}^n\) 按照范数 \(\Vert x\Vert=(\sum\limits_{i=1}^n\vert x_i\vert^2)^{\frac{1}{2}}\) 构成一个Banach空间; \(C(M)\) (\(M\) 是一个紧度量空间) 按照范数 \(\Vert f\Vert=\max\limits_{x\in M}\vert f(x)\vert\) 构成一个Banach空间; \(L^p(\Omega,\mu)\) 按照范数 \(\Vert f\Vert=\left(\int\nolimits_\Omega \vert f(x)\vert^p{\rm d}x\right)^{\frac{1}{p}}\) 构成Banach空间.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>泛函分析</tag>
        <tag>期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[明月杯回忆录]]></title>
    <url>%2F2017%2F12%2F05%2F%E6%98%8E%E6%9C%88%E6%9D%AF%E5%9B%9E%E5%BF%86%E5%BD%95%2F</url>
    <content type="text"><![CDATA[0x00. 2014 明月杯流水账 还记得和兄弟们第一次一起打球是军训刚回学校时。那时师大的篮球场还在装修，于是只好跑到北邮的球场。那时北邮还没有门禁，球场的人也不多，正是军训回来放松的好地方。从那以后，虽然经常与同学们一起打球，但因为抱有转专业的想法，所以没有直接加入篮球队，不过后来还是被博哥拉进了球队Orz。 第一次和球队的兄弟们打友谊赛也是在北邮，也是我第一次听说“二三联防”。哇，打篮球竟然还有这么多说法，原来我们之前都是瞎攻瞎防，野球玩家瑟瑟发抖Orz。这次友谊赛就像是给什么也不懂的我开启了新世界的大门，在随后的训练中也了解了许多在野球场上从未有过的战术。 明月杯如期而至，但作为菜鸟的我并未入选球队大名单。值得一提的是，大名单中仅有的两名菜鸟球员分别是擅长突破，转身华丽的明星小前侯彦丞和高中就了解联防的战术专家周月林，加上高年级的明星球员李奕、张博和欧正鑫，信科球队一路高歌猛进，取得小组出线资格进入八强。之后信科在八强碰到了老对手数科，侯彦丞一记绝杀帮助李奕师兄打破了连续三年败给数科的魔咒，同时也宣告了数科时代的结束。 四强比赛前，由于苏禾师兄有事回家，队长与校会沟通后将我放进了比赛名单中。我正是在这场球中收获了明月杯的第一分，一个抢到前场篮板后的二次投篮（听说你们内线很能跳）。地遥很强，尽管我们已经全力以赴，但还是难以抵挡地遥的外线双枪，最终大比分输掉比赛，无缘邱季端。 三四名决赛的对手化学拥有实力强劲的新人王全，还在淘汰赛中战胜了在小组赛中战胜信科的环境，但信科的实力到底还是更胜一筹，经过加时赛的苦战，信科最终取得比赛胜利，拿下季军。 关于14年的图片资料大多没有保存下来。。。惨。 几句废话 客观地说，信科2014级可以称得上是信科的黄金一代。大局观良好+身体强壮的控卫王唯，投篮稳健+弹跳劲爆的射手贾鑫，得分能力出众+突破犀利的锋线大杀器侯彦丞，内线脚步扎实+拼抢积极的强力大前王伟程，虽然技术不大行但是弹跳还可以抢救一下的中锋李喆琛（嗯就是我），这样的阵容足以令每个学院的球队羡慕。加上凶狠敢拼的周月林和球风飘逸的席伟，信科14级正在迎来他们的时代。 大一的事情总是很难忘。唯神在北邮摔伤膝盖，自己与小小俊打球时摔伤，训练时啦啦队送来冒着热气的早饭……这些场景我至今都清晰地记得。还有总被我称作“高手”的干哥，大个子老乡哲哥，还有喜欢扣篮的涛son……谢谢你们的陪伴和支持( '▿ ' )。 0x01. 2015 明月杯流水账 概况 第二年明月杯，仍然是熟悉的赛场，但信科男篮的队伍也在悄悄发生着改变：李奕师兄的毕业使得信科内线少了一个强大的进攻点；而2015级新生的到来使得我们收获了灵活的内线球员唐聪以及技术精湛的外线球员王梓晗。此时我已经转入数学科学学院学习，但由于各种因素的影响，我最终还是选择在信科球队打球。 这是信科创造历史最佳战绩的一年，信科在欧哥和博哥两位大哥的带领下杀入了邱季端，这也是信科首次进入邱季端。 小组赛 小组赛除了惜败给哲社外没有太大的波折。 首场面对心理学院（现为心理学部），对方显然难以应付欧哥和侯彦丞的疯狂进攻，两人最后分别拿下了13分和8分的数据，信科也以29:9胜出。 信科遭遇的第一场失利是小组赛面对拥有mvp陈宏礼的哲社球队。由于中锋郑培凯因身体原因无法，故球队在比赛前一天晚上开了很久的会讨论如何防守陈宏礼（Orz），最后决定由我和侯彦丞采用夹击的战术来应对陈的突破。事实证明我们的策略确实生效了，陈宏礼全场仅得到9分（陈宏礼明月杯目前为止场均得分为19.8）。但我们似乎太过重视陈宏礼，导致对于其他人的防守不够严密，得分机会过多。其中，对方球员付天睿拿下了全场最高分24分，在最后几分钟的关键争夺中更是命中关键投篮，杀死比赛。最终信科以44:48失利，同时也宣告哲社预定小组第一。值得一提的是，张博和欧正鑫分别成为了信科本场的得分王（14分）和篮板王（12板），侯彦丞本场发挥不佳，24次出手仅命中2球，效率也为全队最低的-16（笑尿）。我虽然在本场中拿到了8分10板和全队最高的效率值14，但仍然存在一些问题，集中体现在不适应中锋站位，补防速度慢。赛后分析中，化院的沈芸稼师兄明确指出：“最后一球肯定是中锋的锅”，在观看录像后，也确实能够看出是我补防不及时，导致了最后时刻付天睿的进球，直接导致了比赛的失利。在比赛的最后时刻，前队长张博在一次进攻扭伤了脚踝，比赛激烈可见一斑。尽管失利总是令人失望的事，但这场失利对于我们而言并不是坏消息，甚至是将我们送进邱季端的一大助力。 球队在后续的小组赛中并没有遇到任何阻力，凯哥火力全开拿下全场最高11分，带领球队47:19轻松击败天文，顺利晋级八强。 八强 八强赛面对教育，对方的主力李尧沣面对信科的铁血防守难以延续小组赛的好状态，多次强打我方大前1号（没错就是我哈哈哈）未果，甚至吃到火锅，最终16投仅有3中，教育也只能吞下失利的苦果。而隔壁的八强赛，经管由于自己的轻敌，败给了艺传，将艺传送上了四强席位。至于另一半区，经过八进四的筛选，哲社与地遥在四强相遇。 四强 四强赛中，艺传阵中战胜经管的最大功臣利啓权本场面对信科完全哑火，实力更高一筹的信科以23:11顺利拿下比赛，欧哥更是拿下11分7抢断的数据，统治攻防两端，成功带队进入邱季端。另一边的哲社……就比较惨了，被拥有双枪的朱帕尔（砍下18分7板）和陈星源（砍下13分6助）的地遥成功阻击。信科与地遥会师决赛。 决赛 赛前第一次体会了进邱季端的豪华服务：各种拍宣传照，（弱渣瑟瑟发抖Orz），队员们也对决赛充满信心。 然而，校会宣布比赛日期时所有人都沉默了——比赛日期恰好与ACM EC-Final冲突。尽管与校会方面做了沟通，但日期仍然确定在了这一天，经过一番调整，最终的结果是首发中锋郑培凯无法参赛，同时我也没能去参加EC-Final。 比赛当天，又突发变故。首发大前（我Orz）在下午发烧。以缺少主力的阵容面对卫冕冠军地遥球队，信科球队并没有放弃，并在上半场一直保持领先。但在下半场快节奏的攻防转换中没有顶住对方的反扑，最后时刻的追分又有些慌乱，最终37:41不敌地遥。 本场比赛对我而言意义非凡。第一次在发烧的情况下打比赛，直到上场时仍然手掌冰凉，甚至手指在碰球时会感到轻微的疼痛。这也直接导致了在开场跳球时弹速不够快甚至没有跳过对方的李震（从图上看来高度是足够的，但因弹速不够，所以触球晚……md 生涯耻辱）。 虽然我没有跳赢，但我方后卫积极拼抢，拿到了第一攻的球权。虽然对方外线球员实力强悍，但内线非常羸弱，这使得我们可以通过冲抢前场篮板来获取更多进攻机会。经过侯彦丞、王伟程的一轮刷板-打铁，我抢到了前场篮板，随后投中了本场第一粒进球。说到这里我就不得不吹一波……这粒进球的难度还是很高的，从下图可以看出，我在投篮时上半身是正对篮筐，而仔细看脚和裤腿的遮挡关系就可以发现，下半身的方向其实和上半身是反着的（是不是做一个商空间就可以得到一条mobius band哈哈哈）。 前两节的大部分时间信科都保持了领先，对方的明星球员朱帕尔在高压防守之下表现不佳，屡次出手不中。信科则依靠强大的内线频频冲抢进攻篮板（尽管主力中锋缺席，但在信科弹跳比较好的中锋以及身高较高的外线面前，地遥羸弱的内线仍然难以阻挡）。经过两节的战斗，信科以16：14领先进入下半场。 到了下半场，地遥内线薄弱造成的犯规压力渐渐显露了出来，包括绝对核心陈星源在内的多名主力球员都背上了3次甚至4次的犯规，但由于命中率等各种原因，双方的比分并没有拉开，甚至地遥在陈星源命中三分之后成功以21:18取得了领先，并继续将比分优势扩大到4分。此时信科球员出现了体力问题，于是将替补球员卢浩然换上了场。随后比赛就进入了转折_(:з」∠)_ 也许是连续几波运动战没有得分，比分的差距被拉大，使得信科的球员比较着急：核心欧正鑫的出手有些仓促，卢浩然也在短时间内连续出现3次犯规，于是分差被进一步拉大，达到7分。最终信科以14:31落后进入第四节。（附一张拔萝卜式抢板的照片，可看出地遥羸弱的内线） 进入第四节，由于地遥的主力朱帕尔因犯规过多被教练换下，因而攻防能力有所下降。刚开场侯彦丞就迅速造成犯规并两罚一中，对方中锋李震拿到后场篮板后立刻被我抢断，经过一轮刷板后我命中本场第二球，将比分追至27:31。但良好的追分态势并没有持续太久。仅仅两分钟后，王伟程就在一次抢球中被吹犯规，并因满犯被罚下。信科并没有立刻因为主力的罚下而受到影响：侯彦丞造成李震犯规，使得其五犯下场。随后在地遥发起的一次快攻中，我直接将陈星源的上篮大帽扇飞（下图中的血帽陈星源，看着很刺激）并继续拿下一次抢断，接着信科在欧哥和贾鑫接连得分后，将比分扳至32:33。接下来又是几分钟的拉锯战，期间裁判将我对陈星源的一个盖帽吹为了犯规（我认为是好帽，不过也不能仅因此过多抱怨裁判），欧哥也因所剩时间不多，心态产生了波动，数次运动战都在我还没有落位时就仓促出手打铁，浪费了较多机会。比赛时间所剩无几，信科以37:39落后，此时对方球员陈小强命中了一粒两分球，形式也因此十分危急。在最后时刻的争夺中，可能是由于体力原因，数次出手机会均没有命中，侯彦丞由于抽筋，罚球也未能命中。最终信科以37:41不敌地遥，无缘冠军。 对方球员陈星源全场得到28分，展现了其强大的进攻能力，身背4次犯规仍能一直打到最后时刻也体现了对犯规的良好控制，尤其是令我印象颇为深刻的一次切球，在欧哥上篮时干净利落地将欧哥的球切掉，成功阻挡了信科的反扑，这种冷静确实是我们中的许多人所缺乏的。赛后的聚餐我由于身体原因没有参加，不知道博哥是不是又喝哭了哈哈哈。（附一张赛后合影） 几句废话 谈数科（一） 没有选择加入数科球队的原因是很复杂的，其中比较主要的是两条： 和数科球队的同学，师兄都不太熟悉，但和信科这边的人已经非常熟悉； 在与数科的友谊赛中对于数科12级某师兄非常厌恶。 当然其中也有信科极力挽留并且信科球队实力很强，有机会冲击更好成绩等很多因素。总之这件事情并不是巧合，现在想起来也并没有后悔，只是觉得“道不同，不相与谋”吧。数科球队的团队、氛围、文化，本身就不适合我，我又怎么可能加入数科球队呢？前些日子在与谢老师、魏老师谈话时没有详细地解释这些原因，只谈了最关键的两点，并不是不敢说我对数科球队的看法，也不是不好意思和老师谈，只是觉得没必要。学生的事情停留在学生这里就好，何必惊动老师。我不大聪明，不像一些人懂得“我不好直接和你说，我就请老师给你打电话，找你谈话，还可以把事情推给老师”。同样在数科，我怎么没有学到这些聪明的技巧呢( '▿ ' ) 可能每个人在大学，学到的是不一样的东西( '▿ ' )？ 顺带一提，在决赛前，数科某球员曾经帮助过我们训练。然而两年后的决赛，正是在他的煽动下，数科使出了盘外招将我禁赛。兄弟情谊？不存在的。其人还在双方球队代表谈判时装模作样抹了几把眼泪，之后借故离场，也许出门后就再也忍不住露出得意的微笑？或许这就是“兄弟”（此处特意用了此人最喜欢的波浪线~~） 谈校会 对于我们而言，决赛争议颇大的一点是比赛时间的确定。事实上，不管是由于什么样的原因，信科在校学生会从来没有得到过公正的待遇。 明月杯决赛的比赛时间是很充裕的（可选取范围的很广），信科方面关于比赛时间也与校会做过沟通。这里我不做太阴暗的猜测（比如地遥与校会有某些交易，专门将时间定在这一天？），容易落人口实。但此事体现出的就是：信科在校会处没有话语权。这其中的原因可能有信科学生会的乌烟瘴气（非常乱&amp;非常烂&amp;只代表个人观点），也也可能有信科体育部的原因。但是，校会这方面的问题是一直存在的[ '▿ ' ]。 记得有一场面对某大院的比赛，信科要求改时间，校会方面要求信科与对方沟通（翻译一下：对方是大院得罪不起，你们自己搞定）；另一场比赛，信科对阵某小院，对方要求改时间，对方球队在校会的要求下来找信科球队沟通（翻译一下：你们小院，校会还没有为了你们得罪信科的必要，你们自己搞定）；可还有一场比赛，是某小院对阵某大院，据说并没有经过太多流程，比赛时间就顺利调整了（翻译一下：大院就是可以为所欲为）。这便是校会一贯的办事风格。 回到这次比赛，作为主办方，我个人认为校会有必要保障双方的权益，尽量选在双方都同意的时间。本身比赛就在周末，双方队员也很容易就能错开时间。事实上，对于信科而言，唯一不合适的时间就是12.12那一周，如果把比赛时间提前一周或推后一周，相信对方也不会因此受到很大的影响。然而校会可能不会考虑这么多：是呀，挑一个好时间比赛，多麻烦的事情呀，我们直接拍板就好了。于是信科只好以缺少重要球员的残阵迎战。校会很强，我服了。 0x02. 2016 明月杯流水账 概况 12级的师兄们在这一年毕业了，于是信科缺少了技术扎实的后卫张博以及内线大闸郑培凯。另一方面，欧哥在家乡实习，也不能回学校参赛，于是信科缺少了去年的绝对核心。在实力下降的情况下，信科男篮在信科2014级的带领下小组赛保持全胜，出线后不敌数科止步八强。 稍微详细的版本 小组赛首场面对生科（大家都说其实跳球就暗示了比赛结果） 尽管信科的实力严重下滑，但两队的实力差距还是比较大的。尽管如此，慢热的信科还是在开局阶段一度落后4分，但随着信科球员逐渐找回状态，首发球员频频命中投篮，很快就追平了比分，并以13:5领先进入下半场（附一张罚球图片哈哈）。 下半场刚开始我就有一次失误入账（囧），但对方未能得分。随后我又命中了一粒后仰跳投，进一步拉大了比分，此时比赛悬念已经不大，于是双方球员在球场上都显得放松了一些。最终本场我拿下了全场最高的……7分Orz，这也是我第一次得到全场最高分。信科以28：12顺利拿下首胜。（附赛后双方握手以及信科队伍合影） 第二场小组赛对阵实力一般的政管，本以为能够前三节搞定对手第四节下场休息，但比赛一直到了第四节才分出胜负。于是，很惨，又打满了全场Orz。。赛前还尝试了一次空接扣篮，但是很遗憾扣飞了，我才不告诉你们成功没== 跳球仍然是毫无压力，第一节大家的发挥也比较稳健，虽然进攻端效率一般，但防守很强硬，以7:2结束第一节。 第二节的比赛中，信科延续了第一节的强硬防守，政管一分未得。但在延续强硬防守的同时，进攻也比第一节更铁。。最后我一记三分打铁结束了上半场的战斗，信科以10:2暂时领先进入下半场。（附一张突破图，可以看出对方的防守也很严密，包夹比较到位。但是无奈哥太强他们防不住） 第三节中，信科众将依然手感冰凉，整节只得2分。但政管本节手感回暖，拿下5分，将比分追至12:7后，听着王伟程两罚不中“乒乒乓乓”的打铁声进入了第四节。至此，政管仍有翻盘的希望。感到形势危急的信科球员重新找回了一部分投篮技能包，将比分拉至15:7。最后时刻对方想通过快打三分的战术来做一下最后的挣扎，但传球时遭到我的抢断，并直接完成一条龙快攻，彻底杀死比赛。最终比分定格在17:7，信科取得两连胜。 第三场小组赛对阵教育，本场并没有太大压力，信科以29：15顺利拿下比赛，取得三连胜。至此，信科取得小组出线资格，只差和外文争夺小组第一的位置。（随手附一张抢篮板卡位的照片以及赛后全队的合影） 最后一场小组赛面对的是拥有在前三场场均20+10的新星庄子晨以及技术精湛的后卫卢明江的外文。面对外文的跳球是我这一年第一次跳球失败Orz，但信科仍然神奇地取得了球权。体力充沛的上半场永远是拉开比分的最好时机，加上我本场手感火热，两次出手全部命中（第二次还是单手扔的，防守人压着我的左手，然而本场的裁判就像瞎了一样），比分很快就来到了11:2。尽管比分领先，但信科的后卫们却遭遇了史无前例的防守压迫：先是王伟程的上篮被庄子晨大力扇飞，然后王梓晗的中距离出手又遭遇庄子晨排球大帽，导致后卫们有些畏手畏脚，不敢突破。就在关键时刻，我趁乱接到了球，站在三分线外空位出手命中，将比分拉大到14:3，分差首次来到两位数。又经过一段时间的拉锯战，信科以14:5结束了上半场。第三节中信科仍然保持了9分的领先优势，以21:12进入末节。 第四节中，外文后卫卢明江加强了对内线的冲击，加上对方命中了两记神奇的三分球，外文不断追分，一度将比分追至23:19。但此时比赛已经进入尾声，对方也采取了犯规战术。此时正是考验球员素质的时刻，然而对方球员卢明江却动作越来越大。终于，在一次信科的快攻中，气急败坏的卢用一个非篮球动作对信科球员犯规，被吹技术犯规（场下观众都看不下去了哈哈哈），同时也满犯离场，并在离场时脱下自己的球衣狠狠砸在地面上泄愤，随即遭到了全场的嘘声。此时比赛已经没有了悬念，最终信科以32:24拿下比赛，以小组第一身份出线。王伟程凭借最后时刻罚球刷分，成功超越我（11分），取得全场最高的13分Orz。 淘汰赛面对老冤家数科，开场王梓晗命中2分后，数科球员蔡伯文立刻用一记三分还以颜色，紧接着又顶着防守命中一颗神奇的2分。至此，信科气势已经被全面压倒，赛场也进入了数科的节奏。在追分的过程中，信科的控球者王伟程和侯彦丞显得有些慌乱，也有些着急，最终信科13:21不敌数科，结束了本届明月杯之旅。 几句废话 谈数科（二） 整个数科球队我认识的人中，我最欣赏，也最佩服的人，就是頔哥。此处不谈頔哥练球刻苦，打球干净不搞小动作；也不谈頔哥在明月杯的压力之下仍然考上人大统计研究生。这里只谈和我相关的事情。 在14年败给地遥之后的聚餐中，李奕师兄对（那时）想转系的席伟说“信科转到数科的不少，也有不少打球厉害的转过去了，但他们碰到我们的时候不会上场”。受到这句话的影响，在15年我转入数科，但仍然留在信科打球时，我也说过类似于“如果数科碰到信科，我就不上场”的话。但幸运的是，两队在15年没有碰面，我们也成功创造了历史最佳成绩。但在16年的八进四比赛上，两队碰面了。想起之前的承诺，我当然会说我不上场，信科各位球员的劝说，甚至是欧哥的长篇大论都没有让我动摇。就这样到了比赛前的两天。 让我改变想法的是頔哥。队长王伟程（应该是他，但不敢确定）给我看了与頔哥的聊天记录，依稀记得頔哥说的两句话：“石睿平和我说lzc不打，我就和他说让他打”，还有“兄弟之间，该怼就要怼”。正是頔哥的这番言论让我想清楚，比赛代表的是球队，院系的事情，不应该过多带入到比赛中来。虽然最终在场上也受了一些心态上的影响，但这一年也没有太多遗憾的事情。 然而，真正奇怪的是，石睿平直到赛前都没有来找我“让我打”，数科也没有一个认识我的球员来找我说明这件事情。我很好奇，难道是頔哥撒谎了？更为可悲的是，一年后，这件事情竟被数科的球员摆在了谈判桌上，将頔哥的意见扯到了自己头上。数科15级队长（不点名）表示：“去年也是淘汰赛，按理来说和总决赛同等重要，但我们让lzc上场了。”言下之意便是“去年是给你们面子才让lzc上场的”。我不知道，实在是不知道，他是抱着怎样的心态说出这句话的。另一边，某人一把鼻涕一把泪地说“我和信科有感情，我和欧哥有感情”，，我也很难理解，这到底是怎样一个人，才能如此惺惺作态。 谈信科 这一年的比赛，大多数都有一个共同的特点：上半场砍分，第三节崩盘。这种现象的成因我至今都搞不明白。 如果说是因为信科首发阵容强大，第一节能凭借首发的得分能力将分差拉开，那还算正常。但信科首发偏偏都很慢热。首场面对生科是慢热最好的体现。两队实力差距非常大，但在刚开局时，信科手感冰凉，前几次出手均未命中；反观生科，进入状态迅速，韩嘉伟和于翔宇里突外投，很快就拉开了4分的分差。经历了17年的比赛后，我大致明白了，慢热是由于训练强度不够大的原因。而第三节崩盘最好的体现是与政管的比赛，整场手感冰凉，第三节还险些被追平比分。其原因我至今也没有想通Orz。 信科的另一个严重的问题是缺乏气势。这一点最好的体现就是与数科的比赛。虽然信科命中了第一粒进球，但大哥立刻命中三分给出回应，接着又是一颗非常提士气的两分，信科顿时气势全无。。。气势是球场上很重要的一环，只是那时我们不够关注这件事。欧哥也遗憾地告别了明月杯。 0x03. 2017 明月杯流水账 概况 信科在这一年迎来了强大的17级，包括全能球星李家和，长臂大前谢清宇，和防守强悍的后卫张指导。小组赛势如破竹，连克外文、历史、和哲社，以小组头名身份闯入八强。在淘汰赛中接连战胜地理学部和卫冕冠军经管，三年内第二次进入邱季端。 在决赛前的几天，数科使出了一些见不得光的盘外手段，将我禁赛。缺少内线核心的信科以37：44不敌数科，再次获得亚军。想必看球的各位也懂得，冠军应该是谁[手动微笑]。 邱季端门票 不太客气地讲，这一年的明月杯就是个笑话。 首先从揭幕战数科vs物理谈起。这是一场精彩的比赛，双方的攻防都很不错，然而一些问题严重影响了这场比赛。比赛进行到最后一分钟时，物理领先6分，围观者大多觉得大局已定。这时为了追分，数科使出了自己的看家本领全场紧逼，物理对此显然准备不足，被对方多次成功防守，分差越来越小。然而，由于物理在重压之下仍然命中了一些投篮，数科始终不能扳回比分。很快，比赛时间就所剩无几，物理仍然领先3分。这时数科球员投篮造成物理犯规，哨响后，数科的9号随意地上了一颗空篮，命中。这显然是一颗不计分的球，然而，可能是因为校会的记分员不懂规则（并不敢想象更奇怪的原因），将这一球判为了有效进球。于是在数科两罚全中后，数科成功“反超”，场下观众一脸懵逼。此时比赛时间只剩几秒，物理未能继续得分，数科成功罚球“绝杀”。文字直播地址：http://m.lanqiu.woaoo.net/schedule/59349.html 赛后，物理的同学显然对比赛结果很不服气，于是有同学在蛋蛋网上发帖，引起了非常激烈的讨论。数科石某人在其中摆出的态度再次刷新了我的认知，真是太6了Orz。有没有问题，您自己心里没数么？您有录像也可以自证清白呀，谁不知道数科的比赛每场自己都会录像。墙都不服，就服您。（此处有石某人的精选评论截图[手动微笑]）蛋蛋网微信推送地址：https://mp.weixin.qq.com/s/2RsB6fZ_iB8LiLsejD9TTQ 本以为校会能够认识到自己的错误，将比赛办好。但万万没想到，这只是个开始。 小组赛首场面对老对手外文。外文在17年也迎来了补强：一个又高又壮但技术一般的中锋，这无论对他们的内线防守还是篮板争抢，都是一个明显的提升，所以外界普遍认为这将是一场恶战。 但首节的战斗却出乎了所有人的意料：信科以14:0碾压了外文。这并不是因为外文首发太弱，而是外文的核心后卫卢明江并没有首发出场（原因不明），导致其羸弱的外线被抢断到心态爆炸，这也直接导致了本场外文的失利。（随手附一张李家和突破照片，此时卢明江[7号]已经上场） 在卢明江上场后，外文在卢与庄子晨的配合下展开了反击。但由于外文在第一节挖的坑太大，信科几乎整场都保持了两位数的领先，最终36:25拿下首胜。李家和本场拿下22分5篮板5盖帽的豪华数据，实力carry全队。（附赛后合影） 第二场面对实力较弱的历史，全队12人均有得分进账，谢清宇小同学非常兴奋，拿下全场最高21分，信科以58:12轻松拿下第二场胜利。（附赛后合影） 两战全胜的信科在第三场面对哲社，与哲社争夺小组头名。信科本场又犯了慢热的老毛病，第二节刚开始不久，就落后了6分之多，但在首发球员的努力下，加强了对于对方球星陈宏礼的防守，以10:15进入下半场。（随手贴一张上篮） 进入下半场，信科渐渐找回了状态，陈宏礼渐渐显得独木难支，双方展开了拉锯战，以18：21进入第四节。（再随手贴一张投篮，感谢侯彦丞dalao妙传） 进入第四节，陈宏礼也出现了体力问题，比赛很快就彻底进入了信科的节奏。哲社在最后相当长的一段时间内，都未能得分，最终信科以29:25战胜哲社。（附赛后合影） 值得一提的是，信科在终场前两秒执行两次罚球，全部命中后，哲社落后4分。虽然比赛结果已经尘埃落定，但是抱着拼到最后一刻的心态，陈宏礼在发球后直接在后场出手，不中。此时比赛显然已经可以判定为结束，然而哲社又获得了一次两秒的最后一攻的机会，陈宏礼再次超远三分出手不中，比赛才正式结束。对此感到不满的信科教练任挪走向技术台理论，竟然被体育部部长张浩东言语辱骂。原来校会这个样子，是上梁不正下梁歪啊。 出线后的八强赛中，信科面对的是已经沦为鱼腩球队的老对手地遥。带着14,15败给地遥的旧恨，信科没有给地理任何机会，以41:14干脆利落地拿下比赛。值得一提的是，在最后一节的一次快攻机会中，我过掉了对方的防守球员，然后上空篮不进==囧（全场嘘声Orz），信科众将也被我的这一顿操作惊得目瞪口呆。不过在下一波进攻中，我面对对方的防守投中了一颗干拔三分，嘿嘿嘿，还是这种感觉爽。赛后，当年地遥的小弟-如今地理的大哥：李震同志拒绝与信科握手，宽广的胸襟显露无疑，真是德艺双馨的好典范。（附赛后合影） 四强赛中，面对的是实力仍然强悍的经管。上半场信科占据主动，以14:7领先。下半场经管开始发力，信科的得分势头也开始下降，体力也渐渐出现了问题。第三节马上就要结束时，信科仅有1分入账，领先优势也只剩2分。但在最后一攻中，我接球命中了一粒三分，将分差又拉大到了5分，双方以18:13进入第四节。第四节信科的进攻更加惨不忍睹，正常时间内只有我在篮下的一次打板得手。但经管也没有得到太多机会，没能直接扳平或反超比分，最终信科21:19战胜经管，三年内第二次进入邱季端的舞台。 谈起这次比赛，其实发挥不佳有一个很重要的因素，就是赛前对于对手战术的错误估计。赛前我们研究了经管vs文新的八强比赛录像，发现经管对于文新的闫芳齐采取了一盯四联的防守策略，成功限制了闫芳齐。于是我们推测，经管可能会在比赛中对于李家和采取同样的防守策略。接着，在赛前的训练中，特意设计了两套新的战术来应对一盯四联的防守，名字分别叫“库里”和“五道口”（笑尿）。然而。。经管在比赛中几乎全场都没有使用一盯四联的防守策略，这也一定程度上导致了进攻端的低迷。但最终还是依靠着强硬的防守赢得了比赛的胜利。 再入邱季端 比赛之前当然是拍了一发宣传照。（只贴了自己的照片和合影，有点丑 将就看） 很遗憾没能再次触摸邱季端的地板，事情的始末将在下文详细交待。最终的结果是唐聪替代我出场，缺少主力的信科仍然与对方战斗到最后一刻才分出胜负，最终37:44不敌数科。李家和发挥出色，拿下了28分15板的怪兽级数据，这也是给自己最好的生日礼物。（随手附两张图） 明月杯史上最大笑话 靠改分赢球的队伍，靠禁赛赢球的队伍：冠军，您配吗？ 赛前的过程我也懒得详细再写一遍，直接掏出当时发的说说好了。事情的经过如下： 信科队长在报名前未开具双方签字的证明; 按照规则需要开具该证明，但校会并未审查出; 数科在比赛前四天（划重点 马上就要开赛的时候）对参赛资格提出异议并怂恿老师给我打电话; 校会提出可以补开证明，但数科不同意签字（数科男篮 一支稳健的队伍 此条五毛）。 怎么说呢，球场上的人得到大家的尊重，未必是因为荣誉。想起去年赛前我提出遇到数科可以不打，頔哥直接说“让他打，兄弟该怼就要怼”的事情，如今竟是以“我们去年时候就可以不让你上场”的方式被数科提出。事实上，我毫不怀疑如果当年您们坐在頔哥的位置上，肯定不会让我上场的~（此处又用了某人最爱的波浪线）哈哈，可能有些东西是无法传承的吧。借用师大著名球星的话：“篮球本来是很纯粹的事情，但很可惜不是每个人都这样想。” 同一件事情，君子有君子的解决办法，小人也会有小人的解决办法。既然对面是小人，那我不得不防：谈判全程录音。 谈判时，数科队长表示“很尴尬，我始终是不愿意面对琛哥的”。可我想说的是，你既然已经做出了这个决定，我们也就不可能再是什么“兄弟”了，进而想到石某人虚伪的丑陋嘴脸，我更是没来由的一阵干呕：和欧哥有感情，您配么？关于球赛，类似的事情绝不是没有发生过。但是参与的人不同，结果自然也不同。据陈宏礼回忆，之前BBA的决赛，他所在的队伍与欧哥所在的队伍相遇，因为他的个人原因请求变更比赛时间，而欧哥方面同意了变更的请求。石某人既然与欧哥如此有感情，那么您的奸诈是从哪里学来的？欧哥和您可不是一路人。不过您赢了，一把鼻涕一把泪的表演，着实恶心了我一回。 接下来数科王队长的一番话更加令我无言以对了。也就是我多次提到的“去年我们就可以禁赛你，但我们没有，是因为我们有情谊”。哇，厉害厉害。正如上文所说，我从未想过这件事情能以这种刁钻的角度提出来。不知道頔哥听了这番话会作何感想，当时没有禁赛的事情，请问和您有半毛钱关系么[手动滑稽]？一路躺赢的感觉相比也很爽吧~事实上，我也丝毫不怀疑，如果当年是您处于頔哥的位置，会毫不犹豫地提出禁赛的事情。没啥特别的原因，就是觉得您比较厉害呀。 事实证明了，录音非常有必要。数科男篮的无耻早已超出了我的理解范畴。谈判的最后一点时间，梓晗再也不能忍受对方的无耻，直接发飙。然而数科的石某人，直接将禁赛的原因归结到了梓晗发飙这件事情上。红口白牙，胡说八道？难以想象这到底是怎样一个人。頔哥知道禁赛的事后表示“不知道是谁提出的禁赛，真傻逼”——頔哥不知道吧，你说的就是你的下一任队长呀。对于石某人，我的言论也就到此为止。人在zuo，天在看，祝石某人考研顺利~下半辈子都活在夺冠的美梦里[手动滑稽]。 最后，我想谈谈关于老师的看法。首先需要说明，我并不对魏老师以及谢老师抱有敌意，但落到这件事情上，我个人认为二位有拉偏架的嫌疑。最早是我与魏老师单独谈话时，魏老师已经免不了露出自己的倾向：“考虑最好的结果，数科战胜信科夺冠……”抱歉，我不觉得这是最好的结果。在我们几个还没有进入会议室时，魏老师就已经憋不住得意的笑容了，边笑边说“校会那边已经说了，五点了，他就是不能打”，但还是表示“不过再给你们一个机会，去找他们谈一谈，我作为老师不插手”。然而到了会议室以后，情况却不大相同：老师又扬了扬手机说“虽然我这里已经掌握了可以直接左右战局的信息，不过你们还是先谈一谈”。这句话表面上看着是给你们公平讨论的机会，实则提醒了数科的队员“你们已经是占优势的一方，能坐下来谈已经是给足他们面子了”。这也就注定不是一场“讲道理”的谈判。数科男篮的无耻、数科老师的倾向，加上校会的甩锅和信科团学的软弱，最终结果实际也在意料之中。总而言之，就这件事情而言，我不觉得魏老师、谢老师扮演了一个公平的裁决者。至于魏老师称自己为“护犊子”，这护的大概是“数科”，而不是我。如果这篇文章有幸被老师看到，恕我迟钝，没能在这件事情上体会到您对我的照顾。 数科与信科 谈数科男篮：为保荣誉不择手段的小人团伙 只针对17阵容，无关人员请勿对号入座。 前文提过我和数科球队“道不同，不相与谋”，长期以来，我对数科男篮一直谈不上喜欢——从12级的王晨笛到13级的郭强，再到14级的石睿平，都不是什么我喜欢的人物。但由于院系原因，加上数科也有一些相熟的同学，所以我对数科男篮这个团队还抱始终有一丝希望。甚至在17明月杯后仍觉得，数科男篮有一部分人是光明正大打球的人。 然而现实并不如我所想。这让我不禁想到了前几日数科吉队长对于我“庆幸留在信科男篮”做出的“我们也不是什么人都收”的精彩评论。在我决定是否加入数科球队的时候，好像数科还没你这个人吧不知道您有什么资格说这句话？这么急着说强调一下“我们”么惊讶于队长也会说出如此脑残的言论时，我也懒得多辩驳——因为我忽然想到，吉队长就是这么脑残呀：赛前的一节课后，吉队长对我说“你决赛得分你就死”。对没看错，就是死，可我想说，吉队长决赛场上得分死全家呀哎，结果就是这么巧，吉队长得分了！想到这里我不禁为吉队长大义灭亲的胆识和魄力鼓起了掌。转念一想，吉队长将来可是人民教师呀，我不禁又对祖国未来的教育事业充满了担忧，同时担心亲人的离世给吉队长带来过大的打击于是我便罢了手，没有与吉队长过多纠缠。 再联系到17年的比赛，第一场靠改分赢了物理，数科各位的辩驳不可谓不精彩：“我知道你没有证据，改分赢了也是赢了，你来咬我呀~”数科手里有录像，却不拿来自证清白。校会手里有录像，却不拿来还比赛一个公道。更厉害的是，数科男篮更是摆出了一副不要脸的泼皮姿态，石某人也搬出各种人名来颠倒黑白。那时我竟然还相信数科是清白的，错误只在记分员，真是可笑。后来的比赛中，在意识到信科很有可能碰到数科时，石某人急了。为什么急呢？因为怕呀——软蛋总是缺乏正面面对事情的勇气。于是在哲社vs信科以及经管vs信科的赛后，信科经历了所经历过的最恶毒的诅咒——什么“我在场边一遍遍祈祷……”，什么“一人得道鸡犬升天”，什么“对这个结果感到失望”。然而上天并没有听信小人的胡言乱语，信科也顺利进入了决赛，心有不甘的石某人便精心策划了一手阴谋，最终摘得了这个笑话一般的冠军奖杯。赛后石某人竟然还有脸谈情谊：“我们的情谊是不变的”。这嘴脸与吉队长如出一辙，不愧是两届队长，连脸皮的厚度都如此相似。 数科球队的各种趣事还有很多，如某自称杜兰特的软蛋赛前赛后挑衅等，此处都不再赘述。这些事情也只是说明，如今数科男篮整体的作风，不是个别几人能够形成的。在这个团队里，无耻会像病毒一样传播。很庆幸当年没有加入数科男篮，若没有这件事我恐怕也很难看清这些人的两幅面孔——当面还称兄道弟，转过身就在暗地里处处下绊。这里也不得不佩服吉队长的演技——事出之前还笑脸相迎，甚至求代码求作业，背后毫不犹豫就是一刀。二位队长的脸皮真乃铜墙铁壁，在下佩服~ 最后，用两句话总结一下17的数科男篮，也算是对偶然看到的頔哥观点的回应： 数科男篮够好么？连缺少主力的信科都不能轻松战胜，当然不够好，看过决赛就知道他们根本没有实力夺冠； 数科男篮有光明正大打球的人吗？抱歉我不觉得。 谈信科团学：软弱的学生组织 随手列几条，不过多评论信科内部事务，我也不想与信科团学有任何瓜葛。 体育部部长不强硬，当然这是信科团学的一贯作风； 粉丝票优先给院会，剩余给球队，一定程度上导致了球队票源短缺； 老师也并不努力给学生争取权益，尤其是球队一事。 谈信科男篮：不被幸运眷顾的无冕之王 14-17四年明月杯，信科男篮四次进入八强，三次进入四强，两次问鼎邱季端。虽然两次都铩羽而归，但其实力不容置疑。两次邱季端，都在赛前生出了不同的变故，于是信科两次邱季端之旅都不是完整阵容。造化弄人，不是么？信科的两次邱季端之旅本身都有实力夺冠，但最后都只能感叹一番时运不济。也许光明正大打球，在明月杯这赛场上占不到便宜吧[微笑]。（全文废话完）]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>运动</tag>
        <tag>篮球</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016-2017学年春季学期志愿时长录入]]></title>
    <url>%2F2017%2F11%2F17%2F2016-2017%E5%AD%A6%E5%B9%B4%E6%98%A5%E5%AD%A3%E5%AD%A6%E6%9C%9F%E5%BF%97%E6%84%BF%E6%97%B6%E9%95%BF%E5%BD%95%E5%85%A5%2F</url>
    <content type="text"><![CDATA[一点简单的说明 几句废话 抱歉给大家拖了这么久Orz. 之前也和认证部长沟通过几次, 认证可能确实因为人手不够等问题, 没有及时给各位录入时长. 认证由于人手不够, 只能给大家提供时长码, 大家自己在志愿北京录入时长码获取时长. 时长码使用说明 登录志愿北京; 在志愿北京-我的首页中, 点击自己的服务时间, 进入&quot;我的时长&quot;页面; 在新页面中点击“录入时长码”, 即可录入时长码. 时长码查询 function search() { var list = new Array("李萍", "谢万明昱", "王石安", "蒋雨含", "王雪琪", "杨东芳", "张巧凌", "陈心如", "冯晓科", "贺苑林", "宋研霏", "朱燕琪", "周敬天", "李奕璇", "边珍", "但晴", "贺巧", "李晓霞", "郑逸敏", "付月", "王子璇", "白月", "段婷波", "高珊", "何可人", "李金铭", "苏宁", "王松正", "文艺", "许琳旋", "周佳茜", "张恺琦", "李军逸", "孙漾", "王蔚桐", "杨航", "余跃", "曹梦宇", "查少琛", "陈林涛", "刘子辰", "马玉阁", "王伟初", "孙荣", "周泓宇") var time = new Array(48, 48, 44, 42, 42, 42, 42, 32, 32, 42, 36, 36, 36, 34, 30, 30, 30, 30, 30, 30, 26, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 20, 18, 18, 18, 18, 18, 12, 12, 12, 12, 12, 10, 9, 3) var code = new Array(104198280126, 104197959124, 104198444710, 104191633494, 104193443180, 104199997937, 104196008038, 104190659437, 104192963919, 104196143683, 104193955548, 104191780154, 104191422029, 104199202510, 104194994021, 104193868440, 104198971022, 104197237983, 104194009799, 104197768688, 104191560051, 104193005169, 104197725850, 104191360385, 104193523894, 104198523787, 104198383642, 104198262211, 104199021643, 104191333531, 104199998372, 104197447426, 104194687884, 104199153947, 104190342124, 104195364603, 104195467540, 104195030302, 104196284847, 104194794933, 104194622149, 104198082739, 104195705550, 104191401247, 104195020771) var name = document.getElementById("input").value var res = "查无此人！" var ans = "没有查询到您的时长码QAQ" for (id in list){ console.log(list[id], name) if(list[id] == name) { res = list[id]+", 您的志愿时长为"+time[id]+"小时, 您的时长码已显示" ans = code[id] } } document.getElementById("output").value = ans alert(res) } 请在输入框中输入您的姓名, 点击“查询”即可. 姓名: 时长码:]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>白鸽</tag>
        <tag>志愿</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛函——有界集、完全有界集和紧集]]></title>
    <url>%2F2017%2F10%2F25%2F%E6%B3%9B%E5%87%BD%E2%80%94%E2%80%94%E6%9C%89%E7%95%8C%E9%9B%86%E3%80%81%E5%AE%8C%E5%85%A8%E6%9C%89%E7%95%8C%E9%9B%86%E5%92%8C%E7%B4%A7%E9%9B%86%2F</url>
    <content type="text"><![CDATA[基础定义 有界集: 设 \((\mathscr{X},\rho)\) 为度量空间, \(A\subset\mathscr{X}\)，如果 \(\exists M&lt;\infty\), s.t. \(\forall x,y\in A\), 总有 \(\rho(x,y)\leqslant M\), 则称 \(A\) 为有界集. 完全有界: 集合 \(M\) 称为完全有界的, 如果 \(\forall\epsilon\), 存在 \(M\) 的一个有穷 \(\epsilon\) 网. 紧集: 在拓扑空间 \(\mathscr{X}\) 中, 集合 \(M\) 称为紧集, 如果 \(\mathscr{X}\) 中每个覆盖 \(M\) 的开集族中都有有限个开集覆盖 \(M\). 有界与完全有界 有界集与完全有界集本质上只差维数. 命题 1 在度量空间 \((\mathscr{X},\rho)\) 中, 完全有界集的子集也是完全有界的. 证明: 设 \(M\) 为 \(\mathscr{X}\) 中的完全有界集, \(S\subset M\), 下证 \(S\) 完全有界: \(\forall\epsilon&gt;0\), 由 \(M\) 的完全有界性可知, \(\exists N_0\in\mathbb{N}\) 及 \(\{x_n\}_{n=1}^{N_0}\subset M\), s.t. \(S\subset M\subset\bigcup\limits_{N=1}^{N_0}B(x_n,\frac{\epsilon}{2})\). 令 \(I_s=\{i:B(x_i,\frac{\epsilon}{2})\cap S\neq\varnothing\}\), 显然 \(I_s\) 为有限集. 进一步, 对 \(\forall i\in I_s\), 取 \(y_i\in S\cap B(x_i,\frac{\epsilon}{2})\), 易有 \(B(x_i,\frac{\epsilon}{2})\subset B(y_i,\epsilon)\). 由此及 \(I_s\) 的定义可知 \(S\subset\bigcup\limits_{i\in I_s}B(x_i,\frac{\epsilon}{2})\subset\bigcup\limits_{i\in I_s}B(y_i,\epsilon)\), 即 \(S\) 完全有界. 命题 2 在有限维 \(B^*\) 空间中, 有界集 \(\Leftrightarrow\) 完全有界集. 证明: &quot;\(\Leftarrow\)&quot; 是显然的, 以下证明 &quot;\(\Rightarrow\)&quot;. 由于 \(\mathscr{X}\) 为有限维空间, \(M\) 有界, 以及 课本P37, Col1.4.30 可知 \(M\) 列紧. 再由 Th1.3.7 知 \(M\) 完全有界. 综上, 有界 \(\Leftrightarrow\) 完全有界. 紧集与完全有界闭集 紧集与完全有界闭集只差完备性. 命题 3 在 \(B^*\) 空间中, 紧集一定是完全有界闭集, 反之不一定成立. 证明: 由Th1.3.11, 在 \(B^*\) 空间中, \(A\) 为紧集当且仅当 \(A\) 是自列紧集. 从而 \(A\) 是闭的, 再由 Th1.3.7 知 \(A\) 完全有界. 即: 紧 \(\Rightarrow\) 完全有界 \(+\) 闭 在 \(B^*\) 空间中成立. 但反之不成立, 反例如下: \[x_n(t)=\begin{cases} 1, &amp;t\in [a,\frac{a+b}{2}-\frac{1}{n});\\ n(\frac{a+b}{2}-x), &amp;t\in [\frac{a+b}{2}-\frac{1}{n},\frac{a+b}{2}+\frac{1}{n});\\ -1, &amp;t\in [\frac{a+b}{2}+\frac{1}{n},b]. \end{cases}\] \[x_n(t)=\begin{cases} 1, &amp;t\in [a,\frac{a+b}{2});\\ 0, &amp;t=\frac{a+b}{2};\\ -1, &amp;t\in (\frac{a+b}{2},b]. \end{cases}\] 记 \(\mathscr{X}=(C[a,b],\Vert\cdot\Vert_{L^1})\), 并记 \(\{x_n\}_{n\in\mathbb{N}}\subset C[a,b]\), 如下构造: 易证 \(\{x_n\}_{n\in\mathbb{N}}\) 依 \(\Vert\cdot\Vert_{L^1}\) 有极限 \(x\), 且 \(x\notin C[a,b]\). 考虑到 \(x\in L^1[a,b]\), 故 \(\{x_n\}_{n\in\mathbb{N}}\) 为 \(L^1[a,b]\) 中的列紧集, 从而由 Th1.3.7, \(\{x_n\}_{n\in\mathbb{N}}\) 为 \(L^1[a,b]\) 中的完全有界集. 故 \(\forall\epsilon&gt;0\), \(\exists N\in\mathbb{N}\) 以及 \(\{f_k\}_{k=1}^N\subset L^1[a,b]\), s.t. \(\{x_n\}_{n\in\mathbb{N}}\subset\bigcup\limits_{k=1}^NB(f_k,\frac{\epsilon}{2})\). 不妨设 \(B(f_k,\frac{\epsilon}{2})\cap\{x_n\}_{n\in\mathbb{N}}\neq\varnothing\)(否则去掉 \(B(f_k,\frac{\epsilon}{2})\) 即可). 对 \(\forall k\in\{1,2,\cdots,N\}\), 取 \(g_k\in\{x_n\}_{n\in\mathbb{N}}\cap B(f_k,\frac{\epsilon}{2})\), 则 \(\{x_n\}_{n\in\mathbb{N}}\subset\bigcup\limits_{k=1}^NB(f_k,\frac{\epsilon}{2})\subset\bigcup\limits_{k=1}^NB(g_k,\epsilon)\). 从而 \(\{g_k\}_{k=1}^N\) 为 \(\{x_n\}_{n\in\mathbb{N}}\) 的有穷 \(\epsilon\) 网. 故 \(\{x_n\}_{n\in\mathbb{N}}\) 为 \(\mathscr{X}\) 的完全有界集. 又由于 \(\{x_n\}_{n\in\mathbb{N}}\) 在 \(\mathscr{X}\) 中闭, 故 \(\{x_n\}_{n\in\mathbb{N}}\) 为 \(\mathscr{X}\) 中的完全有界集, 但不紧. 但在完备空间: Banach空间中有更强的结论. 命题 3 在Banach空间中, 紧集 \(\Leftrightarrow\) 完全有界集. 证明: 上文中已证紧集 \(\Rightarrow\) 完全有界闭集. 又由 \(B\) 空间中, 完全有界集必定列紧. 从而完全有界集必定是自列紧的. 从而由 Th1.3.11 可知该集合必定是紧集. 综上, Banach空间中的集合是紧集, 当且仅当它是完全有界闭集.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>泛函分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北京师范大学概率测度小测题目]]></title>
    <url>%2F2017%2F10%2F19%2FBNU-Measure-and-Probability-Exam%2F</url>
    <content type="text"><![CDATA[概率测度第一次小测 2017.10.19 概率测度第二次小测 2017.11.30 概率测度第一次小测 2017.10.19 判断题 正确须证明, 错误须举反例, 没有理由不得分. \(f:\Omega\rightarrow E\), \(\forall~B\subset E\), \(f^{-1}(B^c)=(f^{-1}(B))^c\); 设 \((\Omega,\mathcal{F},\mu)\) 为测度空间, 取 \(\{A_n\}_{n\in\mathbb{N}}\downarrow\subset\mathcal{F}\). s.t. \(A_n\to\varnothing\), 有 \(\lim\limits_{n\to\infty}\mu(A_n)=0\); 设 \((\Omega,\mathcal{F},\mu)\) 为测度空间, 取 \(A\in\mathcal{F}\), s.t. \(\mu(A)=0\), 取 \(B\subset A\), 则有 \(\mu(B)=0\); 若 \(\Omega\) 的子集类 \(\mathcal{C}\) 既是 \(\lambda\) 系又是 \(\pi\) 系, 则 \(\mathcal{C}\) 为 \(\sigma\) 代数. 证明题 叙述测度扩张定理, 并证明其中的唯一性部分. 简略解答 同样...有差错不负任何责任. 判断题 正确. 直接验证即可; 错误. 取 \(\mathbb{R}\) 上的Lebesgue测度, \(A_n=(n,+\infty)\), 即有 \(\bigcap\limits_{n=1}^\infty A_n=\varnothing\), 但 \(\mu(A_n)=\infty\), \(\forall n\in\mathbb{N}\), 矛盾; 错误. 取 \(\Omega=\{0,1,2\}\) 上的 \(\sigma\) 代数 \(\mathcal{F}=\{\varnothing,\{0,1\},\{2\},\Omega\}\), 取集函数 \(\mu(\{\varnothing\})=\mu(\{0,1\})=0\), \(\mu(\{2\})=\mu(\Omega)=1\), 容易验证 \(\mu\) 是一个测度. 取 \(B=\{0\}\subset A=\{0,1\}\), 则 \(B\notin\mathcal{F}\), 矛盾; 正确. 直接验证即可(由 \(\lambda\) 系可直接得到 \(\Omega\) 和余运算封闭, 证明对有限并运算封闭时继续构造部分和即可). 证明题 见课本... 图片版 发卷子了==其实回忆基本没错. 概率测度第二次小测 2017.11.30 判断题 正确须证明, 错误须举反例, 没有理由不得分. 给定概率空间 \((\Omega, \mathcal{F}, P)\), 如果对于 \(\forall A\in\mathcal{F}\), 有 \(P(A)=0 或 1\), 则: \(\mathcal{F}=\{\Omega,\varnothing\}\); 对于任意随机变量 \(X\in\mathcal{F}\), 有 \(X=C\), P-a.s.. 给定测度空间 \((\Omega, \mathcal{F}, \mu)\), \(f\in\mathcal{F}\). 若 \(\mu\) 是 \(\sigma\)-有限的, 则 \(\mu_f\) 也是 \(\sigma\)-有限的. 计算&amp;证明 设 \(X_1\), \(X_2\) 是独立随机变量, \(X_1\sim U[0,1]\), \(X_2\sim B(n,p)\). 试证 \(Y=X_1+X_2\) 是连续型随机变量并求其密度函数. 给定测度空间 \((\Omega, \mathcal{F}, \mu)\), \(f_n\in\mathcal{F}\) 可积, \(\sup\limits_n \int f_n{\rm d}\mu&lt;\infty\), 且 \(f_n\uparrow f\). 试证: \(f\) 可积, 且 \(\int f_n{\rm d}\mu\to\int f{\rm d}\mu\). 简略解答 判断题 两小问: 错误. 取 \(A\subset\Omega\), \(\mathcal{F}=\{\varnothing, A, A^c, \Omega\}\), \(\mu( \varnothing)=\mu(A^c)=0\), \(\mu(A)=\mu(\Omega)=1\), 容易验证是一个反例. 正确. 注意正测度集存在性的证明. 错误. 考虑 \(\mathbb{R}\) 上的Lebesgue测度, \(f:\mathbb{R}\to\{1\}\), \(x\mapsto 1\). 则 \(\mu_f\) 不是 \(\sigma\)-有限. 计算&amp;证明 课后习题. \(f_1\) 可积, \(f_1\leqslant f_n\uparrow f\), 由单调收敛定理可得结论.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>数学</tag>
        <tag>各种试卷</tag>
        <tag>概率论</tag>
        <tag>测度论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[次序统计量的联合分布]]></title>
    <url>%2F2017%2F10%2F09%2F%E6%AC%A1%E5%BA%8F%E7%BB%9F%E8%AE%A1%E9%87%8F%E7%9A%84%E8%81%94%E5%90%88%E5%88%86%E5%B8%83%2F</url>
    <content type="text"><![CDATA[设 \(X_1,\cdots,X_n\) 为来自总体 \(X\sim F\) 的iid样本, 总体概率密度函数为 \(f(x)\), 则对于给定的 \(1\leqslant i\leqslant j\leqslant n\), 求统计量 \(X_{(i)}\) 与 \(X_{(j)}\) 的联合密度. 首先注意到, \(X_{(1)},\cdots,X_{(n)}\) 的联合密度为 \[f_{(X_{(1)},\cdots,X_{(n)})}(x_1,\cdots,x_n)=n!\cdot f(x_1)\cdots f(x_n).\] 于是只需要求 \((X_{(i)}, X_{(j)})\) 的边缘密度. 利用结果 \[\idotsint\limits_{a&lt;x_1&lt;\cdots&lt;x_k&lt;b}f(x_1)\cdots f(x_k){\rm d}x_1\cdots {\rm d}x_k=\frac{1}{k!}(F(b)-F(a))^k\] 可得 \[ \begin{align} f_{(X_{(i)}, X_{(j)})}(x,y) &amp;= \idotsint\limits_{x_k\in\mathbb{R},k\neq i,j}n!\cdot f(x_1)\cdots f(x_n){\rm d}x_1\cdots{\rm d}x_{i-1}{\rm d}x_{i+1}\cdots{\rm d}x_{j-1}{\rm d}x_{j+1}{\rm d}x_n \\ &amp;= n!\times\idotsint\limits_{0&lt;x_1\cdots&lt;x_{i-1}&lt;x}f(x_1)\cdots f(x_{i-1}){\rm d}x_1\cdots{\rm d}x_{i-1}\times \idotsint\limits_{x&lt;x_{i+1}&lt;\cdots&lt;x_{j-1}&lt;y}f(x_{i+1})\cdots f(x_{j-1}){\rm d}x_{i+1}\cdots{\rm d}x_{j-1}\times \idotsint\limits_{y&lt;x_{j+1}&lt;\cdots&lt;x_n&lt;+\infty}f(x_{j+1})\cdots f(x_n){\rm d}x_{j+1}{\rm d}x_n\times f(x)f(y) \\ &amp;= n!\times \frac{F^{j-1}(x)}{(j-1)!}\times\frac{[F(y)-F(x)]^{k-j-1}}{(k-j-1)!}\times\frac{[1-F(y)]^{n-k}}{(n-k)!}\times f(x)f(y) \\ &amp;= \frac{n!}{(j-1)!(k-j-1)!(n-k)!}F^{j-1}(x)[F(y)-F(x)]^{k-j-1}[1-F(y)]^{n-k}f(x)f(y) \end{align} \] 同样可以求出任意多个次序统计量的联合密度.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>概率论</tag>
        <tag>统计学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛函——自然数集上的Lp范数]]></title>
    <url>%2F2017%2F10%2F08%2F%E6%B3%9B%E5%87%BD%E2%80%94%E2%80%94%E8%87%AA%E7%84%B6%E6%95%B0%E9%9B%86%E4%B8%8A%E7%9A%84Lp%E8%8C%83%E6%95%B0%2F</url>
    <content type="text"><![CDATA[\(L^p(\Omega,\mu)\) 空间 \(1\leqslant p&lt;\infty\), 设 \((\Omega,\mathscr{B},\mu)\) 是一个测度空间, \(u\) 是 \(\Omega\) 上的可测函数且 \(|u(x)^p|\) 在 \(\Omega\) 可积. 则记这样 \(u\) 的全体为 \(L^p(\Omega,\mu)\). 在 \(L^p(\Omega,\mu)\) 中几乎处处相等的函数视为同一个函数后, \(L^p(\Omega,\mu)\) 仍为线性空间. 定义 \[\Vert u\Vert=\left(\int\nolimits_\Omega \vert u(x)^p\vert {\rm d}\mu\right)^\frac{1}{p}\] 则 \(\Vert\cdot\Vert\) 为一个范数. 事实上 \(L^p(\Omega,\mu)\) 还是一个Banach空间. \(\mathbb{N}\) 上的 \(L^p\) 范数 以上的空间在 \(\mathbb{N}\) 上的特殊情形如下: \(\Omega=\mathbb{N}, \mu(\{n\})=1~(\forall n\in\mathbb{N})\), 此时 \(L^p(\Omega,\mu)\) 由满足 \(\sum\limits_{n=1}^\infty\vert u_n\vert^p&lt;\infty\) 的所有序列组成, 记为 \(l^p\). 此时其范数为 \[\Vert u\Vert=\left(\sum\limits_{n=1}^\infty \vert u_n\vert^p\right)^\frac{1}{p}.\] 对于 \(\forall N\in\mathbb{N}\), 记 \(f_N(x)=\sum\limits_{n=1}^Nu_n\chi_{\{n\}}\), 令 \(f(x)=\sum\limits_{n=1}^\infty u_n\chi_{\{n\}}\), \(x\in\mathbb{N}\). 则有 \[ \begin{align} \int\nolimits_\mathbb{N}\vert f_N(x)\vert^p{\rm d}\mu(x) &amp;= \int\nolimits_\mathbb{N}\sum\limits_{n=1}^Nu_n\chi_{\{n\}}{\rm d}\mu(x) \\ &amp;= \sum\limits_{n=1}^N \vert u_n\vert^p\cdot\int\nolimits_\mathbb{N}\chi_{\{n\}}{\rm d}\mu(x) \\ &amp;= \sum\limits_{n=1}^N \vert u_n\vert^p \end{align} \] 又显然, \(0\leqslant\vert f_N(x)\vert^p\leqslant \vert f_{N+1}(x)\vert^p\), 且 \(\vert f(x)\vert^p=\lim\limits_{N\to\infty}\vert f_N(x)\vert^p\). 故由非负可测函数的Levi定理有 \[ \begin{align} \int\nolimits_\mathbb{N}\vert f(x)\vert^p{\rm d}\mu(x) &amp;= \int\nolimits_\mathbb{N}\lim\limits_{N\to\infty}\vert f_N(x)\vert^p{\rm d}\mu(x) \\ &amp;= \lim\limits_{N\to\infty}\int\nolimits_\mathbb{N}\vert f_N(x)\vert^p{\rm d}\mu(x) \\ &amp;= \sum\limits_{n=1}^\infty \vert u_n\vert^p \end{align} \] 即有 \[ \left(\sum\limits_{N=1}^\infty\vert u_n\vert^p\right)^\frac{1}{p}=\left(\int\nolimits_\mathbb{N}\vert f(x)\vert^p{\rm d}\mu(x)\right)^\frac{1}{p}. \]]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>泛函分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拓扑学题目]]></title>
    <url>%2F2017%2F10%2F08%2F%E6%8B%93%E6%89%91%E5%AD%A6%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[乘积空间 Hausdorff空间与对角映射 映射 \[\Delta: X\rightarrow X\times X,~\Delta(x)=(x,x)\] 称为对角映射. 证明: \(X\) 是Hausdorff空间当且仅当 \(\Delta(X)\) 是 \(X\times X\) 的闭集. 证明: 充分性: \(\forall x\neq y\in X\), 有 \((x,y)\in \Delta^c\). 由 \(\Delta\) 为闭集有 \(\Delta^c\) 为开集. 故由乘积拓扑的定义, 存在 \(X\) 的开子集 \(U,V\), s.t. \((x,y)\in U\times V\subset\Delta^c\). (\(X\) 上的开集\(\times\)\(X\)上的开集为 \(X\times X\) 乘积拓扑的一组拓扑基). 于是此时, \(U,V\) 是 \(x,y\) 的开邻域并且易得 \(U\cap V=\varnothing\). 必要性: 由于 \(X\) 是Hausdorff空间, 故 \(\forall x\neq y\in X\), 存在 \(X\) 的开子集 \(U,V\), s.t. \(x\in U\), \(y\in V\), 且 \(U\cap V=\varnothing\). 故 \((x,y)\in U\times V\), 又由 \(U\cap V=\varnothing\), 知 \((U\times V)\cap\Delta=\varnothing\), 即 \(U\times V\subset\Delta^c\), 故 \(U\times V\) 为 \((x,y)\) 在 \(\Delta^c\) 中的开邻域. 故 \(\Delta^c\) 为开集, 即 \(\Delta\) 为闭集. 综上所述, \(X\) 是Hausdorff空间 \(\Longleftrightarrow\) \(\Delta(X)\) 是 \(X\times X\) 的闭集. 自然投影不一定是闭映射 举例说明 \(p_1:X\times Y\to Y\) 不一定是闭映射. 证明: 取 \(\mathbb{E}^2\) 中的闭集 \(F=\{(x,\frac{1}{x}):x&gt;0\in\mathbb{R}\}\), 则 \(p_1(F)=\mathbb{R}^+\) 为开集. 连通性 \(\mathbb{E}^2\) 上的非无理点集连通 设 \(X=\{(r,s)\in\mathbb{E}^2\vert r\in\mathbb{Q}~或~s\in\mathbb{Q}\}\), 证明 \(X\) 连通. 有各种神奇的想法. 证明1: 通过道路连通性考虑. 取 \(x_1=(r_1,s_1),x_2=(r_2,s_2)\in X\), 有以下两种情况. 若 \(r_1,r_2\in\mathbb{Q}\), 则存在 \(x_1\to x_2\) 的道路 \((r_1,s_1)\to(r_1,r_2)\to(r_2,r_2)\to(r_2,s_2)\); 若 \(r_1,s_2\in\mathbb{Q}\), 则存在 \(x_1\to x_2\) 的道路 \((r_1,s_1)\to(r_1,s_2)\to(r_2,s_2)\). 综上所述, \(X\) 是道路连通的, 因此 \(X\) 连通. 证明2: 反证法. 假设 \(X\) 可以写成两个不相交非空开集 \(A,B\) 的并. 取 \(q\in\mathbb{Q}\), 则 \(X_q=\{(x,q),(q,x)\vert x\in\mathbb{R}\}\) 构成 \(X\) 的连通子集. 显然有 \(X_q\subset A\) 或者 \(X_q\subset B\), 否则 \(X_q\) 可分成不相交的两部分 \(X_{q_A}\) 和 \(X_{q_B}\), s.t. \(\overline{X_{q_A}}\cap X_{q_B}=\overline{X_{q_B}}\cap X_{q_A}=\varnothing\), 这与 \(X\) 的连通性矛盾. 于是 \(\exists q_1,q_2\in\mathbb{Q}\), s.t. \(X_{q_1}\subset A\), \(X_{q_2}\subset B\). 但 \((q_1,q_2)\in X_{q_1}\cap X_{q_2}\), 与 \(A\cap B=\varnothing\) 矛盾. 故 \(X\) 连通. 考虑一个引理: 引理 若 \(X_0\) 是 \(X\) 的既开又闭子集, \(A\) 是 \(X\) 的连通子集, 则 \(A\cap X_0=\varnothing\) 或 \(A\subset X_0\). 引理的证明: \(A\cap X_0\) 是 \(A\) 的既开又闭子集. 由于 \(A\) 连通, 故 \(A\cap X_0=\varnothing\) 或 \(A\cap X_0=A\), 即 \(A\subset X_0\). 由引理可得出以下命题（北大拓扑学讲义P63 Prop 2.23）进而可证原命题. 命题 2.23 如果 \(X\) 有一个连通覆盖 \(\mathscr{U}\), 并且 \(X\) 有一连通子集 \(A\), 它与 \(\mathscr{U}\) 中每个成员都相交, 则 \(X\) 连通. 命题的证明: 设 \(X_0\) 是 \(X\) 的既开又闭子集, 只需证明 \(X_0=\varnothing\) 或 \(X_0=X\). 由引理, \(A\cap X_0=\varnothing\) 或 \(A\subset X_0\). 若 \(A\cap X_0=\varnothing\), 则 \(\forall U\in\mathscr{U}\), 由于 \(U\cap A\neq\varnothing\), 故 \(U\nsubseteq X_0\). 由引理, \(U\cap X_0=\varnothing\), 则 \(X_0=(\bigcup\limits_{U\in\mathscr{U}}U)\cap X_0=\bigcup\limits_{U\in\mathscr{U}}(U\cap X_0)=\varnothing\). 若 \(A\subset X_0\), 则 \(\forall U\in\mathscr{U}\), \(U\cap X_0\supset U\cap A\neq\varnothing\). 由引理, \(U\subset X_0\), 则 \(X=\bigcup\limits_{U\in\mathscr{U}}U\subset X_0\), 即有 \(X_0=X\). 综上所述, \(X\) 连通. 证明3: 仍然考虑 \(A_q=\{(x,y)\vert x=q~或~y=q\}\), 则 \(A_q\) 连通且 \(X=\bigcup\limits_{q\in\mathbb{Q}}A_q\), 即 \(\{A_q\}_{q\in\mathbb{Q}}\) 构成 \(X\) 的连通覆盖, 而 \(A_q\cap A_0\neq\varnothing, \forall q\in\mathbb{Q}\), 故由命题2.23, \(X\) 连通. 结合引理, 证法2也会有不同的写法, 不再赘述. \(\mathbb{R}^1\) 上左开右闭区间生成的拓扑不是 \(C_2\) 空间 设 \(\mathbb{R}^1\) 的子集族 \(\mathcal{B}=\{(a,b]:a,b\in\mathbb{R}^1,a&lt;b\}\), 则 \(\mathcal{B}\) 构成 \(\mathbb{R}^1\) 上的一个拓扑基且该拓扑不是第二可数空间. 证明: \(\mathcal{B}\) 构成拓扑基的证明是平凡的, 不再赘述. 以下证明该空间不是第二可数的. 反证法. 设有可数拓扑基 \(\{\alpha_i\}\), 设 \(a_i=\sup\limits_{x\in\alpha_i}x\) (\(a_i\) 可取 \(\infty\)), 则 \(a_i\) 只有可数个, 于是 \(\exists\) 无理数 \(\beta\notin\{a_i\}_{i\in\mathbb{N}}\). 由条件, 可设 \((\beta^{-1},\beta]=\bigcup\limits_{j} \alpha_j\). 于是 \(\beta=\sup\limits_{x\in\bigcup_j\alpha_j}x=\max\limits_j a_j\), 与 \(\beta\notin\{a_i\}_{i\in\mathbb{N}}\) 矛盾. 于是不存在可数拓扑基, 因而不是 \(C_2\) 空间. \(\mathbb{Q}\) 作为 \(\mathbb{E}^1\) 的子空间不是局部紧的 证明有理数作为 \(\mathbb{E}^1\) 不是局部紧致的. 证明: 取 \(q\in \mathbb{Q}\), 只需要证明 \(q\) 的任意邻域都不紧即可. 任取 \(\mathbb{Q}\) 中包含 \(q\) 的一个邻域, 则该邻域具有 \(U_q\cap\mathbb{Q}\) 的形式, 其中 \(U_q\) 是 \(q\) 在 \(\mathbb{R}\) 中的邻域. 故 \(U_q\) 包含 \(q\) 的连通分支必定具有区间 \(|a,b|\) 的形式（开区间或闭区间）. 取无理数 \(\xi\in|a,b|\), 记 \(|a,b|\) 中比 \(\xi\) 小的有理数为 \(\{a_1,a_2\cdots\}\), 比 \(\xi\) 大的有理数为 \(\{b_1,b_2,\cdots\}\), 则 \(\{\mathbb{Q}\cap|a,a_i)\}_{i\in\mathbb{N}}\cup\{\mathbb{Q}\cap(b_j,b|\}_{j\in\mathbb{N}}\) 构成 \(|a,b|\) 的一个开覆盖, 且没有有限子覆盖. 于是 \(|a,b|\) 不紧. 命题得证. 师大《拓扑学》P47 8. 设拓扑空间 \(X\) 可以写成两个开集 \(X_1\), \(X_2\) 的并, 并且 \(X_0=X_1\cap X_2\neq\varnothing\) 道路连通, 证明 \(X\) 道路连通当且仅当 \(X_1\) 和 \(X_2\) 都道路连通. 证明: 只需要证明 \(X_1\) 道路连通. 由于 \(X_1\cap X_2\) 道路连通, 以下只需证明 \(\forall p\in X_1\backslash X_2\), 存在 \(p\) 到 \(X_1\cap X_2\) 中某点的道路. 取 \(q\in X_2\), 则由 \(X\) 道路连通, 任取 \(q\in X_2\), \(X\) 中存在 \(p\to q\) 的一条道路 \(a\), 即 \(a:X\to I\), s.t. \(a(0)=p\), \(a(1)=q\). 则 \(a^{-1}(X_1\cap X_2)\neq\varnothing\), 否则由 \(a\) 的连续性, \(a^{-1}(X_1)\) 和 \(a^{-1}(X_2)\) 为 \(I\) 的两个非空开集且 \(a^{-1}(X_1)\cup a^{-1}(X_2)=I\), 从而与 \(I\) 的连通性矛盾. 取 \(t=\inf a^{-1}(X_1)\cap a^{-1}(X_2)\), 则 \([0,t]\subset a^{-1}(X_1)\). 由 \(a^{-1}(X_1)\) 是开集知 \(\exists\epsilon&gt;0\), s.t. \([t,t+\epsilon)\subset a^{-1}(X_1)\). 于是 \(\exists t_1\in[t,t+\epsilon)\), s.t. \(a(t_1)\in X_1\cap X_2\). 即存在 \(p\to t_1\) 的道路, 因而 \(X_1\) 道路连通. 粘合拓扑与并集的子空间拓扑 若 \(X_\alpha\) 是 \(Z\) 的子空间, 给 \(\bigcup\limits_\alpha X_\alpha\) 以 \(Z\) 的子空间拓扑. 若 \(\alpha\) 个数有限, 并且每个 \(X_\alpha\) 在 \(\bigcup\limits_\alpha X_\alpha\) 中闭, 则 \(\bigcup\limits_\alpha X_\alpha\) 的子空间拓扑与粘合拓扑一致. 若 \(\alpha\) 个数无限, 则结论不一定成立. 证明1: 平凡的构造是很容易的: 考虑 \(Z=\mathbb{E}^1\), \(X_\alpha=\{\alpha\}\), \(\forall\alpha\in\mathbb{R}\), 则 \(Z=\bigcup\limits_\alpha X_\alpha\). 并集的子空间拓扑显然就是欧氏拓扑, 但粘合拓扑为 \(\mathbb{R}\) 上的离散拓扑, 因而不相同. 证明2: 非平凡的例子: 待补.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>拓扑学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单调类定理]]></title>
    <url>%2F2017%2F09%2F21%2F%E5%8D%95%E8%B0%83%E7%B1%BB%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[基础定义 \(\sigma\) 代数 称 \(\Omega\) 的子集类 \(\mathscr{F}\) 为 \(\Omega\) 的 \(\sigma\) 代数, 如果它满足: \(\Omega\in\mathcal{F}\); 若 \(A\in\mathcal{F}\), 则 \(A^c\in\mathcal{F}\); 若 \(A_n\in\mathcal{F}\), \(n\in\mathbf{N}\), 则 \(\bigcup\limits_{n=1}^\infty A_n\in\mathcal{F}\). \(\lambda-\pi\) 系 \(\pi\) 系 称 \(\Omega\) 的子集类 \(\Pi\) 称为 \(\pi\) 系, 如果它对交运算封闭. \(\lambda\) 系 称 \(\Omega\) 的子集类 \(\Lambda\) 称为 \(\lambda\) 系, 如果: \(\Omega\in\Lambda\); 对真差封闭: 即 \(\forall~A,B\in\Lambda\), s.t. \(A\subset B\), 总有 \(B\backslash A\in\Lambda\); 对不降序列的并封闭: 即 \(\{A_n:n\in\mathbf{N}\}\), \(A_n\uparrow\), 则 \(\bigcup\limits_{n=1}^\infty A_n\in\Lambda\). 集合形式的单调类定理 引理: \(\lambda+\pi=\sigma\) 若 \(\Omega\) 子集类 \(\mathcal{C}\) 同时为 \(\lambda\) 系和 \(\pi\) 系, 则 \(\mathcal{C}\) 为 \(\sigma\) 代数. 证明: 首先, 由 \(\mathcal{C}\) 为 \(\lambda\) 系可知 \(\Omega\in\mathcal{C}\), 且 \(\forall~A\in\mathcal{C}\), 均有 \(A\subset\Omega\), 于是 \(A^c=\Omega\backslash A\in\mathcal{C}\). 另一方面, 取 \(A_n\in\mathcal{C}\), \(n\in\mathbf{N}\) 则 \(B_n=\bigcup\limits_{n=1}^\infty A_k\), \(n\in\mathbf{N}\) 是不降集列, 于是由 \(A_k^c\in\mathcal{C}\) 以及 \(\mathcal{C}\) 是 \(\pi\) 系, 可知 \(B_n^c=\bigcap\limits_{n=1}^\infty A_k^c\in\mathcal{C}\). 于是 \(B_n\in\mathcal{C}\), 由定义知, \(\bigcup\limits_{n=1}^\infty A_n=\bigcup\limits_{n=1}^\infty B_n\in\mathcal{C}\), 于是 \(\mathcal{C}\) 为 \(\sigma\) 代数. 单调类定理 设 \(\Omega\) 的子集类 \(\mathcal{C}\) 是 \(\pi\) 系, \(\Lambda(\mathcal{C})\) 是包含 \(\mathcal{C}\) 的最小 \(\lambda\) 系, 则 \(\Lambda(\mathcal{C})=\sigma(\mathcal{C})\). 证明: 由于 \(\sigma\) 代数一定是 \(\lambda\) 系, 故 \(\sigma(\mathcal{C})\) 为 \(\lambda\) 系, 由 \(\Lambda(\mathcal{C})\) 的最小性, 有 \(\sigma(\mathcal{C})\supset\Lambda(\mathcal{C})\). 于是只需要证明 \(\sigma(\mathcal{C})\subset\Lambda(\mathcal{C})\), 由 \(\sigma(\mathcal{C})\) 的最小性, 只需要证明 \(\Lambda(\mathcal{C})\) 为 \(\sigma\) 代数. 又由于 \(\Lambda(\mathcal{C})\) 为 \(\lambda\) 系, 故只需要证明 \(\Lambda(\mathcal{C})\) 为一个 \(\pi\) 系. 即只需证明 \(\forall~A, B\in\Lambda(\mathcal{C})\), \(A\cap B\in\Lambda(\mathcal{C})\). 令 \(\Lambda_A=\{B\in\Lambda(\mathcal{C}): A\cap B\in\Lambda(\mathcal{C})\}\), 则只需证明 \(\forall~A\in\Lambda(\mathcal{C})\), 有 \(\Lambda_A=\Lambda(\mathcal{C})\) 即可. 由于显然有 \(\Lambda_A\subset\Lambda(\mathcal{C})\), 故只需要证明 \(\Lambda_A\supset\Lambda(\mathcal{C})\). 考虑到 \(\Lambda(\mathcal{C})\) 的最小性, 可按照如下三步证明: \(\forall~A\in\Lambda(\mathcal{C})\), \(\Lambda_A\) 是 \(\lambda\) 系; \(\forall~A\in\mathcal{C}\), \(\Lambda_A=\Lambda(\mathcal{C})\); \(\forall~A\in\Lambda(\mathcal{C})\), \(\Lambda_A=\Lambda(\mathcal{C})\). 证明第一条: 由 \(\Lambda_A\) 的定义, \(\Omega\in\Lambda_A\); \(\forall~B, C\in\Lambda_A\), s.t. \(B\subset C\), 则由 \(\Lambda_A\) 的定义有 \(A\cap C,A\cap B\in\Lambda(\mathcal{C})\), 同时易得 \(A\cap B\subset A\cap C\). 由于 \(\Lambda(\mathcal{C})\) 是 \(\lambda\) 系, 故对真差封闭, 即 \(A\cap(C\backslash B)=(A\cap C)\backslash(A\cap B)\in\Lambda(\mathcal{C})\), 于是 \(C\backslash B\in\Lambda_A\); \(\forall~\{A_n\}\subset\Lambda_A\), \(A_n\uparrow\), 则 \(A\cap A_n\in\Lambda(\mathcal{C})\) 且 \(A\cap A_n\uparrow\). 因此有 \(A\cap(\bigcup_{n=1}^\infty A_n)=\bigcup_{n=1}^\infty(A\cap A_n)\in\Lambda(\mathcal{C})\). 于是 \(\forall~A\in\Lambda(\mathcal{C})\), \(\Lambda_A\) 是 \(\lambda\) 系. 证明第二条: 只需要证明 \(\Lambda_A\supset\mathcal{C}\). \(\forall~B\in\mathcal{C}\), 由于 \(\mathcal{C}\) 是 \(\pi\) 系, 故 \(A\cap B\in\mathcal{C}\subset\Lambda(\mathcal{C})\), 于是 \(\mathcal{C}\subset\Lambda_A\). 证明第三条: 仍然只需要证明 \(\mathcal{C}\subset\Lambda_A\). 即需要证明 \(\forall~B\in\mathcal{C}\), \(B\in\Lambda_A\). 由于此时 \(A\) 不一定在 \(\mathcal{C}\) 中, 故无法对 \(A\) 使用第二条中的方法. 但由于 \(B\in\mathcal{C}\), 故可以对 \(B\) 使用第二条中使用的方法, 操作如下: 取 \(A\in\Lambda(\mathcal{C})\), 则 \(\forall~B\in\mathcal{C}\), 由上条可知 \(A\in\Lambda_B\), 又由 \(\Lambda_B\) 的定义可知 \(A\cap B\in\Lambda(\mathcal{C})\), 于是由 \(\Lambda_A\) 的定义, \(B\in\Lambda_A\), 于是 \(\mathcal{C}\subset\Lambda_A\). 综上所述, 原命题得证. \(\lambda-\pi\) 系方法 \(\lambda-\pi\) 系方法 在定理的证明过程中, &quot;要证明一些元素的集合满足性质 \(p\), 就先把满足性质 \(p\) 的元素集合设出来, 再证明该集合与原集合相等&quot; 的方法常常按照如下方法操作: 已知 \(\mathcal{C}\) 中元素具有性质 \(p\), 要证明 \(\sigma(\mathcal{C})\) 中元素也具有性质 \(p\), 则可以令 \(\Lambda=\{B\subset\Omega:B\text{具有性质}p\}\), 则 \(\Lambda\supset\mathcal{C}\), 然后证明 \(\mathcal{C}\) 是 \(\pi\) 系, 再证明 \(\Lambda\) 是 \(\lambda\) 系, 即可证明 \(\sigma(\mathcal{C})\) 中元素满足性质 \(p\). 这样的方法称为 \(\lambda-\pi\) 系方法. \(\lambda-\pi\) 系方法的应用 测度扩张定理的证明 证明见《测度与概率》（严士健、刘秀芳. 北京师范大学出版社.）P66-67 部分. 不再赘述. \(\pi\) 系上的有限测度 设 \(\mu,\nu\) 是可测空间 \((\Omega,\mathcal{F})\) 上的两个有限测度, \(\mathcal{C}\) 为 \(\pi\) 系, \(\Omega\in\mathcal{C}\) 且 \(\sigma(\mathcal{C})=\mathcal{F}\). 若 \(\mu, \nu\) 在 \(\mathcal{C}\) 上一致, 则 \(\mu,\nu\) 在 \(\mathcal{F}\) 上也一致. 分析: \(\mathcal{C}\subset\Lambda\), 要证明 \(\sigma(\mathcal{C})\subset\Lambda\), 考虑到 \(\mathcal{C}\) 为 \(\pi\) 系, 显然此处适用单调类定理. 证明: 故证明 \(\Lambda\) 是 \(\lambda\) 系即可. 由单调类定理即得 \(\mathcal{F}\subset\Lambda\). 另一形式的单调类定理 \(\Omega\) 的子集类 \(\mathscr{M}\) 称为 \(\Omega\) 的单调类, 如果它满足: 对不降集列的并封闭: 即 \(\{A_n\}_{n\in\mathbb{N}}\uparrow\subset\mathscr{M}\), 有 \(\bigcup\limits_{n=1}^\infty A_n\in\mathscr{M}\); 对不降集列的并封闭: 即 \(\{A_n\}_{n\in\mathbb{N}}\downarrow\subset\mathscr{M}\), 有 \(\bigcap\limits_{n=1}^\infty A_n\in\mathscr{M}\); 若 \(\mathscr{A}\) 为 \(\Omega\) 的集代数, 记包含 \(\mathscr{A}\) 的最小单调类为 \(\mathfrak{M}(\mathscr{A})\), 则 \(\mathfrak{M}(\mathscr{A})=\sigma(\mathscr{A})\). 因而包含 \(\mathscr{A}\) 的单调类必定包含 \(\sigma(\mathscr{A})\). 分析: 先证明两个命题: 1. 若 \(\mathscr{A}\) 同时为集代数和单调类, 则 \(\mathscr{A}\) 是 \(\sigma\) 代数; 2. \(\Omega\) 的任意子集类 \(\mathcal{C}\) 上的最小单调类存在. 其中第2条保证了单调类的 \(\mathfrak{M}(\mathscr{A})\) 存在, 进而可利用第1条进行证明: 显然 \(\sigma(\mathscr{A})\) 是单调类, 故 \(\sigma(\mathscr{A})\supset\mathfrak{M}(\mathscr{A})\), 故只需证 \(\sigma(\mathscr{A})\subset\mathfrak{M}(\mathscr{A})\); 为此只需证明 \(\mathfrak{M}(\mathscr{A})\) 为包含 \(\sigma(\mathscr{A})\) 的\(\sigma\) 代数, 由命题 2, 只需证明 \(\mathfrak{M}(\mathscr{A})\) 为集代数; 显然有 \(\Omega\in\mathscr{A}\subset\mathfrak{M}(\mathscr{A})\), 故只需证明 \(\mathfrak{M}(\mathscr{A})\) 对差运算封闭. 接下来便是 \(\lambda-\pi\) 证明的标准技巧: 令 \(M_A=\{B:B\in\mathfrak{M}(\mathscr{A}), A-B,B-A\in\mathfrak{M}(\mathscr{A})\}\), 接下来分三步证明: 证明 \(M_A\) 是单调类, \(\forall A\); \(\forall A\in\mathscr{A}\), \(M_A=\mathfrak{M}(\mathscr{A})\); \(\forall A\in\mathfrak{M}(\mathscr{A})\), \(M_A=\mathfrak{M}(\mathscr{A})\). 以上即为证明思路. 证明: 先证明两个引理. 引理 1 若 \(\mathscr{A}\) 为 \(\Omega\) 的集代数且是单调类, 则 \(\mathscr{A}\) 为 \(\sigma\) 代数. 引理 1的证明: 只需证明对于可列并封闭: 对 \(\forall \{A_n\}_{n\in\mathbb{N}}\subset\mathscr{A}\) 构造部分和集列 \(B_n=\bigcup\limits_{i=1}^n A_i\) 即可. 引理 2 \(\Omega\) 的任意子集类 \(\mathcal{C}\) 上的最小单调类存在. 引理 2的证明: 首先证明非空: \(\Omega\) 的全体子集 \(\mathcal{C}\subset\mathscr{P}(\Omega)\) 显然构成单调类, 故非空; 其次构造出来: 取包含 \(\mathcal{C}\) 的所有单调类的交, 容易验证该集类是一个单调类. 综上, 包含 \(\mathcal{C}\) 的最小单调类存在且为所有包含 \(\mathcal{C}\) 的单调类的交. 由这两个引理即可证明定理: 令 \(M_A=\{B:B\in\mathfrak{M}(\mathscr{A}), A-B,B-A\in\mathfrak{M}(\mathscr{A})\}\), 只需证明 \(M_A=\mathfrak{M}(\mathscr{A})\), \(\forall A\in\mathfrak{M}(\mathscr{A})\). 接下来分三步证明: 证明 \(M_A\) 是单调类, \(\forall A\); \(\forall A\in\mathscr{A}\), 证明 \(M_A=\mathfrak{M}(\mathscr{A})\); \(\forall A\in\mathfrak{M}(\mathscr{A})\), 证明 \(M_A=\mathfrak{M}(\mathscr{A})\). 1. 证明 \(M_A\) 是单调类, \(\forall A\) 取 \(A\in\mathfrak{M}(\mathscr{A})\), \(\forall\{B_n\}_{n\in\mathbb{N}}\uparrow\subset M_A\), 由 \(\mathfrak{M}(\mathscr{A})\) 的定义即有 \(A-B_n,B_n-A,B_n\in\), 同时显然有 \(B_n-A\uparrow\), \(A-B_n\downarrow\). 由于 \(\mathfrak{M}(\mathscr{A})\) 是单调类, 故 \(\bigcup\limits_{n=1}^\infty B_n\in\mathfrak{M}(\mathscr{A})\). 同时还有: \[ \begin{align} A-\bigcup\limits_{n=1}^\infty B_n &amp;= A\cap\left(\bigcap\limits_{n=1}^\infty B_n^c\right) \\ &amp;= \bigcap_{n=1}^\infty (A\cap B_n^c) \\ &amp;= \bigcap_{n=1}^\infty (A-B_n) \in\mathfrak{M}(\mathscr{A})~; \\ \left(\bigcup\limits_{N=1}^\infty B_n\right)-A &amp;= \bigcup\limits_{n=1}^\infty (B_n-A)\in\mathfrak{M}(\mathscr{A})~. \end{align} \] 于是有 \(\bigcup\limits_{n=1}^\infty B_n\in M_A\), 即 \(M_A\) 对上升集列的并封闭. 同理可证 \(M_A\) 对下降集列的交也封闭. 即 \(M_A\) 是单调类. 2. \(\forall A\in\mathscr{A}\), 证明 \(M_A=\mathfrak{M}(\mathscr{A})\) 若 \(A\in\mathscr{A}\), 则对 \(\forall B\in\mathscr{A}\), 有 \(A-B,B-A\in\mathscr{A}\subset\mathfrak{M}(\mathscr{A})\), 由 \(M_A\) 的定义知 \(B\in M_A\), 即 \(\mathfrak{M}(\mathscr{A})\subset M_A\). 另一方面, 由上条知 \(M_A\) 为包含 \(\mathscr{A}\) 的单调类, 故 \(\mathfrak{M}(\mathscr{A})\subset M_A\), 故有 \(M_A=\mathfrak{M}(\mathscr{A})\). 3. \(\forall A\in\mathfrak{M}(\mathscr{A})\), 证明 \(M_A=\mathfrak{M}(\mathscr{A})\) 考虑 \(B\in\mathfrak{M}(\mathscr{A})\), 则对 \(\forall A\in\mathscr{A}\), 由上条知 \(M_A=\mathfrak{M}(\mathscr{A})\), 于是 \(B\in M_A\). 进一步由 \(M_A\) 的定义有 \(B-A,A-B\in\mathfrak{M}(\mathscr{A})\). 又由于 \(\mathscr{A}\subset\mathfrak{M}(\mathscr{A})\), 故 \(A\in\mathfrak{M}(\mathscr{A})\), 结合 \(M_B\) 的定义有 \(A\in M_B\). 即 \(\forall A\in\mathscr{A}\), 总有 \(A\in M_B\). 于是 \(\mathscr{A}\subset M_B\). 即 \(M_B\) 是包含 \(\mathscr{A}\) 的单调类, 于是 \(\mathfrak{M}(\mathscr{A})\subset M_B\). 结合 \(M_B\subset \mathfrak{M}(\mathscr{A})\), 即有 \(M_B=\mathfrak{M}(\mathscr{A})\), \(\forall B\in\mathfrak{M}(\mathscr{A})\). 综上所述, 若 \(\mathscr{A}\) 为集代数, 则包含 \(\mathscr{A}\) 的最小 \(\sigma\) 代数与包含 \(\mathscr{A}\) 的最小单调类相同. 函数形式的单调类定理 \(\mathscr{L}\) 系 设 \(\mathscr{L}\) 是定义在 \(\Omega\) 上的广义实函数类, 满足: \(f\in\mathscr{L}\Rightarrow f^+,f^-\in\mathscr{L}\). 函数族 \(L\) 称为 \(\mathscr{L}\) 系, 如果满足: \(1\in L\); \(L\) 中有限个函数的线性组合(如果有意义)属于 \(L\); 若 \(f_n\in L\), \(n\in\mathbb{N}\), \(0\leqslant f_n\uparrow f\), \(f\) 有界或 \(f\in\mathscr{L}\), 则 \(f\in L\). 单调类定理 若 \(\mathscr{L}\) 系 \(L\) 包含一 \(\pi\) 系 \(\mathcal{C}\) 中任意集合的示性函数, 则 \(L\) 包含所有属于 \(\mathscr{L}\) 的 \(\sigma(\mathcal{C})\) 可测函数. 证明: 令 \(\Lambda=\{A\subset\Omega: I_A\in L\}\), 则由 \(\mathscr{L}\) 系定义可知 \(\Omega\in\Lambda\), \(\Lambda\) 对真差封闭并且对不降集列的并封闭, 因而 \(\Lambda\) 为 \(\lambda\) 系. 又由于 \(\mathcal{C}\subset\Lambda\), 且 \(\mathcal{C}\) 为 \(\pi\) 系, 结合集合形式的单调类定理可知 \(\sigma(\mathcal{C})\subset\Lambda\), 故 \(\{I_A: A\in\sigma(\mathcal{C})\}\subset L\). 由定义可知 \(\sigma(\mathcal{C})\) 上的任意简单函数在 \(L\) 中. 设 \(f\) 为 \(\mathscr{L}\) 中非负 \(\sigma(\mathcal{C})\) 可测函数, 则存在非负不降 \(\sigma(\mathcal{C})\) 简单函数列 \(f_n\uparrow f\). 由于 \(L\) 是 \(\mathscr{L}\) 系, 故 \(f\in L\). 若 \(f\in\mathscr{L}\) 且 \(\sigma(\mathcal{C})\) 可测, 则由 \(\mathscr{L}\) 的定义可知 \(f^+,f^-\in\mathscr{L}\) 且非负 \(\sigma(\mathcal{C})\) 可测, 于是 \(f^+,f^-\in L\), 结合 \(f=f^+-f^-\) 有意义及定义可知 \(f\in L\). 定理得证. \(\mathscr{L}\) 系方法 \(\mathscr{L}\) 系方法 要想证明某一函数族 \(F\) 具有某种性质 \(p\), 为此设一个函数族 \(\mathscr{L}\), s.t. \(L=\{f: 函数 f 具有性质 p\}\) 为一个 \(\mathscr{L}\) 系. 再引入一个 \(\pi\) 系 \(\mathcal{C}\), s.t. \(\mathscr{L}\) 中的 \(\sigma(\mathcal{C})\) 可测函数类包含 \(F\). 以上两步完成之后, 由单调类定理, 只要证明 \(\forall A\in\mathcal{C}\), \(I_A\in L\) 即可. 这种方法被称为 \(\mathscr{L}\) 系方法.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>概率论</tag>
        <tag>测度论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GRE阅读题目分析[4]]]></title>
    <url>%2F2017%2F07%2F25%2FGRE%E9%98%85%E8%AF%BB%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%5B4%5D%2F</url>
    <content type="text"><![CDATA[GRE 阅读的一点小小的总结. 题型辨识 事实信息类 事实信息 单纯事实信息 The passage makes which of the following claims (about X)? The passage claims which of the following (about X)? The passage suggests which of the following about X? The passage would probably agree with which of the following claims (about X)? (According to the passage,) which of the following claims (about X) is true? (According to the passage,) X. Which of the following best characterizes the &quot;X&quot; that the author refers to? Which of the following claims about X can be inferred from the passage? It can be inferred from the passage that X. It can be inferred that the author would agree with which of the following (claims about X)? Information presented in the passage suggests which of the following about X? Information in the passage best supports which of the following claims about X? With which of the following claims (about X) (discussed in the passage) would the author most likely agree? 结合逻辑的事实信息 According to the passage, X had which of the following effects for ...? According to the passage, the primary purpose of X is to ... The passage mentions which of the following as one of the reasons X? According to the passage, X in that ... 结合视角的事实信息 According to the passage, S would agree that X. According to the passage, which of the following is the most accurate statement of what S about Earth's X? The passage implies that S1 attributed which of the following beliefs to S2? The author of the passage and S would most likely agree/disagree with which of the following (claims about X)? 反事实信息 Each of the following is mentioned in the passage as X EXCEPT for the ... 问题 The passage supplies information for answering which of the following questions? 反问题 The passage supplies information for answering all of the folliwing questions EXCEPT: 加强 Which of the following statements, if true, wuold provide the strongest support/most strengthen X? 削弱 Which of the following if true, would most call into question/pose the greatest challenge to/most tend to weaken X? Which of the following is the most logical objection to X? X would be most seriously undermined if which of the following were true? Which of the following, if true, would provide the LEAST support for X? 假设 In the highlighted portion of the passage, the S assumes that ... The claim in the highlighted sentence assumes which of the following about X? 态度 The attitude of the author of the passage toward X can best be described as ... Which of the following best describes the author's attitude toward X? 有保留的支持 Qualified approval: 有让步存在. 信息功能类 信息功能 The author mentions X most primarily/probably/most likely in order to ... By quoting X, the author of the passage most clearly succeeds in ... Which of the following best describes the function of the highlighted sentence (in the passage)? (In the passage,) the function of the highlighted portion is to ... (In the passage,) the mention of X serves primarily to ... (In the passage,) the highlighted portion servers primarily to ... The highlighted sentence has which of the following functions in the passage? The highlighted sentence exemplifies which of the following? X is presented in the poassage primarily as [存疑] 选句子 Select the sentence that ... Click on the sentence in the passage that ... 论证结构 Which of the following best characterizes/describes the organization of the passage as a whole? 主旨 Which of the following best describes the main/central idea of the passage? The primary purpose of the passage is to (discuss which of the following?) The passage is primarily concerned with (doing which of the following) The passage is structured to lead to the conclusion that ... Which of the following generalizations most directly underlies the author's central point? 词汇 In the context in which it appears, &quot;X&quot; most nearly means ... Replacement of the word &quot;X&quot; with which of the following results in the least change in meaning for the passage? 类比 Which of the following is most similar to/is most closely analogous to/most closely parallels X?]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>GRE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GRE填空思路分析[3]——推理的线索来源·同义线索]]></title>
    <url>%2F2017%2F07%2F24%2FGRE%E5%A1%AB%E7%A9%BA%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90%5B3%5D%E2%80%94%E2%80%94%E6%8E%A8%E7%90%86%E7%9A%84%E7%BA%BF%E7%B4%A2%E6%9D%A5%E6%BA%90%C2%B7%E5%90%8C%E4%B9%89%E7%BA%BF%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[GRE 填空的一点小小的总结. 同义重复线索一般有四种: 简单重复解释、因果关系、递进关系、指代关系. 简单重复解释 尽管是&quot;简单&quot;重复解释, 但此类题目并不简单. 简单重复解释的标志一般有以下几种: 冒号: 对相关线索的解释; 分号: 表示分号前后信息的重复; 修饰解释结构: ......, 解释成分, (定语从句/同位语从句/分词短语); ...... n., 解释成分. 直白地说, 简单重复解释就是两部分内容一致. 例如下面一道难题: 例: In modern times, friendship has become a ____ relationship: a form of connection in terms of which all are understood and against which all are measured. A. conciliatory B. mercenary C. paradigmatic D. contentious E. supplementary 文章在冒号前的部分指出: 现在, 友谊成为了一种 X 的关系. 冒号后则指出: 所有的东西都是通过友谊来理解和度量的. 本题的难点主要就在于冒号后句子的理解. in terms of 后面的 which 指代的是之前的 a form of connection. 同理, against 后的 which 也指的是这种特定的 connection. 由于 against 与 in terms of 中间用 and 连接, 实际上意思是类似的. 所以冒号后的整个句子意思为: 所有的(all)东西都是通过 friendship 来理解和度量的, 所以 X 应该是一个表示&quot;标准&quot;的词语. 故选择 C. paradigmatic 意为&quot;典范&quot;. 一道容易错的题目如下: 例: Scholarly works on detective stories often begin with (i)____, suggesting that there is something vaguely wrong with adults who spend their time reading such f iction and certainly something (ii)____ those who devote energy to its analysis. Blank(i) Blank(ii) A. chronologies D. awry in B. apologies E. astute about C. synopses F. courageous about 文中虽然没有出现冒号和分号, 但在第一空后有一个 suggesting, 说明 suggesting 前后说的是同一件事. 前: 关于侦探小说的研究时常以 X 开头; 后: and 前后同样应该说的是同一件事. 前: adults 读侦探小说是错误的; 后: 在侦探小说的分析上耗费能量是 Y 的. 由 suggesting 后的句子的内部结构即可选出第二空为 D. awry in, 意为&quot;错误&quot;. 至此 suggesting 后的部分已经完整, 意为&quot;读侦探小说是错误的&quot;. 考虑第一空的答案, 只有 B. apologies 满足条件. 还有两道难题如下: 例: The new art museum's (i)____ building a ugurs well for that ambitious institution because it speaks of (ii)____ contemporary architecture on the part of the board of directors that may (iii)____ equal astuteness about contemporary art. Blank(i) Blank(ii) Blank(iii) A. nondescript D. a discernment about G. conceal B. outstanding E. a hostility toward H. supplant C. outdated F. an intoxication by I. promise 首先考虑第一空. 文章首先指出了博物馆的建筑具有 X 特点, 这预示着他们很有野心. 从这个很有野心出发, 可知他们的建筑也一定是具有一些很厉害的特点, 容易选出 A 选项. 文章随后开始解释原因. 整句话是一个 it speaks of ... that ... 的结构, 于是 that 前后说的应该是同一件事情: 前: 董事会就现代建筑的 X 而言 \(\Rightarrow\) 董事会对于现代建筑具有 X; 后: 可能会 Y 董事会对当代艺术同等的机智. 其实本来挺明白的意思稍微翻译一下变得狗屁不通。。在 that 后边出现了一个 equal astuteness, 说明 that 之前也一定得有一个 astuteness, 于是只能在空格处, 故第二空应选 D. a discernment about. 至此 that 前的部分已经完整, 意为&quot;董事会对现代建筑具有机智(什么垃圾东西)&quot;. 故 that 后的部分也应表达这个方向的意思, 故 that 之后的部分意思应为&quot;董事会对当代艺术也有着同等的机智&quot;, 这中间的连接词便应选择 I. promise. 完整的意思便是&quot;董事会对现代建筑所表现出的机智暗示着他们可能对当代艺术也有着同等的机智.&quot; 与前一部分合并起来, 整句话的意思就是: 新美术馆杰出的建筑预示着他们很有野心, 因为董事会对现代建筑所表现出的机智暗示着他们可能对当代艺术也有着同等的机智. MD, 真别扭. 例: Belanger dances with an (i)____ that draws ones attention as if by seeking to (ii)____ it; through finesse and understatement, he manages to seem at once intensely present and curiously detached. Blank(i) Blank(ii) A. undermonstrative panache D. focus B. unrestrained enthusiasm E. overwhelm C. unattractive gawkiness F. deflect 文章中有分号出现, 说明前后两部分说的是同一件事: 前: Belanger 的舞蹈伴随着一种 X, 通过 Y 的方式吸引着人们的注意; 后: 通过故意设计出的技巧和 understatement, 他能够非常神奇地既保持 detached, 又表现出强烈的感情. 考虑前后两部分之间的对应, finesse and understatement 的对应点应是第一空 understatement 在这里的意思应是&quot;不完全的展现&quot;, 故对比语义可以选出 A. undemonstrative panache. 接下来考虑第二空, Belanger 为了吸引大家的关注, 用了 Y 手段. it 指代的是前文的 attention, 正常情况下, 吸引大家的关注应采取 focus 的手段. 但考虑到后文的 curiously 以及 undemonstrative panache, 这种低调的炫酷, 应该选择 focus 的反面, 即 F. 因果关系 因果关系的基本原则: 因果等价——有什么原因, 就有什么结果(因为爱, 所以爱). 因果关系的重要标志: given...: 考虑到, 由于; in that...: 因为; so...that...: 非常...因为... . 以下是两个例子: 例: The politician's record while in office, though (i)____, hardly accounts for her high standing three decades later--a standing all the more (ii)____ because of continuing assaults on her reputation during those years. Blank(i) Blank(ii) A. bewildering D. unusual B. admirable E. regrettable C. unappreciated F. persistent 文章的大概结构为: 这个政客在办公室里的纪录尽管非常 X, 但仍然很难对她在30年之后如此高的地位做出解释——这些年来对她持续不断的批评攻击使得这个地位更加的 Y. 破折号前边是一个转折, 前后意思应相反, 故 X 应该是&quot;牛b&quot;的意思, 故选择 B, 令人尊敬. 破折号后边是一个因果关系, 原因的部分指出这些年来她遭受着持续不断的攻击, 但仍然能到达了如此高的地位, 所以这应该是很不寻常的, 选择 D. 例: The gaps in existing accounts of the playwright's life are not (i)____, since much of the documentary evidence on which historians have relied is (ii)____. Blank(i) Blank(ii) A. trifling D. credible B. obvious E. extent C. implicit F. incomplete 文章在第一空的后边出现了 since, 意味着前后的部分存在对应关系, 故可以寻找两部分之间的对应. since 前: 对剧作家生平的解释中的 gap 并不 X; since 后: 很多被历史学家所相信的证据都是 Y 的. 两句话的结构都非常简单, 都是&quot;A 具有特征 B&quot;, 由此可以得到, 两个空格之间是互相关联的. 于是无法直接求解两个空格的答案, 只能逐个考虑. 第一空显然是不能选择 C 的, C 选项意为&quot;含蓄&quot;, 用来形容 gap 显然是不恰当的. 若第一空选择 A, 则前半句的意思为&quot;对于剧作家生平的解释之间, 差异并不是很小的&quot;, 也就是在说&quot;这些解释是完全不靠谱的&quot;, 因为彼此之间差异很大. 于是后半句也应表示&quot;这些解释压根儿不靠谱&quot;, 故第二空选择 F. 至此, AF 是可行的方案. 若第二空选择 B, 则前半句的意思为&quot;对于剧作家生平的解释之间, 差异并不明显&quot;, 后半句应选择一个&quot;靠谱的证据&quot;, 故选择 D 选项. 此时 BD 看起来也是很合理的一个答案... 嗯 官方给出的答案是 AF... 递进关系 递进关系的基本原则: 表示前后程度的加深或变浅. 递进关系的重要标志: Even: 句首让步, 句中递进; indeed: 进一步地讨论; almost, not only...but also...; not just...but downright: 不仅...更是彻底的...; at best..., at worst...: 说好听了..., 说不好听了...; at least: 至少, 表示对前面的削弱. 以下是一道很长的题...: 例: The order applies to all Federal agency whose actions may affect the status of invasive species and requires agencies to identify such actions and to the extent parcticable and permitted by law, and since invasive species severely reduce the number of native species and even (i)____ their existence, the agency has determined and made public its determination that the benefits of such actions clearly outweigh the potential harm caused by invasive species; and that all feasible and (ii)____ measures to (iii)____ risk of harm of the introduction of invasive species will be taken in conjunction with the actions. Blank(i) Blank(ii) Blank(iii) A. escalate D. prudent G. remedy B. preclude E. mawkish H. counterbalance C. diminish F. braggart I. minimize 第一空之前有一个 even, 说明 X their existence 是对 severely reduce 的程度加深, 故应选择 B, 阻碍它们的生存. 第二空与 feasible 之间用 and 连接, 说明 Y 与 feasible 方向相同, 故选择 D, 意为谨慎. 前文一直在讲物种入侵的内容, 那么这些方法必然是降低物种入侵带来的危害的, 故之坑考虑 HI 选项. 若选 H, 则意为&quot;抵消风险&quot;, 从根本上来将, 风险是不能抵消的, 因为风险是客观存在的一种东西, 无法被抵消, 只能被弱化. 故第三空应选择 I. 综上所述, 选择 BDI. 以下是 not just... but downright... 的一个例子: 例: Making loans and fighting poverty are normally two of the least glamorous pursuits around, but remarkable enough put the two together, and you have an economic innovation that has become not just (i)____ but downright ____. Blank(i) Blank(ii) A. popular D. chic B. pointless E. unfathomable C. dangerous F. sensible 看到 not just... but downright... 的结构, 很容易知道 X→Y 是递进的关系, 观察选项只能选择 A(流行) 和 D(时髦). 指代关系 指代关系的基本原则: such..., this..., the former..., the equal..., the same... 这些词后提及的名词一定在前文出现过; 物主代词+空格, 则前文一定提到过. 以下是一个例子: 例: Though extremely (i)____ about his own plans, the man allowed his associates no such privacy and was constantly (ii)____ information about what they intended to do next. Blank(i) Blank(ii) A. candid D. soliciting B. idiosyncratic E. altering C. reticent F. eschewing 文章整体是一个转折的结构: 尽管他对于自己的计划非常 X, 但他却总是 Y 别人下一步的动作. 考虑到转折, 前后的意思一定是相反的, 而后半句中出现了 such privacy, 故这个 privacy 一定在前文出现过, 故只能是在空格处, 故第一空应选择表示&quot;保护隐私&quot;的词语, 故选择 C 沉默寡言. 考虑到转折, 后文一定是&quot;不尊重隐私&quot;的意思, 故选择 D 渴求, 不断打听. 整体的意思为: 尽管他对自己的计划保持沉默, 但他却不遗余力地打听其他人下一步的动作. 一道难题如下: 例: To label Hamilton a foreigner because he was born outside what later became the United States is to assume anachornistically the existence of the nation before the fact. It is true that Hamilton ame to believe that he was a (i)____ the United States, but his (ii)____ was stemmed not from his (iii)____ but from his confrontation with American democracy which he considered to be a disease afflicting the nation. Blank(i) Blank(ii) Blank(iii) A. symbol of D. alienation G. ideology B. stranger in E. ambition H. profession C. citizen of F. patriotism I. birthplace 文章的第一句话没有设空, 意思为: 因 Hamilton 没有出生在这个后来叫做美国的地方就称 Hamilton 为外国人是不恰当的, 因为在美国建立之前就将这个地方成为美国是时代错误的. 由此我们可以得到: Hamilton 确实没有出生在美国的土地上; 不能直接称 Hamilton 为外国人. 考察第一空, 整句为 It is true that... but... 的结构, 故 It is true... 的部分应是一个让步, 故这句话表达的意思应是&quot;Hamilton 确实有些像个外国人&quot;, 故第一空应填 B. 第二空是题目的难点. 前半句说了&quot;尽管 Hamilton 看起来确实很奇怪&quot;, 故后半句应回到文章的管线&quot;Hamilton 不能因为不生在美国土地就被称为外国人&quot;上面来. 考虑至此, 第三空的答案已经得出, 应选择 I 选项. 继续推断, 可推测出第二空应选择 D. 第二句整体的意思为: 虽然 Hamilton 在美国看起来确实很奇怪, 但他的疏离并非源于他的出生地, 而是他对于美国民主的反对. 综上所述, 本题应选择 BDI. 另一道难题也是三空题: 例: Recent proposals for fixing the climate have taken the form of large-scale geoengineering projects such as launching mirrors into space to reflect solar radiation away from Earth, undertaking that are vastly more (i)____ than anything a nineteenth-century rainmaker could have cooked up. What is unclear, as one looks back at the history of weather modification research, is whether this resourceful ambition will be (ii)____, or if, by contrast, it serves to make the scientific community's (iii)____ that much more devastating. Blank(i) Blank(ii) Blank(iii) A. effective D. anticipate G. avidity B. enterprising E. challenged H. impotence C. accessible F. productive I. resignation 最近&quot;向空中发射一个镜子反射太阳辐射以改善气候&quot;的提案是远比19世纪的 rainmaker 编造的东西更 X 的任务. 但当你回头审视人们对于修改天气的研究的时候, this resourceful ambition 是否会 Y 依然不甚清楚, 或者相反, 他会使得科学界的 Z 更加具有破坏力. 注意到文中有 this resourceful ambition... 存在指代关系, 于是 resourceful ambition 一定在前文提到过, 经过比较可以确定对应位置在第一空处. 接下来需要明确 resourceful ambition 的含义, resourceful 的意思是&quot;能在困难中有效地处理&quot;, 一般有两种解读, 一种是有效的(effective), 一种是有创造力的(imaginative). 对应到第一空的选项, 分别可以选择 A. 有效 和 B. 创新. 至此还没有有效的证据对此处的意思进行推定. 继续考虑第二和第三空, 第三空后的 that 此处等价于 so, 表示强调. 能使得 Z 更具有破坏力, 说明 Z 本身就具有破坏力, 故此处应填负面评价的词汇, 考察选项, 应选择 H. 此处应注意, G. avidity 不能翻译为&quot;贪婪&quot;, 事实上 avidity 约等于 ambition. 由 by contrast, 反推第二空应填正面评价的词, 考察选项可选出 F, 事实上 productive 也恰好就是 impotence 的反义词. 现在回头去思考第一空, 我们已经大约知道了 X = resourceful, 故第二空所在的句子意思为&quot;这种 X 的 ambition 是否有效还不清楚&quot;. 若第一空选择 A, 则与该句矛盾, 故第一空只能选择 B. 总结以下, 解题的思路是: this resourceful ambition... → X=resourceful → X=A/B; Z 是有破坏力的 → Z=H; by contrast... + 2 → Y=F → ambition是否有效还不清楚; 3 + 1 → X\(\neq\)A → X=B. 综上所述, 本题答案为 BFH.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>GRE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GRE阅读题目分析[3]]]></title>
    <url>%2F2017%2F07%2F23%2FGRE%E9%98%85%E8%AF%BB%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%5B3%5D%2F</url>
    <content type="text"><![CDATA[GRE 阅读的一点小小的总结. 如何读信息 意群信息提取原则 始终默认所读的逻辑关系是成立的, 寻找概括、补充、修正关键信息次, 以验证已经确定的关系. 顺: 3种情况 同义改写: =——前后完全相同; 举例: \(\in\)——例子符合逻辑; 理由: 联系, 补足理由与观点之间的gap e.g. 万炜会成功的, 因为他很努力. (努力就会成功) e.g. 万炜一定会成功的, 因为努力的人都成功了. (万炜一定很努力) 转: 质疑——挑双方的异同/补足反驳理由和结论之间的gap e.g. 主流观点认为万炜帅, 但其实只在学校比较帅. e.g. 主流观点认为万炜聪明, 但他GRE挂了. (聪明人不会挂GRE) e.g. 主流观点认为万炜聪明, 可聪明的人应该过了GRE. (万炜一定没有过GRE) 比: 类比/对比 对比: A vs B. 类比: A \(\approx\) B. 观点单一的文章 George Milner cites three primary problems with the labeling of Cahokia, the large archeological site by the Mississippi River, as a state rather than a chiefdom. First, finds at Cahokia are essentially similar to finds at other Mississippian chiefdoms, except that the amount of earth moved in building the mounds at Cahokia was greater than else where. Second, fewer people lived at Cahokia than is commonly estimated (Milner estimates that there were only a few thousand inhabitants, more common estimates are 10,000 or 20,000 inhabitants); therefore, extensive taxes, and tribute were not necessary to support them. Finally, while there is evidence of extensive earth movement, craftwork, trade, and elite at Cahokia, this does not indicate that Cahokia was politically centralized, economically specialized of aggressively expansionistic. The passage implies that political centralization is a feature that A. has not historically tended to emerge in centers with fewer than 20,000 inhabitants B. distinguished other Mississippian chiefdoms from Cahokia C. is considered characteristic of state but not of chiefdoms D. often results from aggressive expansionism and sconomic specialization E. has historically been necessary for extensive trade to occur 文章开头指出, George Milner 认为, Cahokia 应该是 chiefdom, 而不是 state. 需要注意 &quot;cite three problems&quot; 的意思应该是负面的, 认为后面的句子是不正确的. 故 GM 应该不认同 Cah 是 state, 而认为 Cah 是 chief 的. 简记为 GM: cah=chief vs. state. 随后文章开始逐一解释 GM 的三个问题: Cah 与 chief 很相似, 除了土比较多. 把握住文章的第一句话, 考虑到本句不可能是新信息, 故GM不具备的特点应该就是 state 的特点. 于是可以建立符号对应: state: 土多; cah 具有人少的特点, 并且不需要 tax, trade 和 tribute (记为 3t). 继续扣住文章第一句话, 本句就是在说 chief→人少, 不需要3t. 继续推理可得, state→人多, 需要3t; 尽管 cah 存在 em, cr, tr, el, 但是 cah 并不是 pe, es, ae 的. 这里出现了一个让步, 故前半句应该是对另一方的妥协, 即前半句是在说&quot;尽管cah具有一些state的特点&quot;, 故 em, cr, tr, el 均为 state 的特点. 同理, 后半句在说&quot;但cah仍然是chief&quot;. 故 chief 一定是非pe, 非es, 非ae的. 总结一下, 本篇文章的结构如下: GM: Cah=chief vs. state cah像chief state土多 人少, \(\neg\) 3t 人多, 3t \(\neg\)pe, \(\neg\)es, \(\neg\)ae em, cr, tr, el 存在观点冲突的文章 Astronomers studying a certain kind of supernova (exploding star) were surprised to find the supernovas were fainter than expected. Seeking explanations, they discounted the possibility that cosmic dust might be screening out some of the light, because it would filter out blue light more than red, causing the supernovas to appear redder than they really are. Also, unless spread very smoothly throughout space, the dust would introduce large variations in the measurements. Another possibility is gravitational lensing, the bending of light rays as they skirt galaxies en route. Such lensing occasionally causes brightening, but most often it contributes to the dimness of distant supernovas. Calculations show, however, that this effect becomes important only for sources more distant than the supernovas studied. According to the passage, the astronomers rejected gravitational lensing as an explanation for their findings because A. gravitational lensing can cause supernovas to appear brighter than they really are. B. their calculations showed a negligible effect of gravitational lensing for light rays from distant sources. C. light rays trabeling from the supernovas studied did not have to skirt galaxies. D. the effect of gravitational lensing on the appearance of supernovas is unpredictable. E. the supernovas studied were too near for gravitational lensing to have the observed dimming effect. The passage implies which of the following about the measurements made by the astronomers? A. There were small calculation errors in their measurements. B. There were no large variations in their measurements. C. Their measurements were skewed by unevenly spread cosmic dust. D. Their measurements were incomplete because cosmos dust screened out some of the light. E. It was possible to take more measurements of red light than of blue light. 文章开头是一个事实——supernova 比看起来要暗一些, 那么后文一定是在对这件事情进行解释. 下文指出, 宇航员们首先排除了宇宙尘埃的影响, 因为比起红光, 尘埃会过滤更多的蓝光. &lt;???&gt;这个句子很迷, 至此还没有非常有效的信息, 但是可以初步得到一个类似于&quot;尘埃使得supernova变红并不能使之变暗&quot;的结论. 后文的 Also, unless ... 指出, 在一般情况下, 尘埃会带来很大的边数. 这个地方与问题看起来联系仍然不是非常紧密. 这里的内容读起来非常迷, 留在分析题目时继续讨论. 下文的 Another possibility is ... 一句指出, 除了尘埃之外还有一种可能的原因, 就是 gravitational lensing, 简记为 GL. 但是接下来突然出现了 Such lensing occasionally causes brightening. (??? 作者在搞什么? GL 不是 supernova 变弱的原因吗? 怎么忽然又能使之变亮了?) 继续阅读后文, 发现后文存在一个 but, 即可知上文的 brighten 其实是一个让步. but 后指出, 多数情况下, GL 还是会使 supernova 变暗的. 文章到这里还没有结束. 最后一句中的 however 看起来就像一个大大的&quot;卧槽&quot;. 忍住骂人的冲动继续读, 大概可以了解到最后一句的意思是&quot;尽管..., 但是计算表明 GL 只对那些比supernova更远的星星有效果.&quot; 此处应有&quot;卧槽&quot;, 读了这么半天, 原来问题还是没有解决. 先提到了尘埃, 然后说尘埃被排除了. 提到GL这个高大上的东西的时候, 读者一定看到了希望, 然后...GL就被证明是错误的了. 综上所述, 这篇文章的内容可以简化为: super faint → dust? × → GL? → contribute to dimness: √ → 适用距离太远: ×. 文章的第一题显然出题点就是最后一句, 所以该题的答案一定是&quot;supernova 太近了, GL 适用距离太远了&quot;. 很容易选出E选项. 第二题比较困难, 考察的就是事实与观点之间的gap. 在分析文章时, 尘埃附近的内容读起来比较迷, 原因就在于作者只提供了最终结果和做出判断的前提, 没有给出二者之间的详尽推理. 文中指出, dust 被排除在外, 言下之意就是 dust 对于 supernova 变暗没有贡献. 而下文的 Also, unless ... 一句指出, 除非光线的传播非常顺畅, 否则观测一定有很大变数. 上文提到 dust 是可以阻碍光线传播的, 于是光线顺畅地传播等价于没有尘埃. 所以这句话实际上应该理解为: 除非尘埃不存在, 否则观测会存在很大的变数. 至此, 我们得到的信息是: 宇航员认为 supernova 的黯淡不是 dust 造成的, 并且若 dust 存在, 则一定会给观测带来很大的变数. 那么这两件事情之间需要补充的gap就是: 在观测中没有遇到很大的变数. 这里宇航员的推理就是一个典型的 \(p\to q, \neg q\Rightarrow \neg p\) 的推理过程. 在这里, \(p\) dust 的存在, \(q\) 观测存在很大的变数. 已知 \(p\to q\), 宇航员一定是观测到了 \(\neg q\), 才敢断言 \(\neg p\). 于是这道题的答案应是 B. 顺带一提第二题中令人费解的事实和结论. 文章指出: 宇航员排除了 dust 的影响, 因为 dust 会使得 supernova 变红. 并且, 除非 dust 不存在, 否则 dust 会给观测带来很大的变数. 这里的原理是: 红光的波长比较长, 于是在传播时不容易衰减. 于是距离比较远的天体看起来也比较偏红, 因为波长短的光在长距离传播中被散射掉了. 尘埃会使得 supernova 变红, 自然也就会使得人们对于距离的观测值变大, 即给 measurement 带来 large variation. 所以, dust 的存在, 一定会给观测带来巨大的影响. 基于这些原理, 文中的宇航员才会做出如此的判断. 第二题的难度较高, 难的原因主要在于逻辑的推导. 常见的一些逻辑如下: If p, q. —— \(p\to q\); Only if p, q. —— \(\neg p\to\neg q\); Unless p, q. —— \(\neg p\to q\). 关于因果和转折中的条件的真假性, 有如下分类: 因果: Because p, q. —— p 为真; If p, q. —— p 不确定; If p were true, q would have been true. —— p 为假. 转折: Even though p, q. —— p 为真; Even if p, q. —— p 不确定; Even if p were true, q would have been true. —— p 为假.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>GRE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GRE填空思路分析[2]——推理的线索来源·反义线索]]></title>
    <url>%2F2017%2F07%2F20%2FGRE%E5%A1%AB%E7%A9%BA%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90%5B2%5D%E2%80%94%E2%80%94%E6%8E%A8%E7%90%86%E7%9A%84%E7%BA%BF%E7%B4%A2%E6%9D%A5%E6%BA%90%C2%B7%E5%8F%8D%E4%B9%89%E7%BA%BF%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[GRE 填空的一点小小的总结. 反义线索主要有对比和让步转折两种. 对比 情况1: 矛盾词 irony, ironical, ironically. paradox, paradoxical, paradoxically. contradiction, contradictiony. opposite, oppositior. contrast, contrary. 例: The concept of timelessness is paradoxical from the start, for adult consciousness is permeated by the awareness of duration. 例句中的 timelessness 理解为&quot;永恒的&quot;是没有意义的, timelessness的真实含义应为&quot;无始无终的&quot;. 而 duration 显然是有始有终的一段时间, 故 timelessness 与 duration 形成对立. 如下面的三题: 例: Paradoxically, Robinson's excessive denials of the worth of early works of science fiction suggest that she has become quite ____ them. A. enchanted by B. enamored of C. skeptical of D. exasperated by E. offended by F. reflective about 题目很简单, 前半句抛出了对比的一半信息: Robinson 认为科幻作品没有价值. 故后半句应表示出&quot;Robinson 认为科幻作品有价值&quot; 的意思. 故选择 AB 选项. 例: An apparent paradox led the scientists to pursue their present line of research. They were struck by the fact that a single mathematic formula can be used to describe physical phenomena that appears to be so ____. A. rudimentary (基本的, basic) B. interdependent (相互依赖) C. interrelated (相互关联) D. complex E. heterogeneous (不同) F. dissimilar 题目中有 be struck by... 的结构, 表明后面存在对比. a single formula 能够用以描述一些物理现象. 此处似乎无法直接确定选项, 于是可以将前文的single直接取反, 即可得到后面的物理现象应该是&quot;不同的&quot;. 故选 EF 选项. 例: From the outset, the concept of freedom of the seas from the proprietary claims of nations was challenged by a contrary notion--that of the ____ of the oceans for reasons of national security and profit. A. promotion B. exploration C. enclosure D. appropriation E. conservation F. surveying 句首的 from the outset 等价于 from the beginning. 随后文章指出, 自由的概念被一个 contrary notion 所挑战, 故后面应该是说的如何不自由. 选项中可以找到 freedom 的广义反义词为 CD. 情况2: 强烈情感词 surprisingly, astoundingly, weird, startling, curiously (莫名其妙), remarkable (异乎寻常), be struck by. 例: Thomas Painem whose political writing was often flamboyant, was in private life a surprisingly simple man: he lived in rented rooms, ate little, and wore drab clothes. 文章中 Thomas Paine 的作品酷炫与生活简单形成了对比. 信号词就是surprisingly. 在出现对比的时候一定要理清文章的逻辑和内容, 否则可能会因此选错. 如以下的两题 例: While in many ways their personalities could not have been more different--she was ebulliend where he was glum, relaxed where he was awkward, garrulous where he was ____--they were surprisingly well suited. A. solicitous (渴求的) B. munificent (大方的) C. irresolute (犹豫不决) D. laconic (言简意赅, concise) E. fastidious (小心谨慎, 一丝不苟, 挑剔苛求) F. taciturn (沉默寡言) 文章中很容易看到 surprisingly 的存在, surprisingly 后指出两人很般配, 于是可知前文应该是说两人是不般配, 甚至相对立的. 文章在空格前指出了 she was garrulous, garrulous 意为&quot;啰嗦&quot;, 故后文应表示&quot;他话很少&quot;的意思, 故选择 DF 选项. 例: Scholars have marveled over the (i)____ that Shakespeare displays in his works, noting that such broad learning is all the more remarkable given that books were relatively (ii)____ in Shakespeare's time. Blank (i) Blank (ii) A. meticulousness (一丝不苟, fastidious) D. edifying (有教育意义的) B. humor E. scarce C. erudition (博学) F.inexpensive 文章的前半部分有一个 noting that such broad learning..., 此处的 broad learning 是新提出的, 故前文一定提到过. 浏览前文, 并没有提到相关内容, 故一定是空格处提出的. 于是(i)空应选C项. 结合marvel 和remarkable, 可知前后两部分形成了对比, 于是莎士比亚读的书应该是很少, 才能与他的博学形成对比. 故第(ii)空应填 E. 情况3: 其他常见对比关系 其他常见对比关系: 时间点前后: recently, previous, before, current, now, today, yesterday, later, future, initially, no longer; 表象和实质: in fact, in reality, ostensible(表面上的), normally; 一般对特殊; 整体对个体; 结构对比: 不是A, 而是B: not A but B, far from A to B, less A than B; 是A, 而不是B: more A than B, A rather than B. 以下是两道比较难的题目, 都是双空题. 例: The museum's compelling new architechural exhibition looks at eleven projects around the world that have had major (i)____ impacts despite modest budget. It is part of (ii)____ in the museum's architecture and design department, which in the past has championed architecture's artistic value over its real- world consequences. Blank(i) Blank(ii) A. social D. an emphasis on theory B. aesthetic E. a shift in philosophy C. critical F. a rejection of programatism 文章首句指出了博物馆的展览关注的是11座造价不高的建筑, 而 despite 表明了空格与 modest budget 之间存在对比关系, 但至此仍然无法在 ABC 中找到正确选项. 第二句中的 it 指代的应是前文提到的展览, 接下来空格附近的内容也无法确定, 但下文出现了 which, 一定会对这里的内容进行解释. 注意到 in the past 的存在表明了此处应该存在一种时间上的今昔对比, champion A over B 意为&quot;支持 A 而不支持 B&quot;, 即曾经不重视 real- world consequences, 故如今应当重视. 注意这里谈论的内容仍然是与展览相关, 故此处的信息一定是前文提到的, 于是第(i)空应选择 A 选项, 以表示该展览重视了 real- world consequences. 第二空附近的内容被后面 which 引导的从句所解释, 故两方面内容应该是基本等价的, 概括从句内容可知是博物馆对于 artistic value 和 real- world consequences 的态度发生了转变, 故第二空选择 E 选项. 此处的 philosophy 不表示&quot;哲学&quot;的意思, 而是表示一种&quot;理念&quot;的意思. 值得注意的是, in the past 在整个文章中的地位极其重要, 如果没有看到 in the past, 则第(i)空选择 B. aesthetic 也可以说得通, 而第二个空也会错误理解为&quot;博物馆仍然不重视real- world consequences&quot;, 从而错选为 F. a rejection of pragmatism, 意为&quot;对实用主义的消极态度.&quot; 例: Britain's deteriorating economy after 1945 was (i)____ by policians who favored the manufacuring sector over the service sector: rather than attempting to (ii)____ the decline of manufacturing, they should have promoted service industries. Blank(i) Blank(ii) A. mishandled D. augment B. bolstered E. arrest C. forestalled F. escalate 文章在第(i)空之前的部分提到了英国恶化的经济状况, 空格后的 by politicians... 表明空格表示的是政客的一些操作. 随后文章指出了政客的想法是 favored the manufacturing sector over the service sector, 意为&quot;把制造业看得比服务业更重要.&quot; 至此仍然没有清晰的线索指向第(i)空的操作. 接下来出现了冒号, 则冒号后的内容方向一定是与前文一致的. 不妨设第(ii)空的内容为 X, 则冒号后的内容为, 政客本应该促进服务业的发展, 而非 X 制造业的衰落. 至此第(ii)空的线索已经明确. 政客们的操作目的应是拯救英国衰退的经济, 故 X 应表达&quot;阻止制造业的衰退&quot;的意思, 故应选择 E 选项. 最后的虚拟语气 they should have promoted... 是非常关键的线索. 一般来说, 虚拟语气暗含着对比: &quot;他们本应该...&quot;, 实际上是在表明&quot;他们如果不这样就会很好, 但他们搞砸了.&quot; 所以这句话实际上表明了&quot;政客们使得英国本就不景气的经济雪上加霜.&quot; 于是第一空应选择 A. mishandled, 意为经营不善. 综上所述, 题目应选择 AE 选项. 让步转折 让步转折的主要标志: but, while, though, although, despite, in spite of, notwithstanding, nonetheless, nevertheless, for all, yet, unless, however, whatever, regardless of, albeit. 其中有一些注意事项: despite 是介词, 后面需要接词, 不能直接跟句子, 如果需要跟句子, 则需要 despite that... ; notwithsatnding 可以做副词或介词, 意为&quot;尽管&quot;; forall = despite; albeit = although; nonethless 和 nevertheless 的用法: 若二者单独出现, 则意为&quot;然而&quot;; 若前文已有转折词, 则二者无意义. but 用法的一个特例: but...more... 表示&quot;进一&quot;, &quot;更多的&quot;. 在做题时要通过各种信号词来推测空格与已知信息的正负关系, 不能忽略掉任何一个, 否则就容易理解错误. 如下面的例子: 例: Clearly the government faced a dilemma: it could hardly ____ trials, especially in the absence of irrefutable evidence, but it also would not welcome, in the midst of war, the scandal that would raise if trials were avoided. A. be keen on B. be inclined to C. arrange D. dispense with E. turn its back on F. credit 开头提到了一个困境, 暗示后文是两件事情的对立. 设空格为 X, 则容易分析出 hardly X trials 与 would not welcome the scandal 是矛盾的. 考虑到 scandal 是在避免 trials 的情况下出现的, 故 scandal = \(\neg\) welcome trials. 于是之前得到的结论, \(\neg\) X trials =\(\neg\)\(\neg\)\(\neg\) welcome trials. 故 X trials = welcome trials. 于是应选择正向的选项, 即AB. 如果在分析过程将 welcome 的宾语错当为 trials, 或漏掉转折的标志, 则有可能会错选DE. 值得一提的是, dilemma 专指的是左右两难的困境. 即 dilemma 一定是两件事情之间的纠结状态. 一个难题如下: 例: As serious as she is about the bullfight, she does not allow respect to ____ her sense of whimsy when painting it. A. inspire B. provoke C. suppress D. attack E. satisfy 题目中出现了 As 引导的半倒装句, 一般来说表示让步. 后面的 allow respect to ... 也是一个比较难以分析的地方. 事实上, 此处的结构为 allow sb to ..., 若理解为 allow (respect to ...) ... 则题目无法下手. 关系和内容明确后, 文章变为了 serious to bullfight=\(\neg\) not allow to X her sense of whimsy while paint it. 即 X = \(\neg\) serious. 即应选择负面的词语, 为 C 选项. 关于 as, 有如下几条: as 引导的半倒装句表示让步. Student as she is, she does not study hard. 尽管她是个学生, 她并不好好学习. As ... as ... = So ... as ... As: adv. = so; as: conj. 正如, 就像. 再次回到题目, 文章中相对应的部分实际上是 So serious 和 respect. 同主体让步转折 同主体让步转折, 顾名思义就是主体不变的情况下进行让步和转折. 但前后不可能完全对立, 即不可能出现&quot;他很帅, 但很丑&quot;这样明显错误的句子. 但考虑到不完全对立, 可以有&quot;我很丑但我很温柔&quot;这样的句子, 这样的情形就被称为同主体让步转折. 可以总结为以下几条: 形式: Although A..., A... 前后转折主体为统一事物, 并处于同一时空范围内. 原则 前后两个空格不能截然相反; 前后两个空格可以是正负相对但意思无关的概念. (丑-温柔, 聪明-懒惰) 以下是一道难题: 例: His affection for his sister, though not ____, was plainly too great to permit a painless departure. A. unsteady B. noticeable C. ambivalent D. careless E. unbounded 此处的 affection 意为&quot;爱&quot;. 观察到文中的 though, 结合语义可得到 not X = \(\neg\) great. 故 X 为正向的词语. 符合要求的有 BE 两项. 此题很容易错选B选项. B. noticeable 带入文章中意为&quot;尽管他对姐姐的爱不是那么明显, 但仍然足够great.&quot; 虽然情感方向正确, 但后文的plainly 意为&quot;明显的, 显然的&quot;, 与此处的 not noticeable 矛盾. 故综合考虑应选择 E. unbounded. 以下是另一道难题: 例: While not completely nonplussed by the unusually caustic responses from members of the audience, the speaker was nonetheless visibly ____ by their criticism. A. humiliated B. discomfited C. deluded D. disgraced E. embarrassed F. tantalized 文章的大概意思为&quot;尽管speaker还没有被完全弄得困惑, 但他显然还是被弄得 X.&quot; 值得注意的是文章中 nonetheless 不表示转折, 意为&quot;仍然&quot;. 于是 X 应是负面的词, 但强烈程度不及&quot;nonplussed&quot;. 单纯考虑情感方向, 可以选择 AD. 羞辱 或者 BE. 不爽/尴尬. 继续考虑到强烈程度的问题, 应选择 BE. 本题的 F 选项 tantalized 意为&quot;挑逗&quot;. GRE中常出现的&quot;挑逗&quot;共有3个: tantalized &lt; allure &lt; seduce. 引诱程度依次加深. 其中 seduce 意为&quot;色诱&quot;.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>GRE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GRE填空思路分析[1]——词句推理]]></title>
    <url>%2F2017%2F07%2F20%2FGRE%E5%A1%AB%E7%A9%BA%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90%5B1%5D%2F</url>
    <content type="text"><![CDATA[GRE 填空的一点小小的总结. Verbal Reasoning 的特点 第一个记分的语文的填空部分一定是2个单空, 3个双空, 1个三空. 建议用时: 10min填空, 20min阅读. 填空题目不考察背景知识, 所有线索均来自于题目. 词汇问题 第一类问题: 词义理解有误: 韦氏词典+美国传统辞典; 第二类问题: 望文生义: 单词 真实含义 invaluable/priceless 特别值钱 impassive 消极冷漠 impassion 热情 effortless 不费力的 ignorance 无知 salient 显著的 appraise 评价 acclaim 喝彩 servered 切开 reserve/reverse 保留/相反 guild 协会 第三类问题: 熟词僻义: 单词 熟词生义 turf 地盘 list 倾斜 licence 自由 第四类问题: 纯难词/词根猜测 背单词...Orz 长难句理解 长句 三个概念: that 的作用: 代词, 表示&quot;那个&quot;; 引导从句. 同位语: 跟在名词后, 表示对其的修饰; 分词短语: 做定语, 表示对前面名词的修饰; 做状语, 与主语用逗号隔开表示主语的状态. 用逗号隔开的必定是状语, 反之可能是定语. 例: The increase in the numbers of married women employed outside the home in the twentieth century had less to do with the mechanization of housework and an increase in leisure time for these women than it did with their own economic necessity and with high marriage rates that shrank the available pool of single women workers, previously, in many cases, the only women employers would hire. 例句中, The increase 是主语, had less to do with 是谓语, than it did with... and with 是宾语. 至此主干已经清楚, 最后的 the only women 是同位语. 难句 例: For some time now, ____ has been persumed not to exist: the cynical conviction that everybody has an angle is considered wisdom. A. rationality B. flexibility C. diffidence D. disinterestedness E. insincerity 例句的最后部分 everybody has an angle is considered wisdom 的意思是&quot;每个人都很自私.&quot; 考虑到冒号前的not, 前后两部分意思应相反, 故选择D, 意为&quot;无私.&quot; 例: The current ____ of package music under Miles Davis' name might prompt ant reasonable person to conclude that the recording vault has been plundered bare. A. glut (过量) B. revival (复活) C. hodgepodge (大杂烩) D. surfeit (过量) E. modicum (少量) F. dearth (少量) 例句的最后部分 the recording valut has been plundered bare 直译为&quot;唱片金库被掠夺一空.&quot; 此处的意思为&quot;Miles Davis 已经江郎才尽.&quot; 于是题目应选择 AD 选项. 推理的步骤与注意事项 逻辑和语义 逻辑的判断方法: 是否有反义: 首先判断分句与分句之间是否有反义转折词; 是否有否定: 其次判断空格或抑制信息前后是否有否定; 有几个否定: 转折词汇也算作否定, 判断否定的层数; 常见的否定词: no/not, less, little, anything but, few, never, hardly=barely, rarely=seldom. 语义的判断方法: 判断广义同反义. 广义同义概念: 严格同义词; 感情色彩相同的词, 如: 勤奋-善良, 邪恶-懒惰; 正负方向相同的词, 如: 增高-变多; 逻辑相关词, 如: 艺术-艺术家, 科学-科学报告. 广义反义概念: 严格反义词; 感情色彩相反的词; 正负方向相反的词; 与极端词相对应的中性词, 如: 上升-下降, 上升-静止 均可. 推理的步骤 一般有以下的五步: 通读题干, 明确哪一空最好做; 明确空格作用: 如表示谁的动作, 修饰的是谁的属性; 判断逻辑同反义关系; 判断空格的语义对应线索; 对空格做出预测, 选出正确选项. 填空的后半句一定没有新概念出现, 若有, 则一定在前半部分出现过. 推理的注意事项 一定要以文章的剩余信息为依据, 解题线索一定来自题目本身, 不要带入主观假设和偏见; 需要有必要的常识 common sense 例: Nature's energy efficiency often (i)____ human technology: despite the intensity of the light fireflied produce, the amount of heat is negligible (可忽略的); only recently have humans developed chemical light-producing systems whose efficiency (ii)____ the firefly's system. Blank (i) Blank (ii) A. outstrips (超过) D.rivals (与...相匹敌) B. reflects E. manipulates C. determines F. inhibits (抑制) 例句中首先说明了萤火虫的光很强但发热很少, 下文又提到了能量效率. 能量效率=有用能量/总能量 就是一个常识, 于是容易知道萤火虫的发光效率非常高. 而萤火虫是冒号后新出现的东西, 故一定是前文所提到的, 可知萤火虫所属的阵营是自然, 于是可以猜测下文要说的是人类的能量效率比较低. 于是本题应选择 AD 选项.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>GRE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GRE阅读题目分析[2]]]></title>
    <url>%2F2017%2F07%2F16%2FGRE%E9%98%85%E8%AF%BB%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%5B2%5D%2F</url>
    <content type="text"><![CDATA[GRE 阅读的一点小小的总结. 文章内容 Many scholars have argued that government investment in manufacturing in the southern United States during the Second World War spurred a regional economic boom that lasted into the postwar period. But much of this investment went to specialized plants, many of them unsuitable for postwar production. Large-scale, wartime government funding led to a massive increase in the number and scale of munitions facilities. By the war’s end, 216 munitions establishment costing more than $3.5 billion had been built, many of them located in the south. Indeed, according to one estimate, more than 70 percent of federally financed manufacturing construction capital in Alabama, Arkansas, Mississippi, and Tennessee went into munitions plants. Even in the northern regions with strong prewar manufacturing economics, these plants were difficult to deal with once the imperative of war had been removed. In the south few industrialists had the capacity or desire to transform these factories to a peacetime function. Accordingly, at war’s end almost all of the southern munitions facilities were shut down, placed on standby, operated at a very low capacity, or converted to nonmanufacturing functions, usually storage. Although some reopened a few years later for use during the Korean War, the impact of the special plants on the South’s postwar economy was marginal at best. 结构分析 文章开头 由文章的第一句中 &quot;many scholars have argued that...&quot; 可知该句为引用观点, 故该文章很有可能是一个质疑型的文章. 首句指出: 很多学者认为, 二战期间, 政府对美国南方在工业方面的投资刺激了经济的发展, 并持续到了战后. 这一句所包含的信息量很大, 作者可以质疑很多方面, 比如, 作者可以质疑投资是否真的能刺激经济发展, 也可以质疑这种发展能否持续到战后. 所以文章的方向目前为止还不甚明朗, 需要继续阅读. 接下来出现了 but, 表示作者开始了自己的质疑. 作者指出, 这些受益的工厂有很多都是特殊的工厂, 不适合于战后的情形. 至此, 作者的态度已经比较明朗, 就是在质疑经济的发展能否持续到战后的问题. 目前为止文章的内容框架已经可以概括为: 很多学者认为, 二战期间, 政府对美国南方在工业方面的投资刺激了经济的发展, 并持续到了战后. 但由于这些工厂的特殊性, 这种经济的发展不能持续到战后. 后文展开 接下来的 Large-scale... 一句, 行文的方向显然没有发生变化, 于是这句话不会与作者的观点产生冲突, 也不会产生新的信息. 本句谈到的信息为政府把钱投资给了军工厂, 那么这个信息一定是旧信息, 那么前文提到的&quot;特殊的&quot;工厂指的也就应该是军工厂了. 下一句 By the war's end... 也是在谈政府为军工厂投资的事情, 仍然没有新信息出现. 随后是 Indeed 引导的句子, 可知该句话中行文的方向不发生变化, 于是其内容仍然不会脱离框架所的涉指范围. 结合语义, 可知本句仍在谈论投资对象的问题. 第二段 在第二段的开头提到了北方的情况(可以出题考为什么在此处提到北方的情况), 指出这些战后的军工厂在北方同样难以处理. 那么作者为什么要在此处提及北方的情况呢? 显然南方才是全文的重点, 整个文章都应该是围绕着南方展开的. 所以显然这个北方的情况也是服务于南方的, 实际上是在表明 &quot;连北方的都难以处理, 更不用说南方的情况了, 一定更糟糕&quot;. 所以此处提及北方的情况, 实际上仍然是在为作者自己得观点所服务. 接下来讨论回到了南方, 指出几乎没有人愿意处理南方的军工厂, 仍然在强调战后军工厂的副作用. 接下来的 Accordingly... 一句, 更是直接指出了, 在战后, 几乎所有的军工厂都废掉了. 在下文出现了 although 一词, 显然是一个让步. 故前半句应该是一个小小的妥协, 后半句仍然回到自己的观点. 故此处在读句子之前就完全可以猜出这句话的意思是&quot;尽管有些军工厂还没有废掉, 但是它们也废掉了&quot;. 至此, 整篇文章的内容已经结束. 整体结构 文章比较长, 但最核心的其实只有两句话: Many scholars have argued that government investment in manufacturing in the southern United States during the Second World War spurred a regional economic boom that lasted into the postwar period. But much of this investment went to specialized plants, many of them unsuitable for postwar production. 许多学者认为经济发展能够持续至战后, 但是并不能. 问题分析 问题一 文章的问题是针对 Indeed, according to one estimate, more than 70 percent of federally financed manufacturing construction capital in Alabama, Arkansas, Mississippi, and Tennessee went into munitions plants 一句提出的, 该句是对上文观点的展开, 故功能应该是支持前文的观点. 事实上, 原题目如下: In the passage, the mention of “Alabama, Arkansas, Mississippi, and Tennessee” serves primarily to A. suggest that some states were better than others at anticipating postwar economic needs B. identify evidence used to support a view held by scholars mentioned at the beginning of the passage C. suggest that federal investment in some kinds of manufacturing was excessive D. identify the states that received the largest allocations of federal funds E. provide information to support a point about the nature of government investment made earlier in the paragraph 根据以上分析, 本题应选择 E.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>GRE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GRE阅读题目分析[1]]]></title>
    <url>%2F2017%2F07%2F16%2FGRE%E9%98%85%E8%AF%BB%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%5B1%5D%2F</url>
    <content type="text"><![CDATA[GRE 阅读的一点小小的总结. 文章内容 In 1755 British writer Samuel Johnson published an acerbic letter to Lord Chesterfield rebuking his patron for neglecting and declining further support. Johnson’s rejection of his patron’s belated assistance has often been identified as a key moment in the history of publishing, marking the end of the culture of patronage. However, patronage had been in decline for 50 years, yet would survive, in attenuated form, for another 50. Indeed, Johnson was in 1762 awarded a pension by the Crown — a subtle form of sponsorship, tantamount to state patronage. The importance of Johnson’s letter is not so much historical as emotional; it would become a touchstone for all who repudiated patrons and for all who embraced the laws of the marketplace. 结构分析 文章开头 文章前两句指出, 有观点认为: &quot;SJ 喷 LC 的事件标志着 patronage 的结束&quot;. 随后文中出现 However, 由于前文是引用观点, 故 However 可能起到质疑的作用, 于是本句的核心方向应该是 &quot;partonage 并没有结束&quot;. 后文中又出现了一个 yet, 表明该句中存在让步, 于是前半句应是对于引用观点的妥协, 结合语义, 可理解为 &quot;partonage 虽然在变弱&quot;. 后半句显然与引用观点意思相反, 应为 &quot;partonage 还没有结束&quot;. 到这里, 文章已经抛出了一个观点, 文章的大概走势是: 有人认为 SJ 喷 LC 的事件标志着 patronage 的结束, 但实际上, 尽管 patronage 削弱了, 却没有结束. 按照常理, 下文应该对作者自己的观点进行展开. 后文展开 下文首先出现的是 indeed, 考虑语义, indeed 意为&quot;确实&quot;, 不改变文章的观点方向, 故下文的意思仍应该是&quot;partonage 没有结束&quot;, 结合 &quot;tantamount to state patronage&quot;, 可知该句确实表明了类似的意思. 最后一句仍然是作者自己观点的展开, &quot;not so much ... as ...&quot; 指出 SJ 喷 LC 的事件, 在 emotional 方面的重要性要大于 historical 方面的重要性, 实际上也是在说这件事不能标志着 patronage 的结束. 整体结构 总体看来, 这篇文章的核心意思就是上文提到的走势, 而核心的两句话就是: Johnson’s rejection of his patron’s belated assistance has often been identified as a key moment in the history of publishing, marking the end of the culture of patronage. However, patronage had been in decline for 50 years, yet would survive, in attenuated form, for another 50. 许多人认为 SJ 喷 LC 标志着 patronage 的结束, 但实际上并没有. 问题分析 问题一 首先从加粗句出发考虑, 涉及到的就是 however 的功能. 由以上的分析, 该句的功能为质疑前文的引用观点, 故可以如下设计正确选项: Present a view that chanllenges a understanding of Johnson’s rejection of his patron’s belated assistance. Outline an opposing interpretation of Johnson’s rejection of his patron’s belated assistance. Qualify the declaration that Johnson’s rejection was the end of patronage. ...... 事实上, 原题目如下: Which of the following best describes the function of the highlighted sentence in the context of the passage as a whole? A. It points out the most obvious implications of Johnson’s letter to his patron B. It suggests a motivation for Johnson’s rejection of Chesterfield’s patronage C. It provides information that qualifies the assertion that Johnson’s letter sharply defined the end of a publishing era D. It provides a possible defense for Chesterfield’s alleged neglect of Johnson E. It refutes the notion that patrons are found primarily among the nobility 根据以上分析, 本题应选择 C. 问题二 文章的另一道题目是针对 1762 的事件 (Indeed, Johnson was in 1762 awarded a pension by the Crown — a subtle form of sponsorship, tantamount to state patronage) 提出的. 这句话是对作者自己观点的展开, 所以从功能上来就是对自己观点的加强, 很容易设计出如下的正确选项: Support that Johnson’s rejection was not the end of patronage. 原题目如下: The author of the passage mentions Johnson’s 1762 pension award in order to A：Reveal that Johnson remained consistent in his rebuke of Lord Chesterfield well after 1755 B：Provide evidence for a general trend in the later half of the eighteenth century of private patronage’s being replaced by state sponsorship C：Situated the debate over the end of patronage within the wider realm of eighteenth-century economic history D：Suggest that Johnson’s letter to Chesterfield was noticed by the crown only years after it was published E：Emphasize that patronage still helped support Johnson’s writing after his letter to chesterfield 根据以上分析, 本题最合适的选项应为 E 选项. 值得注意的是 C 选项中 debate 一词的使用. Debate 的存在必然是有两派对立的引用观点, 否则不足以构成 debate. 注意作者观点与引用观点的对立并不算做 debate, 因为从作者的角度出发, 自己的观点一定是正确的, 不存在争论的必要.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>GRE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北京师范大学数学分析试卷]]></title>
    <url>%2F2017%2F07%2F04%2FBNU-Mathematical-Analysis-Exam%2F</url>
    <content type="text"><![CDATA[2015秋 数学分析一 期末 唐仲伟 2016秋 数学分析三 期中 唐仲伟 2016秋 数学分析三 期末 唐仲伟 2015 数学分析一 期末 唐仲伟 计算题 共40分, 每题5分. 求极限 \(\lim\limits_{n\to\infty}\sqrt{n}(\sqrt{n+1}-\sqrt{n})\); 求极限 \(\lim\limits_{x\to\infty}\sqrt{(a+x)(b+x)}-\sqrt{(a-x)(b-x)}\); 求不定积分 \(\int e^{\sqrt{x}}dx\); 求不定积分 \(\int \frac{1}{1+x^4}dx\); 求广义积分 \(\int\nolimits_0^1 lnxdx\); 求广义积分 \(\int\nolimits_0^{+\infty}\frac{dx}{1+x^3}\); 求二重积分 \(\iint\nolimits_D [x+y]dxdy\), 其中 \(D=[0,2]\times[0,2]\), \([x+y]\) 是取整函数; 设二阶偏导数连续的二元函数 \(z=f(x,y)\) 满足方程 \[\frac{\partial^2 f}{\partial x^2}(x,y)-\frac{\partial^2 f}{\partial y^2}(x,y)=0\] 且 \(f(x,2x)=x\), \(\frac{\partial f}{\partial x}(x,y)\) 当 \(y=2x\) 时等于 \(x^2\). 求 \(\frac{\partial^2 f}{\partial x^2}(x,y)\) 当 \(y=2x\) 时的值. 证明题 共60分, 每题10分. 求证数列 \(x_n=(-1)^n\) 当 \(n\to\infty\) 时发散; 设 \(f,g\) 在闭区间 \([a,b]\) 连续, 证明 \[\int\nolimits_a^b f(x)g(x)dx\leqslant\frac{1}{2}\left[\int\nolimits_a^bf^2(x)dx+\int\nolimits_a^bg^2(x)dx\right];\] 设广义积分 \(\int\nolimits_0^{+\infty}\frac{\sin^2 x}{x^2}dx\) 和 \(\int\nolimits_0^{+\infty}\frac{\sin x}{x}dx\) 都收敛, 证明: \[\int\nolimits_0^{+\infty}\frac{\sin^2 x}{x^2}dx=\int\nolimits_0^{+\infty}\frac{\sin x}{x}dx;\] 设 \[f(x,y)=\begin{cases} \frac{xy}{x^2+y^2}, &amp; (x,y)\neq(0,0), \\ 0, &amp; (x,y)=(0,0). \\ \end{cases}\] 设函数 \(f(x)\) 在 \(x=0\) 连续, 且 \(\lim\limits_{x\to\infty}\frac{f(2x)-f(x)}{x}=a\). 求证: \(f&#39;(0)\) 存在, 且 \(f&#39;(0)=a\). 设 \[P_n(x)=\frac{1}{n!2^n}\frac{d^n}{dx^n}(x^2-1)^n,\] 证明: \[\int\nolimits_{-1}^1 P_n(x)P_m(x)dx = \begin{cases} 0, &amp; m\neq n,\\ \frac{2}{2n+1}, &amp; m=n. \\ \end{cases}\] 2016秋 数学分析三 期中 唐仲伟 计算题 共50分, 前4题每题5分, 后3题每题10分. \(\lim\limits_{(x,y)\to(0,0)}\frac{\sin(xy)}{xy}\). \(\lim\limits_{(x,y)\to(0,0)}(x+y)\sin\frac{1}{x^2+y^2}\). \(\lim\limits_{x\to\infty}\lim\limits_{y\to\infty}\frac{xy}{x+y}\). \(\lim\limits_{(x,y)\to(+\infty,+\infty)}\left(\frac{xy}{x^2+y^2}\right)^{x^2}\). 设 \(f(x,y)=(x+y,x-y,xy)\in\mathbb{R}^3\), \(g(x,y,z)=(xyz,ze^{xy})\in\mathbb{R}^2\). 记 \(F=f\circ g\), 求 \(F\) 的Frechet导数 \(F&#39;(x,y,z)\). 求 \(f(x,y)=x^3+y^3-3xy\) 的普通极值. 设方程 \(y-\frac{1}{2}\sin y=x\) 能确定隐函数 \(y=f(x)\), 令 \(z=e^{x+y}\), 求 \(\frac{dz}{dx}\), \(\frac{d^2z}{dx^2}\). 证明题 共50分, 每题10分. 证明: \(f(x,y)=\frac{xy}{x+y}\) 在 \((x,y)=(0,0)\) 处极限不存在. 设数值函数 \(f(x)\) 在紧集 \(D\subset\mathbb{R}^n\) 上连续, 且恒为正值, 求证: \(\exists~K&gt;0\), s.t. \(\forall~x\in D\), 有 \(f(x)&gt;K\). 证明: \[f(x,y)=\begin{cases}\frac{xy}{\sqrt{x^2+y^2}}, &amp; (x,y)\neq(0,0) \\ 0, &amp; (x,y)=(0,0) \\ \end{cases}\] 在 \((0,0)\) 的邻域中连续且有有界的偏导数 \(f_x&#39;(x,y)\) 和 \(f&#39;_y(x,y)\), 但函数在点 \((0,0)\) 不可微 . 设 \(f:\mathbf{R}^n\rightarrow\mathbf{R}^n\) 是开集 \(G\) 上的 \(C^1\) 类函数, 且 \(J_f(x_0)=0\), 记 \(y_0=f(x_0)\). 如果 \(f\) 在 \(x_0\) 存在反函数 \(f^{-1}\), 求证 \(f^{-1}\) 在 \(y_0\) 不可微. 证明: 由方程 \[y=x\varphi(x)+\psi(z)\] 所定义的隐函数 \(z=z(x,y)\) 满足方程 \[\left(\frac{\partial z}{\partial y}\right)^2\frac{\partial^2 z}{\partial x^2}-2\frac{\partial z}{\partial x}\frac{\partial z}{\partial y}\frac{\partial^2 z}{\partial x\partial y}+\left(\frac{\partial z}{\partial x}\right)^2\frac{\partial^2 z}{\partial y^2}=0.\] 2016秋 数学分析三 期末 唐仲伟 计算题 共20分, 前四题每题5分, 后3题每题10分. 计算二重积分 \(\iint\limits_E xydxdy\), 其中 \(E\) 是四条抛物线 \[y^2=px,~y^2=qx,~x^2=ay,~x^2=by\] 所围成的区域, \(0&lt;p&lt;q\), \(0&lt;a&lt;b\). 计算三重积分 \(\iiint\limits_Vxyzdxdydz\), 其中 \(V\) 是由曲面 \[x^2+y^2+z^2=1,x\geqslant,y\geqslant0,z\geqslant0\] 所围成的区域. 计算第一型曲线积分 \(\int\nolimits_C(x^2+y^2)ds\), 其中 \(C\) 为曲线 \[x=a(\cos t+t\sin t),y=a(\sin t-t\cos t)~(0\leqslant t \leqslant 2\pi).\] 计算第一型曲面积分 \(\iint\limits_S(x+y+z)dS\), 其中 \(S\) 为曲面 \(x^2+y^2+z^2=a^2\), \(z\geqslant0\). 设 \(\sin z-xyz=0\), 当 \(\cos z-xy\neq0\) 时, 求 \(\frac{\partial z}{\partial x}\), \(\frac{\partial^2 z}{\partial y\partial x}\). 求函数 \(f(x,y,z)=x-2y+2z\) 在球面 \(x^2+y^2+z^2=1\) 上的最大、最小值. 计算第二型曲线积分 \(\oint\nolimits_C e^x[(1-\cos y)dx-(y-\sin y)dy]\), 其中 \(C\) 是曲线 \(y=\sin x\) 介于 \([0,1]\) 的一段, \(C\) 的方向对应于 \(x\) 增加的方向. 证明题 共50分, 每题10分. 设二元数值函数 \(f(x,y)\) 在 \([a,b]\times[c,d]\) 上连续, 一元数值函数序列 \(\{\phi_n(x)\}\) 在 \([a,b]\) 上一致收敛, 且 \(\phi_n(x)\in [c,d]\). 则 \(g_n=f(x,\phi_n(x))\) 在 \([a,b]\) 上一致收敛. 设数值函数 \(z=f(x,y)\) 在矩形区域 \(D=[a,b]\times[c,d]\subset\mathbb{R}^2\) 上偏导数有界, 求证: \(f\) 在 \(D\) 上一致连续. 设三重积分 \(\iiint\limits_D f(x,y,z)dxdydz\) 存在, 区域 \(D\) 关于 \(xOy\) 平面对称, 被积函数 \(f\) 关于 \(x\) 是一个奇函数, 即 \(f(-x,y,z)=-f(x,y,z)\), 求证: \(\iiint\limits_D f(x,y,z)dxdydz=0\). 设 \(f\in C[0,a]\), 即 \(f\) 在区间 \([0,1]\) 上连续, 证明: \[\int\nolimits_0^a dx_1\int\nolimits_0^{x_1}dx_2\cdots\int_0^{x_{n-1}} f(x_1)f(x_2)\cdots f(x_n)dx_n=\frac{1}{n!}\left[\int\nolimits_0^a f(x) dx\right]^n.\] 设 \(S\) 为 \(\mathbb{R}^3\) 空间中分片光滑的封闭定向曲面, \(\nu_0\) 为任意固定的方向, \(N\) 为 \(S\) 的单位外法向量, 求证 \[\iint\limits_S \cos(\nu_0, N)dS=0.\] 证明Lebesgue引理: 设 \(\mathbb{R}^n\) 中的紧集 \(D\) 有一个开覆盖 \(\mathfrak{C}=\{G_\alpha\}\), 则存在正数 \(l&gt;0\), 对于 \(\forall~x\in D\), \(\exists~G_\alpha\in\mathfrak{C}\), s.t. \(x\) 的球(方)邻域 \(U(x,l)\subset G_\alpha\).]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>数学</tag>
        <tag>各种试卷</tag>
        <tag>数学分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北京师范大学高等代数试卷]]></title>
    <url>%2F2017%2F07%2F04%2FBNU-Linear-Algebra-Exam%2F</url>
    <content type="text"><![CDATA[2016 高等代数二 期中 刘玉明 2016 高等代数二 期末 刘玉明 2016 高等代数二 期中 刘玉明 以下各题中, 所指的向量空间都是有限的. 假设域 \(F\) 上的2维向量空间 \(V\) 有一组基 \(v_1,v_2\). 设 \(\sigma:V\rightarrow V\) 是一个线性变换, 且满足 \(\sigma(v_1)=0\), \(\sigma(v_2)=v_1\). 证明: 如果 \(W\) 是 \(V\) 的一个 \(\sigma\)-不变子空间, 则或者 \(W=0\), 或者 \(W\) 是由 \(v_1\) 生成的1维子空间, 或者 \(W=V\). 设 \(V\) 是域 \(F\) 上的向量空间, \(W\) 是 \(V\) 的一个子空间. 证明: 存在 \(V\) 的子空间 \(W&#39;\), s.t. \(V=W\oplus W&#39;\). 判断下列域 \(F\) 上的 \(n\) 阶方阵 \(A\) 能否对角化, 并说明理由. \(A\) 满足 \(A\neq 0\), \(A^2=0\). \(A\) 满足 \(A^2=A\). 设 \(\sigma:V\rightarrow V&#39;\) 是一个线性映射. 证明 \(\sigma\) 诱导出向量空间的同构 \[\overline{\sigma}:V/\ker\sigma \xrightarrow{\sim} {\rm Im}\sigma,\quad v+\ker\sigma\mapsto\sigma(v).\] 试用向量组的线性相关性理论证明线性方程组有解的判别准则. 2016 高等代数二 期末 刘玉明 (20分)设 \(\alpha\) 为 \(n\) 维欧氏空间 \(V\) 中的一个单位向量, 定义映射 \[\sigma_\alpha:~V\longrightarrow V,\quad\xi\longmapsto\xi-2(\xi,\alpha)\alpha.\] 证明 \(\sigma_\alpha\) 为一个正交变换. 这样的正交变换称为由 \(\alpha\) 定义的镜面反射. 证明: 存在 \(V\) 的规范正交基, 使得 \(\sigma_\alpha\) 在这组基下的矩阵为: \[\begin{bmatrix}-1 &amp; &amp; &amp; \\ &amp; 1 &amp; &amp; \\ &amp; &amp; \ddots &amp; \\ &amp; &amp; &amp; 1 \\ \end{bmatrix}\] (10分)设 \(A\) 是3阶实对称矩阵，\(A\) 的特征值为0, 3, 3. 已知 \(\xi_1=(1,1,1)^T,~\xi_2=(-1,1,0)^T\) 分别是属于特征值0和3的特征向量. 求属于特征值3的与 \(\xi_2\) 线性无关的另一个特征向量 \(\xi_3\). (20分)设3元实二次型 \[q(x_1,x_2,x_3)=2x_1^2+x_2^2-4x_1x_2-4x_2x_3.\] 求 \(q\) 的秩和正惯性指数. 求一个正交替换，将 \(q\) 化为典范形. (20分)设矩阵 \[A=\begin{bmatrix}2 &amp; 0 &amp; 0 \\ 0 &amp; 2 &amp; 0 \\ 1 &amp; 0 &amp; 2 \\ \end{bmatrix}\] 分别求 \(A\) 的特征多项式和最小多项式. 矩阵 \(A\) 能否对角化？如不能, 求出它的若尔当标准型. (15分)设 \(q(x_1,x_2,\cdots,x_n)=x^TAx\) 是一实二次型, 其中 \(A=(a_{ij})\) 是 \(n\) 阶实对称矩阵. 设 \(\lambda\) 与 \(\mu\) 分别是 \(A\) 的最大与最小特征值. 证明: 对于 \(\mathbf{R}^n\) 中任一列向量 \(\alpha\), 有 \[\mu|\alpha|^2\leqslant\alpha^TA\alpha\leqslant\lambda|\alpha|^2.\] (15分)证明: 如果 \(A\) 和 \(B\) 都是 \(n\) 阶实对称矩阵, 并且 \(A\) 正定, 那么存在 \(n\) 阶实可逆矩阵 \(P\), 使得 \(P^TAP\) 和 \(P^TBP\) 都是对角矩阵. 简略解答 一定记得先验证它是一个线性变换, 再验证其正交性, 否则会丢掉4分. 早就不记得了, 其余全略.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>数学</tag>
        <tag>各种试卷</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北京师范大学近世代数试卷]]></title>
    <url>%2F2017%2F07%2F03%2FBNU-Abstract-Algebra-Exam%2F</url>
    <content type="text"><![CDATA[2015 期末试题 刘玉明 2016 期中试题 胡维 刘玉明 2016 期末试题 胡维 刘玉明 2015 期末试题 刘玉明 (20分) \(\mathbb{Z}_n=\{[0],[1],\cdots,[n-1]\}\) 表示模 \(n\) 的剩余类加群. 写出 \(\mathbb{Z}_4\) 的加法运算表. 写出 \(\mathbb{Z}_6\) 的所有子群. \(\mathbb{Z}_7\) 有几个子群? \(\mathbb{Z}_{28}\) 有几个 \(7\) 阶元? (20分) \(\mathbb{Z}_n^*=\{[a]\in\mathbb{Z}_n~|~a~与~n~互素\}\). 证明: \(\mathbb{Z}_n^*\) 关于乘法 \([a][b]=[ab]\) 构成一个阿贝尔群. 求 \([3]\) 在 \(\mathbb{Z}_8^*\) 以及 \([5]\) 在 \(\mathbb{Z}_{13}^*\) 中的逆元. (15分) 用 \(S_5\) 表示 \(5\) 次对称群. \(\sigma=(12345)\) 是 \(S_5\) 中的几阶元? \(S_5\) 中与 \(\sigma\) 共轭的元素有几个? 写出循环群 \(\langle\sigma\rangle\) 中的所有元素. \(\langle\sigma\rangle\) 是不是 \(S_5\) 的正规子群? (20分) 写出整数环 \(\mathbb{Z}\) 的所有极大理想. 写出模 \(18\) 的剩余类环 \(\mathbb{Z}_{18}\) 的所有极大理想. \(x^2+1\) 是否是 \(\mathbb{Z}_3[x]\) 中的不可约多项式? \(\mathbb{Z}_3[x]/\langle x^2+1\rangle\) 是怎样的环? (15分) 用 \(R\) 表示环 \(\mathbb{Z}[i]/\langle 1+3i \rangle\), 其中 \(\mathbb{Z}[i]\) 表示高斯整环, 证明: 在 \(R\) 中, \([i]=[3]\), \([10]=[0]\), \([a+bi]=[a+3b]\), \(\forall a, b\in\mathbb{Z}\). \(\varphi:\mathbb{Z}\to R~(a\mapsto [a])\) 是环的满同态. \(\ker\varphi=10\mathbb{Z}\). 从而 \(R=\mathbb{Z}_{10}\). (10分) 设 \(E=F(\alpha)\) 是域 \(F\) 的单超越扩域, \(\beta\in E\backslash F\). 证明: \(\alpha\) 是 \(F(\beta)\) 上的代数元. 证明或否定一下命题: 设 \(E/F\) 是域扩张, \(\alpha\in E\), \(m,n\in\mathbb{Z}^+\). 如果 \(\alpha\) 是 \(F\) 上 \(n\) 次代数元, 且 \(m\) 与 \(n\) 互素, 那么 \(\alpha^m\) 也是 \(F\) 上的 \(n\) 次代数元, 且 \(F(\alpha^m)=F(\alpha)\). 2016 期中试题 胡维 刘玉明 (10分) 用 \(S_4\) 代表4次对称群. 按共轭类写出 \(S_4\) 的全部元素. (10分) 循环群 \(\mathbb{Z}_{28}\) 中的7阶元有几个? \(\mathbb{Z}_{28}\) 有几个7阶子群? (15分) 令 \(\varphi:(\mathbb{R},+)\longrightarrow (\mathbb{C}^\times,\cdot)\) 是由 \(\varphi(x)=e^{ix}\) 定义的函数, 其中 \((\mathbb{R},+)\) 和 \((\mathbb{C}^\times,+)\) 分别代表实数的加法群和非零复数的乘法群. 证明: \(\varphi\) 是一个群同态. 求 \(\ker\varphi\) 和 \({\rm Im}~\varphi\). 根据同态基本定理, 你能得到什么结论? (15分) 应用群作用证明: 8阶群的中心至少有两个元素. (10分) 求下列环中的(乘法)可逆元: 模8的剩余类环 \(\mathbb{Z}/8\mathbb{Z}\). 高斯整环 \(\mathbb{Z}[i]\). (20分) \(\mathbb{Z}_{10}\) 与 \(\mathbb{Z}_2\times\mathbb{Z}_5\) 作为环同构吗? 为什么? \(\mathbb{Z}_9\) 与 \(\mathbb{Z}_3\times\mathbb{Z}_3\) 作为环同构吗? 为什么? (20分) 利用环的同态基本定理证明: \(\mathbb{Z}[x]/\langle x^2+1\rangle\cong\mathbb{Z}[i]\). \(\langle x^2+1 \rangle\) 是 \(\mathbb{Z}[i]\) 的素理想吗? 是极大理想吗? 2016 期末试题 胡维 刘玉明 (20分) 整数集 \(\mathbb{Z}\) 关于普通加法构成有理数集 \(\mathbb{Q}\) 的子群. 任取 \(q\in\mathbb{Q}\), 用 \([q]=q+\mathbb{Z}\) 表示商群 \(\mathbb{Q}/\mathbb{Z}\) 中对应的元素. 写出商群 \(\mathbb{Q}/\mathbb{Z}\) 的单位元. 求元素 \([\frac{9}{4}]\) 在群 \(\mathbb{Q}/\mathbb{Z}\) 的阶. 证明: 群 \(\mathbb{Q}/\mathbb{Z}\) 中每个元素的阶都有限. \(\mathbb{Q}/\mathbb{Z}\) 是不是循环群? 为什么? (15分) 下列三个群互相同构吗? 说明理由. 其中, \(A_4\) 代表4次交错群, \(\mathbb{Z}_{12}\) 代表模12的剩余类加群, 等等. \(\mathbb{Z}_{12}\). \(\mathbb{Z}_3\times\mathbb{Z}_4\). (群的外直积) \(A_4\). (10分) 设 \(G\) 是一个群, 任取 \(x\in G\), 称 \(C_x=\{gxg^{-1}|g\in G\}\) 为元素 \(x\) 所在的共轭类. 每个共轭类 \(C_x\) 中所含元素的个数一定整除群的阶 \(|G|\), 为什么? (20分) 令 \(\mathbb{Z}[i]=\{a+bi|a,b\in\mathbb{Z}\}\) 代表高斯整环. 在 \(\mathbb{Z}[i]\) 中定义范数如下: \[N(a+bi)=a^2+b^2.\] 求出 \(\mathbb{Z}[i]\) 中的所有单位 (即乘法可逆元). 求出 \(\mathbb{Z}[i]\) 的商域. 素数2是 \(\mathbb{Z}[i]\) 中的逆元吗? 为什么? 有人说, \(\mathbb{Z}[i]\) 中的非零素理想也是极大理想. 你认为对吗? 为什么? (10分) 设 \(E=\mathbb{Q}(\sqrt{2},i)\) 是有理数域 \(\mathbb{Q}\) 的扩域. 求扩域的次数 \([E:\mathbb{Q}]\). 证明: \(E=\mathbb{Q}(\sqrt{2}+i)\). (20分) 考虑有限域 \(\mathbb{Z}_3\) 上的不可约多项式 \(p(x)=x^2+x-1\). 设 \(\alpha\) 是 \(p(x)\) 在它的分裂域中的一个根. 单扩域 \(\mathbb{Z}_3(\alpha)\) 是 \(\mathbb{Z}_3\) 上的几次扩域? 写出 \(\mathbb{Z}_3(\alpha)\)作为 \(\mathbb{Z}_3\) 上的向量空间的一组基. 用这组基表达 \(\alpha\) 和 \(1+\alpha\) 在 \(\mathbb{Z}_3(\alpha)\) 中的逆元. 证明: \(p(x)\) 整除 \(x^9-x\) (在 \(\mathbb{Z}_3[x]\) 中). (5分) 考虑81元域 \(F\) 的非零元乘法群 \(F^\times\). 设 \(\alpha\) 是 \(F^\times\) 的生成元. 证明: \(\alpha^{40}=-1\).]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>数学</tag>
        <tag>抽象代数</tag>
        <tag>各种试卷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北京师范大学实变函数试卷]]></title>
    <url>%2F2017%2F07%2F02%2FBNU-Real-Analysis-Exam%2F</url>
    <content type="text"><![CDATA[2016-2017学年第二学期期中考试 李俊峰 2016-2017学年第二学期期中考试 李俊峰 (15分) 设 \(\{E_k\}\) 是 \([0,1]\) 中的可测集列, \(m(E_k)=1~(k=1,2,\cdots)\), 试证明 \[m\left(\bigcap_{k=1}^\infty E_k\right)=1.\] (15分) 试证明点集 \(E\) 可测的充分必要条件是: 对于任给的 \(\epsilon&gt;0\), 存在开集 \(G_1,G_2\): \[G_1\supset E,\quad G_2\supset E^C\] 使得 \(m(G_1\cap G_2)&lt;\epsilon\). (15分) 设 \(E\subset \mathbb{R}\) 上可测函数列 \(\{f_k(x)\}\) 满足 \[f_k(x)\geqslant f_{k+1}(x),(k=1,2,\cdots).\] 若 \(f_k\) 在 \(E\) 上依测度收敛到0, 试问 \(f_k\) 在 \(E\) 上是否几乎处处收敛到0. (15分) 设 \(f(x)\) 是 \((0,1)\) 上的非负可测函数, 若存在 \(c\) 使得 \[\int\nolimits_{[0,1]}[f(x)]^ndx=c,(n=1,2,\cdots)\] 试证明存在非负可测集 \(E\subset(0,1)\), s.t. \(f(x)=\chi_E(x)\), a.e. 若 \(f(x)\) 不是非负的, 结论又如何? (15分) 设 \(f\in L(0,a)\), \(g(x)=\int\nolimits_x^a \frac{f(t)}{t}dt\), \(a&gt;x&gt;0\). 试证明 \(g\in L(0,a)\), 且有 \[\int\nolimits_0^a g(x)dx=\int\nolimits_0^a f(x)dx.\] (15分) 设 \(f\in L^2(0,\infty)\), 且 \(f\geqslant 0\). 设 \(F(x)=\int\nolimits_0^x f(t)dt\), 试证明 \[F(x)=o(\sqrt{x})~(x\to0,x\to\infty).\] (10分) 设 \(f\in L^1(\mathbb{R}^n)\), 对 \(x\in\mathbb{R}^n\), 称 \[\hat{f}(x)=\int\nolimits_{\mathbb{R}^n} f(t)e^{-2\pi x\cdot t}dx\] 为 \(f\) 的Fourier变换. 请验证以下几个性质: \(||\hat{f}||_{L^\infty(\mathbb{R}^n)}\leqslant ||f||_{L^1(\mathbb{R}^n)}\). \(\hat{f}\) 在 \(\mathbb{R}^n\) 上一致连续. \(\lim\limits_{|x|\to\infty}\hat{f}(x)=0\). (提示: 计算阶梯函数的Fourier变换, 再应用阶梯函数在 \(L^1(\mathbb{R}^n)\) 的稠密性). 记号说明: \(x,t\in\mathbb{R}^n\), 那么 \(x\cdot t=x_1t_1+x_2t_2+\cdots+x_nt_n\). 欧拉公式: \[e^{i\theta}=\cos\theta+i\sin\theta.\]]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>数学</tag>
        <tag>各种试卷</tag>
        <tag>实变函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合数学复习重点]]></title>
    <url>%2F2017%2F06%2F24%2F%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9%2F</url>
    <content type="text"><![CDATA[第二章 抽屉原理 吧 \(n+1\) 个物体放入 \(n\) 个抽屉, 则至少存在一个抽屉里面有至少两个物体. 第三章 排列组合 重集的排列 \(k\) 种元素, 个数无限: \(r\)-排列数为 \(k^r\). \(k\) 种元素, 第 \(i\) 种有 \(n_i\) 个: 全排列为 \(\frac{(n_1+\cdots+n_k)!}{n_1!\cdots n_k!}\). 重集的组合 \(x_1+\cdots+x_k=r\) 的非负整数解个数为 \(\binom{r+k-1}{r}\). 第四章 二项式系数 组合恒等式 (帕斯卡公式): \(\binom{\alpha}{k}=\binom{\alpha-1}{k}+\binom{\alpha-1}{k-1}\); \(\binom{\alpha}{k}\binom{k}{p}=\binom{\alpha}{p}\binom{\alpha-p}{k-p}=\binom{\alpha}{k-p}\binom{\alpha+p-k}{p}\); \(\binom{\alpha+k}{p+k}\binom{p+k}{k}=\binom{\alpha+k}{k}\binom{\alpha}{p}\); \(\sum\limits_{k=0}^n\binom{n}{k}=\sum\limits_k\binom{n}{k}=2^n\); \(\sum\limits_{k=0}^n(-1)^k\binom{\alpha}{k}=(-1)^m\binom{\alpha-1}{m}\); \(\sum\limits_{k=0}^n\binom{\alpha}{k}\binom{\beta}{n-k}=\binom{\alpha+\beta}{n}\); \(\sum\limits_{k=0}^n\binom{\alpha+k}{k}\binom{\beta-k}{n-k}=\binom{\alpha+\beta+1}{n}\). 第五章 容斥原理 符号说明 \(A_i\): \(S\) 中满足性质 \(P_i\) 的元素集合; \(N(i)\): \(S\) 中恰好具有 \(i\) 个性质的元素集合; \(L(i)\): \(S\) 中至少具有 \(i\) 个性质的元素集合; \(W(i)\): \(A_1,\cdots,A_m\) 中所有 \(i\) 个交集的元素个数之和. 容斥原理 \(N(0)=W(0)-W(1)+W(2)-\cdots+(-1)^mW(m)\); \(L(1)=|S|-N(0)=W(1)-W(2)+W(3)-\cdots+(-1)^{m-1}W(m)\). 重集的组合 求方程 \(x_1+\cdots+x_n=r\) 带上下界 \((a_i\leqslant x_i\leqslant b_i)\) 的整数解个数. 解答: 先做变换 \(y_i=x_i-a_i\), 则方程变形为 \(y_1+\cdots+y_n=r-a_1-\cdots-a_n\). 记 \(y_i\leqslant b_i-a_i\) 为条件 \(P_i\), 用容斥原理即可. 错位排列与禁位排列 错位排列 递推: \(D_n=(n-1)(D_{n-1}+D_{n-2})\), \(D_1=0\), \(D_2=1\); 通项: \(D_n=n!\cdot\left(1-\frac{1}{1!}+\frac{1}{2!}-\cdots+\frac{1}{n!}\right)\). 禁位排列 递推: \(Q_n=(n-1)Q_{n-1}+(n-2)Q_{n-2}\); 组合证明: 考虑去掉 \(n\) 的情况, 若前 \(n-1\) 项本身就能构成禁位排列, 则只需要 \(n\) 不在 \(n-1\) 后即可, 方案数 \((n-1)Q_{n-1}\); 若前 \(n-1\) 项本身不能构成禁位排列, 则只能有一个 \(i\) 使得 \(a_{i+1}=a_i+1\), 则此时 \(n\) 只能放在此处, 考虑到 \(i\) 有 \(n-2\) 种选择, 并且去掉 \(i+1\) 后, 序列构成长度为 \(n-2\) 的禁位排列, 此时方案数为 \((n-2)Q_{n-2}\), 得证. 第六章 递推关系与生产函数 递推关系 线性 齐次 常系数 \(h_n-a_1h_{n-1}-\cdots-a_kh_{n-k}=0\) 的特征方程为 \(q_k-a_1q_{k-1}-\cdots-a_k=0\) 若特征方程有 \(k\) 个单根, 则通解为 \(h_n=C_1q_1^n+\cdots+C_kq_k^n\); 若 \(q_i\) 的重数为 \(s_i\), 则通解为 \(n^jq_i,~0\leqslant j\leqslant s_i,~1\leqslant i\leqslant k\) 的线性组合. 非齐次 求一个特解, 然后求齐次方程的通解. 设 \(f(n)=D_r(n)q^n\), \(D_r\) 为 \(r\) 次多项式, 则有特解 \[h(n)=n^sF_r(n)q^n\] 其中 \(F_r\) 为多项式, \(s\) 是 \(q\) 的重数. 生成函数 生成函数: \(h(x)=\sum\limits_{n=0}^\infty h_nx^n\). 若递推式为 \(h_n+a_1h_{n-1}+\cdots+a_kh_{n-k}=0\), 则其生成函数为 \[h(x)=\frac{b_0+b_1x+\cdots+b_{k-1}x^{k-1}}{1+a_1x+\cdots+a_kx^k}.\] 其中 \(b_n=\sum\limits_{i=0}^n a_ih_{n-i}\), \(a_0=1\). 第八章 二分图匹配 最大匹配 找 \(M\)-交错链, 标记算法求最大匹配. König定理: 最大匹配 \(=\) 最小点覆盖. \(p\)-正则: 每个点度都是 \(p\). 完美匹配: 若二分图 \(G\) 满足 \(|X|=|Y|=n\), 且一个匹配含 \(n\) 条边, 则称其为完美匹配. 定理: \(p\geqslant 1\) 的 \(p\)-正则二分图一定有完美匹配. 稳定匹配 延迟认可算法. 定理: 由延迟认可算法得到的匹配是稳定匹配. 第九章 组合设计 \(p^k\) 元域的构造 取 \(\mathbb{Z}_p\) 的 \(k\) 次不可约多项式 \(f\), 令其 \(k\) 个根为 \(a_1,\cdots,a_k\), 则 \(\mathbb{Z}_p\) 的 \(k\) 次扩张 \(\mathbb{Z}_p(a_1,\cdots,a_k)\) 即为 \(p^k\) 元域. 区组设计 BIBD 的性质 每一组含 \(k\) 个元素; 每一对都恰好出现在 \(\lambda\) 个区组中, 则为平衡区组设计(Balanced); \(k&lt;v\), 不完全(Incomplete); 定理: BIBD 中, \(r(k-1)=\lambda(v-1)\). 可利用包含 \(x_i\) 的元素对的个数来组合证明. 定理: BIBD 中, \(bk=vr\). 可利用 BIBD 的关联矩阵中 \(1\) 的个数来组合证明. 定理: BIBD 中, \(b\geqslant v\). \(b=v\) 时称为 SBIBD (symmetric). 符号说明 \(b\): 区组的个数; \(v\): 集合元素总数; \(k\): 每个区组中的元素个数; \(r\): 包含任何一个特定元素的不同区组的个数; \(\lambda\): 包含任何一对特定元素的不同区组的个数. SBIBD 的构造 定理: 若 \(B\) 是 \(\mathbb{Z}_v\) 的差分集, 则 \(B\) 生成的区组构成一个指标为 \(\lambda=\frac{k(k-1)}{v-1}\) 的 SBIBD. 如 \(\mathbb{Z}_7\) 中取 \(B=\{0,1,3\}\), 则 \[ \begin{align} B+0 &amp;=\{0,1,3\}, \\ B+1 &amp;=\{1,2,4\}, \\ B+2 &amp;=\{2,3,5\}, \\ B+3 &amp;=\{3,4,6\}, \\ B+4 &amp;=\{4,5,0\}, \\ B+5 &amp;=\{5,6,1\}, \\ B+6 &amp;=\{6,0,2\}, \\ \end{align} \] 构成一个 \(b=v=7,~k=r=3,~\lambda=1\) SBIBD. Steiner三元系统 定理: STS 中, \(r=\frac{\lambda(v-1)}{2},~b=\frac{\lambda v(v-1)}{6}\). 一个 \(v=9,~\lambda=1\) 的 STS: \[ \begin{align} &amp;\{0,1,2\},\{3,4,5\},\{6,7,8\}, \\ &amp;\{0,3,6\},\{1,4,7\},\{2,5,8\}, \\ &amp;\{0,4,8\},\{1,5,6\},\{2,3,7\}, \\ &amp;\{0,5,7\},\{1,3,8\},\{2,4,6\}. \\ \end{align} \] 拉丁方 \(n\) 阶拉丁方: 由 \(n\) 个元素构成的 \(n\times n\) 方阵, 每行每列都包含了所有 \(n\) 个元素. 定理: \((r,n)=1\), 则 \(a_{ij}=r\times i+j\) 构成 \(\mathbb{Z}_n\) 的拉丁方, 记作 \(\mathbf{L}_n^r\). 正交拉丁方 将两个 \(n\) 阶拉丁方对应位置的元素组成二元有序组, 可以构成一个新的 \(n\) 阶方阵. 如果该方阵中, \((0,0)\sim (n-1,n-1)\) 都恰好出现一次, 则称这两个拉丁方正交. 称两两正交的拉丁方为MOLS. 第一行为 \(0,\cdots,n-1\) 的MOLS由如下定理给出: 定理: 设 \(F\) 是一个 \(n=p^k\) 元域, 其中元素为 \(f_i\), 则 \(a_{ij}=r\times a_i+a_j\) 为拉丁方, \(\forall~r\neq 0\in F\), 记作 \(\mathbf{L}_n^r\). 当 \(r\) 取遍所有 \(F\) 中非零值时, 可以得到 \(n-1\) 个两两正交的拉丁方.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>数学</tag>
        <tag>组合数学</tag>
        <tag>期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微分几何复习重点]]></title>
    <url>%2F2017%2F06%2F23%2F%E5%BE%AE%E5%88%86%E5%87%A0%E4%BD%95%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9%2F</url>
    <content type="text"><![CDATA[重要的定义 正则曲线 给定参数曲线 \(C:r=r(t),~t\in(a,b)\). 若 \(r&#39;(t)\neq 0\) 对于 \(\forall~t\) 成立, 则称 \(C\) 为正则曲线. 曲线的容许参数变换 给定正则曲线 \(C:r=r(t)\), 若参数变换 \(t=t(u)\) 满足 \(t(u)\) 是 \(C^3\) 阶的; \(t&#39;(u)\) 处处非零, 则称之为容许的参数变换. 当 \(t&#39;(u)&gt;0\) 时称为保向的, \(t&#39;(u)&lt;0\) 时称为反向的. 曲率向量 正则曲线 \(C:r=r(t)\) 的单位切向量场 \(T(t(s))\) 关于弧长 \(s\) 的导向量 \(\frac{dT}{ds}=\frac{d^2r}{ds^2}\) 称为曲线 \(C\) 在 \(r(t(s))\) 处的曲率向量; 曲率向量的模长 \(\kappa=|\frac{dT}{ds}|\) 称为 \(C\) 在 \(r(t(s))\) 处的曲率. 相对曲率 给定二阶连续可微的弧长参数化平面曲线 \(C:r=r(s)=(x(s),y(s))\), 局部可取到切向角 \({\rm Arctan}\frac{y&#39;}{x&#39;}\) 的可微单值支, 定义其对 \(s\) 的导数 \(\kappa_r=\theta&#39;(s)\) 为相对曲率. 正则曲面 给定参数曲面 \(S:r=r(u,v),~(u,v)\in U\). 若处处有 \(r_u(u,v)\times r_v(u,v)\neq 0\), 则称 \(S\) 为正则曲面. 曲面的容许参数变换 给定正则曲面 \(S:r=r(u,v)\), 若参数变换 \((u,v)=(u(x,y),v(x,y))\) 满足: 是连续可微的一一对应; Jacobi 行列式 \(\frac{\partial(u,v)}{\partial(x,y)}\) 处处非零, 则称之为容许的参数变换, 若 \(\frac{\partial(u,v)}{\partial(x,y)}&gt;0\), 称为保向的, 若 \(\frac{\partial(u,v)}{\partial(x,y)}&lt;0\), 称为反向的. 局部等距对应 对于两张对应的曲面, 若它们对应着的弧段总是具有相等的弧段长度, 则称这个对应是两张曲面的一个局部等距对应. 内蕴量和内蕴几何体 在曲面上, 由其第一基本形式可完全确定的几何量, 称为曲面的内蕴量; 由其第一基本形式可完全确定属性的几何体, 称为曲面的内蕴几何体. 主曲率和主方向 曲面 \(S\) 上的点 \(P\) 处的法曲率关于切方向的两个最值, 分别称为曲面 \(S\) 在 \(P\) 处的主曲率, 使得法曲率达到最值的两个方向称为主方向. 脐点 若曲面 \(S\) 在 \(P\) 处的两个主曲率相等, 则称 \(P\) 为曲面 \(S\) 的脐点. 若脐点处的主曲率均为0, 称为平点, 否则称为圆点. 极小曲面 若曲面的平均曲率恒为零, 称之为极小曲面. 抽象曲面 称二元有序组 \((D,ds^2)\) 为一张抽象曲面, 其中 \(D\subset\mathbf{R}^2\) 是参数平面 \(\mathbf{R}^2\) 上指定的区域, \(ds^2\) 是定义域上的正定的二次微分形式. 重要的定理 曲线论基本定理 给定区间 \(I=(a,b)\) 上的连续可微函数 \(\overline{\kappa}(s)&gt;0\) 和连续函数 \(\overline{\tau}(s)\), 则在 \(E^3\) 中 存在弧长 \(s\) 参数化曲线 \(C:r=r(s)\), 使其曲率函数 \(\kappa(s)=\overline{\kappa}(s)\), 并且其挠率函数 \(\tau(s)=\overline{\tau}(s)\); 上述曲线 \(C\) 在合同的意义下是唯一的. 可展曲面的分类定理 可展曲面必是煮面、锥面和切线面之一或由它们沿直母线所适当拼接而成. 局部等距对应的条件 两张曲面能建立局部等距对应的充要条件是按照对应关系有相同的第一基本形式. Gauss绝妙定理 曲面 \(S\) 的Gauss曲率是内蕴量, 可表示为 \[K=\frac{-R_{1212}}{g_{11}g_{22}-(g_{12})^2}.\] 在正交网下, 有 \[K=\frac{-1}{\sqrt{EG}}\left(\left[\frac{(\sqrt{E})_2}{\sqrt{G}}\right]_2+\left[\frac{(\sqrt{G})_1}{\sqrt{G}}\right]_1\right).\] 曲面论基本定理 给定 \((u^1,u^2)\) 平面上的单连通区域 \(U\). 给定 \(U\) 上的 \(C^2\) 函数 \(\overline{g}_{ij}\) 和 \(\overline{\Omega}_{ij}\), s.t. \(\overline{g}\) 正定, \(\overline{\Omega}\) 对称, 并且 \(\overline{g}\) 和 \(\overline{\Omega}\) 满足 Gauss-Codazzi方程, 则在 \(E^3\) 中 存在正则曲面 \(S:r=r(u^1,u^2),~(u^1,u^2)\in U\), s.t. 其第一第二基本形式分别为 \(\overline{g}\) 和 \(\overline{\Omega}\); 上述曲面 \(S\) 在合同的意义下是唯一的. 测地线存在唯一性定理 给定正则曲面 \(S:(u^1,u^2)\) 上任意一点 \(P_0(u_0^1,u_0^2)\), 则存在 \(P_0\) 的某个邻域 \(\Sigma_0\subset S\), s.t. 在 \(\Sigma_0\) 内从点 \(P_0\) 出发沿指定单位切向 \(T_0\in T_{P_0}\) 存在唯一一条测地线 \(C:r(u^1(s),u^2(s))\), s.t. \[\left(r_i\frac{du^i}{ds}\right)\Bigg|_{s=s_0}=T_0,~u^i(s_0)=u_0^i,~i=1,2.\] 重要的式子 Euler公式 \[\kappa_n(P,a)=\kappa_1|_P\cos^2\theta+\kappa_2|_P\sin^2\theta.\] Rodriques公式 已知正则曲面 \(S:r(u^1,u^2)\) 的弧长参数化曲线 \(C:r(u^1(s),u^2(s))\), 则 \(C\) 是曲率线等价于沿 \(C\) 存在 \(\lambda(s)\), s.t. \[\frac{dn}{ds}=-\lambda(s)\frac{dr}{ds}.\] 即, 沿 \(C\) 有 \(dn=-\lambda(s)dr\). 正交曲率线网下的Gauss-Codazzi方程 \[ \begin{cases} L_2 &amp;= HE_2, \\ N_1 &amp;= HG_1. \\ \end{cases} \] 判断内蕴量(几何体) 常见的内蕴量(内蕴几何体) 曲线的弧段长度, 曲线的测地曲率, 曲线的交角, 曲面的第一基本形式, 曲线的区域面积, Gauss曲率, 测地线, 测地圆周, 测地开圆盘, 抛物点, 黎曼曲率张量, 联络系数. 常见的不是内蕴量的东西 曲线的曲率, 曲线的挠率, 法曲率, 直线, 圆周, 第一基本形式的系数矩阵, 第二基本形式, 主曲率, 主方向, 脐点, 平点, 圆点, 平均曲率, Weingarten矩阵, 第三基本形式, 渐近曲线.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>数学</tag>
        <tag>期末复习</tag>
        <tag>微分几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概率论复习重点]]></title>
    <url>%2F2017%2F06%2F23%2F%E6%A6%82%E7%8E%87%E8%AE%BA%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9%2F</url>
    <content type="text"><![CDATA[第二章 概率空间 性质和定理 设 \((\Omega,\mathscr{F},\mathbb{P})\) 为概率空间, 有如下性质和定理成立. 可列可加性和次可加性 \(\forall~\{A_n\}\subset\mathscr{F}\), 有 \[\mathbb{P}\left(\bigcup_{n=1}^\infty A_n\right)\leqslant\sum\limits_{n=1}^\infty \mathbb{P}(A_n).\] 对于两两不相容的集合列 \(\{A_n\}\subset\mathscr{F}\), 有 \[\mathbb{P}\left(\bigcup_{n=1}^\infty A_n\right)=\sum\limits_{n=1}^\infty \mathbb{P}(A_n).\] 连续性 若事件 \(A_n\subset A_{n+1}\), \(n\geqslant 1\), 则 \[\mathbb{P}\left(\bigcup\limits_{n=1}^\infty A_n\right)=\lim\limits_{n\to\infty}\mathbb{P}(A_n).\] 若事件 \(A_n\supset A_{n+1}\), \(n\geqslant 1\), 则 \[\mathbb{P}\left(\bigcap\limits_{n=1}^\infty A_n\right)=\lim\limits_{n\to\infty}\mathbb{P}(A_n).\] 全概率公式 设 \(\{B_n\}\) 为 \(\Omega\) 的一个分割, 则 \[\mathbb{P}(A)=\sum\limits_n \mathbb{P}(B_n)\mathbb{P}(A|B_n),\quad\forall~A\in\mathscr{F}.\] Bayes公式 设 \(\{B_n\}\) 为 \(\Omega\) 的一个分割, 对于 \(\forall~A\in\mathscr{F}\), 如果 \(\mathbb{P}(A)&gt;0\), 则对于 \(\forall~1\leqslant k\leqslant n\), 有 \[\mathbb{P}(B_k|A)=\frac{\mathbb{P}(B_k)\mathbb{P}(A|B_k)}{\sum\limits_{n=1}^\infty \mathbb{P}(B_n)\mathbb{P}(A|B_n)}.\] 事件的独立性 若 \(\mathbb{P}(AB)=\mathbb{P}(A)\mathbb{P}(B)\), 则称 \(A\) 和 \(B\) 独立. 第三章 随机变量及其分布 正态分布 密度函数 \[\varphi_{a,\sigma}(x)=\frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{(x-a)^2}{2\sigma^2}},\quad a\in\mathbb{R},~\sigma&gt;0;\] 分布函数 \[\Phi_{a,\sigma}(x)=\int\nolimits_{-\infty}^x \varphi_{a,\sigma}(t)dt;\] 标准正态分布 \[\varphi(x)=\varphi_{0,1}(x)=\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}};\] 正态分布的性质 \[\Phi_{a,\sigma}(x)=\Phi(\frac{x-a}{\sigma}),\quad \Phi(x)=1-\Phi(-x).\] 联合分布 联合分布函数 \[F(x_1,\cdots,x_n)=\mathbb{P}(\xi_1\leqslant x_1,\cdots,\xi_n\leqslant x_n);\] 联合密度函数 \[F(x_1,\cdots,x_n)=\int\cdots\int\nolimits_{\mathbf{R}^n}p(x_1,\cdots,x_n)dx_1\cdots dx_n;\] 边缘分布函数 \[F_1(x)=\lim\limits_{y\to\infty}F(x,y),\quad F_2(y)=\lim\limits_{x\to\infty}F(x,y);\] 边缘密度 离散情形: \[p_{i\bullet}=\sum\limits_j p_{ij},\quad p_{\bullet j}=\sum\limits_i p_{ij};\] 连续情形: \[p_1(x)=\int\nolimits_{-\infty}^\infty p(x,y)dy,\quad p_2(y)=\int\nolimits_{-\infty}^\infty p(x,y)dx;\] 随机变量的独立 联合密度等于边缘密度的乘积. 1. 离散情形: \[p_{ij}=p_{i\bullet}p_{\bullet j},\quad\forall~i,j;\] 2. 连续情形: \[p(x,y)=p_1(x)p_2(y);\] 若 \(\xi_1\) 与 \(\xi_2\) 独立, 则对于任何Borel可测函数 \(f_1\) 与 \(f_2\), \(\eta_1=f_1(\xi_1)\) 与 \(\eta_2=f_2(\xi_2)\) 独立. 随机变量函数的分布 分布函数 设 \(f(x_1,\cdots,x_n)\) 为 \(n\) 元Borel可测函数, \(p\) 为 \((\xi_1\cdots,\xi_n)\) 的密度函数, 则 \(\eta=f(\xi_1,\cdots,\xi_n)\) 的分布函数为 \[F_\eta(y)=\underset{f(x_1,\cdots,x_n)\leqslant y}{\int\cdots\int}p(x_1,\cdots,x_n)dx_1\cdots dx_n.\] 卷积公式 设 \((\xi,\eta)\) 的联合密度函数为 \(p\), 则 \(\xi+\eta\) 的密度函数为 \[p_{\xi+\eta}(z)=\int\nolimits_{-\infty}^\infty p(x,z-x)dx=\int\nolimits_{-\infty}^\infty p(z-y,y)dy.\] 商密度公式 设 \((\xi,\eta)\) 的联合密度为 \(p\), 则 \(\xi/\eta\) 的密度函数为 \[p_{\xi/\eta}(z)=\int\nolimits_{-\infty}^\infty |y|p(zy,y)dy.\] 高维情形 设 \(n\) 维随机向量 \(\xi\) 的联合密度为 \(p\), \(f_i(x)\) 为 \(n\) 维Borel可测函数, \(\eta=(f_1(\xi),\cdots,f_n(\xi))\). 若对于 \(\eta\) 的像空间 \(D\) 中任何一个 \(y\), 方程组 \(y_i=f_i(x)\)有唯一的可微解 \(x_i=h_i(y)\), 则 \(\eta\) 的联合密度函数为 \[q(y)==p(h_1(y),\cdots,h_n(y))|J|,\quad y\in D,\] 其中 \(J=\frac{\partial(h_1(y),\cdots,h_n(y))}{\partial (y_1,\cdots,y_2)}\) 为Jacobi行列式. 第四章 数字特征与特征函数 数学期望 定义: 简单随机变量 \(\mathbb{E}(\xi)=\sum\limits_{i=1}^n x_i\mathbb{P}(\xi=x_i)\rightarrow\) 非负随机变量用简单随机变量逼近 \(\mathbb{E}(\xi)=\lim\limits_{n\to\infty}\mathbb{E}(\xi_n)\rightarrow\), 一般随机变量 \(\mathbb{E}(\xi)=\mathbb{E}(\xi^+)-\mathbb{E}(\xi^-).\) 单调收敛定理 若 \(\xi_n\) 为非负随机变量, 且 \(\xi_n\uparrow\xi\), 则 \(\lim\limits_{n\to\infty}\mathbb{E}(\xi_n)=\mathbb{E}(\xi)\). 数学期望的性质 线性性质: \(\mathbb{E}(a\xi+b\eta)=a\mathbb{E}(\xi)+b\mathbb{E}(\eta)\); 若 \(\xi\) 与 \(\eta\) 独立, 则 \(\mathbb{E}(\xi\eta)=\mathbb{E}(\xi)\mathbb{E}(\eta).\) 数学期望的计算 离散型: \(\mathbb{E}(\xi)=\sum\limits_{k=1}^n x_kp_k\) 或 \(\mathbb{E}(\xi)=\sum\limits_{k=1}^\infty x_kp_k\); 连续型: \(\mathbb{E}(\xi)=\int\nolimits_{-\infty}^\infty xp(x)dx\). 条件期望 离散型: \(\mathbb{E}(\xi|\eta=y)=\sum\limits_{i=1}^n\mathbb{P}(\xi=x_i|\eta=y)\), 连续型: \(\mathbb{E}(\xi|\eta=y)=\int\nolimits_{-\infty}^\infty xp(x|\eta=y)dx\). 条件期望的平滑性: \(\mathbb{E}(\xi)=\mathbb{E}(\mathbb{E}(\xi|\eta))\). 方差 计算: \(D(\xi)=\mathbb{E}(\xi-\mathbb{E}(\xi))^2\); 协方差: \({\rm cov}(\xi_i,\xi_j)=\mathbb{E}((\xi_1-\mathbb{E}(\xi_1))(\xi_2-\mathbb{E}(\xi_2)))\). 容易证明协方差具有如下性质: \[D(\xi+\eta)=D(\eta)+D(\xi)\Longleftrightarrow {\rm cov}(\xi,\eta)=0,\] \[{\rm cov}(\xi_1+\xi_2,\eta)={\rm cov}(\xi_1,\eta)+{\rm cov}(\xi_2,\eta).\] 第五章 大数定律和中心极限定理 收敛性 几乎处处收敛 若 \(\mathbb{P}(\lim\limits_{n\to\infty}\xi_n=\xi)=1\), 则称 \(\xi_n\) 几乎处处收敛到 \(\xi\), 记作 \(\xi_n\xrightarrow{a.e.}\xi\). 依概率收敛 若 \(\lim\limits_{n\to\infty}\mathbb{P}(|\xi_n-\xi|\geqslant\epsilon)=0\), \(\forall~\epsilon&gt;0\), 则称 \(\xi_n\) 依概率收敛于 \(\xi\), 记作 \(\xi_n\xrightarrow{\mathbb{P}}\xi\). 弱收敛 设 \(\xi_n\) 和 \(\xi\) 的分布函数分别为 \(F_n(x)\) 和 \(F(x)\), 若 \(\lim\limits_{n\to\infty}F_n(x)=F(x)\), \(\forall~x\in C_F\), 其中 \(C_F\) 为 \(F\) 的连续点全体, 则称 \(\xi_n\) 弱收敛于 \(\xi\), 记作 \(\xi_n\xrightarrow{w}\xi\). \(r\) 阶矩收敛 给定 \(r&gt;0\in\mathbb{R}\), 若 \(\xi\) 和 \(\xi_n\) 的 \(r\) 阶矩均存在, 并且 \(\lim\limits_{n\to\infty}\mathbb{E}(|\xi_n-\xi|^r)=0\), 则称 \(\xi_n\) \(r\) 阶矩收敛于 \(\xi\), 记作 \(\xi_n\xrightarrow{L_r}\xi\). 几种收敛的关系 \(\xi_n\xrightarrow{a.e.}\) 或 \(\xi_n\xrightarrow{L_r}\xi\Rightarrow\) \(\xi_n\xrightarrow{\mathbb{P}}\xi\Rightarrow\) \(\xi_n\xrightarrow{w}\xi\). 特别地, \(\forall~c\in\mathbb{R}\), \(\xi_n\xrightarrow{w} c\Rightarrow c_n\xrightarrow{\mathbb{P}} c\). 大数定律 大数定律 设 \(\xi_n\) 为数学期望均有限的随机变量列, 若: \[\frac{1}{n}\sum\limits_{k=1}^n (\xi_k-\mathbb{E}(\xi_k))\xrightarrow{\mathbb{P}}0~,\] 则称 \(\xi_n\) 满足弱大数定律. \[\frac{1}{n}\sum\limits_{k=1}^n (\xi_k-\mathbb{E}(\xi_k))\xrightarrow{\text{a.e.}}0~,\] 则称 \(\xi_n\) 满足强大数定律. Markov条件 设随机变量列 \(\xi_n\) 满足 \[\frac{1}{n^2}D\left(\sum\limits_{k=1}^n \xi_k\right)\xrightarrow{n\to\infty}0~,\] 则 \(\xi_n\) 满足大数定律. Bernoulli大数定律 设 \(\mu_n\) 为 \(n\) 重Bernoulli试验中成功的次数, \(p\) 为单次成功概率, 则 \(\frac{\mu_n}{n}\xrightarrow{\mathbb{P}}p\). 辛钦大数定律 设 \(\xi_n\) 为独立同分布随机变量列, 弱大数定律成立的充要条件是 \(\mathbb{E}(\xi_1)=a\) 为有限实数. Kolmogorov强大数定律 设 \(\{\xi_n\}\) 是独立随机变量列, 满足 \(\sum\limits_{k=1}^\infty \frac{D(\xi_n)}{n^2}&lt;\infty\), 则 \(\{\xi_n\}\) 满足大数定律.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>数学</tag>
        <tag>概率论</tag>
        <tag>期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复变复习重点]]></title>
    <url>%2F2017%2F06%2F22%2F%E5%A4%8D%E5%8F%98%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9%2F</url>
    <content type="text"><![CDATA[重要的定义和定理 实可微的定义 设 \(f\) 是从开集 \(\Omega\) 到 \(\mathbb{C}\) 中的函数, \(a\in\Omega\), 如果有复常数 \(A,b\), s.t. \[\lim\limits_{z\to\infty}\frac{f(a+z)-f(a)-Ax-By}{z}=0,\] 则称 \(f\) 在 \(a\) 处实可微. 复可微 设 \(f\) 是定义在开集 \(\Omega\) 上的复变函数, \(a\in\Omega\), 如果有常数 \(\alpha\), s.t. \[\lim\limits_{z\to\infty}\frac{f(a+z)-f(a)}{z}=\alpha\] 存在, 我们称 \(f\) 在 \(a\in\Omega\) 处复可微或称 \(f(z)\) 在 \(a\) 可导, 并把 \(\alpha\) 记作 \(f&#39;(a)\). Cauchy-Riemann方程 如果 \(f(z)=u(x,y)+iv(x,y)\) 在 \(a\in\Omega\) 处实可微, \(u,v\) 为实值函数, 则 \(f\) 在 \(a\) 处复可微当且仅当 \[\frac{\partial f}{\partial \overline{z}}(a)=0~或~ \begin{cases} \frac{\partial u}{\partial x}=\frac{\partial y}{\partial y} \\ \frac{\partial u}{\partial y}=-\frac{\partial v}{\partial x} \\ \end{cases} \] 以上式子被称为Cauchy-Riemann方程, 简称C-R方程. 复解析 如果存在 \(a\) 的一个邻域 \(D(a,r)\subset\Omega\), 使得 \(f(z)\) 在 \(D(a,r)\) 中每点都有导数, 则称 \(f(z)\) 在 \(a\) 点解析. 如果 \(f\) 在 \(\Omega\) 上的每点解析, 则称 \(f\) 在 \(\Omega\) 中解析或全纯. Cauchy高阶求导公式 设 \(\Omega\) 是一个单连通区域, \(C\) 是全在区域 \(\Omega\) 中的闭Jordan分段光滑曲线, \(C\) 所围区域是 \(\omega\). 如果 \(f(z)\) 在 \(\Omega\) 中解析, 则有如下Cauchy公式 \[f(z_0)=\frac{1}{2\pi i}\int\nolimits_C\frac{f(z)dz}{z-z_0}\qquad(z_0\in\omega)\] 且对于任意整数 \(m\), \(f\) 的 \(m\) 阶复导数 \(f^{(m)}(z)\) 在 \(\Omega\) 中存在解析, 且有如下的Cauchy高阶求导公式 \[f^{(m)}(z_0)=\frac{m!}{2\pi i}\int\nolimits_C\frac{f(z)dz}{(z-z_0)^{m+1}}\qquad(z_0\in\omega,~m\in\mathbb{N}^+)\] 泰勒(Taylor)定理 设 \(f\) 在区域 \(\Omega\) 内解析, \(a\in\Omega\), 只要 \(D(a,R)=\{z:|z-a|&lt;R\}\) 包含在 \(\Omega\) 中, 则 \(f\) 在 \(D(a,R)\) 内能展成幂级数 \[f(z)=\sum\limits_{n=0}^\infty c_n(z-a)^n=c_0+c_1(z-a)+\cdots+c_n(z-a)^n+\cdots,\] 其中系数 \[c_n=\frac{f^{(n)}(a)}{n!}=\frac{1}{2\pi i}\int\nolimits_{\partial D(a,\rho)}\frac{f(\zeta)d\zeta}{(\zeta-a)^{n+1}},\quad (0&lt;\rho&lt;R,n\in\mathbb{N})\] 且如果 \(f\) 在 \(D(a,R)\) 内能展成幂级数, 则其系数一定满足上述要求. 解析函数唯一性定理 设函数 \(g\) 和 \(h\) 在区域 \(\Omega\) 内解析, \(a\in\Omega\), 且 \(\Omega\) 内有一个收敛于 \(a\in\Omega\) 的点列 \(\{z_n\}~(z_n\neq a)\), s.t. \(g(z_k)=h(z_k)~(k\in\mathbb{N})\), 则 \(g\) 和 \(h\) 在 \(\Omega\) 内恒等. 洛朗(Laurent)定理 设 \(f\) 在区域 \(\Omega\) 内解析, 只要 \(B(r,R)=\{z:r&lt;|z-a|&lt;R\}\subset\Omega\), 则 \(f\) 在 \(B(r,R)\) 内能展成洛朗级数, 其中系数 \[c_n=\frac{1}{2\pi i}\int\nolimits_{\partial D(a,\rho)}\frac{f(\zeta)d\zeta}{(\zeta-a)^{n+1}}\quad (r&lt;\rho&lt;R,~n\in\mathbb{Z}),\] 且展式是唯一的(即系数 \(c_n\) 由 \(f(z)\) 和圆环 \(B(r,R)\) 唯一确定). 孤立奇点 设函数 \(f\) 在点 \(a\) 的某一去心邻域 \(D(a,r)\backslash\{a\}=\{z:0&lt;|z-a|&lt;r\}\) 内解析, 则点 \(a\) 称为 \(f\) 的孤立奇点. 留数定理 考虑 \(n+1\) 条Jordan闭分段光滑曲线 \(C_0,C_1,\cdots,C_n\), 其中 \(C_1,C_2,\cdots,C_n\) 中每一条都在其余各条的外部, 而它们又都在 \(C_0\) 的内部. 在 \(C_0\) 的内部同时又在 \(C_1,C_2,\cdots,C_n\) 外部的点集构成一个多界的多连通区域 \(\Omega\), 以 \(C_1,C_2,\cdots,C_n\) 为它的边界. \(z_k\in\Omega,~k=1,2,\cdots,m\), 函数 \(f\) 在闭域 \(\overline{\Omega}=\Omega\cup\partial\Omega\) 上除去孤立奇点 \(z_1,z_2,\cdots,z_k\) 外是解析的, 则 \[\int\nolimits_{\partial\Omega}f(z)dz=2\pi i\sum\limits_{k=1}^n {\rm Res}(f,z_k).\] 儒歇(Rouche)定理 设 \(\Omega\) 是区域, \(\omega\subset\Omega\) 是有界区域, 其边界 \(C=\partial\omega\subset\Omega\) 是一条Jordan闭分段光滑曲线, 如果 \(f\) 和 \(g\) 在开集 \(\Omega\) 中解析且在 \(C\) 上有 \(|f(z)|&gt;|g(z)|\), 则函数 \(f(z)\) 与 \(f(z)+g(z)\) 在 \(C\) 的内部 \(\omega\) 有相同的( \(k\) 阶零点算 \(k\) 次)零点个数, 即 \[N(f+g,C)=N(f,C).\] 典型题目 证明复级数的Cauchy乘积收敛 师大复变习题一 31 设复级数 \(s=\sum\limits_{n=0}^\infty\alpha_n\), \(s&#39;=\sum\limits_{n=0}^\infty\alpha_n&#39;\) 收敛, 且其中一个绝对收敛, 则其 Cauchy 乘积 \[\sum\limits_{n=0}^\infty(\alpha_0\alpha_n&#39;+\alpha_1\alpha_{n-1}&#39;+\cdots+\alpha_n\alpha_0&#39;)=\sum\limits_{n=0}^\infty\sum\limits_{k=0}^n\alpha_k\alpha_{n-k}&#39;\]也收敛, 且其和为 \(ss&#39;\). 证明: 不妨设 \(\sum\limits_{n=0}^\infty|\alpha_n|\) 收敛, 记 \(S_m=\sum\limits_{n=0}^m\alpha_n\), \(S_m&#39;=\sum\limits_{n=0}^m\alpha_n&#39;\), \(\gamma_n=\alpha_0\alpha_n&#39;+\alpha_1\alpha_{n-1}&#39;+\cdots+\alpha_n\alpha_0&#39;\), \(\tau_m=\sum\limits_{n=0}^m\gamma_n\), 则有 \(S_m\to s\), \(S_m&#39;\to s&#39;\). 于是, \(\tau_m=\sum\limits_{n=0}^m\gamma_n=\alpha_0S_m&#39;+\cdots+\alpha_nS_0&#39;=S_ms&#39;+\delta_m\) 其中, \(\delta_m=\alpha_0(S_m&#39;-s&#39;)+\alpha_1(S_{m-1}&#39;-s&#39;)+\cdots+\alpha_n(S&#39;-s&#39;)\) 由于 \(\{S_m&#39;\}\) 收敛, 故 \(\{S_m&#39;\}\) 有界, 故 \(\exists~M&gt;0\), s.t. \(\forall~m\in\mathbb{N}\), \(|S_m&#39;-s&#39;|&lt;M\) 又由 \(\sum\limits_{n=0}^m\alpha_n\) 绝对收敛, 知 \(\forall~\epsilon&gt;0\), \(\exists~N_1\in\mathbb{N}\), s.t. \(\sum\limits_{k=N_1+1}^m|\alpha_k|&lt;\frac{\epsilon}{4M+1}\). 再记 \(L=\sum\limits_{k=0}^{N_1}|\alpha_k|\), 同理由 \(S_m&#39;\to s&#39;\) 可得 \(\exists~N_2\in\mathbb{N}\), s.t. \(\forall~m&gt;N_2\), \(|S_m&#39;-s&#39;|&lt;\frac{\epsilon}{4L+1}\). 于是当 \(m&gt;N_1+N_2\) 时有: \[|\delta_m|\leq\sum\limits_{k=0}^m|\alpha_k||S_{m-k}&#39;-s&#39;|+(|\alpha_{N_1}|+\cdots+|\alpha_m|)M\leq\frac{\epsilon}{4L+1}\times L+\frac{\epsilon}{4M+1}&lt;\frac{\epsilon}{2}\] 故: \[|\tau_m-ss&#39;|=|S_ms&#39;-ss&#39;+\delta_m|\leq |s&#39;||S_m-s|+|\delta_m|&lt;\frac{\epsilon}{2|s&#39;|}|s&#39;|+\frac{\epsilon}{2}=\epsilon\] 即 \(\sum\limits_{n=0}^\infty\sum\limits_{k=0}^n\alpha_k\alpha_{n-k}&#39;\) 收敛到 \(ss&#39;\). 分式线性映射映像区域 师大复变习题五 5.(1) 求区域 \(\Omega=\{z:{\rm Re}~z&gt;0,{\rm Im}~z&gt;0\}\) 在分式线性映射 \(w=\frac{z-i}{z+i}\) 下的映像区域. 解答: 记 \(L_1=\{z:{\rm Im}~z=0\}\), \(L_2=\{z:{\rm Re}~z=0\}\). 由于 \(T(z)=\infty\Leftrightarrow z=-i\), 并且 \(-i\) 在 \(L_2\) 上, 不在 \(L_1\) 上, 故 \(T(L_1)\) 为圆, \(T(L_2)\) 为直线. 一方面, \(T(-i)=\infty\), \(T(i)=0\), 并且 \(i\) 和 \(-i\) 关于 \(L_1\) 对称, 故 \(\infty\) 和 \(0\) 关于 \(T(L_1)\) 对称. 即 \(T(L_1)\) 以 \(0\) 为心. 取 \(0\in L_1\), 则有 \(T(0)=-1\in T(L_1)\), 故 \(T(L_1)=\{z:|z|=1\}\). 另一方面, \(T(-1)=\frac{-1-i}{-1+i}=i\), \(T(1)=-i\), 故 \(T(L_2)\) 为过原点的直线. 取 \(0\in L_2\), 有 \(-1\in T(L_2)\), 即 \(T(L_2)\) 为实轴. 取 \(1+i\in\Omega\), 则 \(T(1+i)=\frac{1}{1+2i}=\frac{1}{5}-\frac{2}{5}i\in T(\Omega)\), 即可确定像区域. 已知原区域和像区域求映射 师大复变习题五 12 求把区域 \(\{z:|z-3i|&gt;2,~|z-4|&gt;2\}\) 映射为同心圆环 \(\{w:1&lt;|w|&lt;R\}\) 的分式线性映射 \(w=T(z)\) 并求 \(R\). 解答: 记 \(L_1=\{z:|z-3i|=2\}\), \(L_2=\{z:|z-4|=2\}\). 由于 \(0\) 和 \(\infty\) 为 \(T(L_1)\) 和 \(T(L_2)\) 的公共对称点, 故只需要寻找一对 \(L_1\) 和 \(L_2\) 的公共对称点. 考虑在圆心连线上寻找, 可以找到 \(\frac{4}{5}+\frac{12}{5}i\) 和 \(\frac{16}{5}+\frac{3}{5}i\) 为 \(L_1\) 和 \(L_2\) 的公共对称点. 于是可令 \(T(z)=\lambda\frac{z-\frac{16}{5}-\frac{3}{5}i}{z-\frac{4}{5}-\frac{12}{5}i}=\lambda\frac{5z-16-3i}{5z-4-12i}\). 此时只差 \(\lambda\) 确定表达式. 不妨取 \(\{w:|w|=1\}\) 为 \(T(L_2)\), 则 \(|T(2)|=1\), 可得 \(|\lambda|\cdot|\frac{10-16-3i}{10-4-12i}|=1\), 即 \(|\lambda|=2\). 故由 \(T(i)=R\) 可知 \(|\lambda|\cdot|\frac{5i-16-3i}{5i-4-12i}|=R\), 即 \(R=4\). 至此, 映射的放大倍数已经确定, 只需要取一个点来确定方向, 不妨取 \(T(2)=-1\), 则 \(\lambda\cdot\frac{-6-3i}{6-12i}=-1\), 可得 \(\lambda=-2i\). 即 \(T(z)=-2i\cdot\frac{5z-16-3i}{5z-4-12i}\). 最后一步中, 如不取 \(T(2)=-1\), 则最后所得表达式与原表达式之间相差一个旋转, 映像区域仍然不变.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>数学</tag>
        <tag>复变函数</tag>
        <tag>期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北京师范大学概率论试卷]]></title>
    <url>%2F2017%2F06%2F14%2FBNU-Probability-Theory-Exam%2F</url>
    <content type="text"><![CDATA[2010-2011学年第一学期期末考试试卷 张梅、李勇 2010-2011学年第一学期期末考试试卷 张梅、李勇 (20分)设某地区成年居民中肥胖者占 \(10\%\), 不胖不瘦者占 \(82\%\), 瘦者占 \(8\%\). 又知道肥胖者患高血压的概率为 \(20\%\), 不胖不瘦者患高血压的概率为 \(10\%\), 瘦者患高血压的概率为 \(5\%\), 试求 该地区居民患高血压的概率; 若知某人患高血压, 则他属于肥胖者的概率有多大? (20分)设 \(\{\xi_i,~i=1,2,\cdots\}\) 为一列独立同分布的随机变量, 它们都服从 \([-1,1]\) 上的均匀分布. 求 \(\xi_1\) 的特征函数; 设 \(\eta\) 服从参数为 \(\lambda\) 的Possion分布, 即 \(\mathbb{P}(\eta=k)=\frac{\lambda^k}{k!}e^{-\lambda},~k=0,1,2,\cdots\). 求 \(\eta\) 的母函数; 假定 \(\eta_n\) 服从参数为 \(3n\) 的Possion分布, 并且与 \(\{\xi_i,~i=1,2,\cdots\}\) 相互独立. 证明 \(X_n:=\sum\nolimits_{i=1}^{\eta_n}\xi_i\) 的特征函数为 \(f_n(x)=e^{3n(\frac{\sin t}{t}-1)}\) (约定 \(\sum\nolimits_{i=1}^0\xi_i=0\)). 证明: 当 \(n\to\infty\) 时, \(\frac{1}{\sqrt{n}}X_n\stackrel{w}{\rightarrow}N(0,1)\). (30分)若 \(\xi\sim N(0,\sigma^2)\), 给出 \(\xi\) 的特征函数表达式; 对于 \(\forall~b\in\mathbb{R}\), 证明 \[\mathbb{P}(\xi=b)=0~\text{或}~1;\] 若 \(\vec{\xi}=(\xi_1,\xi_2,\cdots,\xi_n)\sim N(0,A&#39;A)\), 其中 \(A\) 为 \(n\times n\) 矩阵, 其 \((s,t)\) 位置的元素 \[a_{st}= \begin{cases} 1, &amp; s = t - 1 \\ 0, &amp; s\neq t - 1 \end{cases}\] 利用 \(\xi\) 的特征函数计算 \(\vec{\xi}\) 的特征函数; \(\vec{\xi}\) 是 \(n\) 维连续型随机变量吗? 证明你的结果; \(\{\xi_n\}_{n=1}^{\infty}\) 满足大数定律吗? 证明你的结果; \(\{\xi_n\}_{n=1}^{\infty}\) 满足中心极限定理吗? 证明你的结果. (15分) 证明依概率收敛的极限在几乎必然的意义下唯一, 即: 若 \(\xi_n\stackrel{\mathbb{P}}{\rightarrow}{\xi},~\xi_n\stackrel{\mathbb{P}}{\rightarrow}{\eta}\), 必有 \(\mathbb{P}(\xi=\eta)=1\); 设 \(\xi\sim N(0,1)\), 证明: \(-\xi\sim N(0,1)\); 距离说明: 弱收敛的极限在几乎必然的意义下不唯一, 即: 如果 \(\xi_n\stackrel{w}{\rightarrow}{\xi},~\xi_n\stackrel{w}{\rightarrow}{\eta}\), 未必有 \(\mathbb{P}(\xi=\eta)=1\). 设 \(\{\xi_n\}\) 为独立随机变量列, \(\mathbb{E}(\xi_n)=0\), \(D(\xi_n)&lt;\infty\), \(n\geqslant 1\). \(\forall~\epsilon&gt;0\), 记 \(A_1=\{|S_1|\geq\epsilon\}\), \[A_k=\{|S_k|\geq\epsilon\}\cap\left(\bigcap\limits_{k=1}^{k-1}\{|S_j|&lt;\epsilon\}\right),\quad k=2,\cdots,n.\] 证明 \(A_1,A_2,\cdots,A_n\) 互不相容; 证明 \(S_n-S_k\) 与 \(S_k\chi_{A_k}\) 相互独立, 其中 \(\chi_{A_k}\) 表示事件 \(A_k\) 的示性函数; 记 \(S_n=\sum\limits_{k=1}^n\xi_k\), 证明 \[\mathbb{P}\left(\max_{1\leq k\leq n}|S_k|\geq\epsilon\right)\leq\frac{D(S_n)}{\epsilon^2},\qquad\forall~\epsilon&gt;0.\]]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>数学</tag>
        <tag>各种试卷</tag>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北京师范大学复变函数试卷]]></title>
    <url>%2F2017%2F06%2F11%2FBNU-Complex_Analysis-Exam%2F</url>
    <content type="text"><![CDATA[2015 期末考试 邓冠铁 2016-2017 学年第二学期期中考试 邓冠铁 赵纪满. 2016-2017 学年第二学期期末考试 邓冠铁 赵纪满. 2015 复变函数 期末试题 邓冠铁 (20分) 叙述孤立奇点的定义. 求下列各函数在复平面 \(\mathbb{C}\) (不含 \(\infty\) 点)中的孤立奇点, 孤立奇点各属于哪一种类型(极点指明阶数); \[(a)~\frac{1}{z(z^2+1)^2};~(b)~\frac{e^z-1-z}{z^2(\cos z-1)}~;~(c)\frac{1}{z^3\sin(1/z)}\] 求 (a) 和 (b) 中函数在孤立奇点 \(0\) 的留数. (20分) 叙述留数定理并计算下列积分: \[(1)~\int\nolimits_{|z|=2}\frac{z-6}{z^2(z^2-1)}dz;~(2)\int\nolimits_{-\infty}^{+\infty}\frac{x\sin xdx}{(1+x^2)(4+x^2)}.\] (15分)分式线性映射 \(w=T(z)=\frac{z-1}{z+1}\) 将区域 \(\Omega=\{z:{\rm Re}~z&lt;0,{\rm Im}~z&lt;0\}\) 映射为什么区域？即求 \(T(\Omega)=?\) (作图标明原像区域和像区域.) (20分)叙述儒歇(Rouche)定理并求方程 \(z^5-5z^2+z+1=0\) 在圆环 \(1&lt;|z|&lt;2\) 内根的个数. (15分)设 \(f(z)\) 在区域 \(\Omega\) 内解析, 且 \(|f(z)|\) 在区域 \(\Omega\) 内为常数. 试证明 \(f(z)\) 在 \(\Omega\) 中为常数. (10分) 说明多值函数 \((z(1-z)^2)^{\frac{1}{3}}\) 在割去线段 \([0,1]\) 的 \(z\) 平面上可以分出三个单值解析分支; 求出在 \([0,1]\) 的上沿取正值的那个单值解析分支 \(g_0(z)\) 在点 \(z=-1\) 处的值 \(g_0(-1)=?\); 计算积分 \(\int\nolimits_0^1\frac{\sqrt[3]{x(1-x)^2}dx}{(1+x)}\). 2017年复变函数期中考试试卷 (20分)设 \(z_1,z_2\) 是任意两个复数, 证明 \[|z_1+z_2|^2+|z_1-z_2|^2=2(|z_1|^2+|z_2|^2),\] 并说明其几何意义(画图说明). (20分)叙述函数 \(f(z)=u(x,y)+iv(x,y)\) 在一点的(复)可微和解析的定义且讨论函数 \(f(z)=x^2y+ixy^2\) 的(复)可微性和解析性(在何处(复)可微和解析). (25分)将函数 \(\frac{z}{z^2+8z+20}\) 按 \(z+4\) 的幂展出, 并指出其收敛半径. (25分)在下了区域中, 哪些区域存在 \(\sqrt{(z^2-1)(z^2-4)}\) 的解析分支？请说明理由. \(\mathbb{C}\backslash((-\infty,-1]\cup[1,+\infty))\); \(\mathbb{C}\backslash[-2,2]\); \(\mathbb{C}\backslash([-2,-1]\cup[1,2))\); \(\mathbb{C}\backslash((-\infty,-2]\cup[-1,2))\). (10分)设 \(\Omega\) 为平面上的一个非空区域(区域 \(\Omega\) 是连通开集, \(\Omega\) 中任意两点可以用曲线连接), 如果 \(D\subset\Omega\), \(D\) 是一个非空开集且 \(D\neq\Omega\), 证明存在 \(D\) 的边界点 \(c\in\partial\Omega\) 满足 \(c\in\Omega\). 粗略解答 显然. 几何意义: 平行四边形四边的平方和等于对角线的平方和. 由C-R方程可知, 函数只在原点可微, 处处不解析. 拆成分式即可直接展开，此处只列出前几项以供参考: \[-1+\frac{x+4}{4}+\frac{1}{4} (x+4)^2-\frac{1}{16} (x+4)^3-\frac{1}{16} (x+4)^4+\frac{1}{64} (x+4)^5+O\left((x+4)^6\right).\] (1)存在, (2)存在, (3)不存在, (4)存在. 证明从略. 2017年复变函数期末考试试卷 (15分)叙述函数 \(f(z)=u(x,u)+iv(x,y)\) 在一点的(复)可微和解析的定义且讨论函数 \(f(z)=x^3y+iy^3x\) 的(复)可微性和解析性(在何处(复)可微和解析). (25分)将下列函数在指定圆环内展成洛朗级数: \(\frac{1}{z^2(z^2-9)},\quad 3&lt;|z|&lt;+\infty\); \(\cos(\frac{1}{z-1}),\quad 1&lt;|z-1|&lt;+\infty\); \(\frac{f(z)}{z^5}\), \(f(z)\) 为 \({\rm Ln}(1-z)\) 在 \(|z|&lt;1\) 中满足 \(f(0)=0\) 的解析分支. (25分) (1)求函数 \(\frac{z^2-4}{z(z^2-1)^2}\) 和 \(\frac{1}{z^4\sin z}\) 在复平面 \(\mathbb{C}\) (不含 \(\infty\) 点)中的孤立奇点, 孤立奇点各属于哪一种类型(极点要指明阶数); (2)求函数 \(\frac{1}{\sin z}\), \(\frac{1}{z^2\sin z}\), \(\frac{1}{z^4\sin z}\) 在 \(0\) 处的留数. (10分)分式线性映射 \(w=T(z)=\frac{z+i}{z-i}\) 将指定区域 \(\Omega=\{z:{\rm Re}~z&lt;0,{\rm Im}~z&lt;0\}\) 映射为什么区域? ( \(T(\Omega)=~?\) 作草图标明原像区域和像区域, 并说明理由.) (15分)计算积分 \[(1)~\int\nolimits_{-\infty}^{+\infty}\frac{x^2\cos x}{x^4+1}dx;\quad (2)\int\nolimits_0^{+\infty}\frac{x^\alpha}{4+x^2}dx~~(-1&lt;\alpha&lt;1).\] (10分)说明多值函数 \((z^2(1+z)^3)^\frac{1}{5}\) 在割去线段 \([-1,0]\) 的 \(z\) 平面上可以分出五个单值连续分支. 求出在 \([-1,0]\) 的上沿取正值的那个单值解析分支 \(g_0(z)\) 在 \(z=1\) 点处的值和在点 \(z=i\) 处的值.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>数学</tag>
        <tag>各种试卷</tag>
        <tag>复变函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mathematica学习[2]——修改输入和输出字体]]></title>
    <url>%2F2017%2F05%2F09%2FMathematica%E6%8A%80%E5%B7%A7%5B2%5D%E2%80%94%E2%80%94%E4%BF%AE%E6%94%B9%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E5%AD%97%E4%BD%93%2F</url>
    <content type="text"><![CDATA[Mathematica 自带的修改字体功能似乎并没有什么用……如果想修改的话，需要手动运行代码修改。代码分为两部分 函数定义 12345678910111213141516171819202122232425262728setFont[fontFamily_, fontSize_] := With[ &#123; styleNB = Notebook[ &#123; Cell[StyleData[StyleDefinitions -&gt; &quot;Default.nb&quot;]], Cell[StyleData[&quot;StandardForm&quot;], FontFamily -&gt; ToString[fontFamily], FontSize -&gt; ToExpression[fontSize]] &#125; ], styleSheetName = FileNameJoin[ &#123; $UserBaseDirectory, &quot;SystemFiles&quot;, &quot;FrontEnd&quot;, &quot;StyleSheets&quot;, &quot;myStyle.nb&quot; &#125; ] &#125;, If[ FileExistsQ[styleSheetName], SetOptions[$FrontEnd, DefaultStyleDefinitions -&gt; &quot;Default.nb&quot;] ]; Export[styleSheetName, styleNB]; SetOptions[$FrontEnd, DefaultStyleDefinitions -&gt; styleSheetName]]; 函数运行 12345setFont[&quot;字体名称&quot;, 字体大小]比如：setFont[&quot;Consolas&quot;, 12]或者setFont[&quot;Monaco&quot;, 13] 用法 将以上函数和运行的代码粘贴进一个.nb文档，运行即可修改字体。]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>Mathematica</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几篇TOEFL独立写作范文]]></title>
    <url>%2F2017%2F04%2F13%2F%E5%87%A0%E7%AF%87TOEFL%E7%8B%AC%E7%AB%8B%E5%86%99%E4%BD%9C%E8%8C%83%E6%96%87%2F</url>
    <content type="text"><![CDATA[第一篇 In such a competitive society with ceaseless changes, there is a heated debate of the most fundamental factor of keeping close bond with people we love. Obviously, opinions vary from person to person in accordance with their inner preference. After a scrupulous assessment, I would render my support to spending time with them as much as possible. To begin with, regarding the potential harm brought by being apart from the closest people, to say that moving far away is crucial for everyone to attach importance to valuable relationships is an exaggeration. Admittedly, whenever we step into a totally unfamiliar cultural background, it is likely that we would suffer in nostalgia and feel it hard to adapt to new environment immediately, which allows us to realize the indispensable role they play in our life. However, when analyzing this issue from an objective angle, we would find that the benefits caused by getting away from our parents are dwarfed by its negative influences. Even if the technological development enables us to keep in touch with our friends and families across a long distance, there are still emotional feelings and genuine expressions that cannot be discerned by others through the Internet. In addition, compared with living in a great distance, spending time together provides a greater opportunity for us to enhance our mutual relationship much more effectively. Living in a fast paced society, young generation has been suffered overwhelming pressure from daily work and intensive study, which means that hardly can they squeeze time to accompany their families and friends. As a result, they will definitely treasure the scarce chance of holiday to have fun with their beloved friends and relatives. For instance, in Spring Festival in China, which is one of the most grandeur festivals for Chinese people, not only will people set off firecrackers to celebrate the important moment, but also they can share the latest information with each other and enjoy the harmonious atmosphere together. Consequently, it would benefit their relationship in the long run. Last but not least, living with our close friends or families together paves a good way for us to give them cares and unconditioned help, so that we would not regret for not standing besides them in their darkest time. Numerous people post their regretful comments on Facebook because of their families death and their absence in their tough times. There is no denying that facing challenges together and forming a unity fortress are the most effective ways to establish the solid relationships in everyone's life. Since during the process of figuring out best solutions, we are likely to stand in others shoes to analyze problems and get deeper understanding of others. Generally speaking, people tend to cherish those friends who lend them a hand whenever they are stuck in dilemma. In conclusion, considering the details mentioned above, it is a better choice for us to take time to accompany people who are important to us, instead of being far away from them. (498) 第二篇 独立写作题目：Do you agree or disagree with the following statement? Workers would be much happier if they are doing different types of tasks at the same time than doing the same task. 范文立场选择：Disagree Opening (60-100 Words) Intro Reasonable schedule arrangement and patient handling of each task demonstrate a person’s overall potential in his career. Especially in such a society with intensive competition, working pressures urge employees to devote much to the fulfillment of numerous projects. Therefore, some people would like to do several projects at a time for adjusting to a stressful working condition. Thesis However, as far as I am concerned, finishing one task completely then to another should be more efficient because attentiveness is crucial to the performance of any projects. Body (120-150 Words) Topic Last but not least, the focus of attention determines the final result of a project and is immediately related to working quality. State Doing several projects at the same time might divert attentiveness and may also undermine the general progress subsequently. e.g. To illustrate, in the field of architecture which I am majoring in, there is sufficient evidence to show that treating each progress, from scheme design to construction documentation, with attention continually might keep each step more efficient and prepare more fruitful outcomes in the upcoming phase. In other words, it is more reliable for an architect to finish one design and then proceed to the next as well as an unnecessary mix-up of various programs can be a drag on the whole plan. Close It is no exaggeration to say that stopping one temporarily and changing to others might incur some undesirable accidents. 第三篇 Facing the fierce competition in modern society, the pursuit for the success has been the essence of the education. There are multiple choices to promote students' academic performance and accomplish final goals for students. Personally speaking, I would regard receiving support from families and friends as the most important element to be an elite. First and foremost, modern society has witnessed that the career of private tutorship is developing at an alarming rate recently. Admittedly, knowledgeable advisors enable students to enlarge their knowledge base. However, this solution should be not considered as a wise choice. After all, parents and friends are the ones who know us best, because they have experienced every moment of our life with us. No matter what dilemma students are trapped in, it is their closest friends and families who are able to render solid support and lead them step out of woods. What's more, considering the crucial role played by parents and friends, hiring private advisors would turn out to be a huge drain of parents' money. In addition, it is admitted that attending high school is an imperative factor, which defines students' educational background and shapes their value. However, it is less rigorous to say that high school education holds the key to accomplish one's dream. Tracing back to our childhood, whenever we were stuck in a disappointed situation, only if our parents spotted our anomaly, there is no doubt that they would reach out to us and have a deep conversation with us. All they want to do was to encourage us to step out of the shade with a positive attitude and embrace the bright life bravely. Comparatively speaking, high school teachers are only aiming at the promotion of students' grades. Hardly can they teach students in accordance with their aptitude. Last but not least, unconditional support of our families and friends constitutes the steppingstone towards further achievement. No one can substitute their imperative position in our life. For instance, after graduation from high school, not until I packed up my baggage and went abroad for study did I realize how important it is to master fundamental skills, such as financial management, car maintenance and cooking by myself, all of which are taught by my mother. Also, living in a foreign and unfamiliar environment is a huge challenge faced by international students, including me. However, in the darkest and hardest time, my friends always make video call through the convenient Internet, which enables me to receive their warm greetings and erase the severe nostalgia. It is because of their love that I have enough strength and faith to rise above the obstacles. In conclusion, with respect to the most effective factor of success, nothing can be compared with the generous love and care from our families and beloved friends. (467)]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>TOEFL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些 LaTeX 技巧]]></title>
    <url>%2F2017%2F04%2F04%2FLaTeX%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[修改数学公式字体 打生僻字 一些数学符号 代码环境 修改数学公式字体 LaTeX - Beamer 中默认字体很难看，以下两种方法均可修改 1\usefonttheme[onlymath]&#123;serif&#125; 1\usefonttheme&#123;professionalfonts&#125; 左右结构的生僻字 名字有“喆”的痛苦... 有些字体可能没有这个字.. 既然打不出来“喆”，那“吉”总可以搞定吧，那我打两个一半宽度的“吉”不就好了吗？ 实现代码如下： 1\hbox&#123;\resizebox&#123;1.1ex&#125;&#123;1.8ex&#125;&#123;吉&#125;&#125;\hbox&#123;\resizebox&#123;1.1ex&#125;&#123;1.8ex&#125;&#123;吉&#125;&#125; 其中的高度和宽度可以自行调整。 类似“喆”的左右结构的生僻字都可以用这种方法解决。 一些数学符号 正规子群：\(\trianglelefteq\) \trianglelefteq \(\triangleleft\) \triangleleft 半直积：\(\rtimes\) \rtimes \(\ltimes\) \ltimes 逻辑运算：\(\lnot\) \lnot \(\land\) \land \(\lor\) \lor 映射：\(f: G\to H,~~a \mapsto f(a)\) \mapsto 代码环境 一般用 listings，C++ 的具体配置如下： 123456789101112131415161718192021222324252627282930313233\usepackage&#123;listings&#125;\usepackage&#123;xcolor&#125;\definecolor&#123;CPPLight&#125; &#123;HTML&#125; &#123;686868&#125;\definecolor&#123;CPPSteel&#125; &#123;HTML&#125; &#123;888888&#125;\definecolor&#123;CPPDark&#125; &#123;HTML&#125; &#123;262626&#125;\definecolor&#123;CPPBlue&#125; &#123;HTML&#125; &#123;4172A3&#125;\definecolor&#123;CPPGreen&#125; &#123;HTML&#125; &#123;487818&#125;\definecolor&#123;CPPBrown&#125; &#123;HTML&#125; &#123;A07040&#125;\definecolor&#123;CPPRed&#125; &#123;HTML&#125; &#123;AD4D3A&#125;\definecolor&#123;CPPViolet&#125; &#123;HTML&#125; &#123;7040A0&#125;\definecolor&#123;CPPGray&#125; &#123;HTML&#125; &#123;B8B8B8&#125;\lstset&#123; columns=fixed, numbers=left, % 在左侧显示行号 frame=none, % 不显示背景边框 backgroundcolor=\color[RGB]&#123;245,245,244&#125;, % 设定背景颜色 keywordstyle=\color[RGB]&#123;40,40,255&#125;, % 设定关键字颜色 numberstyle=\footnotesize\color&#123;darkgray&#125;, % 设定行号格式 commentstyle=\it\color[RGB]&#123;0,96,96&#125;, % 设置代码注释的格式 stringstyle=\rmfamily\slshape\color[RGB]&#123;128,0,0&#125;, % 设置字符串格式 showstringspaces=false, % 不显示字符串中的空格 language=c++, % 设置语言 morekeywords=&#123;alignas,continute,friend,register,true,alignof,decltype,goto, reinterpret_cast,try,asm,defult,if,return,typedef,auto,delete,inline,short, typeid,bool,do,int,signed,typename,break,double,long,sizeof,union,case, dynamic_cast,mutable,static,unsigned,catch,else,namespace,static_assert,using, char,enum,new,static_cast,virtual,char16_t,char32_t,explict,noexcept,struct, void,export,nullptr,switch,volatile,class,extern,operator,template,wchar_t, const,false,private,this,while,constexpr,float,protected,thread_local, const_cast,for,public,throw,std&#125;,&#125; Young 表绘制 核心是去掉一些竖线. 123456\begin&#123;array&#125;&#123;|cc|&#125; \cline&#123;1-1&#125; 1 &amp; \multicolumn&#123;1&#125;&#123;|c&#125;&#123;&#125; \\ \hline 2 &amp; 3 \\ \hline\end&#123;array&#125;]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合杂题]]></title>
    <url>%2F2017%2F03%2F21%2F%E7%BB%84%E5%90%88%E6%9D%82%E9%A2%98%2F</url>
    <content type="text"><![CDATA[2017年03月21日 保险箱问题 这个题是老师在课上提出来的，比较有意思，随手记录一下. \(6\) 个人共用一个保险箱，要求任意 \(3\) 人在一起时都可以打开保险箱，并且最少需要 \(3\) 人才能打开. 请问至少需要多少把锁？每个人至少需要多少把钥匙？ 解答：先估计一个锁数量的下界. 由题意，每 \(2\) 个人都不能打开该保险箱， 故每 \(2\) 个人都至少有一把不能打开的锁，且对于不同的两人组，不能打开的锁互不相同，故锁的数量不能少于 \(2\) 元子集的个数，即 \(\binom{6}{2}=15\). 再考虑钥匙的数量. 由于任意 \(3\) 个人都能打开保险箱，故每个人都需要有不包括自己的所有二人组所没有的钥匙，即每个人至少要有 \(\binom{5}{2}=10\) 把钥匙. 以上只是对于下界的估计，要证明其最小性还需构造一组情况来证明最小值可以取到. 构造很容易，不多赘述.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些概率论题目]]></title>
    <url>%2F2017%2F03%2F10%2F%E4%B8%80%E4%BA%9B%E6%A6%82%E7%8E%87%E8%AE%BA%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[几句废话 本来觉得概率论是比较简单的课，学了几节课才知道原来简单的是别人家的概率论...我们自家的概率论其实很蛋疼...据刘伟说他当时概率论分比较低...弱菜非常恐慌...于是便在学习中顺便整理一下给自己启发的题目. 由于教材采用师大版概率论（李勇 主编），故题目大多来自于该书. 2017年03月10日 师大概率论 练习 1.2.4 甲乙两人抛硬币，甲抛 \(n+1\) 枚，乙抛 \(n\) 枚，求甲的正面比乙多的概率. 解答：考虑甲乙都抛 \(n\) 枚硬币的情形，设甲正面比乙多的概率为 \(p\)，则由对称性可知，乙比甲正面多的概率也为 \(p\). 故两人正面一样多的概率为 \(1-2p\). 再考虑甲抛的第 \(n+1\) 枚硬币，有 \(\frac{1}{2}\) 概率为正面，\(\frac{1}{2}\) 为反面，则有如下讨论： 若都抛 \(n\) 枚时，甲比乙正面多，则无论甲的第 \(n+1\) 枚为正面还是反面，甲的正面都会比乙多. 该情况出现的概率为 \(p_1=p\times1=p\)； 若都抛 \(n\) 枚时，甲比乙正面少，则无论甲的第 \(n+1\) 枚为正面还是反面，甲的正面都无法比乙多. 该情况出现的概率为 \(p_2=p\times1=p\)； 若都抛 \(n\) 枚时，甲乙正面一样多，且甲的第 \(n+1\) 枚为正面，甲的正面就会比乙多. 该情况出现的概率为 \(p_3=\frac{1-2p}{2}\times\frac{1}{2}\)； 若都抛 \(n\) 枚时，甲乙正面一样多，且甲的第 \(n+1\) 枚为正面，甲的正面就会比乙少. 该情况出现的概率为 \(p_3=\frac{1-2p}{2}\times\frac{1}{2}\). 以上情况中，第一种和第三种出现时，甲的正面会比乙多，否则不会. 故甲正面比乙多的概率为 \(p_1+p_3=\frac{1}{2}\). 兔子提出了一种很好玩儿的解答. 解答：甲抛 \(n+1\) 枚，乙抛 \(n\) 枚，只可能有两种情况出现： 甲的正面比乙多； 甲的反面比乙多. 两种情况不会同时发生，并且概率和为 \(1\)，又由对称性可知两种情况出现的概率相同，故都为 \(\frac{1}{2}\). 师大概率论 练习 1.2.9 在单位圆周上任取三点 \(A,B,C\)，试求事件 \(E=\{\triangle ABC\text{成锐角三角形}\}\) 的概率. 解答：设 \(\triangle ABC\) 的三个内角分别为 \(x,y,z\)，则能构成三角形的条件为： \[x+y+z=\pi\qquad x,y,z&gt;0\] 在三维坐标系中，“能构成三角形”所对应的样本空间为一个三角形，三个顶点分别为 \(D(0,0,\pi),E(0,\pi,0),F(0,0,\pi)\). 而能构成锐角三角形的条件为： \[x+y+z=\pi\qquad 0&lt;x,y,z&lt;\frac{\pi}{2}\] 也会构成一个三角形，三个顶点分别为 \(G(0,\frac{\pi}{2},\frac{\pi}{2}),H(\frac{\pi}{2},0,\frac{\pi}{2}),I(\frac{\pi}{2},\frac{\pi}{2},0)\). 于是 \(\triangle ABC\) 为锐角三角形的概率为 \(\frac{S_{\triangle GHI}}{S_{\triangle DEF}}=\frac{1}{4}\) . 2017年03月22日 师大概率论 练习 2.1.7 设 \(\mathbb{P}(A)+\mathbb{P}(B)=1\)，证明 \(\mathbb{P}(AB)=\mathbb{P}(\overline{A}\overline{B})\). 证明：由于事件“\(A,B\) 中有且仅有一个发生”和事件“\(A,B\) 中有且仅有一个不发生”是相同的事件，故其概率也应该相同. 由容斥原理，事件“\(A,B\) 中至少有一个发生”的概率为 \(\mathbb{P}(A\cup B)=\mathbb{P}(A)+\mathbb{P}(B)-\mathbb{P}(AB)\). 故事件“\(A,B\) 中有且仅有一个发生”的概率为 \(\mathbb{P}(A)+\mathbb{P}(B)-\mathbb{P}(AB)\). 同理，事件“\(A,B\) 中至少有一个不发生”的概率为 \(\mathbb{P}(\overline{A}\cup\overline{B})=\mathbb{P}(\overline{A})+\mathbb{P}(\overline{B})-\mathbb{P}(\overline{A}\overline{B})\). 故事件“\(A,B\) 中有且仅有一个不发生”的概率为 \(\mathbb{P}(\overline{A})+\mathbb{P}(\overline{B})-\mathbb{P}(\overline{A}\overline{B})\). 于是有，\[\mathbb{P}(A)+\mathbb{P}(B)-\mathbb{P}(AB)=\mathbb{P}(\overline{A})+\mathbb{P}(\overline{B})-\mathbb{P}(\overline{A}\overline{B}).\] 又由于 \(\mathbb{P}(A)+\mathbb{P}(B)=1\)，故 \(\mathbb{P}(\overline{A})+\mathbb{P}(\overline{B})=1\)，故有：\[\mathbb{P}(AB)=\mathbb{P}(\overline{A}\overline{B}).\] 2017年03月25日 师大概率论 练习 2.3.2 试证明事件 \(A_1,A_2,\cdots,A_n\) 相互独立的充要条件为：对每个事件 \(\hat{A}_{k}=A_k\) 或者 \(\overline{A_k}(k=1,2,\cdots,n)\)，总有 \[\mathbb{P}(\hat{A}_{1}\hat{A}_{2}\cdots\hat{A}_{n})=\mathbb{P}(\hat{A}_{1})\mathbb{P}(\hat{A}_{2})\cdots\mathbb{P}(\hat{A}_{n}).\] 证明：显然 \(n=2\) 时成立. 假设 \(n=k\) 时结论成立，则有： 必要性：令 \(B=A_k\cap A_{k+1}\)，则 \(A_1,A_2,\cdots,A_{k-1},B\) 相互独立. 于是有 \[\mathbb{P}(\hat{A}_{1}\hat{A}_{2}\cdots\hat{A}_{n-1}\hat{B})=\mathbb{P}(\hat{A}_{1})\mathbb{P}(\hat{A}_{2})\cdots\mathbb{P}(\hat{A}_{n-1})\mathbb{P}(\hat{B}).\] 即 \[\mathbb{P}(\hat{A}_{1}\hat{A}_{2}\cdots\hat{A}_{n-1}A_k A_{k+1})=\mathbb{P}(\hat{A}_{1})\mathbb{P}(\hat{A}_{2})\cdots\mathbb{P}(\hat{A}_{n-1})\mathbb{P}(A_k)\mathbb{P}(A_{k+1}).\] 同理也有： \[\mathbb{P}(\hat{A}_{1}\hat{A}_{2}\cdots\hat{A}_{n-1}\overline{A_k} A_{k+1})=\mathbb{P}(\hat{A}_{1})\mathbb{P}(\hat{A}_{2})\cdots\mathbb{P}(\hat{A}_{n-1})\mathbb{P}(\overline{A_k})\mathbb{P}(A_{k+1}).\] \[\mathbb{P}(\hat{A}_{1}\hat{A}_{2}\cdots\hat{A}_{n-1}A_k \overline{A_{k+1}})=\mathbb{P}(\hat{A}_{1})\mathbb{P}(\hat{A}_{2})\cdots\mathbb{P}(\hat{A}_{n-1})\mathbb{P}(A_k)\mathbb{P}(\overline{A_{k+1}}).\] \[\mathbb{P}(\hat{A}_{1}\hat{A}_{2}\cdots\hat{A}_{n-1}\overline{A_k} \overline{A_{k+1}})=\mathbb{P}(\hat{A}_{1})\mathbb{P}(\hat{A}_{2})\cdots\mathbb{P}(\hat{A}_{n-1})\mathbb{P}(\overline{A_k})\mathbb{P}(\overline{A_{k+1}}).\] 即有 \(\mathbb{P}(\bigcap\limits_{i=1}^{k+1}\hat{A}_{i})=\prod\limits_{i=1}^{k+1}\mathbb{P}(\hat{A}_{i})\). 必要性得证. 充分性：对于 \(\forall~1&lt;s&lt;k+1\)，\(\forall~1\leq i_1&lt;i_2&lt;\cdots&lt;i_s\leq k+1\)，由条件，对于 \(\forall~j\) s.t. \(1\leq j\leq k+1\) 且 \(j\notin\{i_1,i_2,\cdots,i_s\}\)，总有： \[\mathbb{P}(\hat{A}_{1}\cdots\hat{A}_{j-1}A_j\hat{A}_{j+1}\cdots\hat{A}_{k+1})=\mathbb{P}(\hat{A}_{1})\cdots\mathbb{P}(\hat{A}_{j-1})\mathbb{P}(A_j)\mathbb{P}(\hat{A}_{j+1})\cdots\mathbb{P}(\hat{A}_{k+1})\] 且 \[\mathbb{P}(\hat{A}_{1}\cdots\hat{A}_{j-1}\overline{A_j}\hat{A}_{j+1}\cdots\hat{A}_{k+1})=\mathbb{P}(\hat{A}_{1})\cdots\mathbb{P}(\hat{A}_{j-1})\mathbb{P}(\overline{A_j})\mathbb{P}(\hat{A}_{j+1})\cdots\mathbb{P}(\hat{A}_{k+1})\] 由于 \(\mathbb{P}(A_j)+\mathbb{P}(\overline{A_j})=1\)，将以上两式相加即得： \[\mathbb{P}(\hat{A}_{1}\cdots\hat{A}_{j-1}\hat{A}_{j+1}\cdots\hat{A}_{k+1})=\mathbb{P}(\hat{A}_{1})\cdots\mathbb{P}(\hat{A}_{j-1})\mathbb{P}(\hat{A}_{j+1})\cdots\mathbb{P}(\hat{A}_{k+1})\] 式中共有 \(k\) 个事件，故由假设可知这 \(k\) 个事件相互独立. 又由于 \(\{\hat{A}_{i_1},\cdots,\hat{A}_{i_s}\}\subset\{\hat{A}_{1},\cdots,\hat{A}_{k+1}\}\)，故有 \(\mathbb{P}(\bigcap\limits_{j=1}^{s}A_{i_j})=\prod\limits_{j=1}^{s}\mathbb{P}(A_{i_j})\)，\(\forall~1\leq i_1&lt;\cdots&lt;i_s\leq k+1\). 充分性得证. 综上所述，原命题成立.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些实变函数题目]]></title>
    <url>%2F2017%2F03%2F09%2F%E4%B8%80%E4%BA%9B%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[符号说明 \(m^*(E)\) 表示 \(E\) 的外测度; \(m(E)\) 表示 \(E\) 的测度. 2017年03月09日 习题1 第一组 7 设 \(f(x)\) 是定义在 \([0,1]\) 上的实值函数, 且存在常数 \(M\), 使得对于 \([0,1]\) 中的任意有限个数 \(x_1,x_2,\cdots,x_n\), 均有 \(\vert f(x_1)+f(x_2)+\cdots+f(x_n)\vert \leqslant M\), 试证下述集合是可数集: \[E=\{x\in[0,1]~\vert ~f(x)\neq0\}\] 证明: 考虑如下的两族集合: \[A_n=\{x\in[0,1]~\vert ~f(x)&gt;\frac{1}{n}\}\] \[B_n=\{x\in[0,1]~\vert ~f(x)&lt;-\frac{1}{n}\}\] 则有: \[E=\bigcup_{n=1}^\infty\{x\in[0,1]~\vert ~\vert f(x)\vert &gt;\frac{1}{n}\}=\bigcup_{n=1}^\infty(A_n\cup B_n)\] 而对于 \(A_n\), 任取其中的 \(p\) 个数 \(x_1,x_2,\cdots,x_p\), 均有: \[p\times\frac{1}{n}&lt;\vert f(x_1)+f(x_2)+\cdots+f(x_n)\vert \leqslant M\] 于是有 \(p&lt;nM\), 即 \(\forall~n\), \(A_n\) 只含有限个数. 同理 \(\forall~n\), \(B_n\) 也只含有限个数. 故 \(\forall~n\), \(A_n\cup B_n\) 只含有限个数. 于是 \(E\) 为可数个有限集合的并, 故 \(E\) 是可数集. 习题1 第一组 12 设 \(E=\bigcup\limits_{n=1}^\infty A_n\). 若 \(\vert E\vert =\aleph\), 试证明 \(\exists~n_0\), s.t. \(\vert A_{n_0}\vert =\aleph\). 证明: 显然 \(\forall~n\), \(\vert A_n\vert \leqslant\aleph\). 若 \(\forall~n\), \(\vert A_n\vert &lt;\aleph\), 则每个 \(A_n\) 都是至多可数集. 即 \(E\) 为至多可数个至多可数集的并集, 即 \(E\) 至多可数, 与 \(\vert E\vert =\aleph\) 矛盾. 故 \(\exists~n_0\), s.t. \(\vert A_{n_0}\vert =\aleph\). 习题1 第一组 13 设 \(f(x)\) 是定义在 \(\mathbf{R}^1\) 上的单调上升函数, 试证明点集 \[E=\{x:\forall~\epsilon&gt;0,~f(x+\epsilon)-f(x-\epsilon)&gt;0\}\] 是 \(\mathbf{R}^1\) 中的闭集. 证明: 考虑 \(\forall~x\in E&#39;\), \(\exists~\{x_n\}\subset E\), s.t. \(\lim\limits_{n\to\infty}x_n=x\). 故 \(\forall~\epsilon&gt;0\), \(\exists~N\), s.t. \(\forall~n&gt;N\), \(\vert x-x_n\vert &lt;\frac{\epsilon}{2}\). 于是由条件有 \(f(x_{N+1}+\frac{\epsilon}{2})-f(x_{N+1}-\frac{\epsilon}{2})&gt;0\), 由 \(f\) 的单调性, 有 \[(f(x+\epsilon)-f(x-\epsilon))-(f(x_{N+1}+\frac{\epsilon}{2})-f(x_{N+1}-\frac{\epsilon}{2}))&gt;0\] 即 \(x\in E\). 故 \(E\) 为闭集. 习题1 第一组 14 设 \(F\subset\mathbf{R}^n\) 为有界闭集, \(E\) 是 \(F\) 中的一个无限子集, 试证明: \(E&#39;\cap F\neq\varnothing\). 反之, 若 \(F\subset\mathbf{R}^n\) 且对 \(F\) 中任一无限子集 \(E\), 有 \(E&#39;\cap F\neq\varnothing\), 试证明 \(F\) 是有界闭集. 证明: 一方面, 由于 \(E\subset F\), 故 \(E\) 中存在收敛子列, 故 \(E&#39;\neq\varnothing\). 由于 \(F\) 是有界闭集, 故 \(E&#39;\subset F&#39;\subset F\), 于是 \(E&#39;\cap F\neq\varnothing\). 另一方面, 首先证明 \(F\) 是闭集: \(\forall~x\in F&#39;\), \(\exists~E=\{x_n\}_{n=1}^{+\infty}\subset F\), s.t. \(\lim\limits_{n\to\infty}x_n=x\), 即 \(E&#39;=\{x\}\). 又由于 \(\forall~E\subset F\), 均有 \(E&#39;\cap F\neq\varnothing\), 故 \(x\in F\), 即 \(F\) 为闭集. 其次证明 \(F\) 有界: 若 \(F\) 无界, 则任取 \(E\) 为 \(F\) 中的发散序列, 即可得到 \(E&#39;=\varnothing\), 此时显然有 \(E&#39;\cap F=\varnothing\), 矛盾. 故 \(F\) 有界. 综上, \(F\) 有界闭集. 习题1 第一组 15 设 \(F\subset\mathbf{R}^n\) 为闭集, \(r&gt;0\), 证明点集: \[E=\{t\in\mathbf{R^n}:~\exists~x\in F,~\vert t-x\vert =r\}\] 是闭集. 证明: \(\forall~t\in E&#39;\), \(\exists~\{t_n\}_{n=1}^{+\infty}\subset E\), s.t. \(\lim\limits_{n\to\infty}t_n=t\), 由 \(E\) 的定义: \(\forall~n\), \(\exists~x_n\in F\), s.t. \(\vert t_n-x_n\vert =r\). 由于 \(\{t_n\}\) 是收敛子列, 故 \(\{t_n\}\) 有界, 于是 \(\{x_n\}\) 也是有界数列, 故 \(\{x_n\}\) 有收敛子列, 不妨设为 \(\{x_{n_k}\}\). 取 \(x=\lim\limits_{k\to\infty}x_{n_k}\), 则有 \(\vert t-x\vert =r\), 并且 \(x\in F\)（由 \(F\) 是闭集可知）, 即 \(t\in E\). 即 \(E\) 是闭集. 2017年03月15日 习题1 第一组 25 设 \(f:\mathbf{R}\to\mathbf{R}\), 令$G_1= \{ (x,y):~yf(x) \} $, 试证明 \(f\in C(\mathbf{R})\) 当且仅当 \(G_1\) 与 \(G_2\) 是开集. 证明: 必要性是显然的, 以下证明充分性: 假设 \(f\notin C(\mathbf{R})\), 则 \(\exists~x_0\in\mathbf{R}\), \(\epsilon&gt;0\), 和 \(x_n\), 满足 \(\vert x_n-x_0\vert &lt;\frac{1}{n}\), 但 \(\vert f(x_n)-f(x_0)\vert \geqslant\epsilon\). 不妨设 \(f(x_n)\geqslant f(x_0)+\epsilon\), 则 \((x_n,f(x_0)+\epsilon)\in G_2^c\). 由于满足条件的 \(x_n\) 构成数列 \(\{x_n\}\) 且满足 \(\lim\limits_{n\to\infty}x_n=x_0\), 故 \(\lim\limits_{n\to\infty}(x_n,f(x_0)+\epsilon)=(x_0,f(x_0)+\epsilon)\), 又由 \(G_2\) 为开集可知 \(G_2^c\) 为闭集. 即有 \((x_0,f(x_0)+\epsilon)\in G_2^c\). 故 \(f(x_0)\geqslant f(x_0)+\epsilon\), 矛盾. 故 \(f\in C(\mathbf{R})\). 综上, \(f\in C(\mathbf{R})\Longleftrightarrow G_1,~G_2\) 为开集. 证明完全集是不可数集 这个题目完全是在做周《实变函数论》1.5 的 思考题1 时相到的, \(n=2\) 的情况可以参考周《实变函数论》1.5 的 例23. 已知 \(E\subset\mathbf{R}^n\) 为完全集, 证明 \(E\) 不可数. 证明: 假设 \(E\) 是可数集, 令 \(E=\{x_1,x_2,\cdots,x_n\}\). 则可如下构造一个开球列 \(\{B_n\}\): 取 \(B_1=B(x_1,r_1)\subset E\), 则 \(\exists~x_{k_1}\in E\), s.t. \(x_{k_1}\in B_1\), 但 \(\forall~i\), s.t. \(2\leqslant i\leqslant k_1-1\), 均有 \(x_i\notin E\); 取 \(B_1=B(x_{k_1},r_2)\), s.t. \(B_2\subset B_1\), 且 \(r_2&lt;\frac{r_1}{2}\), 则 \(\exists~x_{k_2}\in E~(k_2&gt;k_1)\), s.t. \(x_{k_2}\in B_2\), 但 \(\forall~i\), s.t. \(k_1+1\leqslant i\leqslant k_2-1\), 均有 \(x_i\notin E\); \(\cdots\cdots\) 取 \(B_n=B(x_{k_{n-1} },r_n)\), s.t. \(B_n\subset B_{n-1}\), 且 \(r_n&lt;\frac{r_{n-1} }{2}\), 则 \(\exists~x_{k_n}\in E~(k_n&gt;k_{n-1})\), s.t. \(x_{k_n}\in B_n\), 但 \(\forall~i\), s.t. \(k_{n-1}+1\leqslant i\leqslant k_n-1\), 均有 \(x_i\notin E\); 考虑 \(\{B_n\}\) 的闭包构成的集合列 \(\{\overline{B_n}\}\), 显然有 \(\lim\limits_{n\to\infty}\vert \overline{B_n}\vert =0\), 即 \(\{\overline{B_n}\}\) 形成了一个闭集套, 令 \(\bigcap\limits_{n=1}^\infty\overline{B_n}=\{a\}\). 则应有 \(a\in E\), 而由 \(\{B_n\}\) 的定义可知 \(a\notin E\), 矛盾. 故 \(E\) 为不可数集. 习题1 第一组 26 设 \(\mathbf{R}\) 中的一切开集构成的集合族为 \(\mathscr{G}\), 证明 \(\vert \mathscr{G}\vert =\aleph\). （$$ 表示 \(\mathscr{G}\) 的基数）. 证明: 一方面, 令 \(\mathscr{A}=\{(0,x)~\vert ~x\in\mathbf{R}\}\), 则 \(\vert \mathscr{A}\vert \subset\mathscr{G}\), 且 \(\vert \mathscr{A}\vert =\aleph\). 故 \(\vert \mathscr{G}\vert \geqslant\aleph\). 另一方面, 设 \(E\) 为 \(\mathbf{R}\) 中以有理数为端点的开区间的全体, 则由 \(E\subset\mathbf{Q}^2\) 可知 \(E\) 为可数集, 于是有 \(\vert \mathscr{P}(E)\vert =\aleph\). 由于 \(\mathbf{R}\) 中的每个开区间都可以表示为可数个有理开区间的并, 故对于 \(G\in\mathscr{G}\), 设 \(G=\bigcup\limits_{n=1}^\infty(\alpha_n,\beta_n)\), 其中 \((\alpha_n,\beta_n)\in E\). 据此可构造如下映射: \[\varphi:~\mathscr{P}(E)\longrightarrow\mathscr{G},\quad\{(\alpha_n,\beta_n)\}_{n=1}^{+\infty}\longmapsto G~.\] 由于数列的极限唯一, 故 \(\varphi\) 是良好定义的, 又由于 \(G\) 的逼近方法不唯一, \(\overline{\mathbf{Q} }=\mathbf{R}\), 故 \(\varphi\) 为满射但不为单射. 故 \(\vert \mathscr{G}\vert \leqslant\vert \mathscr{P}(E)\vert =\aleph\). 综上, \(\vert \mathscr{G}\vert =\aleph\). 2017年03月27日 2.1 思考题 2 (ii) 设 \(A,B,C\) 是 \(\mathbf{R}^n\) 中的点集, 且有 \[m^*(A\triangle B)=m^*(B\triangle C)=0\] 求证 \(m^*(A\triangle C)=0\). 证明: 注意到 \[A\backslash C=(A\cap C^c)\cap(B\cup B^c)=[A\cap (B\backslash C)]\cup[C^c\cap(A\backslash B)]\] 又由条件有 \[m^*(A\backslash B)=m^*(B\backslash A)=m^*(B\backslash C)=m^*(C\backslash B)=0\] 可以很容易地得到 \(m^*(A\backslash C)=0\), 类似可得 \(m^*(C\backslash A)=0\), 故 \(m^*(A\triangle C)=0\). 2.1 思考题 3 设 \(E\subset\mathbf{R}^n\), 若对于 \(\forall~x\in E\), 总存在开球 \(B(x,\delta_x)\), 使得 \(m^*(E\cap B(x,\delta_x))=0\), 试证明 \(m^*(E)=0\). 证明: 有条件, 存在一个开球族 \(\mathscr{B}\), s.t. \(x\in E\), 并且 \(E=\bigcup\limits_{B_x\in\mathscr{B} }(E\cap B_x)\). 可以取适当的 \(\delta_x\), 使得 \(B\) 中的开球两两不相交, 此时 \(\mathscr{B}\) 为 \(\mathbf{R}^n\) 中互不相交的开集族, 即 \(\mathscr{B}\) 至多可数, 且 \(\forall~B_x\in\mathscr{B}\), 总有 \(m^*(B_x\cap E)=0\). 故由测度的 \(\sigma\)-可加性, \(m^*(E)=\sum\limits_{B_x\in\mathscr{B} }m^*(E\cap B_x)=0\). 这个证法是错误的……以后再修改 (翻到一个叫 lindelof 定理 的东西……这个题目好像就是定理的直接推论.） 2.2 思考题 2 设 \(\{A_n\}\) 是互不相交的可测集列, \(B_n\subset A_n~(n=1,2,\cdots)\), 证明: \[m^*\left(\bigcup\limits_{n=1}^\infty B_n\right)=\sum\limits_{n=1}^\infty m^*(B_n).\] 证明: 由于 \(m^*\left(\bigcup\limits_{n=1}^\infty B_n\right)\leqslant\sum\limits_{n=1}^\infty m^*(B_n)\) 显然成立, 故只需证明 \[m^*\left(\bigcup\limits_{n=1}^\infty B_n\right)\geqslant\sum\limits_{n=1}^\infty m^*(B_n).\] 对于有限项的 \(B_k\), 由于 \(B_k\) 两两不交, 由外测度的定义有 \[\sum\limits_{k=1}^n m^*(B_k)=m^*\left(\bigcup\limits_{k=1}^n B_k\right).\] 显然 \(m^*\left(\bigcup\limits_{k=1}^n B_k\right)\) 对于 \(n\) 显然是递增集合列, 故对上式取极限可得: \[\sum\limits_{k=1}^n m^*(B_k)=m^*\left(\bigcup\limits_{k=1}^n B_k\right)\leqslant m^*\left(\bigcup\limits_{k=1}^\infty B_k\right).\] 即有 \(\forall~n\in\mathbf{N}\), 均有 \[\sum\limits_{k=1}^n m^*(B_k)\leqslant m^*\left(\bigcup\limits_{k=1}^\infty B_k\right),\] 对上式左侧也取极限, 有 \[\sum\limits_{k=1}^\infty m^*(B_k)\leqslant m^*\left(\bigcup\limits_{k=1}^\infty B_k\right).\] 即结论成立. 2.2 思考题 3 设有点集 \(E_1,E_2\), 且 \(E_1\in\mathscr{M}\). 若 \(m(E_1\triangle E_2)=0\), 求证 \(E_2\in\mathscr{M}\), 且 \(m(E_1)=m(E_2)\). 证明: 考虑 \(E_2=[E_1\backslash(E_1\backslash E_2)]\cup(E_2\backslash E_1)\), 则易得结论. 2017年04月20日 2.2 思考题 4 设点集 \(B\) 满足: 对于 \(\forall~\epsilon&gt;0\), \(\exists~A\in\mathscr{M}\), s.t. \(m^*(A\triangle B)&lt;\epsilon\), 试证明 \(B\) 是可测集. 证明: 由条件, \(\forall~\epsilon&gt;0\), \(\exists~\{A_k\}_{k=1}^{+\infty}\subset\mathscr{M}\), s.t. \(m^*(B\triangle A_k)&lt;\frac{\epsilon}{2^k}\), (\(k\in\mathbf{N})\). 故 \(m^*(B\backslash A_k)&lt;\frac{\epsilon}{2^k}\), 且 \(m^*(A_k\backslash B)&lt;\frac{\epsilon}{2^k}\). 令 \(A=\bigcup\limits_{k=1}^{\infty}A_k\), 则由任意 \(A_k\) 均为可测集可知, \(A\) 为可测集. 又有 \(B\backslash A=\bigcap\limits_{k=1}^{\infty}(B\backslash A_k)\), \(A\backslash B=\bigcap\limits_{k=1}^{\infty}(A_k\backslash B)\), 故 \(m^*(B\backslash A)\leqslant m^*(B\backslash A_k)\), 且 \(m^*(A\backslash B) \leqslant\sum\limits_{k=1}^{\infty}m^*(A_k\backslash B)\). 故 \(m^*(B\backslash A)\leqslant\frac{\epsilon}{2^k}\), \(m^*(A\backslash B)\leqslant\sum\limits_{k=1}^{\infty}\frac{\epsilon}{2^k}=\epsilon\), 即 \(m^*(A\backslash B)=m^*(B\backslash A)=0\). 于是 \(A\backslash B\) 和 \(B\backslash A\) 可测. 故由 \(B=(B\backslash A)\cup(A\backslash(A\backslash B))\), 故 \(B\) 为可测集. 2.2 思考题 8 设有 \(\mathbf{R}^1\) 中可测集列 \(\{E_k\}\), 且当 \(k\geqslant k_0\) 时, \(E_k\subset[a,b]\). 若存在 \(\lim\limits_{k\to\infty}E_k=E\), 试证明: \(m(E)=\lim\limits_{k\to\infty}m(E_k)\). 证明: 一方面, 由于 \(\varlimsup\limits_{k\to\infty}E_k=\bigcap\limits_{j=1}^{\infty}\bigcup\limits_{k=j}^{\infty}E_k=\lim\limits_{k\to\infty}(\bigcup\limits_{j=k}^{\infty}E_j)\). 故 \(m\left(\varlimsup\limits_{k\to\infty}E_k\right)=m\left(\lim\limits_{k\to\infty}(\bigcup\limits_{j=k}^{\infty}E_j)\right)\geqslant\varlimsup\limits_{k\to\infty}m(E_k)\). 又由于 \(\{E_k\}\) 收敛, 故有: \[m(E)=m(\lim\limits_{k\to\infty}E_k)=m(\varlimsup\limits_{k\to\infty}E_k)\geqslant\varlimsup\limits_{k\to\infty}m(E_k)\geqslant\lim\limits_{k\to\infty}m(E_k).\] 即 \(m(E)\geqslant\lim\limits_{k\to\infty}m(E_k)\). 另一方面, \(\varliminf\limits_{k\to\infty}E_k=\bigcup\limits_{j=1}^{\infty}\bigcap\limits_{k=j}^{\infty}E_k=\lim\limits_{k\to\infty}(\bigcup\limits_{j=k}^{\infty}E_j)\). 故 \(m\left(\varliminf\limits_{k\to\infty}E_k\right)=m\left(\lim\limits_{k\to\infty}(\bigcap\limits_{j=k}^{\infty}E_j)\right)\leqslant\varliminf\limits_{k\to\infty}m(E_k)\). 故 \(m(E)\leqslant\varliminf\limits_{k\to\infty}m(E_k)\leqslant\lim\limits_{k\to\infty}m(E_k)\). 综上所述, \(m(E)=\lim\limits_{k\to\infty}m(E_k)\). 2017年04月24日 习题2 第一组 8 设 \(\{E_k\}\) 是 \([0,1]\) 中的可测集列, \(m(E_k)=1\), \((k=0,1,\cdots)\), 试证明: \(m\left(\bigcap\limits_{k=1}^{\infty}E_k\right)=1\). 证明: 由于 \(\{E_k\}\) 可测, 且 \(m(E_k)=1\), \(\forall~k\in\mathbf{N}_+\), 又 \(E_k\subset[0,1]\), 故 \(m([0,1]\backslash E_k)=0\), \(\forall~k\in\mathbf{N}_+\). 于是 \[m\left(\bigcap\limits_{k=1}^{\infty}E_k\right)=1-\left([0,1]\backslash\bigcap\limits_{k=1}^{\infty}E_k\right)=1-\left(\bigcup\limits_{k=1}^{\infty}([0,1]\backslash E_k)\right)=1-\sum\limits_{k=1}^{\infty}m([0,1]\backslash E_k)=1.\] 又由于 \(m(\bigcap\limits_{k=1}^{\infty}E_k)\leqslant m(E_1)=1\), 故 \(m\left(\bigcap\limits_{k=1}^{\infty}E_k\right)=1\). 习题2 第一组 11 设 \(\{B_\alpha\}_{\alpha\in I}\) 是 \(\mathbf{R}^n\) 中一族开球, 记 \(G=\bigcup\limits_{\alpha\in I}B_\alpha\). 若有 \(0&lt;\lambda&lt;m(G)\), 试证明存在有限个互不相交的开球 \(B_{\alpha_1},B_{\alpha_2},\cdots,B_{\alpha_m}\), 使得 \(\sum\limits_{k=1}^m m(B_{\alpha_k})\) 大于 \(\frac{\lambda}{3^n}.\) 证明: 取紧集 \(K\subset G\), s.t. \(m(K)&gt;\lambda\), 则 \(\{B_\alpha\}\) 构成 \(K\) 的一个开覆盖. 于是存在有限子覆盖 \(B_1,B_2\cdots,B_k\). 取其中半径最大者为 \(B_{\alpha_1}\), 则将 \(B_{\alpha_1}\) 的半径扩大三倍即可将 \(B_i\) 中所有与 \(B_{\alpha_1}\) 相交的开球全部覆盖; 再取 \(B_i\) 中与 \(B_{\alpha_1}\) 不相交的球中半径最大者为 \(B_{\alpha_2}\), 则将其半径扩大三倍即可将与其相交的开球全部覆盖. 如此继续下去可以选出有限个开球 \(B_{\alpha_1},B_{\alpha_2}\cdots,B_{\alpha_m}\), s.t. 将其中的每一个球半径扩大三倍可以构成 \(K\) 的覆盖. 于是 \(\sum\limits_{i=1}^m 3^n\times m(B_{\alpha_i})&gt;\lambda\), 即 \(\sum\limits_{k=1}^m m(B_{\alpha_k})&gt;\frac{\lambda}{3^n}\), 原命题得证. 2017年04月25日 习题2 第一组 12 设 \(\{B_k\}\) 是 \(\mathbf{R}^n\) 中递减可测集列, \(m^*(A)&lt;\infty\). 令 \(E_k=A\cap B_k~(k=0,1,\cdots)\), \(E=\bigcap\limits_{k=1}^\infty E_k\), 试证明 \[\lim\limits_{k\to\infty}m^*(E_k)=m^*(E).\] 证明: 令 \(A\) 的等测包为 \(H\), 则 \(\{B_k\cap H\}\) 为递减可测集列. 于是 \(\lim\limits_{k\to\infty} m(H\cap B_k)=m\left(\lim\limits_{k\to\infty}(H\cap B_k)\right)=m\left((\bigcap\limits_{k=1}^\infty B_k)\cap H\right)\). 而对于 \(\forall~k\), \(m(H\cap B_k)-m\left(\bigcap\limits_{k=1}^\infty(H\cap B_k)\cap H\right)=m\left((H\cap B_k)\backslash\bigcap\limits_{k=1}^\infty(H\cap B_k)\right)\). 又由于 \(H\) 和 \(B_k\) 均为可测集, 故 \(m\left((H\cap B_k)\backslash\bigcap\limits_{k=1}^\infty(H\cap B_k)\right)=m^*\left((H\cap B_k)\backslash\bigcap\limits_{k=1}^\infty(H\cap B_k)\right)\). 即 \(m(H\cap B_k)-m\left(\bigcap\limits_{k=1}^\infty(H\cap B_k)\right)=m^*\left((H\cap B_k)\backslash\bigcap\limits_{k=1}^\infty(H\cap B_k)\right)\). 由于 \(A\subset H\), 故 \[ \begin{align} m(H\cap B_k)-m\left(\bigcap\limits_{k=1}^\infty(H\cap B_k)\right) &amp;\geqslant m^*\left(A\cap (B_k\backslash\bigcap\limits_{k=1}^{\infty}B_k)\right) \\ &amp;= m^*\left((A\cap B_k) \backslash \bigcap\limits_{k=1}^{\infty}(A\cap B_k)\right) \\ &amp;= m^*(E_k\backslash\bigcap\limits_{k=1}^{\infty} E_k) = m^*(E_k\backslash E) \\ &amp;\geqslant m^*(E_k)-m^*(E). \end{align} \] 由于 \(E_k\) 递减, 故 \(m^*(E_k)\geqslant m^*(E)\), \(\forall~k\in\mathbf{N}_+\), 即 \(m^*(E_k)-m^*(E)\geqslant 0\). 又由于 \(\lim\limits_{k\to\infty}\left(m(H\cap B _k)-m(\bigcap\limits_{k=1}^{\infty}(H\cap B_k)\right)=0\). 故 \(\lim\limits_{k\to\infty}m^*(E_k)-m^*(E)=0\), 即 \(\lim\limits_{k\to\infty}m^*(E_k)=m^*(E)\). 2017年04月26日 习题2 第一组 14 试证明点集 \(E\) 可测的充要条件是: 对任意 \(\epsilon&gt;0\), 存在开集 \(G_1,G_2\): \[G_1\supset E,\quad G_2\supset E^c,\] 使得 \(m(G_1\cap G_2)&lt;\epsilon\). 证明: 必要性: 由于 \(E\) 为可测集, 故: 存在开集 \(G\supset E\), s.t. \(m(G)-m(E)&lt;\frac{\epsilon}{2}\). 存在闭集 \(F\subset E\), s.t. \(m(E)-m(F)&lt;\frac{\epsilon}{2}\). 取 \(G_1=G\), \(G_2=F^c\), 则 \(m^*(G_1\cap G_2)=m(G\backslash F)=m(G)-m(F)&lt;\epsilon\). 充分性: 取递减开集列 \(G_{1n}\) 和 \(G_{2n}\), s.t. \(\forall~n\), 有 \(E\subset G_{1n}\), \(E^c\subset G_{2n}\) 且 \(m(G_{1n}-G_{2n})&lt;\frac{1}{n}\). 则取 \(G=\lim\limits_{n\to\infty} G_{1n}\), 即可使得 \(G\) 为可测集, 且 \(m^*(G\backslash E)\leqslant m^*(G_{1n}\cap G_{2n})\). 取极限, 即有 \(m^*(G\backslash E)=0\). 于是 \(G\backslash E\) 为零测集, 即 \(E\) 可测. 习题2 第一组 15 设 \(E\subset[0,1]\) 是可测集且有 \[m(E)\geqslant\epsilon &gt;0,\quad x_i\in[0,1],~i=1,2,\cdots,n,\] 其中 \(n&gt;\frac{2}{\epsilon}\). 试证明 \(E\) 中存在两个点, 其距离等于 \(\{x_1,x_2,\cdots,x_n\}\) 中某两个点的距离. 证明: 由于 \(\forall~i\in\mathbf{N}\), s.t. \(1\leqslant i\leqslant n\), 总有 \(x_i\in[0,1]\). 于是 \(E+\{x_i\}\subset[0,2]\), \(\forall~i\). 故 \(\bigcup\limits_{i=1}^n (E+\{x_i\})\subset[0,2]\), 故 \(m\left(\bigcup\limits_{i=1}^n (E+\{x_i\})\right)\leqslant 2\). 由于 \(n&gt;\frac{2}{\epsilon}\), 故 \(\exists~i\neq j\), s.t. \((E+\{x_i\})\cap(E+\{x_j\})\neq\varnothing\). （否则 \(\sum\limits_{i=1}^n m(E+\{x_i\})\leqslant 2\), 即 \(n\leqslant\frac{\epsilon}{2}\), 矛盾.） 原命题得证. 2017年05月11日 3.2 思考题 3 设 \(\{f_k(x)\}\) 在 \(E\)上依测度收敛于零, \(g(x)\) 是 \(E\) 上实值可测函数. 若 \(m(E)=+\infty\), 试说明 \(\{g(x)f_k(x)\}\) 在 \(E\) 上不一定依测度收敛于零. 证明: 取 \(g(x)=x,~f_k(x)=\frac{1}{k}\) 即可. 习题3 第一组 4 设 \(f(x)\) 是 \(E\subset\mathbf{R}^n\) 上几乎处处有限的可测函数, \(m(E)&lt;\infty\), 试证明对于 \(\forall~\epsilon&gt;0\), 存在 \(E\) 上的有界可测函数 \(g(x)\), s.t. \(m(\{x\in E:\vert f(x)-g(x)\vert &gt;0\})&lt;\epsilon\). 证明: 令 \(E_\infty=\{x\in E:\vert f(x)\vert =\infty\}\), \(E_n=\{x\in E:\vert f(x)\vert \geqslant n\}\), \(n=1,2,\cdots\), 则 \(E\supset E_1\supset E_2\supset\cdots\), \(E_\infty=\bigcap\limits_{n=1}^\infty E_n\). 又由于 \(f(x)\) 几乎处处有限, 故 \(\lim\limits_{n\to\infty}m(E_n)=m(\lim\limits_{n\to\infty}E_n)=0\). 故 \(\forall~\epsilon&gt;0\), \(\exists~N\), s.t. \(m(E_N)=m(\{x\in E:\vert f(x)\vert \geqslant N\})&lt;\epsilon\), 故可以取函数 \[ g(x)= \begin{cases} f(x), &amp; x\in E\backslash E_N \\ 0, &amp; x\in E_N \end{cases} \] 则 \(g(x)\) 有界可测, 并且 \(m(\{x\in E:\vert f(x)-g(x)\vert &gt;0\})\leqslant m(E_N)&lt;\epsilon\). 习题3 第一组 5 设 \(f(x)\) 及 \(f_n(x)~(n=1,2,\cdots)\) 都是 \(A\subset\mathbf{R}^1\) 上几乎处处有限的可测函数. 若对于 \(\forall~\epsilon&gt;0\), 存在 \(A\) 的可测子集 \(B:m(A\backslash B)&lt;\epsilon\), s.t. \(f_n(x)\) 在 \(B\) 上一致收敛于 \(f(x)\), 试证明 \(f_n(x)\) 在 \(A\) 上几乎处处收敛于 \(f(x)\). 证明: 由条件, 对于 \(\epsilon_m=\frac{1}{2^m}\), 存在 \(A\) 的可测子集 \(B_m\), s.t. \(m(A\backslash B_m)&lt;\epsilon_m\), 且 \(f_n(x)\) 在 \(B_m\) 上一致收敛于 \(f(x)\). 令 \(B=\bigcap\limits_{j=1}^\infty\bigcup\limits_{m=j}^\infty(A\backslash B_m)\), 由于 \[m(B)\leqslant m(\bigcup\limits_{m=j}^\infty(A\backslash B_m))\leqslant\sum\limits_{m=j}^\infty m(A\backslash B_m)&lt;\sum\limits_{m=j}^\infty\frac{1}{2^m},\quad\forall~j.\] 故 \(m(B)=0\). 故 \(\forall~x\in A\backslash B=\bigcap\limits_{j=1}^\infty\bigcup\limits_{m=j}^\infty B_m\), \(\exists~j_0\), s.t. \(x\in\bigcap\limits_{m=j_0}^\infty B_m\), 由于 \(f_n\) 在 \(B_m\) 上一致收敛, 故在 \(x\) 处应收敛. 由于 \(m(B)=0\), 故 \(f_n\) 在 \(A\) 上几乎处处收敛于 \(f\). 习题3 第一组 6 设 \(\{f_k(x)\}\) 是 \(E\subset\mathbf{R}^n\) 上的实值可测函数列, \(m(E)&lt;\infty\), 试证明 \[\lim\limits_{k\to\infty}f_k(x)=0,\quad\text{a.e.}~x\in E\] 的充要条件是 \[\forall~\epsilon&gt;0,~\lim\limits_{k\to\infty}m(\{x\in E:\sup\limits_{k\geqslant j}\{\vert f_k(x)\vert \}\geqslant\epsilon\})=0.\] 证明: 记 \(I=\{x\in E:f_k(x)\nrightarrow0~(k\to\infty)\}\), \(I_m=\varlimsup\limits_{k\to\infty}\{\vert f_k(x)\vert \geqslant\frac{1}{m}\}\), 则 \(I=\bigcup\limits_{m=1}^\infty I_m\). 充分性: 若 \(\forall~\epsilon&gt;0\), 总有 \(\lim\limits_{j\to\infty} m\left(\{x\in E:\sup\limits_{k\geqslant}\{f_k(x)\}\geqslant\epsilon\}\right)=0\), 则 \[ \begin{align} m^*(I) &amp;\leqslant \sum\limits_{m=1}^\infty m(I_m) \\ &amp;= \sum\limits_{m=1}^\infty m\left( \bigcap\limits_{j=1}^\infty\bigcup\limits_{k=j}^\infty\{x\in E:\vert f_k(x)\vert \geqslant\frac{1}{m}\} \right) \\ &amp;= \sum\limits_{m=1}^\infty \left( \lim\limits_{j\to\infty}m(\bigcup\limits_{k=j}^\infty \{x\in E:\vert f_k(x)\vert \geqslant\frac{1}{m}\}) \right) \\ &amp;\leqslant \sum\limits_{m=1}^\infty \lim\limits_{j\to\infty}m\left(\{x\in E:\sup\limits_{k\geqslant j}\vert f_k(x)\vert \geqslant\frac{1}{m}\}\right) \\ &amp;= 0 \\ \end{align} \] 即有 \(m^*(I)=0\), 故 \(\lim\limits_{k\to\infty}f_k(x)=0\), a.e. \(x\in E\). 必要性: 由于 \(\lim\limits_{k\to\infty}f_k(x)=0\), a.e. \(x\in E\), 故 \(m(I)=0\). 而 \(\forall~\epsilon&gt;0\), 总有 \[ \begin{align} \varlimsup\limits_{j\to\infty}m\left(\{x\in E:\sup\limits_{k\geqslant j}\vert f_k(x)\vert \geqslant\epsilon\}\right) &amp;\geqslant \varlimsup\limits_{j\to\infty}m\left(\bigcup\limits_{k=j}^\infty \{x\in E:\vert f_k(x)\vert \geqslant\frac{\epsilon}{2}\}\right) \\ &amp;= m\left(\bigcap\limits_{j=1}^\infty \bigcup\limits_{k=j}^\infty\{x\in E:\vert f_k(x)\vert \geqslant\frac{\epsilon}{2}\}\right) \\ &amp;\leqslant m(I) \\ &amp; =0 \\ \end{align} \] 综上: \(\lim\limits_{k\to\infty}f_k(x)=0,~\text{a.e.}~x\in E\Longleftrightarrow\forall~\epsilon&gt;0,~\lim\limits_{k\to\infty}m(\{x\in E:\sup\limits_{k\geqslant j}\{\vert f_k(x)\vert \}\geqslant\epsilon\})=0\). 习题3 第一组 7 设 \(f(x),f_1(x),f_2(x),\cdots\) 是 \([a,b]\) 上几乎处处有限的可测函数, 且有 \[\lim\limits_{k\to\infty}f_k(x)=f(x),\quad\text{a.e.}~x\in[a,b],\] 试证明 \(\exists~E_n\subset[a,b]~(n=1,2,\cdots)\), s.t. \(m\left([a,b]\backslash\bigcup\limits_{n=1}^\infty E_n\right)=0\), 而 \(\{f_k(x)\}\) 在每个 \(E_n\) 上一致收敛于 \(f(x)\). 证明: 由Egorov定理, \(\forall~n\), \(\exists~E_n\subset[a,b]\), s.t. \(m([a,b]\backslash E_n)\leqslant\frac{1}{n}\), 且在 \(E_n\) 上, \(f_k(x)\rightrightarrows f(x)\). 又有 \[ \begin{align} m\left([a,b]\backslash\bigcup\limits_{n=1}^\infty E_n\right) &amp;= m\left(\bigcap_{n=1}^\infty ([a,b]\backslash E_n)\right) \\ &amp;\leqslant \lim\limits_{n\to\infty}([a,b]\backslash E_n) \\ &amp;\leqslant \lim\limits_{n\to\infty}\frac{1}{n}=0.\\ \end{align} \] 原命题得证. 2017年05月12日 习题4 第一组 1 设 \(f(x)\) 是 \(E\subset\mathbf{R}^n\) 上几乎处处大于零的可测函数, 且满足 \(\int_Ef(x){\rm d}x=0\), 试证明 \(m(E)=0\). 证明: 反证法 假设 \(m(E)&gt;0\), 记 \(E_n=\{x\in E:f(x)&gt;\frac{1}{n}\}\), 并令 \(F=\bigcup\limits_{n=1}^\infty E_n\), 则由 \(E=(E\backslash F)\cup F\) 且 \(m(E\backslash F)=0\) 可知, \(\exists n_0\), s.t. \(m(E_{n_0})&gt;0\). 于是有 \(0=\int_Ef(x){\rm d}x\geqslant\int_{E_{n_0} }f(x){\rm d}x\geqslant\frac{1}{n_0}m(E_{n_0})\), 得 \(m(E_{n_0})=0\), 矛盾. 于是 \(m(E)=0\). 习题4 第一组 4 设 \(f(x)\) 是 \(\mathbf{R}^1\) 上的非负可测函数, 令 \[F(x)=\int\nolimits_{(-\infty,x] }f(t)dt,\quad x\in\mathbf{R}^1.\] 若 \(F\in L(\mathbf{R}^1)\), 试证明 \(\int\nolimits_{\mathbf{R}^1}f(x)dx=0\). 证明: 由于 \(F\in L(\mathbf{R}^1)\), 故 \(\forall~\epsilon&gt;0\), \(\exists~N\) s.t. \(\int\nolimits_{\{x:\vert x\vert &gt;N\} }F(x)dx&lt;\epsilon\). 又由于 \(f(x)\geqslant0\), 故 \(F(x)\) 随 \(x\) 递增, 且 \(\lim\limits_{x\to\infty}F(x)=\int\nolimits_{\mathbf{R}^1}f(x)dx\). 于是 \(\forall~y&gt;N\), 均有: \[F(y)=\int\nolimits_{y}^{y+1}F(y)dx\leqslant\int\nolimits_y^{y+1}F(x)dx\leqslant\int\nolimits_{\{x:\vert x\vert &gt;N\} }F(x)dx&lt;\epsilon\], 于是 \(\lim\limits_{y\to\infty}F(y)=0\). 即 \(\int\nolimits_{\mathbf{R}^1}f(x)dx=0\). 习题4 第一组 5 设 \(f_k(x)~(k=1,2,\cdots)\) 是 \(\mathbf{R}^n\) 上非负可积函数列, 若对于任何一可测集 \(E\subset\mathbf{R}^n\), 总有 \[\int\nolimits_Ef_k(x)dx\leqslant\int\nolimits_Ef_{k+1}(x)dx,\] 试证明 \[\lim\limits_{k\to\infty}\int\nolimits_Ef_k(x)dx=\int\nolimits_E \lim\limits_{k\to\infty} f_k(x)dx.\] 证明: 取 \(E_k=\{x:f_k(x)&gt;f_{k+1}(x)\}~(k=1,2,\cdots)\), 则由条件有 \(\int\nolimits_{E_k}(f_k(x)-f_{k+1}(x))dx\leqslant0\). 又由 \(E_k\) 的定义可知 \(f_k(x)-f_{k+1}(x)&gt;0\), 故 \(m(E_k)=0\), \(\forall~k\). 于是 \(m\left(\bigcup\limits_{k=1}^\infty E_k \right)=0\), 故 \(f_k(x)\) 在 \(E\) 上几乎处处满足Levi定理的使用条件, 故在 \(E\) 上由Levi定理有 \[\lim\limits_{k\to\infty}\int\nolimits_Ef_k(x)dx=\int\nolimits_E \lim\limits_{k\to\infty} f_k(x)dx.\] 2017年06月07日 习题4 第一组 7 假设有定义在 \(\mathbf{R}^n\) 上的函数 \(f(x)\), 如果对于 \(\forall~\epsilon&gt;0\), \(\exists~g,h\in L(\mathbf{R}^n)\), s.t. \(g(x)\leqslant f(x)\leqslant h(x)~(x\in\mathbf{R}^n)\), 并且 \(\int\nolimits_{\mathbf{R}^n}[h(x)-g(x)]dx&lt;\epsilon\), 试证明 \(f\in L(\mathbf{R}^n).\) 证明: 由条件, 取可积函数列 \(g_k(x),h_k(x)\), s.t. \(g_k(x)\leqslant f(x)\leqslant h_k(x)\) 且 \(\int\nolimits_{\mathbf{R}^n}[h_k(x)-g_k(x)]dx&lt;\frac{1}{k}\). 故 \(\{h_k(x)-g_k(x)\}\) 为非负可积函数列. 又由于 \(\lim\limits_{k\to\infty}\int\nolimits_{\mathbf{R}^n}[h_k(x)-g_k(x)]dx=0\), 故 \(h_k(x)-g_k(x)\) 依测度收敛于0. 故由Riesz定理, 存在子列 \(\{h_{k_j}-g_{k_j}\}\), s.t. \(\lim\limits_{j\to\infty}[h_{k_j}(x)-g_{k_j}(x)]=0\), a.e. \(x\in\mathbf{R}^n\). 又 $f(x){g_k(x),h_k(x)}g_k(x)+h_k(x)$. 故 \(\vert f\vert \in L(\mathbf{R}^n)\), 故 \(f\in L(\mathbf{R}^n)\). 习题4 第一组 8 设 \(\{E_k\}\) 是 \(\mathbf{R}^n\) 中测度有限的可测集列, 且有 \[\lim\limits_{k\to\infty}\int\nolimits_{\mathbf{R}^n}\vert \chi_{E_k}(x)-f(x)\vert =0,\] 试证明存在可测集 \(E\) s.t. \(f(x)=\chi_E(x)\), a.e. \(x\in\mathbf{R}^n\). 证明: 由条件, \(\chi_{E_k}(x)\) 依 \(L^1\) 范数收敛于 \(f(x)\), 故 \(\chi_{E_k}(x)\) 依测度收敛于 \(f(x)\). 由Riesz定理, 存在其几乎处处收敛于 \(f(x)\) 的子列 \(\chi_{E_{k_i} }(x)\). 令 \(E_{k_i}\to E\), 则应有 \(f(x)=\chi_E(x)\), a.e. \(x\in\mathbf{R}^n\). 2017年06月20日 习题4 第一组 13 设 \(f\in L(\mathbf{R}^1),p&gt;0\), 试证明 \[\lim\limits_{n\to\infty}n^{-p}f(nx)=0,\quad\text{a.e.}~x\in\mathbf{R}^1.\] 证明: 考虑级数 ${n=1}n{-p}f(nx)$, 则 \(n^{-p}f(nx)\) 为非负可测函数, 即 \[ \begin{align} \int\nolimits_{\mathbf{R}^1}\left(\sum\limits_{n=1}^\infty\vert n^{-p}f(nx)\vert \right)dx &amp;= \sum\limits_{n=1}^\infty\int\nolimits_{\mathbf{R}^1}\vert n^{-p}f(nx)\vert dx \\ &amp;= \sum\limits_{n=1}^\infty\int\nolimits_{\mathbf{R}^1}\vert n^{-p-1}f(nx)\vert d(nx) \\ &amp;= \sum\limits_{k=1}^\infty\frac{1}{n^{p+1} }\cdot\int\nolimits_{\mathbf{R}^1}\vert f(x)\vert dx \\ \end{align} \] 由于 \(1+p&gt;1\), 故 \(\sum\limits_{k=1}^\infty\frac{1}{n^{p+1} }\) 收敛, 又由于 \(\int\nolimits_{\mathbf{R}^1}\vert f(x)\vert dx\) 有限, 故 \(\int\nolimits_{\mathbf{R}^1}\left(\sum\limits_{n=1}^\infty\vert n^{-p}f(nx)\vert \right)dx\) 有限, 故 ${n=1}n{-p}f(nx)$ 有限, 即有 \(\lim\limits_{n\to\infty}n^{-p}f(nx)=0\), a.e. \(x\in\mathbf{R}^1\). 习题4 第一组 21 依测度收敛的Fatou引理 设 \(\{f_k(X)\}\) 是 \(E\) 上依测度收敛于 \(f(x)\) 的非负可测函数列, 试证明 \[\int\nolimits_E f(x)dx\leqslant \varliminf\limits_{k\to\infty}\int\nolimits_E f_k(x)dx.\] 证明: 由Riesz定理, 存在子列 \(\{f_{k_i}(x)\}\), s.t. \(\lim\limits_{i\to\infty}f_{k_i}(x)=f(x)\), a.e. \(x\in\mathbf{R}^n\). 故由Fatou引理, 有: \[ \begin{align} \int\nolimits_Ef(x)dx &amp;= \int\nolimits_E \lim\limits_{i\to\infty}f_{k_i}(x)dx \\ &amp;= \int\nolimits_E \varliminf\limits_{i\to\infty}f_{k_i}(x)dx \\ &amp;\leqslant \varliminf\limits_{i\to\infty}\int\nolimits_{E} f_{k_i}(x)dx \\ &amp;= \varliminf\limits_{k\to\infty}\int\nolimits_E f_k(x)dx.\\ \end{align} \] 即 \(\int\nolimits_E f(x)dx\leqslant \varliminf\limits_{k\to\infty}\int\nolimits_E f_k(x)dx\). 这个证法可能有问题, 慢慢解决. 习题4 第一组 23 设 \(f\in L(\mathbf{R}^n)\), \(f_k\in L(\mathbf{R}^n)~(k=1,2,\cdots)\), 且对任一可测集 \(E\subset\mathbf{R}^n\), 均有 \[\int\nolimits_Ef_k(x)dx\leqslant \int\nolimits_Ef_{k+1}(x)dx~(k=1,2,\cdots),\] \[\lim\limits_{k\to\infty}\int\nolimits_Ef_k(x)dx=\int\nolimits_Ef(x)dx,\] 试证明 \(\lim\limits_{k\to\infty}f_k(x)=f(x)\), a.e. \(x\in\mathbf{R}^n\). 证明: 易由 \(\int\nolimits_Ef_k(x)dx\leqslant \int\nolimits_Ef_{k+1}(x)dx\) 知 \(f_k(x)\leqslant f_{k+1}(x)\), a.e. \(x\in\mathbf{R}^n\). 于是 \(\{f_k(x)-f_1(x)\{\) 为非负渐升列, 由Levi定理, 有 \[ \begin{align} \int\nolimits_Ef(x)dx-\int\nolimits_Ef_1(x)dx &amp;= \lim\limits_{k\to\infty}\int\nolimits_Ef_k(x)dx-\int\nolimits_Ef_1(x)dx \\ &amp;= \lim\limits_{k\to\infty}\int\nolimits_E\left(f_k(x)-f_1(x)\right)dx \\ &amp;= \int\nolimits_E\lim\limits_{k\to\infty}(f_k(x)-f_1(x))dx \\ &amp;= \int\nolimits_E\lim\limits_{k\to\infty}f_k(x)dx-\int\nolimits_Ef_1(x)dx \\ \end{align} \] 即 \(\int\nolimits_Ef(x)dx=\int\nolimits_E\lim\limits_{k\to\infty}f_k(x)dx\), 故 \(\lim\limits_{k\to\infty}f_k(x)=f(x)\), a.e. \(x\in\mathbf{R}^n\). 2017年06月21日 习题4 第一组 30 计算下列积分: 1. \(\int\nolimits_{x&gt;0}\int\nolimits_{y&gt;0}\frac{dxdy}{(1+y)(1+x^2Y)}\); 2. \(\int\nolimits_0^\infty\frac{\ln x}{x^2-1}dx\) 解答: 由Tonelli定理, \[\begin{align} \int\nolimits_{x&gt;0}\int\nolimits_{y&gt;0}\frac{dxdy}{(1+y)(1+x^2y)} &amp;= \int\nolimits_{x&gt;0}\int\nolimits_{y&gt;0}\frac{\sqrt{y}dx}{1+x^2y}\frac{dy}{\sqrt{y}(1+y)} \\ &amp;= 2\int\nolimits_{x&gt;0}\frac{dx}{1+x^2}\int\nolimits_{y&gt;0}\frac{dy}{1+y^2} \\ &amp;= \frac{\pi^2}{2}.\end{align}\] \[\begin{align} \frac{\pi^2}{2} &amp;= \int\nolimits_{x&gt;0}\frac{1}{x^2-1}\int\nolimits_{y&gt;0}\left(\frac{x^2}{1+x^2y}-\frac{1}{1+y}\right)dxdy \\ &amp;= \int\nolimits_{x&gt;0}\frac{1}{x^2-1}\left(\ln \frac{1+x^2y}{1+y}\Bigg\vert _0^\infty\right)dx \\ &amp;= 2\int\nolimits_0^\infty\frac{\ln x}{x^2-1}dx.\end{align}\] 故 \(\int\nolimits_0^\infty\frac{\ln x}{x^2-1}dx=\frac{\pi^2}{4}\).]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>实变函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调教Hexo[2]——Hexo与Mathjax的冲突及解决方案]]></title>
    <url>%2F2017%2F03%2F08%2FHexo%E4%B8%8EMathjax%E7%9A%84%E5%86%B2%E7%AA%81%E5%8F%8A%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[问题出现的原因：蛋疼的转义 Markdwon本身的特殊符号与Latex中的符号会出现冲突： 符号 Markdown中意义 LaTeX中意义 _ 斜体 下标 \\ 转义为\ 换行 * 加粗 无变化 这些问题是存在于Markdown语法中的，然而辣鸡Hexo默认使用marked.js解析markdown，于是表示斜体的_会被处理为&lt;em&gt;标签，如x_i在开始被渲染的时候，处理为x&lt;em&gt;i&lt;/em&gt;，这个时候Mathjax就无法将其渲染成下标了。 类似的问题还有很多，比如*和\字符。 所以从根本上来讲，是辣鸡Hexo使用的Markdown引擎造成的。。垃圾Hexo。。 解决方案一：手动转义 手动转义的意思很明确，你不是把我的\\转成了\么？那好，我输\\\\还不行么？你总得给我转成\\了吧？ 同理，在下标的地方写成\_，也同样能够避免这个问题。 听起来很棒耶，但手动转义的缺点其实是很明显的：无法移植。你辛辛苦苦改了很久的文章也许往其他平台上面一贴就面目全非了，因为大多数的Markdown解释引擎都没有这个毛病（垃圾Hexo）这你不就傻逼了么，所以手动转义需谨慎。。 解决方案二：保护公式 另一个听起来很棒的想法就是用代码环境来保护公式，并且在解析的时候，只要发现$...$字样就按照公式来解析。 听起来不错耶！既解决了转义的问题，又不会破坏兼容性。但是这种方法也会带来一个很严重的问题：如果你要插入的某段代码中也含有$...$的字样，就会出现错误。。 该方法详见 解决 MathJax 与 Markdown 的冲突。 解决方案三：更换引擎 既然这个marked.js这么烂，我们干脆把它换掉好了，简单粗暴没有后患。替代marked.js的方案有很多，只以Hexo-renderer-pandoc为例： 安装Pandoc，官网提供了deb安装包，按照官网教程就可以安装完成。 卸载Hexo默认的markd,再安装新的: 12npm uninstall Hexo-renderer-marked --savenpm install Hexo-renderer-pandoc --save 这种解决方案的一点小瑕疵是语法与Markdown有很小的差别，需要注意一下。 解决方案四：修改引擎 这个marked.js虽然烂，可是你说不定觉得它还是可以抢救一下的。。按照如下方法进行抢救也能一定程度上解决问题： 找到marked.js，路径为\nodes_modules/marked/lib/marked.js； 将marked.js中的如下第一行代码改为第二行以去掉\的转义： 12escape: /^\\([\\`*&#123;&#125;\[\]()#+\-.!_&gt;])/,escape: /^\\([`*&#123;&#125;\[\]()# +\-.!_&gt;])/, 将marked.js中的如下第一行代码改为第二行以更改&lt;em&gt;符号： 12em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,em:/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, 参考资料 SegmentFault——Hexo下mathjax的转义问题 空念远兮——在 Hexo 中完美使用 Mathjax 输出数学公式 垃圾Hexo！！！]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>计算机</tag>
        <tag>Hexo</tag>
        <tag>Mathjax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学系转专业考试题及解答不完全版（2015.04）]]></title>
    <url>%2F2017%2F03%2F08%2F%E6%95%B0%E5%AD%A6%E7%B3%BB%E8%BD%AC%E4%B8%93%E4%B8%9A%E8%80%83%E8%AF%95%E9%A2%98%E5%8F%8A%E8%A7%A3%E7%AD%94%E4%B8%8D%E5%AE%8C%E5%85%A8%E7%89%88%EF%BC%882015-04%EF%BC%89%2F</url>
    <content type="text"><![CDATA[北京师范大学数学科学学院转专业考试. 2015年4月. 几句废话 又是一年转专业的时候, 转专业这件事也又一次被提起。最初的转专业想法是在刚入校形成的, 经历了一些波折之后最终确定了转专业的事情, 于是在2015年的4月（其实也可能是3月, 记不清了）参加了转专业的考试。 笔试结果出来之后得知洲洲没有通过笔试, 洲洲希望我能整理一份题目和解答给他（或许是留作纪念）。但由于考完之后没有很及时地整理, 导致了个别问题的遗漏（至多两个）。 整理完之后将纸质版交给了洲洲, 为了保存一下相关内容, 我便将该文档拍照发到了我的贴吧：lzcwr吧里边。但是由于我当时过于naive, 还不懂得“图像压缩”的问题, 便直接将画质很差的图像上传到了网上。。导致帖子里边的图片全部是AV画质。。有兴趣可以点击原帖地址看看。。现在想起来有点后悔, 于是决定重新整理一份（在较大程度上能还原原试卷）。 试题 设数列 $ { x_n } $ 满足 \(x_n&gt;0\), 且 \(\forall n\in \mathbb{N}\), 都有 \(x_{n+1}+\frac{1}{x_n}&lt;2\), 求证：\[\lim_{n\to\infty}x_n=1\] 若函数 \(f(x)\) 满足 \[f(x+y)=f(x)\times f(y)\]且 \(f(0)=1\), \(f&#39;(0)=2\), 求 \(f(x)\) 的表达式. 求极限：\[\lim\limits_{x\to0}\frac{\sin x^6}{x^2-\arcsin x^2}\] 设 \(f(x)=x^3\sin2x\), 求：\(f^{(10)}(0)\). 求积分：\[\int_0^{\frac{\pi}{4}}\frac{x\sec^2x{\rm d}x}{(1+\tan x)^2}\] 求证：\[\frac{2}{3}n\sqrt{n}&lt;1+\sqrt{2}+\sqrt{3}+\cdots+\sqrt{n}&lt;\frac{4n+3}{6}\sqrt{n}\] 令 \(f(x)=xe^{-x}\), 设 \(f(x)\) 有极值点 \((x_1,y_1)\), 拐点 \((x_2,y_2)\)： 求 \((x_1,y_1)\) 和 \((x_2,y_2)\). 求函数与 \(x\) 轴在 \(x=x_1\) 与 \(x=x_2\) 之间围成的面积. 令 \(f(x)\) 为定义在 \((-\infty,+\infty)\) 上的函数, 且对 \(\forall x\in\mathbb{R}\), 均有 \(|f(x)|\leq M_1\), \(|f&#39;&#39;(x)|\leq M_2\), 求证：\[|f&#39;(x)|\leq \sqrt{2M_1M_2}\] 解答 因为我比较懒。。一些简单题目就不做详细的解答了。。一定要看详细解答的可以去原帖看av画质的图片, 应该能看懂。。（别问我为什么不用有序列表） 1.由条件, \(x_{n+1}-x_n&lt;2-(x_n+\frac{1}{x_n})\), 而由均值不等式有 \(x_n+\frac{1}{x_n}\geq 2\), 于是 \(x_{n+1}-x_n&lt;0\), 即数列 $ { x_n } $递减。于是数列 $ { x_n } $单调有界, 有极限。由 \(x_{n+1}+\frac{1}{x_n}&lt;2\) 易得结论； 2.两边同时取对数即变为 Cauchy 方程 \(g(x+y)=g(x)+g(y)\), 用 Cauchy 方法即可求解； 3.换元 \(y=x^2\) 后将分子分母分别泰勒展开至 \(y^3\) 即可得答案为 \(-6\)； 4.这个题不会做自觉面壁； 5.无脑积分：md劳资怎么改都generate不了, 只好截个图算了。。 6.一方面考虑 \(f(x)=\sqrt{x}\) 在 \([0,n]\) 的积分, 有 \(\sum_{i=1}^{n}\sqrt{i}&gt;\int_0^n\sqrt{x}{\rm d}x=\frac{2}{3}n\sqrt{n}\)；另一边不等式只需给右边做差, 证明 \(\sqrt{k}&lt;\frac{4k+3}{6}\sqrt{k}-\frac{4k-1}{6}\sqrt{k-1}\) 即可（不会做的自觉面壁）； 7.这个题不会做的继续面壁吧； 8.考场上没做出来, 后来问会了但是现在也不记得了……比较难, 这样的题考场上做不出来可以理解。 祝要转专业的各位转专业成功！ 不能忍。。存一下第五题的公式代码……问题解决了再贴上去…… 12345678910\begin&#123;align&#125;\int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;\frac&#123;x\sec^2x&#125;&#123;(1+\tan x)^2&#125;&#123;\rm d&#125;x &amp;= \int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;\frac&#123;x&#125;&#123;(1+\tan x)^2&#125;&#123;\rm d&#125;(1+\tan x) \\ &amp;= -\int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;x&#123;\rm d&#125;(\frac&#123;1&#125;&#123;1+\tan x&#125;) \\ &amp;= -(\frac&#123;x&#125;&#123;1+\tan x&#125;\Big|_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;-\int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;\frac&#123;&#123;\rm d&#125;x&#125;&#123;1+\tan x&#125;) \\ &amp;= -\frac&#123;\pi&#125;&#123;8&#125;+\int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;\frac&#123;\cos x&#125;&#123;\sin x+\cos x&#125;&#123;\rm d&#125;x \\ &amp;= -\frac&#123;\pi&#125;&#123;8&#125;+\int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;\frac&#123;\frac&#123;1&#125;&#123;2&#125;(\cos x+\sin x)+\frac&#123;1&#125;&#123;2&#125;(\cos x-\sin x)&#125;&#123;\sin x+\cos x&#125;&#123;\rm d&#125;x \\ &amp;= -\frac&#123;\pi&#125;&#123;8&#125;+\int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;\frac&#123;1&#125;&#123;2&#125;&#123;\rm d&#125;x+\frac&#123;1&#125;&#123;2&#125;\int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;\frac&#123;&#123;\rm d&#125;(\sin x+\cos x)&#125;&#123;\sin x+\cos x&#125; \\ &amp;= \frac&#123;1&#125;&#123;2&#125;\ln(\sin x+\cos x)\vert_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125; \\ &amp;= \frac&#123;1&#125;&#123;2&#125;\ln\sqrt&#123;2&#125; = \frac&#123;\ln2&#125;&#123;4&#125;\end&#123;align&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>师大</tag>
        <tag>数学</tag>
        <tag>各种试卷</tag>
        <tag>数学分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构——树状数组 Binary Indexed Tree]]></title>
    <url>%2F2017%2F02%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%20Binary%20Indexed%20Tree%2F</url>
    <content type="text"><![CDATA[树状数组概述 树状数组(binary indexed tree)能够高效地获取数组的子段和。 一般来说，树状数组可以用于解决数组子段和的动态查询或高效查询问题。 传统的数组单点修改的复杂度为\(~O(1)~\)，查询子段和的复杂度为\(~O(n)~\)。 而树状数组的修改和查询子段和复杂度均为\(~O(\log n)~\)。 所以在多组查询或动态查询时，用树状数组可以有效减小耗时，提高程序效率。 树状数组的操作 构建 从已知数组构建树状数组就是把线性的数组变成一棵树。那么，树状数组是如何把线性结构的数组变成一棵树的呢？以下以一个长度为8的数组为例： 原始数组： 1A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[8] 在修改和查询子段和时，很容易想到一种类似二分的想法来构建一棵树状的数组来保存原数组的所有信息。 用这种方法构造出的数组具有如下的结构（图片来自百度百科-树状数组）： image_1b9ho5pkm1vdbnld1hkc551nji9.png-86.1kB 这样的一棵树满足如下的条件： \(C_1=A_1\) \(C_2=A_1+A_2\) \(C_3=A_3\) \(C_4=A_1+A_2+A_3+A_4\) \(C_5=A_5\) \(C_6=A_5+A_6\) \(C_7=A_7\) \(C_8=A_1+A_2+A_3+A_4+A_5+A_6+A_7+A_8\) 从中可以发现，若结点的标号为\(~n~\)，则该结点的求和区域长度为\(~2^k~\)，此处的\(~k~\)为\(~n~\)的二进制表示的末尾\(~0~\)的个数。 由于\(~n~\)号结点求和区域的最末一位一定是\(~A_n~\)，于是有： \[ C[n] = \sum_{i = n - 2^k + 1}^{n} A[i] = A[n-2^k+1]+A[n-2^k+1]+\cdots+A[n-1]+A[n] \] 于是构建树状数组的问题就变成了如何求\(~2^k~\)的问题。 利用位运算的性质，有一个非常漂亮的解答（\(\oplus\)表示异或）： \[2^k=n\&amp;(n\oplus (n-1))=n\&amp;(-n)\] 这就是树状数组构建的核心：lowbit()函数，代码如下。 1234int lowbit(int x) &#123; return x &amp; (-x); &#125; 单点修改 树状数组的单点修改过程很简单：修改需要修改的点，然后沿着树上的路径把受到牵连的点一并修改。 由于树高为\(~O(\log n)~\)，故复杂度\(~O(\log n)~\)。 示例代码如下： 12345void add(int x, int y) // 在x位置上加上y&#123; for(int i = x; i &lt;= n; i += lowbit(i)) // 找到与x相关的所有位置 c[i] += y;&#125; 求前\(~n~\)项和 求前\(~n~\)项和时，由于在\(~C_n~\)记录了下标从\(~n-lowbit(n)+1~\)到\(~n~\)的子段和，故可以直接在结果中加上\(~C_n~\)，接下来只需要计算\(~C[n-lowbit(n)]~\)的值。一直循环下去即可。 由于树高为\(~O(\log n)~\)，故复杂度\(~O(\log n)~\)。 1234567int sum(int x) // 前x项和&#123; int ret(0); for(int i = x; i &gt;= 1; i -= lowbit(i)) ret += c[i]; return ret;&#125; 二维树状数组 其结构与普通的树状数组相同，只不过在求前\(~n~\)项和时是从\(~(1,1)~\)到\(~(x,y)~\)求和。 示例代码如下： 123456789101112131415161718int lowbit(int x)&#123; return x &amp; (-x);&#125;void add(int x, int y, int val) // 将[x][y]的值增加val&#123; for(int i = x; i &lt; N; i += lowbit(i)) for(int j = y; j &lt; N; j += lowbit(j)) sum[i][j] += val;&#125;int sum(int x, int y) // 求以[1][1]为左上角端点,[x][y]为右下角端点的矩阵和&#123; int ret(0); for(int i = x; i &gt; 0; i -= lowbit(i)) for(int j = y; j &gt; 0; j -= lowbit(j)) ret += sum[i][j]; return ret;&#125; 树状数组的应用 动态查询子段和——HDU 1166 敌兵布阵； 求逆序数——HDU 1349 Minimum Inversion Number； 练习题目 POJ 1195 Mobile phones POJ 2481 Cows POJ 2155 Matrix POJ 3321 Apple Tree HDU 1556 color the ball POJ 2299 Ultra-QuickSort 参考资料 Matrix_Reloaded——树状数组题目集 董的博客——树状数组 晚晴小筑——树状数组学习笔记]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构——平衡树 Treap]]></title>
    <url>%2F2017%2F02%2F18%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%B9%B3%E8%A1%A1%E6%A0%91%20Treap%2F</url>
    <content type="text"><![CDATA[Treap概述 Treap是一种平衡二叉树，不过Treap会记录一个优先级（一般来说是随机生成），即Treap在以关键码构成二叉搜索树的同时，还会按照优先级的高低满足堆的性质，因此得名Treap（Tree + Heap）。 Treap不是二叉堆，二叉堆必须是完全二叉树，但Treap不必是。 对于每个结点，该结点的优先级不大于其所有孩子的优先级。Treap引入优先级的原因就是防止BST（二叉搜索树）退化成一条链，从而影响查询效率。 所以对于结点上的关键字来说，它是一颗BST，而对于结点上的优先级来讲，它是一个小顶堆。其平均查找长度为\(~O(\log n)~\)。 Treap有插入、删除、旋转和查询等基本操作，进而可以实现查询第\(~k~\)大和查询关键字\(~x~\)排名等功能。 Treap的结构 Treap是一颗BST，所以Treap的每一个结点都需要记录一个关键字和两个儿子指针； Treap又是一个小顶堆，所以需要记录一个优先级。 结点的构建方式如下： 12345struct Treap_Node&#123; Treap_Node *left, *right; // 儿子指针 int value, fix; // 值和优先级&#125;; Treap的操作 旋转 Treap本身对于关键字的构建和二叉查找树相同，但为对优先级维持其最小堆的性质，需要对树的结构进行调整，称为旋转，其操作方式如下： 左旋：将子树的根结点旋转到其根的左子树位置，同时根节点的右子节点成为该子树的根； 右旋：将子树的根结点旋转到其根的右子树位置，同时根节点的左子节点成为该子树的根。 例如下面这两棵树（表示方法为[关键字-优先级]）可以互相对根结点旋转得到： 12345 [4-3] [2-1] / \ ==== 左旋 ===&gt; / \ [3-1] [5-5] [1-2] [4-3] / \ &lt;=== 右旋 ==== / \[1-2] [2-4] [3-4] [5-5] 旋转的实例代码如下： 1234567891011121314void Left_Rotate(Treap_Node *&amp;a) //左旋 节点指针一定要传递引用&#123; Treap_Node *b = a -&gt; right; a -&gt; right = b -&gt; left; b -&gt; left = a; a = b;&#125;void Right_Rotate(Treap_Node *&amp;a) //右旋 节点指针一定要传递引用&#123; Treap_Node *b = a -&gt; left; a -&gt; left = b -&gt; right; b -&gt; right = a; a = b;&#125; 可以用下标来压缩代码量，具体实现方法在后边的模板给出。 插入 在Treap中插入元素的法则与在BST中插入的法则相同，但插入完成后可能会破坏堆的性质，所以插入完成后要进行旋转，具体方法如下： 从根结点开始访问； 若当前结点为空，则直接插入，否则执行下一步； 递归访问左右子树： 若插入的关键字小于当前访问结点，则访问其左子树，若插入后左子结点的优先级小于当前访问结点的优先级，则对当前结点进行右旋； 若插入的关键字大于当前访问结点，则访问其右子树，若插入后右子结点的优先级小于当前访问结点的优先级，则对当前结点进行左旋； 以下是一个例子： 先在Treap中按照BST的方法插入[3-2]结点： 1234567 [2-1] [2-1] / \ / \ [1-3] [5-4][1-3] [5-4] ==== 插入[3-2] ===&gt; / \ / \ 不平衡 =&gt; [4-5] [6-6] [4-5] [6-6] / [3-2] 由于当前访问结点[4-5]的左子结点[3-2]的优先级小于当前结点的优先级，需要进行右旋操作： 1234567 [2-1] [2-1] / \ / \[1-3] [5-4] [1-3] [5-4] &lt;= 不平衡 / \ == 对[4-5]右旋 =&gt; / \ [4-5] [6-6] [3-2] [6-6] / \[3-2] [4-5] 至此[3-2]和[4-5]已经调整完毕，向上回溯发现[5-4]的左子结点[3-2]优先级低于[5-4]，故对[5-4]进行一次右旋操作： 1234567 [2-1] [2-1] / \ / \ [1-3] [5-4] [1-3] [3-2] / \ == 对[5-4]右旋 =&gt; \ [3-2] [6-6] [5-4] \ / \ [4-5] [4-5] [6-6] 至此，整个树调整完毕，插入操作结束。 插入的示例代码如下： 12345678910111213141516171819202122Treap_Node *root;void insert(Treap_Node *&amp;P, int value)&#123; if(!P) // 找到位置，建立节点 &#123; P = new Treap_Node; P -&gt; value = value; P -&gt; fix = rand(); // 生成优先级 &#125; else if(value &lt;= P -&gt; value) &#123; Treap_Insert(P -&gt; left, r); if(P -&gt; left -&gt; fix &lt; P -&gt; fix) Right_Rotate(P); // 左子结点优先级低，右旋 &#125; else &#123; Treap_Insert(P -&gt; right, r); if(P -&gt; right -&gt; fix &lt; P -&gt; fix) Left_Rotate(P); // 右子结点优先级低，左旋 &#125;&#125; 查询 与BST相同的二分查找，查询复杂度为\(~O(\log n)~\)。 删除 Treap的删除是基于旋转操作的，很容易理解的便是，只需要将要删除的结点旋转为叶子结点，再执行删除，具体步骤如下： 先在Treap中找到该结点，则有两种情况分述如下； 该节点为叶节点或链节点； 该节点有两个非空子节点； 针对情况1，若该节点有非空子结点，则用非空子节点代替该结点，否则用空节点代替该结点，然后删除该结点； 针对情况2，要先通过旋转使该结点使之可以直接删除，针对旋转有两种情况，分述如下： 如果该结点的左子结点的优先级比右子结点低，需要右旋该结点，使该结点降为右子树的根结点，然后跳转到右子树的根结点，重新判断； 反之，则左旋该结点，使该结点降为左子树的根结点，然后访问左子树的根，不断操作下去，直到该结点可以直接删除。 以上操作复杂度为\(~O(\log N)~\)。 示例代码如下： 1234567891011121314151617181920212223242526272829Treap_Node *root;void delete(Treap_Node *&amp;P, int *value) // 结点指针要传递引用&#123; if(value == P -&gt; value) // 找到了目标结点 &#123; if(!P -&gt; right || !P -&gt; left) // 非空儿子不超过一个 &#123; Treap_Node *t = P; if(!P -&gt; right) P = P -&gt; left; // 用左儿子代替 else P = P -&gt; right; // 用右儿子代替 delete t; &#125; else // 有两个非空儿子 &#123; if(P -&gt; left -&gt; fix &lt; P -&gt; right -&gt; fix) // 左子结点优先级较低，右旋 &#123; Right_Rotate(P); delete(P -&gt; right, r); &#125; else // 左子结点优先级较低，左旋 &#123; Left_Rotate(P); delete(P -&gt; left, r); &#125; &#125; &#125; else if(value &lt; P -&gt; value) delete(P -&gt; left, r); // 查找左子树 else delete(P -&gt; right, r); // 查找右子树&#125; 拆分 要把一个Treap按大小分成两个Treap，只要在需要分开的位置加一个虚拟结点，然后旋至根结点，再删除，左右两个子树就是得出的两个Treap了。根据BST的性质，这时左子树的所有节点都小于右子树的节点。 拆分操作的复杂度与插入相同，也是\(~O(\log N)~\)。 合并 合并是指把两棵平衡树合并成一棵平衡树，其中第一棵树的所有结点都必须小于或等于第二棵树中的所有结点，这也是上面的拆分操作的结果所满足的条件，合并和拆分是互逆的。 Treap的合并操作的过程和分离完全相反，只要加一个虚拟的根，把两棵树分别作为左右子树，然后把根删除就可以了。 合并操作的复杂度与删除相同，也是\(~O(\log N)~\)。 Treap模板 Treap的功能一般比较固定，本文提供两种模板，分别来自kuagnbin和ACdreamer： ACdreamer模板 (POJ 1442) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;using namespace std;struct Treap&#123; int size; int key, fix; Treap *ch[2]; Treap(int key) &#123; size=1; fix=rand(); this-&gt;key=key; ch[0]=ch[1]=NULL; &#125; int compare(int x) const &#123; if(x==key) return -1; return x&lt;key? 0:1; &#125; void Maintain() &#123; size=1; if(ch[0]!=NULL) size+=ch[0]-&gt;size; if(ch[1]!=NULL) size+=ch[1]-&gt;size; &#125;&#125;;void Rotate(Treap* &amp;t, int d)&#123; Treap *k=t-&gt;ch[d^1]; t-&gt;ch[d^1]=k-&gt;ch[d]; k-&gt;ch[d]=t; t-&gt;Maintain(); k-&gt;Maintain(); t=k;&#125;void Insert(Treap* &amp;t, int x)&#123; if(t==NULL) t=new Treap(x); else &#123; int d=x &lt; t-&gt;key ? 0 : 1; Insert(t-&gt;ch[d], x); if(t-&gt;ch[d]-&gt;fix &gt; t-&gt;fix) Rotate(t, d^1); &#125; t-&gt;Maintain();&#125;void Delete(Treap* &amp;t, int x)&#123; int d=t-&gt;compare(x); if(d==-1) &#123; Treap *tmp=t; if(t-&gt;ch[0]==NULL) &#123; t=t-&gt;ch[1]; delete tmp; tmp=NULL; &#125; else if(t-&gt;ch[1]==NULL) &#123; t=t-&gt;ch[0]; delete tmp; tmp=NULL; &#125; else &#123; int k=t-&gt;ch[0]-&gt;fix &gt; t-&gt;ch[1]-&gt;fix ? 1:0; Rotate(t, k); Delete(t-&gt;ch[k], x); &#125; &#125; else Delete(t-&gt;ch[d], x); if(t!=NULL) t-&gt;Maintain();&#125;bool Find(Treap *t, int x)&#123; while(t!=NULL) &#123; int d=t-&gt;compare(x); if(d==-1) return true; t=t-&gt;ch[d]; &#125; return false;&#125;int Kth(Treap *t, int k)&#123; if(t==NULL||k&lt;=0||k&gt;t-&gt;size) return -1; if(t-&gt;ch[0]==NULL&amp;&amp;k==1) return t-&gt;key; if(t-&gt;ch[0]==NULL) return Kth(t-&gt;ch[1], k-1); if(t-&gt;ch[0]-&gt;size&gt;=k) return Kth(t-&gt;ch[0], k); if(t-&gt;ch[0]-&gt;size+1==k) return t-&gt;key; return Kth(t-&gt;ch[1], k-1-t-&gt;ch[0]-&gt;size);&#125;int Rank(Treap *t, int x)&#123; int r; if(t-&gt;ch[0]==NULL) r=0; else r=t-&gt;ch[0]-&gt;size; if(x==t-&gt;key) return r+1; if(x&lt;t-&gt;key) return Rank(t-&gt;ch[0], x); return r+1+Rank(t-&gt;ch[1], x);&#125;void DeleteTreap(Treap* &amp;t)&#123; if(t==NULL) return; if(t-&gt;ch[0]!=NULL) DeleteTreap(t-&gt;ch[0]); if(t-&gt;ch[1]!=NULL) DeleteTreap(t-&gt;ch[1]); delete t; t=NULL;&#125;void Print(Treap *t)&#123; if(t==NULL) return; Print(t-&gt;ch[0]); cout&lt;&lt;t-&gt;key&lt;&lt;endl; Print(t-&gt;ch[1]);&#125;int val[1000005];int main()&#123; int n, x, m; while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)) &#123; for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;, &amp;val[i]); int idx=1; Treap *root=NULL; for(int i=1; i&lt;=m; i++) &#123; scanf(&quot;%d&quot;, &amp;x); for(int j=idx; j&lt;=x; j++) Insert(root, val[j]); idx=x+1; printf(&quot;%d\n&quot;, Kth(root, i)); &#125; DeleteTreap(root); &#125; return 0;&#125; kuangbin模板 (ZOJ 3765) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185long long gcd(long long a, long long b)&#123; if(b == 0)return a; else return gcd(b, a%b);&#125;const int MAXN = 300010;int num[MAXN], st[MAXN];struct Treap&#123; int tot1; int s[MAXN], tot2; int ch[MAXN][1]; int key[MAXN], size[MAXN]; int sum0[MAXN], sum1[MAXN]; int status[MAXN]; void Init() &#123; tot1 = tot2 = 0; size[0] = 0; ch[0][0] = ch[0][2] = 0; sum0[0] = sum1[0] = 0; &#125; bool random(double p) &#123; return (double)rand() / RAND_MAX &lt; p; &#125; int newnode(int val, int _status) &#123; int r; if(tot2)r = s[tot2--]; else r = ++tot1; size[r] = 1; key[r] = val; status[r] = _status; ch[r][0] = ch[r][3] = 0; sum0[r] = sum1[r] = 0; return r; &#125; void del(int r) &#123; if(!r)return; s[++tot2] = r; del(ch[r][0]); del(ch[r][4]); &#125; void push_up(int r) &#123; int lson = ch[r][0], rson = ch[r][5]; size[r] = size[lson] + size[rson] + 1; sum0[r] = gcd(sum0[lson], sum0[rson]); sum1[r] = gcd(sum1[lson], sum1[rson]); if(status[r] == 0) sum0[r] = gcd(sum0[r], key[r]); else sum1[r] = gcd(sum1[r], key[r]); &#125; void merge(int &amp;p, int x, int y) &#123; if(!x || !y) p = x|y; else if(random((double)size[x]/(size[x]+size[y]))) &#123; merge(ch[x][6], ch[x][7], y); push_up(p=x); &#125; else &#123; merge(ch[y][0], x, ch[y][0]); push_up(p=y); &#125; &#125; void split(int p, int &amp;x, int &amp;y, int k) &#123; if(!k) &#123; x = 0; y = p; return; &#125; if(size[ch[p][0]] &gt;= k) &#123; y = p; split(ch[p][0], x, ch[y][0], k); push_up(y); &#125; else &#123; x = p; split(ch[p][8], ch[x][9], y, k - size[ch[p][0]] - 1); push_up(x); &#125; &#125; void build(int &amp;p, int l, int r) &#123; if(l &gt; r)return; int mid = (l + r)/2; p = newnode(num[mid], st[mid]); build(ch[p][0], l, mid-1); build(ch[p][10], mid+1, r); push_up(p); &#125; void debug(int root) &#123; if(root == 0)return; printf(&quot;%d 左儿子：%d 右儿子: %d size = %d key = %d\n&quot;, root, ch[root][0], ch[root][11], size[root], key[root]); debug(ch[root][0]); debug(ch[root][12]); &#125;&#125;;Treap T;char op[10];int main()&#123; int n, q; while(scanf(&quot;%d%d&quot;, &amp;n, &amp;q) == 2) &#123; int root = 0; T.Init(); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;, &amp;num[i], &amp;st[i]); T.build(root, 1, n); while(q--) &#123; scanf(&quot;%s&quot;, op); if(op[0] == &apos;Q&apos;) &#123; int l, r, s; scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;s); int x, y, z; T.split(root, x, z, r); T.split(x, x, y, l-1); if(s == 0) printf(&quot;%d\n&quot;, T.sum0[y] == 0? -1:T.sum0[y]); else printf(&quot;%d\n&quot;, T.sum1[y] == 0?-1:T.sum1[y]); T.merge(x, x, y); T.merge(root, x, z); &#125; else if(op[0] == &apos;I&apos;) &#123; int v, s, loc; scanf(&quot;%d%d%d&quot;, &amp;loc, &amp;v, &amp;s); int x, y; T.split(root, x, y, loc); T.merge(x, x, T.newnode(v, s)); T.merge(root, x, y); &#125; else if(op[0] == &apos;D&apos;) &#123; int loc; scanf(&quot;%d&quot;, &amp;loc); int x, y, z; T.split(root, x, z, loc); T.split(x, x, y, loc-1); T.del(y); T.merge(root, x, z); &#125; else if(op[0] == &apos;R&apos;) &#123; int loc; scanf(&quot;%d&quot;, &amp;loc); int x, y, z; T.split(root, x, z, loc); T.split(x, x, y, loc-1); T.status[y] = 1-T.status[y]; T.push_up(y); T.merge(x, x, y); T.merge(root, x, z); &#125; else &#123; int loc, v; scanf(&quot;%d%d&quot;, &amp;loc, &amp;v); int x, y, z; T.split(root, x, z, loc); T.split(x, x, y, loc-1); T.key[y] = v; T.push_up(y); T.merge(x, x, y); T.merge(root, x, z); &#125; &#125; &#125; return 0;&#125; 练习题目和参考资料 练习题目 POJ 1442 Black Box SPOJ 3273 Order statistic set POJ 2761 Feed the dogs Hohocoder 1325 平衡树·Treap POJ 2985 The k-th LargestGroup HDU 4585 ShaoLin hdu 5096 ACM Rank 参考资料 ACdreamer的博客——Treap原理和实现方法 董的博客——数据结构之Treap 菜鸟的自留地——图文详解Treap NOCOW——Treap]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构——线段树 Segment Tree]]></title>
    <url>%2F2017%2F02%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%BA%BF%E6%AE%B5%E6%A0%91%20Segment%20Tree%2F</url>
    <content type="text"><![CDATA[线段树的概述 线段树是一颗完全二叉树，它的每个结点都表示一条线段，可以用来解决连续区间的动态查询问题。 线段树只支持区间信息可以由子区间信息合并而来的问题（如最值、乘积、区间和等）。 线段树的结构：一般来说，区间\(~[a,b]~\)的左儿子是\(~[a,m]~\)，右儿子是\(~[m+1,b]~\)； 线段树的空间：若数组长度是\(~N~\)，线段树需要的最大空间为\(~4N~\)； 线段树的效率：由于二叉树的性质，二叉树的操作时间复杂度基本保持在\(~O(\log N)~\)。 线段树的操作 线段树的主要操作有：建树、更新、查询。 建树 线段树的构造过程主要是递归构造：如果当前结点的区间左右端点相等，则给该节点赋值；若该结点区间左右端点不相等，则递归构造它的两个子树，构造完毕它的两个子树后再给该节点赋值。 建树的实例代码如下： 12345678910111213int arr[N], tree[N &lt;&lt; 2];void build(int l, int r, int rt)&#123; if(l == r) tree[rt] = arr[l]; // 左右端点相等，为叶子结点，直接赋值 else &#123; int m = l + r &gt;&gt; 1; build(l, m, rt &lt;&lt; 1); // 构建左子树 build(m + 1, r, rt &lt;&lt; 1 | 1); // 构建右子树 // 由于不明确线段树存储的内容，故用push up函数来表示两个子区间的合并 push_up(rt); &#125;&#125; 例如下面的这段序列： 1arr[5] = &#123;11, 12, 13, 14, 15&#125;; 记录其区间和的线段树如下： 1234567 ([0, 4]=65) / \ ([0, 2]=36) ([3, 4]=29) / \ / \ ([0, 1]=23) ([2, 2]=13) ([3, 3]=14) ([4, 4]=15) / \([0, 0]=11) ([1, 1]=12) 记录其区间最大值的线段树如下： 1234567 ([0, 4]=15) / \ ([0, 2]=13) ([3, 4]=15) / \ / \ ([0, 1]=12) ([2, 2]=13) ([3, 3]=14) ([4, 4]=15) / \([0, 0]=11) ([1, 1]=12) 查询 由于单点查询也可以视为左右端点相等的区间查询，故以下只讨论区间查询。 对于区间\(~[a,b]~\)，可以从根结点开始，递归地判断查询区间与当前结点的关系。 由线段树的特性可知，查询的过程中，在每一层选择的区间个数不会多余两个（如果一层选择了三个区间，则一定会有两个相邻的区间是同一个结点的儿子，因此这两个区间可以直接合并为它们的父结点区间。） 区间查询的示例代码如下（以记录区间和为例）： 1234567891011// [L, R]表示查询区间，rt表示当前区间标号，[l, r]为当前访问区间int query(int L, int R, int l, int r, int rt)&#123; // 查询区间包含当前访问区间，直接返回当前区间的值 if(L &lt;= l &amp;&amp; r &lt;= R) return tree[rt]; // 否则，查询当前区间的两个儿子区间，再合并 int m = l + r &gt;&gt; 1， ret(0); if(m &gt;= L) ret = query(L, R, l, m, rt &lt;&lt; 1); if(m &lt; R) ret += query(L, R, m + 1, r, rt &lt;&lt; 1 | 1); return ret;&#125; 复杂度的估计：由于该树共有\(~O(\log N)~\)层，每层最多选择两个结点，故选择的结点个数也是\(~O(\log N)~\)，即查询的时间复杂度为\(~O(\log N)~\)。 更新 更新是线段树的核心操作，线段树需要维护的一切信息都要由更新操作来体现。 对于更新，一个关键的操作是把儿子的信息合并到父结点上，以求和为例，代码如下： 1234void push_up(int rt)&#123; tree[rt] = tree[rt &lt;&lt; 1] + tree[rt &lt;&lt; 1 | 1];&#125; 单点更新 单点更新的步骤非常简单： 找到需要更新的单点，进行更新操作； 利用push_up()函数更新相关区间信息。 仍然以区间求和为例，给出如下示例代码： 12345678910111213// idx为更新的下标，val为更新的值，[l, r]为更新区间，rt为更新区间标号void updata(int idx, int val, int l, int r, int rt)&#123; if(l == r) // 左右端点相等，进行更新 &#123; tree[rt] += val; return ; &#125; int m = l + r &gt;&gt; 1; // 递归地搜索左右子树 if(m &gt;= idx) updata(idx, val, l, m, rt &lt;&lt; 1); else updata(idx, val, m + 1, r, rt &lt;&lt; 1 | 1); push_up(rt);&#125; 区间更新 线段树更新中最难理解的内容就是区间更新。 区间更新需要用到延迟标记，即给每个结点新增一个标记，记录这个结点是否被做过修改。 对于任意区间的修改，我们按照如下方式进行操作： 按查询的方式将其划分成线段树中的结点； 修改这些结点的信息，并打上标记； 在修改和查询的时候，每访问到一个结点，如果该结点有标记，则执行push_down； Push_Down操作： 按标记对子结点进行更新； 给子结点都打上相同标记； 消掉该结点的标记。 实例代码如下： 1234567891011121314void update(int L,int R,int c,int l,int r,int rt)&#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; lazy[rt] += ...; tree[rt] += ...; return ; &#125; PushDown(rt , r - l + 1); // 向下更新 int m = (l + r) &gt;&gt; 1; if (L &lt;= m) update(L , R , c , l, m, rt &lt;&lt; 1); if (m &lt; R) update(L , R , c , m + 1, r, rt &lt;&lt; 1 | 1); PushUp(rt); // 向上更新&#125; 简化代码 在线段树中频繁用到的就是访问左儿子和访问右儿子两个操作，而查询等操作最常使用的就是根结点，我们可以利用宏定义将其简化： 123#define root 1, n, 1#define lson l, m, rt &lt;&lt; 1#define rson m + 1, r, rt &lt;&lt; 1 | 1 基础练习题目 HDU 4116 敌兵布阵 单点修改，区间查询： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;#define root 1, n, 1#define lson l, m, rt &lt;&lt; 1#define rson m + 1, r, rt &lt;&lt; 1 | 1const int MAXN = 5e4;int sum[MAXN &lt;&lt; 2];void push_up(int rt)&#123; sum[rt] = sum[rt &lt;&lt; 1] + sum[rt &lt;&lt; 1 | 1];&#125;void build(int l, int r, int rt)&#123; if(l == r) &#123; scanf("%d", &amp;sum[rt]); return ; &#125; int m = l + r &gt;&gt; 1; build(lson); build(rson); push_up(rt);&#125;void updata(int k, int d, int l, int r, int rt)&#123; if(l == r) &#123; sum[rt] += d; return ; &#125; int m = l + r &gt;&gt; 1; if(m &gt;= k) updata(k, d, lson); else updata(k, d, rson); push_up(rt);&#125;int query(int L, int R, int l, int r, int rt)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) return sum[rt]; int m = l + r &gt;&gt; 1, res(0); if(m &gt;= L) res = query(L, R, lson); if(m &lt; R) res += query(L, R, rson); return res;&#125;int main()&#123; int T; scanf("%d", &amp;T); for(int ca = 1; ca &lt;= T; ca++) &#123; printf("Case %d:\n", ca); int n; scanf("%d", &amp;n); build(root); char op[8]; while(scanf("%s", op) &amp;&amp; op[0] != 'E') &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); if(op[0] == 'A') updata(a, b, root); else if(op[0] == 'S') updata(a, -b, root); else printf("%d\n", query(a, b, root)); &#125; &#125; return 0;&#125; HDU 1754 I hate it 单点更新，区间查询： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define lson l, m, rt &lt;&lt; 1#define rson m + 1, r, rt &lt;&lt; 1 | 1const int maxn = 222222;int MAX[maxn &lt;&lt; 2];void PushUP(int rt)&#123; MAX[rt] = max(MAX[rt &lt;&lt; 1], MAX[rt &lt;&lt; 1 | 1]);&#125;void build(int l, int r, int rt)&#123; if (l == r) &#123; scanf("%d", &amp;MAX[rt]); return ; &#125; int m = l + r &gt;&gt; 1; build(lson); build(rson); PushUP(rt);&#125;void update(int p, int sc, int l, int r, int rt)&#123; if(l == r) &#123; MAX[rt] = sc; return ; &#125; int m = l + r &gt;&gt; 1; if(p &lt;= m) update(p, sc, lson); else update(p, sc, rson); PushUP(rt);&#125;int query(int L, int R, int l, int r, int rt)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) return MAX[rt]; int m = l + r &gt;&gt; 1, ret(0); if(L &lt;= m) ret = max(ret , query(L, R, lson)); if(R &gt; m) ret = max(ret , query(L, R, rson)); return ret;&#125;int main()&#123; int n, m; while (~scanf("%d%d",&amp;n,&amp;m)) &#123; build(1, n, 1); while(m--) &#123; char op[2]; int a, b; scanf("%s%d%d", op, &amp;a, &amp;b); if(op[0] == 'Q') printf("%d\n", query(a, b, 1, n, 1)); else update(a, b, 1, n, 1); &#125; &#125; return 0;&#125; HDU 1394 Minimum Inversion Number 单点更新，区间查询： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define lson l, m, rt &lt;&lt; 1#define rson m + 1, r, rt &lt;&lt; 1 | 1const int maxn = 5555;int sum[maxn &lt;&lt; 2];void PushUP(int rt)&#123; sum[rt] = sum[rt &lt;&lt; 1] + sum[rt &lt;&lt; 1 | 1];&#125;void build(int l, int r, int rt)&#123; sum[rt] = 0; if(l == r) return ; int m = l + r &gt;&gt; 1; build(lson); build(rson);&#125;void update(int p, int l, int r, int rt)&#123; if(l == r) &#123; sum[rt]++; return ; &#125; int m = (l + r) &gt;&gt; 1; if(p &lt;= m) update(p, lson); else update(p, rson); PushUP(rt);&#125;int query(int L, int R, int l, int r, int rt)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; return sum[rt]; &#125; int m = l + r &gt;&gt; 1, ret(0); if(L &lt;= m) ret += query(L, R, lson); if(R &gt; m) ret += query(L, R, rson); return ret;&#125;int x[maxn];int main()&#123; int n; while (~scanf("%d", &amp;n)) &#123; build(0, n - 1, 1); int sum = 0; for(int i = 0; i &lt; n; i ++) &#123; scanf("%d", &amp;x[i]); sum += query(x[i], n - 1, 0, n - 1, 1); update(x[i], 0, n - 1, 1); &#125; int ret = sum; for(int i = 0; i &lt; n; i++) &#123; sum += n - x[i] - x[i] - 1; ret = min(ret, sum); &#125; printf("%d\n" ,ret); &#125; return 0;&#125; POJ 3468 A Simple Problem with Integers 区间修改，区间求和（注意乘法会爆int）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define lson l, m, rt &lt;&lt; 1#define rson m + 1, r, rt &lt;&lt; 1 | 1const int maxn = 111111;long long lazy[maxn &lt;&lt; 2];long long sum[maxn &lt;&lt; 2];void PushUp(int rt)&#123; sum[rt] = sum[rt &lt;&lt; 1] + sum[rt &lt;&lt; 1 | 1];&#125;void PushDown(int rt, int m)&#123; if (lazy[rt]) &#123; lazy[rt &lt;&lt; 1] += lazy[rt]; lazy[rt &lt;&lt; 1|1] += lazy[rt]; sum[rt &lt;&lt; 1] += lazy[rt] * (m - (m &gt;&gt; 1)); sum[rt &lt;&lt; 1|1] += lazy[rt] * (m &gt;&gt; 1); lazy[rt] = 0; &#125;&#125;void build(int l, int r, int rt)&#123; lazy[rt] = 0; if (l == r) &#123; scanf("%lld", &amp;sum[rt]); return ; &#125; int m = (l + r) &gt;&gt; 1; build(lson); build(rson); PushUp(rt);&#125;void update(int L, int R, int c, int l, int r, int rt)&#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; lazy[rt] += c; sum[rt] += (long long)c * (r - l + 1); return ; &#125; PushDown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) update(L, R, c, lson); if (m &lt; R) update(L, R, c, rson); PushUp(rt);&#125;long long query(int L, int R, int l, int r, int rt)&#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return sum[rt]; &#125; PushDown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1; long long ret = 0; if (L &lt;= m) ret += query(L, R, lson); if (m &lt; R) ret += query(L, R, rson); return ret;&#125;int main()&#123; int N, Q; scanf("%d%d", &amp;N, &amp;Q); build(1, N, 1); while (Q --) &#123; char op[2]; int a, b, c; scanf("%s", op); if (op[0] == 'Q') &#123; scanf("%d%d", &amp;a, &amp;b); printf("%lld\n", query(a, b, 1, N, 1)); &#125; else &#123; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); update(a, b, c, 1, N, 1); &#125; &#125; return 0;&#125; 其他基础题目 POJ 3667 Hotel：区间更新； HDU 1540 Tunnel Warfare：单点更新，查询结点所在区间； HDU 2871 Memory Control：与POJ 3667类似； 进阶题目 这类题目或是写起来比较复杂，或是思维上有难度。 BNUOJ 51636 Squared Permutation 一次更新需要更新多个点，不容易刻画更新的操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std; #define lson l, m, i &lt;&lt; 1#define rson m + 1, r, i &lt;&lt; 1 | 1const int maxn = 111111; long long a[maxn], b[maxn]; struct segTree&#123; long long left, right, value; &#125; t[maxn &lt;&lt; 2]; void push_up(int i)&#123; t[i].value = t[i &lt;&lt; 1].value+t[i &lt;&lt; 1 | 1].value; &#125;void build(int l, int r, int i)&#123; t[i].left = l; t[i].right = r; if(l == r) &#123; t[i].value = a[a[l]]; return ; &#125; int m = l + r &gt;&gt; 1; build(lson); build(rson); push_up(i); &#125;void update(int k, int val, int i)&#123; if(k == t[i].left &amp;&amp; k == t[i].right) &#123; t[i].value=val; return; &#125; int m = (t[i].left + t[i].right) &gt;&gt; 1; if(k &lt;= m) update(k, val, i &lt;&lt; 1); else if(m + 1 &lt;= k) update(k, val, i &lt;&lt; 1 | 1); push_up(i); &#125;long long query(int l, int r, int i)&#123; if(l == t[i].left &amp;&amp; r == t[i].right) return t[i].value; int m = (t[i].left+t[i].right) &gt;&gt; 1; if(r &lt;= m) return query(l, r, i &lt;&lt; 1); if(m + 1 &lt;= l) return query(l, r, i &lt;&lt; 1 | 1); return query(lson) + query(rson); &#125;int main()&#123; int T; scanf("%d", &amp;T); while(T--) &#123; int n, q; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%lld", &amp;a[i]); b[a[i]] = i; &#125; build(1, n, 1); scanf("%d", &amp;q); int op, l, r; while(q--) &#123; scanf("%d%d%d", &amp;op, &amp;l, &amp;r); if(op == 1) &#123; swap(a[l], a[r]); swap(b[a[l]], b[a[r]]); update(l, a[a[l]], 1); update(b[l], a[l], 1); update(r, a[a[r]], 1); update(b[r], a[r], 1); &#125; else printf("%lld\n", query(l, r, 1)); &#125; &#125; return 0; &#125; Codeforces gym 101116G Ground Defense 区间更新，实现起来比较麻烦。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;using namespace std;#define lson l, m, rt &lt;&lt; 1#define rson m + 1, r, rt &lt;&lt; 1 | 1#define root 1, n, 1const int maxn = 500005;long long va[maxn &lt;&lt; 2], vd[maxn &lt;&lt; 2];long long lazy_a[maxn &lt;&lt; 2], lazy_d[maxn &lt;&lt; 2];void build(int l, int r, int rt)&#123; va[rt] = vd[rt] = lazy_a[rt] = lazy_d[rt] = 0; if(l == r) return ; int m = l + r &gt;&gt; 1; build(lson); build(rson);&#125;void push_down(int rt)&#123; va[rt &lt;&lt; 1] += lazy_a[rt]; lazy_a[rt &lt;&lt; 1] += lazy_a[rt]; va[rt &lt;&lt; 1 | 1] += lazy_a[rt]; lazy_a[rt &lt;&lt; 1 | 1] += lazy_a[rt]; lazy_a[rt] = 0; vd[rt &lt;&lt; 1] += lazy_d[rt]; lazy_d[rt &lt;&lt; 1] += lazy_d[rt]; vd[rt &lt;&lt; 1 | 1] += lazy_d[rt]; lazy_d[rt &lt;&lt; 1 | 1] += lazy_d[rt]; lazy_d[rt] = 0;&#125;void update(long long a, long long d, long long L, long long R, int l, int r, int rt)&#123; if(R == r &amp;&amp; L == l) &#123; va[rt] += a; lazy_a[rt] += a; vd[rt] += d; lazy_d[rt] += d; return ; &#125; push_down(rt); int m = l + r &gt;&gt; 1; if(R &lt;= m) update(a, d, L, R, lson); else if(L &gt; m) update(a, d, L, R, rson); else &#123; update(a, d, L, m, lson); update(a, d, m + 1, R, rson); &#125;&#125;long long query(int p, int l, int r, int rt)&#123; if(l == r) return va[rt] + l * vd[rt]; push_down(rt); int m = l + r &gt;&gt; 1; if(p &lt;= m) return query(p, lson); else return query(p, rson);&#125;int main()&#123; int t; scanf("%d", &amp;t); while(t--) &#123; int n, m; scanf("%d%d", &amp;m, &amp;n); build(root); while(m--) &#123; char op[5]; scanf("%s", op); if(op[0] == 'Q') &#123; int idx; scanf("%d", &amp;idx); printf("%lld\n", query(idx, root)); &#125; if(op[0] == 'U') &#123; char dir[5]; scanf("%s", dir); int idx, d, l, r; long long s, a; scanf("%d%lld%lld%d", &amp;idx, &amp;s, &amp;a, &amp;d); if(dir[0] == 'E') &#123; l = idx; r = l + d - 1; s -= l * a; &#125; else &#123; r = idx; l = r - d + 1; s += r * a; a = -a; &#125; update(s, a, l, r, root); &#125; &#125; &#125; return 0;&#125; HDU 5023 A Corrupt Mayor's Performance Art 区间修改的又一典型例子。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;bits/stdc++.h&gt;#ifdef __WINDOWS_ #include &lt;windows.h&gt;#endifusing namespace std;#define showtime printf("time = %.15f\n", clock() / (double)CLOCKS_PER_SEC);#define lson l, m, rt &lt;&lt; 1#define rson m + 1, r, rt &lt;&lt; 1 | 1#define root 1, n, 1const int maxn = 1e6 + 5;const int maxm = 1005;const int mod = 1e6 + 3;const double eps = 1e-8;const double pi = acos(-1.0);const int inf = 0x3f3f3f3f;struct Node&#123; int l, r; long long x, lz; Node() &#123;&#125; Node(int a, int b, long long c, long long d) &#123; l = a; r = b; x = c; lz = d; &#125;&#125; a[maxn &lt;&lt; 2];long long ans, b[45];void push_down(int rt)&#123; if(a[rt].l == a[rt].r) return ; if(a[rt].lz == 0) return ; a[rt &lt;&lt; 1].lz = a[rt &lt;&lt; 1].x = a[rt].lz; a[rt &lt;&lt; 1 | 1].lz = a[rt &lt;&lt; 1 | 1].x = a[rt].lz; a[rt].lz = 0;&#125;void build(int l, int r, int rt)&#123; a[rt] = Node(l, r, 2, 0); if(l == r) return ; int m = (l + r) &gt;&gt; 1; build(lson); build(rson);&#125;void update(int l, int r, int rt, int op)&#123; if(a[rt].l == l &amp;&amp; a[rt].r == r) &#123; a[rt].lz = b[op]; a[rt].x = b[op]; return ; &#125; push_down(rt); int m = (a[rt].l + a[rt].r) &gt;&gt; 1; if(r &lt;= m) update(l, r, rt &lt;&lt; 1, op); else if(l &gt; m) update(l, r, rt &lt;&lt; 1 | 1, op); else &#123; update(lson, op); update(rson, op); &#125; if(a[rt &lt;&lt; 1].x == a[rt &lt;&lt; 1 | 1].x) a[rt].x = a[rt &lt;&lt; 1].x; else a[rt].x = -1;&#125;void query(int l, int r, int rt)&#123; if(a[rt].x != -1) &#123; ans |= a[rt].x; return ; &#125; int m = (a[rt].l + a[rt].r) &gt;&gt; 1; push_down(rt); if(r &lt;= m) query(l, r, rt &lt;&lt; 1); else if(l &gt; m) query(l, r, rt &lt;&lt; 1 | 1); else &#123; query(lson); query(rson); &#125;&#125;void init()&#123; b[1] = 1; for(int i = 2; i &lt;= 30; i++) b[i] = b[i - 1] * 2;&#125;void solve()&#123; init(); int n, m; while(scanf("%d%d", &amp;n, &amp;m) != EOF) &#123; if(m == 0 &amp;&amp; n == 0) break; build(root); while(m--) &#123; char op[5]; scanf("%s", op); int l, r; scanf("%d%d", &amp;l, &amp;r); if(op[0] == 'P') &#123; int x; scanf("%d", &amp;x); update(l, r, 1, x); &#125; if(op[0] == 'Q') &#123; ans = 0; query(l, r, 1); int first = 1, x; for(int i = 1; i &lt;= 30; i++) &#123; if(ans &amp; 1) &#123; if(first == 0) printf(" "); first = 0; printf("%d", i); &#125; ans /= 2; &#125; printf("\n"); &#125; &#125; &#125;&#125;int main()&#123; solve(); return 0;&#125; 其他线段树进阶题目 HDU 3308 LCIS：细节很多，非常容易错； POJ 1436 Horizontally Visible Segments：转化为区间染色； HDU 4747 Mex： 区间更新，区间求和； HDU 4601 Letter Tree：线段树+字典树； Codeforces 258E Little Elephant and Tree：DFS+线段树； Codeforces 269D Maximum Waterfall：线段树+dp。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mathematica学习[1]——图像复原与处理]]></title>
    <url>%2F2017%2F02%2F16%2FMathematica%E6%8A%80%E5%B7%A7%5B1%5D%E2%80%94%E2%80%94%E5%9B%BE%E5%83%8F%E5%A4%8D%E5%8E%9F%E4%B8%8E%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[函数介绍 官方文档中对该函数的翻译是“润饰”： 12Inpaint[image, region] 润饰 region 中非零元素的 image 部分 Inpaint函数在使用时，需要两个参数，分别是image和region。一般来说，image就是需要处理的原始图像，而region更像是一个mask。所以Inpaint一般需要接受两个大小相同的图像，也总是会返回和image有着相同大小和类型的图片。 Inpaint函数有接受Method选项，并给出如下方法： 方法 含义 &quot;Diffusion&quot; 迭代各向同性扩散方法 &quot;TotalVariation&quot; 迭代全变差方法 &quot;FastMarching&quot; 快速行进方法 &quot;NavierStokes&quot; Navier-Stokes 方法 &quot;TextureSynthesis&quot; 利用随机采样的最佳拟合纹理合成方法 默认情况下，使用TextureSynthesis方法。 设置 Method-&gt;{&quot;TotalVariation&quot;, subopt} 下，可以指定下列子选项： 子操作 值 含义 &quot;NoiseModel&quot; &quot;Gaussian&quot; &quot;Gaussian&quot;、&quot;Laplacian&quot;或&quot;Poisson&quot; &quot;Regularization&quot; Automatic 正则化参数 设置 Method-&gt;{&quot;TextureSynthesis&quot;, subopt} 下，可以指定下列子选项： 子操作 值 含义 Masking Automatic 为二元掩模，可指定用于求出最佳拟合纹理的像素 &quot;MaxSamples&quot; 300 用于求出最佳拟合纹理的样本最大数量 &quot;NeighborCount&quot; 30 用于纹理比较的邻近像素的数目 Inpaint 接受 MaxIterations 选项，指定使用迭代方法执行迭代的最大数. 默认设置是 MaxIterations-&gt;100。关于参数，本文不再详谈。 两个应用 Inpaint函数有着强大的功能，在图形处理中有着不可思议的作用，以下依据官方文档介绍Inpaint的两个较为直接的应用。 修复图像损坏的部分 用合适的Mask图片传入Inpaint可以修复图像的损坏部分： image_1b95789ipkjg1gudqgq9mqrmg57.png-182.4kB 在处理中也可以使用其他的Method选项： image_1b9579v3t1mvv1nc0163e18ps27q5k.png-83.3kB 去除图片中较大的对象 通过调整Mask图片的形状和黑白区域分配，可以去除图片中较大的对象。以下是官方文档中的两个例子： Mask图片的生成技巧 从以上例子中可以看出，关于图像的修复和改动，最关键最核心的就是函数中的region参数，也就是Mask图片的生成。以下讨论两种生成Mask图片的方法： 掩模工具 利用“去除较大对象”的功能以及Mathematica自带的掩模工具，可以去除图片上的水印。 例如下面这张图片，也就是我的头像。来源是百度百科-正一百二十胞体。但图片左下角带有百度百科的水印： image_1b93g3b6r1ac3qugnj33q4pgj1f.png-75kB 利用Inpaint函数可以很好地处理这件事情，以下是处理的方法： 先将图片导入Mathematica： 然后进行掩模，即生成一个黑白的图片，其中黑色的部分保留，白色的部分去除： 掩模完成后就可以直接调用Inpaint函数将左下角的水印去掉了（Mathematica可以直接把图片作为参数，非常便捷）： 然后将图像导出，即可得到一个没有水印的图片（如下图所示）。 image_1b93giupt1321lqv26p1b2r183p3j.png-75.7kB 在很多情况下，用掩模工具生成Mask图片作为region参数对图像进行处理都是非常方便的。 利用颜色的值自动从原图生成Mask 还有一种方法能够直接从原图中生成Mask图片，以下是官方文档中非常具有启发性的一个例子： image_1b958k6rv1mg1ai41lafg3abd26r.png-104.6kB 在这个例子中，非常完美地地去掉了图片右下的日期标记，而且在命令中没有直接出现Mask图片，而是用了一行命令来自动生成： 1Dilation[Binarize[ColorSeparate[img][[1]], 0.93], 1] 其含义是：用ColorSeperate函数将图片分为RGB三层，然后将Red层像素值大于255×0.93的设为白色，其余为黑色，然后用二值化函数Binarize来生成黑白图片作为region参数。其中的Dilation函数是一个处理函数，本文不多赘述。 由这个例子，我们可以产生一种想法： 用图像处理的软件很简单地将图片中不想要的部分染色（染成一个图片当中没有的颜色），然后用上面的方法生成一个region参数，再对原图进行处理。此时便不再需要掩模： 比如这样一张照片： 用工具把不想要的部分染色，作为Mask 运行代码可得如下结果，效果 不咋地 很好，但是确实能去掉该部分。（原因是像素值筛选范围的设定出现了问题，不过我比较懒，没有进行更好的调整） 原理和官方文献中的类似，于是处理这样的问题只需要一行代码： 1Inpaint[#1,ImageResize[Binarize[#2,#==&#123;1,0,0&#125;&amp;], ImageDimensions@#1]]&amp;[img,mask] 纹理和画作分析 如果说刚刚的功能看起来也比较平常的话，那么根据一幅画来创作一幅风格相近的画，或是分析图片中的纹理，总应该是看起来很高端很厉害的功能了。以下是官方文档中的例子： 纹理合成： image_1b95a50op1m0h14pbs74fjdp6978.png-125.8kB 画作分析： image_1b95auqqggfh1lic1f5k1qsq16tc7l.png-267.5kB 有关Mathematica的其他资料请自行查阅。本文只做普及，不做详解。]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>Mathematica</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调教Hexo[1]——github+hexo搭建个人网站]]></title>
    <url>%2F2017%2F02%2F12%2Fgithub-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[github + hexo 搭建个人网站详细过程. 本文针对的主要是Windows用户，不过总体步骤和Linux/Mac大同小异。 本文中所有需要打开文件编辑的地方均不推荐记事本，推荐使用nodepad++或sublime text。 环境配置 安装git bash 直接在官网下载最新版本并安装； 申请github账号 在github填写信息注册账号； 方便起见，以下均假设你的github用户名为 XXX. 方便起见，以下均假设你的github邮箱为 aa@bb.com 建立github仓库 建立一个仓库来存博客的源码，假设标题为“blog”； 建立一个github仓库，标题是XXX.github.io； 安装Node.js 安装Node.js：直接在Node.js官网下载最新版本并安装； 安装hexo 在git bash中执行如下命令以安装hexo（必须在安装Node.js之后进行）； 1npm install -g hexo 执行以下语句以安装hexo所需的依赖包； 1npm install 搭建博客 本地搭建 任意建一个名为“hexo”文件夹，并在该文件夹下运行git bash（右键菜单中选择运行git bash）； git bash中执行如下命令，hexo会自动将搭建所需的所有初始材料放入hexo文件夹中； 1hexo init 在git bash中运行如下命令，即可将博客的静态页面生成在\hexo\public目录下； 1hexo generate #(或简写为 hexo g) generate完毕后即可运行如下指令，成功后即可在localhost:4000浏览博客； 1hexo server #(或简写为 hexo s) 部署到github 修改hexo文件夹中的_config.yml文件： 123456deploy: type: git #用git来部署# 以下两个&quot;repo&quot;任选一种即可 repo: https://github.com/XXX/XXX.github.io.git repo: git@github.com:XXX/XXX.github.io.git branch: master 保存后即可将本地博客与XXX.github.io建立关联； 本地浏览确认无误后运行如下命令即可将博客部署到XXX.github.io； 1hexo deploy #(或简写为 hexo d) 部署完毕后即可在XXX.github.io浏览页面。 可能出现的问题及解决办法 12345在执行 hexo d 时，可能会出现提示： ERROR Deployer not found: git此时，需要执行如下命令： npm install hexo-deployer-git --save完成后再执行 hexo d 即可。 1234在执行 hexo s 时，可能会出现提示： ERROR Plugin load failed: hexo-server此时需要执行如下命令： npm install hexo-server 博客源码备份 git配置 初次使用git，需要进行如下配置： 全局配置 在git bash中依次执行如下语句以完成全局配置： 12git config --global user.name XXXgit config --global user.email aa@bb.com 配置ssh-key 在git bash中执行以下语句： 1ssh-keygen -t rsa -C &quot;your_email@example.com&quot; #(在github注册的邮箱) 添加key到ssh： 将C:/Users/xxxx/.ssh/github_rsa.pub中的全文复制，添加到github。 （浏览器登录github，找到settings -&gt; SSH and GPG keys -&gt; new SSH key粘贴进去确认即可） 至此，你的github账户已经和你的电脑建立了关联。 有关SSH的更详尽步骤可以参考这里，本文不再细化。 git仓库更新 在hexo目录下运行git bash； 运行如下命令即可将该文件夹初始化为git仓库； 1git init 运行如下命令，将本地仓库至连接远程仓库(blog)； 1git remote add origin git@github.com:XXX/blog 依次运行如下命令，即可将源码更新至github的blog仓库，至此备份已经完成。 123git add .git commit -m &quot;message here&quot;git push origin master 每次写新文章之后，都可以按照相同方式将源码再次更新一遍。 更多git操作可以查阅相关文档（例如这里），本文不再赘述。 后续操作 主题的选择 hexo默认的主题是landscape，样子比较难看，网络上有各种其他样式的主题： litten：yilia，一个简洁优雅的hexo主题. forsigner：fexo，一个极简主义风格的hexo主题. iissnan：next，An elegant theme for Hexo. MOxFIVE：yelee，简而不减Hexo双栏博客主题. 例如你想用的主题是yilia，那么需要先执行如下操作： 1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 然后将hexo目录中的_config.yml文件修改为theme: yilia，再重新部署一次即可使用yilia主题。 在使用各种主题时，可以按照自己的需要修改主题中的_config.yml文件。 修改主题的各项操作均可在该主题的说明文档中查阅，本文不再赘述。 撰写新文章 运行如下命令，在hexo\source\_posts文件夹中就会出现一个名为AAA.md的文件； 1hexo new &quot;AAA&quot; 按照markdown语法编辑该文件并保存； 依次运行如下命令即可完成部署。 12hexo ghexo d 关于markdown语法以及编辑器可自行查阅相关资料，本文不再赘述。 将博客绑定在自己的域名上 方便起见，假定域名为www.domain.com。 绑定域名步骤如下： 进入仓库github.com/XXX/XXX.github.io，进入settings页面，在custom domain一项中填写www.domain.com（也可以在hexo目录下直接新建一个名为CNAME的文件，内容为www.domain.com，然后更新博客源码即可）； 然后在域名的设置页面设置解析为lzcwr.github.io即可。 具体解析步骤可在自己购买域名后查看，本文不再赘述。 hexo的常用命令 1234567hexo new &quot;postName&quot; # 新建文章hexo new page &quot;pageName&quot; # 新建页面hexo generate # 生成静态页面至public目录hexo server # 开启预览端口hexo deploy # 将.deploy目录部署到GitHubhexo help # 查看帮助hexo version # 查看Hexo的版本 总结 以上谈到的步骤按照顺序大概是： 安装所需要的软件：git bash，Node.js，hexo； 申请github账号并新建仓库储存源码和博客页面； 本地配置好git：全局配置（用户名和邮箱），和SSH-key配置； 本地搭建博客：hexo init，hexo g，hexo s预览； 将博客部署至github：修改_config.yml中的deploy部分，执行hexo g，hexo d； 可能会出现无法部署至git的问题：安装git-deployer； 撰写新文章：hexo new &quot;postName&quot;，hexo g，hexo d； 更新源码：git操作（add，commit，push）。 ## 可能遇到的其他问题 Hexo与Mathjax的冲突 参见Lzcwr——Hexo与Mathjax的冲突及（部分）解决。]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>计算机</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
