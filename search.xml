<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>记一次费劲的改版...</title>
      <link href="/2018/10/04/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%94%B9%E7%89%88/"/>
      <content type="html"><![CDATA[<blockquote><p>其实大概是因为我太笨Orz... 又双叒叕是一篇没有营养的文章.</p></blockquote><p>很早就发现之前用的 <code>yelee</code> 主题中的 <code>git</code> 图标不能用了，前几日又发现无序列表的符号也挂掉了？？ 这可不能忍... 然而我又不想花时间折腾主题本身，加上搜索功能一直没有配好的积怨，决定干脆换一个主题.</p><p>这个 <code>NexT</code> 主题好像看起来不错！就是它了！</p><p>随后就是很多问题...佛了.</p><blockquote><p>所以在这里把一些（能想起来的）问题简单记一下。</p></blockquote><a id="more"></a><h2 id="tags和categories页面无法正常显示的问题">Tags和Categories页面无法正常显示的问题</h2><p>在最初更换主题后，<code>tags</code> 和 <code>categories</code> 页面只有一个光秃秃的标题，下面的链接全部消失了... 我以为是页面没有生成好的问题，于是先运行 <code>hexo clean</code> 再运行 <code>hexo g</code>，然后重新 <code>hexo s</code>.</p><p>然而并没有什么效果！吓尿的我赶紧 <del>重试了n发</del> Google了一下，大概是搜索姿势问题，这个问题不太容易准确描述... 费了一通劲，终于查明白了：只需要在这两个页面中分别加入一句话就可以了.</p><p>完整的构建过程如下（只以 <code>tags</code> 为例，<code>categories</code> 同理）：</p><ul><li><p>先在终端中键入 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure></p></li><li><p>然后在 <code>/source</code> 目录下会生成一个 <code>/tags</code> 子目录，内含一个 <code>index.md</code> 文件，其初始内容为： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">date:</span> <span class="string">yyyy-mm-dd</span> <span class="attr">hh:mm:ss</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></p></li><li><p>只需添加一行 <code>type: tags</code> 即可. 即改为： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">date:</span> <span class="string">yyyy-mm-dd</span> <span class="attr">hh:mm:ss</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></p></li></ul><p>如此操作后，<code>tags</code> 页面即可正常显示. <code>categories</code> 页面也是同理.</p><h2 id="mathjax显示问题">Mathjax显示问题</h2><blockquote><p>这个问题我认为是 <code>NexT</code> 主题的锅.</p></blockquote><p>像我这样的一个网站，<code>mathjax</code> 的重要性不言而喻... 没有 <code>mathjax</code> 我这个网站简直可以直接关掉了. 于是这是我刚换了主题就立刻着手配置的东西.</p><p>在 <code>NexT</code> 主题的配置文件 <code>_config.yml</code> 中关于 <code>mathjax</code> 的内容如下： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Third Party Services Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MathJax Support</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  per_page:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  cdn:</span> <span class="string">//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML</span></span><br></pre></td></tr></table></figure></p><p>按照其文档所描述，只需将 <code>enable: false</code> 改为 <code>enable: true</code> 即可. 然而我照做后，发现文档中的 <code>mathjax</code> 公式只能短暂地正常显示几秒，就会变成一堆不知道是什么的小方块...</p><p>看到这个情况以后我很慌张... 冷静了一会儿之后开始思考这个问题的成因... 最初没有想到是 <code>NexT</code> 主题的问题，感觉可能性比较大的也就是这么几个：</p><ul><li>是 <code>Google Chrome</code> 浏览器的问题，辣鸡 <code>Chrome</code> 无法正常显示 <code>mathjax</code> 公式.<ul><li>检查方案：换个浏览器打开 <code>localhost:4000</code> 试试；</li><li>检查结果：其他浏览器显示的也是一堆小方块...GG！</li></ul></li><li>既然不是 <code>Chrome</code> 的锅，那就是我配错了！<ul><li>检查方案：找找其他用了 <code>NexT</code> 主题的网站，看看是否有同样问题；</li><li>检查结果：找这个有 <code>LaTeX</code> 公式的 <code>NexT</code> 网站就费了老鼻子劲... 然后发现也是一堆小方块... GG again！</li></ul></li><li>和卜凡大神讨论了一下，可能是 <code>mathjax</code> 被墙了？<ul><li>检查方案：墙个屁啊...可能么？链接都能打开怎么可能是墙了... one more GG！</li></ul></li></ul><p>三个我认为比较可能的问题都不存在... 这让我陷入了短暂的蒙蔽... 回过神来以后，我感到我对于我最初做的假设“主题本身没有错”产生了一丝怀疑，联想到 <code>yelee</code> 主题仍然能正常显示 <code>LaTeX</code> 公式，我查了一发 <code>mathjax</code> 的配置方法，然后发现 <code>cdn</code> 和这里的不一样...</p><p>于是我在某篇文章中加了另一个 <code>cdn</code>，这篇文章便能正确加载 <code>mathjax</code> 了... 我简直佛了，于是进行了如下修改，<code>mathjax</code> 即能正确加载. <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MathJax Support</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  per_page:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  cdn:</span> <span class="string">//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span></span><br></pre></td></tr></table></figure></p><h2 id="动画特效canvas-nest配置">动画特效canvas-nest配置</h2><p>文档中提供的方法为：在配置文件中将 <code>canvas_nest</code> 一项改为 <code>true</code> ，我照做了，然而并没有什么效果.</p><p>单页的配置方法很简单：在文章中加入以下字段即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/lib/canvas-nest/canvas-nest.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>若想在所有页面均启用该特效，则须修改 <code>_layout.swig</code> 文件：</p><ul><li><p>在<code>_layout.swig</code> 的 <code>body</code> 中添加如下字段： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.canvas_nest %&#125;</span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"/lib/canvas-nest/canvas-nest.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>然后依次运行 <code>hexo clean</code>, <code>hexo g</code> 和 <code>hexo s</code> / <code>hexo d</code> 即可看到特效.</p></li></ul><h2 id="搜索功能的配置">搜索功能的配置</h2><p>按照文档中的方法进行操作即可成功配置，治好了我多时没有在 <code>yelee</code> 中配好搜索功能的心病...</p><p><strong>注意：</strong>不需要在 <code>_config.yml</code> 中添加 <code>search</code> 项，否则侧栏中将会出现两个“搜索”.</p><h2 id="评论功能的配置">评论功能的配置</h2><h3 id="gitment">Gitment</h3><p>之前的版本配置了多说评论，然而不久多说就GG了，加上 <code>disqus</code> 疑似被墙... 之后一直没有再弄评论. 既然改版了，顺手配了一个 <code>gitment</code> 评论，如有错误欢迎批评.</p><p>配置很简单：</p><ul><li><p>在 <a href="https://github.com/settings/developers" class="uri" target="_blank" rel="noopener">https://github.com/settings/developers</a> 申请一个 application, 按照如下内容填写申请即可： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Application</span> <span class="string">name：Gitment</span></span><br><span class="line"><span class="string">Homepage</span> <span class="string">URL：https://网站地址/</span></span><br><span class="line"><span class="string">Application</span> <span class="string">description：Blog</span> <span class="string">comment</span> <span class="string">system</span></span><br><span class="line"><span class="string">Authorization</span> <span class="string">callback</span> <span class="string">URL：https://网站地址/</span></span><br></pre></td></tr></table></figure></p></li><li>然后在 <code>github</code> 新建一个仓库用来存评论，比如叫做 <code>gitment-comments</code>.</li><li><p>在主题配置文件 <code>_config.yml</code> 中填写 <code>gitment</code> 相关内容即可完成配置. <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gitment:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  mint:</span> <span class="literal">true</span> <span class="comment"># RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway</span></span><br><span class="line"><span class="attr">  count:</span> <span class="literal">true</span> <span class="comment"># Show comments count in post meta area</span></span><br><span class="line"><span class="attr">  lazy:</span> <span class="literal">false</span> <span class="comment"># Comments lazy loading with a button</span></span><br><span class="line"><span class="attr">  cleanly:</span> <span class="literal">false</span> <span class="comment"># Hide 'Powered by ...' on footer, and more</span></span><br><span class="line"><span class="attr">  language:</span> <span class="string">zh-Hans</span> <span class="comment"># Force language, or auto switch by theme</span></span><br><span class="line"><span class="attr">  github_user:</span> <span class="string">lzcwr</span> <span class="comment"># MUST HAVE, Your Github ID</span></span><br><span class="line"><span class="attr">  github_repo:</span> <span class="string">gitment-comments</span> <span class="comment"># MUST HAVE, The repo you use to store Gitment comments</span></span><br><span class="line"><span class="attr">  client_id:</span> <span class="string">在申请好application的页面中有</span> <span class="comment"># MUST HAVE, Github client id for the Gitment</span></span><br><span class="line"><span class="attr">  client_secret:</span> <span class="string">在申请好application的页面中有</span> <span class="comment"># EITHER this or proxy_gateway, Github access secret token for the Gitment</span></span><br><span class="line"><span class="attr">  proxy_gateway:</span> <span class="comment"># Address of api proxy, See: https://github.com/aimingoo/intersect</span></span><br><span class="line"><span class="attr">  redirect_protocol:</span> <span class="comment"># Protocol of redirect_uri with force_redirect_protocol when mint enabled</span></span><br></pre></td></tr></table></figure></p></li></ul><h4 id="又双叒叕失败了">又双叒叕失败了！</h4><p>正当我满心欢喜意为自己配好了 <code>Gitment</code> 的时候，突然感到事情太顺利了（？）于是决定测试一下评论. <code>hexo d</code> 部署完毕以后，我在本文的后面尝试了一下用 <code>github</code> 账号登录.</p><p>然而！报错了！报错信息为 <code>[object ProgressEvent]</code>.</p><p>我赶紧去 <code>gitment</code> 的 <code>issue</code> （参见<a href="https://github.com/imsun/gitment/issues/170" class="uri" target="_blank" rel="noopener">https://github.com/imsun/gitment/issues/170</a>） 里翻了一下，果然很多人有这样的问题...</p><p>大致阅读了一下，原因应该是 <code>gitment</code> 作者自己的网站的证书到期了，而 <code>gitment</code> 需要以此为接口，故会报错... 按照里面的一些方法进行了修改，但是似乎没有什么效果...</p><p>怎么办！换吧...</p><h3 id="gitalk">Gitalk</h3><p>换什么呢... 开始自闭... 对哦！然想起来 <a href="https://njuwfang.github.io/" target="_blank" rel="noopener">望望同学的博客</a> 里面用的好像是 <code>github issues</code> 评论！</p><p>赶紧去翻翻是不是 <code>gitment</code>... 噢，原来是 <code>gitalk</code>... OK！就是它了！</p><h4 id="配置方法">配置方法</h4><blockquote><p>附一个 <code>gitalk</code> 的官方demo：<a href="https://gitalk.github.io/" class="uri" target="_blank" rel="noopener">https://gitalk.github.io/</a><br>官方 <code>github</code> 仓库：<a href="https://github.com/gitalk/gitalk" class="uri" target="_blank" rel="noopener">https://github.com/gitalk/gitalk</a></p></blockquote><p><code>NexT</code> 主题中并没有集成 <code>gitalk</code> 功能，需要自己手动添加.</p><ul><li>首先肯定还是要在 <code>github</code> 上申请一个 application，具体步骤见上.</li><li>其次肯定还是要在 <code>github</code> 上建立一个 repository，具体步骤不多啰嗦.</li><li><p>在 <code>/layout/_third-party/comments/</code> 目录下新建 <code>gitalk.swig</code> 文件，内容如下： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> page.comments &amp;&amp; theme.gitalk.enable %&#125;</span><br><span class="line">    &lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"https://unpkg.com/gitalk/dist/gitalk.css"</span>&gt;</span><br><span class="line">    &lt;script src=<span class="string">"https://unpkg.com/gitalk/dist/gitalk.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="keyword">var</span> gitalk = <span class="keyword">new</span> Gitalk(&#123;</span><br><span class="line">          clientID: <span class="string">'&#123;&#123; theme.gitalk.ClientID &#125;&#125;'</span>,</span><br><span class="line">          clientSecret: <span class="string">'&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;'</span>,</span><br><span class="line">          repo: <span class="string">'&#123;&#123; theme.gitalk.repo &#125;&#125;'</span>,</span><br><span class="line">          owner: <span class="string">'&#123;&#123; theme.gitalk.githubID &#125;&#125;'</span>,</span><br><span class="line">          admin: [<span class="string">'&#123;&#123; theme.gitalk.adminUser &#125;&#125;'</span>],</span><br><span class="line">          id: location.pathname,</span><br><span class="line">          distractionFreeMode: <span class="string">'&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;'</span></span><br><span class="line">        &#125;)</span><br><span class="line">        gitalk.render(<span class="string">'gitalk-container'</span>)           </span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure></p></li><li><p>修改 <code>/layout/_partials/comments.swig</code>，在最后一个 <code>elseif</code> 后添加如下字段： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% elseif theme.gitalk.enable %&#125;</span><br><span class="line"> &lt;div id=<span class="string">"gitalk-container"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><ul><li>添加后的 <code>comments.swig</code> 应如下所示： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  &#123;% elseif theme.gitment.enable %&#125;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"comments"</span> id=<span class="string">"comments"</span>&gt;</span><br><span class="line">      &#123;% <span class="keyword">if</span> theme.gitment.lazy %&#125;</span><br><span class="line">        &lt;div onclick=<span class="string">"showGitment()"</span> id=<span class="string">"gitment-display-button"</span>&gt;&#123;&#123; __(<span class="string">'gitmentbutton'</span>) &#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div id="gitment-container" style="display:none"&gt;&lt;/</span>div&gt;</span><br><span class="line">      &#123;% <span class="keyword">else</span> %&#125;</span><br><span class="line">        &lt;div id=<span class="string">"gitment-container"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      &#123;% endif %&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  &#123;% elseif theme.valine.appid and theme.valine.appkey %&#125;</span></span><br><span class="line"><span class="regexp">    &lt;div class="comments" id="comments"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  </span><br><span class="line">  &#123;% elseif theme.gitalk.enable %&#125;</span><br><span class="line">    &lt;div id=<span class="string">"gitalk-container"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>修改 <code>/layout/_third-party/comments/index.swig</code>，在其末尾添加如下字段： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include <span class="string">'gitalk.swig'</span> %&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>设置 <code>gitalk</code> 的样式，参考<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>： 在 <code>/source/css/_common/components/third-party/</code> 目录下新建 <code>gitalk.styl</code> 文件，内容如下： <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.gt-header</span> <span class="selector-tag">a</span>, <span class="selector-class">.gt-comments</span> <span class="selector-tag">a</span>, <span class="selector-class">.gt-popup</span> <span class="selector-tag">a</span></span><br><span class="line">  <span class="selector-tag">border-bottom</span>: <span class="selector-tag">none</span>;</span><br><span class="line"><span class="selector-class">.gt-container</span> <span class="selector-class">.gt-popup</span> <span class="selector-class">.gt-action</span><span class="selector-class">.is--active</span><span class="selector-pseudo">:before</span></span><br><span class="line">  <span class="selector-tag">top</span>: 0<span class="selector-class">.7em</span>;</span><br></pre></td></tr></table></figure></p></li><li><p>修改 <code>/source/css/_common/components/third-party/third-party.styl</code> 文件，在末尾添加如下字段： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">"gitalk"</span>;</span><br></pre></td></tr></table></figure></p></li><li><p>最后在主题配置文件 <code>_config.yml</code> 中添加如下项： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gitalk:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  owner:</span> <span class="string">你的github帐号</span>  <span class="comment"># lzcwr  </span></span><br><span class="line"><span class="attr">  repo:</span> <span class="string">存放评论的仓库名称</span>   <span class="comment"># Gitalk-comments</span></span><br><span class="line"><span class="attr">  ClientID:</span> <span class="string">在申请好application的页面中有</span></span><br><span class="line"><span class="attr">  ClientSecret:</span> <span class="string">在申请好application的页面中有</span></span><br><span class="line"><span class="attr">  adminUser:</span> <span class="string">你的github帐号</span> <span class="comment"># 可初始化评论的账户</span></span><br><span class="line"><span class="attr">  distractionFreeMode:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p></li></ul><p>完整无误地完成上述步骤后，在本地即可看到 <code>gitalk</code> 的按钮. 但本地不能用，必须要 <code>hexo d</code> 部署完毕后才能使用.</p><blockquote><p>你以为这样就完了吗？那可未必...</p></blockquote><h4 id="error-validation-failed-解决方案">Error: Validation Failed 解决方案</h4><blockquote><p>参考了：<a href="https://priesttomb.github.io/%E6%97%A5%E5%B8%B8/2018/02/12/%E5%A4%84%E7%90%86Gitalk%E4%B8%AD%E7%94%B1%E4%BA%8E%E6%96%87%E7%AB%A0URL%E8%BF%87%E9%95%BF%E5%AF%BC%E8%87%B4%E7%9A%84Validation-Failed(422)/" target="_blank" rel="noopener">处理Gitalk中由于文章URL过长导致的Validation-Failed(422)</a></p></blockquote><p>部署完毕后我试了一下，又gg了！又双叒叕翻了一下 <code>issues</code>，发现是文章 <code>URL</code> 过长导致的（坏习惯，用中文做标题Orz... 中文会被编码成很长的串...）. <code>gitalk</code> 支持的长度只有50，难道我要一个一个改标题么？不能忍... 于是 <code>google</code> 了一大通，最终受到上述文章启发，决定用其 <code>md5</code> 码代替文章标题.</p><p>注意到前文所添加的 <code>gitalk.swig</code> 文件中的段落： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> gitalk = <span class="keyword">new</span> Gitalk(&#123;</span><br><span class="line">        clientID: <span class="string">'&#123;&#123; theme.gitalk.ClientID &#125;&#125;'</span>,</span><br><span class="line">        clientSecret: <span class="string">'&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;'</span>,</span><br><span class="line">        repo: <span class="string">'&#123;&#123; theme.gitalk.repo &#125;&#125;'</span>,</span><br><span class="line">        owner: <span class="string">'&#123;&#123; theme.gitalk.owner &#125;&#125;'</span>,</span><br><span class="line">        admin: [<span class="string">'&#123;&#123; theme.gitalk.adminUser &#125;&#125;'</span>],</span><br><span class="line">        id: location.pathname,</span><br><span class="line">        distractionFreeMode: <span class="string">'&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    gitalk.render(<span class="string">'gitalk-container'</span>)           </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><p><code>var gitalk</code> 中有一项为： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id: location.pathname,</span><br></pre></td></tr></table></figure></p><p>这里正是索引的地方，我们只需要添加一个 <code>md5</code> 的函数，然后将其改为 <code>md5(...)</code> 即可.</p><p>我用的是 <a href="https://github.com/blueimp/JavaScript-MD5/blob/master/js/md5.min.js" class="uri" target="_blank" rel="noopener">https://github.com/blueimp/JavaScript-MD5/blob/master/js/md5.min.js</a>，更改完毕之后的 <code>gitalk.swig</code> 文件如下： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> page.comments &amp;&amp; theme.gitalk.enable %&#125;</span><br><span class="line">    &lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"https://unpkg.com/gitalk/dist/gitalk.css"</span>&gt;</span><br><span class="line">    &lt;script src=<span class="string">"/js/md5.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script src=<span class="string">"https://unpkg.com/gitalk/dist/gitalk.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="keyword">var</span> gitalk = <span class="keyword">new</span> Gitalk(&#123;</span><br><span class="line">          clientID: <span class="string">'&#123;&#123; theme.gitalk.ClientID &#125;&#125;'</span>,</span><br><span class="line">          clientSecret: <span class="string">'&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;'</span>,</span><br><span class="line">          repo: <span class="string">'&#123;&#123; theme.gitalk.repo &#125;&#125;'</span>,</span><br><span class="line">          owner: <span class="string">'&#123;&#123; theme.gitalk.owner &#125;&#125;'</span>,</span><br><span class="line">          admin: [<span class="string">'&#123;&#123; theme.gitalk.adminUser &#125;&#125;'</span>],</span><br><span class="line">          id: md5(location.pathname),</span><br><span class="line">          distractionFreeMode: <span class="string">'&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;'</span></span><br><span class="line">        &#125;)</span><br><span class="line">        gitalk.render(<span class="string">'gitalk-container'</span>)           </span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure></p><p>这样好像就彻底搞好了？<del>我这乌鸦嘴可还行==</del></p><h4 id="关闭评论的页面">关闭评论的页面</h4><p>在需要关闭评论的页面加一句 <code>comments: false</code> 即可.</p><h2 id="pdf插件配置">PDF插件配置</h2><blockquote><p>不多说了，参见 <a href="https://pdfobject.com/" class="uri" target="_blank" rel="noopener">https://pdfobject.com/</a><br>官方 <code>github</code> 仓库：<a href="https://github.com/pipwerks/PDFObject" class="uri" target="_blank" rel="noopener">https://github.com/pipwerks/PDFObject</a></p></blockquote><div class="footnotes"><hr><ol><li id="fn1"><p><a href="https://asdfv1929.github.io/2018/01/20/gitalk/" class="uri" target="_blank" rel="noopener">https://asdfv1929.github.io/2018/01/20/gitalk/</a><a href="#fnref1">↩</a></p></li></ol></div>]]></content>
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 计算机 </tag>
            
            <tag> Hexo </tag>
            
            <tag> Mathjax </tag>
            
            <tag> Gitalk </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python学习[1]——时间序列分析</title>
      <link href="/2018/09/26/Python%E5%AD%A6%E4%B9%A0-1-%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%88%86%E6%9E%90/"/>
      <content type="html"><![CDATA[<ul><li>做了一个数据预测的东西, 对这方面的内容过于生疏, 顺手简单学习了一波Orz...</li><li><code>tsa</code> 的官方文档：<a href="http://www.statsmodels.org/dev/tsa.html" class="uri" target="_blank" rel="noopener">http://www.statsmodels.org/dev/tsa.html</a></li></ul><blockquote><p>面向乱搞的程序设计？</p></blockquote><a id="more"></a><h2 id="序列的分析">序列的分析</h2><h3 id="序列的平稳性">序列的平稳性</h3><p>如果时间序列 <span class="math inline">\(x_t\)</span> 在某一常数附近波动并且范围不大，方差和均值为常数，且延迟 <span class="math inline">\(k\)</span> 期的子自协方差和自相关系数是相等的，则称 <span class="math inline">\(x_t\)</span> 是平稳序列. <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p><p>自协方差和自相关系数的定义如下：</p><ul><li>自协方差：<span class="math inline">\(\gamma(t,s) = \mathbb{E}[(x_t-\mu_t)(x_s-\mu_s)]\)</span></li><li>自相关系数：<span class="math inline">\(\rho(t,s) = \frac{cov(x_t, x_s)}{\sigma_t\sigma_s}\)</span></li></ul><h4 id="平稳序列的判定平稳性检验">平稳序列的判定：平稳性检验</h4><p>一般有以下两种方法：</p><ol style="list-style-type: decimal"><li>时序图检验：根据平稳序列的均值和方差都为常数的性质，平稳时间序列的时序图应当显示该序列始终在一个常数附近随机波动，且波动范围有限；</li><li>自相关检验：平稳时间序列具有短期相关性，故平稳时间序列通常只有近期的项才对当前值的影响较为明显。随着间隔 <span class="math inline">\(k\)</span> 的增大，平稳序列的自相关系数会不断衰减至 <span class="math inline">\(0\)</span>，而非平稳序列的衰减较慢。</li></ol><h3 id="白噪声序列">白噪声序列</h3><ul><li>白噪声序列指的是纯随机序列，序列的各项之间毫无关系，从中无法获取任何有用的信息。</li></ul><h4 id="白噪声序列的判定纯随机性检验">白噪声序列的判定：纯随机性检验</h4><p>纯随机序列满足 <span class="math inline">\(\gamma(k) = 0\)</span>，其样本自相关系数很接近零，并且在零附近随机扰动。一般构造 <span class="math inline">\(Q\)</span> 统计量和 <span class="math inline">\(LB\)</span> 统计量来进行检验.</p><ul><li>在 <code>Python</code> 中可以使用 <code>acorr_ljungbox</code> 方法来检验.</li></ul><h2 id="常用的模型原理">常用的模型原理</h2><p>时间序列趋势主要受到总体趋势 <span class="math inline">\(T\)</span>、季节性因素 <span class="math inline">\(S\)</span>、周期性波动 <span class="math inline">\(C\)</span> 和随机扰动 <span class="math inline">\(\varepsilon\)</span> 的影响，一般来说有加法和乘法两种模型。</p><ol style="list-style-type: decimal"><li>加法模型(additive model): <span class="math inline">\(x_t = T_t+S_t+C_t+\varepsilon_t\)</span>;</li><li>乘法模型(multiplicative model): <span class="math inline">\(x_t = T_t\times S_t\times C_t\times\varepsilon_t\)</span>.</li></ol><p>在作分析时，常常采用的是AR-MA模型：</p><ol style="list-style-type: decimal"><li>AR模型 <span class="math inline">\(AR(p)\)</span>：每一项都与前 <span class="math inline">\(p\)</span> 项线性相关, 与随机扰动项无关. <span class="math display">\[x_t=\varphi_0 + \varphi_1 x_{t-1}+\varphi_2 x_{t-2}+\cdots+\varphi_p x_{t-p}+\varepsilon_t = \varphi_0+ \sum\limits_{k=1}^p \varphi_k x_{t-k}+\varepsilon_t\]</span> 其中随机扰动项 <span class="math inline">\(\varepsilon_t\)</span> 为均值为 <span class="math inline">\(0\)</span> 的白噪声序列. 均值方差均为常数，ACF拖尾，PACF <span class="math inline">\(q\)</span> 阶截尾.</li><li>MA模型 <span class="math inline">\(MA(q)\)</span>：每一项都与前 <span class="math inline">\(q\)</span> 项的随机扰动线性相关, 与真实值无关. <span class="math display">\[x_t = \mu + \varepsilon_t-\theta_1 \varepsilon_{t-1}-\theta_2\varepsilon_{t-2}-\cdots-\theta_q \varepsilon_{t-q} = \mu + \varepsilon_t - \sum\limits_{k=1}^q \theta_k\varepsilon_{t-k}\]</span> 其中随机扰动项 <span class="math inline">\(\varepsilon_t\)</span> 为均值为 <span class="math inline">\(0\)</span> 的白噪声序列，<span class="math inline">\(\mu\)</span> 为序列均值. 均值方差为常数，ACF为 <span class="math inline">\(q\)</span> 阶截尾，PACF拖尾.</li><li>ARMA模型 <span class="math inline">\(ARMA(p,q)\)</span>：每一项都与前 <span class="math inline">\(p\)</span> 项线性相关, 同时与前 <span class="math inline">\(q\)</span> 项的随机扰动有关. <span class="math display">\[\begin{align}x_t &amp;= \varphi_0 + \varphi_1 x_{t-1}+\varphi_2 x_{t-2}+\cdots+\varphi_p x_{t-p} + \varepsilon_t-\theta_1 \varepsilon_{t-1}-\theta_2\varepsilon_{t-2}-\cdots-\theta_q \varepsilon_{t-q} \\&amp;= \varphi_0 + \sum\limits_{i=1}^p \varphi_i x_{t-i} + \varepsilon_t - \sum\limits_{j=1}^q \theta_j\varepsilon_{t-j}\end{align}\]</span> 其中随机扰动项 <span class="math inline">\(\varepsilon_t\)</span> 为均值为 <span class="math inline">\(0\)</span> 的白噪声序列，<span class="math inline">\(\mu\)</span> 为序列均值. 均值方差为常数，ACF为 <span class="math inline">\(q\)</span> 阶截尾，PACF <span class="math inline">\(p\)</span> 阶截尾.</li></ol><blockquote><p>容易看出AR模型和MA模型分别是ARMA在 <span class="math inline">\(p=0\)</span> 和 <span class="math inline">\(q=0\)</span> 时的特例.</p></blockquote><p>一般在分析时分析的多是平稳序列，可以考虑用ARMA模型。有一些序列本身不是平稳序列，但做一阶差分之后成为平稳序列，这种序列被称为差分平稳序列，可以使用ARIMA模型进行拟合.</p><h2 id="python中的amra模型">Python中的AMRA模型</h2><h3 id="导入库">导入库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> statsmodels.graphics.tsaplots <span class="keyword">import</span> plot_acf <span class="comment"># 自相关图</span></span><br><span class="line"><span class="keyword">from</span> statsmodels.graphics.tsaplots <span class="keyword">import</span> plot_pacf <span class="comment"># 偏自相关图</span></span><br><span class="line"><span class="keyword">from</span> statsmodels.stats.diagnostic <span class="keyword">import</span> acorr_ljungbox <span class="comment"># 白噪声检验</span></span><br><span class="line"><span class="keyword">from</span> statsmodels.tsa.stattools <span class="keyword">import</span> adfuller <span class="keyword">as</span> ADF <span class="comment"># 平稳性检测</span></span><br><span class="line"><span class="keyword">from</span> statsmodels.tsa.seasonal <span class="keyword">import</span> seasonal_decompose <span class="comment"># 季节性分解</span></span><br><span class="line"><span class="keyword">from</span> statsmodels.tsa.arima_model <span class="keyword">import</span> ARMA</span><br><span class="line"><span class="keyword">from</span> statsmodels.tsa.arima_model <span class="keyword">import</span> ARIMA</span><br></pre></td></tr></table></figure><h3 id="乱码问题处理">乱码问题处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'SimHei'</span>] <span class="comment"># 显示中文标签</span></span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="keyword">False</span> <span class="comment"># 显示负号</span></span><br></pre></td></tr></table></figure><h3 id="数据读取与处理">数据读取与处理</h3><p>按照我的习惯会将日期一列命名为 <code>date</code>.</p><h4 id="数据读取">数据读取</h4><p>一般数据的格式为 <code>XLS</code> 或者 <code>CSV</code>.</p><ol style="list-style-type: decimal"><li><p>数据为CSV格式 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">'文件地址'</span>, encoding = <span class="string">'utf-8'</span>, indeax_col = <span class="string">'date'</span>)</span><br></pre></td></tr></table></figure></p></li><li><p>数据为XLS格式 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_excel(<span class="string">'文件地址'</span>, encoding = <span class="string">'utf-8'</span>, index_col = <span class="string">'data'</span>)</span><br></pre></td></tr></table></figure></p></li></ol><p>若数据为数据库形式(如 <code>MySQL</code>), 则可以直接用 <code>SQL</code> 语句从数据库中提取.</p><h4 id="数据格式的处理">数据格式的处理</h4><p>以上读取数据的函数只会将读入的数据保存为 <code>DataFrame</code> 对象，但我们做预测所需要的数据类型是 <code>Series</code>，故需要将其转换为该格式，并将 <code>date</code> 指定为索引.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.index = pd.to_datetime(df.index)  <span class="comment"># 指定 date 为索引</span></span><br><span class="line">ts = df[<span class="string">'x'</span>]  <span class="comment"># 生成Series对象</span></span><br></pre></td></tr></table></figure><blockquote><center><font color="red"><strong>注意此处数据文件中的日期必须为日期格式. </strong></font>如 (yyyy/mm/dd) 是合法的，但 &quot;20080808&quot; 就是不合法的，必须进行处理.<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a></center></blockquote><p>如此得到的 <code>ts</code> 即为一个可用的时间序列，不仅可以用类似于 <code>2014-1-1</code> 的字符串进行访问，也可以用时间对象 <code>datetime(2014, 1, 1)</code> 进行访问. 即以下两种访问方式都是可行的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ts[<span class="string">'2014-1-1'</span>]</span><br><span class="line">ts[datetime(<span class="number">2014</span>, <span class="number">1</span>, <span class="number">1</span>)]</span><br><span class="line">ts[<span class="string">'2014-1-1'</span> : <span class="string">'2014-5-1'</span>] <span class="comment"># 切片操作. 注意此处的切片为闭区间, 端点都包括.</span></span><br></pre></td></tr></table></figure><blockquote><p>关于 <code>Series</code> 的更多内容参见 https://blog.csdn.net/zutsoft/article/details/51482573</p></blockquote><h3 id="数据的趋势分析">数据的趋势分析</h3><h4 id="平稳性检验">平稳性检验</h4><p>可以进行 <code>ADF</code> 检验. 弱鸡还不理解其原理...暂且放在这里.</p><h4 id="平稳性处理季节性分解">平稳性处理：季节性分解</h4><blockquote><p>为了使序列更平稳，在做计算时经常对其取对数: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ts_log = np.log(ts)</span><br></pre></td></tr></table></figure></p></blockquote><p>若原始数据有很强的周期性，则可以考虑对其进行季节性的分解，即将元素数据分离为总体趋势，季节性趋势以及残差三部分.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">decomposition = seasonal_decompose(ts_log, model=<span class="string">"additive"</span>)</span><br><span class="line">trend = decomposition.trend</span><br><span class="line">seasonal = decomposition.seasonal</span><br><span class="line">residual = decomposition.resid</span><br></pre></td></tr></table></figure><p>将三种因素分离后，即可分别做预测，再相加. <code>statsmodels</code> 中还提供了乘法模型，只需将上述代码中的 <code>additive</code> 改为 <code>multiplicative</code> 即可.</p><h3 id="模型识别">模型识别</h3><p>只需要对所要拟合的数据集绘制其 ACF(自相关) 与 PACF(偏自相关) 图，观察其截尾与拖尾性质即可确定模型阶数.<br>相关图的绘制代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plot_acf(ts_log).show()</span><br><span class="line">plot.pacf(ts_log).show()</span><br></pre></td></tr></table></figure><p>例如最终识别为 <span class="math inline">\(p=q=1\)</span>，则预测模型为 <span class="math inline">\(ARMA(1,1)\)</span>，实现代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = ARMA(ts_log, order = (<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">result = model.fit(disp = <span class="number">-1</span>, method = <span class="string">'css'</span>)</span><br></pre></td></tr></table></figure><p>随后用以下代码即可预测：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">predict = result.predict(begin, end) <span class="comment"># begin 和 end 表示所需预测的起点与终点</span></span><br><span class="line">predict = np.exp(predict) <span class="comment"># 若之前取了对数 or 做了差分, 预测之后应还原</span></span><br></pre></td></tr></table></figure><h2 id="python中的arima模型">Python中的ARIMA模型</h2><p>根本不会，学会再写。</p><div class="footnotes"><hr><ol><li id="fn1"><p>参见 https://zhuanlan.zhihu.com/p/35128342<a href="#fnref1">↩</a></p></li><li id="fn2"><p>python时间序列分析: https://www.cnblogs.com/foley/p/5582358.html<a href="#fnref2">↩</a></p></li><li id="fn3"><p>将 &quot;yyyymmdd&quot; 转换为 &quot;yyyy/mm/dd&quot; 的方法很简单，以下给出 <code>C++</code> 代码： <figure class="highlight c++"><figcaption><span>date_format.cpp 处理日期格式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c - <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>); <span class="comment">// 输入到文件里, 方便使用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s; <span class="comment">// 输入格式为 yyyymmdd 字符串</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">1000</span> * f(s[<span class="number">0</span>]) + <span class="number">100</span> * f(s[<span class="number">1</span>]) + <span class="number">10</span> * f(s[<span class="number">2</span>]) + f(s[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">10</span> * f(s[<span class="number">4</span>]) + f(s[<span class="number">5</span>]);</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">10</span> * f(s[<span class="number">6</span>]) + f(s[<span class="number">7</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d/%d/%d\n"</span>, y, m, d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a href="#fnref3">↩</a></p></li></ol></div>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 计算机 </tag>
            
            <tag> 统计学 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Windows下用Shell——Cmder配置</title>
      <link href="/2018/09/23/Cmder%E9%85%8D%E7%BD%AE/"/>
      <content type="html"><![CDATA[<p>平时免不了会用到windows下的命令行, 但是 <code>cmd</code> 使用体验非常差... 后来开始用 <code>PowerShell</code>, 比起 <code>cmd</code> 来说确实有了一些改善, 但是仍然不是很友好Orz. 再后来发现了 <code>Cmder</code>, 对 <code>Shell</code> 的支持更为友好, 界面也很美观, 于是就彻底放弃了 <code>PowerShell</code>...</p><blockquote><p>这里记录一下 <code>Cmder</code> 的配置, 主要是给自己看的.</p><ul><li>中文支持</li><li>环境变量添加</li><li>右键菜单配置</li><li>提示符修改</li></ul></blockquote><a id="more"></a><h2 id="中文支持">中文支持</h2><p>在 <code>Settings -&gt; Startup -&gt; Environment</code> 里面加如下的语句即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set LANG=zh_CN.UTF8</span><br></pre></td></tr></table></figure><h2 id="环境变量添加">环境变量添加</h2><p>将 <code>Cmder</code> 的安装目录添加到 <code>PATH</code> 中. 例如我的安装目录是 <code>D:\Cmder</code>, 直接将其添加到 <code>PATH</code> 的开头即可.</p><p>成功添加环境变量后, 在 <code>Win+R</code> 调出的“运行”窗口中键入 <code>Cmder</code> 即可直接在用户目录下打开 <code>Cmder</code>.</p><h2 id="右键菜单配置">右键菜单配置</h2><p>添加好环境变量后, 在 <code>cmd</code> 或 <code>PowerShell</code> 中运行如下语句即可.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cmder.exe /REGISTER ALL</span><br></pre></td></tr></table></figure><p>成功后在任意文件夹空白处右击鼠标, 即可在快捷菜单中找到 <code>Cmder Here</code>, 即在该目录下运行 <code>Cmder</code>.</p><h2 id="提示符修改">提示符修改</h2><blockquote><p>这个在网上查了很多东西都不能直接用, 需要自己多尝试.</p></blockquote><p><code>Cmder</code> 的默认输出提示符是 <span class="math inline">\(\lambda\)</span>, 多少看着有点别扭, 按照 <code>Linux</code> 的习惯可以将其改为美元符号 <span class="math inline">\(\$\)</span>.<br>网上的教程大多是修改 <code>/vendor</code> 目录下的 <code>init.bat</code>, <code>clink.lua</code> 或 <code>profile.ps1</code> 来达到修改提示符的目的, 但是具体方法大多是不可行的.<br>我目前所使用的版本可以通过修改 <code>clink.lua</code> 来实现, 具体做法是将该文件第43行的 <code>local lambda = &quot;λ&quot;</code> 修改为 <code>local lambda = &quot;$&quot;</code> 即可...</p><p>观众用完之后（如果无效）, 不能骂我== 因为我...根本没有头发（<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p><h2 id="linux命令速查表">Linux命令速查表</h2><p>顺手放一个表在这里方便查阅..<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p><script src="/js/pdfobject.js"></script><style>    /* Only resize the element if PDF is embedded */    .pdfobject-container {        width: 800px;        height: 900px;    }</style><center><div id="my-container"></div></center><script>    PDFObject.embed("https://i.linuxtoy.org/files/pdf/fwunixref.pdf", "#my-container");</script><div class="footnotes"><hr><ol><li id="fn1"><p>该梗的出处见《【成龙】我的洗发液》: <a href="https://www.bilibili.com/video/av2023391" class="uri" target="_blank" rel="noopener">https://www.bilibili.com/video/av2023391</a><a href="#fnref1">↩</a></p></li><li id="fn2"><p>转载自 <a href="https://linuxtoy.org/archives/unix-linux-command-cheat-sheet.html" class="uri" target="_blank" rel="noopener">https://linuxtoy.org/archives/unix-linux-command-cheat-sheet.html</a><a href="#fnref2">↩</a></p></li></ol></div>]]></content>
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件配置 </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>组合数学[1]——球放入盒子的方案数</title>
      <link href="/2018/09/17/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E2%80%94%E2%80%94%E7%90%83%E6%94%BE%E5%85%A5%E7%9B%92%E5%AD%90%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/"/>
      <content type="html"><![CDATA[<p>近日观室友做面试题有感, 恰好遇到了球装盒子的问题, 顺手整理一波.</p><blockquote><p><span class="math inline">\(n\)</span> 个球放入 <span class="math inline">\(m\)</span> 个盒子, 共有多少种不同的方案?</p></blockquote><table><thead><tr class="header"><th align="center">球</th><th align="center">盒</th><th align="center">允许空</th><th align="center">方案数</th></tr></thead><tbody><tr class="odd"><td align="center">不同</td><td align="center">不同</td><td align="center">是</td><td align="center"><span class="math inline">\(m^n\)</span></td></tr><tr class="even"><td align="center">不同</td><td align="center">不同</td><td align="center">否</td><td align="center"><span class="math inline">\(m!\cdot S(n,m)\)</span></td></tr><tr class="odd"><td align="center">不同</td><td align="center">相同</td><td align="center">是</td><td align="center"><span class="math inline">\(\sum\limits_{k=0}^m S(n,k)\)</span></td></tr><tr class="even"><td align="center">不同</td><td align="center">相同</td><td align="center">否</td><td align="center"><span class="math inline">\(S(n,m)\)</span></td></tr><tr class="odd"><td align="center">相同</td><td align="center">不同</td><td align="center">是</td><td align="center"><span class="math inline">\(\binom{n+m-1}{m-1}\)</span></td></tr><tr class="even"><td align="center">相同</td><td align="center">不同</td><td align="center">否</td><td align="center"><span class="math inline">\(\binom{n-1}{m-1}\)</span></td></tr><tr class="odd"><td align="center">相同</td><td align="center">相同</td><td align="center">是</td><td align="center"><span class="math inline">\(dp(n,m)\)</span></td></tr><tr class="even"><td align="center">相同</td><td align="center">相同</td><td align="center">否</td><td align="center"><span class="math inline">\(dp(n-m,m)\)</span></td></tr></tbody></table><a id="more"></a><h2 id="球不同">球不同</h2><h3 id="盒子不同">盒子不同</h3><h4 id="不允许有空盒子">不允许有空盒子</h4><p>可以先视盒子为相同, 方案数为 <span class="math inline">\(S(n,m)\)</span>（参见下文）, 再考虑盒子的全排列.</p><blockquote><p><span class="math inline">\(n\)</span> 个不同的球放入 <span class="math inline">\(m\)</span> 个不同的盒子, 盒子不允许为空, 方案数为 <span class="math inline">\(m!\cdot S(n,m)\)</span>.</p></blockquote><h4 id="允许有空盒子">允许有空盒子</h4><p>最简单的情况没有之一:</p><blockquote><p><span class="math inline">\(n\)</span> 个不同的球放入 <span class="math inline">\(m\)</span> 个不同的盒子, 盒子允许为空, 方案数为 <span class="math inline">\(m^n\)</span>.</p></blockquote><h3 id="盒子相同">盒子相同</h3><h4 id="不允许有空盒子-1">不允许有空盒子</h4><blockquote><p><span class="math inline">\(n\)</span> 个不同的球放入 <span class="math inline">\(m\)</span> 个相同的盒子, 盒子不允许为空, 方案数为第二类Stirling数 <span class="math inline">\(S(n,m)\)</span>.</p></blockquote><p><strong>简略证明:</strong> 对于第 <span class="math inline">\(n\)</span> 个球, 有且仅有如下两种情况:</p><ol style="list-style-type: decimal"><li><strong>前 <span class="math inline">\(n-1\)</span> 个球的放法已经保证了 <span class="math inline">\(m\)</span> 个盒子都不空:</strong> 此时只需将 <span class="math inline">\(n\)</span> 号球随意放即可, 方案数为 <span class="math inline">\(mS(n-1,m)\)</span>;</li><li><strong>前 <span class="math inline">\(n-1\)</span> 个球放好后有且仅有一个盒子是空的:</strong> 此时必须将 <span class="math inline">\(n\)</span> 号球放入空盒中, 方案数为 <span class="math inline">\(S(n-1,m-1)\)</span>.</li></ol><p>于是, 此时的方案数递推式为 <span class="math display">\[S(n,m)=mS(n-1,m)+S(n-1,m-1)\]</span> 初值为:</p><ul><li><span class="math inline">\(S(0,m)=1\)</span>. (没球的方案只有一种)</li><li><span class="math inline">\(S(n,1)=1\)</span>. (一个盒子的方案只有一种)</li></ul><p>一段计算该种方案数的代码如下（递归版本）:</p><figure class="highlight c++"><figcaption><span>球不同, 盒相同, 不许空</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; m) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 球比盒子还少, 无法满足盒子非空</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span> || m == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 没球 or 一个盒子</span></span><br><span class="line">    <span class="keyword">return</span> m * dp(n - <span class="number">1</span>, m) + dp(n - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="允许有空盒子-1">允许有空盒子</h4><blockquote><p><span class="math inline">\(n\)</span> 个不同的球放入 <span class="math inline">\(m\)</span> 个相同的盒子, 盒子允许为空, 方案数为 <span class="math inline">\(\sum\limits_{k=0}^m S(n,k)\)</span>.</p></blockquote><p>只需要枚举非空箱子的个数, 然后按照上一种情况的方法来计算, 求和即可. 在计算时最好先预处理出 <span class="math inline">\(S(n,m)\)</span> 的值.</p><h2 id="球相同">球相同</h2><h3 id="盒子不同-1">盒子不同</h3><h4 id="不允许有空盒子-2">不允许有空盒子</h4><blockquote><p><span class="math inline">\(n\)</span> 个相同的球放入 <span class="math inline">\(m\)</span> 个不同的盒子, 盒子不允许为空, 方案数为 <span class="math inline">\(\binom{n-1}{m-1}\)</span>.</p></blockquote><p><strong>简略证明:</strong> 将 <span class="math inline">\(n\)</span> 球装入 <span class="math inline">\(m\)</span> 个盒子, 相当于插 <span class="math inline">\(m-1\)</span> 个板. 由于不允许为空, 故在 <span class="math inline">\(n-1\)</span> 个空中选出 <span class="math inline">\(m-1\)</span> 个插板即可.</p><h4 id="允许有空盒子-2">允许有空盒子</h4><blockquote><p><span class="math inline">\(n\)</span> 个相同的球放入 <span class="math inline">\(m\)</span> 个不同的盒子, 盒子允许为空, 方案数为 <span class="math inline">\(\binom{n+m-1}{m-1}\)</span>.</p></blockquote><p><strong>简略证明:</strong> <span class="math inline">\(n\)</span> 个球放完之后, 在每个盒子中都加一个球, 此时一定无空箱. 这说明此时的方案数不多于 <span class="math inline">\(n+m\)</span> 个相同的球放入 <span class="math inline">\(m\)</span> 个不同盒子的方案数. 反过来也可证明另一边的不等式, 于是此时的方案数就是<span class="math inline">\(n+m\)</span> 个相同的球放入 <span class="math inline">\(m\)</span> 个不同盒子的方案数.</p><h3 id="盒子相同-1">盒子相同</h3><h4 id="不允许有空盒子-3">不允许有空盒子</h4><blockquote><p><span class="math inline">\(n\)</span> 个相同的球放入 <span class="math inline">\(m\)</span> 个相同的盒子, 盒子不允许为空, 方案数为 <span class="math inline">\(dp(n-m,m)\)</span>.</p></blockquote><p>其中 <span class="math inline">\(dp(n,m)\)</span> 为下一种情况的方案数.</p><h4 id="允许有空盒子-3">允许有空盒子</h4><blockquote><p><span class="math inline">\(n\)</span> 个相同的球放入 <span class="math inline">\(m\)</span> 个相同的盒子, 盒子允许为空, 方案数为 <span class="math inline">\(dp(n,m)\)</span>.</p></blockquote><p><strong>计算思路:</strong>: 在放置 <span class="math inline">\(n\)</span> 个球的时候, 有且仅有如下两种策略:</p><ol style="list-style-type: decimal"><li><strong>给每个盒子放一个球:</strong> 还剩下 <span class="math inline">\(n-m\)</span> 个球, 故此时的方案数为 <span class="math inline">\(dp(n-m,m)\)</span>;</li><li><strong>至少一个盒子不放球:</strong> 可以扔掉一个空盒子, 故此时的方案数为 <span class="math inline">\(dp(n,m-1)\)</span>.</li></ol><p>于是此种情况的递推式为: <span class="math display">\[dp(n,m)=dp(n-m,m)+dp(n,m-1)\]</span> 边界值为:</p><ul><li><span class="math inline">\(S(0,m)=1\)</span>. (没球的方案只有一种)</li><li><span class="math inline">\(S(n,1)=1\)</span>. (一个盒子的方案只有一种)</li></ul><p>上述推导过程中我们做了 <span class="math inline">\(n\geqslant m\)</span>, 即&quot;球不少于盒子&quot;的假设. 当该假设不成立时, <span class="math inline">\(n\)</span> 个苹果至多放满 <span class="math inline">\(n\)</span> 个盘子, 故此时方案数实际上为 <span class="math inline">\(dp(n,n)\)</span>.</p><p>一段计算该情况方案数的代码如下（递归版本）:</p><figure class="highlight c++"><figcaption><span>球相同, 盒相同, 允许空 </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(m &lt; n) <span class="keyword">return</span> dp(m, m);</span><br><span class="line">    <span class="keyword">return</span> dp(m, n - <span class="number">1</span>) + dp(m - n, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2015年近世代数期末考试试卷</title>
      <link href="/2018/09/17/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62015%E5%B9%B4%E8%BF%91%E4%B8%96%E4%BB%A3%E6%95%B0%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7/"/>
      <content type="html"><![CDATA[<h2 id="试题">试题</h2><ol style="list-style-type: decimal"><li>(20分) <span class="math inline">\(\mathbb{Z}_n=\{[0],[1],\cdots,[n-1]\}\)</span> 表示模 <span class="math inline">\(n\)</span> 的剩余类加群.<ol style="list-style-type: decimal"><li>写出 <span class="math inline">\(\mathbb{Z}_4\)</span> 的加法运算表.</li><li>写出 <span class="math inline">\(\mathbb{Z}_6\)</span> 的所有子群.</li><li><span class="math inline">\(\mathbb{Z}_7\)</span> 有几个子群?</li><li><span class="math inline">\(\mathbb{Z}_{28}\)</span> 有几个 <span class="math inline">\(7\)</span> 阶元?</li></ol></li><li>(20分) <span class="math inline">\(\mathbb{Z}_n^*=\{[a]\in\mathbb{Z}_n~|~a~与~n~互素\}\)</span>.<ol style="list-style-type: decimal"><li>证明: <span class="math inline">\(\mathbb{Z}_n^*\)</span> 关于乘法 <span class="math inline">\([a][b]=[ab]\)</span> 构成一个阿贝尔群.</li><li>求 <span class="math inline">\([3]\)</span> 在 <span class="math inline">\(\mathbb{Z}_8^*\)</span> 以及 <span class="math inline">\([5]\)</span> 在 <span class="math inline">\(\mathbb{Z}_{13}^*\)</span> 中的逆元.</li></ol></li><li>(15分) 用 <span class="math inline">\(S_5\)</span> 表示 <span class="math inline">\(5\)</span> 次对称群.<ol style="list-style-type: decimal"><li><span class="math inline">\(\sigma=(12345)\)</span> 是 <span class="math inline">\(S_5\)</span> 中的几阶元?</li><li><span class="math inline">\(S_5\)</span> 中与 <span class="math inline">\(\sigma\)</span> 共轭的元素有几个?</li><li>写出循环群 <span class="math inline">\(\langle\sigma\rangle\)</span> 中的所有元素. <span class="math inline">\(\langle\sigma\rangle\)</span> 是不是 <span class="math inline">\(S_5\)</span> 的正规子群?</li></ol></li><li>(20分)<ol style="list-style-type: decimal"><li>写出整数环 <span class="math inline">\(\mathbb{Z}\)</span> 的所有极大理想.</li><li>写出模 <span class="math inline">\(18\)</span> 的剩余类环 <span class="math inline">\(\mathbb{Z}_{18}\)</span> 的所有极大理想.</li><li><span class="math inline">\(x^2+1\)</span> 是否是 <span class="math inline">\(\mathbb{Z}_3[x]\)</span> 中的不可约多项式?</li><li><span class="math inline">\(\mathbb{Z}_3[x]/\langle x^2+1\rangle\)</span> 是怎样的环?</li></ol></li><li>(15分) 用 <span class="math inline">\(R\)</span> 表示环 <span class="math inline">\(\mathbb{Z}[i]/\langle 1+3i \rangle\)</span>, 其中 <span class="math inline">\(\mathbb{Z}[i]\)</span> 表示高斯整环, 证明:<ol style="list-style-type: decimal"><li>在 <span class="math inline">\(R\)</span> 中, <span class="math inline">\([i]=[3]\)</span>, <span class="math inline">\([10]=[0]\)</span>, <span class="math inline">\([a+bi]=[a+3b]\)</span>, <span class="math inline">\(\forall a, b\in\mathbb{Z}\)</span>.</li><li><span class="math inline">\(\varphi:\mathbb{Z}\to R~(a\mapsto [a])\)</span> 是环的满同态.</li><li><span class="math inline">\(\ker\varphi=10\mathbb{Z}\)</span>. 从而 <span class="math inline">\(R=\mathbb{Z}_{10}\)</span>.</li></ol></li><li>(10分)<ol style="list-style-type: decimal"><li>设 <span class="math inline">\(E=F(\alpha)\)</span> 是域 <span class="math inline">\(F\)</span> 的单超越扩域, <span class="math inline">\(\beta\in E\backslash F\)</span>. 证明: <span class="math inline">\(\alpha\)</span> 是 <span class="math inline">\(F(\beta)\)</span> 上的代数元.</li><li>证明或否定一下命题: 设 <span class="math inline">\(E/F\)</span> 是域扩张, <span class="math inline">\(\alpha\in E\)</span>, <span class="math inline">\(m,n\in\mathbb{Z}^+\)</span>. 如果 <span class="math inline">\(\alpha\)</span> 是 <span class="math inline">\(F\)</span> 上 <span class="math inline">\(n\)</span> 次代数元, 且 <span class="math inline">\(m\)</span> 与 <span class="math inline">\(n\)</span> 互素, 那么 <span class="math inline">\(\alpha^m\)</span> 也是 <span class="math inline">\(F\)</span> 上的 <span class="math inline">\(n\)</span> 次代数元, 且 <span class="math inline">\(F(\alpha^m)=F(\alpha)\)</span>.</li></ol></li></ol><h2 id="懒没有解答">懒！没有解答！</h2>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 抽象代数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018北京马拉松小记</title>
      <link href="/2018/09/16/2018%E5%8C%97%E4%BA%AC%E9%A9%AC%E6%8B%89%E6%9D%BE%E5%B0%8F%E8%AE%B0/"/>
      <content type="html"><![CDATA[<p>本次北马, 我幸运地以志愿者身份参与了赛前的筹备工作. 9.13-9.15三天里结识了很多有趣的人, 总算不虚此行.</p><blockquote><p>三天三个师弟, 还有丢手机的小姐姐及其大师兄, 77岁仍然坚持跑步的老奶奶, 还有一起工作的志愿者董跃、王超、王辰, 以及二位负责人. 很高兴认识各位.</p></blockquote><a id="more"></a><h2 id="一句废话">一句废话</h2><p>这事实上是一篇流水账都不算的东西==</p><h2 id="day-0-9.12">DAY 0: 9.12</h2><ul><li>几日前接到通知, 12日下午要去领志愿者物资并进行简单岗前培训. 我和孙李师弟都被分在换票组, 师弟正是组长.</li><li>11日晚才了解到, 孙李师弟前两天不能如期到岗, 故负责人生哥将组长换为了我. (一脸蒙蔽)</li><li>12日中午记错了地点...有点蠢...还以为地点是在人大, 看到群里大家发位置才明白是在农展馆Orz 匆忙坐公交前往, 但仍然迟到30m... 太蠢了.</li><li>志愿者感觉很大一部分是北航和人大的. Orz, Orz.</li><li>换票组喊了很久没人到...最终也只有我和董跃到了Orz.</li></ul><h2 id="day-1-9.13">DAY 1: 9.13</h2><blockquote><p>きょうの後輩: 李嘉民！</p></blockquote><ul><li>按照通知7:30就要赶到, 6:20匆匆在学五吃过早饭直接赶往场地.</li><li>基本准时赶到后, 竟然被通知为9:15开始入场... 这里必须得吐槽一下..</li><li>本来被安排的换票小屋被大妈带领一群小妹妹占领了（？？？</li><li>于是在手环处前面做疏导工作（我总觉得是无用功）... 中午给大家发饭吃, 至此, 换票组已彻底沦为机(打)动(杂)组.</li><li>第一天下午真的什么事情也没有, 人流量较小, 手环处前面根本不需要疏导, 和师弟还有董跃到处摸鱼, 最后提前1h撤了...</li><li>在马拉松博览会场馆内留了个影 <img src="http://pcoeutp54.bkt.clouddn.com/单人.jpg?imageMogr2/auto-orient" width="600" alt="2018北马留念"></li></ul><h2 id="day-2-9.14">DAY 2: 9.14</h2><blockquote><p>きょうの後輩: 冶文斌！</p></blockquote><center><strong>直白地讲: 这！一！整！天！都！什！么！事！情！也！没！有！</strong></center><ul><li>上午: 摸鱼.</li><li>中午: 找了个长凳睡了一觉？？被蚊子叮了俩包很气..</li><li>下午: 摸鱼.<ul><li>偶遇丢手机的小姐姐及其大师兄 <del>我本来以为人家俩是爷爷和孙女...囧</del>, 帮二位联系咨询台和广播台...总而言之绕了一大圈, 最后轻松找到了.</li><li>被小姐姐安利了几发跑步...其实自己也有一点这样的想法, 所以顺便也了解了一下.</li><li>找手机期间小姐姐还以为我志愿工作忙...其实啥事儿也没有...有点惭愧.</li><li>找完手机送走二位果断找到师弟继续开始摸鱼...<del>说好的惭愧呢</del></li></ul></li><li>附一张和二位的合影（才发现小姐姐比大师兄高） <img src="http://pcoeutp54.bkt.clouddn.com/丢手机.jpg?imageMogr2/auto-orient" width="600" alt="与丢手机的二位合影"></li></ul><h2 id="day-3-9.15">DAY 3: 9.15</h2><blockquote><p>きょうの後輩: 孙李本尊！</p></blockquote><ul><li>起得/到得比D1还早Orz... 听说这一天要入场1w7的选手Orz.</li><li>早上所有生哥这里的志愿者来了一发大合影... <img src="http://olgwnj89q.bkt.clouddn.com/大合影.jpg?imageMogr2/auto-orient" width="600" alt="一发大合影"></li><li>和师弟+董跃一起换到了刷身份证的岗位, 真·坐了一天...</li><li>很简单很机械很没有技术含量的岗位...竟然被一个妹子（大概是什么负责人 or 组委会的人吧）说成是很困难很有技术含量很需要学习的工作？？？还把虚拟机称为“在一个电脑中打开另一个电脑”？？？因此对生哥把人调走表示非常不满, 还顺手打了一波小报告？？敝人见识短浅, 表示不解...</li><li>全程不涉及任何虚拟机操作...点点鼠标就完事...相当无聊的工作.</li><li>偶遇太原老乡王辰, 很开朗健谈的妹子（</li><li>仅有的慰藉就是和周围志愿者谈笑风生 &amp; 偶尔会遇到外国选手, 听到了各种口音的英语（</li><li>上午人很多, 直到中午, 几乎一刻不得闲. 下午人渐少, 晚饭后基本和第一日下午一样了, 加上晚上有事, 就带着师弟和董跃一起撤了.</li><li>晚饭后在会场闲逛, 顺手和啦啦队小姐姐合了一张影（ <img src="http://pcoeutp54.bkt.clouddn.com/啦啦队.jpg?imageMogr2/auto-orient" width="600" alt="与啦啦队合影"></li><li>临走和二位负责人合影 <img src="http://pcoeutp54.bkt.clouddn.com/五人合影.jpg?imageMogr2/auto-orient" width="600" alt="与负责人合影"></li></ul>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 志愿 </tag>
            
            <tag> 运动 </tag>
            
            <tag> 马拉松 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018毕业季留念</title>
      <link href="/2018/07/30/2018%E6%AF%95%E4%B8%9A%E5%AD%A3%E7%95%99%E5%BF%B5/"/>
      <content type="html"><![CDATA[<blockquote><p>毕业季前后忙着夏令营和期末等各种事情, 来不及整理照片. 最近终于有空, 稍做整理. 没有进行什么排版, 都是高清大图（</p></blockquote><ul><li>本来想用JS搞一些bling-bling的特效, 但是搞了一个小时宣告失败... 我耐心很有限[手动再见]</li><li><strong><code>时间仓促, 很多朋友们没有来得及合影.. 小小的抱歉一下, 我没有忘记大家Orz</code>.</strong></li></ul><a id="more"></a><h2 id="野鸡115">野鸡115</h2><blockquote><p>第一个要讲的当然就是野鸡115, 一群野鸡的四年.</p></blockquote><h3 id="野鸡115的摆拍">野鸡115的摆拍</h3><h4 id="展板前">展板前</h4><blockquote><p>是时候欣赏大家的蹲♂姿了. 骚犇以绝对优势胜出.</p></blockquote><ul><li>第一张郭犇在蜜汁抓♂胸？<center><img src="http://pcoeutp54.bkt.clouddn.com/3.jpg?imageMogr2/auto-orient" width="600" alt="毕业快乐展板-1"></center></li><li>第二张我看起来非常像是闭眼了. 虽然放大会发现没有完全闭上.<center><img src="http://pcoeutp54.bkt.clouddn.com/4.jpg?imageMogr2/auto-orient" width="600" alt="毕业快乐展板-2"></center></li><li>第三张我和郭犇正常了, 可丁丁已经睡着了.<center><img src="http://pcoeutp54.bkt.clouddn.com/5.jpg?imageMogr2/auto-orient" width="600" alt="毕业快乐展板-3"></center></li></ul><h4 id="电子楼">电子楼</h4><blockquote><p>大家都是信科走出来的, 当然要和电子楼来两张.</p></blockquote><center><img src="http://pcoeutp54.bkt.clouddn.com/6.jpg?imageMogr2/auto-orient" width="600" alt="电子楼门前-1"></center><center><img src="http://pcoeutp54.bkt.clouddn.com/8.jpg?imageMogr2/auto-orient" width="600" alt="电子楼门前-2"></center><h4 id="主楼和校训碑">主楼和校训碑</h4><blockquote><p>算是师大的两个标志性建筑物.</p></blockquote><center><img src="http://pcoeutp54.bkt.clouddn.com/10.jpg?imageMogr2/auto-orient" width="600" alt="主楼前"></center><center><img src="http://pcoeutp54.bkt.clouddn.com/12.jpg?imageMogr2/auto-orient" width="600" alt="校训碑, 没有猫哥Orz"></center><h4 id="科技楼前">科技楼前</h4><center><img src="http://pcoeutp54.bkt.clouddn.com/2.jpg?imageMogr2/auto-orient" width="600" alt="寝室在科技楼前"></center><h3 id="散伙前的最后一张">散伙前的最后一张</h3><blockquote><p>郭犇惺忪的睡眼是此张照片的最大看点.</p></blockquote><center><img src="http://pcoeutp54.bkt.clouddn.com/1.jpg?imageMogr2/auto-orient" width="600" alt="各位临走时115的最后一张合影, 可惜猫哥不在."></center><h3 id="野鸡115与乱入的兄弟们">野鸡115与乱入的兄弟们</h3><h4 id="乱入的朱彦丞">乱入的朱彦丞</h4><blockquote><p>无孔不入（ 其实最开头的一张也有他.</p></blockquote><ul><li>电子楼<center><img src="http://pcoeutp54.bkt.clouddn.com/7.jpg?imageMogr2/auto-orient" width="600" alt="电子楼+朱彦丞-1"></center><center><img src="http://pcoeutp54.bkt.clouddn.com/9.jpg?imageMogr2/auto-orient" width="600" alt="电子楼门前+朱彦丞-2"></center></li><li>主楼<center><img src="http://pcoeutp54.bkt.clouddn.com/11.jpg?imageMogr2/auto-orient" width="600" alt="主楼前+朱彦丞"></center></li></ul><h4 id="乱入的小boo">乱入的小boo</h4><ul><li>里面仍然有朱神, Orz.<center><img src="http://pcoeutp54.bkt.clouddn.com/13.jpg?imageMogr2/auto-orient" width="600" alt="校训碑+小boo+朱彦丞"></center></li></ul><h2 id="与117的合影">与117的合影</h2><h3 id="乱入117寝室合照">乱入117寝室合照</h3><center><img src="http://pcoeutp54.bkt.clouddn.com/14.jpg?imageMogr2/auto-orient" width="600" alt="与117寝室的合影"></center><h3 id="与泽坤丁丁合影">与泽坤+丁丁合影</h3><blockquote><p>事实上这是第一波合影. 感谢摄影师邱哥.</p></blockquote><h4 id="三人合影">三人合影</h4><blockquote><p>全部都是在教九小花园拍的. 丁丁是115最胖, 石锤了.</p></blockquote><center><img src="http://pcoeutp54.bkt.clouddn.com/15.jpg?imageMogr2/auto-orient" width="600" alt="与泽坤+丁丁的合影-1"></center><center><img src="http://pcoeutp54.bkt.clouddn.com/16.jpg?imageMogr2/auto-orient" width="600" alt="与泽坤+丁丁的合影-2"></center><center><img src="http://pcoeutp54.bkt.clouddn.com/17.jpg?imageMogr2/auto-orient" width="600" alt="与泽坤+丁丁的合影-3"></center><center><img src="http://pcoeutp54.bkt.clouddn.com/18.jpg?imageMogr2/auto-orient" width="600" alt="与泽坤+丁丁的合影-4"></center><center><img src="http://pcoeutp54.bkt.clouddn.com/19.jpg?imageMogr2/auto-orient" width="600" alt="与泽坤+丁丁的合影-5"></center><h4 id="与泽坤单独合影">与泽坤单独合影</h4><blockquote><p>容易看出, 仍然是在教九小花园.</p></blockquote><center><img src="http://pcoeutp54.bkt.clouddn.com/20.jpg?imageMogr2/auto-orient" width="600" alt="与泽坤的合影"></center><h2 id="信科男篮黄金一代">14信科男篮黄金一代</h2><blockquote><p>轮到我装逼了! 四年三座奖杯, 两进总决赛. 照片比较多, 分类比较细.</p></blockquote><h3 id="单人照">单人照</h3><blockquote><p>抱着奖杯装逼的时刻, 四年仅此一回.</p></blockquote><h4 id="侯彦丞">侯彦丞</h4><center><img src="http://pcoeutp54.bkt.clouddn.com/31.jpg?imageMogr2/auto-orient" width="600" alt="侯彦丞"></center><h4 id="贾鑫">贾鑫</h4><center><img src="http://pcoeutp54.bkt.clouddn.com/32.jpg?imageMogr2/auto-orient" width="600" alt="贾鑫"></center><h4 id="李喆琛">李喆琛</h4><center><img src="http://pcoeutp54.bkt.clouddn.com/33.jpg?imageMogr2/auto-orient" width="600" alt="李喆琛"></center><h4 id="王唯">王唯</h4><center><img src="http://pcoeutp54.bkt.clouddn.com/34.jpg?imageMogr2/auto-orient" width="600" alt="王唯"></center><h4 id="王伟程">王伟程</h4><center><img src="http://pcoeutp54.bkt.clouddn.com/35.jpg?imageMogr2/auto-orient" width="600" alt="王伟程"></center><h3 id="邱季端北合影">邱季端北合影</h3><blockquote><p>这里必须恭喜一下lzc同学C位出道.</p></blockquote><h4 id="带奖杯版本">带奖杯版本</h4><ul><li>唯神和鑫神有点gay（<center><img src="http://pcoeutp54.bkt.clouddn.com/36.jpg?imageMogr2/auto-orient" width="600" alt="信科14黄金一代在邱季端的合影-1"></center></li><li>果然分开就没那么gay了.<center><img src="http://pcoeutp54.bkt.clouddn.com/37.jpg?imageMogr2/auto-orient" width="600" alt="信科14黄金一代在邱季端的合影-2"></center></li></ul><h4 id="无奖杯版本">无奖杯版本</h4><ul><li>唯神又和王队有点gay!<center><img src="http://pcoeutp54.bkt.clouddn.com/40.JPG?imageMogr2/auto-orient" width="600" alt="信科14黄金一代在邱季端的合影-3"></center></li><li>分开之后果然没那么gay了.<center><img src="http://pcoeutp54.bkt.clouddn.com/41.JPG?imageMogr2/auto-orient" width="600" alt="信科14黄金一代在邱季端的合影-4"></center></li><li>鑫神-唯神-王队! 唯神选择了和鑫神gay.<center><img src="http://pcoeutp54.bkt.clouddn.com/42.JPG?imageMogr2/auto-orient" width="600" alt="信科14黄金一代在邱季端的合影-5"></center></li></ul><h3 id="在篮球场的合影">在篮球场的合影</h3><h4 id="站版本">站版本</h4><ul><li>分的比较开, 显得略有零散.<center><img src="http://pcoeutp54.bkt.clouddn.com/43.JPG?imageMogr2/auto-orient" width="600" alt="信科14黄金一代在篮球场的合影-1"></center></li><li>站成一团果然紧凑多了. 重要的是这次一点也不gay?<center><img src="http://pcoeutp54.bkt.clouddn.com/44.JPG?imageMogr2/auto-orient" width="600" alt="信科14黄金一代在篮球场的合影-2"></center></li></ul><h4 id="坐版本">坐版本</h4><blockquote><p>有点……喜感?</p></blockquote><ul><li>大家一起抬头看狂, 侯老大不禁感叹: 篮筐像大海一样广阔.<center><img src="http://pcoeutp54.bkt.clouddn.com/45.JPG?imageMogr2/auto-orient" width="600" alt="信科14黄金一代在篮球场的合影-1 坐着有点奇怪"></center></li><li>大家都转过来了, 好像有一丢丢不对称?<center><img src="http://pcoeutp54.bkt.clouddn.com/47.JPG?imageMogr2/auto-orient" width="600" alt="信科14黄金一代在篮球场的合影-2 转过来有点逗"></center></li><li>大家忽然又转过去了? 诶, 等等我...<center><img src="http://pcoeutp54.bkt.clouddn.com/46.JPG?imageMogr2/auto-orient" width="600" alt="信科14黄金一代在篮球场的合影-3 只有我一个人转过来就更加蠢.."></center></li></ul><h3 id="与师弟们的合影">与师弟们的合影</h3><blockquote><p>这是将荣誉和使命交给师弟们（严肃点不许笑）</p></blockquote><ul><li>恭喜李家和小同学C位出道.<center><img src="http://pcoeutp54.bkt.clouddn.com/38.jpg?imageMogr2/auto-orient" width="600" alt="信科14黄金一代+17师弟在邱季端的合影-1"></center></li><li>这个角度有点刁, 后排都被挡了一半脸.<center><img src="http://pcoeutp54.bkt.clouddn.com/39.jpg?imageMogr2/auto-orient" width="600" alt="信科14黄金一代+17师弟在邱季端的合影-2"></center></li></ul><h2 id="各种旧相识">各种旧相识</h2><h3 id="年同校的妹子">16年同校的妹子</h3><blockquote><p>小学 + 初中 + 高中 + 大学 = 16年同校. Orz. 可惜研究生不能继续同校了_(:з」∠)_</p></blockquote><ul><li>第一张很正常对吧.<center><img src="http://pcoeutp54.bkt.clouddn.com/24.jpg?imageMogr2/auto-orient" width="600" alt="赵元鼎-1"></center></li><li>但是好像难逃两张照片必有一张表情蠢的魔咒?<center><img src="http://pcoeutp54.bkt.clouddn.com/23.jpg?imageMogr2/auto-orient" width="600" alt="赵元鼎-2"></center></li></ul><h3 id="师大唯一高中同班同学">师大唯一高中同班同学</h3><blockquote><p>这个身高在我们寝室也是准前三水平 —— 大概就是吓坏我室友的水平.</p></blockquote><ul><li>感谢路人赠送的蜜汁气球.<center><img src="http://pcoeutp54.bkt.clouddn.com/21.jpg?imageMogr2/auto-orient" width="600" alt="郭嘉宝-1"></center></li><li>我这个表情好像有点蠢.<center><img src="http://pcoeutp54.bkt.clouddn.com/22.jpg?imageMogr2/auto-orient" width="600" alt="郭嘉宝-2"></center></li></ul><h3 id="小学课外班相识的鸡哥">小学课外班相识的鸡哥</h3><blockquote><p>按次序应当是师大第二个和我认识的人. 妹子也是高中同学Orz<br>（同志, 你听说过学霸情侣么? ）</p></blockquote><center><img src="http://pcoeutp54.bkt.clouddn.com/27.jpg?imageMogr2/auto-orient" width="600" alt="与鸡哥的合影"></center><center><img src="http://pcoeutp54.bkt.clouddn.com/28.jpg?imageMogr2/auto-orient" width="600" alt="与鸡哥+铭轩的合影"></center><h3 id="乒乓球师兄">&quot;乒乓球师兄&quot;</h3><blockquote><p>在师兄离校前夕和丁丁约到了师兄打球, 幸运地碰到了屈老师. Orz.</p></blockquote><ul><li>师兄的身高是我和丁丁的等差中项.<center><img src="http://pcoeutp54.bkt.clouddn.com/25.jpg?imageMogr2/auto-orient" width="600" alt="与丁丁+张玉潇师兄的合影"></center></li><li>希望我像屈老师这个年龄也能身体这么好Orz.<center><img src="http://pcoeutp54.bkt.clouddn.com/26.jpg?imageMogr2/auto-orient" width="600" alt="与丁丁+屈国峰老师的合影"></center></li></ul><h3 id="牛b的想爷">牛b的想爷</h3><blockquote><p>想爷太强了, 只有Orz.</p></blockquote><center><img src="http://pcoeutp54.bkt.clouddn.com/29.jpg?imageMogr2/auto-orient" width="600" alt="与想爷的合影"></center><h3 id="一起打铁的兄弟">一起打铁的兄弟</h3><blockquote><p>四年前一起打铁, 四年后一起合影. Orz一下优秀的前队友们.</p></blockquote><center><img src="http://pcoeutp54.bkt.clouddn.com/30.jpg?imageMogr2/auto-orient" width="600" alt="新生队：许宏旭+曾耀辉+李喆琛"></center>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 毕业 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>保研二三事</title>
      <link href="/2018/07/28/%E4%BF%9D%E7%A0%94%E5%A4%8F%E4%BB%A4%E8%90%A5%E4%BA%8C%E4%B8%89%E4%BA%8B/"/>
      <content type="html"><![CDATA[<p>只是随便写写3月份以来的各种经历. 按时间顺序是北大数科, 软件所, 北大信科.</p><a id="more"></a><h2 id="第一站北大数科">第一站：北大数科</h2><blockquote><p>只是大概谈一下过程吧.</p></blockquote><h3 id="接到通知">接到通知</h3><ul><li>按照飞机童鞋的说法, 考试时间应在4月10日前后, 但实际上的考试时间是在3.31, 略有意外. 经查, 去年的考试时间好像是4.8.</li><li>通知链接: <a href="http://www.math.pku.edu.cn/zygg/68832.htm" target="_blank" rel="noopener">直博生摸底考试通知</a></li></ul><h3 id="初审及考试">初审及考试</h3><h4 id="初审">初审</h4><ul><li>3.23前后接到初审通过的短信, 北大的考试在师大设有考点.</li><li>在北大官网也出了通知: <a href="http://www.math.pku.edu.cn/zygg/68833.htm" target="_blank" rel="noopener">直博生摸底考试初审结果通知</a></li><li>初审要求感觉非常松, 有广撒网的意思.</li></ul><h4 id="考试">考试</h4><ul><li>考试时间是一上午, 北大派老师来监考, 之后会介绍北大的大概情况.</li><li>3.31 正式考试, 满分200分, 数分代数几何各占100, 70, 30.</li><li>我几何学的非常差, 尽管几何题看起来不是很难, 我仍然没有做出来. 并且对题目没有印象了.</li><li>数分题目思路清奇, 当然题目也很清奇...<ul><li>将一个五元店视作一个超市物品到 <span class="math inline">\(\mathbb{R}\)</span> 的函数, 该函数是否可微?</li><li>构造一个夹在 <span class="math inline">\(|x|\)</span> 与 <span class="math inline">\(|x|+1\)</span> 之间的严格下凸函数. 并证明.</li><li>好像有一个类似函数方程/微分方程的东西, 记不起来了.</li><li>题目不能全部记起Orz.</li></ul></li><li>代数题目总共有三道, 其中有30分很简单.<ul><li>30分超级简单的题目, 是一些求子空间交并和维数的题目, 其实就是矩阵瞎搞搞.</li><li>一个分块矩阵的题目, 很好玩, 可是不会做Orz.</li><li>还有一个记不得了.</li></ul></li></ul><h4 id="结果">结果</h4><ul><li>考完感觉一般般, 通过概率应该不大, 但还是和之前联系的夏壁灿老师见了一面.</li><li>夏老师做的是符号计算, 具体来说是可满足性问题SAT/SMT. 夏老师最后表示我的背景适合学习他的方向, 若此次考试未能通过, 9月份可以继续联系.</li><li>我仔细了解了SAT/SMT问题以及夏老师所提及的Z3求解工具, 其实是很有意思的问题, 但是考试未能通过, 我也不可能把未来押到9月份, 故没有继续联系.</li><li>考试结果应该是一个月内就除了, 我只考了60+, 未能通过Orz. 太菜了. 当然就没有后续了.</li></ul><blockquote><p><strong>非常感谢复习期间飞机童鞋(张骏达)给我的一些帮助.</strong></p></blockquote><blockquote><p><strong>非常感谢夏壁灿老师给我等菜鸡一个机会.</strong> 其实在北大信科夏令营之后仍然联系过, 在此不多讨论.</p></blockquote><blockquote><p>自此开始联系其他老师, 主要是应明生老师和曹永知老师.</p></blockquote><h3 id="后续的其他尝试">后续的其他尝试</h3><ul><li>按照时间顺序, 是曹永知老师-&gt;应明生老师.</li><li>我联系老师主要是看方向, 能看懂的话也可以找一篇论文看? 时间仓促, 我没怎么看懂二位的论文...</li><li>要想清楚找老师时要说些什么, 邮件和简历里面捡好听的写. 可以写专业课平均分90+, 但是公选课得61分什么的别写.</li><li>要有自信, 老师看不上自己的话别气馁(</li></ul><h4 id="曹永知老师社会计算">曹永知老师：社会计算</h4><ul><li>曹老师以前是师大数科的博士, 聊起来气氛大概也比较轻松愉快.</li><li>和老师聊天的内容不外乎几条:<ul><li>个人情况, 无须多讲.</li><li>老师情况, 也无须多讲.</li><li>方向细节, 曹老师有几个方向, 其中我兴趣高一点的是社会计算.</li><li>后续操作, 在曹老师的建议下, 开始参加曹老师的讨论班.</li></ul></li></ul><h4 id="应明生老师量子计算">应明生老师：量子计算</h4><ul><li>我最初联系应明生老师是在清华网站上找的, 应老师回信中表示欢迎到软件所的办公室聊一聊.</li><li>最初以为应老师仍然在做逻辑等方向, 但应老师表示现在只做量子计算.</li><li>应老师本人非常随和, 我聊得还挺愉快的? (就是不知道应老师愉快不愉快Orz毕竟我太菜).</li><li>最后应老师表示虽然你成绩差, 但是你这个背景还算合适, 并且我也不是非常看重排名的老师, 所以你可以试试. 最后给了我两本书看.</li><li>接下来一段时间没有太多联系, 主要是在看应老师的书.<ul><li>最初看 Nielsen 的书, 结果有点看不进去, 可能是废话有点多.</li><li>之后开始读应老师自己写的 Foundations... 一书, 比较精炼, 有数学教材的味道. 从此就开始读这本书.</li></ul></li><li>对量子计算有一个大概了解后, 再次与应老师联系, 应老师表示做做习题发给他看.</li><li>大概做了第二章的大部分习题之后, 到了夏令营报名时间. 再次见到应老师就是夏令营了.</li></ul><h2 id="第二站科学院软件所">第二站：科学院软件所</h2><blockquote><p>按时间顺序, 这是我的第一个夏令营.</p></blockquote><h3 id="准备材料">准备材料</h3><ul><li>根据在官网上挂出的<a href="http://www.iscas.ac.cn/yjsjy2016/zsxx2016/201804/t20180428_5004800.html" target="_blank" rel="noopener">通知</a>, 需要准备如下材料:<ol style="list-style-type: decimal"><li>夏令营申请表, <font color="red">须签字</font>;</li><li>成绩单 + 排名证明; 这个吐槽一下, 学院开的貌似是所有成绩都算的那个排名.</li><li>英语水平证明材料; 四六级/TOEFL/IELTS/GRE 等.</li><li>论文/获奖证书等; 社会工作奖这样没有说服力的东西可以不要.</li><li>推免申请表, <font color="red">须签字</font>;</li></ol></li><li>同时须在其申请系统中报名, 详见具体通知.</li><li>其他几点:<ul><li>材料不需要寄送, 只需要在开营的时候带着就可以了.</li><li>成绩单在主楼可以打印.</li><li>需要盖章的地方找学院盖章即可, 我不记得软件所有没有要盖章的地方了.</li></ul></li></ul><h3 id="面试-笔试-只有一道题的考核.">面试? 笔试? 只有一道题的考核.</h3><ul><li>夏令营一共五天, 具体安排如下:<ul><li>D1: 白天报到, 晚上开营+班会. 班会按照姓氏拼音分组, 与师兄师姐交流夏令营相关的问题, 时长大约2h.</li><li>D2: 一个很长的报告+整整一下午的方向介绍, 晚上有鸟巢游览, 没有去.</li><li>D3: 上午仍然是实验室方向介绍, 下午组织考核. 中午吃完饭直接去找应老师, 下午三点就结束了. 也不知道应老师感觉如何.</li><li>D4: 按照安排应是一天考试, 但国重全看老师, 应老师表示不用过来. 自我介绍的slides其实白做了哈哈.</li><li>D5: 体检+退卡. 中午和郭犇吃饭, 偶遇应老师, 应老师给一篇文章读.</li></ul></li><li>在开营的前一两天, 国重的夏盟佶老师电话联系我, 当时在图书馆的我有点emmm 受宠若惊.<ul><li>聊了一下方向, 表示了招收我的意向.</li><li>夏老师做的也是理论计算机, 似乎是复杂性理论和一些组合相关的东西. 曾经也是我非常想学的东西Orz.</li><li>夏老师非常热情, 问我是否联系过老师之类的问题, 我表示联系了yms老师, 场面一度有点尴尬...</li><li>我肥肠感谢夏老师的欣赏Orz. 了解了一下夏老师的研究, 非常佩服夏老师的学术水平.</li></ul></li><li>简单谈一下考核的事情:<ul><li>整体的考核流程应该是 D3下午笔试/机试 + D4全天继续考核, 包括面试.</li><li>国重的考核全听老师的意思, 比方说yms老师只考了我一个题目, 大概2-3h就结束了. D4我完全不用去, 自我介绍slides完全白做了.</li><li>好像应老师在与不在完全不是两种考核方式... 听说去年是四个数学题+一个算法题, 主要包括代数数分和概率论. 还有包括英文自我介绍在内的N对1面试.</li><li>今年应老师亲自面试我, 出了一个拓扑题目(敲黑板划重点, 拓扑! 我也很意外.) 证明Kuratowski十四集定理, 并在 <span class="math inline">\(\mathbb{E}^1\)</span> 中构造一个能生成14个集合的例子. 这是一个很有意思的题目, 据说在凯莱《一般拓扑学》中有此题目, 我没有读过该书.</li><li>考核之后应老师给我发了一封邮件, 然而我没有及时查看Orz... 最后一日在软件所用卡里剩下的钱请郭犇在软件所吃饭, 吃饭时偶遇应老师, 向我提及了邮件的事情, 表示让我发成绩单, 并且读一读论文, 有空时给他讲.</li><li>然而因为16-18日就是北大夏令营, 故论文只读了一小部分, 很惭愧...</li></ul></li><li>夏令营期间去自动化所找郭犇蹭饭, 偶然抓拍到nb的郭犇Orz. 话不多说, 先Orz为敬.<center><img src="http://olgwnj89q.bkt.clouddn.com/%E8%BD%AF%E4%BB%B6%E6%89%80%E5%A4%8F%E4%BB%A4%E8%90%A5-%E9%83%AD%E7%8A%87.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="牛b的郭犇Orz"></center></li></ul><h3 id="关于结果">关于结果</h3><ul><li>听说, 除国重外的实验室, 不会立刻知道结果.</li><li>国重应该全看老师, 但我最终没有全部完成yms老师的考核流程, 所以不太清楚.</li><li>软件所研究生部会给国重老师一个提供自己优秀营员名单的截止日期, 国重的老师须在截止日期之前提交自己的优秀营员名单.</li><li>软件所有一个人性化的双向选择机制, 优秀营员公布后不会直接分派名额. 应充分考虑和尝试后, 再决定是否最终来软件所. 故软件所会给优秀营员长约一个月的缓冲时间, 来尝试其他夏令营 &amp; 做最终决定.</li></ul><blockquote><p><strong>非常感谢应明生老师给我的机会以及夏盟佶老师对我的赏识, 虽然我最后浪费掉了这个机会Orz. 希望自己有朝一日能成为应明生老师这样的大家.</strong></p></blockquote><blockquote><p><strong><font color="blue">非常感谢应老师的学生方望老哥</font>, 非常感谢. 非常感谢. 在我读应老师的书时给予了我非常大量, 真的是非常大量的帮助. 在下感激不尽.</strong></p></blockquote><blockquote><p><strong>同时也非常感谢国重的李页霆师兄在夏令营期间的照顾. 非常感谢.</strong></p></blockquote><h2 id="第三站北大信科">第三站：北大信科</h2><blockquote><p>按时间顺序, 这是我的最后一个夏令营. 当然 总共就俩.</p></blockquote><h3 id="准备材料-等待初审">准备材料 + 等待初审</h3><ul><li>北大在4月底挂出了夏令营的<a href="http://eecs.pku.edu.cn/personnel/YJS/RecruitStudents/6805.shtml" target="_blank" rel="noopener">通知</a>, 原定6.30出入营名单, 但种种原因导致推迟到了7.5前后. <em>(附: <a href="http://eecs.pku.edu.cn/personnel/YJS/RecruitStudents/6979.shtml" target="_blank" rel="noopener">北大信科参营通知</a>)</em></li><li>主要谈谈申请流程.<ul><li>首先是在网上填写申请材料.</li><li>按照通知, 还应准备如下材料:<ol style="list-style-type: decimal"><li>申请表, <font color="red">应该是要签字盖章</font>;</li><li>个人陈述, <font color="red">应该也要签字</font>;</li><li>推荐信, 博士需要找三个副教授以上的老师签推荐信, 我分别找了冯速, 何青, 以及李俊峰老师(此处按年龄排序哈哈哈), <font color="Red">需要骑缝处签字</font>;</li><li>成绩单 + 排名证明;</li><li>英语水平证明材料; 四六级/TOEFL/IELTS/GRE 等.</li><li>论文/获奖证书等. 社会工作奖这样没有说服力的东西可以不要.</li></ol></li><li><strong>所有材料需在指定日期前自己送/邮寄至北大.</strong></li></ul></li></ul><h3 id="机试-面试">机试 + 面试</h3><ul><li>夏令营时间是7.16-7.18, 活动大致安排如下:<ul><li>D1: 上午报到+下午讲座, 实验室方向介绍. 晚上机试热身赛, 各种IDE非常齐全, OpenJudge环境也相当不错.</li><li>D2: 上午讲座+下午座谈会. 上午讲座翘掉了, 座谈会就是和老师聊天. 理论和软工在一起, 满屋子全是软工. 晚上机试, 打得非常崩, 前几天敲了很多题但手还是很生&amp;复习方向有误...</li><li>D3: 按照安排上午8.30开始面试, 事实上理论组下午1.30开始. 和信安+图形学一起, 三个方向加起来才十个人... 面试发挥还凑合, 题目大都答得上来, 但是似乎老师们觉得我成绩一般... 虽然好像确实如此... 但我从不质疑自己的能力, 尽管机试打得非常崩. 晚些时候, 大概吃晚饭时, 最终得到了曹老师的口头承诺, 准备参加曹老师联系的暑期课程.</li></ul></li><li>北大的活动安排十分紧凑. 这里还是主要说说考核.<ul><li>机试热身赛据说是去年的题目, 不算难吧.. 随便写了写. 主要是测环境嘛.</li><li>OpenJudge环境很好, 比poj.org强百倍.<ul><li>支持 <code>#include &lt;bits/stdc++.h&gt;</code>;</li><li>支持 <code>C++11</code>;</li><li>没试过, 应该也支持 <code>rope</code> 吧?</li></ul></li><li>本地编译器非常齐全.<ul><li>按照习惯 我仍然用了 <code>Sublime</code>+命令行. 但是命令行好像有时会有一种奇怪的问题, 连接不上输入的接口.</li><li><code>Code::Blocks</code>, <code>Dec-C++</code> 好像都有. 正式赛用的是codeblocks.</li><li>总之环境很好, 各种环境不背锅. 完全是自己太菜.</li></ul></li><li>正式赛题目我觉得选的一般, 区分度不太好.<ul><li>长时间不摸键盘, 两个水题半个多小时才过, 并且还挂了几次.</li><li>一道线段树/树状数组求逆序, 按理来说是裸题, 可是怎么也写不上来... 完全没想过会考这种东西??? 打比赛的时候哥也是经常写线段树的人, 现在太菜了Orz</li><li>一道带权并查集, GGGGGGG. 复习的时候完全没想过会考带权的???</li><li>以上四个是中文题... 本菜鸡就这样, 中文题卡全场...</li><li>英文题几乎都没有细读, 看出来好像有一个搜索, 然而没怎么搞...</li><li>赛前主要是在补动态规划的内容... 没想到中文题一个也没有??? 太难过了. 复习方向完全偏离, 很难受.</li><li>打得实在太崩, 细节不想多谈.</li></ul></li><li>最后谈一下面试:<ul><li>一般是自己所报方向的老师主面, 我是比较幸运, 是曹老师主面.</li><li>不清楚自我介绍环节是否必须, 反正我没有自我介绍..</li><li>开头是念一段英文的论文, 并翻译. 文段不是很长, 生词也不会多, 就是典型的论文.</li><li>然后就聊一些专业课的内容.</li><li>之后是学习的一些情况, 在此期间被一些老师嫌弃成绩差Orz. 其实是很多公共课成绩差(</li><li>最后一个老师问了一个算法题, 比较简单.</li><li><strong>其实面试略有尴尬的原因, 就是机试打得太菜. 如果机试多过题, 面试会非常有底气.</strong></li></ul></li></ul></li><li>最终算是涉险过关. 开始参加夏立荣老师的暑期课程. 非常巧, 夏立荣老师和曹永知老师以前都是应明生老师的学生.</li></ul><h3 id="关于结果-1">关于结果</h3><ul><li>今年出结果非常快, 面试当晚就有很多人得到了结果. 如果提前联系过老师, 可以直接询问.</li><li>官网挂通知是夏令营结束后的第二天 (周三面试完毕, 周五晚上挂通知).</li><li>由于今年硕士名额大幅减少, 很多方向竞争非常激烈.</li></ul><blockquote><p><strong>两波夏令营期间蹭了几顿饭, 感谢郭犇某天中午的收留. 非常感谢. 上课期间也蹭了几顿饭, 感谢曹老师的学生王海滨老哥以及郭晓熙老哥. 同样非常感谢.</strong></p></blockquote><blockquote><p><strong>也要感谢冯速, 何青, 李俊峰三位老师给我签推荐信.</strong></p></blockquote><blockquote><p><strong>当然也要感谢曹老师和夏老师. 课程非常有趣, 收获良多.</strong></p></blockquote><h2 id="夏令营事后">夏令营事后</h2><ul><li>北大官网出<a href="http://eecs.pku.edu.cn/personnel/YJS/RecruitStudents/7004.shtml" target="_blank" rel="noopener">优秀营员名单</a>后, 自然是与夏壁灿老师, 应明生老师, 以及夏盟佶老师发邮件联系, 告知三位老师自己大致定了北大信科的事情. 三位老师都很友好, 我非常感激三位老师的认可. 其实加上曹老师, 四位老师的方向我都很喜欢, 但已经定了曹老师这里, 不可得兼.</li><li>当然, 更要感谢曹老师的认可了Orz... 希望自己能真正做出自己的成果.</li></ul><h2 id="尾声">尾声</h2><p>2018.9.28 最终在学信网上填写了个人信息并进行了报名和确认. 保研之路终于算是走完了.</p><center><img src="http://olgwnj89q.bkt.clouddn.com/待录取通知.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="待录取通知"></center>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 计算机 </tag>
            
            <tag> 北大 </tag>
            
            <tag> 软件所 </tag>
            
            <tag> 保研 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>点估计——最大似然估计、最大后验概率估计和贝叶斯估计</title>
      <link href="/2018/07/26/%E7%82%B9%E4%BC%B0%E8%AE%A1%E2%80%94%E2%80%94%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1%E3%80%81%E6%9C%80%E5%A4%A7%E5%90%8E%E9%AA%8C%E4%BC%B0%E8%AE%A1%E5%92%8C%E8%B4%9D%E5%8F%B6%E6%96%AF%E4%BC%B0%E8%AE%A1/"/>
      <content type="html"><![CDATA[<p>在北大听夏立荣老师的《经济与计算》课程时有一个小问题没有搞明白, 课后花了一些时间, 算是复习了之前数理统计学的MLE, 顺便研究了一下MAP和Bayes估计.</p><blockquote><p>一枚硬币，掷14次，有10次正面向上. 请估计接下来两次都出现正面向上的概率. (如下图所示)</p></blockquote><center><img src="http://olgwnj89q.bkt.clouddn.com/xia_problem.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/quality/75%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="老师的slides截图"></center><a id="more"></a><h2 id="简短分析">简短分析</h2><ul><li>一些显而易见的信息：<ul><li><strong>参数</strong>: 题目中只有一个参数, 那就是单次实验中正面向上的概率 <span class="math inline">\(\theta\)</span>, 这个 <span class="math inline">\(\theta\)</span> 实际上是由硬币本身决定的.</li><li><strong>参数空间</strong>: 显然 <span class="math inline">\(\Theta=[0,1]\)</span>.</li><li><strong>样本空间</strong>: 显然 <span class="math inline">\(n\)</span> 次试验的样本空间为 <span class="math inline">\(\{H,T\}^n\)</span>, <span class="math inline">\(H\)</span> for head, <span class="math inline">\(T\)</span> for tail.</li></ul></li><li>题目所需要估计的值并不是 <span class="math inline">\(\theta\)</span> 的值, 而是 <span class="math inline">\(\theta^2\)</span> 的值. <strong><font color="red">请注意 <span class="math inline">\(\hat{\theta}^2\)</span> 未必会与 <span class="math inline">\(\hat{\theta^2}\)</span> 相等.</font></strong></li></ul><h2 id="最大似然估计">最大似然估计</h2><h3 id="题目的做法">题目的做法</h3><p>似然函数为: <span class="math display">\[L(\theta)=\mathbb{P}(D|p)=\binom{14}{4}\theta^{10}(1-\theta)^4.\]</span> 求其取最大值时 <span class="math inline">\(\theta\)</span> 的取值: <span class="math display">\[\theta_{MLE}=\arg\max_\theta\{L(\theta)\}=\frac{5}{7}.\]</span> 与老师slides中的结果相吻合.</p><h3 id="一般情形">一般情形</h3><p>一般情况下, 选取的样本 <span class="math inline">\(x_1,\cdots,x_n\)</span> 都是i.i.d.样本, 于是似然函数只需要将其密度函数乘起来: <span class="math display">\[L(x_1,\cdots,x_n|\theta)=\prod_{i=1}^nf(x_i|\theta)\]</span> 然后求 <span class="math inline">\(\theta\)</span>, s.t. <span class="math inline">\(L(x_1,\cdots,x_n|\theta)\)</span> 取最大即可, 一般只需解方程 <span class="math display">\[\frac{\partial L}{\partial \theta}=0\]</span> 有些情况下求对数似然函数 <span class="math inline">\(l(x_1,\cdots,x_n|\theta)=\ln L(x_1,\cdots,x_n|\theta)\)</span> 的最大值计算起来更方便, 如正态分布.<br>维基百科上有详细讨论, 此处略去细节.</p><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1" target="_blank" rel="noopener">维基百科：最大似然估计</a><br><a href="https://en.wikipedia.org/wiki/Maximum_likelihood_estimation" target="_blank" rel="noopener">Wiki: Maximum likelihood estimation</a></p></blockquote><h2 id="最大后验概率估计">最大后验概率估计</h2><h3 id="题目的做法-1">题目的做法</h3><ul><li>此处假设的先验分布是 <span class="math inline">\(\theta\sim U(0,1)\)</span>.<ul><li>分布函数CDF: <span class="math inline">\(F(x)=x\)</span>;</li><li>密度函数PDF: <span class="math inline">\(f(x)=1\)</span>.</li></ul></li></ul><p>由Bayes公式, 可得后验概率为：<span class="math display">\[\begin{align}\mathbb{P}(\theta|D)&amp;=\frac{\mathbb{P}(D|\theta)\mathbb{P}(\theta)}{\mathbb{P}(D)} \\&amp;= \frac{\binom{14}{4}\theta^{10}(1-\theta)^4\cdot f(\theta)}{\int_0^1\binom{14}{4}\theta^{10}(1-\theta)^4{\rm d}F(\theta)} \\&amp;= \frac{\theta^{10}(1-\theta)^4}{\int_0^1\theta^{10}(1-\theta)^4}.\end{align}\]</span> 最大化这个概率, 可得MAP对 <span class="math inline">\(\theta\)</span> 的估计值为: <span class="math display">\[\begin{align}\theta_{MAP}&amp;=\arg\max_\theta\{\mathbb{P}(\theta|D)\}\\&amp;=\arg\max_\theta\{\theta^{10}(1-\theta)^4\}\\&amp;=\frac{5}{7}\end{align}.\]</span></p><p>实际上MAP的结果在 <span class="math inline">\(\theta\sim U(0,1)\)</span> 时与MLE没有任何区别.</p><h3 id="一般情形-1">一般情形</h3><ul><li>已知先验分布, 及其CDF <span class="math inline">\(F(x)\)</span> 和PDF <span class="math inline">\(f(x)\)</span>.</li><li>在做实验得到数据 <span class="math inline">\(D\)</span> 后, 利用MAP估计 <span class="math inline">\(\theta\)</span> 的值.</li></ul><p>由Bayes公式有: <span class="math display">\[\mathbb{P}(\theta|D)=\frac{\mathbb{P}(D|\theta)\mathbb{P}(\theta)}{\mathbb{P}(D)}\]</span> 逐项计算等号右边各项:</p><ul><li><span class="math inline">\(\mathbb{P}(D|\theta)\)</span> 为: 单次实验结果为 <span class="math inline">\(H\)</span> 的概率, 直接用概率论/组合数学/统计学知识计算即可.</li><li><span class="math inline">\(\mathbb{P}(\theta)\)</span> 为: <span class="math inline">\(\theta\)</span> 的先验概率, 即先验分布的PDF <span class="math inline">\(f(\theta)\)</span>.</li><li><span class="math inline">\(\mathbb{P}(D)\)</span> 为: 样本空间中出现 <span class="math inline">\(D\)</span> 的总概率, 等于后验概率 <span class="math inline">\(\mathbb{P}(D|\theta)\)</span> 对 <span class="math inline">\(\theta\)</span> 的分布积分, 即 <span class="math display">\[\mathbb{P}(D)=\int_\theta \mathbb{P}(D|\theta)~{\rm d}F(\theta)\]</span></li></ul><p>简单整理一下, 可得: <span class="math display">\[\mathbb{P}(\theta|D)=\frac{\mathbb{P}(D|\theta)f(\theta)}{\int_\theta \mathbb{P}(D|\theta)~{\rm d}F(\theta)}\]</span> 事实上, <span class="math inline">\(\theta\)</span> 对于 <span class="math inline">\(D\)</span> 的后验分布其实就是 <span class="math inline">\(\theta\)</span> 对 <span class="math inline">\(D\)</span> 的条件分布.<br>得到上式之后, 求使得该式最大的 <span class="math inline">\(\theta\)</span> 即可. 由于分母是一个常数, 故: <span class="math display">\[\theta_{MAP}=\arg\max_\theta\{\mathbb{P}(D|\theta)f(\theta)\}.\]</span> 容易看出, 当 <span class="math inline">\(\theta\sim U(0,1)\)</span> 时, 因 <span class="math inline">\(f(\theta)=1\)</span> 有 <span class="math inline">\(\theta_{MAP}=\theta_{MLE}\)</span>. 但一般情况下二者并不相等.</p><h2 id="贝叶斯估计">贝叶斯估计</h2><h3 id="题目的做法-2">题目的做法</h3><ul><li>此处假设的先验分布是 <span class="math inline">\(\theta\sim U(0,1)\)</span>.<ul><li>分布函数CDF: <span class="math inline">\(F(x)=x\)</span>;</li><li>密度函数PDF: <span class="math inline">\(f(x)=1\)</span>.</li></ul></li></ul><p>由Bayes公式, 可得后验概率为：<span class="math display">\[\begin{align}\mathbb{P}(\theta|D)&amp;=\frac{\mathbb{P}(D|\theta)\mathbb{P}(\theta)}{\mathbb{P}(D)} \\&amp;= \frac{\binom{14}{4}\theta^{10}(1-\theta)^4\cdot f(\theta)}{\int_0^1\binom{14}{4}\theta^{10}(1-\theta)^4{\rm d}F(\theta)} \\&amp;= \frac{\theta^{10}(1-\theta)^4}{\int_0^1\theta^{10}(1-\theta)^4}.\end{align}\]</span> <span class="math inline">\(\theta\)</span> 的Bayes估计值即为后验概率的期望: <span class="math display">\[\begin{align}\hat{\theta}=\mathbb{E}(\theta|D)&amp;= \int_0^1\theta~\mathbb{P}(\theta|D){\rm d}\theta \\&amp;= \int_0^1\frac{\theta^{11}(1-\theta)^4{\rm d}\theta}{\int_0^1\theta^{10}(1-\theta)^4}=\frac{11}{16}.\end{align}\]</span> 题目中要求估计两次正面向上, 就是要估计 <span class="math inline">\(\theta^2\)</span>: <span class="math display">\[\begin{align}\hat{\theta^2}=\mathbb{E}(\theta|D)&amp;= \int_0^1\theta^2~\mathbb{P}(\theta|D){\rm d}\theta \\&amp;= \int_0^1\frac{\theta^{13}(1-\theta)^4{\rm d}\theta}{\int_0^1\theta^{10}(1-\theta)^4} \\ &amp;= \frac{33}{68}\approx 0.485.\end{align}\]</span> 这个答案恰好和老师的slides中给出的答案相符. 同时也作为一个例子说明了 <span class="math inline">\(\hat{\theta^2}\neq\hat{\theta}^2\)</span>.</p><h3 id="一般情形-2">一般情形</h3><ul><li>已知先验分布, 及其CDF <span class="math inline">\(F(x)\)</span> 和PDF <span class="math inline">\(f(x)\)</span>.</li><li>在做实验得到数据 <span class="math inline">\(D\)</span> 后, 利用Bayes估计来估计 <span class="math inline">\(\theta\)</span> 的值.</li></ul><p>Bayes估计的估计值实际上是参数 <span class="math inline">\(\theta\)</span> 关于试验数据 <span class="math inline">\(D\)</span> 的条件期望: <span class="math display">\[\hat{\theta}=\mathbb{E}(\theta|D)\]</span> 条件分布的密度函数与MAP中得到的相同: <span class="math display">\[\mathbb{P}(\theta|D)=\frac{\mathbb{P}(D|\theta)f(\theta)}{\int_\theta \mathbb{P}(D|\theta)~{\rm d}F(\theta)}\]</span> 得到上式之后, 积分求期望即可. 即: <span class="math display">\[\begin{align}\hat{\theta}&amp;=\mathbb{E}(\theta|D) \\&amp;= \int_\theta \mathbb{P}(D|\theta)\theta{\rm d}\theta \\&amp;= \frac{\int_\theta \mathbb{P}(D|\theta)f(\theta)\theta~{\rm d}\theta}{\int_\theta \mathbb{P}(D|\theta)~{\rm d}F(\theta)}.\end{align}\]</span></p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 概率论 </tag>
            
            <tag> 统计学 </tag>
            
            <tag> 经济学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法拾遗[5]——Java大数</title>
      <link href="/2018/07/17/%E7%AE%97%E6%B3%95%E6%8B%BE%E9%81%97-5-%E2%80%94%E2%80%94Java%E5%A4%A7%E6%95%B0/"/>
      <content type="html"><![CDATA[<p>比较重要的几条是:</p><ul><li><code>add, subtract, multiply, divide, mod, remainder</code> 加减乘除取模取余<font color="red">---注意取模中 <span class="math inline">\(b\)</span> 必须为正!</font></li><li><code>a.compareTo(b)</code> <span class="math inline">\(a=b\)</span> 返回 <span class="math inline">\(0\)</span>, 否则返回 <span class="math inline">\(a&gt;b\)</span> 的值.</li><li><code>a.toString(b)</code> 将 <span class="math inline">\(a\)</span> 转换为 <span class="math inline">\(b\)</span> 进制字符串.</li></ul><p>另外注意 <code>Scanner</code> 的写法:</p><ul><li>输入接口: <code>Scanner cin = new Scanner(System.in);</code></li><li>EOF写法: <code>while(cin.hasNext()) {}</code></li><li>输入:<code>BigInteger a = cin.nextBigInteger();</code></li></ul><p>以及变量的声明(注意 <code>new</code>):</p><ul><li>单个变量: <code>BigInteger a = new BigInteger(&quot;0&quot;);</code></li><li>声明数组: <code>BigInteger a[] = new BigInteger[size];</code></li><li>静态方法: <code>BigInteger a = BigInteger.valueOf(x);</code></li></ul><a id="more"></a><p>完整版本如下:</p><blockquote><p>来源: https://blog.csdn.net/qq644262163/article/details/53116713</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;  </span><br><span class="line"><span class="keyword">import</span> java.math.*;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读到EOF</span></span><br><span class="line">        <span class="keyword">while</span>(cin.hasNext())&#123;&#125;</span><br><span class="line">        <span class="comment">// 读入BigInteger</span></span><br><span class="line">        BigInteger a = cin.nextBigInteger();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 赋值</span></span><br><span class="line">        <span class="comment">// 将十进制字符串转化为BigInteger</span></span><br><span class="line">        <span class="comment">// public BigInteger(String val)</span></span><br><span class="line">        BigInteger a = <span class="keyword">new</span> BigInteger(<span class="string">"3"</span>);</span><br><span class="line">        <span class="comment">// 将radix进制的字符串转化为BigInteger</span></span><br><span class="line">        <span class="comment">// public BigInteger(String val, int radix)</span></span><br><span class="line">        BigInteger a = <span class="keyword">new</span> BigInteger(<span class="string">"3"</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 将整数赋给BigInteger</span></span><br><span class="line">        BigInteger a = BigInteger.valueOf(<span class="number">100</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 常量</span></span><br><span class="line">        a = BigInteger.ZERO;</span><br><span class="line">        a = BigInteger.ONE;</span><br><span class="line">        a = BigInteger.TEN;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 值等于val的值</span></span><br><span class="line">        <span class="comment">// public static BigInteger valueOf(long val)</span></span><br><span class="line">        BigInteger.valueOf(<span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        a.add(b);</span><br><span class="line">        a.subtract(b);</span><br><span class="line">        a.multiply(b);</span><br><span class="line">        a.divide(b);</span><br><span class="line">        <span class="comment">// 取模a%b b需大于0 5mod3=2 -5mod3=1</span></span><br><span class="line">        a.mod(b);</span><br><span class="line">        <span class="comment">// 求余 5rem3=2 -5rem3=-2 5rem-3=2 -5rem-3=-2</span></span><br><span class="line">        <span class="comment">// public BigInteger remainder(BigInteger val)</span></span><br><span class="line">        a.remainder(b);</span><br><span class="line">        <span class="comment">// [0]为a/b [1]为a%b</span></span><br><span class="line">        <span class="comment">// public BigInteger[] divideAndRemainder(BigInteger val)</span></span><br><span class="line">        a.divideAndRemainder(b);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// a==b?</span></span><br><span class="line">        <span class="comment">// public boolean equals(Object x)</span></span><br><span class="line">        a.equals(b);</span><br><span class="line">        <span class="comment">// a的正负 正为1 0为0 负为-1</span></span><br><span class="line">        <span class="comment">// public int signum()</span></span><br><span class="line">        a.signum();</span><br><span class="line">        <span class="comment">// 绝对值|a|</span></span><br><span class="line">        <span class="comment">// public BigInteger abs()</span></span><br><span class="line">        a.abs();</span><br><span class="line">        <span class="comment">// 比较a&gt;b返回1 a==b返回0 a&lt;b返回-1</span></span><br><span class="line">        <span class="comment">// public BigInteger andNot(BigInteger val)</span></span><br><span class="line">        a.compareTo(b);</span><br><span class="line">        <span class="comment">// 相反数-a</span></span><br><span class="line">        <span class="comment">// public BigInteger negate()</span></span><br><span class="line">        a.negate();</span><br><span class="line">        <span class="comment">// max(a,b)</span></span><br><span class="line">        <span class="comment">// public BigInteger max(BigInteger val)</span></span><br><span class="line">        a.max(b);</span><br><span class="line">        <span class="comment">// min(a,b)</span></span><br><span class="line">        <span class="comment">// public BigInteger min(BigInteger val)</span></span><br><span class="line">        a.min(b);</span><br><span class="line">        <span class="comment">// 乘方</span></span><br><span class="line">        <span class="comment">// public BigInteger pow(int exponent)</span></span><br><span class="line">        a.pow(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// a模b的逆元</span></span><br><span class="line">        <span class="comment">// public BigInteger modInverse(BigInteger m)</span></span><br><span class="line">        a.modInverse(b);</span><br><span class="line">        <span class="comment">// 乘方取模 a^b%c</span></span><br><span class="line">        <span class="comment">// public BigInteger modPow(BigInteger exponent,BigInteger m)</span></span><br><span class="line">        a.modPow(b, c);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 位运算</span></span><br><span class="line">        <span class="comment">// ~a</span></span><br><span class="line">        <span class="comment">// public BigInteger not()</span></span><br><span class="line">        a.not();</span><br><span class="line">        <span class="comment">// a^b</span></span><br><span class="line">        <span class="comment">// public BigInteger xor(BigInteger val)</span></span><br><span class="line">        a.xor(b);</span><br><span class="line">        <span class="comment">// a|b</span></span><br><span class="line">        <span class="comment">// public BigInteger or(BigInteger val)</span></span><br><span class="line">        a.or(b);</span><br><span class="line">        <span class="comment">// a&amp;b</span></span><br><span class="line">        <span class="comment">// public BigInteger divide(BigInteger val)</span></span><br><span class="line">        a.and(b);</span><br><span class="line">        <span class="comment">// a左移n位 (a &lt;&lt; n)</span></span><br><span class="line">        <span class="comment">// public BigInteger shiftLeft(int n)</span></span><br><span class="line">        a.shiftLeft(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// a右移n位 (a &gt;&gt; n)</span></span><br><span class="line">        <span class="comment">// public BigInteger shiftRight(int n)</span></span><br><span class="line">        a.shiftRight(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// a&amp;(~b)</span></span><br><span class="line">        <span class="comment">// public BigInteger andNot(BigInteger val)</span></span><br><span class="line">        a.andNot(b);</span><br><span class="line">        <span class="comment">// 二进制形式中把第n位二进制设为0 (a &amp; ~(1&lt;&lt;n))</span></span><br><span class="line">        <span class="comment">// public BigInteger clearBit(int n)</span></span><br><span class="line">        a.clearBit(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 二进制形式中把第n位二进制设为1 (a | (1&lt;&lt;n))</span></span><br><span class="line">        <span class="comment">// public BigInteger setBit(int n)</span></span><br><span class="line">        a.setBit(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 二进制形式中第n位二进制是否为1 (a &amp; (1&lt;&lt;n)) != 0)</span></span><br><span class="line">        <span class="comment">// public boolean testBit(int n)</span></span><br><span class="line">        a.testBit(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 二进制形式中把第n位二进制翻转 (a ^ (1&lt;&lt;n))</span></span><br><span class="line">        <span class="comment">// public BigInteger flipBit(int n)</span></span><br><span class="line">        a.flipBit(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 二进制形式中最低位1后面0的个数 (a == 0? -1 : log2(a &amp; -a))</span></span><br><span class="line">        <span class="comment">// public int getLowestSetBit()</span></span><br><span class="line">        a.getLowestSetBit();</span><br><span class="line">        <span class="comment">// 二进制形式中与符号不同的位的数量 7为3 -7为2</span></span><br><span class="line">        <span class="comment">// public int bitCount()</span></span><br><span class="line">        a.bitCount();</span><br><span class="line">        <span class="comment">// 二进制形式中不包括符号位的长度</span></span><br><span class="line">        <span class="comment">// public int bitLength()</span></span><br><span class="line">        a.bitLength();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// a和b的最大公约数</span></span><br><span class="line">        <span class="comment">// public BigInteger gcd(BigInteger val)</span></span><br><span class="line">        a.gcd(b);</span><br><span class="line">        <span class="comment">// a可能为素数返回true a一定为合数返回false 素数可能性大于(1-1/(2的certainty次方))</span></span><br><span class="line">        <span class="comment">// public boolean isProbablePrime(int certainty)</span></span><br><span class="line">        a.isProbablePrime(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 大于a的可能为素数的第一个整数。</span></span><br><span class="line">        <span class="comment">// public BigInteger nextProbablePrime()</span></span><br><span class="line">        a.nextProbablePrime();</span><br><span class="line">        <span class="comment">// a的哈希码</span></span><br><span class="line">        <span class="comment">// public int hashCode()</span></span><br><span class="line">        a.hashCode();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// a的二进制补码形式</span></span><br><span class="line">        <span class="comment">// public byte[] toByteArray()</span></span><br><span class="line">        a.toByteArray();</span><br><span class="line">        <span class="comment">// a的十进制字符串形式</span></span><br><span class="line">        <span class="comment">// public String toString()</span></span><br><span class="line">        a.toString();</span><br><span class="line">        <span class="comment">// a的radix进制字符串形式</span></span><br><span class="line">        <span class="comment">// public String toString(int radix)</span></span><br><span class="line">        a.toString(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 将a转换为int</span></span><br><span class="line">        <span class="comment">// public int intValue()</span></span><br><span class="line">        a.intValue();</span><br><span class="line">        <span class="comment">// 将a转换为long</span></span><br><span class="line">        <span class="comment">// public long longValue()</span></span><br><span class="line">        a.longValue();</span><br><span class="line">        <span class="comment">// 将a转换为float</span></span><br><span class="line">        <span class="comment">// public float floatValue()</span></span><br><span class="line">        a.floatValue();</span><br><span class="line">        <span class="comment">// 将a转换为double</span></span><br><span class="line">        <span class="comment">// public double doubleValue()</span></span><br><span class="line">        a.doubleValue();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JAVA 1.8</span></span><br><span class="line">        a.byteValueExact();</span><br><span class="line">        a.intValueExact();</span><br><span class="line">        a.longValueExact();</span><br><span class="line">        a.shortValueExact();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从类 java.lang.Number 继承的方法</span></span><br><span class="line">        <span class="comment">// 将a转换为short</span></span><br><span class="line">        <span class="comment">// public short shortValue()</span></span><br><span class="line">        a.shortValue();</span><br><span class="line">        <span class="comment">// 将a转换为byte</span></span><br><span class="line">        <span class="comment">// public byte byteValue()</span></span><br><span class="line">        a.byteValue();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从类 java.lang.Object 继承的方法</span></span><br><span class="line">        <span class="comment">// public final Class&lt;?&gt; getClass()</span></span><br><span class="line">        a.getClass();</span><br><span class="line">        <span class="comment">// public final void notify()</span></span><br><span class="line">        a.notify();</span><br><span class="line">        <span class="comment">// public final void notifyAll()</span></span><br><span class="line">        a.notifyAll();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// public final void wait() throws InterruptedException</span></span><br><span class="line">            a.wait();</span><br><span class="line">            <span class="comment">// public final void wait(long timeout) throws InterruptedException</span></span><br><span class="line">            a.wait(<span class="number">10</span>);</span><br><span class="line">            <span class="comment">// public final void wait(long timeout, int nanos) throws InterruptedException</span></span><br><span class="line">            a.wait(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 保研复习 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法拾遗[4]——STL用法</title>
      <link href="/2018/07/17/%E7%AE%97%E6%B3%95%E6%8B%BE%E9%81%97-4-%E2%80%94%E2%80%94STL%E7%94%A8%E6%B3%95/"/>
      <content type="html"><![CDATA[<p>主要bb一下优先队列和字符串吧. 哦还有 <code>bitset</code>.</p><a id="more"></a><h2 id="优先队列">优先队列</h2><ul><li>定义很容易: <code>priority_queue&lt;int&gt; pq;</code></li><li>内部是一个堆.</li></ul><h3 id="基本操作">基本操作</h3><ul><li><code>pq.top()</code> 取堆顶元素; (没有 <code>front()</code> 方法!)</li><li><code>pq.push(x)</code> 插入;</li><li><code>pq.pop()</code> 删除(删除堆顶);</li><li><code>pq.empty()</code> 判断是否为空.</li></ul><h3 id="自定义优先级">自定义优先级</h3><ul><li>最大堆: <code>priority_queue&lt;int&gt; pq;</code></li><li>最小堆: <code>priority_queue&lt; int, vector&lt;int&gt;, greater&lt;int&gt; &gt; pq;</code></li><li>事实上还有自定义优先级 <code>cmp</code> 的方法(优先级最大的最先出队): <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">// a优先级较小时返回true.</span></span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, cmp&gt; pq; <span class="comment">// 此时也是最小堆</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="例题">例题</h4><ul><li>百练 4078: http://bailian.openjudge.cn/practice/4078/</li></ul><h2 id="字符串">字符串</h2><p>定义更容易: <code>string s;</code></p><h3 id="基本操作-1">基本操作</h3><ul><li><code>s.size()</code> 串长度(下标从0 开始)；</li><li><code>s.substr(a, n)</code> 构造子串, a为第一个字符的下标, n为子串字符长度;</li><li><code>s'find(it1, it2, x)</code> 在指针 <code>it1</code> 和 <code>it2</code> 中间查找字符 <code>x</code>; (<code>s.find(x)</code> 为整个 <code>s</code> 中查找 <code>x</code>)</li><li><code>s.erase(a)</code> 删除元素, a貌似是指针, 可以和 <code>find</code> 合用去除指定字符, 如 <code>s.erase(std::find(s.begin(), s.end(), ' '));</code> 去掉所有空格;</li><li><code>s.empty()</code> 判断是否为空;</li><li>支持 <code>push_back</code> 和 <code>pop_back</code>;<br></li><li>支持 <code>+</code>, <code>=</code> 和 <code>==</code> 运算.</li></ul><h3 id="遍历操作">遍历操作</h3><ul><li>可以用 <code>auto it = s.begin(); it != s.end(); it++</code> 遍历;</li><li>但我一般都用 <code>int i = 0; i &lt; s.size(); i++</code> 遍历.</li></ul><h3 id="和数字的转换">和数字的转换</h3><h4 id="字符串转数字">字符串转数字</h4><ul><li><code>stoi</code>, <code>stol</code>, <code>stoll</code>: 字符串转整数;</li><li><code>stof</code>, <code>stod</code>, <code>stold</code>: 字符串转浮点数;</li></ul><h4 id="数字转字符串">数字转字符串</h4><ul><li><code>to_string</code> 直接转成 <code>std::string</code>.</li></ul><h2 id="位向量">位向量</h2><p>定义: <code>bitset&lt;length&gt; b(value);</code></p><h3 id="基本操作-2">基本操作</h3><ul><li>支持位运算 <code>&amp;</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>等;</li><li><code>to_string()</code> 转化为字符串;</li><li><code>to_ulong()</code>, <code>to_ullong()</code> 转化为无符号整数;</li><li><code>flip(i)</code> 第i位取反, 下标从0开始. <code>flip()</code> 全部按位取反.</li></ul>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 保研复习 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法拾遗[3]——图论算法</title>
      <link href="/2018/07/16/%E7%AE%97%E6%B3%95%E6%8B%BE%E9%81%97-3-%E2%80%94%E2%80%94%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/"/>
      <content type="html"><![CDATA[<p>夏令营复习算法, 感到自己对之前学过的算法略有生疏, 写篇流水账, 权当复习.</p><ul><li>并查集</li><li>Dijkstra 算法</li><li>Floyd 算法</li><li>Kruskal 算法</li></ul><a id="more"></a><h2 id="并查集">并查集</h2><p>处理连通关系的一种手段.</p><h3 id="查询所属连通分支">查询所属连通分支</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fa[i] 表示i 所属的连通分支的代表元</span></span><br><span class="line"><span class="comment">// rnk[j] 表示j 号连通分支的结点个数, 注意这里的j 必须是所取的代表元(根结点)</span></span><br><span class="line"><span class="comment">// 使用前注意fa[] 的初始化, rnk[] 初始为1.</span></span><br><span class="line"><span class="keyword">int</span> fa[maxn], rnk[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] == <span class="number">-1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fa[x] = Find(fa[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并操作">合并操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t1 = Find(x);</span><br><span class="line">    <span class="keyword">int</span> t2 = Find(y);</span><br><span class="line">    <span class="keyword">if</span>(t1 != t2)</span><br><span class="line">    &#123;</span><br><span class="line">        fa[t1] = t2;</span><br><span class="line">        rnk[t2] += rnk[t1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dijkstra-算法">Dijkstra 算法</h2><p>单源最短路, 适用于权值非负的图.</p><h3 id="实现代码">实现代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// g 需要初始化, 下标从0 开始.</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre[maxn], d[maxn];</span><br><span class="line"><span class="keyword">int</span> g[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> g[][maxn], <span class="keyword">int</span> d[], <span class="keyword">int</span> n, <span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pre[i] = <span class="number">-1</span>;</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">        d[i] = inf;</span><br><span class="line">    &#125;</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">-1</span>, Min = inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (!vis[i] &amp;&amp; d[i] &lt; Min)</span><br><span class="line">            &#123;</span><br><span class="line">                Min = d[i];</span><br><span class="line">                k = i;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        vis[k] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (!vis[i] &amp;&amp; d[k] + g[k][i] &lt; d[i])</span><br><span class="line">            &#123;</span><br><span class="line">                d[i] = d[k] + g[k][i];</span><br><span class="line">                pre[i] = k;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hdu-2544-最短路">HDU 2544: 最短路</h3><h4 id="problem-description">Problem Description</h4><p>在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？</p><h4 id="input">Input</h4><p>输入包括多组数据。每组数据第一行是两个整数N、M（N&lt;=100，M&lt;=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1&lt;=A,B&lt;=N,1&lt;=C&lt;=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。 输入保证至少存在1条商店到赛场的路线。</p><h4 id="output">Output</h4><p>对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间</p><h4 id="sample-input">Sample Input</h4><p>2 1<br>1 2 3<br>3 3<br>1 2 5<br>2 3 5<br>3 1 2<br>0 0</p><h4 id="sample-output">Sample Output</h4><p>3<br>2</p><h4 id="大致思路">大致思路</h4><p>注意题目中下标从 1 开始.</p><h4 id="ac代码">AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre[maxn], d[maxn];</span><br><span class="line"><span class="keyword">int</span> g[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> g[][maxn], <span class="keyword">int</span> d[], <span class="keyword">int</span> n, <span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pre[i] = <span class="number">-1</span>;</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">        d[i] = inf;</span><br><span class="line">    &#125;</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">-1</span>, Min = inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (!vis[i] &amp;&amp; d[i] &lt; Min)</span><br><span class="line">            &#123;</span><br><span class="line">                Min = d[i];</span><br><span class="line">                k = i;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        vis[k] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (!vis[i] &amp;&amp; d[k] + g[k][i] &lt; d[i])</span><br><span class="line">            &#123;</span><br><span class="line">                d[i] = d[k] + g[k][i];</span><br><span class="line">                pre[i] = k;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                g[i][j] = (i == j) ? <span class="number">0</span> : inf;</span><br><span class="line">        <span class="keyword">while</span> (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v, w;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">            g[u - <span class="number">1</span>][v - <span class="number">1</span>] = g[v - <span class="number">1</span>][u - <span class="number">1</span>] = w;</span><br><span class="line">        &#125;</span><br><span class="line">        Dijkstra(g, d, n, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; d[n - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="floyd-算法">Floyd 算法</h2><p>我所知道的唯一的全源最短路. 复杂度略高, 约 <span class="math inline">\(O(n^3)\)</span>. 可以视为动态规划. 简单好写.</p><h3 id="实现代码-1">实现代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化仍然是i == j时d[i][j]为0, 其余为inf.</span></span><br><span class="line"><span class="comment">// 注意下标从0 开始, 以及k-&gt; i-&gt; j 的顺序.</span></span><br><span class="line"><span class="comment">// 想压行可以把最后的if 写成min.</span></span><br><span class="line"><span class="keyword">int</span> d[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) <span class="comment">// 一定要注意第一层是k</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (d[i][k] + d[k][j] &lt; d[i][j])</span><br><span class="line">                    d[i][j] = d[i][k] + d[k][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hdu-2544-最短路-1">HDU 2544: 最短路</h3><h4 id="problem-description-1">Problem Description</h4><p>在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？</p><h4 id="input-1">Input</h4><p>输入包括多组数据。每组数据第一行是两个整数N、M（N&lt;=100，M&lt;=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1&lt;=A,B&lt;=N,1&lt;=C&lt;=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。 输入保证至少存在1条商店到赛场的路线。</p><h4 id="output-1">Output</h4><p>对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间</p><h4 id="sample-input-1">Sample Input</h4><p>2 1<br>1 2 3<br>3 3<br>1 2 5<br>2 3 5<br>3 1 2<br>0 0</p><h4 id="sample-output-1">Sample Output</h4><p>3<br>2</p><h4 id="大致思路-1">大致思路</h4><p>还是这道裸题...除了注意题目中下标从 1 开始我都不知道还有什么可说的.</p><h4 id="ac代码-1">AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (d[i][k] + d[k][j] &lt; d[i][j])</span><br><span class="line">                    d[i][j] = d[i][k] + d[k][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> d[i][j] = inf;</span><br><span class="line">        <span class="keyword">while</span> (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b, c;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            d[a - <span class="number">1</span>][b - <span class="number">1</span>] = d[b - <span class="number">1</span>][a - <span class="number">1</span>] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        floyd(n);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; d[<span class="number">0</span>][n - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="kruskal-算法">Kruskal 算法</h2><p>所有边排序, 逐条加边, 用并查集判连通, 求最小生成树.</p><h3 id="实现代码-2">实现代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并查集初始化为-1, 不需要在main函数里单独初始化</span></span><br><span class="line"><span class="comment">// tol 需要在main里单独初始化为0</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    Edge()&#123;&#125;</span><br><span class="line">    Edge(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c): u(a), v(b), w(c)&#123;&#125;</span><br><span class="line">&#125; e[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tol; <span class="comment">// 存总边数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[tol++] = Edge(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span> <span class="comment">// 按权值排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[maxn]; <span class="comment">// 并查集</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x] == <span class="number">-1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fa[x] = Find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(fa, <span class="number">-1</span>, <span class="keyword">sizeof</span>(fa));</span><br><span class="line">    sort(e, e + tol, cmp);</span><br><span class="line">    int cnt(0), res(0);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tol; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = e[i].u;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">int</span> w = e[i].w;</span><br><span class="line">        <span class="keyword">int</span> t1 = Find(u);</span><br><span class="line">        <span class="keyword">int</span> t2 = Find(v);</span><br><span class="line">        <span class="keyword">if</span> (t1 != t2)</span><br><span class="line">        &#123;</span><br><span class="line">            fa[t1] = t2;</span><br><span class="line">            res += w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 不连通</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> res; <span class="comment">// 连通返回最小生成树权值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hdu-1863-畅通工程">HDU 1863: 畅通工程</h3><h4 id="problem-description-2">Problem Description</h4><p>省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可）。经过调查评估，得到的统计表中列出了有可能建设公路的若干条道路的成本。现请你编写程序，计算出全省畅通需要的最低成本。</p><h4 id="input-2">Input</h4><p>测试输入包含若干测试用例。每个测试用例的第1行给出评估的道路条数 N、村庄数目M ( &lt; 100 )；随后的 N 行对应村庄间道路的成本，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间道路的成本（也是正整数）。为简单起见，村庄从1到M编号。当N为0时，全部输入结束，相应的结果不要输出。</p><h4 id="output-2">Output</h4><p>对每个测试用例，在1行里输出全省畅通需要的最低成本。若统计数据不足以保证畅通，则输出“?”。</p><h4 id="sample-input-2">Sample Input</h4><p>3 3<br>1 2 1<br>1 3 2<br>2 3 4<br>1 3<br>2 3 2<br>0 100</p><h4 id="sample-output-2">Sample Output</h4><p>3<br>?</p><h4 id="大致思路-2">大致思路</h4><p>裸题, 没什么好说的, 一定要注意 <code>tol</code> 的初始化.</p><h4 id="ac代码-2">AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    Edge() &#123;&#125;</span><br><span class="line">    Edge(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c): u(a), v(b), w(c) &#123;&#125;</span><br><span class="line">&#125; e[maxn];</span><br><span class="line"><span class="keyword">int</span> tol;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[tol++] = Edge(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] == <span class="number">-1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fa[x] = Find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(fa, <span class="number">-1</span>, <span class="keyword">sizeof</span>(fa));</span><br><span class="line">    sort(e, e + tol, cmp);</span><br><span class="line">    int cnt(0), res(0);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tol; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = e[i].u;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">int</span> w = e[i].w;</span><br><span class="line">        <span class="keyword">int</span> t1 = Find(u);</span><br><span class="line">        <span class="keyword">int</span> t2 = Find(v);</span><br><span class="line">        <span class="keyword">if</span> (t1 != t2)</span><br><span class="line">        &#123;</span><br><span class="line">            fa[t1] = t2;</span><br><span class="line">            res += w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        tol = <span class="number">0</span>; <span class="comment">// 初始化!!!</span></span><br><span class="line">        <span class="keyword">while</span> (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v, w;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">            addedge(u, v, w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Kruskal(n);</span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"?\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 保研复习 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法拾遗[2]——数论算法</title>
      <link href="/2018/07/15/%E7%AE%97%E6%B3%95%E6%8B%BE%E9%81%97-2-%E2%80%94%E2%80%94%E6%95%B0%E8%AE%BA%E7%AE%97%E6%B3%95/"/>
      <content type="html"><![CDATA[<p>夏令营复习算法, 感到自己对之前学过的算法略有生疏, 写篇流水账, 权当复习.</p><ul><li>素数筛法</li><li>快速幂取模</li><li>扩展欧几里得/求逆元</li></ul><a id="more"></a><h2 id="素数筛法">素数筛法</h2><p>一种用已知的小素数 <span class="math inline">\(p\)</span> 来筛掉更大的合数, 最终留下素数的算法. 实践复杂度 <span class="math inline">\(O(n\log\log n)\)</span>.</p><h3 id="实现代码-1-打标记">实现代码 1: 打标记</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> notprime[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(notprime, <span class="literal">false</span>, <span class="keyword">sizeof</span>(notprime));</span><br><span class="line">    notprime[<span class="number">0</span>] = notprime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!notprime[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; maxn / i) <span class="keyword">continue</span>; <span class="comment">// 防止i * i 溢出</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i * i; j &lt; maxn; j += i)</span><br><span class="line">                notprime[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现代码-2-直接存素数">实现代码 2: 直接存素数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPrime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(prime, <span class="number">0</span>, <span class="keyword">sizeof</span>(prime));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!prime[i]) prime[++prime[<span class="number">0</span>]] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= prime[<span class="number">0</span>] &amp;&amp; prime[j] &lt;= maxn / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            prime[prime[j] * i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上也可以先打标记, 再 <code>for</code> 一遍把素数拿出来.</p><h3 id="百练-3177-判决素数个数">百练 3177: 判决素数个数</h3><p>总时间限制: 1000ms 内存限制: 65536kB</p><h4 id="描述">描述</h4><p>输入两个整数X和Y，输出两者之间的素数个数（包括X和Y）。</p><h4 id="输入">输入</h4><p>两个整数X和Y（1 &lt;= X,Y &lt;= 105）。</p><h4 id="输出">输出</h4><p>输出一个整数，表示X，Y之间的素数个数（包括X和Y）。</p><h4 id="样例输入">样例输入</h4><p>1 100</p><h4 id="样例输出">样例输出</h4><p>25</p><h4 id="大致思路">大致思路</h4><p>有个坑点... 题目没有保证 <span class="math inline">\(x\leqslant y\)</span>.. 所以需要 <code>swap</code> 一下.</p><h4 id="ac代码">AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> notprime[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(notprime, <span class="literal">false</span>, <span class="keyword">sizeof</span>(notprime));</span><br><span class="line">    notprime[<span class="number">0</span>] = notprime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!notprime[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; maxn / i) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i * i; j &lt; maxn; j += i)</span><br><span class="line">                notprime[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; y) swap(x, y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= y; i++)</span><br><span class="line">            <span class="keyword">if</span>(!notprime[i]) ans++;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展欧几里得算法">扩展欧几里得算法</h2><p>求解 <span class="math inline">\(ax+by=d\)</span> 中的 <span class="math inline">\(x, y\)</span>, 其中 <span class="math inline">\(\gcd(a, b)~|~d\)</span> 才有解.</p><h3 id="实现代码">实现代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回d = gcd(a, b); 和对应于等式ax + by = d 中的x, y</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">extend_gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">long</span> <span class="keyword">long</span> &amp;x, <span class="keyword">long</span> <span class="keyword">long</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 无最大公约数</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> d = extend_gcd(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速幂取模">快速幂取模</h2><p>在 <span class="math inline">\(O(\log n)\)</span> 时间内求 <span class="math inline">\(a^n~\%m\)</span> 的值.</p><h3 id="实现代码-1">实现代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">pow_mod</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)</span><br><span class="line">            ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求逆元">求逆元</h2><p>求 <span class="math inline">\(x\)</span>, s.t. <span class="math inline">\(ax=1~({\rm mod}~m)\)</span>.</p><h3 id="实现代码-1-利用扩展欧几里得">实现代码 1: 利用扩展欧几里得</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ax = 1 (mod n)</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">mod_reverse</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x, y;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> d = extend_gcd(a, n, x, y);</span><br><span class="line">    <span class="keyword">if</span> (d == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> (x % n + n) % n;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现代码-2-利用费马小定理">实现代码 2: 利用费马小定理</h3><p>由于模数 <span class="math inline">\(m\)</span> 一般为素数, 当 <span class="math inline">\((a,m)=1\)</span> 时, 由费马小定理有: <span class="math display">\[a^{m-1}=1~({\rm mod}~m)\Rightarrow a^{-1}=a^{m-2}.\]</span> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pow_mod(a, mod - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 保研复习 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法拾遗[1]——动态规划</title>
      <link href="/2018/07/14/%E7%AE%97%E6%B3%95%E6%8B%BE%E9%81%97-1-%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <content type="html"><![CDATA[<p>夏令营复习算法, 感到自己对之前学过的算法略有生疏, 写篇流水账, 权当复习.</p><ul><li>最长上升子序列</li><li>最长公共子序列</li><li>最大子段和与最大子矩阵</li><li>背包问题</li><li>一些其他的题目</li></ul><a id="more"></a><h2 id="最长上升子序列">最长上升子序列</h2><p>简单来说, 是通过讨论原序列的当前位 <span class="math inline">\(a_i\)</span> 与子序列 <span class="math inline">\(b\)</span> 的末尾 <span class="math inline">\(b_{len-1}\)</span> 的大小关系进行递推/动态规划的一类问题. 具体思路暂不详述.</p><h3 id="实现代码">实现代码</h3><p>给定数组 <span class="math inline">\(a\)</span>, 求 <span class="math inline">\(a\)</span> 某一段 <span class="math inline">\(a[l, r]\)</span> 的LIS的代码如下:<br>不严格的情形有两处需要修改, 请仔细查看注释.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组int a[] 的下标从 0 ~ n-1, 函数可求解 [l, r] 闭区间的LIS长度.</span></span><br><span class="line"><span class="comment">// a[l, r] 的LIS存储在b[0, len-1] 中. 函数返回值为其元素个数.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lis</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    c[<span class="number">0</span>] = a[l];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = l + <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; c[len]) <span class="comment">// 不严格递增情形改为&gt;=</span></span><br><span class="line">            c[++len] = a[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">// 不严格递增情形改为upper_bound()</span></span><br><span class="line">            <span class="keyword">int</span> pos = lower_bound(c, c + len, a[i]) - c;</span><br><span class="line">            c[pos] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len + <span class="number">1</span>; <span class="comment">// 下标从0 开始, 故需要+1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如需求解最长下降子序列, 一个偷懒的办法是将原数组逆序存储, 再求解其逆序的LIS.<br>同时也有 <code>lower_bound(c, c + len, a[i], greater&lt;int&gt;())</code> 的用法, 非常方便.</p><h3 id="百练-2945-拦截导弹">百练 2945: 拦截导弹</h3><p>总时间限制: 1000ms 内存限制: 65536kB</p><h4 id="描述">描述</h4><p>某国为了防御敌国的导弹袭击，开发出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭，并观测到导弹依次飞来的高度，请计算这套系统最多能拦截多少导弹。拦截来袭导弹时，必须按来袭导弹袭击的时间顺序，不允许先拦截后面的导弹，再拦截前面的导弹。</p><h4 id="输入">输入</h4><p>输入有两行，<br>第一行，输入雷达捕捉到的敌国导弹的数量k（k&lt;=25），<br>第二行，输入k个正整数，表示k枚导弹的高度，按来袭导弹的袭击时间顺序给出，以空格分隔。</p><h4 id="输出">输出</h4><p>输出只有一行，包含一个整数，表示最多能拦截多少枚导弹。</p><h4 id="样例输入">样例输入</h4><p>8<br>300 207 155 300 299 170 158 65</p><h4 id="样例输出">样例输出</h4><p>6</p><h4 id="思路">思路</h4><p>很裸, 直接做非严格最长下降子序列. 5min内不AC自觉面壁...</p><h4 id="ac代码">AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], c[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lis</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    c[<span class="number">0</span>] = a[l];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt;= c[len])</span><br><span class="line">            c[++len] = a[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = upper_bound(c, c + len, a[i], greater&lt;<span class="keyword">int</span>&gt;()) - c;</span><br><span class="line">            c[pos] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; lis(<span class="number">0</span>, n - <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="百练-2711-合唱队形">百练 2711: 合唱队形</h3><blockquote><p>题目链接: http://bailian.openjudge.cn/practice/2711/</p></blockquote><p>总时间限制: 1000ms 内存限制: 65536kB</p><h4 id="描述-1">描述</h4><p>N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学不交换位置就能排成合唱队形。 合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1, 2, …, K，他们的身高分别为T1, T2, …, TK，则他们的身高满足T1 &lt; T2 &lt; … &lt; Ti , Ti &gt; Ti+1 &gt; … &gt; TK (1 &lt;= i &lt;= K)。 你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。</p><h4 id="输入-1">输入</h4><p>输入的第一行是一个整数N（2 &lt;= N &lt;= 100），表示同学的总数。第一行有n个整数，用空格分隔，第i个整数Ti（130 &lt;= Ti &lt;= 230）是第i位同学的身高（厘米）。</p><h4 id="输出-1">输出</h4><p>输出包括一行，这一行只包含一个整数，就是最少需要几位同学出列。</p><h4 id="样例输入-1">样例输入</h4><p>8<br>186 186 150 200 160 130 197 220</p><h4 id="样例输出-1">样例输出</h4><p>4</p><h4 id="思路-1">思路</h4><p>枚举递增和递减中间分叉的位置（令其位于 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(a_{i+1}\)</span> 之间, 对 <span class="math inline">\(i\)</span> 做 <code>for</code> 循环）, 分别对两边做正序和逆序的LIS, 长度相加取最大, 最后再用 <span class="math inline">\(n\)</span> 减去即可.<br>注意一个<font color="red">特殊情况</font>, 就是前半段上升的最高点可能和后半段下降的最高点数值相等, 需要特判一下, 然后总长度-1.</p><h4 id="ac代码-1">AC代码</h4><p>特意用逆序来做的下降序列, 写的有一点丑, 不想细改了. 代码应该是没问题的.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组a[] 存储原数据, b[] 存储a 的逆序, 用两个函数分别求LIS.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], c[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lis</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    c[<span class="number">0</span>] = a[l];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; c[len])</span><br><span class="line">            c[++len] = a[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = lower_bound(c, c + len, a[i]) - c;</span><br><span class="line">            c[pos] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lis_reverse</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    c[<span class="number">0</span>] = b[l];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i] &gt; c[len])</span><br><span class="line">            c[++len] = b[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = lower_bound(c, c + len, b[i]) - c;</span><br><span class="line">            c[pos] = b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            b[i] = a[n - <span class="number">1</span> - i];</span><br><span class="line">        <span class="keyword">int</span> ans = max(lis(<span class="number">0</span>, n - <span class="number">1</span>), lis_reverse(<span class="number">0</span>, n - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = lis(<span class="number">0</span>, i);</span><br><span class="line">            <span class="keyword">int</span> tmpx = c[x - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> y = lis_reverse(<span class="number">0</span>, n - i - <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">int</span> tmpy = c[y - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(tmpx == tmpy) ans = max(ans, x + y - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> ans = max(ans, x + y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n - ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子序列">最长公共子序列</h2><h3 id="大致算法">大致算法</h3><p>记串 <span class="math inline">\(a\)</span> 和串 <span class="math inline">\(b\)</span> 的以 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 结尾的前缀分别为 <span class="math inline">\(A_i\)</span> 和 <span class="math inline">\(B_j\)</span>, 令 <span class="math inline">\(dp[i, j]\)</span> 表示 <span class="math inline">\(A_i\)</span> 与 <span class="math inline">\(B_j\)</span> 的LCS长度, 则有:</p><p><span class="math display">\[dp[i,j] = \begin{cases}0 &amp; i = 0~\text{or}~ j=0 \\dp[i-1,j-1]+1 &amp; i, j&gt;0,~a_i=b_j \\\max\{dp[i-1, j], dp[i, j-1]\} &amp; i, j&gt;0,~a_i\neq b_j\end{cases}\]</span></p><h3 id="实现代码-1">实现代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意下标, 从1 开始, 输入时也要注意.</span></span><br><span class="line"><span class="comment">// 答案为 dp[n][m].</span></span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">char</span> a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="poj-1458-common-subsequence">POJ 1458: Common Subsequence</h3><h4 id="description">Description</h4><p>A subsequence of a given sequence is the given sequence with some elements (possible none) left out. Given a sequence X = &lt; x1, x2, ..., xm &gt; another sequence Z = &lt; z1, z2, ..., zk &gt; is a subsequence of X if there exists a strictly increasing sequence &lt; i1, i2, ..., ik &gt; of indices of X such that for all j = 1,2,...,k, xij = zj. For example, Z = &lt; a, b, f, c &gt; is a subsequence of X = &lt; a, b, c, f, b, c &gt; with index sequence &lt; 1, 2, 4, 6 &gt;. Given two sequences X and Y the problem is to find the length of the maximum-length common subsequence of X and Y.</p><h4 id="input">Input</h4><p>The program input is from the std input. Each data set in the input contains two strings representing the given sequences. The sequences are separated by any number of white spaces. The input data are correct.</p><h4 id="output">Output</h4><p>For each set of data the program prints on the standard output the length of the maximum-length common subsequence from the beginning of a separate line.</p><h4 id="sample-input">Sample Input</h4><p>abcfbc abfcab<br>programming contest<br>abcd mnp</p><h4 id="sample-output">Sample Output</h4><p>4<br>2<br>0</p><h4 id="ac代码-2">AC代码</h4><p>一定要注意输入和下标!!! <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt; // poj不支持这个头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">char</span> a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp)); <span class="comment">// 应该没必要全都初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, a + <span class="number">1</span>, b + <span class="number">1</span>) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">strlen</span>(a + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> m = <span class="built_in">strlen</span>(b + <span class="number">1</span>);</span><br><span class="line">        init(n, m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[n][m]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="最大子段和与最大子矩阵">最大子段和与最大子矩阵</h2><h3 id="最大子段和">最大子段和</h3><p>最大子段和问题：求解给定数组 <span class="math inline">\(a\)</span> 的所有子段中, 和最大的一个.<br>根据问题, 显然有如下的暴力方法:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定原数组int a[], 元素个数 n.</span></span><br><span class="line"><span class="keyword">int</span> ans = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++)</span><br><span class="line">        ans = max(ans, SUM(a[i]...a[j]));</span><br></pre></td></tr></table></figure></p><p>考虑上求和的 <span class="math inline">\(O(n)\)</span>, 该算法的复杂度为 <span class="math inline">\(O(n^3)\)</span>. 如果优化掉求和的 <span class="math inline">\(O(n)\)</span>, 可优化为 <span class="math inline">\(O(n^2)\)</span>, 具体优化不在此赘述, 毕竟优化完了也很慢...<br>如使用 <span class="math inline">\(dp[i]\)</span> 表示以第 <span class="math inline">\(i\)</span> 位结尾的最大子段和, 则可以使问题得到极大的简化: <span class="math display">\[dp[i]=\max(dp[i - 1] + a[i], a[i]),\]</span> <span class="math display">\[ans = \max\limits_{0\leqslant i\leqslant n-1}\{dp[i]\}.\]</span> 根据该递推式很容易就可以写出如下代码: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定原数组int a[], 元素个数 n. 下标从0 开始.</span></span><br><span class="line"><span class="comment">// 中间变量int dp[], dp[i]表示以第i 位结尾的最大子段和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        dp[i] = max(dp[i - <span class="number">1</span>] + a[i], a[i]);</span><br><span class="line">    <span class="keyword">int</span> res = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        res = max(res, b[i]);</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>容易得出该算法的复杂度为 <span class="math inline">\(O(n)\)</span>. 是最快的求解算法.<br>同时不难想到, 最大子段和还有递归的求解方法, 时间复杂度为 <span class="math inline">\(O(n\log n)\)</span>, 不再赘述.</p><h3 id="最大子矩阵">最大子矩阵</h3><p>最大子段和的求解方式可直接应用于求解最大子矩阵问题:</p><ul><li>先将矩阵的行求和压缩: 对每行的第 <span class="math inline">\(i\)</span> 到第 <span class="math inline">\(j\)</span> 求和.</li><li>再对压缩后的 <span class="math inline">\(sum\)</span> 数组做最大子段和.</li><li>变换 <span class="math inline">\(i\)</span>, <span class="math inline">\(j\)</span>, 取最大值.</li></ul><p>求和数组 <span class="math inline">\(sum\)</span> 的转移方式也就是上文中暴力求最大子段和中求和时间的优化, 其实相当简单: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定原矩阵int a[][maxn], 行数m, 列数n. a[i][j] 表示第i 行第j 个, 下标从0 开始.</span></span><br><span class="line"><span class="comment">// 列和数组int sum[], sum[r] 表示第r 行的状态.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">// 枚举起点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; r++) <span class="comment">// 初始化</span></span><br><span class="line">        sum[r] = a[r][i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) <span class="comment">// 枚举终点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; r++) <span class="comment">// 更新每一行的和</span></span><br><span class="line">            sum[r] += a[r][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>显然我们只需要对每次处理好的 <span class="math inline">\(sum\)</span> 数组做最大子段和, 然后取最大值. 时间复杂度应为 <span class="math inline">\(O(n^3)\)</span>.<br>代码如下: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; n; r++)</span><br><span class="line">            sum[r] = a[r][i];</span><br><span class="line">        dp[<span class="number">0</span>] = sum[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">1</span>; r &lt; m; r++)</span><br><span class="line">            dp[r] = max(dp[r - <span class="number">1</span>] + sum[r], sum[r]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; r++)</span><br><span class="line">            res = max(res, dp[r]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; r++)</span><br><span class="line">                sum[r] += a[r][j];</span><br><span class="line">            dp[<span class="number">0</span>] = sum[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">1</span>; r &lt; m; r++)</span><br><span class="line">                dp[i] = max(dp[i - <span class="number">1</span>] + sum[i], sum[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; r++)</span><br><span class="line">                res = max(res, dp[r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>把最大子段和的函数封装一下可能会更好看, 我懒的搞...</p><h3 id="百练-2766-最大子矩阵">百练 2766: 最大子矩阵</h3><p>总时间限制: 1000ms 内存限制: 65536kB</p><h4 id="描述-2">描述</h4><p>已知矩阵的大小定义为矩阵中所有元素的和。给定一个矩阵，你的任务是找到最大的非空(大小至少是1 * 1)子矩阵。</p><p>比如，如下4 * 4的矩阵</p><p><span class="math display">\[\begin{bmatrix}0 &amp; -2 &amp; -7 &amp; 0 \\9 &amp; 2 &amp; -6 &amp; 2 \\-4 &amp; 1 &amp; -4 &amp; 1 \\-1 &amp; 8 &amp; 0 &amp; -2\end{bmatrix}\]</span></p><p>的最大子矩阵是</p><p><span class="math display">\[\begin{bmatrix}9 &amp; 2 \\-4 &amp; 1 \\-1 &amp; 8\end{bmatrix}\]</span></p><p>这个子矩阵的大小是15。</p><h4 id="输入-2">输入</h4><p>输入是一个N * N的矩阵。输入的第一行给出N (0 &lt; N &lt;= 100)。再后面的若干行中，依次（首先从左到右给出第一行的N个整数，再从左到右给出第二行的N个整数……）给出矩阵中的N2个整数，整数之间由空白字符分隔（空格或者空行）。已知矩阵中整数的范围都在[-127, 127]。</p><h4 id="输出-2">输出</h4><p>输出最大子矩阵的大小。</p><h4 id="样例输入-2">样例输入</h4><p>4<br>0 -2 -7 0 9 2 -6 2<br>-4 1 -4 1 -1</p><p>8 0 -2</p><h4 id="样例输出-2">样例输出</h4><p>15</p><h4 id="思路-2">思路</h4><p>有啥好说的么...很裸. 这题机试要是过不去的话我觉得我可以去死了..</p><h4 id="ac代码-3">AC代码</h4><p>懒, 用了 <code>cin</code>, <code>cout</code>. <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn], dp[maxn], sum[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; r++)</span><br><span class="line">            sum[r] = a[r][i];</span><br><span class="line">        dp[<span class="number">0</span>] = sum[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt; m; r++)</span><br><span class="line">            dp[r] = max(dp[r - <span class="number">1</span>] + sum[r], sum[r]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; r++)</span><br><span class="line">            res = max(res, dp[r]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; r++)</span><br><span class="line">                sum[r] += a[r][j];</span><br><span class="line">            dp[<span class="number">0</span>] = sum[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt; m; r++)</span><br><span class="line">                dp[r] = max(dp[r - <span class="number">1</span>] + sum[r], sum[r]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; r++)</span><br><span class="line">                res = max(res, dp[r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; solve(n, n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="背包相关问题">背包相关问题</h2><p>背包相关的问题的背景大都是往容量有限的背包中装一些给定的物品, 使得总价值尽可能大. 感觉机试中比较多的就是0-1背包.</p><h3 id="背包">0-1背包</h3><p>有 <span class="math inline">\(n\)</span> 件物品和一个容量为 <span class="math inline">\(V\)</span> 的背包. 放入第 <span class="math inline">\(i\)</span> 件物品耗费的费用是 <span class="math inline">\(c_i\)</span>, 得到的 价值是 <span class="math inline">\(w_i\)</span>. 求解将哪些物品装入背包可使价值总和最大.<br>实现代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// maxc 表示cost 最大值, maxn 表示n 最大值.</span></span><br><span class="line"><span class="comment">// dp[cost] 即为答案.</span></span><br><span class="line"><span class="keyword">int</span> n, cost;</span><br><span class="line"><span class="keyword">int</span> dp[maxc], c[maxn], w[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = cost; j &gt;= c[i]; j--)</span><br><span class="line">            dp[j] = max(dp[j], dp[j - c[i]] + w[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="百练-3714-点菜问题">百练 3714: 点菜问题</h3><blockquote><p>题目链接: http://bailian.openjudge.cn/practice/3714/</p></blockquote><p>总时间限制: 1000ms 内存限制: 65536kB</p><h4 id="描述-3">描述</h4><p>北大网络实验室经常有活动需要叫外买，但是每次叫外买的报销经费的总额最大为C元，有N种菜可以点 ，经过长时间的点菜，网络实验室对于每种菜i都有一个量化的评价分数（表示这个菜可口程度），为Vi，每种菜的价格为Pi, 问如何选择各种菜，使得在报销额度范围内能使点到的菜的总评价分数最大？ 注意：由于需要营养多样化，每种菜只能点一次。</p><h4 id="输入-3">输入</h4><p>输入的第一行有两个整数C（1 &lt;= C &lt;= 1000）和N（1 &lt;= N &lt;= 100），C代表总共能够报销的额度，N&gt;代表能点菜的数目。接下来的N行每行包括两个在1到100之间（包括1和100）的的整数，分别表示菜的&gt;价格和菜的评价分数。</p><h4 id="输出-3">输出</h4><p>输出只包括一行，这一行只包含一个整数，表示在报销额度范围内，所点的菜得到的最大评价分数。</p><h4 id="样例输入-3">样例输入</h4><p>90 4<br>20 25<br>30 20<br>40 50<br>10 18<br>40 2<br>25 30<br>10 8</p><h4 id="样例输出-3">样例输出</h4><p>95<br>38</p><h4 id="ac代码-4">AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxc = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, cost;</span><br><span class="line"><span class="keyword">int</span> dp[maxc], c[maxn], w[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = cost; j &gt;= c[i]; j--)</span><br><span class="line">            dp[j] = max(dp[j], dp[j - c[i]] + w[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; cost &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; c[i] &gt;&gt; w[i];</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[cost] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="百练-2773-采药">百练 2773: 采药</h3><p>总时间限制: 1000ms 内存限制: 65536kB</p><h4 id="描述-4">描述</h4><p>辰辰是个很有潜能、天资聪颖的孩子，他的梦想是称为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”</p><p>如果你是辰辰，你能完成这个任务吗？</p><h4 id="输入-4">输入</h4><p>输入的第一行有两个整数T（1 &lt;= T &lt;= 1000）和M（1 &lt;= M &lt;= 100），T代表总共能够用来采药的时间，M代表山洞里的草药的数目。接下来的M行每行包括两个在1到100之间（包括1和100）的的整数，分别表示采摘某株草药的时间和这株草药的价值。</p><h4 id="输出-4">输出</h4><p>输出只包括一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。</p><h4 id="样例输入-4">样例输入</h4><p>70 3<br>71 100<br>69 1<br>1 2</p><h4 id="样例输出-4">样例输出</h4><p>3</p><h4 id="ac代码-5">AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxc = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, cost;</span><br><span class="line"><span class="keyword">int</span> dp[maxc], weight[maxn], value[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = cost; c &gt;= weight[i]; c--)</span><br><span class="line">            dp[c] = max(dp[c], dp[c - weight[i]] + value[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; cost &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; weight[i] &gt;&gt; value[i];</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[cost] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大上升子序列和">最大上升子序列和</h2><h3 id="牛客网-最大上升子序列和">牛客网: 最大上升子序列和</h3><blockquote><p>题目链接: https://www.nowcoder.com/practice/dcb97b18715141599b64dbdb8cdea3bd?tpId=40&amp;tqId=21409&amp;tPage=4&amp;rp=4&amp;ru=/ta/kaoyan&amp;qru=/ta/kaoyan/question-ranking</p></blockquote><h4 id="题目描述">题目描述</h4><p>一个数的序列bi，当b1 &lt; b2 &lt; ... &lt; bS的时候，我们称这个序列是上升的。对于给定的一个序列(a1, a2, ...,aN)，我们可以得到一些上升的子序列(ai1, ai2, ..., aiK)，这里1 &lt;= i1 &lt; i2 &lt; ... &lt; iK &lt;= N。比如，对于序列(1, 7, 3, 5, 9, 4, 8)，有它的一些上升子序列，如(1, 7), (3, 4, 8)等等。这些子序列中序列和最大为18，为子序列(1, 3, 5, 9)的和. 你的任务，就是对于给定的序列，求出最大上升子序列和。注意，最长的上升子序列的和不一定是最大的，比如序列(100, 1, 2, 3)的最大上升子序列和为100，而最长上升子序列为(1, 2, 3)。</p><h4 id="输入描述">输入描述</h4><p>输入包含多组测试数据。 每组测试数据由两行组成。第一行是序列的长度N (1 &lt;= N &lt;= 1000)。第二行给出序列中的N个整数，这些整数的取值范围都在0到10000（可能重复）。</p><h4 id="输出描述">输出描述</h4><p>对于每组测试数据，输出其最大上升子序列和。</p><h4 id="样例输入-5">样例输入</h4><p>7<br>1 7 3 5 9 4 8</p><h4 id="样例输出-5">样例输出</h4><p>18</p><h4 id="大致思路">大致思路</h4><p>仍然是经典的子段/子序列dp的思路, 设原数组为 <span class="math inline">\(a\)</span>, 记 <span class="math inline">\(dp[i]\)</span> 为以第 <span class="math inline">\(i\)</span> 位结尾的最大上升子序列和, 则考虑 <span class="math inline">\(i&lt;j\)</span>, 若 <span class="math inline">\(a[j] &lt; a[i]\)</span>, 则 <span class="math inline">\(a[i]\)</span> 接在以 <span class="math inline">\(a[j]\)</span> 结尾的最大和子序列后可以构成一个以 <span class="math inline">\(a[i]\)</span> 结尾的子序列, 可用该子序列的和去更新 <span class="math inline">\(dp[i]\)</span> 的值, 即: <span class="math display">\[dp[i] = \max\left\{\max_{0&lt;j&lt;i,~a[j]&lt;a[i]}\{dp[j]+a[i]\}, a[i]\right\}.\]</span></p><h4 id="ac代码-6">AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn], dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[i])</span><br><span class="line">                dp[i] = max(dp[i], dp[j] + a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        res = max(res, dp[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; solve(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合数的递推">组合数的递推</h2><p>这是一个很蠢的东西, 勉强算作动态规划吧.. 但实际只应算作递推.</p><h3 id="原理">原理</h3><p>根本不用细说...就这一个式子, 叫做pascal公式. <span class="math display">\[\binom{n}{k}=\binom{n-1}{k}+\binom{n-1}{k-1}.\]</span></p><h3 id="实现代码-2">实现代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c[n][k] 表示n 中取k.</span></span><br><span class="line"><span class="keyword">int</span> c[<span class="number">205</span>][<span class="number">205</span>]; <span class="comment">// 这样的组合数已经大到天上了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getBinom</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">205</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; <span class="number">205</span>; j++)</span><br><span class="line">            c[j][i] = (c[j - <span class="number">1</span>][i] + c[j - <span class="number">1</span>][i - <span class="number">1</span>]) % mod;</span><br><span class="line">    &#125; <span class="comment">// 数字比较小的时候 大概30以下 可以不取模</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 保研复习 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2015年组合数学期末考试试卷</title>
      <link href="/2018/06/28/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62015%E5%B9%B4%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7/"/>
      <content type="html"><![CDATA[<h2 id="试题">试题</h2><ol style="list-style-type: decimal"><li>在边长为 <span class="math inline">\(1\)</span> 的正方形中至少放入几个点, 才能保证至少有两点的距离不大于 <span class="math inline">\(\frac{1}{3}\)</span>?</li><li>化简组合恒等式 <span class="math display">\[\sum\limits_{k=0}^n \binom{\alpha+k}{p+k}\binom{p+k}{k}.\]</span></li><li>记初始排列为 <span class="math inline">\(1,2,\cdots,n\)</span>, 将其重排后为 <span class="math inline">\(a_1,\cdots,a_n\)</span>, s.t. <span class="math inline">\(a_{i+1}\neq a_i+1\)</span> <span class="math inline">\((i=1,2,\cdots,n-1)\)</span>, 令其方案数为 <span class="math inline">\(Q_n\)</span>:<ol style="list-style-type: decimal"><li>利用组合方法推导 <span class="math inline">\(Q_n\)</span> 的递推关系;</li><li>利用容斥原理推导 <span class="math inline">\(Q_n\)</span> 的递推关系.</li></ol></li><li>用延迟认可算法求下面优先矩阵的稳定完备婚姻匹配(男选女, 女选男各做一次), 并给出简单评价:</li></ol><table><thead><tr class="header"><th align="center"></th><th align="center"><span class="math inline">\(a\)</span></th><th align="center"><span class="math inline">\(b\)</span></th><th align="center"><span class="math inline">\(c\)</span></th><th align="center"><span class="math inline">\(d\)</span></th><th align="center"><span class="math inline">\(e\)</span></th><th align="center"><span class="math inline">\(f\)</span></th></tr></thead><tbody><tr class="odd"><td align="center"><span class="math inline">\(A\)</span></td><td align="center"><span class="math inline">\((1,4)\)</span></td><td align="center"><span class="math inline">\((2,3)\)</span></td><td align="center"><span class="math inline">\((3,6)\)</span></td><td align="center"><span class="math inline">\((4,2)\)</span></td><td align="center"><span class="math inline">\((5,5)\)</span></td><td align="center"><span class="math inline">\((6,1)\)</span></td></tr><tr class="even"><td align="center"><span class="math inline">\(B\)</span></td><td align="center"><span class="math inline">\((3,1)\)</span></td><td align="center"><span class="math inline">\((5,2)\)</span></td><td align="center"><span class="math inline">\((6,5)\)</span></td><td align="center"><span class="math inline">\((2,6)\)</span></td><td align="center"><span class="math inline">\((1,3)\)</span></td><td align="center"><span class="math inline">\((4,4)\)</span></td></tr><tr class="odd"><td align="center"><span class="math inline">\(C\)</span></td><td align="center"><span class="math inline">\((5,5)\)</span></td><td align="center"><span class="math inline">\((3,6)\)</span></td><td align="center"><span class="math inline">\((6,1)\)</span></td><td align="center"><span class="math inline">\((4,4)\)</span></td><td align="center"><span class="math inline">\((2,2)\)</span></td><td align="center"><span class="math inline">\((1,3)\)</span></td></tr><tr class="even"><td align="center"><span class="math inline">\(D\)</span></td><td align="center"><span class="math inline">\((6,6)\)</span></td><td align="center"><span class="math inline">\((5,5)\)</span></td><td align="center"><span class="math inline">\((4,4)\)</span></td><td align="center"><span class="math inline">\((3,3)\)</span></td><td align="center"><span class="math inline">\((2,1)\)</span></td><td align="center"><span class="math inline">\((1,2)\)</span></td></tr><tr class="odd"><td align="center"><span class="math inline">\(E\)</span></td><td align="center"><span class="math inline">\((1,3)\)</span></td><td align="center"><span class="math inline">\((3,1)\)</span></td><td align="center"><span class="math inline">\((5,2)\)</span></td><td align="center"><span class="math inline">\((2,5)\)</span></td><td align="center"><span class="math inline">\((4,4)\)</span></td><td align="center"><span class="math inline">\((6,6)\)</span></td></tr><tr class="even"><td align="center"><span class="math inline">\(F\)</span></td><td align="center"><span class="math inline">\((4,2)\)</span></td><td align="center"><span class="math inline">\((5,4)\)</span></td><td align="center"><span class="math inline">\((6,3)\)</span></td><td align="center"><span class="math inline">\((1,1)\)</span></td><td align="center"><span class="math inline">\((2,6)\)</span></td><td align="center"><span class="math inline">\((3,5)\)</span></td></tr></tbody></table><ol start="5" style="list-style-type: decimal"><li>设数列满足 <span class="math inline">\(\{f_n\}\)</span> 满足 <span class="math inline">\(f_0=1\)</span>, <span class="math inline">\(f_1=1\)</span>, <span class="math inline">\(f_n=f_{n-1}+f_{n-2}~(n\geqslant 2)\)</span>, 令 <span class="math inline">\(g_n=f_{2n}\)</span>, <span class="math inline">\(h_n=f_n^2\)</span>.<ol style="list-style-type: decimal"><li>分别求 <span class="math inline">\(f\)</span>, <span class="math inline">\(g\)</span>, <span class="math inline">\(h\)</span> 的通项公式;</li><li>求 <span class="math inline">\(g_n\)</span> 与 <span class="math inline">\(h_n\)</span> 的生成函数.</li></ol></li><li>构造一个指标为 <span class="math inline">\(1\)</span> 的 <span class="math inline">\(9\)</span> 元素 <span class="math inline">\(STS\)</span>, 判断它是否可解, 并给出理由.</li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>荒野行动回忆录</title>
      <link href="/2018/04/24/%E8%8D%92%E9%87%8E%E8%A1%8C%E5%8A%A8%E5%9B%9E%E5%BF%86%E5%BD%95/"/>
      <content type="html"><![CDATA[<blockquote><p>　　偶然在桌面的角落发现了许久没有打开的荒野行动, 顺手打了一盘之后狠下心点了卸载. 游戏结束后看着空荡荡的在线好友列表, 不禁想起每天晚上十点准时吃鸡的日子.<br>　　竟有些怀念.</p></blockquote><a id="more"></a><h2 id="初识吃鸡">初识吃鸡</h2><blockquote><p>这是一个吃鸡全靠运气的时期.</p></blockquote><ul><li>最初开始玩荒野行动大致在2017.12-2018.01这段时间.</li><li>尽管以前玩过CS一类的FPS游戏, 在刚上手吃鸡时还是被打得找不着北.</li><li>第一次吃鸡是被翊坤和白旭阳舔空投带吃鸡的, 那时我还摸不清游戏的节奏.</li><li>慢慢摸清游戏节奏之后, 终于偶尔有了好的表现, 但大多数时间都是躺赢躺输.</li></ul><h2 id="成长之路">成长之路</h2><h3 id="秋田小队">秋田小队</h3><blockquote><p>这段时间可能是荒野行动在我们当中最火的时期.</p></blockquote><ul><li>时间长了, 我们渐渐形成了稳定的开黑车队: 我+贾鑫mvp+社会我丁哥+向思忆+猴子+曾邱. 因为大家开黑时都会穿游戏中的&quot;秋田犬&quot;时装, 故称为秋田小队.</li><li>秋田小队开黑的大部分时间是靠贾鑫mvp带飞的. 在此期间, 我从未在打出好数据的局中吃鸡. 这实际上意味着我虽然对游戏节奏有了更好的理解, 但仍然不能带队吃鸡.</li></ul><h3 id="假期开黑">假期开黑</h3><blockquote><p>终于有了自己对游戏节奏的理解.</p></blockquote><ul><li>随着时间的推移, 我找回了些许从前玩CS的感觉, 终于也能在吃鸡局中打出不俗的数据.<ul><li>正是此时有了第一次不坑的吃鸡:<center><img src="http://olgwnj89q.bkt.clouddn.com/第一次不坑吃鸡.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/quality/75%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="第一次不坑吃鸡"></center></li></ul></li><li>后来把兔子拉入了坑, 加上贾鑫mvp回家以后, 秋田小队名存实亡. 此时的开黑车队变为了: 我+兔子+社会我丁哥+猴子.</li><li>从此开始了和兔子天天窝在309吃鸡的生活: 因为兔子不熟悉游戏, 打法以打野为主. 自此开发了右下角野区的&quot;吃鸡路线&quot;.<ul><li>第一次带兔子吃鸡: 完全是带兔子和社会我丁哥躺鸡, <del>两个人都是零输出有没有</del>.<center><img src="http://olgwnj89q.bkt.clouddn.com/第一次带兔子吃鸡.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/quality/75%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="第一次带兔子吃鸡"></center></li><li>第二次带兔子吃鸡: 这次是和猴子势力开黑吃鸡, <del>这人头都让猴子抢去了.</del><center><img src="http://olgwnj89q.bkt.clouddn.com/第二次和兔子吃鸡.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/quality/75%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="第二次带兔子吃鸡"></center></li><li>和兔子吃5km毒的故事: 值得一提的一场比赛. 扛毒杀人最为致命. 可惜一进圈就被阴Orz.<center><img src="http://olgwnj89q.bkt.clouddn.com/一场吃了5km毒.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/quality/75%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="一场吃了5km毒"></center></li></ul></li></ul><h2 id="日常吃鸡">日常吃鸡</h2><blockquote><p>这时对游戏节奏已经非常清楚, 几乎天天都能吃鸡. 以和社会我丁哥双排为主.</p></blockquote><ul><li><strong>值得纪念的是第一次带社会我丁哥双排吃鸡, 从此拉开了天天吃鸡的序幕.</strong></li></ul><center><img src="http://olgwnj89q.bkt.clouddn.com/第一次和社会我丁哥双排吃鸡.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/quality/75%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="第一次和社会我丁哥双排吃鸡"></center><p>一般吃鸡的情况有以下几种: 策略鸡, 刚枪鸡, 躺鸡. 其中以策略鸡最多.</p><h3 id="策略鸡">策略鸡</h3><blockquote><p>前期避战, 合理转移, 保存实力一波吃鸡的打法.</p></blockquote><p>经典战例如下:</p><h4 id="海上绕圈避战">海上绕圈避战</h4><ul><li>这盘装备一般, 但中期的时候, 观察到圈的特殊性, 直接找船绕了大半圈跑到无人地带, 最后决赛圈一波得手.</li></ul><center><img src="http://olgwnj89q.bkt.clouddn.com/开船绕大圈吃鸡.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/quality/75%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="海上绕圈避战"></center><h4 id="天命鸡">天命鸡</h4><ul><li>这一类很特别: 这一盘因为AI的存在, 数据看起来很像刚枪鸡. 但实际上就是在滨海镇蹲了20分钟杀了1w个AI舔了1w个空投决战圈刷在脸上刚一波成功吃鸡.</li></ul><center><img src="http://olgwnj89q.bkt.clouddn.com/AI-1.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/quality/75%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="天命鸡-1"></center><h4 id="其他策略鸡记录">其他策略鸡记录</h4><center><img src="http://olgwnj89q.bkt.clouddn.com/苟鸡-1.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/quality/75%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="策略鸡-1"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/苟鸡-2.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/quality/75%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="策略鸡-2"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/苟鸡-3.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/quality/75%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="策略鸡-3"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/苟鸡-4.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/quality/75%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="策略鸡-4"></center><h3 id="刚枪鸡">刚枪鸡</h3><blockquote><p>见人就锤, 来车就扫, 杀出一条血路吃鸡的打法.</p></blockquote><h4 id="伤害第一次破千">伤害第一次破千</h4><ul><li>这是一局值得纪念的比赛Orz. 毕竟我很菜, 破千这事情干得不多.</li></ul><center><img src="http://olgwnj89q.bkt.clouddn.com/伤害第一次破千.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/quality/75%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="伤害第一次破千"></center><h4 id="其他刚枪鸡记录">其他刚枪鸡记录</h4><ul><li>都算是打架比较多的局.</li></ul><center><img src="http://olgwnj89q.bkt.clouddn.com/刚鸡-1.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/quality/75%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="刚枪鸡-1"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/刚鸡-2.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/quality/75%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="刚枪鸡-2"></center><h3 id="躺鸡">躺鸡</h3><blockquote><p>搜完房区, 一路无人, 莫名其妙也能吃鸡的打法.</p></blockquote><h4 id="ai鸡">AI鸡</h4><ul><li>躺鸡也有一种AI的情况, 就是杀了几个AI然后没打架就吃鸡. 看数据很容易与策略鸡混淆.</li></ul><center><img src="http://olgwnj89q.bkt.clouddn.com/躺鸡-1.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/quality/75%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="AI鸡-1"></center><h4 id="其他躺鸡记录">其他躺鸡记录</h4><ul><li>可以看得出, 都很躺.</li></ul><center><img src="http://olgwnj89q.bkt.clouddn.com/躺鸡-2.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/quality/75%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="躺鸡-2"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/躺鸡-3.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/quality/75%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="躺鸡-3"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/躺鸡-4.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/quality/75%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="躺鸡-4"></center>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
            <tag> 荒野行动 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>图说农药</title>
      <link href="/2018/04/18/%E5%86%9C%E8%8D%AF%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95/"/>
      <content type="html"><![CDATA[<p>时间过得真快, 不知不觉农药已经玩了快一年了. 翻相册时无意翻到了这些图片, 决定开坑保存一下.</p><a id="more"></a><h2 id="农药大事记">农药大事记</h2><h3 id="排位足迹">排位足迹</h3><blockquote>各个赛季的段位情况如下:<center><img src="http://olgwnj89q.bkt.clouddn.com/赛季总览.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="段位总览"></center></blockquote><h4 id="s7赛季">S7赛季</h4><ul><li>初识农药:<ul><li>最早玩的是后羿, 简单暴力.</li><li>后来因为兔子玩后羿, 改玩安琪拉. 在低端局日常超神.</li></ul></li><li>组队上分:<ul><li>后来结识了小boo, 加入了新乐群战队, 开始了五排上分.</li><li>主要玩射手, 很容易看出, 我可能是射手狂魔.</li><li>这时鲁班非常强, 加上段位不高, 故多玩鲁班, 偶尔玩狄仁杰.</li></ul></li></ul><center><img src="http://olgwnj89q.bkt.clouddn.com/S7.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="S7赛季"></center><h4 id="s8赛季">S8赛季</h4><ul><li>组队上分:<ul><li>初期仍然维持着组队上分的节奏.</li></ul></li><li>疯狂排位:<ul><li>放假后大家时间并不统一, 于是开始了单排上分.</li><li>不过假期还是常打战队赛攒铭文碎片的哈哈.</li><li>虽然开发出了吕布, 但主要还是玩射手, 但主要玩的英雄变成了马可. 后来又学会了孙尚香.</li></ul></li><li>冲上王者:<ul><li>在开学后, 比较艰难地冲上了王者Orz.</li><li>上王者之后, 由于开黑的兄弟们段位都比较低, 加上战队赛打不赢的问题, 掉了一波分.</li></ul></li></ul><center><img src="http://olgwnj89q.bkt.clouddn.com/S8.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="S8赛季"></center><h4 id="s9赛季">S9赛季</h4><ul><li>掉分带人:<ul><li>由于已经上过王者, 我便懒得冲分, 很少打排位. 只是偶尔带一带贾鑫mvp或者其他人.</li><li>可惜贾鑫mvp本赛季没有成功冲上王者Orz.</li><li>此时的英雄池深了很多, 可以看出英雄的使用场次都不多.</li></ul></li><li>给兔子上分:<ul><li>兔子想追上我的段位, 未果. 于是我偶尔用兔子的号上分. 也带带王队.</li><li>我所经历过貂蝉最强的一个赛季, 用貂蝉给兔子上了几个星.</li><li>然而效果并不理想Orz. 我好菜_(:з」∠)_</li></ul></li></ul><center><img src="http://olgwnj89q.bkt.clouddn.com/S9.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="S9赛季"></center><h4 id="s10赛季">S10赛季</h4><ul><li>沉迷吃鸡:<ul><li>由于吃鸡的影响, 不论是匹配还是排位都打得少了一些.</li><li>莫名其妙学会了花木兰, 尽管胜率感人.</li><li>打折期间剁手了嬴政Orz.</li></ul></li><li>对黑王队:<ul><li>王队的加入及其室友的回归壮大了农药玩家的队伍, 于是有一段时间经常开房间5v5对黑.</li><li>战绩嘛emmmmm, <del>宝宝自然是没怎么输过.</del></li></ul></li><li>勉强上钻:<ul><li>兔子卸掉了一段时间农药, 我便觉得暂时没有必要停留在铂金. 用上RMB英雄嬴政, 一波七连胜轻松冲上了钻石.</li><li>上钻之后便基本没有再打. 可能带过贾鑫mvp几盘. 贾鑫mvp在本赛季成功冲上了王者Orz.</li><li>赛季末兔子又下回了农药, 不过上钻已来不及.</li></ul></li></ul><center><img src="http://olgwnj89q.bkt.clouddn.com/S10.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="S10赛季"></center><h4 id="s11赛季">S11赛季</h4><ul><li>在济南的时候开始了S11赛季, <del>宾馆排位, 最为致命</del>.</li><li>妈的第一天就四连败. 肥肠生气..</li></ul><center><img src="http://olgwnj89q.bkt.clouddn.com/S11.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="S11赛季初战绩"></center><ul><li>基本只玩打野和上单的一个赛季.</li><li>基本只玩强势英雄的一个赛季.</li><li>疯狂掉胜率的一个赛季.</li></ul><center><img src="http://olgwnj89q.bkt.clouddn.com/S11-1.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="S11赛季"></center><h4 id="s12赛季">S12赛季</h4><ul><li>与S11形成鲜明对比..上来就是一波五连胜骑脸.</li><li>然后肉丁一口奶, 第六场输了== 按照赌约要在他来收拾寝室的时候干他== 辣鸡肉丁.</li></ul><center><img src="http://olgwnj89q.bkt.clouddn.com/S12-1.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="S12赛季初战绩"></center><h3 id="琐碎的大事记">琐碎的大事记</h3><ul><li>第一次Solo打赢丁丁:<ul><li>蛇皮丁丁 完全就是吊打！有没有！有！没！有！<center><img src="http://olgwnj89q.bkt.clouddn.com/solo%E8%83%9C%E4%B8%81%E4%B8%81.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="第一次Solo胜丁丁"></center></li></ul></li><li>武道会打到第一名:<ul><li>我也不知道为什么这么强, <del>可能是铭文强</del><center><img src="http://olgwnj89q.bkt.clouddn.com/%E6%AD%A6%E9%81%93%E4%BC%9A1st.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="武道会第一名"></center></li></ul></li><li>上王者:<ul><li>没用的狗王者说上就上<center><img src="http://olgwnj89q.bkt.clouddn.com/%E7%8E%8B%E8%80%85.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="王者"></center></li></ul></li><li>第一次成为大神玩家Orz<ul><li>瑟瑟发抖 然而并不知道这样出装哪里不合理Orz<center><img src="http://olgwnj89q.bkt.clouddn.com/%E5%AD%99%E5%B0%9A%E9%A6%99%E5%87%BA%E8%A3%85.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="莫名其妙成为孙尚香大神玩家哈哈哈"></center></li></ul></li><li>公孙离拿五杀<ul><li>记不起是第几次五杀了, <del>这样说会让人觉得我经常五杀</del><center><img src="http://olgwnj89q.bkt.clouddn.com/%E5%85%AC%E5%AD%99%E7%A6%BB%E4%BA%94%E6%9D%80.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="公孙离五杀"></center></li><li>顺手补点其他的五杀<center><img src="http://olgwnj89q.bkt.clouddn.com/马可波罗五杀.jpeg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="马可波罗五杀"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/守约五杀.png?imageMogr2/auto-orient/thumbnail/x155/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="百里守约五杀"> <img src="http://olgwnj89q.bkt.clouddn.com/李元芳五杀.png?imageMogr2/auto-orient/thumbnail/x155/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="李元芳五杀"></center></li></ul></li><li>用兔子号带王队上分Orz<ul><li>莫名其妙就会玩貂蝉了, 输出过半碾压铂金局<center><img src="http://olgwnj89q.bkt.clouddn.com/%E8%B2%82%E8%9D%89-1.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="用兔子号和丁丁带326各位上分之一"><img src="http://olgwnj89q.bkt.clouddn.com/%E8%B2%82%E8%9D%89-2.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="用兔子号和丁丁带326各位上分之二"><img src="http://olgwnj89q.bkt.clouddn.com/貂蝉-战队赛.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="某次战队赛, 有点怀念"></center></li><li>其实自己用芈月这种弱势英雄也打出过类似的数据<center><img src="http://olgwnj89q.bkt.clouddn.com/芈月数据.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="芈月碾压局"></center></li><li>还有大家眼中的废物英雄弈星.<center><img src="http://olgwnj89q.bkt.clouddn.com/弈星数据.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="血崩局弈星输出过半"></center></li><li>还用孙膑打出过这种级别的数据, 虽然输了== 但是我服我自己哈哈哈<center><img src="http://olgwnj89q.bkt.clouddn.com/孙膑数据.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="孙膑数据"></center></li></ul></li><li>圣诞老人皮肤<ul><li>S12的第一天六盘排位之后, 和兔子的师徒等级到了6级, 得到了圣诞老人皮肤. 肥肠开心, yeah!<center><img src="http://olgwnj89q.bkt.clouddn.com/圣诞老人.png?imageMogr2/auto-orient/thumbnail/x200/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="得到皮肤 超开心！"> <img src="http://olgwnj89q.bkt.clouddn.com/老夫子皮肤.jpg?imageMogr2/auto-orient/thumbnail/x200/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="必须得秀一下~"></center><!-- <center></center> --></li></ul></li></ul><h2 id="扯淡的训练营">扯淡的训练营</h2><blockquote><p>训练营也是需要技<del>运气</del>术的好吧(</p></blockquote><ul><li>轮盘方向<center><img src="http://olgwnj89q.bkt.clouddn.com/轮盘方向.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="轮盘方向训练营"></center></li><li>区域施法<center><img src="http://olgwnj89q.bkt.clouddn.com/区域施法.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="区域施法训练营"></center></li><li>穿墙移动<center><img src="http://olgwnj89q.bkt.clouddn.com/穿墙移动.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="穿墙移动训练营"></center></li></ul><h2 id="全英雄金牌进度-8285">全英雄金牌进度: 82/85</h2><!-- 还差武则天（没有英雄），弈星，和盾山。事实上，也差不多就和农药缘尽于此了，这个记录差不多也就要结束了。 --><ul><li>[x] 伽罗<center><img src="http://olgwnj89q.bkt.clouddn.com/伽罗.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌伽罗"></center></li><li>[ ] 盾山 <!-- <center>![金牌盾山][盾山]</center> --></li><li>[x] 司马懿<center><img src="http://olgwnj89q.bkt.clouddn.com/司马懿.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌司马懿"></center></li><li>[x] 孙策<center><img src="http://olgwnj89q.bkt.clouddn.com/孙策.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌孙策"></center></li><li>[x] 元歌<center><img src="http://olgwnj89q.bkt.clouddn.com/元歌-2.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌元歌"></center></li><li>[x] 米莱狄 （对金牌系统表示质疑）<center><img src="http://olgwnj89q.bkt.clouddn.com/米莱迪-1.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="银牌米莱狄"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/米莱迪-2.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌米莱狄"></center></li><li>[x] 狂铁<center><img src="http://olgwnj89q.bkt.clouddn.com/狂铁.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌狂铁"></center></li><li>[ ] 弈星 <!-- <center>![金牌弈星][弈星]</center> --></li><li>[x] 裴擒虎<center><img src="http://olgwnj89q.bkt.clouddn.com/裴擒虎.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌裴擒虎"></center></li><li>[x] 杨玉环<center><img src="http://olgwnj89q.bkt.clouddn.com/杨玉环-1.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌杨玉环"></center></li><li>[x] 公孙离 （按时间顺序第二次对金牌系统表示质疑）<center><img src="http://olgwnj89q.bkt.clouddn.com/啊公孙离.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌公孙离"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/公孙离-1.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="评分低了, 然而位次更高"></center></li><li>[x] 明世隐<center><img src="http://olgwnj89q.bkt.clouddn.com/明世隐.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌明世隐"></center></li><li>[x] 女娲<center><img src="http://olgwnj89q.bkt.clouddn.com/女娲.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌女娲"></center></li><li>[x] 梦奇<center><img src="http://olgwnj89q.bkt.clouddn.com/梦奇.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌梦奇"></center></li><li>[x] 苏烈<center><img src="http://olgwnj89q.bkt.clouddn.com/苏烈.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌苏烈"></center></li><li>[x] 百里玄策<center><img src="http://olgwnj89q.bkt.clouddn.com/百里玄策.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌百里玄策"></center></li><li>[x] 百里守约<center><img src="http://olgwnj89q.bkt.clouddn.com/守约.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌百里守约"></center>还有个分更高的：<center><img src="http://olgwnj89q.bkt.clouddn.com/百里守约-1.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌百里守约"></center></li><li>[x] 铠<center><img src="http://olgwnj89q.bkt.clouddn.com/铠.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌铠"></center></li><li>[x] 鬼谷子<br>鬼谷子都这样了不是金牌…很无奈Orz 就这样了.<center><img src="http://olgwnj89q.bkt.clouddn.com/鬼谷子.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌鬼谷子"></center>然后按照时间顺序第三次对金牌判定提出质疑==<center><img src="http://olgwnj89q.bkt.clouddn.com/鬼谷子-1.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="真·金牌鬼谷子"></center></li><li>[x] 干将莫邪<center><img src="http://olgwnj89q.bkt.clouddn.com/干将.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌干将莫邪"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/干将莫邪.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金用兔号打的"></center></li><li>[x] 东皇太一 暂时不好打到金牌 先这样吧。。<center><img src="http://olgwnj89q.bkt.clouddn.com/东皇太一.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌东皇太一"></center></li><li>[x] 大乔<center><img src="http://olgwnj89q.bkt.clouddn.com/大乔.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌大乔"></center></li><li>[x] 黄忠<center><img src="http://olgwnj89q.bkt.clouddn.com/黄忠.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌黄忠"></center></li><li>[x] 诸葛亮<center><img src="http://olgwnj89q.bkt.clouddn.com/诸葛亮.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌诸葛亮"></center></li><li>[x] 哪吒<center><img src="http://olgwnj89q.bkt.clouddn.com/哪吒.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌哪吒"></center></li><li>[x] 太乙真人<center><img src="http://olgwnj89q.bkt.clouddn.com/太乙真人.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌太乙真人"></center></li><li>[x] 蔡文姬<center><img src="http://olgwnj89q.bkt.clouddn.com/蔡文姬.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌蔡文姬"></center></li><li>[x] 雅典娜<center><img src="http://olgwnj89q.bkt.clouddn.com/雅典娜.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌雅典娜"></center></li><li>[x] 杨戬<center><img src="http://olgwnj89q.bkt.clouddn.com/杨戬.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌杨戬"></center></li><li>[x] 成吉思汗<center><img src="http://olgwnj89q.bkt.clouddn.com/成吉思汗.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌成吉思汗"></center></li><li>[x] 钟馗<center><img src="http://olgwnj89q.bkt.clouddn.com/钟馗.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌钟馗"></center></li><li>[x] 虞姬<center><img src="http://olgwnj89q.bkt.clouddn.com/虞姬.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌虞姬"></center></li><li>[x] 李元芳<center><img src="http://olgwnj89q.bkt.clouddn.com/李元芳.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌李元芳"></center></li><li>[x] 张飞<center><img src="http://olgwnj89q.bkt.clouddn.com/张飞.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌张飞"></center></li><li>[x] 刘备<center><img src="http://olgwnj89q.bkt.clouddn.com/刘备.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌刘备"></center></li><li>[x] 后羿<center><img src="http://olgwnj89q.bkt.clouddn.com/后羿.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌后羿"></center></li><li>[x] 牛魔<center><img src="http://olgwnj89q.bkt.clouddn.com/牛魔.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌牛魔"></center></li><li>[x] 孙悟空<center><img src="http://olgwnj89q.bkt.clouddn.com/孙悟空.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌孙悟空"></center>再放一个分更高的...输出将近一半<center><img src="http://olgwnj89q.bkt.clouddn.com/孙悟空-2.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌孙悟空"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/孙悟空数据.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌孙悟空数据"></center></li><li>[x] 亚瑟<center><img src="http://olgwnj89q.bkt.clouddn.com/亚瑟.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌亚瑟"></center></li><li>[x] 橘右京<center><img src="http://olgwnj89q.bkt.clouddn.com/橘右京.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌橘右京"></center></li><li>[x] 娜可露露<center><img src="http://olgwnj89q.bkt.clouddn.com/娜可露露.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌娜可露露"></center></li><li>[x] 不知火舞<center><img src="http://olgwnj89q.bkt.clouddn.com/不知火舞.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌不知火舞"></center></li><li>[x] 张良<center><img src="http://olgwnj89q.bkt.clouddn.com/张良.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌张良"></center></li><li>[x] 花木兰<center><img src="http://olgwnj89q.bkt.clouddn.com/新花木兰.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌花木兰"></center></li><li>[x] 兰陵王<center><img src="http://olgwnj89q.bkt.clouddn.com/兰陵王.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌兰陵王"></center></li><li>[x] 王昭君<center><img src="http://olgwnj89q.bkt.clouddn.com/王昭君.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌王昭君"></center></li><li>[x] 韩信 其实有一次13+的...忘了截图Orz<center><img src="http://olgwnj89q.bkt.clouddn.com/韩信-1.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌韩信"></center></li><li>[x] 刘邦<center><img src="http://olgwnj89q.bkt.clouddn.com/刘邦.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌刘邦"></center></li><li>[x] 姜子牙 讲道理我觉得这个分数应该可以金牌了，但是并没有。。先这样吧。<center><img src="http://olgwnj89q.bkt.clouddn.com/银牌姜子牙.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌姜子牙"></center></li><li>[x] 露娜<center><img src="http://olgwnj89q.bkt.clouddn.com/露娜.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌露娜"></center></li><li>[x] 程咬金<center><img src="http://olgwnj89q.bkt.clouddn.com/程咬金.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌程咬金"></center></li><li>[x] 安琪拉<center><img src="http://olgwnj89q.bkt.clouddn.com/安琪拉.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌安琪拉"></center></li><li>[x] 貂蝉<center><img src="http://olgwnj89q.bkt.clouddn.com/貂蝉.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌貂蝉"></center></li><li>[x] 关羽<center><img src="http://olgwnj89q.bkt.clouddn.com/关羽-1.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌关羽"></center></li><li>[x] 老夫子<center><img src="http://olgwnj89q.bkt.clouddn.com/老夫子.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌老夫子"></center></li><li>[ ] 武则天 <!-- <center>![金牌武则天][武则天]</center> --></li><li>[x] 项羽<center><img src="http://olgwnj89q.bkt.clouddn.com/项羽.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌项羽"></center></li><li>[x] 达摩<center><img src="http://olgwnj89q.bkt.clouddn.com/达摩.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌达摩"></center></li><li>[x] 狄仁杰<center><img src="http://olgwnj89q.bkt.clouddn.com/狄仁杰.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌狄仁杰"></center></li><li>[x] 马可波罗<center><img src="http://olgwnj89q.bkt.clouddn.com/马可波罗.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌马可波罗"></center></li><li>[x] 李白<center><img src="http://olgwnj89q.bkt.clouddn.com/李白.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌李白"></center></li><li>[x] 宫本武藏<center><img src="http://olgwnj89q.bkt.clouddn.com/宫本武藏.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌宫本武藏"></center></li><li>[x] 典韦<center><img src="http://olgwnj89q.bkt.clouddn.com/典韦.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌典韦"></center></li><li>[x] 曹操<center><img src="http://olgwnj89q.bkt.clouddn.com/曹操.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌曹操"></center></li><li>[x] 甄姬<center><img src="http://olgwnj89q.bkt.clouddn.com/甄姬.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌甄姬"></center></li><li>[x] 夏侯惇<center><img src="http://olgwnj89q.bkt.clouddn.com/夏侯惇.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌夏侯惇"></center></li><li>[x] 周瑜<center><img src="http://olgwnj89q.bkt.clouddn.com/周瑜.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌周瑜"></center></li><li>[x] 吕布<center><img src="http://olgwnj89q.bkt.clouddn.com/吕布.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌吕布"></center></li><li>[x] 芈月<center><img src="http://olgwnj89q.bkt.clouddn.com/芈月.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌芈月"></center></li><li>[x] 白起<center><img src="http://olgwnj89q.bkt.clouddn.com/白起.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌白起"></center></li><li>[x] 扁鹊<center><img src="http://olgwnj89q.bkt.clouddn.com/扁鹊.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌扁鹊"></center></li><li>[x] 孙膑<center><img src="http://olgwnj89q.bkt.clouddn.com/孙膑-1.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌孙膑"></center></li><li>[x] 钟无艳<center><img src="http://olgwnj89q.bkt.clouddn.com/钟无艳-1.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌钟无艳"></center></li><li>[x] 阿轲<center><img src="http://olgwnj89q.bkt.clouddn.com/阿珂.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌阿轲"></center></li><li>[x] 高渐离<center><img src="http://olgwnj89q.bkt.clouddn.com/高渐离.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌高渐离"></center></li><li>[x] 刘禅<center><img src="http://olgwnj89q.bkt.clouddn.com/刘禅.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌刘禅"></center></li><li>[x] 庄周<center><img src="http://olgwnj89q.bkt.clouddn.com/庄周.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌庄周"></center></li><li>[x] 鲁班七号<center><img src="http://olgwnj89q.bkt.clouddn.com/鲁班.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌鲁班七号"></center></li><li>[x] 孙尚香<center><img src="http://olgwnj89q.bkt.clouddn.com/孙尚香.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌孙尚香"></center></li><li>[x] 嬴政<center><img src="http://olgwnj89q.bkt.clouddn.com/嬴政.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌嬴政"></center></li><li>[x] 妲己<center><img src="http://olgwnj89q.bkt.clouddn.com/妲己.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌妲己"></center></li><li>[x] 墨子<center><img src="http://olgwnj89q.bkt.clouddn.com/墨子.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌墨子"></center></li><li>[x] 赵云<center><img src="http://olgwnj89q.bkt.clouddn.com/赵云.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌赵云"></center></li><li>[x] 小乔<center><img src="http://olgwnj89q.bkt.clouddn.com/小乔.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌小乔"></center></li><li>[x] 廉颇<center><img src="http://olgwnj89q.bkt.clouddn.com/廉颇.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="金牌廉颇"></center></li></ul><h2 id="边境突围吃鸡小记录">边境突围吃鸡小记录</h2><blockquote><p>S12赛季农药开发了新模式边境突围, 玩法类似于吃鸡, 但是感觉emmmmm... 不如吃鸡有意思, 而且有点卡.<br>按照惯例, 还是进行一些琐碎且无聊的记录:</p></blockquote><h3 id="初入吃鸡坑">初入吃鸡坑</h3><ul><li>第一次吃鸡:<br>不谦虚地讲, 第一次玩就吃鸡了, 还是单人打双排... 感觉马可在这里边近乎无敌.<center><img src="http://olgwnj89q.bkt.clouddn.com/第一次吃鸡-数据.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="第一次吃鸡"></center></li><li>第一次带兔子吃鸡<br>体验一盘以后就立刻带兔子吃了一盘鸡. 其实这盘体验极差, 开始因为网络原因掉线, 于是和兔子距离过远, 导致兔子死掉了... 背一波锅.<center><img src="http://olgwnj89q.bkt.clouddn.com/第一次带兔子吃鸡-数据.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="第一次带兔子吃鸡"></center></li><li>体检前一晚上睡不着, 于是偷偷吃了一把鸡<center><img src="http://olgwnj89q.bkt.clouddn.com/睡不着偷偷吃把鸡-数据.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="睡不着偷偷吃把鸡"></center></li><li>于是体检当天连跪之后拉兔子吃鸡<br>这盘和上一盘最后都是一波极限一打二... 吹一波自己哈哈哈. 这盘应该算是兔子体验比较好的?<center><img src="http://olgwnj89q.bkt.clouddn.com/连跪后拉兔子吃鸡-数据.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="连跪后拉兔子吃鸡"></center></li></ul><h3 id="冲2k分之旅">冲2k分之旅</h3><blockquote><p>随着分数变高, 吃鸡开始困难了Orz, 大家操作和策略有些提升. 目前打上了2k分, 应该还能上</p></blockquote><ul><li>这一盘战斗力高到天上...我都不记得是怎么做到的.<center><img src="http://olgwnj89q.bkt.clouddn.com/冲2k分之旅-1.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="冲2k分之旅, 战力巅峰, 感觉很难再高了.."></center></li><li>这盘妲己前期跟着我转, 后期乱跟人刚... 就死掉了, 幸亏我很冷静（<center><img src="http://olgwnj89q.bkt.clouddn.com/冲2k分之旅.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="冲2k分之旅"></center></li><li>关键时刻, 单人也是一种选择, 至少队友前期不抢装备.<center><img src="http://olgwnj89q.bkt.clouddn.com/冲上2k分.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="单人双排冲上2k分"></center></li></ul><h3 id="k-2k2">2k-2k2</h3><blockquote><p>单人吃鸡显著难了一些, 不过更考验自己的策略.</p></blockquote><ul><li>2k分上第一鸡, 这个后羿太凶... 我救他两次Orz, 不过最后还是跟着哥混到了糖吃嘻嘻<center><img src="http://olgwnj89q.bkt.clouddn.com/2k分第一鸡.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="2k分上第一鸡"></center></li><li>这个睿智发木兰, 我自己杀人舔装备, 竟然说我&quot;抢得真快&quot;, 于是我只好嘲讽了一下&quot;死的真快&quot;, 随后有惊无险, 单人吃鸡. 这盘战力也非常高.<center><img src="http://olgwnj89q.bkt.clouddn.com/2k分第二鸡.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="2k分上第二鸡, 战力肥肠高"></center></li></ul><h3 id="k2-2k4">2k2-2k4</h3><blockquote><p>单人吃鸡虽然比较难, 但是开黑吃鸡还凑合. 英雄由马可变成了吕布.</p></blockquote><ul><li>和小boo开黑, 非常顺利地拿到四连鸡. （另两次吃鸡属于2k4以上的事情了）<center><img src="http://olgwnj89q.bkt.clouddn.com/冲2k4.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="冲2k4"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/冲上2k4.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="冲上2k4"></center></li></ul><h3 id="k4">2k4+</h3><center><img src="http://olgwnj89q.bkt.clouddn.com/小boo第三鸡.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="小boo第三鸡"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/小boo第四鸡.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="小boo第四鸡"></center><h3 id="助手的图">助手的图</h3>偶然发现助手对于该模式的记录非常简洁, 于是找了九张图.<center><img src="http://olgwnj89q.bkt.clouddn.com/助手-1.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="助手-1"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/助手-2.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="助手-2"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/助手-3.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="助手-3"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/助手-4.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="助手-4"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/助手-5.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="助手-5"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/助手-6.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="助手-6"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/助手-7.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="助手-7"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/助手-8.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="助手-8"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/助手-9.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="助手-9"></center><!-- 和农药有缘再会. -->]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
            <tag> 王者荣耀 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论文笔记[2]——AKS素性测试</title>
      <link href="/2018/04/15/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-2-%E2%80%94%E2%80%94PRIMES-Is-in-P/"/>
      <content type="html"><![CDATA[<blockquote><p>文章: Agrawal M, Kayal N, Saxena N. PRIMES Is in P[J]. Annals of Mathematics, 2004, 160(2):781-793.</p></blockquote><center><font size="5" face="楷体" color="#6E552F"><u>太长不看版</u></font></center><center><img src="http://olgwnj89q.bkt.clouddn.com/poly%20algo.png?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="算法流程"></center><p>文章分为正确性和复杂度两部分:</p><ul><li>正确性: 素数显然会返回 <code>PRIME</code>, 只需证返回 <code>PRIME</code> 的是素数. 返回素数的地方只有 <code>Step 2</code> 和 <code>Step 6</code>, 分别讨论之.<ul><li><code>Step 4</code>: 若 <span class="math inline">\(n\)</span> 是合数则会在 <code>Step 3</code> 中返回, 矛盾.</li><li><code>Step 6</code>: 分段考虑.<ol style="list-style-type: decimal"><li>先考虑 <code>Step 2</code> 中 <span class="math inline">\(r\)</span> 的范围, 可得 <span class="math inline">\(r\leqslant\lceil\log^5n\rceil\)</span>.</li><li>定义多项式之间的关系introspective: <span class="math inline">\([f(x)]^m=f(x^m)~({\rm mod}~x^r-1,p)\)</span>, 则该性质对 <span class="math inline">\(m\)</span> 和 <span class="math inline">\(f\)</span> 都满乘积性质.</li><li>由于在 <code>Step 5</code> 没有返回 <code>COMPOSITE</code>, 故 <span class="math inline">\(\frac{n}{p},p\)</span> 对 <span class="math inline">\(x+a\)</span> 是introspective的. 故 <span class="math inline">\(\frac{n}{p}\)</span> 与 <span class="math inline">\(p^j\)</span> 的任意乘积对 <span class="math inline">\(x+a~(0\leqslant a\leqslant l)\)</span> 的任意乘积是introspective的.</li><li>进一步, 通过建立两个群 <span class="math inline">\(G\)</span> 和 <span class="math inline">\(\mathcal{G}\)</span>, 可得到 <span class="math inline">\(|\mathcal{G}|\)</span> 的下界和一个由条件的上界. 并可最终得到 <span class="math inline">\(n=p\)</span>, 即 <span class="math inline">\(n\)</span> 是素数.</li></ol></li><li><strong>至此算法正确性得证.</strong></li></ul></li><li>复杂度: 逐步分析可知 <code>Step 5</code> 复杂度最高, 为 <span class="math inline">\(O^\sim(\log^\frac{21}{2}n)\)</span>.</li></ul><a id="more"></a><hr><center><font size="5" face="楷体" color="#6E552F"><u>以下是详细的版本</u></font></center><h2 id="记号说明和准备工作">记号说明和准备工作</h2><h3 id="记号列表">记号列表</h3><p>文中出现的记号记录如下:</p><ul><li><span class="math inline">\(P\)</span>: 图灵机在多项式时间内可以解决的问题;</li><li><span class="math inline">\(F_p\)</span> 表示阶为 <span class="math inline">\(p\)</span> 的有限域, 其中 <span class="math inline">\(p\)</span> 是素数;</li><li><span class="math inline">\(f(x)=g(x)~({\rm mod}~h(x),n)\)</span>: 表示 <span class="math inline">\(f(x)=g(x)\)</span> 在 <span class="math inline">\(\mathbb{Z}_n[x]/\langle h(x)\rangle\)</span> 中成立;</li><li><span class="math inline">\(O^\sim (t(n))\)</span>: 表示 <span class="math inline">\(O(t(n))\cdot {\rm poly}(\log t(n))\)</span>. 其中 <span class="math inline">\(\log\)</span> 表示以 <span class="math inline">\(2\)</span> 为底的对数;</li><li><span class="math inline">\(o_r(a)\)</span>: 表示 <span class="math inline">\(a\)</span> 模 <span class="math inline">\(r\)</span> 的指数. 即最小的 <span class="math inline">\(k\)</span>, s.t. <span class="math inline">\(a^k=1~({\rm mod}~r)\)</span>.</li></ul><blockquote><center>为不影响思路的连贯性, 长一点的证明细节都补在最后.</center></blockquote><h3 id="准备工作">准备工作</h3><blockquote><p><strong>LEMMA 1.</strong> 设 <span class="math inline">\(a\in\mathbb{Z}\)</span>, <span class="math inline">\(n\geqslant 2\in\mathbb{N}\)</span>, 且 <span class="math inline">\((a,n)=1\)</span>, 则 <span class="math inline">\(n\)</span> 是素数当且仅当 <span class="math display">\[(x+a)^n=x^n+a~({\rm mod~n}).\]</span> <strong>Proof.</strong> 直接讨论, 利用二项式系数的性质即可.</p></blockquote><blockquote><p><strong>PRELIMINARY 1.</strong> 若 <span class="math inline">\(h(x)\)</span> 是 <span class="math inline">\(F_p[x]\)</span> 中的 <span class="math inline">\(d\)</span> 次不可约多项式, 则 <span class="math inline">\(F_p[x]/\langle h[x]\rangle\)</span> 是阶为 <span class="math inline">\(p^d\)</span> 的有限域.<br><strong>Proof.</strong> 设 <span class="math inline">\(F(\alpha)=0\)</span>, 考虑映射 <span class="math inline">\(\varphi:~F[\alpha]\to F[x],~f(\alpha)\mapsto f(x)\)</span>, 则由环同态基本定理可得 <span class="math display">\[F(\alpha)=F[\alpha]\simeq F[x]/\langle p(x)\rangle.\]</span> 由此即可证得结论.</p></blockquote><blockquote><p><strong>PRELIMINARY 2.</strong> 对于 <span class="math inline">\(\forall a,r\in\mathbb{N}\)</span> 满足 <span class="math inline">\((a,r)=1\)</span>, 都有 <span class="math inline">\(o_r(a)~\vert~\phi(r)\)</span>.<br><strong>Proof.</strong> 若不满足上式, 与 <span class="math inline">\(o_r(a)\)</span> 的最小性矛盾.</p></blockquote><blockquote><p><strong>LEMMA 2.</strong> 令 <span class="math inline">\({\rm LCM}(n)\)</span> 表示前 <span class="math inline">\(n\)</span> 个数的lcm, 则对 <span class="math inline">\(n\geqslant 7\)</span> 有: <span class="math inline">\({\rm LCM}(n)\geqslant 2^n\)</span>.<br><strong>Proof.</strong> Nair M. On Chebyshev-type inequalities for primes[J]. American Mathematical Monthly, 1982, 89(2):126-129.</p></blockquote><h2 id="算法正确性">算法正确性</h2><p>需要证明以下两条:</p><ol style="list-style-type: decimal"><li><span class="math inline">\(n\)</span> 是素数<span class="math inline">\(\to\)</span>算法返回 <code>PRIME</code> ;</li><li>算法返回 <code>PRIME</code> <span class="math inline">\(\to\)</span><span class="math inline">\(n\)</span> 是素数.</li></ol><p>事实上第一条是显然的, 主要部分是第二条的证明.</p><h3 id="n-是素数to算法返回-prime"><span class="math inline">\(n\)</span> 是素数<span class="math inline">\(\to\)</span>算法返回 <code>PRIME</code></h3><blockquote><p><strong>LEMMA 3.</strong> 若 <span class="math inline">\(n\)</span> 是素数, 则算法返回 <code>PRIME</code>.<br><strong>Proof.</strong> 这一条其实是很显然的. 证明全是废话, 略掉.</p></blockquote><h3 id="算法返回-prime-to-n-是素数">算法返回 <code>PRIME</code> <span class="math inline">\(\to n\)</span> 是素数</h3><p>算法返回 <code>PRIME</code> 的地方只有两处, 分别为 <code>Step 4</code> 和 <code>Step 6</code>. 以下分别讨论之.</p><h4 id="step-4-返回-prime-to-n-是素数"><code>Step 4</code> 返回 <code>PRIME</code> <span class="math inline">\(\to n\)</span> 是素数</h4><p>证明很容易: 如果 <span class="math inline">\(n\)</span> 是合数且 <span class="math inline">\(n\leqslant r\)</span>, 则在<code>Step</code>3 中一定可找到 <span class="math inline">\(n\)</span> 的一个非平凡因子. 故在 <code>Step 3</code> 一定会返回 <code>COMPOSITE</code>, 矛盾! 故 <code>Step 4</code> 返回 <code>PRIME</code> <span class="math inline">\(\Rightarrow n\)</span> 是素数.</p><h4 id="step-6-返回-prime-to-n-是素数"><code>Step 6</code> 返回 <code>PRIME</code> <span class="math inline">\(\to n\)</span> 是素数</h4><p>算法的核心步骤是 <code>Step 2</code> 和 <code>Step 5</code>. 算法在 <code>Step 2</code> 中取了一个 <span class="math inline">\(r\)</span> 值, 所以我们从 <span class="math inline">\(r\)</span> 的大致取值开始考虑.</p><blockquote><p><strong>LEMMA 4.</strong> <span class="math inline">\(\exists r\leqslant\max\{3,\lceil\log^5 n\rceil\}\)</span>, s.t. <span class="math inline">\(o_r(n)&gt;\log^2n\)</span>.<br><strong>Proof.</strong> 单独讨论 <span class="math inline">\(n=2\)</span> 情况, 即可设 <span class="math inline">\(n&gt;2\)</span>, 此时可利用 <strong>LEMMA 2</strong> 进行证明.</p></blockquote><p>由于 <span class="math inline">\(o_r(n)&gt;1\)</span>, 故存在 <span class="math inline">\(n\)</span> 的素因子 <span class="math inline">\(p\)</span>, s.t. <span class="math inline">\(o_r(p)&gt;1\)</span> (否则容易得到 <span class="math inline">\(o_r(n)=1\)</span>, 矛盾). 进一步应有 <span class="math inline">\(p&gt;r\)</span>, 否则在 <code>Step 3</code> 和 <code>Step 4</code> 就已经判断了 <span class="math inline">\(n\)</span> 的素性. 又由于 <span class="math inline">\((n,r)=1\)</span>(否则在 <code>Step 3</code> 和 <code>Step 4</code> 会判定 <span class="math inline">\(n\)</span> 素性), 故 <span class="math inline">\(p,n\in\mathbb{Z}_r^*\)</span>. <span class="math inline">\(p\)</span> 和 <span class="math inline">\(r\)</span> 在后文中将被固定, 再令 <span class="math inline">\(l=\lfloor\sqrt{\phi(r)}\log n\rfloor\)</span>.</p><p>由于算法执行到了 <code>Step 6</code>, 故在 <code>Step 5</code> 没有返回 <code>COMPOSITE</code>. 即: <span class="math display">\[(x+a)^n=x^n+a~({\rm mod}~x^r-1,n)\quad\forall a,0\leqslant a\leqslant l.\]</span> 于是 <span class="math display">\[(x+a)^n=x^n+a~({\rm mod}~x^r-1,p)\quad\forall a,0\leqslant a\leqslant l.\]</span> 由以上两式可得: <span class="math display">\[(x+a)^\frac{n}{p}=x^\frac{n}{p}+a~({\rm mod}~x^r-1,p)\quad\forall a,0\leqslant a\leqslant l.\]</span> 结合 <strong>LEMMA 1</strong>, 此时的 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(\frac{n}{p}\)</span> 都满足 <strong>LEMMA 1</strong> 的条件, 将该性质定义如下:</p><blockquote><p><strong>DEFINITION 1.</strong> 对于多项式 <span class="math inline">\(f(x)\)</span> 和 <span class="math inline">\(m\in\mathbb{N}\)</span>, 称 <span class="math inline">\(m\)</span> 是instropective的, 如果 <span class="math display">\[[f(x)]^m=f(x^m)~({\rm mod}~x^r-1,p).\]</span></p></blockquote><p>很容易证明instropective有如下性质:</p><blockquote><p><strong>LEMMA 5.</strong> 若 <span class="math inline">\(m\)</span> 和 <span class="math inline">\(m&#39;\)</span> 对 <span class="math inline">\(f(x)\)</span> 都是instropective的, 则 <span class="math inline">\(m\cdot m&#39;\)</span> 对 <span class="math inline">\(f(x)\)</span> 也是instropective的.</p></blockquote><blockquote><p><strong>LEMMA 6.</strong> 若 <span class="math inline">\(m\)</span> 对 <span class="math inline">\(f(x)\)</span> 和 <span class="math inline">\(g(x)\)</span> 都是instropective的, 则 <span class="math inline">\(m\)</span> 对 <span class="math inline">\(f(x)\cdot g(x)\)</span> 也是instropective的.</p></blockquote><p>于是可以得到如下事实:</p><ul><li>由前文的三个等式可知 <span class="math inline">\(\frac{n}{p}\)</span> 和 <span class="math inline">\(p\)</span> 对 <span class="math inline">\(x+a\)</span> 是instropective的, <span class="math inline">\(\forall 0\leqslant a\leqslant l\)</span>.</li><li>进一步, 集合 <span class="math inline">\(I=\{(\frac{n}{p})^i\cdot p^j~\vert~ i,j&gt;0\}\)</span> 中的每个数对集合 <span class="math inline">\(P=\{\prod\limits_{a=0}^l(x+a)^{e_a}~\vert~ e_a\geqslant 0\}\)</span> 中的每个多项式都是introspective的.</li></ul><p>进一步可在上述集合的基础上如下定义两个群:</p><ul><li><span class="math inline">\(G\)</span>: <span class="math inline">\(I\)</span> 中所有的数模 <span class="math inline">\(r\)</span> 的余数构成一个群. 设 <span class="math inline">\(\vert G\vert=t\)</span>.<ol style="list-style-type: decimal"><li>显然 <span class="math inline">\(G\subset \mathbb{Z}_r^*\)</span>(生成元都在 <span class="math inline">\(\mathbb{Z}_r^*\)</span> 中).</li><li>由 <span class="math inline">\(o_r(n)&gt;\log^2n\)</span> 可知, <span class="math inline">\(t&gt;\log^2n\)</span>.</li></ol></li><li><span class="math inline">\(\mathcal{G}\)</span>: 由 <span class="math inline">\(x,x+1,\cdots,x+l\)</span> 在域 <span class="math inline">\(F=F_p[x]/\langle h(x)\rangle\)</span> 中生成的群.<ol style="list-style-type: decimal"><li>显然 <span class="math inline">\(\mathcal{G}\)</span> 是 <span class="math inline">\(F\)</span> 乘法群的子群.</li><li><span class="math inline">\(P\)</span> 中所有多项式在模 <span class="math inline">\(h(x)\)</span> 和 <span class="math inline">\(p\)</span> 的意义下关于乘法构成一个群.</li></ol></li></ul><p><span class="math inline">\(\vert\mathcal{G}\vert\)</span> 的范围由如下引理给出(证明细节见后文):</p><blockquote><p><strong>LEMMA 7.</strong> <strong>下界:</strong> (Hendrik Lenstra Jr.) <span class="math inline">\(\vert\mathcal{G}\vert\geqslant\binom{t+l}{t-1}\)</span>.</p></blockquote><blockquote><p><strong>LEMMA 8.</strong> <strong>上界:</strong> 若 <span class="math inline">\(n\)</span> 不是 <span class="math inline">\(p\)</span> 的方幂, 则 <span class="math inline">\(\vert\mathcal{G}\vert\leqslant n^{\sqrt{t}}\)</span>.</p></blockquote><p>进一步即可得到最终的结果:</p><blockquote><p><strong>LEMMA 9.</strong> 若算法返回 <code>PRIME</code>, 则 <span class="math inline">\(n\)</span> 是素数.<br><strong>Proof.</strong> 由 <strong>LEMMA 7</strong>, 有: <span class="math display">\[\begin{align}\vert\mathcal{G}\vert &amp;\geqslant \binom{t+l}{t-1} &amp; \\&amp;\geqslant \binom{l+1+\lfloor\sqrt{t}\log n\rfloor}{\lfloor\sqrt{t}\log n\rfloor}&amp;\quad (由于~t&gt;\sqrt{t}\log n) \\&amp;\geqslant \binom{2\lfloor\sqrt{t}\log n\rfloor+1}{\lfloor\sqrt{t}\log n\rfloor} &amp;\quad (由于~l\geqslant \lfloor\sqrt{t}\log n\rfloor) \\&amp;\geqslant 2^{\lfloor\sqrt{t}\log n\rfloor+1} &amp;\quad (由于~\lfloor\sqrt{t}\log n\rfloor&gt;\lfloor\log^2n\rfloor\geqslant 1) \\&amp;\geqslant n^{\sqrt{t}}.\end{align}\]</span> 由 <strong>LEMMA 8</strong>, 当 <span class="math inline">\(n\)</span> 不是 <span class="math inline">\(p\)</span> 的方幂时, 有<span class="math inline">\(\vert\mathcal{G}\vert\leqslant n^\sqrt{t}\)</span>. 故 <span class="math inline">\(\exists k\)</span>, s.t. <span class="math inline">\(n=p^k\)</span>. 若 <span class="math inline">\(k&gt;1\)</span>, 则在 <code>Step 1</code> 就会返回 <code>COMPOSITE</code>. 故只有 <span class="math inline">\(k=1\)</span>, 即 <span class="math inline">\(n=p\)</span>, 即 <span class="math inline">\(n\)</span> 为素数.</p></blockquote><p><strong>至此, 算法正确性已经证明完毕.</strong> 可归纳为如下定理:</p><blockquote><p><strong>THEOREM 1.</strong> 算法返回 <code>PRIME</code> 当且仅当 <span class="math inline">\(n\)</span> 是素数.</p></blockquote><h2 id="复杂度证明">复杂度证明</h2><p>首先做如下假定:</p><ul><li><span class="math inline">\(m\)</span> 位数的四则运算耗时均为 <span class="math inline">\(O^\sim(m)\)</span>;</li><li>两个系数为 <span class="math inline">\(m\)</span> 位整数的 <span class="math inline">\(d\)</span> 次多项式的四则运算耗时为 <span class="math inline">\(O^\sim(d\cdot m)\)</span>.</li><li><span class="math inline">\(n\)</span> 的位数大致为 <span class="math inline">\(O(\log n)\)</span>.</li></ul><p>对于算法的复杂度, 我们将证明如下定理:</p><blockquote><p><strong>THEOREM 2.</strong> 算法的渐进时间复杂度为 <span class="math inline">\(O^\sim(\log^{\frac{21}{2}}n)\)</span>.<br><strong>Proof.</strong> 按照算法步骤逐个讨论:<br>　　<code>Step 1</code>: 判断是否整数的幂.<br>　　　　　　时间复杂度 <span class="math inline">\(O^\sim(\log^3n)\)</span>, 参见 Mordern Computer Algebra. Cambridge Univ.;<br>　　<code>Step 2</code>: 求一个 <span class="math inline">\(r\)</span>, s.t. <span class="math inline">\(o_r(n)&gt;\log^2n\)</span>.<br>　　　　　　1. 取 <span class="math inline">\(r\)</span>, s.t. <span class="math inline">\(o_r(n)&gt;\log^2n\)</span>. 只需枚举 <span class="math inline">\(k\leqslant\log^2n\)</span>, 故至多需要 <span class="math inline">\(O(\log^2n)\)</span>.<br>　　　　　　2. 取定一个 <span class="math inline">\(r\)</span> 后, 至多进行 <span class="math inline">\(O(\log^2n)\)</span> 次模 <span class="math inline">\(r\)</span> 乘法, 开销至多 <span class="math inline">\(O^\sim(\log^2n\log r)\)</span>.<br>　　　　　　3. 由 <strong>LEMMA 4</strong>, 至多需要测试 <span class="math inline">\(O(\log^5n)\)</span> 个不同的 <span class="math inline">\(r\)</span>.<br>　　　　　　综上, <code>Step 2</code> 复杂度至多 <span class="math inline">\(O^\sim(\log^7n)\)</span>.<br>　　<code>Step 3</code>: 需要求 <span class="math inline">\(r\)</span> 次gcd.<br>　　　　　　1. 每次 gcd 的开销为 <span class="math inline">\(O(\log n)\)</span>.<br>　　　　　　2. <span class="math inline">\(r\)</span> 的开销为 <span class="math inline">\(O(\log^5n)\)</span>.<br>　　　　　　综上, <code>Step 3</code> 的复杂度为 <span class="math inline">\(O(r\log n)=O(\log^6n)\)</span>.<br>　　<code>Step 4</code>: 只需要比较 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(r\)</span> 大小.<br>　　　　　　时间复杂度 <span class="math inline">\(O(\log n)\)</span>.<br>　　<code>Step 5</code>: 验证 <span class="math inline">\(\lfloor\sqrt{\phi(r)}\log n\rfloor\)</span> 个多项式等式.<br>　　　　　　1. 每个等式次数都是 <span class="math inline">\(r\)</span>, 故单次验证的开销为 <span class="math inline">\(O^\sim(r\log^2 n)\)</span>.<br>　　　　　　2. 总复杂度为 <span class="math inline">\(O^\sim(r\sqrt{\phi(r)}\log^3n)\)</span>.<br>　　　　　　综上, <code>Step 5</code> 的复杂度为 <span class="math inline">\(O^\sim(r\sqrt{\phi(r)}\log^3n)=O^\sim(r^\frac{3}{2}\log^3n)=O^\sim(\log^\frac{21}{2}n)\)</span>.<br>　　<code>Step 6</code>: 这步啥也没干, 就返回了一个 <code>PRIME</code>.<br>　　　　　　时间复杂度 <span class="math inline">\(O(1)\)</span>.<br>　　<strong>综上, 算法的时间复杂度为 <span class="math inline">\(O(\log^\frac{21}{2}n)\)</span>.</strong></p></blockquote><p><strong>至此, 算法复杂度证明完毕.</strong></p><ul><li>貌似还有一些改进, 有点麻烦, 以后再说.</li></ul><h2 id="一些引理的证明细节">一些引理的证明细节</h2><blockquote><p><strong>LEMMA 1 Proof.</strong> <span class="math inline">\(\forall 0&lt;i&lt;n\)</span>, <span class="math inline">\(x^i\)</span> 在 <span class="math inline">\(((x+a)^n-(x^n+a))\)</span> 中的系数为 <span class="math inline">\(\binom{n}{i}a^{n-i}\)</span>.<br>- 若 <span class="math inline">\(n\)</span> 为素数, 则 <span class="math inline">\(\binom{n}{i}=0~({\rm mod~n})\)</span>, 故 <span class="math inline">\(\forall 0&lt;i&lt;n\)</span>, <span class="math inline">\(x^i\)</span> 系数均为 <span class="math inline">\(0\)</span>, 即原式成立.<br>- 若 <span class="math inline">\(n\)</span> 为合数, 取 <span class="math inline">\(q~\vert~n\)</span>, 且 <span class="math inline">\(q^k~||~n\)</span>. 则 <span class="math inline">\(q^k\)</span> 不能整除 <span class="math inline">\(\binom{n}{q}\)</span>, 且 <span class="math inline">\((q,a^{n-q})=1\)</span>. 故 <span class="math inline">\(x^q\)</span> 系数不为 <span class="math inline">\(0\)</span>. 故原式不成立.<br><strong>综上, 原式成立当且仅当 <span class="math inline">\(n\)</span> 是素数.</strong></p></blockquote><blockquote><p><strong>LEMMA 2 Proof.</strong> 考虑积分 <span class="math display">\[I(m,n)=\int_0^1 x^{m-1}(1-x)^{n-m}{\rm d}x\quad (1\leqslant m\leqslant n).\]</span> 一方面, 由 <span class="math inline">\((1-x)^{n-m}\)</span> 的展式可知 <span class="math inline">\(I(m,n)\)</span> 是分母整除 <span class="math inline">\({\rm LCM}(n)\)</span> 的有理数: <span class="math display">\[I(m,n)=\sum\limits_{0\leqslant j\leqslant n-m}(-1)^j\binom{n-m}{j}\frac{1}{m+j}\in\frac{1}{d_n}\mathbb{Z}.\]</span> 另一方面, 注意到 <span class="math inline">\(\forall 0\leqslant y\leqslant 1\)</span>, 有 <span class="math display">\[\sum\limits_{1\leqslant m\leqslant n}\binom{n-1}{m-1}y^{m-1}I(m,n)=\int_0^1(1-x+xy)^{n-1}{\rm d}x=\frac{1}{n}\sum\limits_{1\leqslant m\leqslant n}y^{m-1}.\]</span> 从而 <span class="math display">\[I(m,n)=\frac{1}{n}\binom{n-1}{m-1}=\frac{1}{m}\binom{n}{m}\quad (1\leqslant m\leqslant n).\]</span> 这说明对 <span class="math inline">\(1\leqslant m\leqslant n\)</span>, 有 <span class="math inline">\(m\binom{n}{m}~\vert~d_n\)</span>. 于是有 <span class="math display">\[\left.\left.n\binom{2n}{n}~\right|~{\rm LCM}(2n)~\right|~{\rm LCM}(2n+1)~~且~~\left.(n+1)\binom{2n+1}{n}=(2n+1)\binom{2n}{n}~\right|~{\rm LCM}(2n+1).\]</span> 由于 <span class="math inline">\((n,2n+1)=1\)</span>, 故 <span class="math display">\[\left.n(2n+1)\binom{2n}{n}~\right|~{\rm LCM}(2n+1).\]</span> 由于 <span class="math inline">\(\binom{2n}{n}\)</span> 是 <span class="math inline">\((1+x)^{2n}\)</span> 系数中最大的一项, 故 <span class="math display">\[{\rm LCM}(2n+1)\geqslant n4^n\quad (n\geqslant 1).\]</span> 从而 <span class="math display">\[{\rm LCM}(2n+1)\geqslant 2\cdot 4^n=2^{2n+1}\quad (n\geqslant 2).\]</span> 且 <span class="math display">\[{\rm LCM}(2n+2)\geqslant {\rm LCM}(2n+1)\geqslant 4^{n+1}\quad (n\geqslant 4).\]</span> 以上已经证明了对于 <span class="math inline">\(n\geqslant 9\)</span> 有 <span class="math inline">\({\rm LCM}(n)\geqslant 2^n\)</span>. 经验证 <span class="math inline">\(n=7,8\)</span> 也成立, <strong>于是原式对 <span class="math inline">\(\forall n\geqslant 7\)</span> 成立.</strong></p></blockquote><blockquote><p><strong>LEMMA 4 Proof.</strong> 当 <span class="math inline">\(n=2\)</span> 时, 取 <span class="math inline">\(r=3\)</span> 即可. 故以下假设 <span class="math inline">\(n&gt;2\)</span>, 即有 <span class="math inline">\(\lceil\log^5n\rceil&gt;10\)</span> 且 <strong>LEMMA 2</strong> 适用.<br><strong>先证存在 <span class="math inline">\(r\leqslant m\)</span>, s.t. <span class="math inline">\(r\not| N\)</span>, 其中 <span class="math display">\[N=n^{\lfloor \log m\rfloor}\cdot\prod\limits_{i=1}^{\lfloor\log^2n\rfloor}(n^i-1).\]</span></strong> 假设 <span class="math inline">\(r~\vert~N\)</span>, <span class="math inline">\(\forall 1\leqslant r\leqslant m\)</span>, 则有 <span class="math inline">\({\rm LCM}(m)\leqslant N\)</span>. 注意到 <span class="math display">\[\begin{align}N &amp;= n^{\lfloor \log m\rfloor}\cdot\prod\limits_{i=1}^{\lfloor\log^2n\rfloor}(n^i-1) \\&amp;&lt; n^{\lfloor \log m\rfloor}\cdot\prod\limits_{i=1}^{\lfloor\log^2n\rfloor}n^i \\&amp;= n^{\lfloor\log m\rfloor+1+2+\cdots+\log^2n} \\&amp;= n^{\lfloor\log m\rfloor+\frac{1}{2}[\log^2n(\log^2n+1)]} \\&amp;= n^{\lfloor\log m\rfloor+\frac{1}{2}[\log^4n+\log^2n]} \\&amp;&lt; n^{\log^4n} \\&amp;= (2^{\log n})^{\log^4n} \\&amp;= 2^{\log^5n} \leqslant 2^m.\end{align}\]</span> 故 <span class="math inline">\(N&lt;2^m\)</span>, 这与 <span class="math inline">\({\rm LCM}(m)\geqslant 2^m\)</span> 矛盾. 故集合 <span class="math inline">\(\{r~|~1\leqslant r\leqslant m,~r\not| N\}\)</span> 非空. <strong>设 <span class="math inline">\(r\)</span> 为其中的最小值.</strong><br><strong>至此我们已经找到了 <span class="math inline">\(r\leqslant m\)</span>, 以下只需证明 <span class="math inline">\(o_r(n)\)</span> 存在, 且 <span class="math inline">\(o_r(n)&gt;\log^2n\)</span>.</strong> 由于 <span class="math inline">\(o_r(n)\)</span> 存在当且仅当 <span class="math inline">\((r,n)=1\)</span>, 故只需证明 <span class="math inline">\(r\)</span> 与 <span class="math inline">\(n\)</span> 互素. 设 <span class="math inline">\(r=ab\)</span>, 其中 <span class="math inline">\(a\)</span> 由 <span class="math inline">\((n,r)\)</span> 的所有素因子组成, <span class="math inline">\(b\)</span> 由其他素因子组成, 即 <span class="math inline">\((a,b)=1\)</span>. 显然有 <span class="math inline">\((b,n)=1\)</span>.<br>注意到 <span class="math inline">\(a\)</span> 的任意素因子在 <span class="math inline">\(a\)</span> 中的最高幂次都不会超过 <span class="math inline">\(\lfloor\log m\rfloor\)</span>, 否则 <span class="math inline">\(a\leqslant r\)</span> 会超过 <span class="math inline">\(m\)</span>. 故 <span class="math inline">\(a\)</span> 的任意素因子在 <span class="math inline">\(a\)</span> 中的幂次都不超过在 <span class="math inline">\(n^{\lfloor\log m\rfloor}\)</span> 中的幂次, 故 <span class="math inline">\(a~|~n^{\lfloor\log m\rfloor}\)</span>.<br>另一方面, 有 <span class="math inline">\(b\not|n^{\lfloor \log m\rfloor}\cdot\prod\limits_{i=1}^{\lfloor\log^2n\rfloor}(n^i-1)\)</span> 且由 <span class="math inline">\((b,n)=1\)</span> 可知 <span class="math inline">\(b\not| n^{\lfloor\log m\rfloor}\)</span>. 故 <span class="math inline">\(b\not| N\)</span>. 然而由 <span class="math inline">\(r\)</span> 的定义可知, <span class="math inline">\(r\leqslant b\)</span>, 于是有 <span class="math inline">\(r=b\)</span>. 故 <span class="math inline">\((r,n)=1\)</span>, 故 <span class="math inline">\(o_r(n)\)</span> 存在.<br><strong>最后证明 <span class="math inline">\(o_r(n)&gt;\log^2n\)</span>:</strong> 假设 <span class="math inline">\(d=o_r(n)\leqslant\log^2n\)</span>, 则由定义有 <span class="math inline">\(n^d=1~({\rm mod}~r)\)</span>, 即 <span class="math inline">\(n^d-1=0~({\rm mod}~r)\)</span>, 故 <span class="math inline">\(n~|~(n^d-1)\)</span>. 即 <span class="math inline">\(r\)</span> 整除 <span class="math inline">\(N\)</span> 的一个因子 <span class="math inline">\(n^d-1\)</span>, 因而 <span class="math inline">\(r~|~N\)</span>, 矛盾! 于是有 <span class="math inline">\(o_r(n)&gt;\log^2n\)</span>.<br><strong>至此, 引理得证.</strong> <!-- 令 $r_1,\cdots,r_t$ 为所有满足 $o_{r_i}(n)\leqslant\log^2n$ 或 $r_i~\vert~n$ 的数. 则有$$r_i~\left|~\prod\limits_{i=1}^{\lfloor\log^2n\rfloor}(n^i-1)\right.<n^{\log^4n}\leqslant 2^{\log^5n}\quad \forall i.$$由 **LEMMA 2**, 有$${\rm LCM}(\lceil\log^5n\rceil)\geqslant 2^{\lceil\log^5n\rceil},$$故 $\exists s\leqslant\lceil\log^5n\rceil$, s.t. $s\notin\{r_1,\cdots,r_t\}$.  - 若 $(s,n)=1$, 则 $o_s(n)>\log^2n$, 引理得证.  - 若 $(s,n)>1$, 则由 $s\nmid n$ 且 $(s,n)\in\{r_1,\cdots,r_t\}$, 可知 $r=\frac{s}{(s,n)}\notin\{r_1,\cdots,r_t\}$. 故 $o_r(n)>\log^2n$.  **综上, 命题成立.** --></p></blockquote><blockquote><p><strong>LEMMA 7 Proof.</strong> 注意到 <span class="math inline">\(h(x)\)</span> 是 <span class="math inline">\(r\)</span> 次分圆多项式 <span class="math inline">\(Q_r(x)\)</span> 的一个因式, <span class="math inline">\(x\)</span> 为 <span class="math inline">\(F\)</span> 上的 <span class="math inline">\(r\)</span> 次本原单位根. 以下证明: <span class="math inline">\(P\)</span> 中任意两个不同的次数不超过 <span class="math inline">\(t\)</span> 的多项式在 <span class="math inline">\(\mathcal{G}\)</span> 中会对应到不同的元素.<br>设 <span class="math inline">\(f(x),g(x)\in P\)</span> 是这样的两个多项式. 假设 <span class="math inline">\(f(x)=g(x)\)</span> 在 <span class="math inline">\(F\)</span> 上成立. 取 <span class="math inline">\(m\in I\)</span>, 则在 <span class="math inline">\(F\)</span> 中有 <span class="math inline">\([f(x)]^m=[g(x)]^m\)</span>. 由于 <span class="math inline">\(m\)</span> 对 <span class="math inline">\(f\)</span> 和 <span class="math inline">\(g\)</span> 都是introspective的, 且 <span class="math inline">\(h(x)~\vert~x^r-1\)</span>, 故 <span class="math display">\[f(x^m)=g(x^m)\quad\text{in}~F.\]</span> 这说明 <span class="math inline">\(\forall m\in G\)</span>, <span class="math inline">\(x^m\)</span> 总是多项式 <span class="math inline">\(Q(y)=f(y)-g(y)\)</span> 的根. 由于 <span class="math inline">\(m\in G\subset\mathbb{Z}_r^*\)</span>, 故 <span class="math inline">\((m,r)=1\)</span>, 故每个这样的 <span class="math inline">\(x^m\)</span> 都是 <span class="math inline">\(r\)</span> 次本原单位根. 故这样得到了 <span class="math inline">\(Q(y)\)</span> 的 <span class="math inline">\(\vert G\vert=t\)</span> 个不同的根. 然而 <span class="math inline">\(Q(y)\)</span> 的次数小于 <span class="math inline">\(t\)</span>, 故根也少于 <span class="math inline">\(t\)</span> 个. 矛盾! 故在 <span class="math inline">\(F\)</span> 上有 <span class="math inline">\(f(x)\neq g(x)\)</span>.<br>注意到 <span class="math inline">\(l=\lfloor\sqrt{\phi(r)}\log n\rfloor&lt;\sqrt{r}\log n&lt;r\)</span> 且 <span class="math inline">\(p&gt;r\)</span>, 故 <span class="math inline">\(x,x+1,\cdots,x+l\)</span> 在 <span class="math inline">\(F\)</span> 中两两不等. 同时, 由 <span class="math inline">\(h(x)\)</span> 的次数大于 <span class="math inline">\(1\)</span> 可知, <span class="math inline">\(x+a\neq 0\)</span>, <span class="math inline">\(\forall 0\leqslant a\leqslant l\)</span>. 于是 <span class="math inline">\(\mathcal{G}\)</span> 中存在至少 <span class="math inline">\(l+1\)</span> 个一次多项式. <strong>故 <span class="math inline">\(\mathcal{G}\)</span> 中至少存在 <span class="math inline">\(\binom{t+l}{t-1}\)</span> 个次数小于 <span class="math inline">\(t\)</span> 的多项式.</strong></p></blockquote><blockquote><p><strong>LEMMA 8 Proof.</strong> 考虑 <span class="math inline">\(I\)</span> 的以下子集: <span class="math display">\[\hat{I}=\{(\frac{n}{p})^i\cdot p^j~\vert~0\leqslant i,j\leqslant\lfloor\sqrt{t}\rfloor\}.\]</span> 若 <span class="math inline">\(n\)</span> 不是 <span class="math inline">\(p\)</span> 的方幂, 则 <span class="math inline">\(\hat{I}\)</span> 有 <span class="math inline">\((\lfloor\sqrt{t}\rfloor+1)^2&gt;t\)</span> 个不同元素.<br>由于 <span class="math inline">\(|G|=t\)</span>, 故由抽屉原理可知 <span class="math inline">\(\hat{I}\)</span> 中至少存在 <span class="math inline">\(2\)</span> 个元素模 <span class="math inline">\(r\)</span> 同余. 令其为 <span class="math inline">\(m_1,m_2\)</span>, 不妨设 <span class="math inline">\(m_1&gt;m_2\)</span>. 则有: <span class="math display">\[x^{m_1}=x^{m_2}~({\rm mod}~x^r-1).\]</span> 令 <span class="math inline">\(f(x)\in P\)</span>, 则 <span class="math display">\[\begin{align}[f(x)]^{m_1} &amp;= f(x^{m_1})~({\rm mod}~x^r-1,p) \\&amp;= f(x^{m_2})~({\rm mod}~x^r-1,p) \\&amp;= [f(x)]^{m_2}~({\rm mod}~x^r-1,p).\end{align}\]</span> 即在 <span class="math inline">\(F\)</span> 上有 <span class="math inline">\([f(x)]^{m_1}=[f(x)]^{m_2}\)</span>. 于是 <span class="math inline">\(f(x)\in\mathcal{G}\)</span> 是多项式 <span class="math inline">\(Q&#39;(y)=y^{m_1}-y^{m_2}\)</span> 在 <span class="math inline">\(F\)</span> 中的一个根. 由于 <span class="math inline">\(f(x)\)</span> 是 <span class="math inline">\(\mathcal{G}\)</span> 中的任意一个元素, 故 <span class="math inline">\(Q&#39;(y)\)</span> 在 <span class="math inline">\(F\)</span> 中至少有 <span class="math inline">\(|\mathcal{G}|\)</span> 个不同的根. 而 <span class="math display">\[{\rm deg}~Q&#39;(y)=m_1\leqslant (\frac{n}{p}\cdot p)^{\lfloor\sqrt{t}\rfloor}.\]</span> <strong>即 <span class="math inline">\(|\mathcal{G}|\leqslant n^{\lfloor\sqrt{t}\rfloor}.\)</span></strong></p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 计算机 </tag>
            
            <tag> 北大 </tag>
            
            <tag> 保研 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 抽象代数 </tag>
            
            <tag> 数论 </tag>
            
            <tag> 论文笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>复变函数拾遗[2]——多值函数的解析分支</title>
      <link href="/2018/04/12/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E6%8B%BE%E9%81%97-2-%E2%80%94%E2%80%94%E5%A4%9A%E5%80%BC%E5%87%BD%E6%95%B0%E7%9A%84%E8%A7%A3%E6%9E%90%E5%88%86%E6%94%AF/"/>
      <content type="html"><![CDATA[<p>大致分为两部分:</p><ul><li>多值函数解析分支的定义;</li><li>多值函数解析分支的讨论.</li></ul><a id="more"></a><h2 id="多值函数解析分支的定义">多值函数解析分支的定义</h2><h3 id="解析分支定义">解析分支定义</h3><blockquote><p><strong>DEFINITION 1.</strong> 设 <span class="math inline">\(\Omega\)</span> 为区域, <span class="math inline">\(\mathbf{F}(z)\)</span> 为 <span class="math inline">\(\Omega\)</span> 上的多值函数, 如果 <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 解析, 且对 <span class="math inline">\(\forall z\in\Omega\)</span>, 有 <span class="math inline">\(f(z)\in\mathbf{F}(z)\)</span>, 则称 <span class="math inline">\(f\)</span> 为 <span class="math inline">\(\mathbf{F}\)</span> 在 <span class="math inline">\(\Omega\)</span> 上的解析分支.</p></blockquote><h3 id="多值函数的本质">多值函数的本质</h3><p>这里的论述可能不太严格.</p><p>考虑复数的三角式: <span class="math display">\[z=\vert z\vert e^{i~{\rm arg}~z}.\]</span> 由于 <span class="math inline">\(e^{2\pi i}=1\)</span>, 故 <span class="math inline">\(\vert z\vert e^{i~{\rm arg}~z}=\vert z\vert e^{i~({\rm arg}~z+2k\pi)}\)</span>. 即 <span class="math inline">\(z\)</span> 的辐角 <span class="math inline">\(\mathbf{Arg}~z\)</span> 是一个多值函数.<br>由于辐角函数是一个多值函数, 这就导致了多值函数的存在. 多值函数的不同解析分支实际上也对应了 <span class="math inline">\(\mathbf{Arg}~z\)</span> 的不同取值.</p><h3 id="辐角函数的连续分支">辐角函数的连续分支</h3><blockquote><p><strong>PROPOSITION 1.</strong> 设 <span class="math inline">\(\Omega\)</span> 为单连通区域, <span class="math inline">\(z_0\notin\Omega\)</span>, 则 <span class="math inline">\(\mathbf{Arg}~(z-z_0)\)</span> 在区域 <span class="math inline">\(\Omega\)</span> 上有连续分支 <span class="math inline">\({\rm arg}~(z-z_0)\)</span>, 且 <span class="math inline">\(\mathbf{Arg}~(z-z_0)\)</span> 在 <span class="math inline">\(\Omega\)</span> 上的所有连续分支如下: <span class="math display">\[\mathbf{Arg}~(z-z_0)=\{ {\rm arg}~(z-z_0)+2k\pi:k\in\mathbb{Z}\}.\]</span> 于是 <span class="math inline">\(\mathbf{Arg}~(z-z_0)\)</span> 在 <span class="math inline">\(\Omega\)</span> 内有无穷多个连续分支.</p></blockquote><h2 id="几个解析分支的例子">几个解析分支的例子</h2><h3 id="对数函数的解析分支">对数函数的解析分支</h3><blockquote><p><strong>THEOREM 1.</strong> 设 <span class="math inline">\(\Omega\)</span> 为单连通区域, <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 中解析且处处不为零, 则 <span class="math inline">\(\mathbf{Ln}~f(z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 有解析分支 <span class="math inline">\(g(z)\)</span>, s.t. <span class="math display">\[e^{g(z)}=f(z),\]</span> 且 <span class="math inline">\(\mathbf{Ln}~f(z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 上所有的解析分支都具有形式 <span class="math inline">\(g(z)+2k\pi i\)</span>, 即: <span class="math display">\[\mathbf{Ln}~f(z)=\{g(z)+2k\pi i:k\in\mathbb{Z}\}.\]</span> 即 <span class="math inline">\(\mathbf{Ln}~f(z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 有无穷多个解析分支.</p></blockquote><p><strong>简略证明:</strong><br>　　从三角式的角度考虑非常显然:<br><span class="math display">\[\begin{align}{\bf Ln}~(z) &amp;= \{\ln~(\vert z\vert e^{i~({\rm arg}~z+2k\pi)})\} \\ &amp;= \{\ln~\vert z\vert+ i({\rm arg}~z+2k\pi)\} \\ &amp;= \{\ln\vert z\vert +i~{\rm arg}~z+2k\pi i:k\in\mathbb{Z}\}.\end{align}\]</span></p><h3 id="幂函数的解析分支">幂函数的解析分支</h3><h4 id="解析函数-n-次方根的解析分支">解析函数 <span class="math inline">\(n\)</span> 次方根的解析分支</h4><blockquote><p><strong>THEOREM 2.</strong> 设 <span class="math inline">\(n\geqslant 2\in\mathbb{N}\)</span>, <span class="math inline">\(\Omega\)</span> 为单连通区域, <span class="math inline">\(z_0\notin\Omega\)</span>, <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 中解析且处处不为零, 则 <span class="math inline">\((f(z))^\frac{1}{n}\)</span> 在 <span class="math inline">\(\Omega\)</span> 上有解析分支 <span class="math inline">\(g(z)\)</span>, 其所有解析分支为 <span class="math inline">\(g(z)e^{\frac{2k\pi i}{n}}\)</span>. 即: <span class="math display">\[(f(z))^\frac{1}{n}=\{g(z)e^{\frac{2k\pi i}{n}}: k=0,1,\cdots,n-1\}.\]</span> 即 <span class="math inline">\((f(z))^\frac{1}{n}\)</span> 在 <span class="math inline">\(\Omega\)</span> 有 <span class="math inline">\(n\)</span> 个解析分支.</p></blockquote><p><strong>简略证明:</strong><br>　　从三角式的角度考虑也是非常显然的. 细节略去.</p><ul><li>解析函数 <span class="math inline">\(n\)</span> 次方根的解析分支可进一步推广为幂函数的解析分支. 懒得细写了, 以后再说.</li></ul><h4 id="幂函数的解析分支-1">幂函数的解析分支</h4><p>再说吧..</p><h2 id="三角函数">三角函数</h2><h3 id="三角函数-1">三角函数</h3><p>只讨论 <span class="math inline">\(\sin\)</span> 和 <span class="math inline">\(\cos\)</span>:</p><ol style="list-style-type: decimal"><li><span class="math inline">\(2i\sin z=e^{iz}-e^{-iz}\)</span>, <span class="math inline">\(2\cos z=e^{iz}+e^{-iz}\)</span>.</li><li><span class="math inline">\(\sin\)</span>, <span class="math inline">\(\cos\)</span> 在复平面上都是解析的. 更一般地, 所有三角函数在有意义的点都是解析的.</li><li><span class="math inline">\(\sin\)</span> 和 <span class="math inline">\(\cos\)</span> 都以 <span class="math inline">\(2\pi\)</span> 为周期.</li><li><span class="math inline">\(\sin z\)</span> 的零点为 <span class="math inline">\(z=n\pi~n\in\mathbb{Z}\)</span>.</li><li><span class="math inline">\(\cos z\)</span> 的零点为 <span class="math inline">\(z=(n+\frac{1}{2})\pi~n\in\mathbb{Z}\)</span>.</li><li>大部分实数中的结论(如导数, 三角恒等式)都仍然适用.</li></ol><h3 id="双曲函数">双曲函数</h3><p>只讨论 <span class="math inline">\(\sinh z\)</span> 和 <span class="math inline">\(\cosh\)</span>:</p><ol style="list-style-type: decimal"><li><span class="math inline">\(\sinh z=\frac{e^{z}-e^{-z}}{2}\)</span>, <span class="math inline">\(\cosh z=\frac{e^{z}+e^{-z}}{2}\)</span>;</li><li>由 <span class="math inline">\(e^{z}\)</span> 的周期性, 二者都以 <span class="math inline">\(2\pi i\)</span> 为周期.</li></ol><h3 id="反三角函数">反三角函数</h3><p>反三角函数是多值函数.</p><blockquote><p><strong>DEFINITION 2.</strong> 反三角函数定义如下:<br>　　反正弦函数: <span class="math display">\[{\bf Arcsin}~z=\{w\in\mathbb{C}:\sin w=z\};\]</span> 　　反余弦函数: <span class="math display">\[{\bf Arccos}~z=\{w\in\mathbb{C}:\cos w=z\};\]</span> 　　反正切函数: <span class="math display">\[{\bf Arctan}~z=\{w\in\mathbb{C}:\tan w=z\};\]</span></p></blockquote><p>有如下表示:</p><blockquote><p><strong>PROPOSITION 2.</strong> 反三角函数有如下表示: <span class="math display">\[\begin{align}{\bf Arcsin}~z &amp;= -i{\bf Ln}(iz+(1-z^2)^\frac{1}{2}), \\{\bf Arccos}~z &amp;= -i{\bf Ln}(z+(1-z^2)^\frac{1}{2}), \\{\bf Arctan}~z &amp;= \frac{1}{2i}{\bf Ln}~\frac{1+iz}{1-iz}.\end{align}\]</span></p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 复变函数 </tag>
            
            <tag> 保研复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>复变函数拾遗[1]——Cauchy定理与最大模原理</title>
      <link href="/2018/04/11/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E6%8B%BE%E9%81%97-1-%E2%80%94%E2%80%94Cauchy%E9%AB%98%E9%98%B6%E6%B1%82%E5%AF%BC%E5%85%AC%E5%BC%8F/"/>
      <content type="html"><![CDATA[<p>解析函数的积分与Cauchy高阶求导公式.</p><a id="more"></a><h2 id="单连通情形的cauchy定理">单连通情形的Cauchy定理</h2><h3 id="goursat定理">Goursat定理</h3><blockquote><p><strong>THEOREM 1.</strong> 设 <span class="math inline">\(\Omega\)</span> 是一个单连通区域, <span class="math inline">\(f(z)\)</span> 在其中解析, 则 <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 中有原函数且对全在 <span class="math inline">\(\Omega\)</span> 中的任意Jordan闭分段光滑曲线, 都有 <span class="math display">\[\int_Cf(z){\rm d}z=0.\]</span></p></blockquote><h3 id="cauchy高阶求导公式">Cauchy高阶求导公式</h3><blockquote><p><strong>THEOREM 2.</strong> 设 <span class="math inline">\(\Omega\)</span> 是一个<strong>单连通区域</strong>, <span class="math inline">\(C\)</span> 是全在 <span class="math inline">\(\Omega\)</span> 中的闭Jordan分段光滑曲线, <span class="math inline">\(C\)</span> 所围区域是 <span class="math inline">\(\omega\)</span>. 如果 <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 内解析, 则如下Cauchy公式 <span class="math display">\[f(z_0)=\frac{1}{2\pi i}\int_C\frac{f(z){\rm d}z}{z-z_0}\quad (z_0\in\omega).\]</span> 成立, 且对 <span class="math inline">\(\forall m\in\mathbb{Z}^+\)</span>, <span class="math inline">\(f\)</span> 的 <span class="math inline">\(m\)</span> 阶复导数 <span class="math inline">\(f^{(m)}(z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 内存在并解析, 且如下Cauchy求导公式成立 <span class="math display">\[f^{(m)}(z_0)=\frac{1}{2\pi i}\int_C\frac{f(z){\rm d}z}{(z-z_0)^{m+1}}\quad (z_0\in\omega,~m\in\mathbb{Z}^+).\]</span></p></blockquote><p><strong>简略证明:</strong><br>　　只证第一式. 设 <span class="math inline">\(z_0\in\omega\)</span>, 则 <span class="math inline">\(\exists\epsilon_0&gt;-\)</span>, s.t. <span class="math inline">\(\overline{D(z_0,\epsilon_0)}\subset\omega\)</span>, 对 <span class="math inline">\(\forall\epsilon\in(0,\epsilon_0)\)</span>, <span class="math inline">\(\exists\)</span> 有向线段 <span class="math inline">\([a,b]\in\overline{\omega}\)</span>, 其中 <span class="math inline">\(a\in\partial D(z_0\epsilon_0)\)</span>, <span class="math inline">\(b\in\partial\omega\)</span>. 假设 <span class="math inline">\(b\)</span> 为 <span class="math inline">\(C\)</span> 的起点和终点, 则 <span class="math display">\[[b\to a]\to\partial D(z_0,\epsilon_0)\to[a\to b]\to[C:b\to b]\]</span> 首尾相接构成一条分段光滑曲线.</p><p>由于 <span class="math inline">\(\frac{f(z)}{z-a}\)</span> 在 <span class="math inline">\(\Omega\backslash\{z_0\}\)</span> 解析, 故 <span class="math display">\[\int_C\frac{f(z)}{z-z_0}{\rm d}z+\int_{[a,b]}\frac{f(z)}{z-z_0}{\rm d}z+\int_{[b,a]}\frac{f(z)}{z-z_0}{\rm d}z-\int_{\partial D(z_0,\epsilon_0)}\frac{f(z)}{z-z_0}{\rm d}z=0.\]</span> 从而 <span class="math display">\[\int_C \frac{f(z)}{z-z_0}{\rm d}z=\int_{\partial D(z_0,\epsilon_0)}\frac{f(z)}{z-z_0}{\rm d}z=\int_0^{2\pi} f(z_0+\epsilon e^{i\theta})i{\rm d}\theta\to 2\pi if(z_0)~~(\epsilon\to 0).\]</span> 　　第二式可由数学归纳法证得.</p><h3 id="cauchy积分定理的推广">Cauchy积分定理的推广</h3><blockquote><p><strong>THEOREM 3.</strong> 设 <span class="math inline">\(C\)</span> 为一条Jordan闭分段光滑曲线, <span class="math inline">\(\Omega={\rm int}~C\)</span>, <span class="math inline">\(f(z)\)</span> 在闭域 <span class="math inline">\(\overline{\Omega}=\Omega\cup C\)</span> 解析, 则 <span class="math display">\[\int_C f(z){\rm d}z=0.\]</span></p></blockquote><h2 id="多连通情形的cauchy定理">多连通情形的Cauchy定理</h2><h3 id="多连通情形的cauchy定理-1">多连通情形的Cauchy定理</h3><p>多连通的情况下, 仍然有如下的Cauchy定理:</p><blockquote><p><strong>THEOREM 4.</strong> 设 <span class="math inline">\(\Omega\)</span> 是由复围线(大圈 <span class="math inline">\(C_0\)</span> 挖掉 <span class="math inline">\(n\)</span> 个不相交小圈 <span class="math inline">\(C_i\)</span>) <span class="math display">\[\partial\Omega=C_0+C_1^-+\cdots+C_n^-\]</span> 所围成的有界多连通区域, <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(\overline{\Omega}\)</span> 中解析, 则 <span class="math display">\[\int_{\partial\Omega}f(z){\rm d}z=0.\]</span></p></blockquote><h3 id="多连通情形的cauchy求导公式">多连通情形的Cauchy求导公式</h3><blockquote><p><strong>THEOREM 5.</strong> 设 <span class="math inline">\(\Omega\)</span> 是由复围线(大圈 <span class="math inline">\(C_0\)</span> 挖掉 <span class="math inline">\(n\)</span> 个不相交小圈 <span class="math inline">\(C_i\)</span>) <span class="math display">\[\partial\Omega=C_0+C_1^-+\cdots+C_n^-\]</span> 所围成的有界多连通区域, <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(\overline{\Omega}\)</span> 中解析, 则 <span class="math display">\[f^{(n)}(z)=\frac{n!}{2\pi i}\int_{\partial\Omega}\frac{f(\zeta){\rm d}\zeta}{(\zeta-z)^{n+1}}\quad (z\in\Omega,~n\in\mathbb{N}).\]</span></p></blockquote><h2 id="cauchy定理的应用">Cauchy定理的应用</h2><h3 id="解析函数均值定理">解析函数均值定理</h3><blockquote><p><strong>THEOREM 6.</strong> 若函数 <span class="math inline">\(f(z)\)</span> 在圆盘 <span class="math inline">\(\vert z-z_0\vert&lt;R\)</span> 中解析, 在闭圆盘 <span class="math inline">\(\vert z-z_0\vert\leqslant R\)</span> 连续, 则 <span class="math display">\[f(z_0)=\frac{1}{2\pi}\int_0^{2\pi} f(z_0+Re^{i\theta}){\rm d}\theta.\]</span> 即在圆心 <span class="math inline">\(z_0\)</span> 的值为圆周上的平均.</p></blockquote><p><strong>简略证明:</strong><br>　　由Cauchy公式, 有 <span class="math display">\[f(z_0)=\frac{1}{2\pi i}\int_{\partial D(z_0,r)} \frac{f(z){\rm d}z}{z-z_0}.\]</span> 其中 <span class="math inline">\(0&lt;r&lt;R\)</span>, 而 <span class="math inline">\(\partial D(z_0,r)\)</span> 的方程为 <span class="math inline">\(z=z_0+re^{i\theta},~0\leqslant\theta\leqslant\pi\)</span>, 从而 <span class="math display">\[f(z_0)=\frac{1}{2\pi i}\int_0^{2\pi}\frac{f(z_0+re^{i\theta})rie^{i\theta}{\rm d}\theta}{re^{i\theta}}.\]</span> 由于 <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(\overline{D(z_0,R)}\)</span> 一致连续, 故令 <span class="math inline">\(r\to R\)</span> 即可.</p><h3 id="推论-cauchy不等式">推论: Cauchy不等式</h3><blockquote><p><strong>THEOREM 7.</strong> 设 <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 内解析, <span class="math inline">\(a\in\Omega\)</span>, 若 <span class="math inline">\(\overline{D(a,R)}=\{z:\vert z-a\vert\leqslant R\}\subset\Omega\)</span>, 则有 <span class="math display">\[\vert f^{(n)}(a)\vert\leqslant\frac{n!M(R)}{R^n}\quad (n\in\mathbb{N}),\]</span> 其中 <span class="math display">\[M(R)=\max\{\vert f(z)\vert:\vert z-a\vert=R\}.\]</span></p></blockquote><p><strong>简略证明:</strong><br>　　由<strong>TH 2.</strong> 有: <span class="math display">\[\begin{align}\vert f^{(n)}(a)\vert &amp;= \left|\frac{n!}{2\pi i}\int_{\partial D(a,R)}\frac{f(z){\rm d}z}{(z-a)^{m+1}}\right| \\ &amp;= \left| \frac{n!}{2\pi}\int_0^{2\pi}\frac{f(a+re^{i\theta}){\rm d}\theta}{r^ne^{in\theta}} \right| \\ &amp;\leqslant \frac{n!M(R)}{R^n}. \\\end{align}\]</span></p><h4 id="liouville定理">Liouville定理</h4><blockquote><p><strong>THEOREM 8.</strong> 有界整函数必定是常函数.</p></blockquote><p><strong>简略证明:</strong><br>　　设 <span class="math inline">\(f(z)\)</span> 是有界整函数, 则 <span class="math inline">\(\exists M&gt;0\)</span>, s.t. <span class="math display">\[\vert f(z)\vert\leqslant M.\]</span> 任取 <span class="math inline">\(a\in\mathbb{C}\)</span>, 则对 <span class="math inline">\(\forall R&gt;1\)</span>, 由Cauchy不等式有: <span class="math display">\[\vert f&#39;(a)\vert\leqslant\frac{M}{R^n}.\]</span> 令 <span class="math inline">\(R\to\infty\)</span>, 则 <span class="math inline">\(f&#39;(a)=0\)</span>, 从而 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(\mathbb{C}\)</span> 中为常数.</p><h3 id="最大模原理">最大模原理</h3><blockquote><p><strong>THEOREM 9.</strong> 设函数 <span class="math inline">\(f(z)\)</span> 在有界区域 <span class="math inline">\(\Omega\)</span> 解析, 并连续到边界 <span class="math inline">\(\partial\Omega\)</span> 上. 设 <span class="math inline">\(M=\max\{\vert f(z)\vert: z\in\overline{\Omega}\}\)</span>, 则在 <span class="math inline">\(\Omega\)</span> 内有 <span class="math inline">\(\vert f(z)\vert&lt;M\)</span>, 除非 <span class="math inline">\(f(z)=Me^{i\alpha}\)</span>. 此处 <span class="math inline">\(M\)</span>, <span class="math inline">\(a\)</span> 为常数.</p></blockquote><ul><li>最大模原理实际上是说: 解析函数必定在边界取最大模.</li></ul>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 复变函数 </tag>
            
            <tag> 保研复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论文笔记[1]——随机分配问题的PS算法和依次有效性</title>
      <link href="/2018/04/05/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-1-%E2%80%94%E2%80%94A%20New%20Solution%20to%20the%20Random%20Assignment%20Problem/"/>
      <content type="html"><![CDATA[<blockquote><p>文章: Bogomolnaia A, Moulin H. A New Solution to the Random Assignment Problem[J]. Journal of Economic Theory, 2001, 100(2):295-328.</p></blockquote><ul><li><span class="math inline">\(n\)</span> 个物品被分配给 <span class="math inline">\(n\)</span> 个人的问题, 称为<strong>分配问题</strong>. 生活中此类问题常采取抽签方式解决. 在此基础上可归纳出一种RP算法.</li><li>文章对已有的RP算法进行了讨论, 并提出了一种新的分配方法, PS算法.</li></ul><a id="more"></a><h2 id="分配问题">分配问题</h2><blockquote><p><strong>分配问题</strong>: <span class="math inline">\(n\)</span> 个物品被分配给 <span class="math inline">\(n\)</span> 个人的问题, 称为分配问题.</p></blockquote><p>分配中, 每个人都对这 <span class="math inline">\(n\)</span> 个东西有一个偏好顺序. 此处假定每个人的偏好关系是严格的, 即每个人对任何两个物品都有一个严格的排序.</p><h2 id="随机优先rp算法">随机优先(RP)算法</h2><blockquote><p><strong>RP</strong> <span class="math inline">\(n\)</span> 个人随机选定一个选择的顺序, 按照顺序在 <span class="math inline">\(n\)</span> 个物品中选择.</p></blockquote><p>很容易发现RP算法有以下两点好处:</p><ul><li>RP算法看起来是比较<strong>公平</strong>的;</li><li><span title="若某个人在选择中撒了谎, 则他最终获得的一定不是他所能得到的最好选择, 故撒谎没有好处.">RP算法是<strong>对策略忠诚</strong>(Strategyproofness)的, 即大家都会选择说真话.</span></li></ul><p>但用<code>VNM效用</code>函数去分析时, RP算法存在缺陷.</p><blockquote><p><strong>VNM效用</strong> 设某人得到物品 <span class="math inline">\(x_i\)</span> 的概率为 <span class="math inline">\(P_i\)</span>, 在得到 <span class="math inline">\(x_i\)</span> 时的效用为 <span class="math inline">\(u(x_i)\)</span>, 则其VNM效用为 <span class="math display">\[U(X)=\sum_i P_i u(x_i)\]</span></p></blockquote><p>分析可知:</p><ul><li><strong>在使VNM效用最大化的意义下, RP算法并不总是最优的.</strong></li></ul><p>但RP算法具有如下两个优势:</p><ol style="list-style-type: decimal"><li>事后有效 (ex post efficient): 每次分配确定的方案都是Pareto最优的. <span title="每个人都会在选择时选当前最优的物品, 若为增大某人利益而进行了一些改变, 则至少有一个人的利益会损害. (写的有点不太像人话Orz)">即增大某人利益的同时一定会损害其他人的利益.</span></li><li>算法简单: RP算法在分配时, 每一轮只需要考虑一个人的偏好.</li></ol><h2 id="概率序列ps算法">概率序列(PS)算法</h2><p>考虑一个例子:</p><blockquote><ul><li>参与者1, 2: <span class="math inline">\(a\succ b\succ c\succ d\)</span>;<br></li><li>参与者3, 4: <span class="math inline">\(b\succ a\succ d\succ c\)</span>.</li></ul></blockquote><p>则RP算法的概率矩阵为 <span class="math inline">\(A\)</span>(每行代表一个人, 每列代表一样物品). 然而考虑 <span class="math inline">\(B\)</span> 可知, 无论效用函数的形式如何, 概率矩阵 <span class="math inline">\(B\)</span> 都比RP算法得到的结果要好. <span class="math display">\[A=\begin{bmatrix}\frac{5}{12}&amp;\frac{1}{12}&amp;\frac{5}{12}&amp;\frac{1}{12}\\ \frac{5}{12}&amp;\frac{1}{12}&amp;\frac{5}{12}&amp;\frac{1}{12}\\ \frac{1}{12}&amp;\frac{5}{12}&amp;\frac{1}{12}&amp;\frac{5}{12}\\ \frac{1}{12}&amp;\frac{5}{12}&amp;\frac{1}{12}&amp;\frac{5}{12}\\ \end{bmatrix},~B=\begin{bmatrix}\frac{1}{2}&amp;0&amp;\frac{1}{2}&amp;0\\ \frac{1}{2}&amp;0&amp;\frac{1}{2}&amp;0\\ 0&amp;\frac{1}{2}&amp;0&amp;\frac{1}{2}\\ 0&amp;\frac{1}{2}&amp;0&amp;\frac{1}{2}\\ \end{bmatrix}\]</span></p><p><span class="math inline">\(B\)</span> 矩阵的获取可从如下角度考虑:</p><p>在分配中, 将每个物品都视为一种食物, 偏好关系表示对食物的喜好. 所有的人同时开始以相同速率(不妨设为1)吃东西. 每个人都会优先吃自己最喜欢的食物. 当一样食物被吃完时, 该食物即被分配给吃该食物量最多的人.</p><h2 id="ps算法的有效性">PS算法的有效性</h2><h3 id="形式化定义">形式化定义</h3><p>设参与者的集合为 <span class="math inline">\(N\)</span>, 物品集合为 <span class="math inline">\(A\)</span>, 集合大小为 <span class="math inline">\(\vert N\vert=\vert A\vert=n\)</span>.</p><h4 id="确定性分配与随机性分配">确定性分配与随机性分配</h4><ul><li>Deterministic Assignment: <span class="math inline">\(N\to A\)</span> 的一一映射, 可用 <span class="math inline">\(n\times n\)</span> 的置换矩阵表示. 记这样的分配构成的集合为 <span class="math inline">\(\mathscr{D}\)</span>;</li><li>Random Allocation: <span class="math inline">\(A\)</span> 上的概率分布, 可用各个分量和为1的 <span class="math inline">\(n\)</span> 维向量表示. 记这样的分配构成的集合为 <span class="math inline">\(\mathscr{L}(A)\)</span>;</li><li>Random Assignment: <span class="math inline">\(\mathscr{D}\)</span> 上的概率分布, 可用一个 <span class="math inline">\(n\times n\)</span> 的双随机矩阵(Bistochastic)表示. 即: <span class="math display">\[P=[p_{ia}]_{i\in N,a\in A}~~其中~~P=\sum\limits_{\Pi\in D}\lambda_\Pi\cdot\Pi,~\lambda_\Pi\geqslant 0,~\sum_\Pi\lambda_\Pi=1\]</span>矩阵的第 <span class="math inline">\(i\)</span> 行 <span class="math inline">\(P_i\)</span> 对应第 <span class="math inline">\(i\)</span> 个人的Random Allocation. <span class="math inline">\(p_{ia}\)</span> 表示 <span class="math inline">\(i\)</span> 得到物品 <span class="math inline">\(a\)</span> 的概率. 双随机矩阵构成的集合记为 <span class="math inline">\(\mathscr{R}\)</span>.</li></ul><blockquote><p><strong>双随机矩阵</strong>可定义为: 每行每列和都为 <span class="math inline">\(1\)</span> 的矩阵. 如此可得到以下结论:<br>1. 第 <span class="math inline">\(i\)</span> 行可视为编号为 <span class="math inline">\(i\)</span> 的人对于 <span class="math inline">\(A\)</span> 中物品的效用分布;<br>2. 第 <span class="math inline">\(j\)</span> 列可视为 <span class="math inline">\(N\)</span> 中的每个人得到编号为 <span class="math inline">\(j\)</span> 的物品的可能性.</p></blockquote><h4 id="效用函数与偏好关系">效用函数与偏好关系</h4><ul><li>Preference: 每个参与者对物品都存在一个严格的偏好关系, 即对应于 <span class="math inline">\(A\)</span> 上的一个序关系 <span class="math inline">\(\succ_i\)</span>. 记所有这样的偏好关系构成的集合为 <span class="math inline">\(\mathscr{A}\)</span>;</li><li>VNM Utility: 每个参与者拿到 <span class="math inline">\(A\)</span> 中的一件物品时, 产生的效用可视作 <span class="math inline">\(A\to\mathbb{R}\)</span> 的函数, 记作 <span class="math inline">\(u_i\)</span>. 效用函数实际上是偏好程度的量化.</li></ul><blockquote><p>称效用函数 <span class="math inline">\(u_i\)</span> 和偏好关系 <span class="math inline">\(\succ_i\)</span> 是<strong>相容</strong>(compatible)的, 如果 <span class="math display">\[u_i(a)&gt;u_i(b)\iff a\succ_ib,~\forall a,b\in A.\]</span></p></blockquote><h3 id="确定性分配的有效性">确定性分配的有效性</h3><ul><li>Priority Assignment: 考虑偏好关系 <span class="math inline">\(\succ=\{\succ_i\}_{i\in N}\)</span>, 设 <span class="math inline">\(\sigma\)</span> 是 <span class="math inline">\(N\)</span> 的一个排列, 则按 <span class="math inline">\(\sigma\)</span> 的顺序进行分配即可得到一个分配方案, 即Priority Assignment. 记作 <span class="math inline">\(Prio(\sigma,\succ)\)</span>;</li></ul><center><strong>以下记 <span class="math inline">\(N\)</span> 的所有排列构成的集合为 <span class="math inline">\(\theta\)</span>.</strong></center><blockquote><p>一个Deterministic Assignment <span class="math inline">\(\Pi\)</span> 称为有效的, 如果<span class="math display">\[\exists\sigma\in\theta,~ \text{s.t.}~ \Pi=Prio(\sigma,\succ).\]</span></p></blockquote><p>关于确定性分配的有效性, 很容易得到下述引理:</p><blockquote><p><strong>LEMMA 1.</strong> 给定偏好关系 <span class="math inline">\(\succ\in\mathscr{A}^N\)</span> 和确定性分配 <span class="math inline">\(\Pi\)</span>, 则下列命题等价:<br>1. <span class="math inline">\(\Pi\)</span> 在 <span class="math inline">\(\mathscr{D}\)</span> 中是Pareto最优的;<br>2. <span class="math inline">\(\forall\)</span> 效用函数组 <span class="math inline">\(u=\{u_i\}\)</span>, <span class="math inline">\(\Pi\)</span> 在 <span class="math inline">\(\mathscr{R}\)</span> 中对 <span class="math inline">\(u\)</span> 是Pareto最优的;<br>3. <span class="math inline">\(\exists\sigma\in\theta\)</span>, s.t. <span class="math inline">\(\Pi=Prio(\sigma,\succ)\)</span>.</p></blockquote><h3 id="随机性分配的有效性">随机性分配的有效性</h3><p>首先定义事前评估有效(ex ante efficient)和事后评估有效(ex post efficient):</p><blockquote><p><strong>Definition 1.</strong> 给定随机性分配 <span class="math inline">\(P\in\mathscr{R}\)</span>, 偏好关系组 <span class="math inline">\(\succ\in\mathscr{A}^N\)</span> 和VNM效用函数组 <span class="math inline">\(u\)</span>, 则有定义:<br>1. <span class="math inline">\(P\)</span> 对 <span class="math inline">\(u\)</span> 是<strong>事前评估有效</strong>的, iff <span class="math inline">\(P\)</span> 在 <span class="math inline">\(\mathscr{R}\)</span> 中对 <span class="math inline">\(u\)</span> 是Pareto最优的;<br>2. <span class="math inline">\(P\)</span> 对 <span class="math inline">\(\succ\)</span> 是<strong>事后评估有效</strong>的, iff <span class="math inline">\(P\)</span> 可被表示为有效的deterministic assignments上的概率分布, 即 <span class="math inline">\(P\)</span> 满足<span class="math display">\[P=\sum_{\sigma\in\theta}\mu_\sigma\cdot Prio(\sigma,\succ),~~~\mu_\sigma\geqslant 0,~\sum_{\sigma\in\theta}\mu_\sigma=1.\]</span></p></blockquote><p>根据上式可知, 所有<strong>事后评估有效</strong>的分配方案存在一个<strong>中心点</strong>(natural central point). 这个中心点就是<strong>随机优先分配</strong>(Random Priority), 即 <span class="math display">\[RP(\succ)=\frac{1}{n!}\sum_{\sigma\in\theta}Prio(\sigma,\succ).\]</span></p><h4 id="随机占优关系">随机占优关系</h4><p>考虑 <span class="math inline">\(A\)</span> 上的序关系 <span class="math inline">\(\succ_i\)</span>, 假设 <span class="math inline">\(a_1\succ_ia_2\succ_i\cdots\succ_ia_n\)</span>.</p><blockquote><p>可如下定义 <span class="math inline">\(\mathscr{L}(A)\)</span> 上的一个偏序关系 <span class="math inline">\(sd(\succ_i)\)</span>: <span class="math display">\[P_i~sd(\succ_i)~Q_i\iff\left\{\sum\limits_{k=1}^tp_{ia_k}\geqslant\sum\limits_{k=1}^tq_{ia_k},~\forall t=1,\cdots,n\right\},~P_i,Q_i\in\mathscr{L}(A).\]</span> 该偏序关系称作<strong>随机占优</strong>(stochastic dominance).</p></blockquote><p>关于随机占优, 容易得到如下结论:</p><blockquote><p><span class="math inline">\(\forall P_i,Q_i\in\mathscr{L}(A)\)</span>, <span class="math inline">\(P_i~sd(\succ_i)~Q_i\)</span> iff <span class="math inline">\(\forall\)</span> 与 <span class="math inline">\(\succ_i\)</span> 相容的 <span class="math inline">\(u_i\)</span>, 总有 <span class="math display">\[u_i\cdot P_i\geqslant u_i\cdot Q_i.\]</span></p></blockquote><p>进一步可以将随机占优关系推到 <span class="math inline">\(\mathscr{R}\)</span> 上:</p><blockquote><p><strong>DEFINITION 2.</strong> 给定偏好 <span class="math inline">\(\succ\)</span>, <span class="math inline">\(P,Q\in\mathscr{R}\)</span>, 称 <span class="math inline">\(Q\)</span> 随机占优于 <span class="math inline">\(P\)</span>(<span class="math inline">\(P\)</span> is stochastically dominated by <span class="math inline">\(Q\)</span>), 如果 <span class="math display">\[Q_i~sd(\succ_i)~P_i,~\forall i~且~Q\neq P\]</span></p></blockquote><h4 id="依次有效性">依次有效性</h4><blockquote><p>给定偏好关系 <span class="math inline">\(\succ\)</span>, 称 <span class="math inline">\(P\in\mathscr{R}\)</span> 是<strong>依次有效</strong>的, 如果不存在 <span class="math inline">\(Q\in\mathscr{R}\)</span>, s.t. <span class="math inline">\(Q\)</span> 随机占优于 <span class="math inline">\(P\)</span>.</p></blockquote><p>依次有效性与事前/事后评估有如下关系:</p><blockquote><p><strong>LEMMA 2.</strong> 给定一个Random Assignment <span class="math inline">\(P\in\mathscr{R}\)</span>, 一个偏好关系 <span class="math inline">\(\succ\)</span>, 和一组与 <span class="math inline">\(\succ\)</span> 相容的效用函数 <span class="math inline">\(u\)</span>, 则有:<br>1. 若 <span class="math inline">\(P\)</span> 对 <span class="math inline">\(u\)</span> 是<strong>事前评估有效</strong>的, 则 <span class="math inline">\(P\)</span> 对 <span class="math inline">\(\succ\)</span> 是<strong>依次有效</strong>的. <em>(逆命题在 <span class="math inline">\(n=2\)</span> 时成立, <span class="math inline">\(n\geqslant 3\)</span> 时可能失效)</em>;<br>2. 若 <span class="math inline">\(P\)</span> 对 <span class="math inline">\(\succ\)</span> 是<strong>依次有效</strong>的, 则 <span class="math inline">\(P\)</span> 对 <span class="math inline">\(\succ\)</span> 是<strong>事后评估有效</strong>的. <em>(逆命题在 <span class="math inline">\(n\leqslant 3\)</span> 时成立, <span class="math inline">\(n\geqslant 4\)</span> 时可能失效)</em>.</p></blockquote><h2 id="进食算法">进食算法</h2><p>在PS算法处已经实际上介绍了进食算法:</p><blockquote><p><strong>SIMULTANEOUS EATING ALGORITHM</strong><br>　　给定偏好关系 <span class="math inline">\(\succ\)</span> 和一组函数 <span class="math inline">\(\{\omega_i(t)\}_{i\in N}\)</span>, s.t. <span class="math inline">\(\omega_i(t)\geqslant 0\)</span>, 且 <span class="math inline">\(\int_0^1\omega_i(t){\rm d}t=1\)</span>, 表示进食的速度.<br>　　所有的人按照自己的偏好关系开始进食, 并且在每个时刻, 每个参与者都吃自己当前最想吃并且有剩余的物品.</p></blockquote><h3 id="进食算法的依次有效性">进食算法的依次有效性</h3><h4 id="依次有效的条件">依次有效的条件</h4><p>在 <span class="math inline">\(\mathscr{R}\)</span> 上可如下定义一个二元关系 <span class="math inline">\(\tau\)</span>:</p><blockquote><p><strong>DEFINITION 2.</strong> 给定一个 Random Assignment <span class="math inline">\(P\in\mathscr{R}\)</span> 和偏好关系 <span class="math inline">\(\succ\)</span>, 如下定义 <span class="math inline">\(\tau\)</span>: <span class="math display">\[a\tau(P,\succ)b\iff \exists i\in N,~s.t.~a\succ_ib,~p_{ib}&gt;0.\]</span></p></blockquote><ul><li><span class="math inline">\(a\tau b\)</span> 其实表示的是: 存在一个 <span class="math inline">\(i\)</span>, 比起 <span class="math inline">\(b\)</span> 更喜欢 <span class="math inline">\(a\)</span>, 但有可能会得到 <span class="math inline">\(b\)</span>.</li></ul><p>根据二元关系 <span class="math inline">\(\tau\)</span> 可得到依次有效的等价条件:</p><blockquote><p><strong>LEMMA 3.</strong> 一个Random Assignment <span class="math inline">\(P\in\mathscr{R}\)</span> 是依次有效的, iff <span class="math inline">\(\tau(P,\succ)\)</span> 无环(acyclic).</p></blockquote><p>其证明并不困难:</p><ul><li>充分性: 假设有一个环, 沿着环转一圈即可得到一个随机占优于 <span class="math inline">\(P\)</span> 的Assignment.</li><li>必要性: 假设存在 <span class="math inline">\(Q\)</span> 随机占优于 <span class="math inline">\(P\)</span>, 则可直接得到一个 <span class="math inline">\(\tau\)</span> 的环.</li></ul><h4 id="进食算法的依次有效性-1">进食算法的依次有效性</h4><blockquote><p>进食算法是依次有效的.</p></blockquote><p>其证明也很简单, 直接利用引理 1即可.</p><p>假设进食算法不是依次有效的, 则 <span class="math inline">\(\tau\)</span> 存在环: <span class="math display">\[a_0\tau a_1\tau\cdots \tau a_k\tau a_0.\]</span> 于是按照算法, 有如下命题:</p><ul><li><span class="math inline">\(i_0\)</span> 开始吃 <span class="math inline">\(a_1\)</span> 的时候, <span class="math inline">\(a_0\)</span> 已经被吃完, 故 <span class="math inline">\(a_0\)</span> 比 <span class="math inline">\(a_1\)</span> 更早被开始吃;</li><li><span class="math inline">\(i_1\)</span> 开始吃 <span class="math inline">\(a_2\)</span> 的时候, <span class="math inline">\(a_1\)</span> 已经被吃完, 故 <span class="math inline">\(a_1\)</span> 比 <span class="math inline">\(a_2\)</span> 更早被开始吃;</li><li><span class="math inline">\(\cdots\cdots\)</span></li><li><span class="math inline">\(i_k\)</span> 开始吃 <span class="math inline">\(a_0\)</span> 的时候, <span class="math inline">\(a_k\)</span> 已经被吃完, 故 <span class="math inline">\(a_k\)</span> 比 <span class="math inline">\(a_0\)</span> 更早被开始吃.</li></ul><p>这显然是一个矛盾.</p><p>进食算法的有效性由下列定理给出:</p><blockquote><p><strong>THEOREM 1.</strong> 给定偏好关系 <span class="math inline">\(\succ\in\mathscr{A}^N\)</span>, 对于任一组进食速率函数 <span class="math inline">\(\omega=\{\omega_i\}_{i\in N}\)</span>, Random Assignment <span class="math inline">\(P_\omega(\succ)\)</span> <strong>总是依次有效的</strong>.<br>　　反过来, 对于任一个对 <span class="math inline">\(\succ\)</span> 依次有效的Random Assignment <span class="math inline">\(P\)</span>, 存在一组进食速率函数 <span class="math inline">\(\omega=\{\omega_i\}_{i\in N}\)</span>, s.t. <span class="math inline">\(P=P_\omega(\succ)\)</span>.</p></blockquote><h3 id="ps算法">PS算法</h3><p>至此我们可以严格地定义PS算法:</p><blockquote><p><strong>DEFINITION 4.</strong> 满足 <span class="math inline">\(\omega_i(t)\equiv 1,~\forall t\in[0,1],~\forall i\in N\)</span> 的进食算法即为PS算法. 记作 <span class="math inline">\(PS(\succ)\)</span>.</p></blockquote><p>PS算法有如下两条性质:</p><ol class="example" style="list-style-type: decimal"><li>PS算法是依次有效的, 由定理1即得;</li><li>PS算法是匿名的, 即对于 <span class="math inline">\(n\)</span> 个人的身份对称.</li></ol><p>关于以上的(2), 有如下引理:</p><blockquote><p><strong>LEMMA 4.</strong> 给定一组进食速率函数 <span class="math inline">\(\omega=(\omega_1,\cdots,\omega_n)\)</span>, <span class="math inline">\(P\)</span> 是由 <span class="math inline">\(\omega\)</span> 生成的分配机制(mechanism). 则 <span class="math inline">\(P\)</span> 是匿名的当且仅当 <span class="math inline">\(P\)</span> 是PS算法.</p></blockquote><h2 id="rp算法与ps算法的比较">RP算法与PS算法的比较</h2><p>略去文中的例子, 直接不加证明地给出文中的结论:</p><h3 id="无嫉妒性">无嫉妒性</h3><p>无嫉妒性(envy-free)定义如下:</p><blockquote><strong>DEFINITION 4.</strong> 称Random Assignment <span class="math inline">\(P\in\mathscr{R}\)</span> 是无嫉妒/弱无嫉妒(envy-free/weak envy-free)的, 当且仅当对 <span class="math inline">\(\forall i,j\in N\)</span>, 总有:<br><table><tr><td>无嫉妒</td><td><span class="math inline">\(P_i~sd(\succ_i)~P_j\)</span></td></tr><tr><td>弱无嫉妒</td><td><span class="math inline">\(P_j~sd(\succ_i)~P_j\Rightarrow P_i=P_j\)</span></td></tr></table></blockquote><h3 id="策略忠诚性">策略忠诚性</h3><p>策略忠诚性(strategyproofness)定义如下:</p><blockquote><strong>DEFINITION 5.</strong> 称一个分配机制 <span class="math inline">\(P(\cdot)\)</span> 是策略忠诚/弱策略忠诚(strategyproofness/weak strategyproofness)的, 当且仅当对 <span class="math inline">\(\forall i,j\in N\)</span>, 总有:<br><table><tr><td>策略忠诚</td><td><span class="math inline">\(P_i(\succ)~sd(\succ_i)~P_i(\succ\vert^i\succ_i^*)\)</span></td></tr><tr><td>弱策略忠诚</td><td><span class="math inline">\(P_i(\succ\vert^i\succ_i^*)~sd(\succ_i)~P_i(\succ)\Rightarrow P_i(\succ)=P_i(\succ\vert^i\succ_i^*)\)</span></td></tr></table></blockquote><h3 id="ps与rp的比较">PS与RP的比较</h3>对任意的偏好关系 <span class="math inline">\(\succ\in\mathscr{A}^N\)</span>, PS与RP的关系如下:<br><table><tr><td></td><td><strong>无嫉妒性</strong></td><td><strong>策略忠诚性</strong></td></tr><tr><td><strong>RP</strong></td><td>弱无嫉妒</td><td>策略忠诚</td></tr><tr><td><strong>PS</strong></td><td>无嫉妒</td><td>弱策略忠诚</td></tr></table>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 北大 </tag>
            
            <tag> 保研 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 经济学 </tag>
            
            <tag> 论文笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京大学数学科学学院2018年直博生考试题目</title>
      <link href="/2018/04/01/%E5%8C%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E6%95%B0%E5%AD%A6%E7%A7%91%E5%AD%A6%E5%AD%A6%E9%99%A22018%E5%B9%B4%E7%9B%B4%E5%8D%9A%E7%94%9F%E8%80%83%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
      <content type="html"><![CDATA[<p>分为分析, 代数, 几何三部分. 满分200分.</p><a id="more"></a><h2 id="分析部分">分析部分</h2><p>四题. 共100分.</p><ol style="list-style-type: decimal"><li>(1.1) (10分) 证明隐函数 <span class="math display">\[y+\sin(xy)-x=0\]</span> 在 <span class="math inline">\(x=0\)</span> 附近可以确定一个函数关系 <span class="math inline">\(y=f(x)\)</span>.<br>(1.2) (5分) 试简单回答该函数的光滑度(不必证明).<br>(1.3) (10分) 求 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\(x=0\)</span> 处的三阶导数 <span class="math inline">\(f&#39;&#39;&#39;(0)\)</span>.<br></li><li>(2.1) (10分) 叙述积分第一中值定理并给出一个几何解释.<br>(2.2) (10分) 叙述一个函数 <span class="math inline">\(g(x)\equiv 1\)</span> 另一个函数 <span class="math inline">\(f(x)\)</span> 单调时的积分第二中值定理(三种情况), 并给出一个几何解释.<br>(2.3) (5分) 请问上问中函数 <span class="math inline">\(f(x)\)</span> 的单调性是实质性条件还是技术性条件. 如果是实质性的, 其本质是什么? 如果是技术性的, 在哪些方面提供了方便.<br></li><li>(25分) 在考虑函数 <span class="math inline">\(f(x)\)</span> 在给定区间上的Fourier级数 <span class="math display">\[\sum a_n\sin nx+b_n\cos nx\]</span> 的收敛性时, <span class="math inline">\(f(x)\)</span> 的光滑性与级数的收敛速度之间有没有一定的关系? 给出自己的理解和描述.</li><li>(4.1) (10分) 试讨论广义积分 <span class="math display">\[\int_\mathbb{R}\frac{\sin x}{x}{\rm d}x\]</span> 的收敛性.<br>(4.2) (10分) 试讨论广义重积分 <span class="math display">\[\iint_D\frac{\sin x}{x}{\rm d}x{\rm d}y,\quad D=\{\mathbb{R}\times[0,1]\}\]</span> 的敛散性.<br>(4.3) (5分) 请对上述结果做出一个你认为合理且本质的解释.</li></ol><h2 id="代数部分">代数部分</h2><p>三题, 共70分.</p><ol start="5" style="list-style-type: decimal"><li>(20分) 求集合 <span class="math display">\[\{A\in M_{7\times 7}(\mathbb{R}): A^3=0\}\]</span> 中矩阵秩的最大值.</li><li>(30分) 设 <span class="math inline">\(V\)</span> 是有限维实内积空间, <span class="math inline">\(\alpha_1,\cdots,\alpha_r,\beta_1,\cdots,\beta_r\in V\)</span>, 假设存在非零向量 <span class="math inline">\(\alpha\in V\)</span>, s.t. <span class="math display">\[\sum\limits_{i=1}^r\langle\alpha,\alpha_i\rangle\beta_i=0.\]</span>证明存在非零向量 <span class="math inline">\(\beta\in V\)</span>, s.t. <span class="math display">\[\sum\limits_{i=1}^r\langle\beta,\beta_i\rangle\alpha_i=0.\]</span></li><li>(30分) 证明对任意 <span class="math inline">\(3\times 3\)</span> 复矩阵 <span class="math inline">\(A\)</span>, 存在 <span class="math inline">\(3\times 3\)</span> 酉矩阵 <span class="math inline">\(U\)</span>, s.t. <span class="math inline">\(UAU^{-1}\)</span> 为形如 <span class="math display">\[\begin{bmatrix}*&amp;0&amp;*\\ *&amp;*&amp;0\\ *&amp;0&amp;*\\ \end{bmatrix}\]</span> 的矩阵.</li></ol><h2 id="几何部分">几何部分</h2><p>一题, 共30分</p><ol start="8" style="list-style-type: decimal"><li>(30分) 对于空间仿射坐标系中的马鞍面 <span class="math inline">\(S: z=xy\)</span>, 记 <span class="math inline">\(G\)</span> 为所有保持 <span class="math inline">\(S\)</span> 作为点集不变的空间仿射变换构成的群, 试决定空间中所有的直线 <span class="math inline">\(L\)</span>, s.t. 对于任意 <span class="math inline">\(G\)</span> 中的变换 <span class="math inline">\(g\)</span>, <span class="math inline">\(g(L)\)</span> 都与 <span class="math inline">\(L\)</span> 平行或重合.</li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 北大 </tag>
            
            <tag> 保研 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 数学分析 </tag>
            
            <tag> 线性代数 </tag>
            
            <tag> 解析几何 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京大学数学科学学院2016年直博生考试题目</title>
      <link href="/2018/04/01/%E5%8C%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E6%95%B0%E5%AD%A6%E7%A7%91%E5%AD%A6%E5%AD%A6%E9%99%A22016%E5%B9%B4%E7%9B%B4%E5%8D%9A%E7%94%9F%E8%80%83%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
      <content type="html"><![CDATA[<p>分为分析, 代数, 几何三部分. 满分200分.</p><a id="more"></a><h2 id="分析部分">分析部分</h2><ol style="list-style-type: decimal"><li>(30分, 每小题15分)<ol style="list-style-type: decimal"><li>若 <span class="math inline">\(f(x)\)</span> 在实轴可导且 <span class="math inline">\(f&#39;(x)&gt;f(x)\)</span>, <span class="math inline">\(\forall x\in\mathbb{R}\)</span>, 则 <span class="math inline">\(f\)</span> 至多有一个零点.</li><li>若 <span class="math inline">\(f(x)\)</span> 在实轴可导且 <span class="math inline">\(f&#39;&#39;(x)&gt;f(x)\)</span>, <span class="math inline">\(\forall x\in\mathbb{R}\)</span>, 则 <span class="math inline">\(f\)</span> 至多有两个零点.</li></ol></li><li>(30分) 假设 <span class="math inline">\(\phi(x,y,z)\)</span> 是原点 <span class="math inline">\(O\)</span> 某个邻域的 <span class="math inline">\(C^\infty\)</span> 函数, 且 <span class="math inline">\(\phi\)</span>, <span class="math inline">\(\phi_x\)</span>, <span class="math inline">\(\phi_y\)</span>, <span class="math inline">\(\phi_{xz}\)</span>, <span class="math inline">\(\phi_{yz}\)</span> 在原点为 <span class="math inline">\(0\)</span>, <span class="math inline">\(\phi_{xx}\)</span>, <span class="math inline">\(\phi_{yy}\)</span> 在原点为 <span class="math inline">\(1\)</span>, <span class="math inline">\(\phi_{xy}(O)=\frac{1}{2}\)</span>, <span class="math inline">\(\phi_z(O)=-\frac{1}{2}\)</span>. <span class="math inline">\(\phi(x,y,z)=0\)</span> 确定的的隐函数记为 <span class="math inline">\(z=z(x,y)\)</span> (已知 <span class="math inline">\(z(0,0)=0\)</span>). 请讨论 <span class="math inline">\(z=z(x,y)\)</span> 在 <span class="math inline">\((0,0)\)</span> 附近的极值问题.</li><li>(40分) 设 <span class="math inline">\(z=z(x,y)\)</span> 是上题中的隐函数, <span class="math inline">\(\Omega_\delta\)</span> 是 <span class="math inline">\((0,0)\)</span> 点的 <span class="math inline">\(\delta\)</span> 邻域, 当 <span class="math inline">\(\delta\)</span> 充分小时, 证明下列极限存在并求值: <span class="math display">\[\lim\limits_{t\to+\infty} t\iint_{\Omega_\delta}e^{-tz(x,y)}{\rm d}x{\rm d}y.\]</span></li></ol><h2 id="代数部分">代数部分</h2><ol start="4" style="list-style-type: decimal"><li>(20分) 设 <span class="math inline">\(A\)</span> 是一个 <span class="math inline">\(2\)</span> 阶复方阵, 考虑二阶复方阵的线性空间 <span class="math inline">\(M_2(\mathbb{C})\)</span> 上的线性变换 <span class="math display">\[\phi_A: M_2(\mathbb{C})\to M_2(\mathbb{C}),~X\mapsto AX-XA.\]</span>试确定 <span class="math inline">\(\dim({\rm Ker}(\phi_A))\)</span> 的所有可能值.</li><li>(20分) 对于有理数域 <span class="math inline">\(\mathbb{Q}\)</span> 上的两个 <span class="math inline">\(n\)</span> 阶方阵 <span class="math display">\[A=\begin{bmatrix}0&amp;1&amp;\cdots&amp;1\\ 0&amp;0&amp;\ddots&amp;\vdots\\ \vdots&amp;\ddots&amp;\ddots&amp;1\\ 0&amp;\cdots&amp;0&amp;0\\ \end{bmatrix},~B=\begin{bmatrix}0&amp;0&amp;\cdots&amp;0\\ 1&amp;0&amp;\ddots&amp;\vdots\\ \vdots&amp;\ddots&amp;\ddots&amp;0\\ 1&amp;\cdots&amp;1&amp;0\\ \end{bmatrix}\]</span>证明二者相似, 并求矩阵 <span class="math inline">\(T\)</span>, s.t. <span class="math inline">\(A=T^{-1}BT\)</span>.</li><li>(20分) <span class="math inline">\(\mathbb{R}[x]\)</span> 中有多项式 <span class="math display">\[f(x)=x^4+a_1x^3+a_2x^2+a_3x+a_4,\]</span> 试用系数 <span class="math inline">\(a_1\sim a_4\)</span> 的关系式给出 <span class="math inline">\(f(x)\)</span> 能表达成某不可约二次多项式 <span class="math inline">\(g(x)\)</span> 平方的充要条件.</li></ol><h2 id="几何部分">几何部分</h2><ol start="7" style="list-style-type: decimal"><li>(30分) 欧式平面上保定向的等距变换群的一个子群 <span class="math inline">\(G\)</span>, 其中每一个非恒同的变换 <span class="math inline">\(g\)</span> 都没有不动点, 且每一个平面上的点 <span class="math inline">\(p\)</span> 在 <span class="math inline">\(G\)</span> 作用下的轨道在平面上都没有聚点. 试证明 <span class="math inline">\(G\)</span> 可由一个或两个平移变换生成.</li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 北大 </tag>
            
            <tag> 保研 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 数学分析 </tag>
            
            <tag> 线性代数 </tag>
            
            <tag> 解析几何 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数学分析拾遗[5]——多元函数的极值</title>
      <link href="/2018/03/28/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E6%8B%BE%E9%81%97-5-%E2%80%94%E2%80%94%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%81%E5%80%BC/"/>
      <content type="html"><![CDATA[<p>多元函数的极值问题: 通常极值与条件极值</p><a id="more"></a><h2 id="通常极值">通常极值</h2><blockquote><p><strong>定理</strong> 设函数 <span class="math inline">\(f(\boldsymbol{x})=f(x_1,\cdots,x_n)\)</span> 在区域 <span class="math inline">\(D\subset\mathbb{R}^n\)</span> 内具有二阶连续偏导数, 且 <span class="math inline">\(f&#39;(\boldsymbol{x}_0)\)</span> <span class="math inline">\((\boldsymbol{x}_0\in D)\)</span>, 再设 <span class="math inline">\(f(\boldsymbol{x})\)</span> 在 <span class="math inline">\(\boldsymbol{x}_0\)</span> 处的Hessi矩阵满秩, 则<br>　　(1) 当 <span class="math inline">\(\boldsymbol{H}_f(\boldsymbol{x}_0)\)</span> 正定时, <span class="math inline">\(f(\boldsymbol{x})\)</span> 在 <span class="math inline">\(\boldsymbol{x}_0\)</span> 取极小值;<br>　　(2) 当 <span class="math inline">\(\boldsymbol{H}_f(\boldsymbol{x}_0)\)</span> 负定时, <span class="math inline">\(f(\boldsymbol{x})\)</span> 在 <span class="math inline">\(\boldsymbol{x}_0\)</span> 取极大值;<br>　　(3) 当 <span class="math inline">\(\boldsymbol{H}_f(\boldsymbol{x}_0)\)</span> 不定时, <span class="math inline">\(f(\boldsymbol{x})\)</span> 在 <span class="math inline">\(\boldsymbol{x}_0\)</span> 不是极值;</p></blockquote><ul><li>Hessi矩阵定义如下: <span class="math display">\[\boldsymbol{H}_f(\boldsymbol{x}_0)=\begin{bmatrix}\frac{\partial f(\boldsymbol{x}_0)}{\partial x_1^2} &amp; \frac{\partial f(\boldsymbol{x}_0)}{\partial x_1\partial x_2} &amp; \cdots &amp; \frac{\partial f(\boldsymbol{x}_0)}{\partial x_1\partial x_n}\\\frac{\partial f(\boldsymbol{x}_0)}{\partial x_2\partial x_1} &amp; \frac{\partial f(\boldsymbol{x}_0)}{\partial x_2^2} &amp; \cdots &amp; \frac{\partial f(\boldsymbol{x}_0)}{\partial x_2\partial x_n}\\\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\\frac{\partial f(\boldsymbol{x}_0)}{\partial x_n\partial x_1} &amp; \frac{\partial f(\boldsymbol{x}_0)}{\partial x_n\partial x_1} &amp; \cdots &amp; \frac{\partial f(\boldsymbol{x}_0)}{\partial x_n^2}\\\end{bmatrix}.\]</span></li></ul><h2 id="条件极值">条件极值</h2><blockquote><p><strong>定理</strong> 设函数 <span class="math inline">\(f(\boldsymbol{x})\)</span>, <span class="math inline">\(\boldsymbol{\varphi}(\boldsymbol{x})=(\varphi_1(\boldsymbol{x}),\cdots,\varphi_m(\boldsymbol{x}))\)</span> 在区域 <span class="math inline">\(D\subset\mathbb{R}^n~(m&lt;n)\)</span> 内具有各个连续偏导数, 再设 <span class="math inline">\(\boldsymbol{x}_0=(x_1^0,\cdots,x_n^0)\in D\)</span> 为 <span class="math inline">\(f(\boldsymbol{x})\)</span> 在约束条件 <span class="math display">\[\begin{cases}\varphi_1(\boldsymbol{x})=0,\\ \varphi_2(\boldsymbol{x})=0,\\ \cdots\cdots\\ \varphi_m(\boldsymbol{x})=0.\end{cases}\]</span> 下的极值点, 且 <span class="math inline">\(\boldsymbol{\varphi}&#39;(\boldsymbol{x}_0)\)</span> 的秩为 <span class="math inline">\(m\)</span>, 则存在常数 <span class="math inline">\(\lambda_1,\cdots,\lambda_m\in\mathbb{R}\)</span>, s.t. 在 <span class="math inline">\(\boldsymbol{x}_0\)</span> 处有如下等式成立: <span class="math display">\[\begin{cases}\frac{\partial f(\boldsymbol{x}_0)}{\partial x_i}+\sum\limits_{j=1}^m \lambda_j\frac{\partial \varphi_j(\boldsymbol{x}_0)}{\partial x_i}=0, &amp; i=1,2,\cdots,n, \\\varphi_j(\boldsymbol{x}_0)=0, &amp; j=1,2,\cdots,m.\end{cases}\]</span></p></blockquote><h3 id="lagrange乘数法">Lagrange乘数法</h3><ol style="list-style-type: decimal"><li><p>构造函数 <span class="math display">\[F(x_1,\cdots,x_n,\lambda_1,\cdots,\lambda_m)=f(\boldsymbol{x})+\sum_{j=1}^m\lambda_j\varphi_j(\boldsymbol{x}),\]</span></p></li><li><p>则 <span class="math inline">\(\boldsymbol{x}_0\)</span> 是极值点的必要条件如下: <span class="math display">\[\begin{cases}\frac{\partial F(\boldsymbol{x}_0)}{\partial x_i}=0 &amp; (i=1,2,\cdots,n),\\ \frac{\partial F(\boldsymbol{x}_0)}{\partial\lambda_j}=0 &amp; (j=1,2,\cdots,m).\\\end{cases}\]</span></p></li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 数学分析 </tag>
            
            <tag> 保研复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数学分析拾遗[4]——含参广义积分的一致收敛</title>
      <link href="/2018/03/27/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E6%8B%BE%E9%81%97-4-%E2%80%94%E2%80%94Abel%E5%88%A4%E5%88%AB%E6%B3%95%E4%B8%8EDirichlet%E5%88%A4%E5%88%AB%E6%B3%95/"/>
      <content type="html"><![CDATA[<p>含参广义积分一致收敛性的常用判断方法是M判别法, 但M判别法太强, 适用面窄. 故在被积函数取绝对值后不一致收敛时, 常用以下的两种判别法:</p><ul><li>Abel判别法;</li><li>Dirichlet判别法.</li></ul><a id="more"></a><h2 id="m判别法">M判别法</h2><blockquote><p><strong>定理</strong> 若 <span class="math inline">\(\exists M(x)\)</span>, s.t.<br>　　(1) <span class="math inline">\(\int_a^{+\infty}M(x){\rm d}x\)</span> 一致收敛.<br>　　(2) <span class="math inline">\(M\)</span> 有界, 即 <span class="math display">\[\vert f(x,y)\vert\leqslant M(x)~~~(\forall x\geqslant a,~\forall y\in I),\]</span><br>则 <span class="math inline">\(\int_a^{+\infty} f(x,y){\rm d}x\)</span> 在 <span class="math inline">\(I\)</span> <font color="red">绝对</font>一致收敛.</p></blockquote><h2 id="abel判别法">Abel判别法</h2><blockquote><p><strong>定理</strong> 若 <span class="math inline">\(\exists g,h\)</span>, s.t.<br>　　(1) <span class="math inline">\(\int_a^{+\infty} g(x,y){\rm d}x\)</span> 对 <span class="math inline">\(y\in I\)</span> <font color="blue">一致收敛</font>;<br>　　(2) <span class="math inline">\(h(x,y)\)</span> 当 <span class="math inline">\(y\)</span> 固定时, 对 <span class="math inline">\(x\)</span> 单调, 且<font color="red">一致有界</font>, 即 <span class="math inline">\(\exists M\)</span>&gt;0, s.t. <span class="math display">\[\vert h(x,y)\vert\leqslant M~~(\forall x\geqslant a, \forall  y\in I).\]</span><br>则 <span class="math inline">\(\int_a^{+\infty}f(x,y){\rm d}x\)</span> 在 <span class="math inline">\(I\)</span> 一致收敛.</p></blockquote><h2 id="dirichlet判别法">Dirichlet判别法</h2><blockquote><p><strong>定理</strong> 若 <span class="math inline">\(\exists g,h\)</span>, s.t.<br>　　(1) <span class="math inline">\(\int_a^{A} g(x,y){\rm d}x\)</span> <font color="blue">一致有界</font>, 即 <span class="math inline">\(\exists M&gt;0\)</span>, s.t. <span class="math display">\[\left|\int_a^A g(x,y){\rm d}x\right|\leqslant M~~~(\forall A\geqslant a, \forall y\in I);\]</span> 　　(2) <span class="math inline">\(h(x,y)\)</span> 当 <span class="math inline">\(y\)</span> 固定时, 对 <span class="math inline">\(x\)</span> 单调, 且当 <span class="math inline">\(x\to +\infty\)</span> 时, <font color="red"><span class="math display">\[h(x,y)\rightrightarrows0.\]</span></font><br>则 <span class="math inline">\(\int_a^{+\infty}f(x,y){\rm d}x\)</span> 在 <span class="math inline">\(I\)</span> 一致收敛.</p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 数学分析 </tag>
            
            <tag> 保研复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线性代数拾遗[2]——Jordan标准形</title>
      <link href="/2018/03/22/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%8B%BE%E9%81%97-2-%E2%80%94%E2%80%94Jordan%E6%A0%87%E5%87%86%E5%9E%8B/"/>
      <content type="html"><![CDATA[<p>Jordan标准形相关理论: <span class="math inline">\(\lambda\)</span> 矩阵, 初等因子, 不变因子.</p><blockquote><p>默认已经了解了Jordan标准形的相关定义.</p></blockquote><a id="more"></a><h2 id="jordan标准形定理">Jordan标准形定理</h2><p>Jordan标准形定理是线性代数里最深刻的结果</p><blockquote><p><strong>定理</strong> 复数域上任意一个 <span class="math inline">\(n\)</span> 阶方阵 <span class="math inline">\(A\)</span> 都相似于一个Jordan标准形. 即 <span class="math inline">\(\forall A\in\mathbb{C}^{n\times n}\)</span>, <span class="math inline">\(\exists\)</span> 可逆阵 <span class="math inline">\(P\)</span>, s.t. <span class="math display">\[P^{-1}AP=\begin{bmatrix}J_{m_1}(\lambda_1)&amp;&amp;\\ &amp;\ddots&amp;\\ &amp;&amp;J_{m_s}(\lambda_s)\end{bmatrix},\]</span> 其中 <span class="math inline">\(J_{m_t}(\lambda_t)\)</span> <span class="math inline">\((t=1,\cdots,s)\)</span> 为 <span class="math inline">\(A\)</span> 的特征<span class="math inline">\(\lambda\)</span>矩阵 <span class="math inline">\(\lambda I-A\)</span> 的初等因子 <span class="math inline">\((\lambda-\lambda_t)^{m_t}\)</span> 所对应的 <span class="math inline">\(m_t\)</span> 阶Jordan块 <span class="math display">\[\begin{bmatrix}\lambda_t&amp;1&amp;0&amp;\cdots&amp;0\\ &amp;\lambda_t&amp;1&amp;\ddots&amp;\vdots\\ &amp;&amp;\ddots&amp;\ddots&amp;0\\ &amp;&amp;&amp;\lambda_t&amp;1\\ &amp;&amp;&amp;&amp;\lambda_t\\ \end{bmatrix}_{m_t\times m_t}.\]</span></p></blockquote><blockquote><p>在不考虑Jordan块顺序的情况下, Jordan标准形是唯一的.</p></blockquote><h2 id="lambda--矩阵"><span class="math inline">\(\lambda-\)</span> 矩阵</h2><h3 id="lambda--矩阵-1"><span class="math inline">\(\lambda-\)</span> 矩阵</h3><blockquote><p><strong>定义</strong> 设 <span class="math inline">\(F\)</span> 是一个数域, <span class="math inline">\(\lambda\)</span> 是一个未定元, <span class="math inline">\(f_{ij}(\lambda)\in F[\lambda]\)</span>, <span class="math inline">\(i=1,\cdots,m\)</span>, <span class="math inline">\(j=1,\cdots,n\)</span>. 一元多项式环 <span class="math inline">\(F[\lambda]\)</span> 上的矩阵 <span class="math display">\[\begin{bmatrix}f_{11}(\lambda)&amp;f_{12}(\lambda)&amp;\cdots&amp;f_{1n}(\lambda)\\ f_{21}(\lambda)&amp;f_{22}(\lambda)&amp;\cdots&amp;f_{2n}(\lambda)\\ \vdots&amp;\vdots&amp;&amp;\vdots\\ f_{m1}(\lambda)&amp;f_{m2}(\lambda)&amp;\cdots&amp;f_{mn}(\lambda)\\ \end{bmatrix}\]</span> 是一个 <span class="math inline">\(\lambda-\)</span> 矩阵.</p></blockquote><h3 id="lambda--矩阵的初等变换"><span class="math inline">\(\lambda-\)</span> 矩阵的初等变换</h3><ol style="list-style-type: decimal"><li>交换两行/两列;</li><li>用一个非零常数乘某行/某列;</li><li>用一个多项式 <span class="math inline">\(g(\lambda)\)</span> 乘以某一行/列加到另一行/列上.</li></ol><h3 id="lambda--矩阵的等价标准形"><span class="math inline">\(\lambda-\)</span> 矩阵的等价标准形</h3><blockquote><p><strong>定理</strong> 任一个非零的 <span class="math inline">\(m\times n\)</span> 的 <span class="math inline">\(\lambda-\)</span> 矩阵 <span class="math inline">\(A(\lambda)\)</span> 都可以变换成以下形式的一个矩阵 <span class="math display">\[\begin{bmatrix}D(\lambda)_{r\times r}&amp; \\ &amp;0\\ \end{bmatrix}\]</span> 其中 <span class="math display">\[D(\lambda)_{r\times r}=\begin{bmatrix}d_1(\lambda)&amp;&amp;&amp;\\ &amp;d_2(\lambda)&amp;&amp;\\ &amp;&amp;\ddots&amp;\\ &amp;&amp;&amp;d_r(\lambda)\\ \end{bmatrix}\]</span> 其中 <span class="math inline">\(r={\rm rank}A(\lambda)\)</span>, <span class="math inline">\(d_i\)</span> 是首一多项式, 且满足 <span class="math display">\[d_i(\lambda)\vert d_{i+1}(\lambda),~i=1,2,\cdots,r-1.\]</span> 这样的矩阵被称为 <span class="math inline">\(A(\lambda)\)</span> 的<strong>等价标准形</strong>.</p></blockquote><h2 id="不变因子和初等因子">不变因子和初等因子</h2><h3 id="行列式因子">行列式因子</h3><h4 id="定义">定义</h4><blockquote><p><strong>定义</strong> 设 <span class="math inline">\(A(\lambda)\)</span> 是 <span class="math inline">\(m\times n\)</span> 的 <span class="math inline">\(\lambda-\)</span> 矩阵. 对于 <span class="math inline">\(k\leqslant \min\{m,n\}\)</span>, <span class="math inline">\(A(\lambda)\)</span> 的所有 <span class="math inline">\(k\)</span> 阶子式的首一最大公因式 <span class="math inline">\(D_k(\lambda)\)</span> 称为 <span class="math inline">\(A(\lambda)\)</span> 的 <span class="math inline">\(k\)</span> 阶行列式因子.</p></blockquote><h4 id="性质">性质</h4><ul><li>行列式因子在 <span class="math inline">\(\lambda-\)</span> 矩阵的初等变换下不变.</li><li>上条可直接推出 <span class="math inline">\(\lambda-\)</span> 矩阵的等价标准形是唯一的.</li></ul><h3 id="不变因子">不变因子</h3><h4 id="定义-1">定义</h4><blockquote><p><strong>定义</strong> <span class="math inline">\(\lambda-\)</span> 矩阵 <span class="math inline">\(A(\lambda)\)</span> 对角线的非零元素 <span class="math inline">\(d_i(\lambda)\)</span>, <span class="math inline">\((i=1,\cdots,r)\)</span> 称为 <span class="math inline">\(A(\lambda)\)</span> 的不变因子.</p></blockquote><h4 id="与行列式因子的关系">与行列式因子的关系</h4><p>不变因子与行列式因子有如下关系: <span class="math display">\[d_1(\lambda)=D_1(\lambda),d_2(\lambda)=\frac{D_2(\lambda)}{D_1(\lambda)},\cdots,d_r(\lambda)=\frac{D_r(\lambda)}{D_{r-1}(\lambda)}\]</span></p><h3 id="初等因子">初等因子</h3><blockquote><p><strong>定义</strong> 设 <span class="math inline">\(n\)</span> 阶 <span class="math inline">\(\lambda-\)</span> 矩阵 <span class="math inline">\(A(\lambda)\)</span> 的不变因子 <span class="math inline">\(d_1,\cdots,d_r\)</span> 的标准分解为 <span class="math display">\[d_1(\lambda)=p_1(\lambda)^{k_{11}}p_2(\lambda)^{k_{12}}\cdots p_s(\lambda)^{k_{1s}},\]</span> <span class="math display">\[d_2(\lambda)=p_1(\lambda)^{k_{21}}p_2(\lambda)^{k_{22}}\cdots p_s(\lambda)^{k_{2s}},\]</span> <span class="math display">\[\cdots\cdots\cdots\cdots\]</span> <span class="math display">\[d_r(\lambda)=p_1(\lambda)^{k_{r1}}p_2(\lambda)^{k_{r2}}\cdots p_s(\lambda)^{k_{rs}},\]</span> 其中 <span class="math inline">\(r={\rm rank}A(\lambda)\)</span>, <span class="math inline">\(p_i(\lambda)\)</span> 是两两不同的首一不可约多项式, 且 <span class="math display">\[0\leqslant k_{1i}\leqslant k_{2i}\leqslant \cdots\leqslant k_{ri},~i=1,2,\cdots,s.\]</span> 分解式中的 <span class="math inline">\(p_i(\lambda)\)</span> 的非零次幂, 叫做 <span class="math inline">\(A(\lambda)\)</span> 的初等因子.</p></blockquote><ul><li>当 <span class="math inline">\(F=\mathbb{C}\)</span> 时, <span class="math inline">\(p_i(\lambda)\)</span> 都是形如 <span class="math inline">\(\lambda-\lambda_i\)</span> 的一次因式.</li></ul><h2 id="jordan标准形的求法-lambda--矩阵">Jordan标准形的求法: <span class="math inline">\(\lambda-\)</span> 矩阵</h2><h3 id="lambda--矩阵法"><span class="math inline">\(\lambda-\)</span> 矩阵法</h3><p>按照以下步骤进行:</p><h4 id="求出a-的特征-lambda--矩阵">1. 求出<span class="math inline">\(A\)</span> 的特征 <span class="math inline">\(\lambda-\)</span> 矩阵</h4><p>直接求 <span class="math inline">\(\lambda I-A\)</span> 即可.</p><h4 id="求-lambda-i-a-的等价标准形">2. 求 <span class="math inline">\(\lambda I-A\)</span> 的等价标准形</h4><p>利用 <span class="math inline">\(\lambda-\)</span> 矩阵的初等变换求出 <span class="math inline">\(\lambda I-A\)</span> 的等价标准形, 记为 <span class="math display">\[\begin{bmatrix}d_1(\lambda)&amp;&amp;&amp;\\ &amp;d_2(\lambda)&amp;&amp;\\ &amp;&amp;\ddots&amp;\\ &amp;&amp;&amp;d_n(\lambda)\\ \end{bmatrix}\]</span> 则 <span class="math inline">\(d_i(\lambda)\)</span> 是 <span class="math inline">\(A\)</span> 的不变因子.</p><h4 id="根据初等因子求jordan块">3. 根据初等因子求Jordan块</h4><p>对 <span class="math inline">\(d_i(\lambda)\)</span> 进行标准分解<span class="math display">\[d_i(\lambda)=(\lambda-\lambda_{i_1})^{m_{i_1}}(\lambda-\lambda_{i_2})^{m_{i_2}}\cdots (\lambda-\lambda_{i_t})^{m_{i_t}}\]</span> 其中 <span class="math inline">\(\lambda_{i_j}\)</span> 互不相等, 则在 <span class="math inline">\(A\)</span> 的Jordan标准形中, <span class="math inline">\(d_i(\lambda)\)</span> 所对应的 <span class="math inline">\(t\)</span> 个Jordan块分别为 <span class="math display">\[J_{m_{i_1}}(\lambda_{i_1}),J_{m_{i_2}}(\lambda_{i_2}),\cdots,J_{m_{i_t}}(\lambda_{i_t}).\]</span></p><h3 id="一个例子">一个例子</h3><h4 id="题目内容">题目内容</h4><blockquote><p><strong>题目</strong> 求 <span class="math display">\[\begin{bmatrix}-1&amp;-2&amp;6\\ -1&amp;0&amp;3\\ -1&amp;-1&amp;4\\ \end{bmatrix}\]</span> 的Jordan标准形.</p></blockquote><h4 id="简略解答">简略解答</h4><p>特征 <span class="math inline">\(\lambda-\)</span> 矩阵为 <span class="math display">\[\lambda I-A=\begin{bmatrix}\lambda+1&amp;2&amp;-6\\ 1&amp;\lambda&amp;-3\\ 1&amp;1&amp;\lambda-4\\ \end{bmatrix}\]</span> 初等变换得到其等价标准形为 <span class="math display">\[\begin{bmatrix}1&amp;0&amp;0\\ 0&amp;\lambda-1&amp;0\\ 0&amp;0&amp;(\lambda-1)^2\\ \end{bmatrix}\]</span> 不变因子为 <span class="math inline">\(\lambda-1\)</span>, <span class="math inline">\((\lambda-1)^2\)</span>, 于是初等因子为 <span class="math inline">\(\lambda-1\)</span>, <span class="math inline">\((\lambda-1)^2\)</span>, 故 <span class="math inline">\(A\)</span> 有一个一阶块, 一个二阶块. 其Jordan标准形为 <span class="math display">\[\begin{bmatrix}1&amp;0&amp;0\\ 0&amp;1&amp;1\\ 0&amp;0&amp;1\\ \end{bmatrix}.\]</span></p><h2 id="jordan标准形的求法-空间分解">Jordan标准形的求法: 空间分解</h2><p>累死, 以后再写==</p><h2 id="参考资料">参考资料</h2><ol style="list-style-type: decimal"><li>王卿文. 线性代数核心思想及应用[M]. 科学出版社, 2012.</li><li>丘维声. 高等代数-第2版[M]. 高等教育出版社, 2002.</li><li>王萼芳. 高等代数教程.下册[M]. 清华大学出版社, 1997.</li><li>霍元极. 高等代数[M]. 北京师范大学出版社, 2009.</li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 线性代数 </tag>
            
            <tag> 保研复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线性代数拾遗[1]——分块矩阵</title>
      <link href="/2018/03/22/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%8B%BE%E9%81%97-1-%E2%80%94%E2%80%94%E5%88%86%E5%9D%97%E7%9F%A9%E9%98%B5/"/>
      <content type="html"><![CDATA[<p>分块矩阵的几个应用:</p><ol style="list-style-type: decimal"><li>特征多项式降阶定理(Sylvester公式);<br></li><li>秩的第一和第二降阶定理;<br></li><li>Sylvester不等式和Frobenius不等式.<br></li><li>一个例子</li></ol><a id="more"></a><h2 id="特征多项式降阶定理">特征多项式降阶定理</h2><h3 id="定理内容">定理内容</h3><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(m\times n\)</span> 矩阵, <span class="math inline">\(B\)</span> 是 <span class="math inline">\(n\times m\)</span> 矩阵, 且 <span class="math inline">\(m\geqslant n\)</span>, 则 <span class="math display">\[\vert\lambda I_m-AB\vert=\lambda^{m-n}\vert\lambda I_n-BA\vert.\]</span></p></blockquote><h3 id="简略证明">简略证明</h3><p>考虑到等式左右的行列式形式, 构造分块矩阵 <span class="math display">\[\begin{bmatrix}\lambda I_m &amp; A \\ B &amp; I_n \\ \end{bmatrix},\]</span></p><p>然后<font color="red"><strong>构造广义初等矩阵:</strong> <span class="math display">\[\begin{bmatrix}I_m &amp; -A \\ 0 &amp; I_n\\ \end{bmatrix},\begin{bmatrix}I_m &amp; -\frac{1}{\lambda}A \\ 0 &amp; I_n \\ \end{bmatrix}.\]</span></font> 则有 <span class="math display">\[\begin{bmatrix}I_m &amp; -A \\ 0 &amp; I_n\\ \end{bmatrix}\begin{bmatrix}\lambda I_m &amp; A \\ B &amp; I_n \\ \end{bmatrix}=\begin{bmatrix}\lambda I_m-AB &amp; 0 \\ B &amp; I_n \\ \end{bmatrix}\]</span> <span class="math display">\[\begin{bmatrix}\lambda I_m &amp; A \\ B &amp; I_n \\ \end{bmatrix} \begin{bmatrix}I_m &amp; -\frac{1}{\lambda}A \\ 0 &amp; I_n \\ \end{bmatrix}=\begin{bmatrix}\lambda I_m &amp; 0 \\ B &amp; I_n-\frac{1}{\lambda}BA \\ \end{bmatrix}\]</span></p><p>取行列式, 即有: <span class="math display">\[\vert \lambda I_m-AB\vert=\begin{vmatrix}\lambda I_m &amp; A \\ B &amp; I_n \\ \end{vmatrix}=\vert\lambda I_m\vert\vert I_n-\frac{1}{\lambda}BA\vert.\]</span></p><h3 id="其他形式">其他形式</h3><p>为了应用上的方便, 常写为 <span class="math display">\[\vert\lambda I_m+AB\vert=\lambda^{m-n}\vert\lambda I_n+BA\vert.\]</span></p><h2 id="秩的第一降阶定理">秩的第一降阶定理</h2><h3 id="定理内容-1">定理内容</h3><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(A\)</span> 可逆, <span class="math inline">\(\begin{bmatrix}A&amp;B\\C&amp;D\\\end{bmatrix}\)</span> 是 <span class="math inline">\(m\times n\)</span> 矩阵, 则 <span class="math display">\[r\begin{bmatrix}A&amp;B\\C&amp;D\\\end{bmatrix}=r(A)+r(D-CA^{-1}B).\]</span></p></blockquote><h3 id="简略证明-1">简略证明</h3><p><font color="red"><strong>构造广义初等矩阵:</strong> <span class="math display">\[\begin{bmatrix}I&amp;0\\ -CA^{-1}&amp;I\\ \end{bmatrix},\begin{bmatrix}I&amp;-A^{-1}B\\ 0&amp;I\\ \end{bmatrix}.\]</span></font> 则 <span class="math display">\[\begin{bmatrix}I&amp;0\\ -CA^{-1}&amp;I\\ \end{bmatrix} \begin{bmatrix}A&amp;B\\C&amp;D\\\end{bmatrix} \begin{bmatrix}I&amp;-A^{-1}B\\ 0&amp;I\\ \end{bmatrix}=\begin{bmatrix}A&amp;0\\ 0&amp;D-CA^{-1}B\\ \end{bmatrix}\]</span> 于是 <span class="math display">\[r\begin{bmatrix}A&amp;B\\C&amp;D\\\end{bmatrix}=r\begin{bmatrix}A&amp;0\\ 0&amp;D-CA^{-1}B\\ \end{bmatrix}=r(A)+r(D-CA^{-1}B).\]</span></p><h2 id="秩的第二降阶定理">秩的第二降阶定理</h2><h3 id="定理内容-2">定理内容</h3><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(A\)</span>, <span class="math inline">\(D\)</span> 分别是 <span class="math inline">\(m\)</span> 阶与 <span class="math inline">\(n\)</span> 阶可逆矩阵, <span class="math inline">\(B\)</span>, <span class="math inline">\(C\)</span> 分别是 <span class="math inline">\(m\times n\)</span> 和 <span class="math inline">\(n\times m\)</span> 矩阵, 则 <span class="math display">\[r(D-CA^{-1}B)=r(D)-r(A)+r(A-BD^{-1}C).\]</span></p></blockquote><h3 id="简略证明-2">简略证明</h3><p>思路与第一降阶定理完全相同, 略去.</p><h2 id="sylverster不等式">Sylverster不等式</h2><p><font color="red"><span class="math display">\[\min\{r(A),r(B)\}\geqslant r(AB)\geqslant r(A)+r(B)-n.\]</span></font></p><h3 id="定理内容-3">定理内容</h3><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span> 分别是 <span class="math inline">\(m\times n\)</span> 和 <span class="math inline">\(n\times l\)</span> 矩阵, 则 <span class="math display">\[r(AB)\geqslant r(A)+r(B)-n.\]</span></p></blockquote><h3 id="简略证明-3">简略证明</h3><h4 id="证法一">证法一</h4><p>由第一降阶定理, 有: <span class="math display">\[\begin{align}r(AB) &amp;= r(0+AI_n^{-1}B)=r\begin{bmatrix}I_n&amp;B\\ -A&amp;0\\ \end{bmatrix}-r(I_n) \\&amp;= r\begin{bmatrix}I_n&amp;B\\ -A&amp;0\\ \end{bmatrix}-n \\&amp;\geqslant r(A)+r(B)-n.\end{align}\]</span></p><h4 id="证法二">证法二</h4><p>构造分块矩阵: <span class="math display">\[\begin{bmatrix}A&amp;0\\ I&amp;B\\ \end{bmatrix},\]</span> 则有 <span class="math display">\[\begin{align}r(A)+r(B) &amp;\leqslant r\begin{bmatrix}A&amp;0\\ I&amp;B\\ \end{bmatrix}=r\begin{bmatrix}0&amp;-AB\\ I&amp;0\\ \end{bmatrix}\\&amp;= r(I)+r(AB).\end{align}\]</span></p><h2 id="frobenius不等式">Frobenius不等式</h2><h3 id="定理内容-4">定理内容</h3><blockquote><p><strong>定理</strong> <span class="math display">\[r(ABC)\geqslant r(AB)+r(BC)-r(B).\]</span></p></blockquote><h3 id="简略证明-4">简略证明</h3><p>考虑变换: <span class="math display">\[\begin{bmatrix}ABC&amp;0\\ 0&amp;B\\ \end{bmatrix}\to\begin{bmatrix}ABC&amp;AB\\ 0&amp;B\\ \end{bmatrix}\to\begin{bmatrix}0&amp;AB\\ -BC&amp;B\\ \end{bmatrix}\]</span> 故有: <span class="math display">\[r(ABC)+r(B)=r\begin{bmatrix}0&amp;AB\\ -BC&amp;B\\ \end{bmatrix}\geqslant r(AB)+r(BC).\]</span></p><h2 id="一个例子">一个例子</h2><h3 id="题目内容">题目内容</h3><blockquote><p>设 <span class="math inline">\(A\in F^{n\times n}\)</span>, <span class="math inline">\(f(x),g(x)\in F[x]\)</span> 且 <span class="math inline">\((f(x),g(x))=1\)</span>, 求证 <span class="math display">\[f(A)g(A)=0\iff r(f(A))+r(g(A))=n.\]</span></p></blockquote><h3 id="简略证明-5">简略证明</h3><p>由 <span class="math inline">\((f(x),g(x))=1\)</span>, 可知 <span class="math inline">\(\exists u(x),v(x)\in F[x]\)</span>, s.t. <span class="math display">\[u(x)f(x)+v(x)g(x)=1.\]</span> 故 <span class="math display">\[u(A)f(A)+v(A)g(A)=I.\]</span> 故有如下变换: <span class="math display">\[\begin{bmatrix}f(A)&amp;0\\ 0&amp;g(A)\\ \end{bmatrix}\to\begin{bmatrix}f(A)&amp;0\\ I&amp;g(A)\\ \end{bmatrix}\to\begin{bmatrix}0&amp;-f(A)g(A)\\ I&amp;0\\ \end{bmatrix}\]</span> 同时取秩, 可得 <span class="math display">\[f(A)g(A)=0\iff r(f(A))+r(g(A))=n.\]</span></p><h3 id="一个变形">一个变形</h3><blockquote><p>设 <span class="math inline">\(A\)</span> 为 <span class="math inline">\(n\)</span> 阶方阵, 则 <span class="math display">\[A^2=A\iff r(A)+r(I-A)=n.\]</span></p></blockquote><h2 id="参考资料">参考资料</h2><ol style="list-style-type: decimal"><li>王卿文. 线性代数核心思想及应用[M]. 科学出版社, 2012.</li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 线性代数 </tag>
            
            <tag> 保研复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo博客的傻瓜式迁移</title>
      <link href="/2018/03/20/hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/"/>
      <content type="html"><![CDATA[<blockquote><p>在网上搜索&quot;hexo博客迁移&quot;, 得到的方案大多是在 <code>git</code> 上开辟一个仓库或者分支来存储博客的源码. 但是对于那些对 <code>git</code> 不是很熟悉的人来说, 这种方案操作难度稍大, 容易出岔子.</p></blockquote><p>本文提供了只保存主题 <code>\themes</code> 和文章 <code>\source</code> 两个文件夹, 重新配置环境的方法和细节.</p><a id="more"></a><h2 id="几句废话">几句废话</h2><p>前两天脑抽重装了一发系统, <del>再重装我就是狗</del>. 由于对 <code>git</code> 操作不够熟悉, 所以在迁移博客时出了一些小问题.</p><h2 id="出现的问题">出现的问题</h2>为了备份博客, 我在搭建之初将整个文件夹同步到了git的仓库中.<div class="github-widget" data-repo="lzcwr/My-blog-backup"></div>但一个很蠢的地方就是 <code>/theme/yelee</code> 中的内容没有被同步上来, 一直是一个空文件夹.<center><img src="http://olgwnj89q.bkt.clouddn.com/themes-yelee.png"></center><p>这个错误一直到我重装完系统后, 将该仓库clone到本地以后, 运行 <code>hexo server</code> 时才发现. 但此时已经来不及了==幸亏 <code>\source</code> 中的内容得以保留.<br>所以, 本文将提供一种重新配置网站的方案细节.</p><h2 id="配置细节">配置细节</h2><h3 id="环境配置">环境配置</h3><ol style="list-style-type: decimal"><li>安装 <code>git-for-windows</code>;</li><li>安装 <code>node.js</code>;</li><li>配置git相关信息: <code>user.name</code>, <code>user.email</code>, <code>ssh</code>.</li></ol><h3 id="hexo相关组件">hexo相关组件</h3><h4 id="hexo-deployer-git">hexo-deployer-git</h4><p>在 <code>git</code> 上部署网站需要安装该插件, 安装命令如下: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><h4 id="hexo-server">hexo-server</h4><p>在本地 <code>hexo s</code> 无法预览时需要安装该插件, 安装命令如下: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-server --save</span><br></pre></td></tr></table></figure></p><h4 id="hexo-renderer-pandoc">hexo-renderer-pandoc</h4><p>详见<a href="https://www.lizhechen.com/2017/03/08/Hexo%E4%B8%8EMathjax%E7%9A%84%E5%86%B2%E7%AA%81%E5%8F%8A%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89%E8%A7%A3%E5%86%B3/" target="_blank" rel="noopener">Hexo与Mathjax的冲突及（部分）解决</a>. 安装命令如下: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure></p><h2 id="后续操作">后续操作</h2><h3 id="文章迁移">文章迁移</h3><p>在空文件夹中运行 <code>hexo init</code>, 即可在文件夹中添加所需要的组件. 将其中的 <code>/source</code> 和 <code>/themes</code> 替换即可.</p><h3 id="搜索配置">搜索配置</h3><p>安装 <code>search</code> 插件, 在主题中配置好即可. 安装命令: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 计算机 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数学分析拾遗[3]——隐函数定理</title>
      <link href="/2018/03/18/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E6%8B%BE%E9%81%97-3-%E2%80%94%E2%80%94%E9%9A%90%E5%87%BD%E6%95%B0%E5%AE%9A%E7%90%86/"/>
      <content type="html"><![CDATA[<h2 id="单个方程的隐函数定理">单个方程的隐函数定理</h2><h3 id="二元情形">二元情形</h3><h4 id="定理内容">定理内容</h4><blockquote><p><strong>定理</strong> 设二元函数 <span class="math inline">\(F(x,y)\)</span> 在 <span class="math inline">\(U((x_0,y_0),\delta)\)</span> 内满足以下条件:<br>　　(1) <span class="math inline">\(F(x_0,y_0)=0\)</span>, <span class="math inline">\(F_y&#39;(x_0,y_0)\neq 0\)</span>;<br>　　(2) <span class="math inline">\(F(x,y)\)</span>, <span class="math inline">\(F_y&#39;(x,y)\)</span> 在 <span class="math inline">\(U((x_0,y_0),\delta)\)</span> 内连续.<br>则 <span class="math inline">\(\exists\delta_0&gt;0~(0&lt;\delta_0&lt;\delta)\)</span>, s.t. 在 <span class="math inline">\(U(x_o,\delta_0)\)</span> 内存在唯一满足下列条件的连续函数 <span class="math inline">\(f(x)\)</span>:<br>　　(a) <span class="math inline">\(y_0=f(x_0)\)</span>;<br>　　(b) <span class="math inline">\(F(x,f(x))=0\)</span>, <span class="math inline">\(\forall x\in U(x_0,\delta_0)\)</span>;<br>　　(c) 如果 <span class="math inline">\(F_x&#39;(x,y)\)</span> 在 <span class="math inline">\(U((x_0,y_0),\delta)\)</span> 内连续, 则 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\(U(x_0,\delta_0)\)</span> 存在连续导数并且有 <span class="math display">\[f&#39;(x)=-\frac{F_x&#39;(x,f(x))}{F_y&#39;(x,f(x))}.\]</span></p></blockquote><h4 id="简略证明">简略证明</h4><p>不妨设 <span class="math inline">\(F_y&#39;(x_0,y_0)&gt;0\)</span>. 由 <span class="math inline">\(F_y&#39;\)</span> 的连续性与极限的保号性, <span class="math inline">\(\exists 0&lt;\delta_1,\delta_2&lt;\delta\)</span>, s.t. <span class="math inline">\(\forall (x,y)\in U(x_0,\delta_1)\times U(y_0,\delta_2)\)</span>, 有 <span class="math display">\[F_y&#39;(x,y)&gt;0.\]</span> 特别地, 若固定 <span class="math inline">\(x=x_0\)</span>, 则 <span class="math inline">\(\forall y\in U(y_0,\delta_2)\)</span>, 有 <span class="math inline">\(F_y&#39;(x_0,y)&gt;0\)</span>. 故 <span class="math inline">\(F(x_0,y)\)</span> 在 <span class="math inline">\(U(y_0,\delta_2)\)</span> 对 <span class="math inline">\(y\)</span> 严格递增. 由于 <span class="math inline">\(F(x_0,y_0)=0\)</span>, 故 <span class="math display">\[F(x_0,y_0-\delta_2)&lt;0,~F(x_0,y_0+\delta_2)&gt;0.\]</span> 由 <span class="math inline">\(F\)</span> 的连续性, <span class="math inline">\(\exists\delta_0\in (0,\delta_1)\)</span>, s.t. <span class="math inline">\(\forall x\in U(x_0,\delta_0)\)</span>, 总有 <span class="math display">\[F(x,y_0-\delta_2)&lt;0,~F(x,y_0+\delta_2)&gt;0.\]</span> <span class="math inline">\(\forall \tilde{x}\in U(x_0,\delta_0)\)</span>, 考虑到 <span class="math inline">\(F_y&#39;(\tilde{x},y)&gt;0\)</span>, 由零点定理可知, 存在唯一的 <span class="math inline">\(\tilde{y}\in U(y_0,\delta_2)\)</span>, s.t. <span class="math display">\[F(\tilde{x},\tilde{y})=0.\]</span> 这说明了隐函数在 <span class="math inline">\(U((x_0,y_0),\delta_0)\)</span> 的存在性.<br>连续性和导数的存在性略去.</p><h3 id="多元情形">多元情形</h3><blockquote><p><strong>定理</strong> 记 <span class="math inline">\(\boldsymbol{x}=(x_1,\cdots,x_n)\)</span>, <span class="math inline">\(\boldsymbol{x}^0=(x_1^0,\cdots,x_n^0)\in\mathbb{R}^n\)</span>, 设函数 <span class="math inline">\(F(\boldsymbol{x},y)=F(x_1,\cdots,x_n,y)\)</span> 在 <span class="math inline">\(U(\boldsymbol{x}_0,\delta)\times U(y_0,\delta)~(\delta&gt;0)\)</span> 内由定义, 且满足<br>　　(1) <span class="math inline">\(F(\boldsymbol{x}_0,y_0)=0\)</span>, <span class="math inline">\(F_y&#39;(\boldsymbol{x}_0,y_0)\neq 0\)</span>;<br>　　(2) <span class="math inline">\(F(\boldsymbol{x},y)\)</span>, <span class="math inline">\(F_y&#39;(\boldsymbol{x},y)\)</span> 在 <span class="math inline">\(U((\boldsymbol{x}_0,y_0),\delta)\)</span> 内连续.<br>则 <span class="math inline">\(\exists\delta_0&gt;0~(0&lt;\delta_0&lt;\delta)\)</span>, s.t. 在 <span class="math inline">\(U(\boldsymbol{x}_o,\delta_0)\)</span> 内存在唯一满足下列条件的连续函数 <span class="math inline">\(f(\boldsymbol{x})\)</span>:<br>　　(a) <span class="math inline">\(y_0=f(\boldsymbol{x}_0)\)</span>;<br>　　(b) <span class="math inline">\(F(\boldsymbol{x},f(\boldsymbol{x}))=0\)</span>, <span class="math inline">\(\forall \boldsymbol{x}\in U(\boldsymbol{x}_0,\delta_0)\)</span>;<br>　　(c) 如果 <span class="math inline">\(F_x&#39;(\boldsymbol{x},y)\)</span> 在 <span class="math inline">\(U(\boldsymbol{x}_0,\delta)\times U(y_0,\delta)\)</span> 内连续, 则 <span class="math inline">\(f(\boldsymbol{x})\)</span> 在 <span class="math inline">\(U(\boldsymbol{x}_0,\delta_0)\)</span> 存在各个连续偏导数并且有 <span class="math display">\[\frac{\partial f(\boldsymbol{x})}{\partial x_i}=-\frac{F_{x_i}&#39;(x_1,\cdots,x_n,y)}{F_y&#39;(x_1,\cdots,x_n,y)},~\forall i=1,\cdots,n,~\forall\boldsymbol{x}\in U(\boldsymbol{x}_0,\delta).\]</span> 其中 <span class="math inline">\(y=f(\boldsymbol{x})\)</span>.</p></blockquote><h2 id="方程组的隐函数组定理">方程组的隐函数(组)定理</h2><p>待补</p><h2 id="反函数存在性定理">反函数存在性定理</h2><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\boldsymbol{y}=(y_1,\cdots,y_n)=(f_1(\boldsymbol{x}),\cdots,f_n(\boldsymbol{x}))\)</span> 是区域 <span class="math inline">\(D\subset\mathbb{R}^n\to\Omega\subset\mathbb{R}^n\)</span> 的一个 <span class="math inline">\(C^1\)</span> 映射, 且在 <span class="math inline">\(\boldsymbol{x}_0\in D\)</span> 处有 <span class="math display">\[\frac{\partial (f_1,\cdots,f_n)}{\partial (x_1,\cdots,x_n)}\Bigg|_{\boldsymbol{x}_0}\neq 0.\]</span> 记 <span class="math inline">\(\boldsymbol{y}=\boldsymbol{f}(\boldsymbol{x}_0)\)</span>, 则存在 <span class="math inline">\(\boldsymbol{x}_0\)</span> 的邻域 <span class="math inline">\(U(\boldsymbol{x}_0,\delta_0)\)</span>, s.t. <span class="math inline">\(\boldsymbol{y}=\boldsymbol{f}(\boldsymbol{x})\)</span> 是 <span class="math inline">\(U(\boldsymbol{x}_0,\delta_0)\to \boldsymbol{f}(U)\)</span> 的 <span class="math inline">\(C^1\)</span> 同胚映射. 其中 <span class="math inline">\(\boldsymbol{f}(U)\)</span> 是包含 <span class="math inline">\(\boldsymbol{y}_0\)</span> 的一个区域.</p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 数学分析 </tag>
            
            <tag> 保研复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数学分析拾遗[2]——积分的中值定理</title>
      <link href="/2018/03/13/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E6%8B%BE%E9%81%97-2-%E2%80%94%E2%80%94%E7%A7%AF%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/"/>
      <content type="html"><![CDATA[<h2 id="积分第一中值定理">积分第一中值定理</h2><h3 id="定理内容">定理内容</h3><blockquote><p><strong>积分第一中值定理</strong> 设函数 <span class="math inline">\(f(x)\in C[a,b]\)</span>, <span class="math inline">\(g(x)\in R[a,b]\)</span> <font color="red"><strong>且在 <span class="math inline">\([a,b]\)</span> 不变号</strong></font>, 则 <span class="math inline">\(\exists\xi\in[a,b]\)</span>, s.t. <span class="math display">\[\int_a^b f(x)g(x){\rm d}x=f(\xi)\int_a^b g(x){\rm d}x.\]</span></p></blockquote><h3 id="几何意义的探讨">几何意义的探讨</h3><p><span class="math inline">\(g(x)\equiv 1\)</span> 且 <span class="math inline">\(f(x)\geqslant 0\)</span> 时, 其形式变为: <span class="math display">\[\int_a^b f(x){\rm d}x=f(\xi)(b-a).\]</span> 此时几何意义是很显然的: 由 <span class="math inline">\(x=a\)</span>, <span class="math inline">\(x=b\)</span>, <span class="math inline">\(y=f(x)\)</span> 所围成的曲边梯形的面积与由 <span class="math inline">\(x=a,\)</span>, <span class="math inline">\(x=b\)</span>, <span class="math inline">\(y=f(\xi)\)</span> 围成的矩形面积相等, 如图所示:</p><center><img src="http://olgwnj89q.bkt.clouddn.com/1st%20m-v%20theorem%20of%20int.png"></center><h2 id="积分第二中值定理">积分第二中值定理</h2><h3 id="定理内容-1">定理内容</h3><blockquote><p><strong>积分第二中值定理</strong> 设函数 <span class="math inline">\(g(x)\in R[a,b]\)</span>, 有以下三种情况: (1) 若函数 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> <font color="red"><strong>单调增</strong></font>, 且对于 <span class="math inline">\(\forall x\in[a,b]\)</span>, 有 <span class="math inline">\(f(x)\geqslant 0\)</span>, 则 <span class="math inline">\(\exists\xi_1\in[a,b]\)</span>, s.t. <span class="math display">\[\int_a^b f(x)g(x){\rm d}x=f(b)\int_{\xi_1}^b g(x){\rm d}x.\]</span> (2) 若函数 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> <font color="red"><strong>单调减</strong></font>, 且对于 <span class="math inline">\(\forall x\in[a,b]\)</span>, 有 <span class="math inline">\(f(x)\geqslant 0\)</span>, 则 <span class="math inline">\(\exists\xi_2\in[a,b]\)</span>, s.t. <span class="math display">\[\int_a^b f(x)g(x){\rm d}x=f(a)\int_a^{\xi_2} g(x){\rm d}x.\]</span> (3) 若函数 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> <font color="red"><strong>单调</strong></font>, 则 <span class="math inline">\(\exists\xi\in[a,b]\)</span>, s.t. <span class="math display">\[\int_a^b f(x)g(x){\rm d}x=f(a)\int_a^\xi g(x){\rm d}x+f(b)\int_\xi^b g(x){\rm d}x.\]</span></p></blockquote><h2 id="参考文献">参考文献</h2><ol style="list-style-type: decimal"><li>伍胜建. 数学分析.第2册[M]. 北京大学出版社, 2010.</li><li>裴礼文. 数学分析中的典型问题与方法-第2版[M]. 高等教育出版社, 2006.</li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 数学分析 </tag>
            
            <tag> 保研复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数学分析拾遗[1]——一些不等式</title>
      <link href="/2018/03/13/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E6%8B%BE%E9%81%97-1-%E2%80%94%E2%80%94%E4%B8%80%E4%BA%9B%E4%B8%8D%E7%AD%89%E5%BC%8F/"/>
      <content type="html"><![CDATA[<h2 id="均值不等式">均值不等式</h2><center><font color="red"><strong>平方 <span class="math inline">\(\geqslant\)</span> 算数 <span class="math inline">\(\geqslant\)</span> 几何 <span class="math inline">\(\geqslant\)</span> 调和</strong><font></font></font></center><h3 id="定理内容">定理内容</h3><blockquote><p><strong>均值不等式</strong> <span class="math inline">\(\forall a_1,\cdots,a_n\geqslant 0\)</span>, 有 <span class="math display">\[\frac{n}{\sum\nolimits_{i=1}^n\frac{1}{a_i}}\leqslant \sqrt[n]{\prod\nolimits_{i=1}^n a_i}\leqslant \frac{\sum\nolimits_{i=1}^n a_i}{n}\leqslant \sqrt{\frac{\sum\nolimits_{i=1}^n a_i^2}{n}}.\]</span>取等号当且仅当 <span class="math inline">\(a_1=\cdots=a_n\)</span>.</p></blockquote><h3 id="简略证明">简略证明</h3><p>只证算术 <span class="math inline">\(\leqslant\)</span> 几何部分: 1. 先证对于 <span class="math inline">\(n=2^k\)</span> 成立: 由二元均值不等式可得<span class="math display">\[\begin{align}\sqrt[2^k]{a_1\cdots a_{2^k}} &amp;\leqslant \sqrt[2^{k-1}]{\frac{a_1+a_2}{2}+\frac{a_3+a_4}{2}+\cdots+\frac{a_{2^k-1}+a_{2^k}}{2}} \\&amp;\leqslant \cdots\leqslant \frac{a_1+\cdots+a_{2^k}}{2^k}.\end{align}\]</span> 2. <strong>反向归纳</strong>: 记 <span class="math inline">\(A=\frac{a_1+\cdots+a_n}{n}\)</span>, 则 <span class="math inline">\(nA=\sum a_i\)</span>. 设 <span class="math inline">\(n+1\)</span> 时不等式成立, 下证 <span class="math inline">\(n\)</span> 时成立: <span class="math display">\[\begin{align}A=\frac{nA+A}{n+1} &amp;= \frac{a_1+\cdots+a_n+A}{n+1} \\&amp;\geqslant  \sqrt[n+1]{a_1\cdots a_n A}.\end{align}\]</span> 于是 <span class="math inline">\(A^{n+1}\geqslant a_1\cdots a_nA\)</span>, 即 <span class="math display">\[A\geqslant \sqrt[n]{a_1\cdots a_n}.\]</span></p><h2 id="hölder不等式">Hölder不等式</h2><h3 id="定理内容-1">定理内容</h3><p><font color="red"><span class="math display">\[a\cdot b\leqslant \Vert a\Vert_p\cdot\Vert b\Vert_q,~\frac{1}{p}+\frac{1}{q}=1\]</span><font></font></font></p><blockquote><p><strong>Hölder不等式</strong> 设 <span class="math inline">\(a_i,b_i\geqslant 0\)</span>, <span class="math inline">\(\frac{1}{p}+\frac{1}{q}=1\)</span>, 则 (1) 当 <span class="math inline">\(p&gt;1\)</span> 时, <span class="math display">\[\sum\limits_{i=1}^n a_ib_i\leqslant (\sum\limits_{i=1}^n a_i^p)^{1/p}(\sum\limits_{i=1}^n a_i^q)^{1/q}.\]</span> (2) 当 <span class="math inline">\(p&lt;1\)</span> 时, <span class="math display">\[\sum\limits_{i=1}^n a_ib_i\geqslant (\sum\limits_{i=1}^n a_i^p)^{1/p}(\sum\limits_{i=1}^n a_i^q)^{1/q}.\]</span> 等号当且仅当 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(b_i\)</span> 成比例时取得.</p></blockquote><h3 id="简略证明-1">简略证明</h3><p>只证 (1): 当 <span class="math inline">\(p&gt;1\)</span> 时, 易有 <span class="math inline">\(q&lt;1\)</span>. 此时有 <span class="math display">\[\begin{align}\frac{a\cdot b}{\Vert a\Vert_p\cdot\Vert b\Vert_q} &amp;= \sum \left(\frac{a_i^p}{\sum a_i^p}\right)^{1/p}\left(\frac{b_i^q}{\sum b_i^q}\right)^{1/q} \\&amp;\leqslant \sum \left[\frac{1}{p}\left(\frac{a_i^p}{\sum a_i^p}\right)+\frac{1}{q}\left(\frac{b_i^q}{\sum b_i^q}\right)\right] \\&amp;= \frac{1}{p}\sum\frac{a_i^p}{\sum a_i^p}+\frac{1}{q}\sum\frac{b_i^q}{\sum b_i^q} \\&amp;= \frac{1}{p}+\frac{1}{q} =1.\end{align}\]</span></p><h2 id="minkowski不等式">Minkowski不等式</h2><h3 id="定理内容-2">定理内容</h3><p><font color="red"><span class="math display">\[\Vert a+b\Vert_p\leqslant \Vert a\Vert_p\cdot\Vert b\Vert_p\]</span><font></font></font></p><blockquote><p><strong>Minkowski不等式</strong> 对于 <span class="math inline">\(\forall r\neq 0,1\in\mathbb{R}\)</span>, 以及 <span class="math inline">\(a_i,b_i\geqslant 0\)</span>, 有 (1) 当 <span class="math inline">\(r&gt;1\)</span> 时, <span class="math display">\[(\sum\limits_{i=1}^n(a_i+b_i)^r)^{1/r}\leqslant (\sum\limits_{i=1}^n a_i^r)^{1/r}+(\sum\limits_{i=1}^n b_i^r)^{1/r}\]</span> (2) 当 <span class="math inline">\(r&lt;1\)</span> 时, <span class="math display">\[(\sum\limits_{i=1}^n(a_i+b_i)^r)^{1/r}\geqslant (\sum\limits_{i=1}^n a_i^r)^{1/r}+(\sum\limits_{i=1}^n b_i^r)^{1/r}\]</span></p></blockquote><h3 id="简略证明-2">简略证明</h3><p>只证 (1): 当 <span class="math inline">\(r&gt;1\)</span> 时, 令 <span class="math inline">\(s_i=a_i+b_i\)</span>, 则有 <span class="math display">\[\begin{align}\sum s_i^r &amp;= \sum (a_i+b_i)^r \\&amp;= \sum (a_i+b_i)(a_i+b_i)^{r-1} \\&amp;= \sum a_is_i^{r-1}+\sum b_is_i^{r-1}.\end{align}\]</span> 令 <span class="math inline">\(p=r\)</span>, <span class="math inline">\(q=\frac{r}{r-1}\)</span>, 则 <span class="math inline">\(\frac{1}{p}+\frac{1}{q}=1\)</span>, 由Hölder不等式可得: <span class="math display">\[\begin{align}\sum s_i^r &amp;\leqslant (\sum a_i^r)^{\frac{1}{r}}(\sum s_i^r)^{\frac{r-1}{r}}+(\sum b_i^r)^{\frac{1}{r}}(\sum s_i^r)^{\frac{r-1}{r}} \\&amp;= [(\sum a_i^r)^{\frac{1}{r}}+(\sum b_i^r)^{\frac{1}{r}}]\cdot (\sum s_i^r)^{1-\frac{1}{r}}.\end{align}\]</span> 两边同乘 <span class="math inline">\((\sum s_i^r)^{1-\frac{1}{r}}\)</span> 即可得到Minkowski不等式.</p><h2 id="young不等式">Young不等式</h2><h3 id="定理内容-3">定理内容</h3><blockquote><p><strong>Young不等式</strong> 设 <span class="math inline">\(f(x)\in[0,+\infty)\)</span> 单调增, <span class="math inline">\(f(0)=0\)</span>, <span class="math inline">\(a,b&gt;0\)</span>, 则 <span class="math display">\[ab\leqslant \int_0^a f(x){\rm d}x+\int_0^b f^{-1}(x){\rm d}x.\]</span> 等号当且仅当 <span class="math inline">\(f(a)=b\)</span> 时成立.</p></blockquote><h3 id="简略证明-3">简略证明</h3><p>从几何上看十分直观.</p><h2 id="参考文献">参考文献</h2><ol style="list-style-type: decimal"><li>裴礼文. 数学分析中的典型问题与方法-第2版[M]. 高等教育出版社, 2006.</li><li>伍胜建. 数学分析.第2册[M]. 北京大学出版社, 2010.</li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 数学分析 </tag>
            
            <tag> 保研复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>范畴论学习笔记</title>
      <link href="/2018/03/02/%E8%8C%83%E7%95%B4%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <content type="html"><![CDATA[<h2 id="何为范畴">何为范畴</h2><h3 id="范畴-category">范畴: category</h3><h4 id="范畴的定义">范畴的定义</h4><p>一个范畴 <span class="math inline">\(\mathscr{C}\)</span> 包含一些对象和一些箭头:</p><ol style="list-style-type: decimal"><li><strong>对象</strong>(Objects): 记作 <span class="math inline">\(A,B,C,\cdots\)</span>;</li><li><strong>箭头</strong>(Morphism): 记作 <span class="math inline">\(f,g,h,\cdots\)</span>.</li></ol><p>这些对象和箭头需要满足以下几个条件:</p><ul><li><strong>箭头有唯一的源和目标</strong>: <span class="math inline">\(\forall f\in\mathscr{C}\)</span>, <span class="math inline">\(\exists\)</span> 唯一 <span class="math inline">\({\rm src}f,{\rm tar} f\in\mathscr{C}\)</span>. 若 <span class="math inline">\({\rm scr}f = A\)</span>, <span class="math inline">\({\rm tar}f = B\)</span>, 则可以记为 <span class="math inline">\(f:A\to B\)</span>.</li><li><strong>箭头可以复合</strong>: <span class="math inline">\(\forall f,g\in\mathscr{C}\)</span>, 设 <span class="math inline">\(f:A\to B\)</span>, <span class="math inline">\(g:B\to C\)</span>, <span class="math inline">\(\exists h=g\circ f:A\to C\)</span>. 称为 &quot;<span class="math inline">\(g\)</span> following <span class="math inline">\(f\)</span>&quot;, 即二者的复合.</li><li><strong>每个对象必须有单位箭头</strong>: <span class="math inline">\(\forall A\in\mathscr{C}\)</span>, <span class="math inline">\(\exists {\rm id}_A:A\to A\in\mathscr{C}\)</span>.</li></ul><p>箭头还满足以下两条性质:</p><ol style="list-style-type: decimal"><li><strong><span class="math inline">\(\circ\)</span> 的结合律</strong>: <span class="math inline">\(\forall f:A\to B,~g:B\to C,~h:C\to D\)</span>, 有 <span class="math display">\[h\circ(g\circ f)=(h\circ g)\circ f.\]</span></li><li><strong><span class="math inline">\({\rm id}_A\)</span> 是 <span class="math inline">\(\circ\)</span> 运算的单位元</strong>: <span class="math inline">\(\forall f:A\to B\)</span>, 有 <span class="math display">\[f\circ {\rm id}_A=f={\rm id}_B\circ f.\]</span></li></ol><h4 id="范畴的例子">范畴的例子</h4><ul><li><strong>幺半群 Monoid</strong></li></ul><p>幺半群 <span class="math inline">\((M,\cdot)\)</span> 指不满足“所有元素可逆”的群:</p><ol style="list-style-type: decimal"><li><strong>存在单位元</strong>: <span class="math inline">\(\exists e\)</span>, s.t. <span class="math inline">\(\forall a\in M\)</span>, <span class="math inline">\(a\cdot e=a=e\cdot a\)</span>;</li><li><strong>乘法结合律</strong>: <span class="math inline">\(\forall a,b,c\in M\)</span>, <span class="math inline">\((a\cdot b)\cdot c=a\cdot (b\cdot c)\)</span>.</li></ol><p>在幺半群 <span class="math inline">\(M\)</span> 的基础上, 可定义范畴 <span class="math inline">\(\mathscr{M}\)</span> 如下:</p><ol style="list-style-type: decimal"><li><strong><span class="math inline">\(\mathscr{M}\)</span>-对象</strong>: 任取一个集合 <span class="math inline">\(S\)</span> 作为 <span class="math inline">\(\mathscr{M}\)</span> 的对象;</li><li><strong><span class="math inline">\(\mathscr{M}\)</span>-箭头</strong>: 用 <span class="math inline">\(M\)</span> 中的元素表示 <span class="math inline">\(\mathscr{M}\)</span> 上的箭头:<ol style="list-style-type: decimal"><li>箭头的复合定义为元素的乘积: <span class="math display">\[(a\circ b)_\mathscr{M}=(a\cdot b)_M;\]</span></li><li>单位箭头定义为 <span class="math inline">\(M\)</span> 的单位元: <span class="math display">\[{\rm id}_\mathscr{M}=e_M.\]</span></li></ol></li></ol><ul><li><strong>幺半范畴</strong></li></ul><p>考虑所有幺半群组成的集合, 可如下定义范畴 <span class="math inline">\(\mathscr{M}\)</span>:</p><ol style="list-style-type: decimal"><li><strong><span class="math inline">\(\mathscr{M}\)</span>-对象</strong>: 幺半群全体作为 <span class="math inline">\(\mathscr{M}\)</span> 的对象;</li><li><strong><span class="math inline">\(\mathscr{M}\)</span>-箭头</strong>: 所有的幺半群同态作为 <span class="math inline">\(\mathscr{M}\)</span> 的箭头.</li></ol><p>该范畴称为<strong>幺半范畴</strong>, 记作 <span class="math inline">\({\tt Mon}\)</span>.</p><ul><li><strong>偏序集</strong></li></ul><p>在一个集合 <span class="math inline">\(S\)</span> 上, 一个偏序 <span class="math inline">\(\leqslant\)</span> 的定义如下:</p><ol style="list-style-type: decimal"><li><strong>自反性</strong>: <span class="math inline">\(\forall x\in S\)</span>, <span class="math inline">\(x\leqslant x\)</span>;</li><li><strong>反对称性</strong>: <span class="math inline">\(x\leqslant y~\text{且}~y\leqslant x\iff x=y\)</span>;</li><li><strong>传递性</strong>: <span class="math inline">\(x\leqslant y,~y\leqslant z\Longrightarrow x\leqslant z\)</span>.</li></ol><p>集合 <span class="math inline">\(S\)</span> 定义了偏序后, 就称为一个<strong>偏序集</strong>. 在偏序集 <span class="math inline">\(S\)</span> 的基础上可以如下定义范畴 <span class="math inline">\(\mathscr{C}\)</span>:</p><ol style="list-style-type: decimal"><li><strong><span class="math inline">\(\mathscr{C}\)</span>-对象</strong>: <span class="math inline">\(S\)</span> 中的元素作为 <span class="math inline">\(\mathscr{C}\)</span> 的对象;</li><li><strong><span class="math inline">\(\mathscr{C}\)</span>-箭头</strong>: 若 <span class="math inline">\(A\leqslant B\in S\)</span>, 则存在唯一的箭头 <span class="math inline">\(f:A\to B\)</span>.</li></ol><p>容易验证这样定义的 <span class="math inline">\(\mathscr{C}\)</span> 是一个范畴.</p><ul><li><strong>偏序范畴</strong></li></ul><p>考虑所有偏序集组成的集合, 可如下定义范畴 <span class="math inline">\(\mathscr{C}\)</span>:</p><ol style="list-style-type: decimal"><li><strong><span class="math inline">\(\mathscr{C}\)</span>-对象</strong>: 偏序集全体作为 <span class="math inline">\(\mathscr{C}\)</span> 的对象;</li><li><strong><span class="math inline">\(\mathscr{C}\)</span>-箭头</strong>: 所有的保序映射作为 <span class="math inline">\(\mathscr{C}\)</span> 的箭头.</li></ol><p>如此定义的范畴, 称为<strong>偏序范畴</strong>, 记作 <span class="math inline">\({\tt Pos}\)</span>.</p><h4 id="几个特殊的范畴">几个特殊的范畴</h4><ul><li><strong>空范畴: empty category</strong></li></ul><p>没有对象也没有箭头的范畴, 称为<strong>空范畴</strong>.</p><ul><li><strong>一元范畴: <span class="math inline">\(1\)</span></strong></li></ul><p>只有一个单位对象和一个单位箭头的范畴, 记作 <span class="math inline">\(1\)</span>.</p><ul><li><strong>二元范畴: von Neumann ordinal <span class="math inline">\(2\)</span></strong></li></ul><p>集合 <span class="math inline">\(\{\varnothing,\{\varnothing\}\}\)</span> 上赋予单位箭头以及 <span class="math inline">\(\varnothing\to\{\varnothing\}\)</span> 箭头的范畴.</p><ul><li>集合范畴</li></ul><p>考虑如下范畴 <span class="math inline">\({\tt Set}\)</span>:</p><ol style="list-style-type: decimal"><li>对象: 所有集合<strong>(注意所有集合全体不是一个集合)</strong>;</li><li>箭头: 集合间的映射(原文为set-function) <span class="math inline">\(f:X\to Y\)</span>.<ol style="list-style-type: decimal"><li>单位箭头是恒等映射, 显然存在且唯一;</li><li>箭头的复合也是很自然的.</li></ol></li></ol><p>该范畴被称为集合范畴.</p><ul><li>逻辑范畴</li></ul><p>在形式语言 <span class="math inline">\(T\)</span> 中考虑如下范畴 <span class="math inline">\({\tt Proof}_T\)</span>:</p><ol style="list-style-type: decimal"><li>对象: 所有 <span class="math inline">\(T\)</span> 中的语句;</li><li>箭头: <span class="math inline">\(\forall\varphi,\psi\in T\)</span>, 存在箭头 <span class="math inline">\(\varphi\to\psi\iff\varphi\vdash\psi\)</span>.<ol style="list-style-type: decimal"><li>单位箭头是恒等映射, 显然存在且唯一;</li><li>箭头的复合根据 <span class="math inline">\(\vdash\)</span> 的定义显然.</li></ol></li></ol><p>该范畴称为 <span class="math inline">\(T\)</span> 上的逻辑范畴.</p><h4 id="一些常见范畴的定义和记号">一些常见范畴的定义和记号</h4><p>如下表所示, 整理自<a href="http://www.logicmatters.net/resources/pdfs/GentleIntro.pdf" target="_blank" rel="noopener">Category Theory: A Gentle Introductio</a>.</p><table><thead><tr class="header"><th align="center">范畴</th><th align="center">记号</th><th align="center">对象</th><th align="center">箭头</th></tr></thead><tbody><tr class="odd"><td align="center">群范畴</td><td align="center"><span class="math inline">\({\tt Grp}\)</span></td><td align="center">所有的群</td><td align="center">群同态</td></tr><tr class="even"><td align="center">交换群范畴</td><td align="center"><span class="math inline">\({\tt Ab}\)</span></td><td align="center">所有的交换群</td><td align="center">群同态</td></tr><tr class="odd"><td align="center">环范畴</td><td align="center"><span class="math inline">\({\tt Rng}\)</span></td><td align="center">所有的环</td><td align="center">环同态</td></tr><tr class="even"><td align="center">布尔范畴</td><td align="center"><span class="math inline">\({\tt Bool}\)</span></td><td align="center">所有的布尔代数</td><td align="center">结构保存映射</td></tr><tr class="odd"><td align="center">偏序/全序范畴</td><td align="center"><span class="math inline">\({\tt Pos/Tot}\)</span></td><td align="center">所有的偏序/全序集</td><td align="center">保序映射</td></tr><tr class="even"><td align="center">拓扑/度量空间范畴</td><td align="center"><span class="math inline">\({\tt Top/Met}\)</span></td><td align="center">所有的拓扑/度量空间</td><td align="center">连续映射</td></tr><tr class="odd"><td align="center">场 <span class="math inline">\(K\)</span> 上的向量空间范畴</td><td align="center"><span class="math inline">\({\tt Vect}_K\)</span></td><td align="center">所有的向量空间</td><td align="center">线性映射</td></tr><tr class="even"><td align="center">集合/有限集范畴</td><td align="center"><span class="math inline">\({\tt Set/FinSet}\)</span></td><td align="center">所有的集合/有限集</td><td align="center">集合映射 <span class="math inline">\(f:X\to Y\)</span></td></tr><tr class="odd"><td align="center">逻辑范畴</td><td align="center"><span class="math inline">\({\tt Proof}_T\)</span></td><td align="center"><span class="math inline">\(T\)</span> 中的所有语句</td><td align="center">按照逻辑推出关系 <span class="math inline">\(\vdash\)</span> 定义箭头</td></tr></tbody></table><h2 id="范畴生范畴">范畴生范畴</h2><p>从已有的一个范畴可以构建出新的范畴, 有以下的一些方法</p><h3 id="逆范畴-opposite-category">逆范畴: opposite category</h3><p>一个范畴 <span class="math inline">\(\mathscr{C}\)</span> 的逆范畴 <span class="math inline">\(\mathscr{C}^{op}\)</span> 定义如下:</p><ol style="list-style-type: decimal"><li><span class="math inline">\(\mathscr{C}^{op}\)</span>-对象: <span class="math inline">\(\mathscr{C}\)</span> 的对象;</li><li><span class="math inline">\(\mathscr{C}^{op}\)</span>-箭头: <span class="math inline">\(f:B\to A~\text{in}~\mathscr{C}^{op}\iff f:A\to B~\text{in}~\mathscr{C}\)</span><ol style="list-style-type: decimal"><li>单位箭头: <span class="math inline">\({\rm id}_A^{op}={\rm id}_A\)</span>, <span class="math inline">\(\forall A\)</span>;</li><li>复合箭头: <span class="math inline">\(f\circ^{op}g=g\circ f\)</span>.</li></ol></li></ol><p>根据定义可知:</p><ol style="list-style-type: decimal"><li>每个范畴 <span class="math inline">\(\mathscr{C}\)</span> 都存在一个对偶 <span class="math inline">\(\mathscr{C}^{op}\)</span>;</li><li>对偶的对偶就是自身: <span class="math inline">\((\mathscr{C}^{op})^{op}=\mathscr{C}\)</span>.</li></ol><h3 id="子范畴-subcategory">子范畴: subcategory</h3><p>对于一个范畴 <span class="math inline">\(\mathscr{C}\)</span>, 若 <span class="math inline">\(\exists\)</span> 范畴 <span class="math inline">\(\mathscr{S}\)</span>, s.t.</p><ol style="list-style-type: decimal"><li><span class="math inline">\(\mathscr{S}\)</span> 的对象全部都是 <span class="math inline">\(\mathscr{C}\)</span> 的(全部或部分)对象;</li><li><span class="math inline">\(\mathscr{S}\)</span> 的箭头全部都是 <span class="math inline">\(\mathscr{C}\)</span> 的(全部或部分)箭头.</li></ol><p>且满足:</p><ol style="list-style-type: decimal"><li><span class="math inline">\(\mathscr{S}\)</span> 继承 <span class="math inline">\(\mathscr{C}\)</span> 中的单位箭头;</li><li><span class="math inline">\(\mathscr{S}\)</span> 继承 <span class="math inline">\(\mathscr{C}\)</span> 的结合律.</li></ol><p>则称 <span class="math inline">\(\mathscr{S}\)</span> 是 <span class="math inline">\(\mathscr{C}\)</span> 的一个<strong>子范畴</strong>.</p><p>由定义立即得到:</p><ul><li><span class="math inline">\({\tt FinSet}\)</span> 是 <span class="math inline">\({\tt Set}\)</span> 的子范畴;</li><li><span class="math inline">\({\tt Ab}\)</span> 是 <span class="math inline">\({\tt Grp}\)</span> 的子范畴.</li></ul><p>特别地, 若对于 <span class="math inline">\(\forall\mathscr{S}\)</span> 对象 <span class="math inline">\(A,B\)</span>, <span class="math inline">\(\mathscr{S}\)</span> 中包含了 <span class="math inline">\(\mathscr{C}\)</span> 中所有的 <span class="math inline">\(A\to B\)</span> 的箭头, 则称 <span class="math inline">\(\mathscr{S}\)</span> 是 <span class="math inline">\(\mathscr{C}\)</span> 的一个<strong>满子范畴</strong>.</p><h3 id="积范畴-product-category">积范畴: product category</h3><p>设 <span class="math inline">\(\mathscr{C}\)</span> 和 <span class="math inline">\(\mathscr{D}\)</span> 是范畴, 如下定义二者的积范畴 <span class="math inline">\(\mathscr{C}\times\mathscr{D}\)</span>:</p><ol style="list-style-type: decimal"><li><span class="math inline">\(\mathscr{C}\times\mathscr{D}\)</span>-对象: <span class="math inline">\((C,D)\)</span>, 其中 <span class="math inline">\(C,D\)</span> 分别是 <span class="math inline">\(\mathscr{C},\mathscr{D}\)</span> 的对象;</li><li><span class="math inline">\(\mathscr{C}\times\mathscr{D}\)</span>-箭头: <span class="math inline">\((f,g):(C_1,D_1)\to (C_2,D_2)\iff f:C_1\to C_2~\text{in}~\mathscr{C},g:D_1\to D_2~\text{in}~\mathscr{D}\)</span><ol style="list-style-type: decimal"><li>单位箭头: <span class="math inline">\({\rm id}_{(C,D)}=({\rm id}_C,{\rm id}_D)\)</span>;</li><li>复合箭头: <span class="math inline">\((f_1,g_1)\circ (f_2,g_2)=(f_1\circ_\mathscr{C} f_2,g_1\circ_\mathscr{D} g_2)\)</span>.</li></ol></li></ol><h3 id="商范畴-quotient-category">商范畴: quotient category</h3><p>设 <span class="math inline">\(\mathscr{C}\)</span> 是一个范畴, <span class="math inline">\(\sim\)</span> 是其上的一个同余关系, 则 <span class="math inline">\(\mathscr{C}/\sim\)</span> 是一个以 <span class="math inline">\(\mathscr{C}\)</span> 对象为对象, <span class="math inline">\(\sim\)</span> 等价类为箭头的一个范畴.</p><p>例如对于拓扑范畴 <span class="math inline">\({\tt Top}\)</span>, 考虑其上的同伦关系, 所得的商空间 <span class="math inline">\({\tt Top}/\sim\)</span> 称为同伦拓扑范畴, 记作 <span class="math inline">\({\tt hTop}\)</span>.</p><h3 id="箭头范畴-arrow-category">箭头范畴: arrow category</h3><p>设 <span class="math inline">\(\mathscr{C}\)</span> 是一个范畴, 其箭头范畴 <span class="math inline">\(\mathscr{C}^\to\)</span> 定义如下:</p><ol style="list-style-type: decimal"><li><span class="math inline">\(\mathscr{C}^\to\)</span>-对象: <span class="math inline">\(\mathscr{C}\)</span> 中的箭头;</li><li><span class="math inline">\(\mathscr{C}^\to\)</span>-箭头: 对于两个 <span class="math inline">\(\mathscr{C}^\to\)</span> 对象 <span class="math inline">\(f_1, f_2\)</span>, 一个 <span class="math inline">\(\mathscr{C}^\to\)</span> 箭头 <span class="math inline">\(f_1\to f_2\)</span> 是一个使得下图交换的一个二元组 <span class="math inline">\((j,k)\)</span>:<span class="math display">\[\begin{matrix}X_1~~ &amp; \xrightarrow{j} &amp; X_2~~ \\\downarrow \tiny{f_1} &amp; &amp; \downarrow \tiny{f_2} \\Y_1~~ &amp; \xrightarrow{k} &amp; Y_2~~ \\\end{matrix}\]</span><ol style="list-style-type: decimal"><li>单位箭头: <span class="math inline">\(f:X\to Y\)</span> 的单位箭头为 <span class="math inline">\(({\rm id}_X,{\rm id}_Y)\)</span>;</li><li>复合箭头: <span class="math inline">\((j_1,k_1):f_1 \to f_2\)</span> 和 <span class="math inline">\((j_2,k_2):f_2 \to f_3\)</span> 的复合为:<span class="math display">\[(j_2\circ j_1,~k_2\circ k_1):f_1\to f_3.\]</span></li></ol></li></ol><h3 id="切片范畴-slice-category">切片范畴: slice category</h3><p>设 <span class="math inline">\(\mathscr{C}\)</span> 是一个范畴, <span class="math inline">\(I\)</span> 是 <span class="math inline">\(\mathscr{C}\)</span> 的一个对象, 则 <span class="math inline">\(\mathscr{C}\)</span> 在 <span class="math inline">\(I\)</span> 的切片范畴 <span class="math inline">\(\mathscr{C}/I\)</span> 定义如下:</p><ol style="list-style-type: decimal"><li><span class="math inline">\(\mathscr{C}/I\)</span>-对象: 二元组 <span class="math inline">\((A,f)\)</span>, 其中 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(\mathscr{C}\)</span> 的对象, <span class="math inline">\(f:A\to I\)</span> 是 <span class="math inline">\(\mathscr{C}\)</span> 的箭头;</li><li><span class="math inline">\(\mathscr{C}/I\)</span>-箭头: 箭头 <span class="math inline">\((A,f)\to (B,g)\)</span> 是在 <span class="math inline">\(\mathscr{C}\)</span> 中满足 <span class="math inline">\(g\circ j=f\)</span> 的箭头 <span class="math inline">\(j:A\to B\)</span>.<ol style="list-style-type: decimal"><li>单位箭头: 对象 <span class="math inline">\((A,f)\)</span> 的单位箭头是 <span class="math inline">\(\mathscr{C}\)</span> 的单位箭头 <span class="math inline">\({\rm id}_A\)</span>;</li><li>复合箭头: 箭头 <span class="math inline">\(j:(A,f)\to(B,g)\)</span> 和 <span class="math inline">\(k:(B,g)\to(C,h)\)</span> 的复合为 <span class="math display">\[k\circ_{\mathscr{C}/I} j:(A,f)\to(C,h)=k\circ_\mathscr{C} j:A\to C.\]</span></li></ol></li></ol><h2 id="箭头的种类">箭头的种类</h2><p>用范畴的语言来定义单射和满射.</p><h3 id="单态-monomorphism">单态: monomorphism</h3><h4 id="定义">定义</h4><blockquote><p><strong>单态</strong>: 设 <span class="math inline">\(\mathscr{C}\)</span> 是一个范畴, 其中的一个箭头 <span class="math inline">\(f:B\to C\)</span> 是一个单态<strong>当且仅当</strong>它满足左消去律. 即对于 <span class="math inline">\(\forall\)</span> 映射 <span class="math inline">\(g:A\to B,~h:A\to B\)</span>, 有<span class="math display">\[f\circ g=f\circ h\iff g=h.\]</span></p></blockquote><h4 id="例子">例子</h4><ol style="list-style-type: decimal"><li><span class="math inline">\({\tt Set}\)</span> 中的箭头是单态当且仅当其对应的映射是单射;</li><li><span class="math inline">\({\tt Grp}\)</span> 中的箭头是单态当且仅当其对应的同态是单同态;</li><li>单位箭头 <span class="math inline">\({\rm id}_A\)</span> 是单态.</li></ol><h4 id="性质">性质</h4><ol style="list-style-type: decimal"><li>如果 <span class="math inline">\(f,g\)</span> 是单态, 则 <span class="math inline">\(f\circ g\)</span> 是单态;</li><li>如果 <span class="math inline">\(f\circ g\)</span> 是单态, 则 <span class="math inline">\(g\)</span> 是单态.</li></ol><h3 id="满态-epimorphism">满态: epimorphism</h3><h4 id="定义-1">定义</h4><blockquote><p><strong>满态</strong>: 设 <span class="math inline">\(\mathscr{C}\)</span> 是一个范畴, 其中的一个箭头 <span class="math inline">\(f:B\to C\)</span> 是一个满态<strong>当且仅当</strong>它满足右消去律. 即对于 <span class="math inline">\(\forall\)</span> 映射 <span class="math inline">\(g:C\to D,~h:C\to D\)</span>, 有<span class="math display">\[g\circ f=h\circ f\iff g=h.\]</span></p></blockquote><h4 id="例子-1">例子</h4><ol style="list-style-type: decimal"><li><span class="math inline">\({\tt Set}\)</span> 中的箭头是满态当且仅当其对应的映射是满射;</li><li><span class="math inline">\({\tt Grp}\)</span> 中的箭头是满态当且仅当其对应的同态是满同态;</li><li>单位箭头 <span class="math inline">\({\rm id}_A\)</span> 是满态.</li></ol><h4 id="性质-1">性质</h4><ol style="list-style-type: decimal"><li>如果 <span class="math inline">\(f,g\)</span> 是满态, 则 <span class="math inline">\(f\circ g\)</span> 是满态;</li><li>如果 <span class="math inline">\(f\circ g\)</span> 是满态, 则 <span class="math inline">\(f\)</span> 是满态.</li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 范畴论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2017年拓扑学期末考试试卷</title>
      <link href="/2018/01/11/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62017%E5%B9%B4%E6%8B%93%E6%89%91%E5%AD%A6%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7/"/>
      <content type="html"><![CDATA[<h2 id="试题">试题</h2><ol style="list-style-type: decimal"><li><p>叙述 <span class="math inline">\(T_0\)</span>, <span class="math inline">\(T_1\)</span>, <span class="math inline">\(T_2\)</span> 的定义, 并分别举出 <span class="math inline">\(T_0\)</span> 但不 <span class="math inline">\(T_1\)</span>, 以及 <span class="math inline">\(T_1\)</span> 但不 <span class="math inline">\(T_2\)</span> 的空间的例子.</p></li><li><p>在 <span class="math inline">\(X\times X\)</span> 上定义映射 <span class="math inline">\(\Delta: X\rightarrow X\times X,~\Delta(x)=(x,x)\)</span>, 证明: <span class="math inline">\(X\)</span> 是Hausdorff空间当且仅当 <span class="math inline">\(\Delta(X)\)</span> 是 <span class="math inline">\(X\times X\)</span> 的闭集.</p></li><li><p>设 <span class="math inline">\(\mathcal{T}\)</span> 是 <span class="math inline">\(\mathbb{R}^1\)</span> 上的余有限拓扑, 讨论其紧性、连通性和道路连通性.</p></li><li>考虑拓扑群作用 <span class="math inline">\(\mathbb{S}^1\times B^2\to B^2,~(z,w)\mapsto zw\)</span>.<ol style="list-style-type: decimal"><li>求 <span class="math inline">\(B^2\)</span> 中一点 <span class="math inline">\(w\)</span> 的迷向群;</li><li>证明其轨道空间同构于单位闭区间 <span class="math inline">\(I\)</span>.</li></ol></li><li><p><span class="math inline">\(X\)</span> 是道路连通曲面, 证明: 连续映射 <span class="math inline">\(f: X\to T^2\)</span> 零伦当且仅当 <span class="math inline">\(f\)</span> 诱导的同态平凡.</p></li></ol><h2 id="简略解答">简略解答</h2><center><strong>有差错不负任何责任.</strong></center><ol style="list-style-type: decimal"><li>定义参见课本P19: Def 2.28. 例子参见课本 P19: Ex 1, Ex 2.<ol style="list-style-type: decimal"><li><span class="math inline">\(T_0\)</span> 但不 <span class="math inline">\(T_1\)</span>: <span class="math inline">\(X=\{0,1\}\)</span>, <span class="math inline">\(\mathcal{T}=\{\varnothing, \{0\}, X\}\)</span>;</li><li><span class="math inline">\(T_1\)</span> 但不 <span class="math inline">\(T_2\)</span>: <span class="math inline">\(\mathbb{R}^1\)</span> 上的余有限拓扑.</li></ol></li><li><p>题目参见课本 P35 习题3.2 第5题. 解答参见 <a href="http://www.lizhechen.com/2017/10/08/%E6%8B%93%E6%89%91%E5%AD%A6%E9%A2%98%E7%9B%AE/" target="_blank" rel="noopener">Zhechen: 拓扑学题目</a>.</p></li><li><p>紧致, 连通, 且道路连通. 证明略. 参见课本P47 习题3.4 第7题.</p></li><li>简略证明:<ol style="list-style-type: decimal"><li>迷向群平凡, 直接按照定义求即可;</li><li>考虑映射 <span class="math inline">\(f: B^2\to I,~re^{i\theta}\mapsto r\)</span>. 则 <span class="math inline">\(f\)</span> 是紧空间到Hausdorff空间的连续满射, 因而是商映射. 于是 <span class="math inline">\(f/\sim\cong I\)</span>. 只需要研究其轨道空间, 说明轨道空间就是 <span class="math inline">\(X/\sim\)</span> 即可.</li></ol></li><li><p>题目类似于课本 P125 习题6.2 的 1,2 题. 简略解答: 考虑复叠映射 <span class="math inline">\(P: \mathbb{E}^2\to T^2\)</span>. 若诱导的同态平凡, 则 <span class="math inline">\(\mathrm{Im}f_*\subset \mathrm{Im}p_*\)</span>, 因而 <span class="math inline">\(f\)</span> 有提升 <span class="math inline">\(\tilde{f}\)</span>. 又由于 <span class="math inline">\(\mathbb{E}^2\)</span> 是凸集, 故 <span class="math inline">\(\tilde{f}\)</span> 零伦, 故 <span class="math inline">\(f=p\circ\tilde{f}\)</span> 零伦. 反方向略.</p></li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 拓扑学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2017年泛函分析期末考试试卷</title>
      <link href="/2018/01/11/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62017%E5%B9%B4%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7/"/>
      <content type="html"><![CDATA[<h2 id="试题">试题</h2><center><strong>7, 8, 9 题目不保证与原文完全一致.</strong></center><ol style="list-style-type: decimal"><li><p>设 <span class="math inline">\(\mathscr{X}\)</span> 是 <span class="math inline">\(B^*\)</span> 空间, <span class="math inline">\(\mathscr{X}_0\)</span> 是 <span class="math inline">\(\mathscr{X}\)</span> 的子空间, 假定 <span class="math inline">\(\exists c\in(0,1)\)</span>, s.t. <span class="math display">\[\inf\limits_{x\in\mathscr{X}_0}\Vert y-x\Vert\leqslant c\Vert y\Vert\quad (\forall y\in\mathscr{X}).\]</span> 求证: <span class="math inline">\(\mathscr{X}_0\)</span> 在 <span class="math inline">\(\mathscr{X}\)</span> 中稠.</p></li><li><p>设 <span class="math inline">\(M\)</span> 是Hilbert空间 <span class="math inline">\(\mathscr{H}\)</span> 的子集, 求证: <span class="math display">\[(M^\perp)^\perp=\overline{\mathrm{span}M}.\]</span></p></li><li><p>设 <span class="math inline">\(\mathscr{H}\)</span> 是Hilbert空间, <span class="math inline">\(A\in\mathscr{L}(\mathscr{H})\)</span>, 且 <span class="math inline">\(\exists m&gt;0\)</span>, s.t. <span class="math display">\[\vert (Ax,x) \vert\geqslant m\Vert x\Vert^2\quad (\forall x\in\mathscr{H}).\]</span> 求证: <span class="math inline">\(\exists A^{-1}\in\mathscr{L}(\mathscr{H})\)</span>.</p></li><li>设 <span class="math inline">\(\mathscr{X}\)</span> 是复线性空间, <span class="math inline">\(p\)</span> 是 <span class="math inline">\(\mathscr{X}\)</span> 上的半模. <span class="math inline">\(\forall x_0\in\mathscr{X}\)</span>, <span class="math inline">\(p(x_0)\neq 0\)</span>. 求证: 存在 <span class="math inline">\(\mathscr{X}\)</span> 上的线性泛函 <span class="math inline">\(f\)</span> s.t.<ol style="list-style-type: decimal"><li><span class="math inline">\(f(x_0)=1\)</span>;</li><li><span class="math inline">\(\vert f(x)\vert\leqslant p(x)/p(x_0)~(\forall x\in\mathscr{X})\)</span>.</li></ol></li><li><p>设 <span class="math inline">\(\mathscr{X}\)</span> 是 <span class="math inline">\(B^*\)</span> 空间, <span class="math inline">\(E\subset\mathscr{X}\)</span> 是非空均衡闭凸集, <span class="math inline">\(\forall x\in\mathscr{X}\backslash E\)</span>. 求证: <span class="math inline">\(\exists f\in\mathscr{X}^*\)</span> 及 <span class="math inline">\(\alpha&gt;0\)</span>, s.t. <span class="math display">\[\vert f(x)\vert&lt;\alpha&lt;\vert f(x_0)\vert\quad (\forall x\in E).\]</span></p></li><li><p>求证: <span class="math inline">\(B\)</span> 空间是自反的当且仅当其共轭空间是自反的.</p></li><li><p>(不保证与原题完全一致) 设 <span class="math inline">\(\mathscr{X},\mathscr{Y}\)</span> 是Banach空间, 设 <span class="math inline">\(\mathscr{L}(\mathscr{X},\mathscr{Y})\)</span> 是连续线性算子全体, 证明: 一一映射在其中构成一个开集.</p></li><li><p>设 <span class="math inline">\(\mathscr{H}\)</span> 是Hilbert空间, <span class="math inline">\(A,B\in\mathscr{L}(\mathscr{H})\)</span>, 若对 <span class="math inline">\(\forall x,y\in\mathscr{X}\)</span>, 有 <span class="math inline">\((Ax,y)=(x,By)\)</span>, 证明: <span class="math inline">\(A\)</span> 连续.</p></li><li><p>(不保证与原题完全一致) 设 <span class="math inline">\(\mathscr{X}\)</span> 是自反空间, <span class="math inline">\(E\)</span> 是其中的闭凸集, 证明: <span class="math display">\[\exists x_0\in E,~\text{s.t.}~\Vert x_0\Vert=\inf\limits_{x\in E}\Vert x\Vert.\]</span></p></li></ol><h2 id="部分简略解答">部分简略解答</h2><center><strong>7, 8, 9 解答不保证正确性.</strong></center><ol style="list-style-type: decimal"><li><p>用 F.Riesz 引理, 参见习题1.4.13;</p></li><li><p>参见习题1.6.5;</p></li><li><p>用 Banach 逆映射定理, 参见习题2.3.3;</p></li><li><p>用复 Hahn-Banach 定理, 参见习题2.4.3;</p></li><li><p>用 Ascoli 定理, 参见习题2.4.10;</p></li><li><p>利用自然映射和共轭算子, 参见习题2.5.5;</p></li><li><p>对于 <span class="math inline">\(T\in\mathscr{L}(\mathscr{X},\mathscr{Y})\)</span>, 取 <span class="math inline">\(\epsilon&lt; \inf\limits_{x\in B(0,1)}\Vert Tx\Vert\)</span> 即可.</p></li><li><p>由闭图像定理, 只需证明 <span class="math inline">\(A\)</span> 是闭算子且定义域闭. 考虑到定义域 <span class="math inline">\(\mathscr{H}\)</span> 显然闭, 只需要证明 <span class="math inline">\(A\)</span> 是闭算子. 取 <span class="math inline">\(x_n\to x\in \mathscr{H}\)</span>, 设 <span class="math inline">\(Ax_n\to z\)</span>, 则只需证 <span class="math inline">\(Ax=z\)</span>. (由闭算子的定义即可得, 参见课本P96: Def 2.3.9) <strong>一方面</strong>, 由内积的连续性, 即有 <span class="math inline">\((Ax_n,y)\to (z,y)\)</span>. 而<strong>另一方面</strong>又由条件有 <span class="math inline">\((Ax_n,y)=(x_n,By)\to (x,By)=(Ax,y)\)</span>. 于是由极限的唯一性即有 <span class="math inline">\(Ax=y\)</span>, 得证.</p></li><li><p>(瞎写的) 设 <span class="math inline">\(d=\inf\limits_{x\in E}\Vert x\Vert\)</span>, 由定义可取 <span class="math inline">\(x_n\in E\)</span>, s.t. <span class="math inline">\(d&lt;\Vert x_n\Vert&lt;d+\frac{1}{n}\)</span>. 由于自反空间中闭集是弱自列紧的, 取其收敛子列的弱极限即可.</p></li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 泛函分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>拓扑学复习重点</title>
      <link href="/2018/01/08/%E6%8B%93%E6%89%91%E5%AD%A6%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/"/>
      <content type="html"><![CDATA[<h2 id="点集拓扑">点集拓扑</h2><h3 id="拓扑空间">拓扑空间</h3><h4 id="拓扑空间-1">拓扑空间</h4><ul><li>拓扑: 包含全集和空集, 对任意并和有限交封闭的集类;</li><li>开集: 拓扑中包含的集合为开集.</li></ul><h4 id="几个拓扑的例子">几个拓扑的例子</h4><ol style="list-style-type: decimal"><li><p><strong>平凡拓扑</strong>: <span class="math inline">\(\{\varnothing, X\}\)</span>(最粗拓扑);</p></li><li><p><strong>离散拓扑</strong>: <span class="math inline">\(\{U: U\subset X\}\)</span>(最细拓扑);</p></li><li><p><strong>欧式拓扑</strong>: <span class="math inline">\(\{U: x\in U\Leftrightarrow B(x,\delta)\subset U\}\)</span>;</p></li><li><p><strong>余有限拓扑</strong>: <span class="math inline">\(\{U: U=\varnothing 或 U^c 是有限集\}\)</span>(类似有余可数拓扑).</p></li></ol><h3 id="邻域与开集">邻域与开集</h3><h4 id="邻域">邻域</h4><p>对于包含 <span class="math inline">\(x\)</span> 的集合 <span class="math inline">\(N\)</span>, 若存在开集 <span class="math inline">\(O\)</span>, s.t. <span class="math inline">\(x\in O\subset N\)</span>, 则称 <span class="math inline">\(N\)</span> 是 <span class="math inline">\(x\)</span> 的邻域.</p><blockquote><p><strong>命题</strong> 设 <span class="math inline">\(X\)</span> 是拓扑空间, 则 <span class="math inline">\(W\)</span> 是 <span class="math inline">\(X\)</span> 的开集当且仅当 <span class="math inline">\(W\)</span> 是其中每点的邻域.</p></blockquote><h4 id="闭集">闭集</h4><p>开集的补集称为闭集, 由此可以立刻得到:</p><ul><li>闭集对任意交和有限并封闭;</li><li>全集和空集是闭集;</li></ul><h4 id="导集">导集</h4><ul><li><strong>聚点</strong>: 若 <span class="math inline">\(p\)</span> 的任意邻域都包含 <span class="math inline">\(A-\{p\}\)</span> 中的至少一点, 则称 <span class="math inline">\(p\)</span> 为 <span class="math inline">\(A\)</span> 的聚点;</li><li><strong>导集</strong>: <span class="math inline">\(A\)</span> 的聚点全体称为 <span class="math inline">\(A\)</span> 的导集, 记作 <span class="math inline">\(A&#39;\)</span>;</li><li><strong>闭包</strong>: <span class="math inline">\(\overline{A}=A\cup A&#39;\)</span>.</li></ul><p>一个例子: <span class="math display">\[A=\{(x,\sin(\frac{\pi}{x}))~\vert~0&lt;x\leqslant 1\},\quad B=\{(0,y)~\vert~-1\leqslant y\leqslant 1\}\Rightarrow \]</span></p><p>关于闭集, 容易得到下列命题:</p><blockquote><p><strong>命题</strong> <span class="math inline">\(A\)</span> 闭 <span class="math inline">\(\iff\)</span> <span class="math inline">\(\overline{A}=A\)</span>.</p></blockquote><h4 id="拓扑基">拓扑基</h4><ul><li>拓扑基: 设 <span class="math inline">\(X\)</span> 是拓扑空间, <span class="math inline">\(\mathcal{B}\)</span> 是一组开集, s.t. <span class="math inline">\(X\)</span> 中的任意非空开集可以写成 <span class="math inline">\(\mathcal{B}\)</span> 中集合的并, 则称 <span class="math inline">\(\mathcal{B}\)</span> 为该拓扑的一组拓扑基;</li><li>拓扑基的定义等价于 <span class="math inline">\(\forall x\in X\)</span> 以及 <span class="math inline">\(x\)</span> 的开邻域 <span class="math inline">\(N\)</span>, <span class="math inline">\(\exists B\in\mathcal{B}\)</span>, s.t. <span class="math inline">\(x\in B\subset N\)</span>.</li></ul><p>关于拓扑基有如下定理:</p><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\mathcal{B}\)</span> 是集合 <span class="math inline">\(X\)</span> 的子集构成的子集类, s.t. 1. 设 <span class="math inline">\(U_1,U_2\in\mathcal{B}\)</span>, <span class="math inline">\(\forall x\in U_1\cap U_2\)</span>, <span class="math inline">\(\exists V\in \mathcal{B}\)</span>, s.t. <span class="math inline">\(x\in V\subset U_1\cap U_2;\)</span> 2. <span class="math inline">\(\mathcal{B}\)</span> 覆盖 <span class="math inline">\(X\)</span>. 则 <span class="math inline">\(\mathcal{B}\)</span> 是 <span class="math inline">\(X\)</span> 中某个拓扑的拓扑基.</p></blockquote><h4 id="子空间拓扑">子空间拓扑</h4><ul><li><strong>子空间拓扑</strong>: 子空间中的开集是全空间中开集与 <span class="math inline">\(A\)</span> 的交.</li><li>子空间中的闭集也是全空间中闭集与 <span class="math inline">\(A\)</span> 的交.</li><li>子空间中的开集也是全空间中的开集.</li></ul><h3 id="连续性">连续性</h3><h4 id="连续性-1">连续性</h4><ul><li><strong>连续性</strong>: 开集的原像是开集.</li></ul><h4 id="关于与连续性等价的几个命题">关于与连续性等价的几个命题</h4><ol style="list-style-type: decimal"><li>开集的原像是开集;</li><li>拓扑基中集合的原像是开集;</li><li>闭集的原像是闭集.</li></ol><h4 id="连续性的其他结论">连续性的其他结论</h4><ol style="list-style-type: decimal"><li>连续映射的复合映射连续;</li><li>连续映射在子空间的限制连续;</li></ol><h4 id="同胚">同胚</h4><ul><li><strong>同胚</strong>: 若连续映射 <span class="math inline">\(f: X\to Y\)</span> 是 <span class="math inline">\(1-1\)</span> 映射且 <span class="math inline">\(f^{-1}\)</span> 连续, 则称其为同胚.</li></ul><p>关于同胚有以下等价命题:</p><ol style="list-style-type: decimal"><li><span class="math inline">\(f\)</span> 是同胚;</li><li><span class="math inline">\(f\)</span> 是连续的一一映射并且是开映射;</li><li><span class="math inline">\(f\)</span> 是连续的一一映射并且是闭映射.</li></ol><h3 id="分离性">分离性</h3><h4 id="分离性-1">分离性</h4><ul><li><span class="math inline">\(T_0\)</span>: 任意一点与另一点分离;</li><li><span class="math inline">\(T_1\)</span>: 任意两点互相分离 <span class="math inline">\(\Leftrightarrow\)</span> 单点集是闭集;</li><li><span class="math inline">\(T_2\)</span>: 任意两点存在各自的开邻域不相交(Hausdorff);</li><li><span class="math inline">\(T_3\)</span>: 任意闭集与其外一点存在开邻域不相交;</li><li><span class="math inline">\(T_4\)</span>: 任意两个不相交闭集存在各自开邻域不相交.</li></ul><p>一些分离性的例子如下:</p><ol style="list-style-type: decimal"><li><p><span class="math inline">\(X=\{0,1\}\)</span>, <span class="math inline">\(\mathcal{T}=\{X,\varnothing,\{0\}\}\)</span>: 是 <span class="math inline">\(T_0\)</span> 但不是 <span class="math inline">\(T_1\)</span>;</p></li><li><p><span class="math inline">\(\mathbb{R}^1\)</span> 上的余有限拓扑是 <span class="math inline">\(T_1\)</span> 但不是 <span class="math inline">\(T_2\)</span>.</p></li></ol><p>对于Hausdorff空间还有如下命题:</p><blockquote><p><strong>命题</strong> Hausdorff空间 <span class="math inline">\(X\)</span> 是 <span class="math inline">\(T_3\)</span> 的当且仅当对于 <span class="math inline">\(\forall x\)</span> 以及 <span class="math inline">\(U_x\)</span>, <span class="math inline">\(\exists V_x\)</span>, s.t. <span class="math display">\[x\in V\subset\overline{V}\subset U.\]</span></p></blockquote><h4 id="tietze-扩张定理">Tietze 扩张定理</h4><blockquote><p><strong>Urysohn引理</strong> 设 <span class="math inline">\(X\)</span> 是Hausdorff空间, 则 <span class="math inline">\(X\)</span> 是 <span class="math inline">\(T_4\)</span> 的当且仅当对于 <span class="math inline">\(X\)</span> 内任意不相交的闭集 <span class="math inline">\(A,B\)</span>, 存在 <span class="math inline">\(X\)</span> 上的连续实函数 <span class="math inline">\(f\)</span>, s.t. <span class="math display">\[f\vert_A=1,~f\vert_B=-1,~-1 &lt; f\vert_{X-(A\cup B)} &lt; 1.\]</span></p></blockquote><p>进一步有 Tietze 扩张定理:</p><blockquote><p><strong>Tietze扩张定理</strong> 设 <span class="math inline">\(X\)</span> 是Hausdorff空间, 则 <span class="math inline">\(X\)</span> 是 <span class="math inline">\(T_4\)</span> 的当且仅当对于 <span class="math inline">\(X\)</span> 内任意闭子集 <span class="math inline">\(A\)</span> 及任意连续函数 <span class="math inline">\(f: A\to \mathbb{E}^1\)</span>, 存在连续函数 <span class="math inline">\(g: X\to \mathbb{E}^1\)</span>, s.t. <span class="math inline">\(g\vert_A=f\)</span>. 进一步, 若在 <span class="math inline">\(A\)</span> 上有 <span class="math inline">\(\vert f\vert\leqslant M\)</span>, 则可做到 <span class="math inline">\(\vert g\vert\leqslant M\)</span>.</p></blockquote><h3 id="紧致性">紧致性</h3><h4 id="紧致性-1">紧致性</h4><ul><li><strong>紧致性</strong>: 任意开覆盖含有限子覆盖.</li></ul><blockquote><p><strong>Heine-Borel定理</strong> <span class="math inline">\(\mathbb{E}^1\)</span> 上的闭区间是紧集.</p></blockquote><ul><li>紧致空间的闭子集是紧的.</li><li>Hausdorff空间中的紧集是闭集.</li><li>紧空间到Hausdorff空间的既单又满的连续映射是同胚.</li></ul><blockquote><p><strong>Bolzano-Weierstrass定理</strong> 紧空间的无穷点集必有聚点.</p></blockquote><h4 id="局部紧致">局部紧致</h4><ul><li>局部紧致: <span class="math inline">\(\forall x\in X\)</span>, 存在 <span class="math inline">\(x\)</span> 的紧致邻域.</li><li>紧致 <span class="math inline">\(\Rightarrow\)</span> 局部紧.</li></ul><h3 id="乘积空间">乘积空间</h3><h4 id="乘积拓扑">乘积拓扑</h4><ul><li>开集 <span class="math inline">\(\times\)</span> 开集 构成一组拓扑基 <span class="math inline">\(\mathcal{B}\)</span>;</li><li>乘积拓扑: <span class="math inline">\(\mathcal{B}\)</span> 决定的拓扑称为乘积拓扑.</li></ul><h4 id="自然投影">自然投影</h4><p>称映射 <span class="math display">\[p_1: X\times Y\to X,~(x,y)\to x;\]</span> <span class="math display">\[p_2: X\times Y\to X,~(x,y)\to y;\]</span> 为自然投影.</p><ul><li><span class="math inline">\(X\times Y\)</span> 的乘积拓扑是使得自然投影都连续的最粗拓扑;</li><li><span class="math inline">\(f:Z\to X\times Y\)</span> 连续 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(p_1\circ f\)</span> 和 <span class="math inline">\(p_2\circ f\)</span> 都连续;</li><li><span class="math inline">\(X\times Y\)</span> 是Hausdorff空间当且仅当 <span class="math inline">\(X\)</span>, <span class="math inline">\(Y\)</span> 都是Hausdorff空间;</li><li><span class="math inline">\(X\times Y\)</span> 紧致当且仅当<span class="math inline">\(X\)</span>, <span class="math inline">\(Y\)</span> 都紧致.</li></ul><h3 id="连通性">连通性</h3><h4 id="连通性-1">连通性</h4><p>以下命题等价:</p><ol style="list-style-type: decimal"><li><span class="math inline">\(X\)</span> 连通;</li><li><span class="math inline">\(X\)</span> 内既开又闭的子集只有 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(\varnothing\)</span>;</li><li><span class="math inline">\(X\)</span> 不能表示为两个不相交的非空开集的并;</li><li>不存在从 <span class="math inline">\(X\)</span> 到多于一点的离散拓扑空间的连续满射.</li></ol><blockquote><p><strong>命题</strong> <span class="math inline">\(\mathbb{E}^1\)</span> 的非空子集连通当且仅当它是一个区间.</p></blockquote><p>关于连通还有如下命题:</p><ul><li>连通空间的连续像连通;</li><li><span class="math inline">\(X\times Y\)</span> 连通当且仅当 <span class="math inline">\(X\)</span>, <span class="math inline">\(Y\)</span> 都连通;</li></ul><h4 id="连通分支">连通分支</h4><ul><li><strong>连通分支</strong>: 极大连通子集.</li></ul><p>有如下例子:</p><ul><li>离散拓扑空间的每一个点是一个连通分支;</li><li>有理数作为欧氏空间的子空间, 每个点是一个连通分支.</li></ul><blockquote><p><strong>中间值定理</strong> 设 <span class="math inline">\(f: X\to\mathbb{E}^1\)</span> 是一个连续函数, 若 <span class="math inline">\(f\)</span> 可以取到 <span class="math inline">\(a,b\)</span>, 则 <span class="math inline">\(f\)</span> 可以取到 <span class="math inline">\(a,b\)</span> 中间的任何值.</p></blockquote><h4 id="局部连通">局部连通</h4><ul><li>局部连通: 任意 <span class="math inline">\(x\)</span>, 任意 <span class="math inline">\(x\)</span> 的邻域 <span class="math inline">\(U\)</span>, 存在连通邻域 <span class="math inline">\(V\)</span>, s.t. <span class="math inline">\(x\in V\subset U\)</span>.</li><li>连通未必局部连通. (例子: <span class="math inline">\((x,\sin(\frac{\pi}{x}))\)</span>)</li></ul><h3 id="道路连通性">道路连通性</h3><h4 id="道路">道路</h4><ul><li><strong>道路</strong>: 连续映射 <span class="math inline">\(\alpha: I\to X\)</span>: 起点为 <span class="math inline">\(\alpha(0)\)</span>, 终点为 <span class="math inline">\(\alpha(1)\)</span>.</li><li><strong>逆道路</strong>: <span class="math inline">\(\overline{\alpha}(t)=\alpha(1-t)\)</span>.</li><li><strong>道路的乘积</strong>: 设 <span class="math inline">\(\alpha: x\to y\)</span>, <span class="math inline">\(\beta: y\to z\)</span>, 定义 <span class="math display">\[\gamma(t)=\begin{cases} \alpha(2t), &amp; 0\leqslant t\leqslant\frac{1}{2}, \\\\ s\beta(2t-1), &amp; \frac{1}{2}\leqslant t\leqslant 1, \end{cases}\]</span> 则 <span class="math inline">\(\gamma\)</span> 为 <span class="math inline">\(\alpha\)</span> 与 <span class="math inline">\(\beta\)</span> 的乘积道路.</li><li><strong>道路的连续像是道路</strong>: <span class="math inline">\(f: X\to Y\)</span> 连续, 则 <span class="math inline">\(f\circ \alpha\)</span> 是 <span class="math inline">\(Y\)</span> 中的道路.</li></ul><h4 id="道路连通">道路连通</h4><ul><li><strong>道路连通空间</strong>: 任意两点都有道路连接的空间;</li><li><strong>道路连通空间必定是连通的</strong> (反证法: 若不然, 则与 <span class="math inline">\(I\)</span> 的连通性矛盾);</li><li><strong>连通空间未必道路连通</strong>: <span class="math inline">\(\sin(x,\sin(\frac{\pi}{x}))\)</span> (证明 <span class="math inline">\((0,0)\)</span> 与 <span class="math inline">\((1,0)\)</span> 之间无道路);</li><li><strong>道路连通分支</strong>: 极大道路连通子集.</li></ul><h4 id="局部道路连通">局部道路连通</h4><ul><li>局部道路连通: 任意 <span class="math inline">\(x\)</span>, 任意 <span class="math inline">\(x\)</span> 的邻域 <span class="math inline">\(U\)</span>, 存在道路连通邻域 <span class="math inline">\(V\)</span>, s.t. <span class="math inline">\(x\in V\subset U\)</span>;</li><li>道路连通未必局部道路连通. (例子: <span class="math inline">\((\frac{1}{n},t)\cup (0,t)\cup (t,0)~t\in I\)</span>)</li><li>连通+局部道路连通 <span class="math inline">\(\Rightarrow\)</span> 道路连通.</li></ul><h3 id="商空间">商空间</h3><h4 id="商空间-1">商空间</h4><ul><li><strong>商空间</strong>: 设 <span class="math inline">\(X\)</span> 上有等价关系, 则可定义商空间 <span class="math inline">\(Y=X/\sim\)</span> (把一个等价类捏成一点);</li><li><strong>投影映射</strong>: <span class="math inline">\(\pi: X\to Y\)</span>, <span class="math inline">\(x\mapsto [x]\)</span>;</li><li><strong>商拓扑</strong>: 在商空间 <span class="math inline">\(Y\)</span> 定义拓扑: <span class="math display">\[U\subset Y 是开集 \Leftrightarrow \pi^{-1}(U) 是 X 中的开集\]</span> 则称该拓扑为 <span class="math inline">\(Y\)</span> 上的商拓扑;</li></ul><p>关于商空间, 一个重要的性质如下:</p><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(X\)</span> 是拓扑空间, <span class="math inline">\(Y\)</span> 是 <span class="math inline">\(X\)</span> 的商空间, <span class="math inline">\(Z\)</span> 是任意空间, 则: <span class="math display">\[f: Y\to Z ~连续~\Leftrightarrow~f\circ\pi: X\to Z~连续.\]</span></p></blockquote><h4 id="商空间的例子">商空间的例子</h4><p><span class="math inline">\(I^2\)</span> 上商空间的几个例子如下:</p><ol style="list-style-type: decimal"><li>平环 <span class="math inline">\(S^1\times I\)</span>: <span class="math inline">\((0,y)\sim(1,y)\)</span>;</li><li>Mobius带: <span class="math inline">\((0,y)\sim(1,1-y)\)</span>.</li><li>球面 <span class="math inline">\(\mathbb{S}^2\)</span>: <span class="math inline">\((0,y)\sim(1,y)\sim(x,0)\sim(x,1)~\forall x,y\)</span>.</li></ol><p>粘合两组对边可得环面 <span class="math inline">\(T^2\)</span> 和Klein瓶:</p><ol style="list-style-type: decimal"><li>环面 <span class="math inline">\(T^2\)</span>: <span class="math inline">\((x,0)\sim (x,1)\)</span>, <span class="math inline">\((0,y)\sim (1,y)\)</span>; (<span class="math inline">\(T^2\cong \mathbb{S}^1\times\mathbb{S}^1\)</span>)</li><li>Klein瓶: <span class="math inline">\((x,0)\sim (x,1)\)</span>, <span class="math inline">\((0,y)\sim (1,1-y)\)</span>.</li></ol><p>在 <span class="math inline">\(S^n\)</span> 上, 重要的商空间是实投影空间:</p><ol style="list-style-type: decimal"><li>实投影空间 <span class="math inline">\(\mathbb{P}^n\)</span>: <span class="math inline">\(x\sim -x\)</span>, <span class="math inline">\(\forall x\in\mathbb{S}^n\)</span>.</li></ol><h4 id="商映射">商映射</h4><p><strong>商映射</strong>: <span class="math inline">\(f\)</span> 是连续满射, 且 <span class="math inline">\(U\subset Y\)</span> 是开集 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(f^{-1}(U)\subset X\)</span> 是开集, 则称 <span class="math inline">\(f\)</span> 是商映射.</p><p>有如下命题:</p><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(f: X\to Y\)</span> 是商映射, 则 1. 映射 <span class="math inline">\(g: Y\to Z\)</span> 连续 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(g\circ f: X\to Z\)</span> 连续; 2. <span class="math inline">\(Y\cong X/\sim\)</span>.</p></blockquote><p>关于商映射的判断, 有如下两条常见的定理:</p><ol style="list-style-type: decimal"><li><strong>连续满射若同时是开映射或闭映射, 则是商映射</strong>;</li><li><strong>紧空间到Hausdorff空间的连续满射是商映射</strong>.</li></ol><h4 id="拓扑锥与双角锥">拓扑锥与双角锥</h4><ul><li>拓扑锥: <span class="math inline">\(X\times I\)</span> 上定义 <span class="math display">\[(x,1)\sim (x&#39;,1),~\forall x,x&#39;\in X;\]</span> <span class="math display">\[(x,t)\sim(x,t), ~\forall x,\forall t&lt;1.\]</span> 而成的商空间称为 <span class="math inline">\(X\)</span> 的拓扑锥, 记作 <span class="math inline">\(CX\)</span>.</li></ul><p>容易知道 <span class="math inline">\(C\mathbb{S}^{n-1}\cong B^n\)</span>.</p><ul><li>双角锥: <span class="math inline">\(X\times[-1,1]\)</span> 上定义 <span class="math display">\[(x,1)\sim(x&#39;,1),~\forall x,x&#39;\]</span> <span class="math display">\[(x,-1)\sim(x&#39;,-1),~\forall x,x&#39;\]</span> <span class="math display">\[(x,t)\sim (x,t), \text{otherwise}.\]</span></li></ul><p>容易知道 <span class="math inline">\(S\mathbb{S}^{n-1}\cong \mathbb{S}^n\)</span>.</p><h3 id="拓扑群与轨道空间">拓扑群与轨道空间</h3><h4 id="拓扑群">拓扑群</h4><ul><li><strong>拓扑群</strong>: 设 <span class="math inline">\(G\)</span> 是一个Hausdorff空间, 同时也是一个群. 若 <span class="math inline">\(G\)</span> 的乘法和求逆都连续, 则称 <span class="math inline">\(G\)</span> 为拓扑群.</li><li><strong>子群</strong>: 子空间+子群.</li><li><strong>同态</strong>: 连续+同态. (同构=同胚+同构).</li></ul><p>拓扑群的例子:</p><ol style="list-style-type: decimal"><li>四元数空间 <span class="math inline">\(\mathbb{H}=\mathbb{C}^2\)</span>;</li><li>一般线性群 <span class="math inline">\(GL(n,\mathbb{R})\subset \mathbb{E}^{n^2}\)</span>.</li><li>正交群 <span class="math inline">\(O(n)\)</span>, <span class="math inline">\(SO(n)\)</span> 和 酉群 <span class="math inline">\(U(n)\)</span>, <span class="math inline">\(SU(n)\)</span>.</li></ol><h4 id="拓扑群作用">拓扑群作用</h4><ul><li>拓扑群作用: 连续映射 <span class="math inline">\(\phi: G\times X\to X\)</span>, s.t.</li></ul><ol style="list-style-type: decimal"><li><span class="math inline">\(\phi(hg,x)=\phi(h,\phi(g,x))\)</span>, <span class="math inline">\(\forall g,h,x\)</span>;</li><li><span class="math inline">\(\phi(e,x)=x\)</span>, <span class="math inline">\(\forall x\)</span></li></ol><p>可以简写为:</p><ol style="list-style-type: decimal"><li><span class="math inline">\((hg)x=h(gx)\)</span>;</li><li><span class="math inline">\(ex=x\)</span>.</li></ol><h4 id="轨道空间">轨道空间</h4><ul><li><strong>轨道</strong>: <span class="math inline">\(O(x)=\{gx~\vert~g\in G\}\)</span>, 显然轨道相交等价于轨道重合;</li><li><strong>轨道空间</strong>: <span class="math inline">\(x\sim y: O(x)=O(y)\)</span>. 记作 <span class="math inline">\(X/G\)</span>.</li><li><strong>可迁作用</strong>: <span class="math inline">\(\forall x,y\in X\)</span>, <span class="math inline">\(\exists g\in G\)</span>, s.t. <span class="math inline">\(gx=y\)</span>;</li><li><strong>自由作用</strong>: <span class="math inline">\(\forall g\neq h\in G\)</span>, <span class="math inline">\(\forall x\in X\)</span>, <span class="math inline">\(gx\neq hx\)</span>.</li><li><strong>迷向群</strong>: <span class="math inline">\(G_x=\{g\in G~\vert~gx=x\}\subset G\)</span>.</li></ul><blockquote><p><span class="math inline">\(G\)</span> 是自由作用当且仅当每点的迷向群是平凡群.</p></blockquote><p>关于轨道空间的连通性有如下命题:</p><blockquote><p><strong>命题</strong> 设 <span class="math inline">\(G\)</span> 是拓扑群, 作用于 <span class="math inline">\(X\)</span> 上. 若 <span class="math inline">\(G\)</span> 与 <span class="math inline">\(G/X\)</span> 连通, 则 <span class="math inline">\(X\)</span> 连通. 反证法: 取开集 <span class="math inline">\(X=A\cup B\)</span>, 则 <span class="math inline">\(U=\pi(A)\cap\pi(B)\)</span> 非空, 取 <span class="math inline">\([p]\in U\)</span>, 考虑 <span class="math inline">\(O_p\)</span> 的连通性即可得结论.</p></blockquote><h2 id="代数拓扑">代数拓扑</h2><h3 id="映射与空间的同伦">映射与空间的同伦</h3><h4 id="映射的同伦">映射的同伦</h4><ul><li><strong>映射同伦</strong>: 设 <span class="math inline">\(X,Y\)</span> 是拓扑空间, <span class="math inline">\(f,g:X\to Y\)</span> 是连续映射, 则 <span class="math inline">\(f\)</span> 到 <span class="math inline">\(g\)</span> 的同伦是指连续映射 <span class="math display">\[F: X\times I\to Y,~\text{s.t.}~F(x,0)=f(x),~F(x,1)=g(x).\]</span> 此时称 <span class="math inline">\(f\)</span> 与 <span class="math inline">\(g\)</span> 同伦, 记作 <span class="math inline">\(f\underset{F}{\simeq} g\)</span>.</li><li><strong>相对子集的同伦</strong>: 若对于 <span class="math inline">\(A\subset X\)</span> 有 <span class="math display">\[F(a,t)=f(a),~\forall a\in A,t\in I,\]</span> 则称 <span class="math inline">\(f\)</span> 与 <span class="math inline">\(g\)</span> 相对于 <span class="math inline">\(A\)</span> 同伦, 记作 <span class="math inline">\(f\underset{F}{\simeq} g, rel A\)</span>.</li><li><strong>线性同伦</strong>: <span class="math inline">\(C\)</span> 是 <span class="math inline">\(\mathbb{E}^n\)</span> 中的凸集, 映射 <span class="math inline">\(f,g: X\to C\)</span> 连续, 取 <span class="math display">\[F(x,t)=(1-t)f(x)+tg(x),\]</span> 则 <span class="math inline">\(f\underset{F}{\simeq} g\)</span>.</li><li><strong>零伦</strong>: 同伦于常值映射的映射称为是零伦的. <strong><span class="math inline">\(X\)</span> 到 <span class="math inline">\(\mathbb{E}^n\)</span> 中凸集的连续映射是零伦的.</strong></li><li><strong>环路</strong>: <span class="math inline">\(\alpha: I\to X\)</span> 是一条道路, 且 <span class="math inline">\(\alpha(0)=\alpha(1)=p\)</span>, 则称 <span class="math inline">\(\alpha\)</span> 是以 <span class="math inline">\(p\)</span> 为基点的环路.</li><li><strong>保基点同伦</strong>: <span class="math inline">\(\alpha\simeq \beta,~rel\{0,1\}\)</span>.</li></ul><h4 id="空间的同伦等价">空间的同伦等价</h4><ul><li><strong>同伦等价</strong>: 存在连续映射 <span class="math display">\[f: X\to Y,\quad g:Y\to X,\]</span> s.t. <span class="math display">\[g\circ f\simeq id_X: X\to X,\quad f\circ g\simeq Y\to Y.\]</span> 则称 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 同伦等价, 记作 <span class="math inline">\(X\simeq Y\)</span>.</li></ul><p>几个例子如下:</p><ol style="list-style-type: decimal"><li><span class="math inline">\(\mathbb{E}^n-\{0\}\simeq\mathbb{S}^{n-1}\)</span>, <span class="math inline">\(f(x)=\frac{x}{\Vert x\Vert}\)</span>, <span class="math inline">\(g(x)=x\)</span>;</li><li><span class="math inline">\(CX\simeq \{p(锥顶)\}\)</span>, <span class="math inline">\(f(x)=p\)</span>, <span class="math inline">\(g(p)\)</span> 为包含映射.</li></ol><h4 id="收缩">收缩</h4><ul><li><strong>可缩空间</strong>: 与单点同伦等价的空间;</li><li><strong>收缩核</strong>: <span class="math inline">\(A\subset X\)</span>, 若存在连续映射 <span class="math inline">\(r: X\to A\)</span>, s.t. <span class="math inline">\(r\vert_A=id_A\)</span>, 则称 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(X\)</span> 的收缩核;</li><li><strong>形变收缩</strong>: <span class="math inline">\(A\subset X\)</span>, <span class="math inline">\(i: A\to X\)</span> 是包含映射, <span class="math inline">\(r\)</span> 是 <span class="math inline">\(X\)</span> 到 <span class="math inline">\(A\)</span> 的收缩. 若 <span class="math inline">\(id_X\underset{F}{\simeq} i\circ r\)</span>, 则称 <span class="math inline">\(F\)</span> 是 <span class="math inline">\(X\)</span> 到 <span class="math inline">\(A\)</span> 的形变收缩, <span class="math inline">\(A\)</span> 是 <span class="math inline">\(X\)</span> 的形变收缩核;</li><li><strong>强形变收缩</strong>: 若 <span class="math inline">\(id_X\underset{F}{\simeq} i\circ r,~rel A\)</span> 则称 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(X\)</span> 的强形变收缩核.</li></ul><blockquote><p><strong>命题</strong> <span class="math inline">\(X\)</span> 可缩 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(X\)</span> 可形变收缩到其中一点.</p></blockquote><p>几个例子: 1. <span class="math inline">\(\mathbb{S}^1\)</span> 是平环和Mobius带的强形变收缩核; 2. <span class="math inline">\(\mathbb{S}^{n-1}\)</span> 是 <span class="math inline">\(\mathbb{E}^n-\{0\}\)</span> 的强形变收缩核.</p><h3 id="基本群">基本群</h3><h4 id="基本群-1">基本群</h4><ul><li><strong>基本群</strong>: 拓扑空间上以 <span class="math inline">\(p\)</span> 点为基点的环路的保基点同伦类关于同伦类的乘积构成一个群, 称为基本群 <span class="math inline">\(\pi_1(X,p)\)</span>. &gt; <strong>道路连通空间的基本群</strong> 若 <span class="math inline">\(X\)</span> 道路连通, 则 <span class="math inline">\(\pi_1(X,p)\cong \pi_1(X,q)\)</span>, <span class="math inline">\(\forall p,q\)</span>.</li></ul><h4 id="基本群的不变性">基本群的不变性</h4><p>设 <span class="math inline">\(f: X\to Y\)</span> 连续, 且 <span class="math inline">\(f(p)=q\)</span>, 则 <span class="math inline">\(f\)</span> 可以诱导映射 <span class="math display">\[g: \pi_1(X,p)\to \pi_1(Y,q),~\langle\alpha\rangle\mapsto \langle f\circ\alpha\rangle.\]</span> 且由 <span class="math display">\[g\circ(\alpha\cdot\beta)=(f\circ\alpha)\cdot(f\circ\beta)\]</span> 可知 <span class="math inline">\(g\)</span> 是同态.</p><h4 id="乘积空间的基本群">乘积空间的基本群</h4><blockquote><p><strong>命题</strong> 若 <span class="math inline">\(X,Y\)</span> 道路连通, 则 <span class="math display">\[\pi_1(X\times Y,(x_0,y_0))\cong \pi_1(X,x_0)\times \pi_1(Y,y_0).\]</span></p></blockquote><h3 id="mathbbsn-的基本群"><span class="math inline">\(\mathbb{S}^n\)</span> 的基本群</h3><h4 id="道路提升定理">道路提升定理</h4><blockquote><p><strong>道路提升</strong> <span class="math inline">\(\alpha\)</span> 是 <span class="math inline">\(\mathbb{S}^1\)</span> 内以 <span class="math inline">\(1\)</span> 为起点的道路, 则存在 <span class="math inline">\(\mathbb{E}^1\)</span> 中唯一一条以 <span class="math inline">\(0\)</span> 为起点的道路<span class="math inline">\(\tilde{\alpha}\)</span>, s.t. <span class="math inline">\(\pi\circ\tilde{\alpha}=\alpha\)</span>.</p></blockquote><h4 id="同伦提升定理">同伦提升定理</h4><blockquote><p><strong>同伦提升</strong> <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(\beta\)</span> 是 <span class="math inline">\(\mathbb{S}^1\)</span> 中的两条道路, 且 <span class="math inline">\(\exists F:I\times I\to \mathbb{S}^1\)</span>, s.t. <span class="math inline">\(\alpha\underset{F}{\simeq}\beta\)</span>, 若 <span class="math inline">\(\alpha\)</span> 有提升, 则 <span class="math inline">\(F\)</span> 有唯一提升 <span class="math inline">\(\tilde{F}: I\times I\to\mathbb{E}^1\)</span>, s.t. <span class="math inline">\(\tilde{F}(0,0)=0\)</span>.</p></blockquote><h4 id="mathbbsn-的基本群-1"><span class="math inline">\(\mathbb{S}^n\)</span> 的基本群</h4><ol style="list-style-type: decimal"><li><span class="math inline">\(\mathbb{S}^1\)</span> 的基本群为 <span class="math inline">\(\mathbb{Z}\)</span>;</li><li><span class="math inline">\(\mathbb{S}^n~(n&gt;2)\)</span> 的基本群为平凡群.</li></ol><h4 id="基本群的应用">基本群的应用</h4><ol style="list-style-type: decimal"><li><strong>代数学基本定理</strong>: <span class="math inline">\(\mathbb{C}\)</span> 上的 <span class="math inline">\(n\)</span> 次多项式存在零点;</li><li><strong>Brouwer 不动点定理</strong>: <span class="math inline">\(\mathbb{B}^n\)</span> 具有不动点性质(任意到自身的连续映射有不动点).</li></ol><h4 id="van-kampen-定理">Van Kampen 定理</h4><blockquote><p><strong>van kampen</strong> 设 <span class="math inline">\(X\)</span> 可以写成非空开集 <span class="math inline">\(X_1\)</span>, <span class="math inline">\(X_2\)</span> 的并集且 <span class="math inline">\(X_0=X_1\cap X_2\neq\varnothing\)</span>. 设 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(X_0\)</span> 道路连通, 取 <span class="math inline">\(x_0\in X_0\)</span>, 则 <span class="math display">\[\pi_1(X,x_0)\cong\pi_1(X_1,x_0)*\pi_1(X_2,x_0)/\sim,\]</span> 其中 <span class="math inline">\(\sim\)</span> 是等价关系 <span class="math display">\[\{i_{1*}(\alpha)=i_{2*}(\alpha)~\vert~\alpha\in\pi_1(X_0,x_0)\}~(i_k~是~X_0\to X_k~的包含映射).\]</span></p></blockquote><p>两个特殊情形如下:</p><blockquote><p><strong>推论 1</strong> 若 <span class="math inline">\(X_0\)</span> 单连通, 则 <span class="math display">\[\pi_1(X,x_0)\cong\pi_1(X_1,x_0)*\pi_1(X_2,x_0).\]</span> <strong>推论 2</strong> 若 <span class="math inline">\(X_2\)</span> 单连通, 则 <span class="math display">\[\pi_1(X,x_0)\cong\pi_1(X_1,x_0)/\sim,\]</span> 其中 <span class="math inline">\(\sim\)</span> 为等价关系 <span class="math inline">\(\{i_{1*}(\alpha)=e~\vert~\alpha\in\pi_1(X_0,x_0)\}\)</span>.</p></blockquote><h4 id="闭曲面分类定理">闭曲面分类定理</h4><ul><li><strong>曲面</strong>: 第二可数的Hausdorff空间 <span class="math inline">\(S\)</span> 称为曲面当且仅当 <span class="math inline">\(\forall x\in S\)</span>, 存在 <span class="math inline">\(x\)</span> 的邻域 <span class="math inline">\(U\)</span>, s.t. <span class="math inline">\(U\)</span> 同胚于圆盘 <span class="math inline">\(D^2\)</span> 或 半圆盘<span class="math inline">\(D^2_+\)</span>;</li><li><strong>内部</strong>: 存在邻域同胚于圆盘的点称为内点, 内点的全体称为内部;</li><li><strong>边界</strong>: 存在邻域同胚于半圆盘的点称为边界点, 边界点的全体称为边界.</li><li><strong>闭曲面</strong>: 紧致无边界的曲面称为闭曲面.</li></ul><p>关于曲面还有如下结论:</p><ol style="list-style-type: decimal"><li>曲面间的同胚把内点映射到内点, 边界点映射到边界点;</li><li>同胚的曲面具有同胚的边界. (由上一条可得到)</li></ol><p>如下定义曲面的可定向性:</p><ul><li><strong>不可定向曲面</strong>: 存在一个同胚于Mobius带的子空间. (否则称为可定向的)</li></ul><blockquote><p><strong>闭曲面分类定理</strong> <span class="math inline">\(\mathbb{S}^2\)</span>, <span class="math inline">\(nT^2~(n\in\mathbb{N})\)</span>, <span class="math inline">\(m\mathbb{P}^2~(m\in \mathbb{N})\)</span> 是两两不同胚的闭曲面, 且所有的闭曲面都可以归为这三类. 进一步, 1. 可定向曲面必定同胚于 <span class="math inline">\(\mathbb{S}^2\)</span> 或 <span class="math inline">\(nT^2~(n\in\mathbb{N})\)</span>; 2. 不可定向曲面必定同胚于 <span class="math inline">\(m\mathbb{P}^2~(m\in \mathbb{N})\)</span>.</p></blockquote><h3 id="复叠空间">复叠空间</h3><h4 id="复叠空间-1">复叠空间</h4><ul><li><strong>复叠映射</strong>: 设 <span class="math inline">\(E,B\)</span> 是道路连通且局部道路连通的空间, <span class="math inline">\(p: E\to B\)</span> 是连续映射. 若对 <span class="math inline">\(\forall b\in B\)</span>, 存在 <span class="math inline">\(b\)</span> 的开邻域 <span class="math inline">\(U\)</span>, s.t. <span class="math inline">\(p^{-1}(U)\)</span> 是 <span class="math inline">\(E\)</span> 中一族两两不交的开集 <span class="math inline">\(\{V_\alpha\}\)</span> 的并集, 且 <span class="math inline">\(p\vert_{V_\alpha}: V_\alpha\to U\)</span> 是同胚, 则称 <span class="math inline">\(p\)</span> 是复叠映射.</li><li><strong>复叠空间</strong>: <span class="math inline">\((E,p)\)</span> 称为 <span class="math inline">\(B\)</span> 上的复叠空间.</li><li><strong>基本邻域</strong>: 上述定义中的 <span class="math inline">\(U\)</span> 称为基本邻域. <span class="math inline">\(U\)</span> 的逆像可以拆成若干与 <span class="math inline">\(U\)</span> 同胚的集合的不交并.</li><li><strong>纤维</strong>: <span class="math inline">\(b\in B\)</span>, 称 <span class="math inline">\(p^{-1}(b)\)</span> 为 <span class="math inline">\(b\)</span> 的纤维. 其基数称为复叠空间的重数/叶数.</li></ul><p>简单来说, 复叠映射就是把一族同胚的不交开集映射到同一开集的映射, 原空间就称为复叠空间. 如果该映射是 <span class="math inline">\(n\)</span> 对 <span class="math inline">\(1\)</span> 的, 则该空间是 <span class="math inline">\(n\)</span> 重的.</p><h4 id="复叠空间上的道路提升与同伦提升">复叠空间上的道路提升与同伦提升</h4><blockquote><p><strong>道路提升</strong> 若 <span class="math inline">\(\alpha\)</span> 是以 <span class="math inline">\(b_0\in B\)</span> 为起点的一条道路, <span class="math inline">\(e_0\in p^{-1}(b_0)\)</span>, 则存在 <span class="math inline">\(E\)</span> 内唯一一条以 <span class="math inline">\(e_0\)</span> 为起点的道路 <span class="math inline">\(\tilde{\alpha}\)</span>, s.t. <span class="math display">\[\alpha=p\circ\tilde{\alpha}.\]</span> <font color="red"> <strong>这说明 <span class="math inline">\(B\)</span> 中以 <span class="math inline">\(b_0\)</span> 为起点的道路与 <span class="math inline">\(E\)</span> 中以 <span class="math inline">\(e_0\)</span> 为起点的道路一一对应.</strong></font> <strong>同伦提升</strong> 若 <span class="math inline">\(\alpha_1,\alpha_2\)</span> 是 <span class="math inline">\(B\)</span> 内两条道路, 且 <span class="math display">\[\alpha_1\underset{F}{\simeq}\alpha_2.\]</span> 设 <span class="math inline">\(\tilde{\alpha}_1\)</span> 是 <span class="math inline">\(\alpha_1\)</span> 的提升, 且 <span class="math inline">\(\tilde{\alpha}_1(0)=e_0\in E\)</span>, 则 <span class="math inline">\(F\)</span> 有唯一提升 <span class="math display">\[\tilde{F}: I\times I\to E,~\text{s.t.}~\tilde{F}(0,0)=e_0.\]</span> <strong>推论</strong> 若 <span class="math inline">\(\alpha_1,\alpha_2\)</span> 是 <span class="math inline">\(B\)</span> 内两条道路, 且 <span class="math display">\[\alpha_1\simeq\alpha_2,~rel\{0,1\}.\]</span> 设 <span class="math inline">\(\tilde{\alpha}_i\)</span> 是 <span class="math inline">\(\alpha_i\)</span> 的提升, 且 <span class="math inline">\(\tilde{\alpha_1}(0)=\tilde{\alpha_2}(0)\)</span>, 则 <span class="math display">\[\alpha_1\simeq\alpha_2,~rel\{0,1\}.\]</span> <font color="red"><strong>这说明道路提升中产生的一一对应能够保持保端点同伦.</strong></font></p></blockquote><h4 id="复叠空间的基本群">复叠空间的基本群</h4><ul><li>复叠映射 <span class="math inline">\(p\)</span> 可诱导单同态 <span class="math inline">\(p_*: \pi_1(E,e_0)\to\pi_1(B,b_0)\)</span>, 且 <span class="math inline">\(p_*(\pi_1(E,e_0))\)</span> 在 <span class="math inline">\(\pi_1(B,b_0)\)</span> 中的指数等于 <span class="math inline">\((E,p)\)</span> 的重数.</li></ul><blockquote><p><strong>命题</strong> 集合 <span class="math inline">\(\{p_*(\pi_1(E,e))~\vert~e\in p^{-1}(b_0)\}\)</span> 是 <span class="math inline">\(\pi_1(B,b_0)\)</span> 的某个子群的共轭类. <font color="red"> <strong>这说明复叠空间 <span class="math inline">\((E,p)\)</span> 决定了 <span class="math inline">\(\pi_1(B,b_0)\)</span> 中的一个子群共轭类.</strong> </font></p></blockquote><h4 id="映射的提升">映射的提升</h4><blockquote><p><strong>映射提升的唯一性</strong> 设 <span class="math inline">\((E,p)\)</span> 是 <span class="math inline">\(B\)</span> 上的复叠空间, <span class="math inline">\(X\)</span> 连通, 映射 <span class="math inline">\(\tilde{f_i}: X\to E\)</span>, <span class="math inline">\(i=1,2\)</span> 都是 <span class="math inline">\(f: X\to B\)</span> 的提升. 若 <span class="math display">\[\exists x_0\in X,~\text{s.t.}~\tilde{f}_1(x_0)=\tilde{f}_2(x_0),\]</span> 则 <span class="math inline">\(\tilde{f}_1=\tilde{f}_2\)</span>. <font color="red"> <strong>这说明对于 <span class="math inline">\(f(x_0)=b_0\)</span>, 满足 <span class="math inline">\(\tilde{f}(x_0)=e_0\)</span> 的提升若存在必唯一.</strong> </font></p></blockquote><p>对于提升的存在性, 有如下定理:</p><blockquote><p><strong>映射提升定理</strong> 设 <span class="math inline">\(X\)</span> 是道路连通且局部道路连通空间, <span class="math inline">\(f: X\to B\)</span> 连续, <span class="math inline">\(f(x_0)=b_0\)</span>, <span class="math inline">\(e_0\in p^{-1}(b_0)\)</span>, 则: <span class="math display">\[\exists~提升~\tilde{f},~\text{s.t.}~\tilde{f}(x_0)=e_0~\Leftrightarrow~f_*(\pi_1(X, x_0))\subset p_*(\pi_1(E,e_0)).\]</span></p></blockquote><h4 id="复叠空间的分类">复叠空间的分类</h4><ul><li><strong>复叠空间的同态</strong>: <span class="math inline">\((E_i, p_i)\)</span>, <span class="math inline">\(i=1,2\)</span> 是 <span class="math inline">\(B\)</span> 上的复叠空间, 若连续映射 <span class="math inline">\(h: E_1\to E_2\)</span> 满足 <span class="math inline">\(p_2\circ h=p_1\)</span>, 则称 <span class="math inline">\(h\)</span> 是复叠空间 <span class="math inline">\((E_1,p_1)\to (E_2,p_2)\)</span> 的同态. 当 <span class="math inline">\(h\)</span> 是同胚时, 则称 <span class="math inline">\(h\)</span> 是同构.</li></ul><blockquote><p><strong>定理</strong> <span class="math inline">\((E_1,p_1)\)</span> 与 <span class="math inline">\((E_2,p_2)\)</span> 等价 <span class="math inline">\(\Leftrightarrow\)</span> 它们决定 <span class="math inline">\(\pi_1(B,b_0)\)</span> 的同一个子群共轭类.</p></blockquote><h4 id="复叠变换">复叠变换</h4><ul><li><strong>复叠变换</strong>: <span class="math inline">\((E,p)\)</span> 上的自同构;</li><li><strong>复叠变换群</strong>: <span class="math inline">\((E,p)\)</span> 上自同构全体关于映射的复合构成一个群, 记作 <span class="math inline">\(D(E,p)\)</span>.</li></ul><h4 id="正则复叠空间">正则复叠空间</h4><p>以下命题等价:</p><ol style="list-style-type: decimal"><li><span class="math inline">\((E,p)\)</span> 是正则复叠空间;</li><li><span class="math inline">\(\forall b\in B\)</span>, <span class="math inline">\(e\in p^{-1}(b)\)</span>, <span class="math inline">\(p_*(\pi_1(E,e))\)</span> 是 <span class="math inline">\(\pi_1(B,p(e))\)</span> 的正规子群;</li><li><span class="math inline">\(\forall b\in B\)</span>, <span class="math inline">\(e,e&#39;\in p^{-1}(b)\)</span>, <span class="math inline">\(p_*(\pi_1(E,e))=p_*(\pi_1(E,e&#39;))\)</span>;</li><li><span class="math inline">\(\forall b\in B\)</span>, <span class="math inline">\(e,e&#39;\in p^{-1}(b)\)</span>, <span class="math inline">\(\exists h\in D(E,p)\)</span>, s.t. <span class="math inline">\(h(e)=e&#39;\)</span>.</li></ol><h4 id="万有复叠空间">万有复叠空间</h4><ul><li><strong>万有复叠空间</strong>: 单连通的复叠空间.(显然正则)</li></ul><blockquote><p><strong>命题</strong> 设 <span class="math inline">\(p:E\to B\)</span> 是复叠空间, <span class="math inline">\(p&#39;: E&#39;\to B\)</span> 是万有复叠空间, 则有复叠映射 <span class="math inline">\(\tilde{p}: E&#39;\to E\)</span>, s.t. <span class="math inline">\(p&#39;=p\circ\tilde{p}\)</span>.</p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 拓扑学 </tag>
            
            <tag> 期末复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数理统计复习重点</title>
      <link href="/2018/01/06/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/"/>
      <content type="html"><![CDATA[<h2 id="基本概念">基本概念</h2><h3 id="chi2-分布"><span class="math inline">\(\chi^2\)</span> 分布</h3><h4 id="定义">定义</h4><p>设 <span class="math inline">\(X_1,\cdots,X_n\)</span> 为来自 <span class="math inline">\(N(0,1)\)</span> 的iid样本, 则称随机变量</p><p><span class="math display">\[\xi=\sum\limits_{i=1}^nX_i^2\]</span></p><p>所服从的分布为自由度为 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(\chi^2\)</span> 分布, 记为 <span class="math inline">\(\xi\sim\chi^2(n)\)</span>.</p><h4 id="性质">性质</h4><ol style="list-style-type: decimal"><li><p><span class="math inline">\(E\xi=n\)</span>, <span class="math inline">\({\rm Var}~\xi=2n\)</span>;</p></li><li><p>设 <span class="math inline">\(\xi\sim\chi^2(m)\)</span>, <span class="math inline">\(\eta\sim\chi^2(n)\)</span>, 且二者独立, 则 <span class="math inline">\(\xi+\eta\sim\chi^2(m+n)\)</span>;</p></li><li><p><font color="red"><span class="math inline">\((n-1)S_n^2/\sigma^2\sim\chi^2(n-1)\)</span></font>.</p></li></ol><h3 id="t-分布"><span class="math inline">\(t\)</span> 分布</h3><h4 id="定义-1">定义</h4><p>设 <span class="math inline">\(\xi\sim N(0,1)\)</span>, <span class="math inline">\(\eta\sim\chi^2(n)\)</span>, 且 <span class="math inline">\(\xi\)</span>, <span class="math inline">\(\eta\)</span> 相互独立, 则称随机变量</p><p><span class="math display">\[T=\frac{\xi}{\sqrt{\eta/n}}\]</span></p><p>服从自由度为 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(t\)</span> 分布, 记为 <span class="math inline">\(T\sim t(n)\)</span>.</p><h4 id="性质-1">性质</h4><ol style="list-style-type: decimal"><li><p>设 <span class="math inline">\(\xi\sim t(n)\)</span>, <span class="math inline">\(n&gt;2\)</span>, 则 <span class="math inline">\(E\xi=0\)</span>, <span class="math inline">\({\rm Var}~\xi=\frac{n}{n-2}\)</span>;</p></li><li><p><span class="math inline">\(t(1)\)</span> 分布为Cauchy分布, 期望不存在;</p></li><li><p><font color="red"> <span class="math inline">\(\frac{\sqrt{n}(\overline{X}-\mu)}{S}\sim t(n-1)\)</span> </font>;</p></li></ol><h3 id="f-分布"><span class="math inline">\(F\)</span> 分布</h3><h4 id="定义-2">定义</h4><p>设 <span class="math inline">\(\xi,\eta\)</span> 是自由度分别为 <span class="math inline">\(m,n\)</span> 的独立的 <span class="math inline">\(\chi^2\)</span> 随机变量, 则称随机变量</p><p><span class="math display">\[F=\frac{\xi/m}{\eta/n}\]</span></p><p>服从自由度为 <span class="math inline">\((m,n)\)</span> 的 <span class="math inline">\(F\)</span> 分布, 记为 <span class="math inline">\(F\sim F(m,n)\)</span>.</p><h4 id="性质-2">性质</h4><ol style="list-style-type: decimal"><li><span class="math inline">\(X\sim F(m,n) \Longleftrightarrow \frac{1}{X}\sim F(n,m)\)</span>.</li></ol><h3 id="gamma-分布族"><span class="math inline">\(\Gamma\)</span> 分布族</h3><h4 id="定义-3">定义</h4><p>PDF 为 <span class="math display">\[\Gamma(x;\alpha,\lambda)=\frac{\lambda^\alpha}{\Gamma(\alpha)}x^{\alpha-1}e^{-\lambda x},\quad x&gt;0\]</span> 的分布称为 <span class="math inline">\(\Gamma\)</span> 分布, 记作 <span class="math inline">\(\Gamma(\alpha,\lambda)\)</span>.</p><h4 id="性质-3">性质</h4><ol style="list-style-type: decimal"><li><p><font color="red"><span class="math inline">\(\Gamma(\frac{n}{2},\frac{1}{2})=\chi^2(n)\)</span></font>;</p></li><li><p><font color="red"><span class="math inline">\(\Gamma(1,\lambda)=E(\lambda)\)</span>, PDF 为 <span class="math inline">\(f(x)=\lambda e^{-\lambda x},~x&gt;0\)</span></font>;</p></li><li><p><font color="red"><span class="math inline">\(\xi\sim\Gamma(\alpha_1,\lambda)\)</span>, <span class="math inline">\(\eta\sim\Gamma(\alpha_2,\lambda)\)</span>, <span class="math inline">\(\eta\)</span> 与 <span class="math inline">\(\xi\)</span> 独立 <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(\xi+\eta\sim\Gamma(\alpha_1+\alpha_2,\lambda)\)</span></font>;</p></li><li><p><font color="red"><span class="math inline">\(\xi\sim\Gamma(\alpha,\lambda)\)</span>, <span class="math inline">\(k&gt;0\in\mathbb{R}\)</span> <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(\xi/k\sim\Gamma(\alpha,k\lambda)\)</span></font>.</p></li></ol><h3 id="充分统计量">充分统计量</h3><h4 id="因子分解定理">因子分解定理</h4><blockquote><p><strong>定理</strong> 对于参数分布族 <span class="math display">\[\mathcal{F}=\{f_\theta(x):\theta\in\Theta\},\]</span> 设 <span class="math inline">\(X_1,\cdots,X_n\)</span> 是其中一组iid样本, <span class="math inline">\(T\)</span> 是一统计量, 且其样本分布 <span class="math inline">\(f_\theta\)</span> 满足 <span class="math display">\[f_\theta(x_1,\cdots,x_n)=g_\theta(T(x_1,\cdots,x_n))\cdot h(x_1,\cdots,x_n),\]</span> 其中 <span class="math inline">\(h(x)\)</span> 不依赖于 <span class="math inline">\(\theta\)</span>.</p></blockquote><h4 id="常见的充分统计量">常见的充分统计量</h4><ol style="list-style-type: decimal"><li><p>均匀分布 <span class="math inline">\(U(0,\theta)\)</span> 中 , <span class="math inline">\(X_{(n)}\)</span> 为 <span class="math inline">\(\theta\)</span> 的充分统计量;</p></li><li><p>正态分布 <span class="math inline">\(N(\mu,\sigma^2)\)</span> 中, <span class="math inline">\((\overline{X},\sum\limits_{i=1}^n (X_i-\overline{X})^2)\)</span> 为 <span class="math inline">\((\mu,\sigma^2)\)</span> 的充分统计量;</p></li><li><p>均匀分布 <span class="math inline">\(U(-\frac{1}{2}+\theta, \frac{1}{2}+\theta)\)</span> 中, <span class="math inline">\((X_{(1)},X_{(n)})\)</span> 为 <span class="math inline">\(\theta\)</span> 的充分统计量.</p></li></ol><h2 id="点估计">点估计</h2><h3 id="矩估计">矩估计</h3><h4 id="矩估计-1">矩估计</h4><p>对于样本 <span class="math inline">\(X_1,\cdots,X_n\)</span> 和 <span class="math inline">\(k\in\mathbb{N}\)</span>, 称 <span class="math display">\[a_k=\frac{1}{n}\sum\limits_{i=1}^n X_i^k,\quad m_k=\frac{1}{n}\sum\limits_{i=1}^n (X_i-\overline{X})^k\]</span> 为 <span class="math inline">\(k\)</span> 阶中心矩和 <span class="math inline">\(k\)</span> 阶原点矩.</p><p>而总体的原点矩和中心矩分别为 <span class="math display">\[\mu_k=\mathbb{E}X^k,\quad \nu_k=\mathbb{E}(X-\mu_1)^k\]</span></p><p>矩估计就是用样本矩来估计总体矩, 即令 <span class="math inline">\(a_k=\mu_k\)</span>, <span class="math inline">\(m_k=\nu_k\)</span>.</p><h4 id="几个矩估计的例子">几个矩估计的例子</h4><ol style="list-style-type: decimal"><li><p>总体均值和总体方差: <span class="math display">\[\hat{\mu}=\overline{X},\quad \hat{\sigma}^2=\frac{n-1}{n}S_n^2;\]</span></p></li><li><p>正态分布 <span class="math inline">\(U(0,\theta)\)</span> 中, <span class="math inline">\(\theta\)</span> 的矩估计为 <span class="math inline">\(\hat{\theta}=2\overline{X}\)</span>;</p></li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 概率论 </tag>
            
            <tag> 统计学 </tag>
            
            <tag> 期末复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>测度与概率复习重点</title>
      <link href="/2018/01/02/%E6%B5%8B%E5%BA%A6%E4%B8%8E%E6%A6%82%E7%8E%87%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/"/>
      <content type="html"><![CDATA[<h2 id="测度空间">测度空间</h2><h3 id="各种集类">各种集类</h3><h4 id="半集代数">半集代数</h4><ol style="list-style-type: decimal"><li><span class="math inline">\(\Omega\in\mathscr{S}\)</span>, <span class="math inline">\(\varnothing\in\mathscr{S}\)</span>;</li><li>若 <span class="math inline">\(A,B\in\mathscr{S}\)</span>, 则 <span class="math inline">\(A\cap B\in\mathscr{S}\)</span>;</li><li>若 <span class="math inline">\(A,A_1\in\mathscr{S}\)</span>, <span class="math inline">\(A_1\subset A\)</span>, 则 <span class="math inline">\(\exists A_2,\cdots,A_n\subset\mathscr{S}\)</span>, <span class="math inline">\(A_1,\cdots,A_n\)</span> 两两不交, 且 <span class="math inline">\(A=\bigcup\limits_{k=1}^nA_k\)</span>.</li></ol><h4 id="集代数">集代数</h4><ol style="list-style-type: decimal"><li><span class="math inline">\(\Omega\in\mathscr{A}\)</span>;</li><li>若 <span class="math inline">\(A,B\in\mathscr{A}\)</span>, 则 <span class="math inline">\(A\cap B, A\cup B\in\mathscr{A}\)</span>;</li><li>若 <span class="math inline">\(A\in\mathscr{A}\)</span>, 则 <span class="math inline">\(A^c\in\mathscr{A}\)</span>.</li></ol><ul><li>包含半集代数 <span class="math inline">\(\mathscr{S}\)</span> 的最小集代数为 <span class="math inline">\(\mathscr{A}(\mathscr{S})=\{\bigcup\limits_{k=1}^n A_k:A_1,\cdots,A_n\in\mathscr{S}\}\)</span>.</li></ul><h4 id="sigma-代数"><span class="math inline">\(\sigma\)</span> 代数</h4><ol style="list-style-type: decimal"><li><span class="math inline">\(\Omega\in\mathcal{F}\)</span>;</li><li>若 <span class="math inline">\(A\in\mathcal{F}\)</span>, 则 <span class="math inline">\(A^c\in\mathcal{F}\)</span>;</li><li>若 <span class="math inline">\(A_n\in\mathcal{F}~(n\in\mathbb{N})\)</span>, 则 <span class="math inline">\(\bigcup\limits_{n=1}^\infty A_n\in\mathcal{F}\)</span>.</li></ol><ul><li>任意一族 <span class="math inline">\(\sigma\)</span> 代数的交仍然是 <span class="math inline">\(\sigma\)</span> 代数;</li><li>所有包含 <span class="math inline">\(\mathcal{C}\)</span> 的 <span class="math inline">\(\sigma\)</span> 代数的交称为包含 <span class="math inline">\(\mathcal{C}\)</span> 的<strong>最小 <span class="math inline">\(\sigma\)</span> 代数</strong>, 记作 <span class="math inline">\(\sigma(\mathcal{C})\)</span>.</li></ul><h3 id="单调类定理">单调类定理</h3><h4 id="lambda-系"><span class="math inline">\(\lambda\)</span> 系</h4><ol style="list-style-type: decimal"><li><span class="math inline">\(\Omega\in\Lambda\)</span>;</li><li>对真差封闭: <span class="math inline">\(A,B\in\Lambda\)</span>, <span class="math inline">\(A\subset B\)</span>, 则 <span class="math inline">\(B\backslash A\in\Lambda\)</span>;</li><li>对不降序列的并封闭: <span class="math inline">\(\{A_n:n\in\mathbb{N}\} \subset\Lambda\)</span>, <span class="math inline">\(A_n\uparrow\)</span>, 则 <span class="math inline">\(\bigcup\limits_{n=1}^\infty A_n\in\Lambda\)</span>.</li></ol><h4 id="pi-系"><span class="math inline">\(\pi\)</span> 系</h4><ol style="list-style-type: decimal"><li>对交封闭: <span class="math inline">\(A,B\in\Lambda\)</span>, 则 <span class="math inline">\(A\cap B\in\Lambda\)</span>.</li></ol><h4 id="单调类定理-1">单调类定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\Omega\)</span> 的子集类 <span class="math inline">\(\mathcal{C}\)</span> 是 <span class="math inline">\(\pi\)</span> 系, 则 <span class="math inline">\(\Lambda(\mathcal{C})=\sigma(\mathcal{C})\)</span>.</p></blockquote><p>证明思路:</p><ol style="list-style-type: decimal"><li>令 $_A={B():AB()} $;</li><li><span class="math inline">\(\forall A\in\Lambda(\mathcal{C})\)</span>, 证明 <span class="math inline">\(\Lambda_A\)</span> 是 <span class="math inline">\(\lambda\)</span> 系;</li><li><span class="math inline">\(\forall A\in\mathcal{C}\)</span>, 证明 <span class="math inline">\(\Lambda_A=\Lambda(\mathcal{C})\)</span>;</li><li><span class="math inline">\(\forall A\in\Lambda(\mathcal{C})\)</span>, 证明 <span class="math inline">\(\Lambda_A=\Lambda(\mathcal{C})\)</span>.</li></ol><h3 id="测度的构造">测度的构造</h3><h4 id="有限可加测度">有限可加测度</h4><ul><li>可加: <span class="math inline">\(\forall A,B\in\mathcal{C}\)</span>, <span class="math inline">\(A\cup B\in\mathcal{C}\)</span>, <span class="math inline">\(A\cap B=\varnothing\)</span>, 有 <span class="math inline">\(\mu(A\cup B)=\mu(A)+\mu(B)\)</span>.</li><li>可加测度 <span class="math inline">\(\Leftrightarrow\)</span> 有限可加测度.</li></ul><h4 id="sigma-可加测度"><span class="math inline">\(\sigma\)</span> 可加测度</h4><ul><li><span class="math inline">\(\forall A_n\in\mathcal{C}\)</span>, <span class="math inline">\(n\in\mathbb{N}\)</span> 两两不交且 <span class="math inline">\(\bigcup\limits_{n=1}^\infty A_n\in\mathcal{C}\)</span>, 有 <span class="math inline">\(\mu(\bigcup\limits_{n=1}^\infty A_n)=\sum\limits_{n=1}^\infty\mu(A_n)\)</span>.</li></ul><h4 id="sigma-有限测度"><span class="math inline">\(\sigma\)</span> 有限测度</h4><p>若 <span class="math inline">\(\forall A\in\mathcal{C}\)</span>, <span class="math inline">\(\exists \{A_n:n\in\mathbb{N}\} \subset\mathcal{C}\)</span>, s.t. <span class="math inline">\(\bigcup\limits_{n=1}^\infty A_n=A\)</span> 且 <span class="math inline">\(\mu(A_n)&lt;\infty\)</span>, <span class="math inline">\(\forall n\in\mathbb{N}\)</span>, 则称其为 <span class="math inline">\(\sigma\)</span> 有限的.</p><h3 id="测度扩张定理">测度扩张定理</h3><h4 id="半集代数上的测度">半集代数上的测度</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(F\)</span> 为 <span class="math inline">\(\mathbb{R}\)</span> 上的右连续增函数, 则在半集代数 <span class="math display">\[\mathscr{S}:=\{(a,b]:-\infty\leqslant a\leqslant b\leqslant\infty\} \]</span> 上有唯一的测度 <span class="math inline">\(\mu=\mu_F\)</span>, s.t. <span class="math display">\[\mu((a,b])=F(b)-F(a),~a\leqslant b\leqslant a,b\in\mathbb{R},\]</span> 并且 <span class="math inline">\(\mu\)</span> 在有限区间上的值有限(因而 <span class="math inline">\(\sigma\)</span> 有限).</p></blockquote><h4 id="测度扩张定理-1">测度扩张定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\mu\)</span> 为 <span class="math inline">\(\Omega\)</span> 的半集代数 <span class="math inline">\(\mathscr{S}\)</span> 上的测度, 则 <span class="math inline">\(\mu\)</span> 在 <span class="math inline">\(\mathscr{S}\)</span> 生成的 <span class="math inline">\(\sigma\)</span> 代数 <span class="math inline">\(\sigma(\mathscr{S})\)</span> 上存在一个扩张. 若 <span class="math inline">\(\mu\)</span> 是 <span class="math inline">\(\sigma\)</span> 有限的, 则扩张唯一.</p></blockquote><ul><li>唯一性证明: <span class="math inline">\(\lambda-\pi\)</span> 系方法.</li></ul><h4 id="外测度">外测度</h4><ol style="list-style-type: decimal"><li><span class="math inline">\(\mu^*(\varnothing)=0\)</span>;</li><li>不降性: <span class="math inline">\(\forall A\subset B\subset\Omega\)</span>, 有 <span class="math inline">\(\mu^*(A)\leqslant \mu^*(B)\)</span>;</li><li>次 <span class="math inline">\(\sigma\)</span> 可加性: <span class="math inline">\(\forall A_n\subset\Omega\)</span>, <span class="math inline">\(n\in\mathbb{N}\)</span>, 有 <span class="math display">\[\mu^*(\bigcup\limits_{N=1}^\infty A_n)\leqslant \sum\limits_{n=1}^\infty \mu^*(A_n).\]</span></li></ol><ul><li><span class="math inline">\(\mu^*\)</span> 可测集: <span class="math inline">\(\mu^*(D)=\mu^*(A\cap D)+\mu^*(A^c\cap D)\)</span>.</li></ul><h3 id="测度空间-1">测度空间</h3><h4 id="测度空间-2">测度空间</h4><p><span class="math inline">\((\Omega,\mathcal{F},\mu)\)</span> 是测度空间当且仅当 <span class="math inline">\(\mathcal{F}\)</span> 是 <span class="math inline">\(\sigma\)</span> 代数且 <span class="math inline">\(\mu\)</span> 是 <span class="math inline">\(\Omega\)</span> 上的 <span class="math inline">\(\sigma\)</span> 可加测度.</p><ul><li>若 <span class="math inline">\(\mu(\Omega)=1\)</span> 则称为概率空间, <span class="math inline">\(\mu\)</span> 即为概率 <span class="math inline">\(\mathbb{P}\)</span>.</li></ul><h4 id="可加性的提升">可加性的提升</h4><blockquote><p><strong>定理</strong> <span class="math inline">\(\mu\)</span> 为集代数 <span class="math inline">\(\mathscr{A}\)</span> 上的<strong>可加</strong>测度, 若 <span class="math inline">\(\mu\)</span> 还满足以下条件之一:</p></blockquote><blockquote><ol style="list-style-type: decimal"><li><span class="math inline">\(\mu\)</span> 下方连续: 即对 <span class="math inline">\(\forall \{A_n\} \subset\mathscr{A}\)</span>, <span class="math inline">\(A_n\uparrow A\)</span>, 总有 <span class="math inline">\(\lim\limits_ {n\to\infty}\mu(A_n)=\mu(A)\)</span>;</li><li><span class="math inline">\(\mu\)</span> 有限且在 <span class="math inline">\(\varnothing\)</span> 上方连续: 即对 <span class="math inline">\(\forall \{A_n\} \subset\mathscr{A}\)</span>, <span class="math inline">\(A_n\downarrow\varnothing\)</span>, 都有 <span class="math inline">\(\lim\limits_{n\to\infty}\mu(A_n)=0\)</span>. 则 <span class="math inline">\(\mu\)</span> 为 <span class="math inline">\(\mathscr{A}\)</span> 上的测度(即有限可加可提升为 <span class="math inline">\(\sigma\)</span> 可加).</li></ol></blockquote><h4 id="测度的完全化">测度的完全化</h4><ul><li><strong><span class="math inline">\(\mu\)</span> 零集</strong>: 零测集的子集称为 <span class="math inline">\(\mu\)</span> 零集;</li><li><strong>完全测度</strong>: 若每一个 <span class="math inline">\(\mu\)</span> 零集都属于 <span class="math inline">\(\mathcal{F}\)</span>, 则称 <span class="math inline">\(\mu\)</span> 为完全测度, 该测度空间为完全测度空间.</li></ul><blockquote><p><strong>定理</strong> 设 <span class="math inline">\((\Omega, \mathcal{F}, \mu)\)</span> 为测度空间, 令 <span class="math display">\[\overline{\mathcal{F}}=\{A\triangle N:A\in\mathcal{F}, N 为 \mu 零集\} =\{A\cup N:A\in\mathcal{F}, N 为 \mu 零集\} \]</span> <span class="math display">\[\overline{\mu}(A\triangle N)=\mu(A),~A\in\mathcal{F},~N 为 \mu 零集合\]</span> 则 <span class="math inline">\((\Omega,\overline{\mathcal{F}},\overline{\mu})\)</span> 为一个完全测度空间, 称为原空间的完全化.</p></blockquote><h2 id="可测函数与随机变量">可测函数与随机变量</h2><h3 id="逆像">逆像</h3><h4 id="逆像与集合运算的交换">逆像与集合运算的交换</h4><p>设 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(\Omega\to E\)</span> 的映射, 则 <span class="math inline">\(f^{-1}\)</span> 有如下性质:</p><ol style="list-style-type: decimal"><li><p><span class="math inline">\(f^{-1}(E)=\Omega\)</span>, <span class="math inline">\(f^{-1}(\varnothing)=\varnothing\)</span>;</p></li><li><p><span class="math inline">\(f^{-1}(B^c)=(f^{-1}(B))^c\)</span>;</p></li><li><p><span class="math inline">\(f^{-1}(\bigcup\limits_{\gamma\in\Gamma}B_\gamma)=\bigcup\limits_{\gamma\in\Gamma}f^{-1}(B_\gamma)\)</span>;</p></li><li><p><span class="math inline">\(f^{-1}(\bigcap\limits_{\gamma\in\Gamma}B_\gamma)=\bigcap\limits_{\gamma\in\Gamma}f^{-1}(B_\gamma)\)</span>;</p></li><li><p><span class="math inline">\(f^{-1}(B_1\backslash B_2)=f^{-1}(B_1)\backslash f^{-1}(B_2)\)</span>.</p></li></ol><h4 id="逆像与集类">逆像与集类</h4><p>进一步, <span class="math inline">\(f^{-1}\)</span> 还对集类有相同的作用:</p><ol style="list-style-type: decimal"><li><p><span class="math inline">\(\mathscr{E}\)</span> 为 <span class="math inline">\(E\)</span> 的一个 <span class="math inline">\(\sigma\)</span> 代数 <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(f^{-1}(\mathscr{E})\)</span> 是 <span class="math inline">\(\Omega\)</span> 的 <span class="math inline">\(\sigma\)</span> 代数;</p></li><li><p><span class="math inline">\(\mathcal{C}\)</span> 是 <span class="math inline">\(E\)</span> 的任意非空子集类, 则 <span class="math inline">\(f^{-1}(\sigma(\mathcal{C}))=\sigma(f^{-1}(\mathcal{C}))\)</span>. (<strong>证明: <span class="math inline">\(\lambda-\pi\)</span> 系方法</strong>)</p></li></ol><h3 id="随机变量">随机变量</h3><blockquote><p><strong>定理</strong> <span class="math inline">\(X\)</span> 是 <span class="math inline">\((\Omega,\mathcal{F})\to (E,\mathscr{E})\)</span> 的可测映射的充要条件是: 存在 <span class="math inline">\(\mathscr{E}\)</span> 的一个子集类 <span class="math inline">\(\mathcal{C}\)</span>, s.t. 1. <span class="math inline">\(\sigma(\mathcal{C})=\mathscr{E}\)</span>; 2. <span class="math inline">\(\forall A\in\mathcal{C}\)</span>, <span class="math inline">\(X^{-1}(A)\in\mathcal{F}\)</span>.</p></blockquote><h4 id="可测函数的构造">可测函数的构造</h4><center><font color="red"><strong>非负简单函数→非负可测函数→可测函数</strong></font></center><h3 id="单调类定理-2">单调类定理</h3><h4 id="mathscrl-系"><span class="math inline">\(\mathscr{L}\)</span> 系</h4><p>设 <span class="math inline">\(\mathscr{L}\)</span> 是定义在 <span class="math inline">\(\Omega\)</span> 上的广义实函数类, 满足: <span class="math inline">\(f\in\mathscr{L}\Rightarrow f^+,f^-\in\mathscr{L}\)</span>. 函数族 <span class="math inline">\(L\)</span> 称为 <span class="math inline">\(\mathscr{L}\)</span>, 如果满足: 1. <span class="math inline">\(1\in L\)</span>; 2. <span class="math inline">\(L\)</span> 中有限个函数的线性组合(如果有意义)属于 <span class="math inline">\(L\)</span>; 3. 若 <span class="math inline">\(f_n\in L\)</span>, <span class="math inline">\(n\in\mathbb{N}\)</span>, <span class="math inline">\(0\leqslant f_n\uparrow f\)</span>, <span class="math inline">\(f\)</span> 有界或 <span class="math inline">\(f\in\mathscr{L}\)</span>, 则 <span class="math inline">\(f\in L\)</span>.</p><h4 id="单调类定理-3">单调类定理</h4><blockquote><p>若 <span class="math inline">\(\mathscr{L}\)</span> 系 <span class="math inline">\(L\)</span> 包含一 <span class="math inline">\(\pi\)</span> 系 <span class="math inline">\(\mathcal{C}\)</span> 中任意集合的示性函数, 则 <span class="math inline">\(L\)</span> 包含所有属于 <span class="math inline">\(\mathscr{L}\)</span> 的 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 可测函数.</p></blockquote><ul><li>证明: <span class="math inline">\(\lambda-\pi\)</span> 系方法.</li></ul><h2 id="积分与数学期望">积分与数学期望</h2><center><font color="red"><strong>非负简单函数→非负可测函数→可测函数</strong></font></center><h3 id="积分的性质">积分的性质</h3><h4 id="单调收敛">单调收敛</h4><blockquote><p><strong>定理</strong> 若 <span class="math inline">\(f_n\)</span>, <span class="math inline">\(n\in\mathbb{N}\)</span> 是<strong>非负</strong>(可举反例)可测函数列, 且 <span class="math inline">\(f_n\uparrow f\)</span>, 则 <span class="math inline">\(\lim\limits_{n\to\infty}\int f_n=\int f\)</span>.</p></blockquote><h4 id="积分的序性质">积分的序性质</h4><ol style="list-style-type: decimal"><li><p>若 <span class="math inline">\(f,g\)</span> 为实函数, <span class="math inline">\(\int f\)</span>, <span class="math inline">\(\int g\)</span> 存在, 且 <span class="math inline">\(f\geqslant g\)</span>, a.e. 则 <span class="math inline">\(\int_A f\geqslant \int_A g\)</span>, <span class="math inline">\(\forall A\in\mathcal{F}\)</span>.</p></li><li><p>若 <span class="math inline">\(\int f\)</span> 存在, 则 <span class="math inline">\(\vert\int f\vert\leqslant \int\vert f\vert\)</span>,</p></li><li><p><span class="math inline">\(f\geqslant 0\)</span>, 则 <span class="math inline">\(\int f=0\Leftrightarrow f=0\)</span>, a.e..</p></li></ol><h4 id="可积性质">可积性质</h4><p>给定可测函数 <span class="math inline">\(f,g\)</span> 有:</p><ol style="list-style-type: decimal"><li><p><span class="math inline">\(f\)</span> 可积 <span class="math inline">\(\Leftrightarrow\)</span> $f&lt;$; 当 <span class="math inline">\(f\)</span> 可积时, <span class="math inline">\(f\)</span> a.e. 有限;</p></li><li><p>若 <span class="math inline">\(\vert f\vert\leqslant g\)</span> 可积, 则 <span class="math inline">\(f\)</span> 可积;</p></li><li><p>若 <span class="math inline">\(f,g\)</span> 可积, 则 <span class="math inline">\(f+g\)</span> 可积.</p></li></ol><h3 id="期望的性质">期望的性质</h3><h4 id="独立事件类的扩张">独立事件类的扩张</h4><p>独立事件类可以由 <span class="math inline">\(\pi\)</span> 系扩张至其生成的 <span class="math inline">\(\sigma\)</span> 代数.</p><blockquote><p><strong>定理</strong> <span class="math inline">\(\mathcal{C}_k\subset\mathcal{F}\)</span> 为包含 <span class="math inline">\(\Omega\)</span> 的 <span class="math inline">\(\pi\)</span> 系, 若 <span class="math inline">\(\forall A_k\in\mathcal{C}_k\)</span>, <span class="math inline">\(k=1,\cdots,n\)</span>, 有 <span class="math display">\[\mathbb{P}(\bigcap\limits_{k=1}^n A_k)=\prod\limits_{k=1}^n \mathbb{P}(A_k),\]</span> 则上式对 <span class="math inline">\(\forall A_k\in\sigma(\mathcal{C}_k)\)</span>, <span class="math inline">\(k=1,\cdots,n\)</span> 成立.</p></blockquote><h4 id="独立随机变量">独立随机变量</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(X_1,\cdots,X_n\)</span> 为独立r.v., 且 <span class="math inline">\(\mathbb{E}X_k\)</span> 有限, 则 <span class="math display">\[\mathbb{E}(X_1\cdots X_n)=\prod\limits_{k=1}^n \mathbb{E}X_k.\]</span></p></blockquote><h3 id="l-s-积分表示">L-S 积分表示</h3><h4 id="分布测度">分布测度</h4><p>设 <span class="math inline">\(f\)</span> 是 <span class="math inline">\((\Omega,\mathcal{F},\mu)\to(E,\mathscr{E})\)</span> 的可测映射, <span class="math inline">\(\mu\)</span> 是 <span class="math inline">\(\mathcal{F}\)</span> 上的测度, 定义 <span class="math display">\[\mu_f(B)=\mu(f^{-1}(B)),\quad \forall B\in\mathscr{E},\]</span> 则 <span class="math inline">\(\mu_f\)</span> 是 <span class="math inline">\(\mathscr{E}\)</span> 上的测度, 也可记作 <span class="math inline">\(\mu_f=\mu\circ f^{-1}\)</span>.</p><h4 id="积分变换定理">积分变换定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(f\)</span> 是 <span class="math inline">\((\Omega,\mathcal{F},\mu)\to(E,\mathscr{E})\)</span> 的可测映射, <span class="math inline">\(g\)</span> 是 <span class="math inline">\((E,\mathscr{E})\)</span> 上的可测函数, 则 <span class="math display">\[\int_{f^{-1}(B)}(g\circ f){\rm d}\mu=\int_B g{\rm d}\mu_f,\quad \forall B\in\mathscr{E}.~(同时存在,~存在即相等)\]</span></p></blockquote><h4 id="积分变换">积分变换</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\mu\)</span> 是 <span class="math inline">\((\Omega,\mathcal{F})\)</span> 上的测度, <span class="math inline">\(p\)</span> 是非负 <span class="math inline">\(\mathcal{F}\)</span> 可测函数, 定义 <span class="math display">\[\nu(A)=\int_A p(w)\mu({\rm d}w),\quad A\in \mathcal{F},\]</span> 则 <span class="math inline">\(\nu\)</span> 是 <span class="math inline">\(\mathcal{F}\)</span> 上的测度, 且有 <span class="math display">\[\int_A g(w)\nu({\rm d}w)=\int_A g(w)p(w)\mu({\rm d}w).~(同时存在,~存在即相等)\]</span></p></blockquote><h3 id="积分的收敛">积分的收敛</h3><h4 id="单调收敛定理">单调收敛定理</h4><blockquote><p><strong>定理</strong> 给定 <span class="math inline">\((\Omega,\mathcal{F},\mu)\)</span>, <span class="math inline">\(g\)</span> 为实可积函数, <span class="math inline">\(f_n\)</span>, <span class="math inline">\(n\in\mathbb{N}\)</span> 是实 <span class="math inline">\(\mathcal{F}\)</span> 可测函数, 若 <span class="math inline">\(g\leqslant f_n\uparrow f\)</span>, a.e. 则 <span class="math display">\[\lim\limits_{n\to\infty}\int f_n=\int\lim\limits_{n\to\infty}f_n.\]</span></p></blockquote><h4 id="fatou引理">Fatou引理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(g,h\)</span> 是可积实函数, ${f_n:n} $ 是实可测函数列, 有 1. <span class="math inline">\(\forall n\in\mathbb{N}\)</span>, <span class="math inline">\(f_n\geqslant g\)</span>, a.e., 则 <span class="math display">\[\int\varliminf\limits_{n\to\infty} f_n\leqslant \varliminf\limits_{n\to\infty}\int f_n.\]</span> 2. <span class="math inline">\(\forall n\in\mathbb{N}\)</span>, <span class="math inline">\(f_n\leqslant h\)</span>, a.e., 则 <span class="math display">\[\int\varlimsup\limits_{n\to\infty} f_n\geqslant \varlimsup\limits_{n\to\infty}\int f_n.\]</span></p></blockquote><h4 id="控制收敛定理">控制收敛定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(g,h\)</span> 为可积实函数. 1. 若 <span class="math inline">\(f_n\)</span>, <span class="math inline">\(n\in\mathbb{N}\)</span> 为实可测函数序列, 当 <span class="math inline">\(g\leqslant f_n\leqslant h\)</span>, a.e., <span class="math inline">\(\forall n\in\mathbb{N}\)</span>, <span class="math inline">\(f_n\to f\)</span>, a.e. 时, 有 <span class="math inline">\(\int f_n\to\int f\)</span>. 2. 若 <span class="math inline">\(f_n\)</span>, <span class="math inline">\(n\in\mathbb{N}\)</span> 为实或复可测函数序列, 当 <span class="math inline">\(\vert f_n\vert\leqslant g\)</span>, a.e., <span class="math inline">\(\forall n\in\mathbb{N}\)</span>, <span class="math inline">\(f_n\to f\)</span>, a.e. 时, 有 <span class="math inline">\(\int\vert f_n-f\vert\to 0\)</span>, 因而 <span class="math inline">\(\int f_n\to\int f\)</span>.</p></blockquote><h2 id="乘积空间">乘积空间</h2><h3 id="乘积-sigma-代数">乘积 <span class="math inline">\(\sigma\)</span> 代数</h3><p>设 <span class="math inline">\((\Omega_i,\mathcal{F})\)</span>, <span class="math inline">\(i=1,2\)</span> 是可测空间, 称包含可测矩形 <span class="math display">\[\mathcal{C}=\{A_1\times A_2: A_i\in\mathcal{F}, i=1,2\} \]</span> 的最小 <span class="math inline">\(\sigma\)</span> 代数为 <span class="math inline">\(\mathcal{F}_1,\mathcal{F}_2\)</span> 的乘积 <span class="math inline">\(\sigma\)</span> 代数.</p><ul><li>可测矩形类 <span class="math inline">\(\mathcal{C}\)</span> 是一个半集代数;</li><li><span class="math inline">\(\mathscr{B}^2=\mathscr{B}\times\mathscr{B}\)</span>. (<strong>证明: <span class="math inline">\(\lambda-\pi\)</span> 系方法</strong>)</li></ul><h3 id="截集">截集</h3><h4 id="截集-1">截集</h4><p><span class="math inline">\(A\subset\Omega_1\times\Omega_2\)</span>, <span class="math inline">\(\omega_i\in\Omega_i\)</span>, <span class="math inline">\(i=1,2\)</span>, 称集合 <span class="math display">\[A_{\omega_1}=A(\omega_1)=\{\omega_2\in\Omega_2: (\omega_1,\omega_2)\in A\} ,\]</span> <span class="math display">\[A_{\omega_2}=A(\omega_2)=\{\omega_1\in\Omega_1: (\omega_1,\omega_2)\in A\} ,\]</span> 分别为 <span class="math inline">\(A\)</span> 在 <span class="math inline">\(\omega_1\)</span>, <span class="math inline">\(\omega_2\)</span> 处的截集.</p><h4 id="截集的性质">截集的性质</h4><p>截集与集合的运算可以交换:</p><ol style="list-style-type: decimal"><li><p><span class="math inline">\(A\cap B=\varnothing\Rightarrow A(\omega_i)\cap B(\omega_i)=\varnothing\)</span>;</p></li><li><p><span class="math inline">\(A\subset B\Rightarrow A(\omega_i)\subset B(\omega_i)\)</span>;</p></li><li><p><span class="math inline">\(A=\bigcup\limits_\alpha A^{(\alpha)}\Rightarrow A(\omega_i)=\bigcup\limits_\alpha A^{(\alpha)}(\omega_i)\)</span>;</p></li><li><p><span class="math inline">\(A=\bigcap\limits_\alpha A^{(\alpha)}\Rightarrow A(\omega_i)=\bigcap\limits_\alpha A^{(\alpha)}(\omega_i)\)</span>;</p></li><li><p><span class="math inline">\(C=A\backslash B\Rightarrow C(\omega_i)=A(\omega_i)\backslash B(\omega_i)\)</span>.</p></li></ol><p>对于截集的可测性有如下定理:</p><blockquote><p><strong>定理</strong> 取 <span class="math inline">\(A\in\mathcal{F}_1\times\mathcal{F}_2\)</span>, 则 <span class="math inline">\(\forall \omega_1\in\mathcal{F}_1\)</span>, 有 <span class="math inline">\(A(\omega_1)\in\mathcal{F}_2\)</span>.</p></blockquote><p><strong>证明: <span class="math inline">\(\lambda-\pi\)</span> 系方法.</strong></p><h4 id="截函数">截函数</h4><ul><li><span class="math inline">\(f_{\omega_1}=f(\omega_1,\cdot)\)</span> 称为 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(\omega_1\)</span> 的截函数;</li><li><span class="math inline">\(f_{\omega_2}=f(\cdot,\omega_2)\)</span> 称为 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(\omega_2\)</span> 的截函数;</li></ul><blockquote><p><strong>定理</strong> 任意 <span class="math inline">\(\mathcal{F}_1\times\mathcal{F}_2\)</span> 可测函数的截函数是可测的.</p></blockquote><p>关于截函数还有如下重要定理:</p><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(\mathcal{F}_1\times\mathcal{F}_2\)</span> 可测函数, <span class="math inline">\(\mu_i\)</span> 是 <span class="math inline">\(\sigma\)</span> 有限测度, 则 <span class="math display">\[f^{(2)}=\int_{\Omega_1}f(\omega_1,\cdot)\mu_1({\rm d}\omega_1)\]</span> <span class="math display">\[f^{(1)}=\int_{\Omega_2}f(\cdot,\omega_2)\mu_2({\rm d}\omega_2)\]</span> 是非负可测函数.</p></blockquote><h3 id="乘积测度">乘积测度</h3><p>设 <span class="math inline">\(\mu_i\)</span> 是 <span class="math inline">\(\sigma\)</span> 有限测度, 若令 <span class="math display">\[\mu(A)=\int_{\Omega_1}\mu_2(A(\omega_1))\mu_1({\rm d}\omega_1),~A\in\mathcal{F}_1\times\mathcal{F}_2,\]</span> 或 <span class="math display">\[\mu(A)=\int_{\Omega_2}\mu_1(A(\omega_2))\mu_2({\rm d}\omega_2),~A\in\mathcal{F}_1\times\mathcal{F}_2,\]</span> 则 <span class="math inline">\(\mu\)</span> 是 <span class="math inline">\(\mathcal{F}_1\times\mathcal{F}_2\)</span> 上唯一满足 <span class="math display">\[\mu(A_1\times A_2)=\mu_1(A_1)\mu_2(A_2),~\forall A_i\in\mathcal{F}_i\]</span> 的 <span class="math inline">\(\sigma\)</span> 有限测度.</p><h3 id="转移测度">转移测度</h3><p>映射 <span class="math inline">\(\lambda:\Omega_1\times\mathcal{F}_2\to [0,\infty]\)</span> 满足下列条件, 就称之为 <span class="math inline">\((\Omega_1,\mathcal{F}_1)\to(\Omega_2,\mathcal{F}_2)\)</span> 的转移测度: 1. <span class="math inline">\(\forall B\in\mathcal{F}_2\)</span>, <span class="math inline">\(\lambda(\cdot,B)\)</span> 是 <span class="math inline">\(\mathcal{F}_1\)</span> 可测函数; 2. <span class="math inline">\(\forall \omega\in\Omega_1\)</span>, <span class="math inline">\(\lambda(\omega,\cdot)\)</span> 是 <span class="math inline">\(\mathcal{F}_2\)</span> 上的测度.</p><p>若 <span class="math inline">\(\exists B_{kn}\in\mathcal{F}_k\)</span>, <span class="math inline">\(n\in\mathbb{N}\)</span> 两两不交, <span class="math inline">\(\Omega_k=\bigcup\limits_{n=1}^\infty B_{kn}\)</span>, <span class="math inline">\(k=1,2\)</span>, s.t. <span class="math display">\[\sup\limits_{\omega\in B_{1m}}\lambda(\omega,B_{2n})&lt;\infty,~\forall m,n\in\mathbb{N},\]</span> 则称 <span class="math inline">\(\lambda\)</span> 为 <span class="math inline">\(\sigma\)</span> 有限转移测度.</p><h3 id="fubini定理">Fubini定理</h3><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(f\)</span> 是非负 <span class="math inline">\(\mathcal{F}_1\times\mathcal{F}_2\)</span> 可测函数, 则 <span class="math display">\[\begin{align}\int_{\Omega_1\times\Omega_2}f{\rm d}(\mu_1\times\mu_2) &amp;= \int_{\Omega_1}\left(\int_{\Omega_2}f(\omega_1,\omega_2)\mu_2({\rm d}\omega_2)\right)\mu_1({\rm d}\omega_1) \\&amp;= \int_{\Omega_2}\left(\int_{\Omega_1}f(\omega_1,\omega_2)\mu_1({\rm d}\omega_1)\right)\mu_2({\rm d}\omega_2).\end{align}\]</span></p></blockquote><h4 id="fubini定理-1">Fubini定理</h4><blockquote><p><strong>Fubini</strong> 设 <span class="math inline">\(f\)</span> 是非负 <span class="math inline">\(\mathcal{F}_1\times\mathcal{F}_2\)</span> 可测函数且 <span class="math inline">\(\int f{\rm d}(\mu_1\times\mu_2)\)</span> 存在, 则 1. 积分函数存在且可测: - <span class="math inline">\(g(\omega_1)=\int_{\Omega_2}f(\omega_1,\omega_2)\mu_2({\rm d}\omega_2)\)</span> 存在且 <span class="math inline">\(\mathcal{F}_1\)</span> 可测; - <span class="math inline">\(h(\omega_2)=\int_{\Omega_1}f(\omega_1,\omega_2)\mu_1({\rm d}\omega_1)\)</span> 存在且 <span class="math inline">\(\mathcal{F}_2\)</span> 可测; 2. <span class="math inline">\(\int_{\Omega_1}g{\rm d}\mu_1\)</span>, <span class="math inline">\(\int_{\Omega_2}h{\rm d}\mu_2\)</span> 存在且 <span class="math display">\[\int_{\Omega_1\times\Omega_2}f({\rm d}\mu_1\times\mu_2)=\int_{\Omega_1}g({\rm d}\mu_1)=\int_{\Omega_2}f({\rm d}\mu_2);\]</span> 3. 若 <span class="math inline">\(f\)</span> 对 <span class="math inline">\(\mu_1\times\mu_2\)</span> 可积, 则 <span class="math inline">\(g\)</span>, <span class="math inline">\(h\)</span> 分别对 <span class="math inline">\(\mu_1\)</span>, <span class="math inline">\(\mu_2\)</span> 可积.</p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 概率论 </tag>
            
            <tag> 测度论 </tag>
            
            <tag> 期末复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>泛函——复习重点</title>
      <link href="/2017/12/24/%E6%B3%9B%E5%87%BD%E2%80%94%E2%80%94%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/"/>
      <content type="html"><![CDATA[<h2 id="度量空间">度量空间</h2><h3 id="基础知识">基础知识</h3><h4 id="压缩映像原理">压缩映像原理</h4><blockquote><p><strong>Banach</strong> 设 <span class="math inline">\((\mathscr{X},\rho)\)</span> 是一个完备度量空间, <span class="math inline">\(T\)</span> 是 <span class="math inline">\(\mathscr{X}\)</span> 到自身的一个压缩映射, 则 <span class="math inline">\(T\)</span> 在 <span class="math inline">\(\mathscr{X}\)</span> 上存在唯一的不动点.</p></blockquote><h4 id="完备化">完备化</h4><p><strong>完备化空间</strong>: 包含 <span class="math inline">\(\mathscr{X}\)</span> 的最小完备度量空间. 关于其存在性有如下定理:</p><blockquote><p><strong>定理</strong> 每个度量空间都有一个自身在其中稠的完备化空间.</p></blockquote><h4 id="有界性与列紧性">有界性与列紧性</h4><blockquote><p><strong>定理</strong> 列紧空间的任意子集都是列紧集. 进一步, 任意闭子集都是自列紧的. <strong>定理</strong> 列紧空间必定完备. 反之不成立, 如 <span class="math inline">\(\mathbb{R}\)</span>.</p></blockquote><ul><li>完全有界和列紧</li></ul><blockquote><p><strong>定理</strong> 列紧集一定完全有界, 完全有界集必定有界. <strong>定理</strong> 有穷维 <span class="math inline">\(B^*\)</span> 空间的有界集必定完全有界, 完备空间中的完全有界集必定列紧.</p></blockquote><p><span class="math inline">\(\mathscr{X}\)</span> 中的列紧集、完全有界集、有界集三者的关系如下: <font color="red"><span class="math display">\[列紧~\underset{\mathscr{X}~完备}{\rightleftarrows}~完全有界~\underset{有限维B^*}{\rightleftarrows}~有界\]</span></font></p><h4 id="一致有界和等度连续">一致有界和等度连续</h4><p><strong>一致有界</strong>: 设 <span class="math inline">\(F\subset C(M)\)</span>, 若 <span class="math inline">\(\exists M_1&gt;0\)</span>, s.t. <span class="math inline">\(\vert\varphi(x)\vert\leqslant M~(\forall x\in M,\forall \varphi\in F)\)</span>, 则称 <span class="math inline">\(F\)</span> 一致有界.</p><p><strong>等度连续</strong>: 设 <span class="math inline">\(F\subset C(M)\)</span>, 若对 <span class="math inline">\(\forall \epsilon&gt;0\)</span>, <span class="math inline">\(\exists\delta(\epsilon)&gt;0\)</span>, s.t. <span class="math inline">\(\vert\varphi(x_1)-\varphi(x_2)\vert&lt; \epsilon~(\forall x_1,x_2\in M, \rho(x_1,x_2)&lt;\delta,\forall\varphi\in F)\)</span>, 则称 <span class="math inline">\(F\)</span> 等度连续.</p><p>关于等度连续, 有如下的Arzela-Ascoli定理:</p><blockquote><p><strong>A-A</strong> <span class="math inline">\(F\subset C(M)\)</span> 列紧 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(F\)</span> 一致有界且等度连续.</p></blockquote><h3 id="准范数与frechet空间">准范数与Frechet空间</h3><h4 id="准范数">准范数</h4><p>线性空间 <span class="math inline">\(\mathscr{X}\)</span> 上的<strong>准范数</strong>定义为这个空间上的一个函数 <span class="math inline">\(\Vert\cdot\Vert:\mathscr{X}\to\mathbb{R}^1\)</span>, s.t.</p><ol style="list-style-type: decimal"><li><span class="math inline">\(\Vert x \Vert\geqslant 0\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>; <span class="math inline">\(\Vert x\Vert=0\Leftrightarrow x=\theta\)</span>;</li><li><span class="math inline">\(\Vert x+y\Vert\leqslant \Vert x\Vert+\Vert y\Vert\)</span>, <span class="math inline">\(\forall x,y\in\mathscr{X}\)</span>;</li><li><span class="math inline">\(\Vert -x\Vert=\Vert x\Vert\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>;</li><li><span class="math inline">\(\lim\limits_{\alpha_n\to 0}\Vert\alpha_n x\Vert=0\)</span>, <span class="math inline">\(\lim\limits_{\Vert x_n\Vert\to 0}\Vert\alpha x_n\Vert=0\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>, <span class="math inline">\(\forall\alpha\in\mathbb{K}\)</span>.</li></ol><h4 id="frechet空间">Frechet空间</h4><p>用准范数 <span class="math inline">\(\Vert x_n-x\Vert\to 0\)</span> 来定义极限 <span class="math inline">\(x_n\to x\)</span> 的线性空间 <span class="math inline">\(\mathscr{X}\)</span>, 称为 <span class="math inline">\(F^*\)</span> 空间. 完备的 <span class="math inline">\(F^*\)</span> 空间称为Frechet空间.</p><h3 id="范数与banach空间">范数与Banach空间</h3><h4 id="范数">范数</h4><p>线性空间 <span class="math inline">\(\mathscr{X}\)</span> 上的<strong>范数</strong> <span class="math inline">\(\Vert\cdot\Vert\)</span> 是一个非负值函数: <span class="math inline">\(\mathscr{X}\to\mathbb{R}^1\)</span>, s.t. 1. <span class="math inline">\(\Vert x\Vert\geqslant 0\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>, 且 <span class="math inline">\(\Vert x\Vert=0\Leftrightarrow x=\theta\)</span>; 2. <span class="math inline">\(\Vert x+y\Vert\leqslant \Vert x \Vert+ \Vert y\Vert\)</span>, <span class="math inline">\(\forall x,y\in\mathscr{X}\)</span>; 3. <span class="math inline">\(\Vert\alpha x\Vert=\vert\alpha\vert\Vert x\Vert\)</span>, <span class="math inline">\(\forall\alpha\in\mathbb{K}\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>.</p><h4 id="banach空间">Banach空间</h4><p>具有范数的 <span class="math inline">\(F^*\)</span> 空间称为 <span class="math inline">\(B^*\)</span> 空间, 完备的 <span class="math inline">\(B^*\)</span> 空间称为Banach空间.</p><h4 id="范数的等价">范数的等价</h4><p>范数 <span class="math inline">\(\Vert\cdot\Vert_1\)</span> 与 <span class="math inline">\(\Vert\cdot\Vert_2\)</span> 等价是指: <span class="math inline">\(\Vert x_n\Vert_1\Leftrightarrow \Vert x_n\Vert_2\)</span>, <span class="math inline">\(n\to\infty\)</span>. 即: <span class="math inline">\(\exists C_1,C_2&lt;0\)</span>, s.t. <span class="math inline">\(C_1\Vert x\Vert_1\leqslant\Vert x\Vert_2\leqslant C_2\Vert x\Vert_1\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>.</p><blockquote><p><strong>定理</strong> 有穷维 <span class="math inline">\(B^*\)</span> 空间的任意范数都等价.</p></blockquote><blockquote><p><strong>推论</strong> 相同维数的有穷维 <span class="math inline">\(B^*\)</span> 空间代数上同构, 拓扑上同胚.</p></blockquote><blockquote><p><strong>推论</strong> 有穷维 <span class="math inline">\(B^*\)</span> 空间必定完备, <font color="red"><strong>反之不成立</strong></font>.</p></blockquote><h4 id="半模">半模</h4><p>半模是 <span class="math inline">\(P:\mathscr{X}\to\mathbb{R}^1\)</span> 是线性空间 <span class="math inline">\(\mathscr{X}\)</span> 上的一个函数, s.t.</p><ol style="list-style-type: decimal"><li><span class="math inline">\(P(x)\geqslant 0\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>; <strong><font color="red">注意没有要求 <span class="math inline">\(P(x)=0\Leftrightarrow x=\theta\)</span></font></strong>;</li><li><span class="math inline">\(P(x+y)\leqslant P(x)+P(y)\)</span>, <span class="math inline">\(\forall x,y\in\mathscr{X}\)</span>;</li><li><span class="math inline">\(P(\alpha x)=\vert\alpha\vert P(x)\)</span>, <span class="math inline">\(\forall\alpha\in\mathbb{K}\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>.</li></ol><h4 id="有穷维-b-空间">有穷维 <span class="math inline">\(B^*\)</span> 空间</h4><blockquote><p><strong>定理</strong> <span class="math inline">\(B^*\)</span> 空间是有穷维的当且仅当其单位球面是列紧的.</p></blockquote><blockquote><p><strong>推论</strong> <span class="math inline">\(B^*\)</span> 空间是有穷维的当且仅当其任意有界集是列紧的.</p></blockquote><p>还有如下的Riesz引理:</p><blockquote><p><strong>Riesz 引理</strong> 如果 <span class="math inline">\(\mathscr{X}_0\)</span> 是 <span class="math inline">\(B^*\)</span> 空间 <span class="math inline">\(\mathscr{X}\)</span> 的一个真闭子空间, 那么对于 <span class="math inline">\(\forall 0&lt;\epsilon&lt;1\)</span>, <span class="math inline">\(\exists y\in\mathscr{X}\)</span>, s.t. <span class="math inline">\(\Vert y\Vert=1\)</span>, 且 <span class="math inline">\(\Vert y-x\Vert\geqslant1-\epsilon\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}_0\)</span>.</p></blockquote><h3 id="凸集与minkowski泛函">凸集与Minkowski泛函</h3><h4 id="凸集和凸包">凸集和凸包</h4><p>凸集: <span class="math inline">\(E\)</span> 是凸集 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(\lambda x+(1-\lambda)y\in E\)</span>, <span class="math inline">\(\forall x,y\in E\)</span>, <span class="math inline">\(\forall 0\leqslant\lambda\leqslant 1\)</span>.</p><p>凸包: <span class="math display">\[co(A)=\{\sum\limits_{i=1}^n\lambda_i x_i ~\vert~ \sum\limits_{i=1}^n \lambda_i=1, \lambda_i\geqslant 0, x_i\in A, i=1,2,\cdots,n, \forall n\in\mathbb{N}\}\]</span>为包含 <span class="math inline">\(A\)</span> 的最小凸集.</p><h4 id="minkowski泛函">Minkowski泛函</h4><p><span class="math inline">\(\mathscr{X}\)</span> 是线性空间, <span class="math inline">\(C\)</span> 是 <span class="math inline">\(\mathscr{X}\)</span> 上含有 <span class="math inline">\(\theta\)</span> 的凸子集, 则如下定义Minkowski泛函:</p><p><span class="math display">\[P(x)=\inf\{\lambda&gt;0 ~\vert~ \frac{x}{\lambda}\in C\},\quad \forall x\in\mathscr{X}.\]</span></p><h3 id="内积与hilbert空间">内积与Hilbert空间</h3><h4 id="共轭双线性函数">共轭双线性函数</h4><p>线性空间 <span class="math inline">\(\mathscr{X}\)</span> 上的双线性函数是指一个二元函数 <span class="math inline">\(a(\cdot,~\cdot):\mathscr{X}\times\mathscr{X}\to\mathbb{K}\)</span>, s.t.</p><ol style="list-style-type: decimal"><li><span class="math inline">\(a(a_1x_1+a_2x_2,y)=a_1a(x_1,y)+a_2a(x_2,y)\)</span>;</li><li><span class="math inline">\(a(x,b_1y_1+b_2y_2)=\overline{b_1}a(x,y_1)+\overline{b_2}a(x,y_2)\)</span>.</li></ol><h4 id="内积">内积</h4><p><span class="math inline">\(\mathscr{X}\)</span> 上的共轭双线性函数 <span class="math inline">\((\cdot,~\cdot)\)</span> 称为一个内积, 如果满足:</p><ol style="list-style-type: decimal"><li><span class="math inline">\((x,y)=\overline{(y,x)}\)</span>;</li><li><span class="math inline">\((x,x)\geqslant 0\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>, 且 <span class="math inline">\((x,x)=0\Leftrightarrow x=\theta\)</span>.</li></ol><ul><li>若去掉 <span class="math inline">\((x,x)=0\Leftrightarrow x=\theta\)</span> 的要求, 则称为<strong>半内积</strong>.</li><li>定义了内积的空间称为内积空间, 完备的内积空间称为<strong>Hilbert</strong>空间.</li></ul><h4 id="cauchy-schwarz-不等式">Cauchy-Schwarz 不等式</h4><blockquote><p><strong>C-S</strong> 设 <span class="math inline">\((\mathscr{X},(\cdot,~\cdot))\)</span> 是内积空间, 取 <span class="math inline">\(\Vert x\Vert=(x,x)^\frac{1}{2}\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>, 则有 <span class="math display">\[\vert (x,y)\vert\leqslant \Vert x\Vert\Vert y\Vert, \quad \forall x,y\in\mathscr{X}.\]</span>等号当且仅当 <span class="math inline">\(x=\lambda y\)</span> 取得.</p></blockquote><h4 id="内积空间与-b-空间">内积空间与 <span class="math inline">\(B^*\)</span> 空间</h4><ul><li>内积空间 <span class="math inline">\(\to\)</span> <span class="math inline">\(B^*\)</span> 空间</li></ul><blockquote><p>内积空间 <span class="math inline">\(\mathscr{X}\)</span> 按照 <span class="math inline">\(\Vert x\Vert=(x,x)^\frac{1}{2}\)</span> 定义范数, 是<strong>严格凸的 <span class="math inline">\(B^*\)</span> 空间</strong>, 且内积关于范数连续.</p></blockquote><ul><li><span class="math inline">\(B^*\)</span> 空间 <span class="math inline">\(\to\)</span> 内积空间</li></ul><blockquote><p>在 <span class="math inline">\(B^*\)</span> 空间 <span class="math inline">\(\mathscr{X}\)</span> 中, 为了引入内积满足上式, 范数必须满足 <span class="math display">\[\Vert x+y\Vert^2+\Vert x-y\Vert^2=2\Vert x\Vert^2+2\Vert y\Vert^2,\quad \forall x,y\in\mathscr{X}.\]</span></p></blockquote><h4 id="正交集">正交集</h4><ul><li>完备正交集: <span class="math inline">\(S\)</span> 为正交集, 且 <span class="math inline">\(S^\perp=\{\theta\}\)</span>.</li><li>Bessel 不等式</li></ul><blockquote><p><strong>Bessel</strong>设 <span class="math inline">\(\mathscr{X}\)</span> 是一个内积空间, 若 <span class="math inline">\(S=\{e_\alpha~\vert~\alpha\in A\}\)</span> 是其中的正交规范基, 那么 <span class="math inline">\(\forall x\in\mathscr{X}\)</span>, 有 <span class="math display">\[\sum\limits_{\alpha\in A}|(x,e_\alpha)|^2\leqslant \Vert x\Vert^2.\]</span> 事实上, <span class="math inline">\(\{\alpha\in A: (x,e_\alpha)\neq 0\}\)</span> 至多可数.</p></blockquote><ul><li>Parseval 等式</li></ul><blockquote><p><strong>Parseval</strong> 设 <span class="math inline">\(\mathscr{X}\)</span> 是一个Hilbert空间, <span class="math inline">\(S\)</span> 是正交规范基, 则 <span class="math display">\[S完备\Leftrightarrow \Vert x\Vert^2=\sum\limits_{\alpha\in A}|(x,e_\alpha)|^2,\quad \forall x\in\mathscr{X}.\]</span></p></blockquote><ul><li>正交分解</li></ul><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(M\)</span> 是Hilbert空间上的一个闭子空间, 则 <span class="math inline">\(\forall x\in\mathscr{X}\)</span> 存在唯一的正交分解: <span class="math display">\[x=y+z\quad (y\in M, z\in M^\perp).\]</span></p></blockquote><h2 id="线性算子与线性泛函">线性算子与线性泛函</h2><h3 id="riesz定理">Riesz定理</h3><h4 id="riesz定理-1">Riesz定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(f\)</span> 是Hilbert空间 <span class="math inline">\(\mathscr{X}\)</span> 上的一个连续线性泛函, 则存在唯一的 <span class="math inline">\(y_f\in\mathscr{X}\)</span>, s.t. <span class="math inline">\(f(x)=(x,y_f)\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>.</p></blockquote><p>该定理直接说明了: <strong><font color="red">若 <span class="math inline">\(\mathscr{X}\)</span> 是Hilbert空间, 则 <span class="math inline">\(\mathscr{X}=\mathscr{X}^*\)</span>.</font></strong></p><h3 id="开映像定理">开映像定理</h3><h4 id="baire纲定理">Baire纲定理</h4><blockquote><p><strong>Baire</strong> 完备度量空间 <span class="math inline">\((\mathscr{X},\rho)\)</span> 是第二纲集.</p></blockquote><h4 id="开映像定理-1">开映像定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\mathscr{X},\mathscr{Y}\)</span> 都是 <span class="math inline">\(B\)</span> 空间, 若 <span class="math inline">\(T\in\mathscr{L}(\mathscr{X},\mathscr{Y})\)</span> 是一个满射, 则 <span class="math inline">\(T\)</span> 是开映射.</p></blockquote><h3 id="闭图像定理">闭图像定理</h3><h4 id="bounded-linear-transform">Bounded Linear Transform</h4><blockquote><p><strong>B.I.T</strong> 设 <span class="math inline">\(T\)</span> 是 <span class="math inline">\(B^*\)</span> 空间 <span class="math inline">\(\mathscr{X}\)</span> 到 <span class="math inline">\(B\)</span> 空间 <span class="math inline">\(\mathscr{Y}\)</span> 的连续线性算子, 那么 <span class="math inline">\(T\)</span> 能唯一地延拓到 <span class="math inline">\(\overline{D(T)}\)</span> 上称为连续线性算子 <span class="math inline">\(T_1\)</span>, s.t. <span class="math inline">\(T_1\vert_{D(T)}=T\)</span>, 且 <span class="math inline">\(\Vert T_1\Vert=\Vert T\Vert\)</span>.</p></blockquote><blockquote><p><strong>命题</strong> <span class="math inline">\(T\)</span> 是闭算子 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(G_T\)</span> 按照图模 (<span class="math inline">\(\Vert x\Vert_G=\Vert x\Vert+\Vert Tx\Vert\)</span>) 是闭集.</p></blockquote><h4 id="范数等价定理">范数等价定理</h4><blockquote><p><strong>定理</strong> 设线性空间 <span class="math inline">\(\mathscr{X}\)</span> 有范数 <span class="math inline">\(\Vert\cdot\Vert_1\)</span> 和 <span class="math inline">\(\Vert\cdot\Vert_2\)</span>. 若 <span class="math inline">\(\mathscr{X}\)</span> 关于二者都构成 <span class="math inline">\(B\)</span> 空间, 且 <span class="math inline">\(\Vert\cdot\Vert_1\)</span> 比 <span class="math inline">\(\Vert\cdot\Vert_2\)</span> 强, 则二者等价.</p></blockquote><h4 id="闭图像定理-1">闭图像定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\mathscr{X},\mathscr{Y}\)</span> 是 <span class="math inline">\(B\)</span> 空间. 若 <span class="math inline">\(T\)</span> 是 <span class="math inline">\(D(T)\to\mathscr{Y}\)</span> 的闭线性算子, 且 <span class="math inline">\(D(T)\)</span> 闭, 则 <span class="math inline">\(T\)</span> 连续.</p></blockquote><h3 id="共鸣定理">共鸣定理</h3><h4 id="共鸣定理-1">共鸣定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\mathscr{X}\)</span> 是 <span class="math inline">\(B\)</span> 空间, <span class="math inline">\(\mathscr{Y}\)</span> 是 <span class="math inline">\(B^*\)</span> 空间, 如果 <span class="math inline">\(W\subset\mathscr{L}(\mathscr{X},\mathscr{Y})\)</span>, s.t. <span class="math inline">\(\sup\limits_{A\in W}\Vert Ax\Vert&lt;\infty~~(\forall x\in\mathscr{X})\)</span>, 那么存在常数 <span class="math inline">\(M\)</span>, s.t. <span class="math inline">\(\Vert A\Vert\leqslant M\)</span>, <span class="math inline">\(\forall A\in W\)</span>.</p></blockquote><p>立刻有如下推论:</p><blockquote><p><strong>推论</strong> 设 <span class="math inline">\(\mathscr{X}\)</span> 是Banach空间, <span class="math inline">\(A\subset\mathscr{X}^*\)</span>, 则 <span class="math inline">\(A\)</span> 有界 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(\forall x\in\mathscr{X}\)</span>, <span class="math inline">\(\sup\limits_{f\in A}\vert f(x)\vert&lt;\infty\)</span>.</p></blockquote><h4 id="banach-steinhaus定理">Banach-Steinhaus定理</h4><blockquote><p><strong>B-S</strong> 设 <span class="math inline">\(\mathscr{X}\)</span> 是 <span class="math inline">\(B\)</span> 空间, <span class="math inline">\(\mathscr{Y}^*\)</span> 是 <span class="math inline">\(B^*\)</span> 空间, <span class="math inline">\(M\)</span> 是 <span class="math inline">\(\mathscr{X}\)</span> 的稠子集. 取 <span class="math inline">\(A_n~(n=1,2,\cdots)\in\mathscr{L}(\mathscr{X},\mathscr{Y})\)</span>, 则 <span class="math inline">\(\lim\limits_{n\to\infty}A_n x=Ax~(\forall x)\)</span> 当且仅当: 1. <span class="math inline">\(\Vert A_n\Vert\)</span> 有界; 2. 对于 <span class="math inline">\(\forall x\in M\)</span>, 有 <span class="math inline">\(\lim\limits_{n\to\infty}A_n x=Ax\)</span>.</p></blockquote><p>该定理实际上说明了算子列的收敛性和有界性很大程度上决定于其在一个稠子集上的情况.</p><h4 id="lax-milgram定理">Lax-Milgram定理</h4><blockquote><p><strong>L-M</strong> 设 <span class="math inline">\(a(x,y)\)</span> 是Hilbert空间 <span class="math inline">\(\mathscr{X}\)</span> 上的一个共轭双线性函数, s.t. 1. <span class="math inline">\(\exists M&gt;0\)</span>, s.t. <span class="math inline">\(\vert a(x,y)\vert\leqslant M\Vert x\Vert\Vert y\Vert~~(\forall x,y\in\mathscr{X})\)</span>; 2. <span class="math inline">\(\exists\delta&gt;0\)</span>, s.t. <span class="math inline">\(\vert a(x,y)\vert\geqslant\delta\Vert x\Vert^2~~(\forall x\in\mathscr{X})\)</span>.</p></blockquote><blockquote><p>则存在唯一的有连续逆的线性算子 <span class="math inline">\(A\in\mathscr{L}(\mathscr{X},\mathscr{Y})\)</span>, s.t. <span class="math inline">\(a(x,y)=(x,Ay)\)</span>, <span class="math inline">\(\forall x,y\in\mathscr{X}\)</span>, 且 <span class="math inline">\(\Vert A^{-1}\Vert\leqslant\frac{1}{\delta^2}\)</span>.</p></blockquote><h3 id="hahn-banach定理">Hahn-Banach定理</h3><h4 id="实hahn-banach定理">实Hahn-Banach定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\mathscr{X}\)</span> 是实线性空间, <span class="math inline">\(p\)</span> 是定义在 <span class="math inline">\(\mathscr{X}\)</span> 上的次线性泛函, <span class="math inline">\(\mathscr{X}_0\)</span> 是 <span class="math inline">\(\mathscr{X}\)</span> 的实线性子空间, <span class="math inline">\(f_0\)</span> 是 <span class="math inline">\(\mathscr{X}_0\)</span> 上的实线性泛函并满足 <span class="math inline">\(f_0(x)\leqslant p(x)~(\forall x\in\mathscr{X}_0)\)</span>. 则 <span class="math inline">\(\mathscr{X}\)</span> 上存在(<strong>未必唯一</strong>)一个实线性泛函 <span class="math inline">\(f\)</span>, s.t. 1. <span class="math inline">\(f(x)\leqslant p(x)~(\forall x\in\mathscr{X})\)</span>; 2. <span class="math inline">\(f(x)=f_0(x)~(\forall x\in\mathscr{X}_0)\)</span>.</p></blockquote><h4 id="复hahn-banach定理">复Hahn-Banach定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\mathscr{X}\)</span> 是复线性空间, <span class="math inline">\(p\)</span> 是定义在 <span class="math inline">\(\mathscr{X}\)</span> 上的半模, <span class="math inline">\(\mathscr{X}_0\)</span> 是 <span class="math inline">\(\mathscr{X}\)</span> 的线性子空间, <span class="math inline">\(f_0\)</span> 是 <span class="math inline">\(\mathscr{X}_0\)</span> 上的线性泛函并满足 <span class="math inline">\(|f_0(x)|\leqslant p(x)~(\forall x\in\mathscr{X}_0)\)</span>. 则 <span class="math inline">\(\mathscr{X}\)</span> 上存在(<strong>未必唯一</strong>)一个线性泛函 <span class="math inline">\(f\)</span>, s.t. 1. <span class="math inline">\(|f(x)|\leqslant p(x)~(\forall x\in\mathscr{X})\)</span>; 2. <span class="math inline">\(f(x)=f_0(x)~(\forall x\in\mathscr{X}_0)\)</span>.</p></blockquote><h4 id="hahn-banach定理-1">Hahn-Banach定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\mathscr{X}\)</span> 是 <span class="math inline">\(B^*\)</span> 空间, <span class="math inline">\(\mathscr{X}_0\)</span> 是 <span class="math inline">\(\mathscr{X}\)</span> 的线性子空间, <span class="math inline">\(f_0\)</span> 是定义在 <span class="math inline">\(\mathscr{X}_0\)</span> 上的有界线性泛函, 则在 <span class="math inline">\(\mathscr{X}\)</span> 上存在有界线性泛函 <span class="math inline">\(f\)</span>, s.t. 1. <span class="math inline">\(f(x)=f_0(x)~(\forall x\in\mathscr{X})\)</span> (在 <span class="math inline">\(\mathscr{X}_0\)</span> 不变); 2. <span class="math inline">\(\Vert f\Vert=\Vert f_0\Vert_0\)</span> (保范).</p></blockquote><p>由此可以立刻得到推论</p><blockquote><p><strong>推论 1</strong> 在 <span class="math inline">\(B^*\)</span> 空间 <span class="math inline">\(\mathscr{X}\)</span> 上, <span class="math inline">\(\forall x_1,x_2\in\mathscr{X}\)</span>, <span class="math inline">\(\exists f\in\mathscr{X}^*\)</span>, s.t. <span class="math inline">\(f(x_1)=f(x_2)\)</span>. <strong>推论 2</strong> 设 <span class="math inline">\(\mathscr{X}\)</span> 是 <span class="math inline">\(B^*\)</span> 空间, <span class="math inline">\(\forall x_0\in\mathscr{X}\backslash\{\theta\}\)</span>, <span class="math inline">\(\exists f\in\mathscr{X}\)</span>, s.t. <span class="math inline">\(f(x_0)=\Vert x_0\Vert\)</span>, 且 <span class="math inline">\(\Vert f\Vert=1\)</span>.</p></blockquote><p>对于 <span class="math inline">\(B^*\)</span> 空间 <span class="math inline">\(\mathscr{X}\)</span> 的子空间 <span class="math inline">\(M\)</span>, 有如下结论:</p><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\mathscr{X}\)</span> 是 <span class="math inline">\(B^*\)</span> 空间, <span class="math inline">\(M\)</span> 是其线性子空间. 若 <span class="math inline">\(x_0\in\mathscr{X}\)</span>, 且 <span class="math inline">\(d:=\rho(x_0,M)&gt;0\)</span>, 则 <span class="math inline">\(\exists f\in\mathscr{X}^*\)</span>, s.t. 1. <span class="math inline">\(f(x)=0~~(\forall x\in M)\)</span>; 2. <span class="math inline">\(f(x_0)=d\)</span>; 3. <span class="math inline">\(\Vert f\Vert=1\)</span>.</p></blockquote><h4 id="hahn-banach定理的几何形式">Hahn-Banach定理的几何形式</h4><p>考虑 <span class="math inline">\(B^*\)</span> 空间 <span class="math inline">\(\mathscr{X}\)</span> 中的一个包含 <span class="math inline">\(\theta\)</span> 的真凸子集 <span class="math inline">\(E\)</span> 及 <span class="math inline">\(E\)</span> 外的一点 <span class="math inline">\(x_0\)</span>, 考虑 <span class="math inline">\(E\)</span> 的Minkowski泛函 <span class="math inline">\(p(x)\)</span>, 则 <span class="math inline">\(p\)</span> 是 <span class="math inline">\(\mathscr{X}\)</span> 上的非零连续次线性泛函.</p><p><strong>此时考虑Hahn-Banach定理的应用条件</strong>, 取子空间 <span class="math display">\[\mathscr{X}_0=\{\lambda x_0~\vert~\lambda\in\mathbb{R}^1\}\]</span> 及其上的线性泛函 <span class="math inline">\(f_0(\lambda x_0)=\lambda p(x_0)\)</span>. 则有 <span class="math inline">\(f_0(x)\leqslant p(x)\)</span>.</p><p><strong>至此, Hahn-Banach定理的条件已经全部满足</strong>. 于是存在实线性泛函 <span class="math inline">\(f\)</span>, s.t. <span class="math inline">\(f(x)\leqslant p(x)~(\forall x\in\mathscr{X})\)</span>, 且 <span class="math inline">\(f(x)=f_0(x)~(\forall x\in\mathscr{X}_0)\)</span>. 又由 <span class="math inline">\(f_0\)</span> 定义可知 <span class="math inline">\(f(x_0)\geqslant 0\)</span>, 以及 <span class="math inline">\(f(x)\leqslant 1~(\forall x\in E)\)</span>, 故 <strong><span class="math inline">\(H_f^1\)</span> 分离 <span class="math inline">\(x_0\)</span> 与 <span class="math inline">\(E\)</span></strong>.</p><p>即如下的几何形式的Hahn-Banach定理:</p><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(E\)</span> 是实 <span class="math inline">\(B^*\)</span> 空间 <span class="math inline">\(\mathscr{X}\)</span> 上以 <span class="math inline">\(\theta\)</span> 为内点的真凸子集, 又设 <span class="math inline">\(x_0\overline{\in}E\)</span>, 则必定存在一个超平面 <span class="math inline">\(H_f^r\)</span> 分离 <span class="math inline">\(x_0\)</span> 与 <span class="math inline">\(E\)</span>.</p></blockquote><p>由此可得到如下定理:</p><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(E_1\)</span> 和 <span class="math inline">\(E_2\)</span> 是 <span class="math inline">\(B^*\)</span> 空间中互不相交的非空凸集, 且 <span class="math inline">\(E_1\)</span> 有内点, 那么 <span class="math inline">\(\exists s\in\mathbb{R}^1\)</span> 以及非零线性连续泛函 <span class="math inline">\(f\)</span>, s.t. 超平面 <span class="math inline">\(H_f^s\)</span> 分离 <span class="math inline">\(E_1\)</span> 和 <span class="math inline">\(E_2\)</span>. 换言之, 存在非零连续线性泛函 <span class="math inline">\(f\)</span>, s.t. <span class="math inline">\(f(x)\leqslant s~(\forall x\in E_1)\)</span> 且 <span class="math inline">\(f(x)\geqslant s~(\forall x\in E_2)\)</span>.</p></blockquote><p>进而有如下两条定理:</p><ul><li>Ascoli定理</li></ul><blockquote><p><strong>Ascoli</strong> 设 <span class="math inline">\(E\)</span> 是实 <span class="math inline">\(B^*\)</span> 空间 <span class="math inline">\(\mathscr{X}\)</span> 中的闭凸集, 则 <span class="math inline">\(\forall x_0\in\mathscr{X}\backslash E\)</span>, <span class="math inline">\(\exists f\in\mathscr{X}^*\)</span> 及 <span class="math inline">\(a\in\mathbb{R}^1\)</span>, s.t. <span class="math inline">\(f(x)&lt;a&lt;f(x_0)\)</span>, <span class="math inline">\(\forall x\in E\)</span>.</p></blockquote><ul><li>Mazur定理</li></ul><blockquote><p><strong>Mazur</strong> 设 <span class="math inline">\(E\)</span> 是 <span class="math inline">\(B^*\)</span> 空间 <span class="math inline">\(\mathscr{X}\)</span> 上的一个有内点的闭凸集, <span class="math inline">\(F\)</span> 是 <span class="math inline">\(\mathscr{X}\)</span> 上的一个线性流形, 又设 <span class="math inline">\(E\cap F=\varnothing\)</span>, 则存在一个包含 <span class="math inline">\(F\)</span> 的闭超平面 <span class="math inline">\(L\)</span>, s.t. <span class="math inline">\(E\)</span> 在 <span class="math inline">\(L\)</span> 的一侧.</p></blockquote><h3 id="共轭空间">共轭空间</h3><ul><li>设 <span class="math inline">\(\mathscr{X}\)</span> 是一个 <span class="math inline">\(B^*\)</span> 空间, <span class="math inline">\(\mathscr{X}\)</span> 上的所有连续限行泛函全体 <span class="math inline">\(\mathscr{X}^*\)</span> 按照范数 <span class="math inline">\(\Vert f\Vert=\sup\limits_{\Vert x\Vert=1} \vert f(x)\vert\)</span> 构成一个 <span class="math inline">\(B\)</span> 空间, 称为 <span class="math inline">\(\mathscr{X}\)</span> 的共轭空间.</li></ul><blockquote><p><strong>定理</strong> 有 <span class="math inline">\((L^p[0,1])^*=L^q[0,1]\)</span>, <span class="math inline">\(\frac{1}{p}+\frac{1}{q}=1~(1\leqslant p&lt;\infty)\)</span>.</p></blockquote><p><font color="red"><strong>值得注意的是, <span class="math inline">\((L^\infty[0,1])^*\neq L^1[0,1]\)</span></strong>.</font></p><h4 id="第二共轭空间与自反空间">第二共轭空间与自反空间</h4><p><span class="math inline">\(\mathscr{X}^*\)</span> 的共轭空间 <span class="math inline">\(\mathscr{X}^{**}\)</span> 称为 <span class="math inline">\(\mathscr{X}\)</span> 的第二共轭空间.</p><p><strong>自然映射</strong>: 对于 <span class="math inline">\(\forall x\in\mathscr{X}\)</span>, 考虑 <span class="math inline">\(X(f)=f(x)~(\forall f\in\mathscr{X}^*)\)</span>, 则 <span class="math inline">\(X\)</span> 是 <span class="math inline">\(\mathscr{X}^*\)</span> 上的线性泛函, 且满足 <span class="math inline">\(\vert X(f)\vert\leqslant \Vert f\Vert\Vert x\Vert\)</span>. 因此 <span class="math inline">\(X\)</span> 是连续的, 满足 <span class="math inline">\(\Vert X\Vert \leqslant \Vert x\Vert\)</span>.</p><p>称上文中的映射 <span class="math inline">\(T:x\mapsto X\)</span> 为<strong>自然映射</strong>. 容易验证 <span class="math inline">\(T\)</span> 是一个等距嵌入, 于是有如下定理</p><blockquote><p><strong>定理</strong> <span class="math inline">\(B^*\)</span> 空间 <span class="math inline">\(\mathscr{X}\)</span> 与它的第二共轭空间 <span class="math inline">\(\mathscr{X}^{**}\)</span> 的一个子空间等距同构, 即 <span class="math inline">\(\mathscr{X}\subset\mathscr{X}^{**}\)</span>.</p></blockquote><p><strong>自反空间</strong>: 若自然映射 <span class="math inline">\(T\)</span> 是满射, 则称 <span class="math inline">\(\mathscr{X}\)</span> 是自反的. 即 <span class="math inline">\(\mathscr{X}=\mathscr{X}^{**}\)</span></p><p>关于自反空间, 有如下定理:</p><blockquote><p><strong>定理</strong> 有限维 <span class="math inline">\(B^*\)</span> 空间是自反的. 特别地, <span class="math inline">\(L^p~(1&lt;p&lt;\infty)\)</span> 是自反的.</p></blockquote><h4 id="弱收敛">弱收敛</h4><p><strong>弱收敛</strong>: 设 <span class="math inline">\(\mathscr{X}\)</span> 是一个 <span class="math inline">\(B^*\)</span> 空间, <span class="math inline">\(\{x_n\}\subset\mathscr{X}\)</span>, <span class="math inline">\(x\in\mathscr{X}\)</span>. 若对于 <span class="math inline">\(\forall f\in\mathscr{X}^*\)</span>, 均有 <span class="math inline">\(\lim\limits_{n\to\infty}f(x_n)=f(x)\)</span>, 则称 <span class="math inline">\(\{x_n\}\)</span> 弱收敛于 <span class="math inline">\(x\)</span>, 记作 <span class="math inline">\(x_n\rightharpoonup x\)</span>.</p><p>容易得到弱收敛和强收敛有如下关系:</p><ul><li>强收敛蕴含弱收敛, 反之不成立(尽管对于 <span class="math inline">\(\mathbb{R}\)</span> 成立);</li><li>当强极限存在时, 强弱收敛等价, 且极限唯一;</li><li>弱极限若存在必定唯一(利用Hahn-Banach定理可证).</li></ul><p>简单概括如下:</p><p><font color="red"><span class="math display">\[强收敛 \underset{在 \mathbb{R} 上}{\rightleftarrows}~弱收敛\quad\quad 强极限\underset{强极限存在}{\rightleftarrows}~弱极限\]</span></font></p><p>在 <span class="math inline">\(B^*\)</span> 空间上, 有如下的Mazur定理:</p><blockquote><p><strong>Mazur</strong> 设 <span class="math inline">\(\mathscr{X}\)</span> 是一个 <span class="math inline">\(B^*\)</span> 空间, 且 <span class="math inline">\(x_n\rightharpoonup x_0\)</span>(注意是弱收敛), 则 <span class="math inline">\(\forall\epsilon&gt;0\)</span>, <span class="math inline">\(\exists \lambda_i&gt;0~(i=1,2,\cdots,n)\)</span>, <span class="math inline">\(\sum\limits_{i=1}^n\lambda_i=1\)</span> s.t. <span class="math display">\[\Vert x_0-\sum\limits_{i=1}^n\lambda_i x_i\Vert\leqslant \epsilon.\]</span></p></blockquote><h4 id="弱收敛-1"><span class="math inline">\(*\)</span> 弱收敛</h4><p><strong><span class="math inline">\(*\)</span> 弱收敛</strong>: 设 <span class="math inline">\(\mathscr{X}\)</span> 是 <span class="math inline">\(B^*\)</span> 空间, <span class="math inline">\(\{f_n\}\subset\mathscr{X}^*\)</span>, <span class="math inline">\(f\in\mathscr{X}^*\)</span>. 若 <span class="math inline">\(\forall x\in\mathscr{X}\)</span>, 都有 <span class="math inline">\(\lim\limits_{n\to\infty}f_n(x)=f(x)\)</span>, 则称 <span class="math inline">\(f_n~*\)</span> 弱收敛于 <span class="math inline">\(f\)</span>, 记作 <span class="math inline">\(w^*-\lim\limits_{n\to\infty}f_n=f\)</span>.</p><p><strong><span class="math inline">\(\mathscr{X}^*\)</span> 上的弱收敛</strong>: 设 <span class="math inline">\(\{f_n\}\subset\mathscr{X}^*\)</span>, <span class="math inline">\(f\in\mathscr{X}^*\)</span>. 若对 <span class="math inline">\(\forall X\in\mathscr{X}^{**}\)</span>, 都有 <span class="math inline">\(X(f_n)\to X(f)\)</span>, 则称 <span class="math inline">\(f_n\)</span> 弱收敛于 <span class="math inline">\(f\)</span>.</p><p><strong>可以证明, <span class="math inline">\(\mathscr{X}^*\)</span> 上的弱收敛 <span class="math inline">\(\Rightarrow~*\)</span> 弱收敛.</strong> 特别地, 当 <span class="math inline">\(\mathscr{X}\)</span> 是一个自反空间时, 二者等价.</p><h4 id="弱列紧与-弱列紧性">弱列紧与 <span class="math inline">\(*\)</span> 弱列紧性</h4><p>对于 <span class="math inline">\(*\)</span> 弱列紧性, 有如下的定理:</p><blockquote><p><strong>定理</strong>: 可分的 <span class="math inline">\(B^*\)</span> 空间中的有界列必定有 <span class="math inline">\(*\)</span> 弱列紧的子列.</p></blockquote><p>进一步还有如下的定理:</p><ul><li>Banach定理:</li></ul><blockquote><p><strong>Banach</strong> 若 <span class="math inline">\(\mathscr{X}\)</span> 是 <span class="math inline">\(B^*\)</span> 空间, 则 <span class="math inline">\(\mathscr{X}\)</span> 可分 <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(\mathscr{X}^*\)</span> 可分.</p></blockquote><ul><li>Pettis定理:</li></ul><blockquote><p><strong>Pettis</strong> 自反空间 <span class="math inline">\(\mathscr{X}\)</span> 的自反空间 <span class="math inline">\(\mathscr{X}_0\)</span> 也是自反的.</p></blockquote><h2 id="附录">附录</h2><h3 id="几种范数">几种范数</h3><p><strong>范数</strong>: 正定性(<span class="math inline">\(\Vert x\Vert=0\Leftrightarrow x=\theta\)</span>)+三角不等式+齐次性.</p><ul><li>准范数: 与范数差齐次性;</li><li>半范数: 与范数差 <span class="math inline">\(\Vert x\Vert=0\Leftrightarrow x=\theta\)</span>.</li></ul><h3 id="几种收敛">几种收敛</h3><h4 id="mathscrx-的收敛"><span class="math inline">\(\mathscr{X}\)</span> 的收敛</h4><center><font color="red"><strong>强收敛 <span class="math inline">\(\Rightarrow\)</span> 弱收敛</strong></font></center><ul><li><strong>弱收敛</strong>: <span class="math inline">\(\forall f\in\mathscr{X}^*\)</span>, <span class="math inline">\(f(x_n)\to f(x)\)</span>, 记作 <span class="math inline">\(x_n\rightharpoonup x\)</span>;</li><li><strong>强收敛</strong>: <span class="math inline">\(\Vert x_n-x\Vert\to 0\)</span>, 记作 <span class="math inline">\(x_n\to x\)</span>.</li></ul><h4 id="mathscrx-的收敛-1"><span class="math inline">\(\mathscr{X}^*\)</span> 的收敛</h4><center><font color="red"><strong>一致收敛 <span class="math inline">\(\Rightarrow\)</span> 强收敛 <span class="math inline">\(\Rightarrow\)</span> 弱收敛 <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(*\)</span> 弱收敛</strong></font></center><ul><li><strong>一致收敛</strong>: <span class="math inline">\(\Vert f_n-f\Vert\to 0\)</span>, 记作 <span class="math inline">\(f_n\rightrightarrows f\)</span>;</li><li><strong>强收敛</strong>: <span class="math inline">\(\Vert (f_n-f)x\Vert\to 0~(\forall x\in\mathscr{X})\)</span>, 记作 <span class="math inline">\(f_n\to f\)</span>;</li><li><strong>弱收敛</strong>: <span class="math inline">\(X(f_n)\to X(f)~(\forall X\in\mathscr{X}^{**})\)</span>, 记作 <span class="math inline">\(f_n\rightharpoonup f\)</span>;</li><li><strong><span class="math inline">\(*\)</span>弱收敛</strong>: <span class="math inline">\(\forall x\in\mathscr{X}\)</span>, 有 <span class="math inline">\(f_n(x)\to f(x)\)</span>, 记作 <span class="math inline">\(w^*-\lim\limits_{n\to\infty}f_n=f\)</span>;</li><li><strong>以上极限若存在必唯一</strong>.</li></ul><h3 id="几种banach空间">几种Banach空间</h3><ol style="list-style-type: decimal"><li><span class="math inline">\(\mathbb{C}^n\)</span> 按照范数 <span class="math inline">\(\Vert x\Vert=(\sum\limits_{i=1}^n\vert x_i\vert^2)^{\frac{1}{2}}\)</span> 构成一个Banach空间;</li><li><span class="math inline">\(C(M)\)</span> (<span class="math inline">\(M\)</span> 是一个紧度量空间) 按照范数 <span class="math inline">\(\Vert f\Vert=\max\limits_{x\in M}\vert f(x)\vert\)</span> 构成一个Banach空间;</li><li><span class="math inline">\(L^p(\Omega,\mu)\)</span> 按照范数 <span class="math inline">\(\Vert f\Vert=\left(\int\nolimits_\Omega \vert f(x)\vert^p{\rm d}x\right)^{\frac{1}{p}}\)</span> 构成Banach空间.</li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 泛函分析 </tag>
            
            <tag> 期末复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2017年概率测度小测二题目</title>
      <link href="/2017/12/20/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62017%E5%B9%B4%E6%A6%82%E7%8E%87%E6%B5%8B%E5%BA%A6%E5%B0%8F%E6%B5%8B%E4%BA%8C%E9%A2%98%E7%9B%AE/"/>
      <content type="html"><![CDATA[<h2 id="题目">题目</h2><h3 id="判断题">判断题</h3><p>正确须证明, 错误须举反例, 没有理由不得分.</p><ol style="list-style-type: decimal"><li>给定概率空间 <span class="math inline">\((\Omega, \mathcal{F}, P)\)</span>, 如果对于 <span class="math inline">\(\forall A\in\mathcal{F}\)</span>, 有 <span class="math inline">\(P(A)=0 或 1\)</span>, 则:<ol style="list-style-type: decimal"><li><span class="math inline">\(\mathcal{F}=\{\Omega,\varnothing\}\)</span>;</li><li>对于任意随机变量 <span class="math inline">\(X\in\mathcal{F}\)</span>, 有 <span class="math inline">\(X=C\)</span>, P-a.s..</li></ol></li><li>给定测度空间 <span class="math inline">\((\Omega, \mathcal{F}, \mu)\)</span>, <span class="math inline">\(f\in\mathcal{F}\)</span>. 若 <span class="math inline">\(\mu\)</span> 是 <span class="math inline">\(\sigma\)</span>-有限的, 则 <span class="math inline">\(\mu_f\)</span> 也是 <span class="math inline">\(\sigma\)</span>-有限的.</li></ol><h3 id="计算证明">计算&amp;证明</h3><ol style="list-style-type: decimal"><li><p>设 <span class="math inline">\(X_1\)</span>, <span class="math inline">\(X_2\)</span> 是独立随机变量, <span class="math inline">\(X_1\sim U[0,1]\)</span>, <span class="math inline">\(X_2\sim B(n,p)\)</span>. 试证 <span class="math inline">\(Y=X_1+X_2\)</span> 是连续型随机变量并求其密度函数.</p></li><li><p>给定测度空间 <span class="math inline">\((\Omega, \mathcal{F}, \mu)\)</span>, <span class="math inline">\(f_n\in\mathcal{F}\)</span> 可积, <span class="math inline">\(\sup\limits_n \int f_n{\rm d}\mu&lt;\infty\)</span>, 且 <span class="math inline">\(f_n\uparrow f\)</span>. 试证: <span class="math inline">\(f\)</span> 可积, 且 <span class="math inline">\(\int f_n{\rm d}\mu\to\int f{\rm d}\mu\)</span>.</p></li></ol><h2 id="简略解答">简略解答</h2><h3 id="判断题-1">判断题</h3><ol style="list-style-type: decimal"><li>两小问:<ol style="list-style-type: decimal"><li>错误. 取 <span class="math inline">\(A\subset\Omega\)</span>, <span class="math inline">\(\mathcal{F}=\{\varnothing, A, A^c, \Omega\}\)</span>, <span class="math inline">\(\mu( \varnothing)=\mu(A^c)=0\)</span>, <span class="math inline">\(\mu(A)=\mu(\Omega)=1\)</span>, 容易验证是一个反例.</li><li>正确. 注意正测度集存在性的证明.</li></ol></li><li>错误. 考虑 <span class="math inline">\(\mathbb{R}\)</span> 上的Lebesgue测度, <span class="math inline">\(f:\mathbb{R}\to\{1\}\)</span>, <span class="math inline">\(x\mapsto 1\)</span>. 则 <span class="math inline">\(\mu_f\)</span> 不是 <span class="math inline">\(\sigma\)</span>-有限.</li></ol><h3 id="计算证明-1">计算&amp;证明</h3><ol style="list-style-type: decimal"><li><p>课后习题.</p></li><li><p><span class="math inline">\(f_1\)</span> 可积, <span class="math inline">\(f_1\leqslant f_n\uparrow f\)</span>, 由单调收敛定理可得结论.</p></li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>明月杯回忆录</title>
      <link href="/2017/12/05/%E6%98%8E%E6%9C%88%E6%9D%AF%E5%9B%9E%E5%BF%86%E5%BD%95/"/>
      <content type="html"><![CDATA[<h1 id="x00.-2014">0x00. 2014</h1><h2 id="明月杯流水账">明月杯流水账</h2><p>还记得和兄弟们第一次一起打球是军训刚回学校时。那时师大的篮球场还在装修，于是只好跑到北邮的球场。那时北邮还没有门禁，球场的人也不多，正是军训回来放松的好地方。从那以后，虽然经常与同学们一起打球，但<strong>因为抱有转专业的想法，所以没有直接加入篮球队</strong>，<del>不过后来还是被博哥拉进了球队Orz</del>。</p><p>第一次和球队的兄弟们打友谊赛也是在北邮，也是我第一次听说“二三联防”。哇，打篮球竟然还有这么多说法，原来我们之前都是瞎攻瞎防，野球玩家瑟瑟发抖Orz。这次友谊赛就像是给什么也不懂的我开启了新世界的大门，在随后的训练中也了解了许多在野球场上从未有过的战术。</p><p>明月杯如期而至，但<strong>作为菜鸟的我并未入选球队大名单</strong>。值得一提的是，大名单中仅有的两名菜鸟球员分别是擅长突破，转身华丽的明星小前侯彦丞和高中就了解联防的战术专家周月林，加上高年级的明星球员李奕、张博和欧正鑫，信科球队一路高歌猛进，取得小组出线资格进入八强。之后信科在八强碰到了老对手数科，侯彦丞一记绝杀帮助李奕师兄打破了连续三年败给数科的魔咒，同时也宣告了数科时代的结束。</p><p><strong>四强比赛前，由于苏禾师兄有事回家，队长与校会沟通后将我放进了比赛名单中。</strong>我正是在这场球中收获了明月杯的第一分，一个抢到前场篮板后的二次投篮（听说你们内线很能跳）。地遥很强，尽管我们已经全力以赴，但还是难以抵挡地遥的外线双枪，最终大比分输掉比赛，无缘邱季端。</p><p>三四名决赛的对手化学拥有实力强劲的新人王全，还在淘汰赛中战胜了在小组赛中战胜信科的环境，但信科的实力到底还是更胜一筹，经过加时赛的苦战，<strong>信科最终取得比赛胜利，拿下季军。</strong></p><p>关于14年的图片资料大多没有保存下来。。。惨。</p><h2 id="几句废话">几句废话</h2><p>客观地说，<strong>信科2014级可以称得上是信科的黄金一代。</strong>大局观良好+身体强壮的控卫王唯，投篮稳健+弹跳劲爆的射手贾鑫，得分能力出众+突破犀利的锋线大杀器侯彦丞，内线脚步扎实+拼抢积极的强力大前王伟程，虽然技术不大行但是弹跳还可以抢救一下的中锋李喆琛（嗯就是我），这样的阵容足以令每个学院的球队羡慕。加上凶狠敢拼的周月林和球风飘逸的席伟，信科14级正在迎来他们的时代。</p><p>大一的事情总是很难忘。唯神在北邮摔伤膝盖，自己与小小俊打球时摔伤，训练时啦啦队送来冒着热气的早饭……这些场景我至今都清晰地记得。还有总被我称作“高手”的干哥，大个子老乡哲哥，还有喜欢扣篮的涛son……谢谢你们的陪伴和支持( '▿ ' )。</p><h1 id="x01.-2015">0x01. 2015</h1><h2 id="明月杯流水账-1">明月杯流水账</h2><h3 id="概况">概况</h3><p>第二年明月杯，仍然是熟悉的赛场，但信科男篮的队伍也在悄悄发生着改变：李奕师兄的毕业使得信科内线少了一个强大的进攻点；而2015级新生的到来使得我们收获了灵活的内线球员唐聪以及技术精湛的外线球员王梓晗。<strong>此时我已经转入数学科学学院学习，但由于各种因素的影响，我最终还是选择在信科球队打球。</strong></p><p><strong>这是信科创造历史最佳战绩的一年，信科在欧哥和博哥两位大哥的带领下杀入了邱季端，这也是信科首次进入邱季端。</strong></p><h3 id="小组赛">小组赛</h3><p><strong>小组赛除了惜败给哲社外没有太大的波折。</strong></p><p>首场面对心理学院（现为心理学部），对方显然难以应付欧哥和侯彦丞的疯狂进攻，两人最后分别拿下了13分和8分的数据，信科也以29:9胜出。</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-xinli3.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="小组赛对阵心理：赛前"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-xinli1.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="小组赛对阵心理：防守（唐聪&amp;欧哥）"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-xinli2.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="小组赛对阵心理：暂停（教练赵晓睿）"></center><p>信科遭遇的第一场失利是小组赛面对拥有mvp陈宏礼的哲社球队。由于中锋郑培凯因身体原因无法，故球队在比赛前一天晚上开了很久的会讨论如何防守陈宏礼（Orz），最后决定由我和侯彦丞采用夹击的战术来应对陈的突破。事实证明我们的策略确实生效了，陈宏礼全场仅得到9分（陈宏礼明月杯目前为止场均得分为19.8）。但我们似乎<strong>太过重视陈宏礼，导致对于其他人的防守不够严密，得分机会过多。</strong>其中，对方球员付天睿拿下了全场最高分24分，在最后几分钟的关键争夺中更是命中关键投篮，杀死比赛。最终信科以44:48失利，同时也宣告哲社预定小组第一。值得一提的是，张博和欧正鑫分别成为了信科本场的得分王（14分）和篮板王（12板），侯彦丞本场发挥不佳，24次出手仅命中2球，效率也为全队最低的-16（笑尿）。我虽然在本场中拿到了8分10板和全队最高的效率值14，但仍然存在一些问题，集中体现在不适应中锋站位，补防速度慢。赛后分析中，化院的沈芸稼师兄明确指出：“最后一球肯定是中锋的锅”，在观看录像后，也确实能够看出是我补防不及时，导致了最后时刻付天睿的进球，直接导致了比赛的失利。在比赛的最后时刻，前队长张博在一次进攻扭伤了脚踝，比赛激烈可见一斑。<strong>尽管失利总是令人失望的事，但这场失利对于我们而言并不是坏消息，甚至是将我们送进邱季端的一大助力。</strong></p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-zheshe1.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="小组赛对阵哲社：暂停指导"></center><p>球队在后续的小组赛中并没有遇到任何阻力，凯哥火力全开拿下全场最高11分，带领球队47:19轻松击败天文，顺利晋级八强。</p><h3 id="八强">八强</h3><p>八强赛面对教育，对方的主力李尧沣面对信科的铁血防守难以延续小组赛的好状态，多次强打我方大前1号（没错就是我哈哈哈）未果，甚至吃到火锅，最终16投仅有3中，教育也只能吞下失利的苦果。而隔壁的八强赛，经管由于自己的轻敌，败给了艺传，将艺传送上了四强席位。至于另一半区，经过八进四的筛选，哲社与地遥在四强相遇。</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-jiaoyu1.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="八强对阵教育：抢板"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-jiaoyu3.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="八强对阵教育：暂停"></center><h3 id="四强">四强</h3><p>四强赛中，艺传阵中战胜经管的最大功臣利啓权本场面对信科完全哑火，实力更高一筹的信科以23:11顺利拿下比赛，欧哥更是拿下11分7抢断的数据，统治攻防两端，成功带队进入邱季端。另一边的哲社……就比较惨了，被拥有双枪的朱帕尔（砍下18分7板）和陈星源（砍下13分6助）的地遥成功阻击。信科与地遥会师决赛。</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-yichuan1.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="四强对阵艺传：突破"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-yichuan2.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="四强对阵艺传：对抗"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-yichuan3.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="四强对阵艺传：观众"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-yichuan4.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="四强对阵艺传：合影"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-siqiang.jpeg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="四强对阵艺传：庆祝"></center><h3 id="决赛">决赛</h3><p>赛前第一次体会了进邱季端的豪华服务：各种拍宣传照，（弱渣瑟瑟发抖Orz），队员们也对决赛充满信心。</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-xinke.JPG?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="决赛宣传照：信科"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-xiaohui.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="决赛宣传照：校会"></center><p>然而，校会宣布比赛日期时所有人都沉默了——<strong>比赛日期恰好与ACM EC-Final冲突。</strong>尽管与校会方面做了沟通，但日期仍然确定在了这一天，经过一番调整，最终的结果是<strong>首发中锋郑培凯无法参赛</strong>，同时我也没能去参加EC-Final。</p><p>比赛当天，又突发变故。首发大前（我Orz）在下午发烧。以缺少主力的阵容面对卫冕冠军地遥球队，信科球队并没有放弃，并在上半场一直保持领先。但在下半场快节奏的攻防转换中没有顶住对方的反扑，最后时刻的追分又有些慌乱，最终37:41不敌地遥。</p><p>本场比赛对我而言意义非凡。第一次在发烧的情况下打比赛，直到上场时仍然手掌冰凉，甚至手指在碰球时会感到轻微的疼痛。这也直接导致了在开场跳球时弹速不够快甚至没有跳过对方的李震（从图上看来高度是足够的，但因弹速不够，所以触球晚……md 生涯耻辱）。</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-js4.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="邱季端vs地遥：跳球"></center><p>虽然我没有跳赢，但我方后卫积极拼抢，拿到了第一攻的球权。虽然对方外线球员实力强悍，但内线非常羸弱，这使得我们可以通过冲抢前场篮板来获取更多进攻机会。经过侯彦丞、王伟程的一轮刷板-打铁，我抢到了前场篮板，随后投中了本场第一粒进球。说到这里我就不得不吹一波……这粒进球的难度还是很高的，从下图可以看出，我在投篮时上半身是正对篮筐，而仔细看脚和裤腿的遮挡关系就可以发现，下半身的方向其实和上半身是反着的（是不是做一个商空间就可以得到一条mobius band哈哈哈）。</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-js1.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="邱季端vs地遥：本场第一个进球"></center><p>前两节的大部分时间信科都保持了领先，对方的明星球员朱帕尔在高压防守之下表现不佳，屡次出手不中。信科则依靠强大的内线频频冲抢进攻篮板（尽管主力中锋缺席，但在信科弹跳比较好的中锋以及身高较高的外线面前，地遥羸弱的内线仍然难以阻挡）。经过两节的战斗，信科以16：14领先进入下半场。</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-js2.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="邱季端vs地遥：侯彦丞罚球"></center><p>到了下半场，地遥内线薄弱造成的犯规压力渐渐显露了出来，包括绝对核心陈星源在内的多名主力球员都背上了3次甚至4次的犯规，但由于命中率等各种原因，双方的比分并没有拉开，甚至地遥在陈星源命中三分之后成功以21:18取得了领先，并继续将比分优势扩大到4分。此时信科球员出现了体力问题，于是将替补球员卢浩然换上了场。<del>随后比赛就进入了转折<code>_(:з」∠)_</code></del> 也许是连续几波运动战没有得分，比分的差距被拉大，使得信科的球员比较着急：核心欧正鑫的出手有些仓促，卢浩然也在短时间内连续出现3次犯规，于是分差被进一步拉大，达到7分。最终信科以14:31落后进入第四节。（附一张拔萝卜式抢板的照片，可看出地遥羸弱的内线）</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-jslb.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="邱季端vs地遥：拔萝卜"></center><p>进入第四节，由于地遥的主力朱帕尔因犯规过多被教练换下，因而攻防能力有所下降。刚开场侯彦丞就迅速造成犯规并两罚一中，对方中锋李震拿到后场篮板后立刻被我抢断，经过一轮刷板后我命中本场第二球，将比分追至27:31。但良好的追分态势并没有持续太久。仅仅两分钟后，王伟程就在一次抢球中被吹犯规，并因满犯被罚下。信科并没有立刻因为主力的罚下而受到影响：侯彦丞造成李震犯规，使得其五犯下场。随后在地遥发起的一次快攻中，我直接将陈星源的上篮大帽扇飞（下图中的血帽陈星源，看着很刺激）并继续拿下一次抢断，接着信科在欧哥和贾鑫接连得分后，将比分扳至32:33。接下来又是几分钟的拉锯战，期间裁判将我对陈星源的一个盖帽吹为了犯规（我认为是好帽，不过也不能仅因此过多抱怨裁判），欧哥也因所剩时间不多，心态产生了波动，数次运动战都在我还没有落位时就仓促出手打铁，浪费了较多机会。比赛时间所剩无几，信科以37:39落后，此时对方球员陈小强命中了一粒两分球，形式也因此十分危急。在最后时刻的争夺中，可能是由于体力原因，数次出手机会均没有命中，侯彦丞由于抽筋，罚球也未能命中。最终信科以37:41不敌地遥，无缘冠军。</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-jsgm.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="邱季端vs地遥：血帽陈星源"></center><p>对方球员陈星源全场得到28分，展现了其强大的进攻能力，身背4次犯规仍能一直打到最后时刻也体现了对犯规的良好控制，尤其是令我印象颇为深刻的一次切球，在欧哥上篮时干净利落地将欧哥的球切掉，成功阻挡了信科的反扑，这种冷静确实是我们中的许多人所缺乏的。赛后的聚餐我由于身体原因没有参加，不知道博哥是不是又喝哭了哈哈哈。（附一张赛后合影）</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-js3.jpeg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="邱季端vs地遥：赛后合影"></center><h2 id="几句废话-1">几句废话</h2><h3 id="谈数科一">谈数科（一）</h3><p>没有选择加入数科球队的原因是很复杂的，其中比较主要的是两条：</p><ol style="list-style-type: decimal"><li>和数科球队的同学，师兄都不太熟悉，但和信科这边的人已经非常熟悉；</li><li>在与数科的友谊赛中对于数科12级某师兄非常厌恶。</li></ol><p>当然其中也有信科极力挽留并且信科球队实力很强，有机会冲击更好成绩等很多因素。总之这件事情并不是巧合，现在想起来也并没有后悔，只是觉得“道不同，不相与谋”吧。<strong>数科球队的团队、氛围、文化，本身就不适合我，我又怎么可能加入数科球队呢？</strong>前些日子在与谢老师、魏老师谈话时没有详细地解释这些原因，只谈了最关键的两点，并不是不敢说我对数科球队的看法，也不是不好意思和老师谈，只是觉得没必要。<strong>学生的事情停留在学生这里就好，何必惊动老师</strong>。我不大聪明，不像一些人懂得“我不好直接和你说，我就请老师给你打电话，找你谈话，还可以把事情推给老师”。同样在数科，我怎么没有学到这些聪明的技巧呢( '▿ ' ) <strong>可能每个人在大学，学到的是不一样的东西( '▿ ' )？</strong></p><p>顺带一提，在决赛前，数科某球员曾经帮助过我们训练。然而两年后的决赛，正是在他的煽动下，数科使出了盘外招将我禁赛。兄弟情谊？不存在的。其人还在双方球队代表谈判时装模作样抹了几把眼泪，之后借故离场，也许出门后就再也忍不住露出得意的微笑？或许这就是“兄弟”<sub>（此处特意用了此人最喜欢的波浪线</sub>~~）</p><h3 id="谈校会">谈校会</h3><p>对于我们而言，决赛争议颇大的一点是<strong>比赛时间的确定</strong>。事实上，不管是由于什么样的原因，信科在校学生会从来没有得到过公正的待遇。 明月杯决赛的比赛时间是很充裕的（可选取范围的很广），信科方面关于比赛时间也与校会做过沟通。这里我不做太阴暗的猜测（比如地遥与校会有某些交易，专门将时间定在这一天？），容易落人口实。但此事体现出的就是：<strong>信科在校会处没有话语权</strong>。这其中的原因可能有信科学生会的乌烟瘴气（非常乱&amp;非常烂&amp;只代表个人观点），也也可能有信科体育部的原因。但是，<strong>校会这方面的问题是一直存在的[ '▿ ' ]</strong>。</p><p>记得有一场面对某大院的比赛，信科要求改时间，校会方面要求信科与对方沟通（翻译一下：对方是大院得罪不起，你们自己搞定）；另一场比赛，信科对阵某小院，对方要求改时间，对方球队在校会的要求下来找信科球队沟通（翻译一下：你们小院，校会还没有为了你们得罪信科的必要，你们自己搞定）；可还有一场比赛，是某小院对阵某大院，据说并没有经过太多流程，比赛时间就顺利调整了（翻译一下：大院就是可以为所欲为）。这便是校会一贯的办事风格。</p><p>回到这次比赛，作为主办方，我个人认为校会有必要保障双方的权益，尽量选在双方都同意的时间。本身比赛就在周末，双方队员也很容易就能错开时间。事实上，对于信科而言，唯一不合适的时间就是12.12那一周，如果把比赛时间提前一周或推后一周，相信对方也不会因此受到很大的影响。然而校会可能不会考虑这么多：是呀，挑一个好时间比赛，多麻烦的事情呀，我们直接拍板就好了。于是信科只好以缺少重要球员的残阵迎战。校会很强，我服了。</p><h1 id="x02.-2016">0x02. 2016</h1><h2 id="明月杯流水账-2">明月杯流水账</h2><h3 id="概况-1">概况</h3><p>12级的师兄们在这一年毕业了，于是信科缺少了技术扎实的后卫张博以及内线大闸郑培凯。另一方面，欧哥在家乡实习，也不能回学校参赛，于是信科缺少了去年的绝对核心。在实力下降的情况下，<strong>信科男篮在信科2014级的带领下小组赛保持全胜，出线后不敌数科止步八强。</strong></p><h3 id="稍微详细的版本">稍微详细的版本</h3><p>小组赛首场面对生科（大家都说其实跳球就暗示了比赛结果）</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2016myb-shengketq.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="小组赛vs生科：跳球"></center><p>尽管信科的实力严重下滑，但两队的实力差距还是比较大的。尽管如此，慢热的信科还是在开局阶段一度落后4分，但随着信科球员逐渐找回状态，首发球员频频命中投篮，很快就追平了比分，并以13:5领先进入下半场（附一张罚球图片哈哈）。</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2016myb-shengkefq.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="小组赛vs生科：罚球"></center><p>下半场刚开始我就有一次失误入账（囧），但对方未能得分。随后我又命中了一粒后仰跳投，进一步拉大了比分，此时比赛悬念已经不大，于是双方球员在球场上都显得放松了一些。最终本场我拿下了全场最高的……7分Orz，这也是我第一次得到全场最高分。信科以28：12顺利拿下首胜。（附赛后双方握手以及信科队伍合影）</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2016myb-shengkews.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="小组赛vs生科：握手"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2016myb-shengkehy.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="小组赛vs生科：合影"></center><p>第二场小组赛对阵实力一般的政管，本以为能够前三节搞定对手第四节下场休息，但比赛一直到了第四节才分出胜负。于是，很惨，又打满了全场Orz。。赛前还尝试了一次空接扣篮，<del>但是很遗憾扣飞了</del>，我才不告诉你们成功没==</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2016myb-zhengguankl.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="小组赛vs政管：训练时尝试空接扣篮"></center><p>跳球仍然是毫无压力，第一节大家的发挥也比较稳健，虽然进攻端效率一般，但防守很强硬，以7:2结束第一节。</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2016myb-zhengguantq.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="小组赛vs政管：跳球"></center><p>第二节的比赛中，信科延续了第一节的强硬防守，政管一分未得。但在延续强硬防守的同时，进攻也比第一节更铁。。最后我一记三分打铁结束了上半场的战斗，信科以10:2暂时领先进入下半场。（附一张突破图，可以看出对方的防守也很严密，包夹比较到位。<del>但是无奈哥太强他们防不住</del>）</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2016myb-zhengguantupo.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="小组赛vs政管：突破"></center><p>第三节中，信科众将依然手感冰凉，整节只得2分。但政管本节手感回暖，拿下5分，将比分追至12:7后，听着王伟程两罚不中“乒乒乓乓”的打铁声进入了第四节。至此，政管仍有翻盘的希望。感到形势危急的信科球员重新找回了一部分投篮技能包，将比分拉至15:7。最后时刻对方想通过快打三分的战术来做一下最后的挣扎，但传球时遭到我的抢断，并直接完成一条龙快攻，彻底杀死比赛。最终比分定格在17:7，信科取得两连胜。</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2016myb-zhengguankg1.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="小组赛vs政管：快攻1"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2016myb-zhengguankg2.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="小组赛vs政管：快攻2"></center><p>第三场小组赛对阵教育，本场并没有太大压力，信科以29：15顺利拿下比赛，取得三连胜。至此，信科取得小组出线资格，只差和外文争夺小组第一的位置。（随手附一张抢篮板卡位的照片以及赛后全队的合影）</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2016myb-jiaoyukw.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="小组赛vs教育：卡位"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2016myb-jiaoyuhy.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="小组赛vs教育：合影"></center><p>最后一场小组赛面对的是拥有在前三场场均20+10的新星庄子晨以及技术精湛的后卫卢明江的外文。面对外文的跳球是我这一年第一次跳球失败Orz，但信科仍然神奇地取得了球权。体力充沛的上半场永远是拉开比分的最好时机，加上我本场手感火热，两次出手全部命中（第二次还是单手扔的，防守人压着我的左手，然而本场的裁判就像瞎了一样），比分很快就来到了11:2。尽管比分领先，但信科的后卫们却遭遇了史无前例的防守压迫：先是王伟程的上篮被庄子晨大力扇飞，然后王梓晗的中距离出手又遭遇庄子晨排球大帽，导致后卫们有些畏手畏脚，不敢突破。就在关键时刻，我趁乱接到了球，站在三分线外空位出手命中，将比分拉大到14:3，分差首次来到两位数。又经过一段时间的拉锯战，信科以14:5结束了上半场。第三节中信科仍然保持了9分的领先优势，以21:12进入末节。</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2016myb-waiwen3f.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="小组赛vs外文：三分"></center><p>第四节中，外文后卫卢明江加强了对内线的冲击，加上对方命中了两记神奇的三分球，外文不断追分，一度将比分追至23:19。但此时比赛已经进入尾声，对方也采取了犯规战术。此时正是考验球员素质的时刻，然而对方球员卢明江却动作越来越大。终于，在一次信科的快攻中，气急败坏的卢用一个非篮球动作对信科球员犯规，被吹技术犯规（场下观众都看不下去了哈哈哈），同时也满犯离场，并在离场时脱下自己的球衣狠狠砸在地面上泄愤，随即遭到了全场的嘘声。此时比赛已经没有了悬念，最终信科以32:24拿下比赛，以小组第一身份出线。王伟程凭借最后时刻罚球刷分，成功超越我（11分），取得全场最高的13分Orz。</p><p>淘汰赛面对老冤家数科，开场王梓晗命中2分后，数科球员蔡伯文立刻用一记三分还以颜色，紧接着又顶着防守命中一颗神奇的2分。至此，信科气势已经被全面压倒，赛场也进入了数科的节奏。在追分的过程中，信科的控球者王伟程和侯彦丞显得有些慌乱，也有些着急，最终信科13:21不敌数科，结束了本届明月杯之旅。</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2016myb-shuke.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="淘汰赛vs数科"></center><h2 id="几句废话-2">几句废话</h2><h3 id="谈数科二">谈数科（二）</h3><p>整个数科球队我认识的人中，我最欣赏，也最佩服的人，就是頔哥。此处不谈頔哥练球刻苦，打球干净不搞小动作；也不谈頔哥在明月杯的压力之下仍然考上人大统计研究生。这里只谈和我相关的事情。</p><p>在14年败给地遥之后的聚餐中，李奕师兄对（那时）想转系的席伟说“信科转到数科的不少，也有不少打球厉害的转过去了，但他们碰到我们的时候不会上场”。受到这句话的影响，在15年我转入数科，但仍然留在信科打球时，我也说过类似于“如果数科碰到信科，我就不上场”的话。但幸运的是，两队在15年没有碰面，我们也成功创造了历史最佳成绩。但在16年的八进四比赛上，两队碰面了。想起之前的承诺，我当然会说我不上场，信科各位球员的劝说，甚至是欧哥的长篇大论都没有让我动摇。就这样到了比赛前的两天。</p><p>让我改变想法的是頔哥。队长王伟程（应该是他，但不敢确定）给我看了与頔哥的聊天记录，依稀记得頔哥说的两句话：“石睿平和我说lzc不打，我就和他说让他打”，还有“<strong>兄弟之间，该怼就要怼</strong>”。正是頔哥的这番言论让我想清楚，比赛代表的是球队，院系的事情，不应该过多带入到比赛中来。虽然最终在场上也受了一些心态上的影响，但这一年也没有太多遗憾的事情。</p><p>然而，真正奇怪的是，石睿平直到赛前都没有来找我“让我打”，数科也没有一个认识我的球员来找我说明这件事情。我很好奇，难道是頔哥撒谎了？更为可悲的是，一年后，这件事情竟被数科的球员摆在了谈判桌上，将頔哥的意见扯到了自己头上。数科15级队长（不点名）表示：“去年也是淘汰赛，按理来说和总决赛同等重要，但我们让lzc上场了。”言下之意便是“去年是给你们面子才让lzc上场的”。我不知道，实在是不知道，他是抱着怎样的心态说出这句话的。另一边，某人一把鼻涕一把泪地说“我和信科有感情，我和欧哥有感情”，，我也很难理解，这到底是怎样一个人，才能如此惺惺作态。</p><h3 id="谈信科">谈信科</h3><p>这一年的比赛，大多数都有一个共同的特点：<strong>上半场砍分，第三节崩盘</strong>。这种现象的成因我至今都搞不明白。</p><p>如果说是因为信科首发阵容强大，第一节能凭借首发的得分能力将分差拉开，那还算正常。但信科首发偏偏都很<strong>慢热</strong>。首场面对生科是慢热最好的体现。两队实力差距非常大，但在刚开局时，信科手感冰凉，前几次出手均未命中；反观生科，进入状态迅速，韩嘉伟和于翔宇里突外投，很快就拉开了4分的分差。经历了17年的比赛后，我大致明白了，慢热是由于训练强度不够大的原因。而第三节崩盘最好的体现是与政管的比赛，整场手感冰凉，第三节还险些被追平比分。其原因我至今也没有想通Orz。</p><p>信科的另一个严重的问题是<strong>缺乏气势</strong>。这一点最好的体现就是与数科的比赛。虽然信科命中了第一粒进球，但大哥立刻命中三分给出回应，接着又是一颗非常提士气的两分，信科顿时气势全无。。。气势是球场上很重要的一环，只是那时我们不够关注这件事。欧哥也遗憾地告别了明月杯。</p><h1 id="x03.-2017">0x03. 2017</h1><h2 id="明月杯流水账-3">明月杯流水账</h2><h3 id="概况-2">概况</h3><p>信科在这一年迎来了强大的17级，包括全能球星李家和，长臂大前谢清宇，和防守强悍的后卫张指导。小组赛势如破竹，连克外文、历史、和哲社，以小组头名身份闯入八强。在淘汰赛中接连战胜地理学部和卫冕冠军经管，三年内第二次进入邱季端。</p><p>在决赛前的几天，数科使出了一些见不得光的盘外手段，将我禁赛。缺少内线核心的信科以37：44不敌数科，再次获得亚军。想必看球的各位也懂得，冠军应该是谁[手动微笑]。</p><h3 id="邱季端门票">邱季端门票</h3><p>不太客气地讲，这一年的明月杯就是个笑话。</p><p>首先从揭幕战数科vs物理谈起。这是一场精彩的比赛，双方的攻防都很不错，然而一些问题严重影响了这场比赛。比赛进行到最后一分钟时，物理领先6分，围观者大多觉得大局已定。这时为了追分，数科使出了自己的看家本领全场紧逼，物理对此显然准备不足，被对方多次成功防守，分差越来越小。然而，由于物理在重压之下仍然命中了一些投篮，数科始终不能扳回比分。很快，比赛时间就所剩无几，物理仍然领先3分。这时数科球员投篮造成物理犯规，哨响后，数科的9号随意地上了一颗空篮，命中。<strong>这显然是一颗不计分的球</strong>，然而，可能是因为校会的记分员不懂规则（并不敢想象更奇怪的原因），将这一球判为了有效进球。于是在数科两罚全中后，数科成功“反超”，场下观众一脸懵逼。此时比赛时间只剩几秒，物理未能继续得分，数科成功罚球“绝杀”。<em>文字直播地址：http://m.lanqiu.woaoo.net/schedule/59349.html</em></p><p>赛后，物理的同学显然对比赛结果很不服气，于是有同学在蛋蛋网上发帖，引起了非常激烈的讨论。数科石某人在其中摆出的态度再次刷新了我的认知，真是太6了Orz。有没有问题，您自己心里没数么？您有录像也可以自证清白呀，谁不知道数科的比赛每场自己都会录像。墙都不服，就服您。（此处有石某人的精选评论截图[手动微笑]）<em>蛋蛋网微信推送地址：https://mp.weixin.qq.com/s/2RsB6fZ_iB8LiLsejD9TTQ</em></p><center><img src="http://olgwnj89q.bkt.clouddn.com/srp666.jpg" alt="人在zuo 天在看"></center><p>本以为校会能够认识到自己的错误，将比赛办好。但万万没想到，这只是个开始。</p><p>小组赛首场面对老对手外文。外文在17年也迎来了补强：一个又高又壮但技术一般的中锋，这无论对他们的内线防守还是篮板争抢，都是一个明显的提升，所以外界普遍认为这将是一场恶战。</p><p>但首节的战斗却出乎了所有人的意料：信科以14:0碾压了外文。这并不是因为外文首发太弱，而是外文的核心后卫卢明江并没有首发出场（原因不明），导致其羸弱的外线被抢断到心态爆炸，这也直接导致了本场外文的失利。（随手附一张李家和突破照片，此时卢明江[7号]已经上场）</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2017myb-waiwendc.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="小组赛vs外文：李家和突破"></center><p>在卢明江上场后，外文在卢与庄子晨的配合下展开了反击。但由于外文在第一节挖的坑太大，信科几乎整场都保持了两位数的领先，最终36:25拿下首胜。李家和本场拿下22分5篮板5盖帽的豪华数据，实力carry全队。（附赛后合影）</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2017myb-waiwenhy.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="小组赛vs外文：合影"></center><p>第二场面对实力较弱的历史，全队12人均有得分进账，谢清宇小同学非常兴奋，拿下全场最高21分，信科以58:12轻松拿下第二场胜利。（附赛后合影）</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2017myb-lishihy.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="小组赛vs历史：合影"></center><p>两战全胜的信科在第三场面对哲社，与哲社争夺小组头名。信科本场又犯了慢热的老毛病，第二节刚开始不久，就落后了6分之多，但在首发球员的努力下，加强了对于对方球星陈宏礼的防守，以10:15进入下半场。（随手贴一张上篮）</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2017myb-zheshetl1.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="小组赛vs哲社：上篮"></center><p>进入下半场，信科渐渐找回了状态，陈宏礼渐渐显得独木难支，双方展开了拉锯战，以18：21进入第四节。（再随手贴一张投篮，感谢侯彦丞dalao妙传）</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2017myb-zheshetl2.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="小组赛vs哲社：投篮"></center><p>进入第四节，陈宏礼也出现了体力问题，比赛很快就彻底进入了信科的节奏。哲社在最后相当长的一段时间内，都未能得分，最终信科以29:25战胜哲社。（附赛后合影）</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2017myb-zheshehy.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="小组赛vs哲社：合影"></center><p>值得一提的是，信科在终场前两秒执行两次罚球，全部命中后，哲社落后4分。虽然比赛结果已经尘埃落定，但是抱着拼到最后一刻的心态，陈宏礼在发球后直接在后场出手，不中。此时比赛显然已经可以判定为结束，然而哲社又获得了一次两秒的最后一攻的机会，陈宏礼再次超远三分出手不中，比赛才正式结束。对此感到不满的信科教练任挪走向技术台理论，竟然被体育部部长张浩东言语辱骂。原来校会这个样子，是上梁不正下梁歪啊。</p><p>出线后的八强赛中，信科面对的是已经沦为鱼腩球队的老对手地遥。带着14,15败给地遥的旧恨，信科没有给地理任何机会，以41:14干脆利落地拿下比赛。值得一提的是，在最后一节的一次快攻机会中，我过掉了对方的防守球员，然后上空篮不进==囧（全场嘘声Orz），信科众将也被我的这一顿操作惊得目瞪口呆。不过在下一波进攻中，我面对对方的防守投中了一颗干拔三分，嘿嘿嘿，还是这种感觉爽。赛后，当年地遥的小弟-如今地理的大哥：李震同志拒绝与信科握手，宽广的胸襟显露无疑，真是德艺双馨的好典范。（附赛后合影）</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2017myb-diyaohy.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="八强vs地遥： 合影"></center><p>四强赛中，面对的是实力仍然强悍的经管。上半场信科占据主动，以14:7领先。下半场经管开始发力，信科的得分势头也开始下降，体力也渐渐出现了问题。第三节马上就要结束时，信科仅有1分入账，领先优势也只剩2分。但在最后一攻中，我接球命中了一粒三分，将分差又拉大到了5分，双方以18:13进入第四节。第四节信科的进攻更加惨不忍睹，正常时间内只有我在篮下的一次打板得手。但经管也没有得到太多机会，没能直接扳平或反超比分，最终信科21:19战胜经管，三年内第二次进入邱季端的舞台。</p><center><img src="?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslimhttp://olgwnj89q.bkt.clouddn.com/basketball-2017myb-jingguanfq.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="四强vs经管：李家和罚球"></center><p>谈起这次比赛，其实发挥不佳有一个很重要的因素，就是赛前对于对手战术的错误估计。赛前我们研究了经管vs文新的八强比赛录像，发现经管对于文新的闫芳齐采取了一盯四联的防守策略，成功限制了闫芳齐。于是我们推测，经管可能会在比赛中对于李家和采取同样的防守策略。接着，在赛前的训练中，特意设计了两套新的战术来应对一盯四联的防守，名字分别叫“库里”和“五道口”（笑尿）。然而。。经管在比赛中几乎全场都没有使用一盯四联的防守策略，这也一定程度上导致了进攻端的低迷。但最终还是依靠着强硬的防守赢得了比赛的胜利。</p><h3 id="再入邱季端">再入邱季端</h3><p>比赛之前当然是拍了一发宣传照。（只贴了自己的照片和合影，<del>有点丑 将就看</del>）</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2017myb-hy.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="2017邱季端：宣传照"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2017myb-geren.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="2017邱季端：合影"></center><p>很遗憾没能再次触摸邱季端的地板，事情的始末将在下文详细交待。最终的结果是唐聪替代我出场，缺少主力的信科仍然与对方战斗到最后一刻才分出胜负，最终37:44不敌数科。李家和发挥出色，拿下了28分15板的怪兽级数据，这也是给自己最好的生日礼物。（随手附两张图）</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2017myb-jsqiuyi1.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="2017-邱季端赛后-1"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2017myb-jsqiuyi2.jpg?imageMogr2/auto-orient/thumbnail/600x/blur/1x0/%7Cwatermark/2/text/WmhlY2hlbg==/font/c2Vnb2Ugc2NyaXB0/fontsize/320/fill/Izg1ODU4NQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="2017-邱季端赛后-2"></center><h2 id="明月杯史上最大笑话">明月杯史上最大笑话</h2><center><font color="red"><strong>靠改分赢球的队伍，靠禁赛赢球的队伍：冠军，您配吗？</strong></font></center><p>赛前的过程我也懒得详细再写一遍，直接掏出当时发的说说好了。事情的经过如下：</p><ol style="list-style-type: decimal"><li>信科队长在报名前未开具双方签字的证明;</li><li>按照规则需要开具该证明，但校会并未审查出;</li><li>数科在比赛前四天（划重点 马上就要开赛的时候）对参赛资格提出异议<strong>并怂恿老师给我打电话</strong>;</li><li>校会提出可以补开证明，但数科不同意签字（数科男篮 一支稳健的队伍 此条五毛）。</li></ol><p><strong>怎么说呢，球场上的人得到大家的尊重，未必是因为荣誉。</strong>想起去年赛前我提出遇到数科可以不打，頔哥直接说“让他打，兄弟该怼就要怼”的事情，如今竟是以“我们去年时候就可以不让你上场”的方式被数科提出。事实上，我毫不怀疑如果当年您们坐在頔哥的位置上，肯定不会让我上场的~（此处又用了某人最爱的波浪线）哈哈，可能有些东西是无法传承的吧。借用师大著名球星的话：“篮球本来是很纯粹的事情，但很可惜不是每个人都这样想。”</p><p>同一件事情，君子有君子的解决办法，小人也会有小人的解决办法。既然对面是小人，那我不得不防：<strong>谈判<font color="red">全程录音</font></strong>。</p><p>谈判时，数科队长表示“很尴尬，我始终是不愿意面对琛哥的”。可我想说的是，你既然已经做出了这个决定，我们也就不可能再是什么“兄弟”了，进而想到石某人虚伪的丑陋嘴脸，我更是没来由的一阵干呕：和欧哥有感情，您配么？<strong>关于球赛，类似的事情绝不是没有发生过。但是参与的人不同，结果自然也不同。</strong>据陈宏礼回忆，之前BBA的决赛，他所在的队伍与欧哥所在的队伍相遇，因为他的个人原因请求变更比赛时间，而欧哥方面<strong>同意</strong>了变更的请求。石某人既然与欧哥如此有感情，那么您的奸诈是从哪里学来的？欧哥和您可不是一路人。不过您赢了，一把鼻涕一把泪的表演，着实恶心了我一回。</p><p>接下来数科王队长的一番话更加令我无言以对了。也就是我多次提到的“去年我们就可以禁赛你，但我们没有，是因为我们有情谊”。哇，厉害厉害。正如上文所说，我从未想过这件事情能以这种刁钻的角度提出来。不知道頔哥听了这番话会作何感想，当时没有禁赛的事情，请问和您有半毛钱关系么[手动滑稽]？一路躺赢的感觉相比也很爽吧~事实上，我也丝毫不怀疑，如果当年是您处于頔哥的位置，会毫不犹豫地提出禁赛的事情。没啥特别的原因，就是觉得您比较厉害呀。</p><p><strong>事实证明了，录音非常有必要。数科男篮的无耻早已超出了我的理解范畴</strong>。谈判的最后一点时间，梓晗再也不能忍受对方的无耻，直接发飙。然而数科的石某人，直接将禁赛的原因归结到了梓晗发飙这件事情上。红口白牙，胡说八道？难以想象这到底是怎样一个人。頔哥知道禁赛的事后表示“不知道是谁提出的禁赛，真傻逼”——頔哥不知道吧，你说的就是你的下一任队长呀。对于石某人，我的言论也就到此为止。人在zuo，天在看，祝石某人考研顺利~下半辈子都活在夺冠的美梦里[手动滑稽]。</p><p>最后，我想谈谈关于老师的看法。<strong>首先需要说明，我并不对魏老师以及谢老师抱有敌意，但落到这件事情上，我个人认为二位有拉偏架的嫌疑。</strong>最早是我与魏老师单独谈话时，魏老师已经免不了露出自己的倾向：“考虑最好的结果，数科战胜信科夺冠……”抱歉，我不觉得这是最好的结果。在我们几个还没有进入会议室时，魏老师就已经憋不住得意的笑容了，边笑边说“校会那边已经说了，五点了，他就是不能打”，但还是表示“不过再给你们一个机会，去找他们谈一谈，我作为老师不插手”。然而到了会议室以后，情况却不大相同：老师又扬了扬手机说“虽然我这里已经掌握了可以直接左右战局的信息，不过你们还是先谈一谈”。这句话表面上看着是给你们公平讨论的机会，实则提醒了数科的队员“你们已经是占优势的一方，能坐下来谈已经是给足他们面子了”。这也就注定不是一场“讲道理”的谈判。<strong>数科男篮的无耻、数科老师的倾向，加上校会的甩锅和信科团学的软弱，最终结果实际也在意料之中</strong>。总而言之，就这件事情而言，我不觉得魏老师、谢老师扮演了一个公平的裁决者。至于魏老师称自己为“护犊子”，这护的大概是“数科”，而不是我。<strong>如果这篇文章有幸被老师看到，恕我迟钝，没能在这件事情上体会到您对我的照顾</strong>。</p><h1 id="数科与信科">数科与信科</h1><h2 id="谈数科男篮为保荣誉不择手段的小人团伙">谈数科男篮：为保荣誉不择手段的小人团伙</h2><center><font color="red"> <strong>只针对17阵容，无关人员请勿对号入座。</strong> </font></center><p>前文提过我和数科球队“道不同，不相与谋”，<strong>长期以来，我对数科男篮一直谈不上喜欢</strong>——从12级的王晨笛到13级的郭强，再到14级的石睿平，都不是什么我喜欢的人物。<strong>但由于院系原因，加上数科也有一些相熟的同学，所以我对数科男篮这个团队还抱始终有一丝希望。甚至在17明月杯后仍觉得，数科男篮有一部分人是光明正大打球的人。</strong></p><p><strong>然而现实并不如我所想。</strong>这让我不禁想到了前几日数科吉队长对于我“庆幸留在信科男篮”做出的“我们也不是什么人都收”的精彩评论。在我决定是否加入数科球队的时候，好像数科还没你这个人吧<sub>不知道您有什么资格说这句话？这么急着说强调一下“我们”么</sub>惊讶于队长也会说出如此脑残的言论时，我也懒得多辩驳——因为我忽然想到，吉队长就是这么脑残呀：赛前的一节课后，吉队长对我说“你决赛得分你就死”。对没看错，就是死，可我想说，吉队长决赛场上得分死全家呀<sub>哎，结果就是这么巧，吉队长得分了！想到这里我不禁为吉队长大义灭亲的胆识和魄力鼓起了掌。转念一想，吉队长将来可是人民教师呀，我不禁又对祖国未来的教育事业充满了担忧，同时担心亲人的离世给吉队长带来过大的打击</sub>于是我便罢了手，没有与吉队长过多纠缠。</p><p>再联系到17年的比赛，第一场靠改分赢了物理，数科各位的辩驳不可谓不精彩：“我知道你没有证据，改分赢了也是赢了，你来咬我呀~”数科手里有录像，却不拿来自证清白。校会手里有录像，却不拿来还比赛一个公道。更厉害的是，数科男篮更是摆出了一副不要脸的泼皮姿态，石某人也搬出各种人名来颠倒黑白。那时我竟然还相信数科是清白的，错误只在记分员，真是可笑。后来的比赛中，在意识到信科很有可能碰到数科时，石某人急了。为什么急呢？因为怕呀——软蛋总是缺乏正面面对事情的勇气。于是在哲社vs信科以及经管vs信科的赛后，信科经历了所经历过的最恶毒的诅咒——什么“我在场边一遍遍祈祷……”，什么“一人得道鸡犬升天”，什么“对这个结果感到失望”。然而上天并没有听信小人的胡言乱语，信科也顺利进入了决赛，心有不甘的石某人便精心策划了一手阴谋，最终摘得了这个笑话一般的冠军奖杯。赛后石某人竟然还有脸谈情谊：“我们的情谊是不变的”。这嘴脸与吉队长如出一辙，<strong>不愧是两届队长，连脸皮的厚度都如此相似。</strong></p><p>数科球队的各种趣事还有很多，如某自称杜兰特的软蛋赛前赛后挑衅等，此处都不再赘述。这些事情也只是说明，<strong>如今数科男篮整体的作风，不是个别几人能够形成的。在这个团队里，无耻会像病毒一样传播。很庆幸当年没有加入数科男篮</strong>，若没有这件事我恐怕也很难看清这些人的两幅面孔——当面还称兄道弟，转过身就在暗地里处处下绊。这里也不得不佩服吉队长的演技——事出之前还笑脸相迎，甚至求代码求作业，背后毫不犹豫就是一刀。二位队长的脸皮真乃铜墙铁壁，在下佩服~</p><p>最后，用两句话总结一下17的数科男篮，也算是对偶然看到的頔哥观点的回应：</p><ol style="list-style-type: decimal"><li>数科男篮够好么？连缺少主力的信科都不能轻松战胜，<strong>当然不够好，看过决赛就知道他们根本没有实力夺冠</strong>；</li><li><strong>数科男篮有光明正大打球的人吗？抱歉我不觉得</strong>。</li></ol><h2 id="谈信科团学软弱的学生组织">谈信科团学：软弱的学生组织</h2><p>随手列几条，不过多评论信科内部事务，我也不想与信科团学有任何瓜葛。</p><ol style="list-style-type: decimal"><li>体育部部长不强硬，当然这是信科团学的一贯作风；</li><li>粉丝票优先给院会，剩余给球队，一定程度上导致了球队票源短缺；</li><li>老师也并不努力给学生争取权益，尤其是球队一事。</li></ol><h2 id="谈信科男篮不被幸运眷顾的无冕之王">谈信科男篮：不被幸运眷顾的无冕之王</h2><p>14-17四年明月杯，信科男篮四次进入八强，三次进入四强，两次问鼎邱季端。虽然两次都铩羽而归，但其实力不容置疑。两次邱季端，都在赛前生出了不同的变故，于是信科两次邱季端之旅都不是完整阵容。造化弄人，不是么？信科的两次邱季端之旅本身都有实力夺冠，但最后都只能感叹一番时运不济。<strong>也许光明正大打球，在明月杯这赛场上占不到便宜吧[微笑]。</strong>（全文废话完）</p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 运动 </tag>
            
            <tag> 篮球 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2016-2017学年春季学期志愿时长录入</title>
      <link href="/2017/11/17/2016-2017%E5%AD%A6%E5%B9%B4%E6%98%A5%E5%AD%A3%E5%AD%A6%E6%9C%9F%E5%BF%97%E6%84%BF%E6%97%B6%E9%95%BF%E5%BD%95%E5%85%A5/"/>
      <content type="html"><![CDATA[<h2 id="一点简单的说明">一点简单的说明</h2><h3 id="几句废话">几句废话</h3><p>抱歉给大家拖了这么久Orz. 之前也和认证部长沟通过几次, 认证可能确实因为人手不够等问题, 没有及时给各位录入时长.</p><p>认证由于人手不够, 只能给大家提供时长码, 大家自己在志愿北京录入时长码获取时长.</p><h3 id="时长码使用说明">时长码使用说明</h3><ul><li>登录<a href="www.bv2008.cn">志愿北京</a>;</li><li>在志愿北京-我的首页中, 点击自己的服务时间, 进入&quot;我的时长&quot;页面; <img src="http://olgwnj89q.bkt.clouddn.com/%E6%97%B6%E9%95%BF-1.png" alt="志愿北京-我的首页"></li><li>在新页面中点击“录入时长码”, 即可录入时长码. <img src="http://olgwnj89q.bkt.clouddn.com/%E6%97%B6%E9%95%BF-2.png" alt="时长码页面"></li></ul><h2 id="时长码查询">时长码查询</h2><script type="text/javascript">function search(){    var list = new Array("李萍", "谢万明昱", "王石安", "蒋雨含", "王雪琪", "杨东芳", "张巧凌", "陈心如", "冯晓科", "贺苑林", "宋研霏", "朱燕琪", "周敬天", "李奕璇", "边珍", "但晴", "贺巧", "李晓霞", "郑逸敏", "付月", "王子璇", "白月", "段婷波", "高珊", "何可人", "李金铭", "苏宁", "王松正", "文艺", "许琳旋", "周佳茜", "张恺琦", "李军逸", "孙漾", "王蔚桐", "杨航", "余跃", "曹梦宇", "查少琛", "陈林涛", "刘子辰", "马玉阁", "王伟初", "孙荣", "周泓宇")    var time = new Array(48, 48, 44, 42, 42, 42, 42, 32, 32, 42, 36, 36, 36, 34, 30, 30, 30, 30, 30, 30, 26, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 20, 18, 18, 18, 18, 18, 12, 12, 12, 12, 12, 10, 9, 3)    var code = new Array(104198280126, 104197959124, 104198444710, 104191633494, 104193443180, 104199997937, 104196008038, 104190659437, 104192963919, 104196143683, 104193955548, 104191780154, 104191422029, 104199202510, 104194994021, 104193868440, 104198971022, 104197237983, 104194009799, 104197768688, 104191560051, 104193005169, 104197725850, 104191360385, 104193523894, 104198523787, 104198383642, 104198262211, 104199021643, 104191333531, 104199998372, 104197447426, 104194687884, 104199153947, 104190342124, 104195364603, 104195467540, 104195030302, 104196284847, 104194794933, 104194622149, 104198082739, 104195705550, 104191401247, 104195020771)    var name = document.getElementById("input").value    var res = "查无此人！"    var ans = "没有查询到您的时长码QAQ"    for (id in list){        console.log(list[id], name)        if(list[id] == name)        {            res = list[id]+", 您的志愿时长为"+time[id]+"小时, 您的时长码已显示"            ans = code[id]        }    }    document.getElementById("output").value = ans    alert(res)}</script><center>请在输入框中输入您的姓名, 点击“查询”即可.</center><p>姓名: <input type="text" id="input" name="q" placeholder="请在这里输入您的姓名..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false"> <input type="button" value="查询" onclick="search()"> <br></p><p>时长码: <input type="text" id="output" name="q" placeholder="您的时长码会显示在这里..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false"></p>]]></content>
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 白鸽 </tag>
            
            <tag> 志愿 </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>泛函——有界集、完全有界集和紧集</title>
      <link href="/2017/10/25/%E6%B3%9B%E5%87%BD%E2%80%94%E2%80%94%E6%9C%89%E7%95%8C%E9%9B%86%E3%80%81%E5%AE%8C%E5%85%A8%E6%9C%89%E7%95%8C%E9%9B%86%E5%92%8C%E7%B4%A7%E9%9B%86/"/>
      <content type="html"><![CDATA[<h2 id="基础定义">基础定义</h2><p><strong>有界集</strong>: 设 <span class="math inline">\((\mathscr{X},\rho)\)</span> 为度量空间, <span class="math inline">\(A\subset\mathscr{X}\)</span>，如果 <span class="math inline">\(\exists M&lt;\infty\)</span>, s.t. <span class="math inline">\(\forall x,y\in A\)</span>, 总有 <span class="math inline">\(\rho(x,y)\leqslant M\)</span>, 则称 <span class="math inline">\(A\)</span> 为有界集.</p><p><strong>完全有界</strong>: 集合 <span class="math inline">\(M\)</span> 称为完全有界的, 如果 <span class="math inline">\(\forall\epsilon\)</span>, 存在 <span class="math inline">\(M\)</span> 的一个有穷 <span class="math inline">\(\epsilon\)</span> 网.</p><p><strong>紧集</strong>: 在拓扑空间 <span class="math inline">\(\mathscr{X}\)</span> 中, 集合 <span class="math inline">\(M\)</span> 称为紧集, 如果 <span class="math inline">\(\mathscr{X}\)</span> 中每个覆盖 <span class="math inline">\(M\)</span> 的开集族中都有有限个开集覆盖 <span class="math inline">\(M\)</span>.</p><h2 id="有界与完全有界">有界与完全有界</h2><div class="text" style=" text-align:center;"><strong>有界集与完全有界集本质上<font color="red">只差维数</font></strong>.</div><blockquote><p><strong>命题 1</strong> 在度量空间 <span class="math inline">\((\mathscr{X},\rho)\)</span> 中, 完全有界集的子集也是完全有界的.</p></blockquote><p><strong>证明</strong>: 　　设 <span class="math inline">\(M\)</span> 为 <span class="math inline">\(\mathscr{X}\)</span> 中的完全有界集, <span class="math inline">\(S\subset M\)</span>, 下证 <span class="math inline">\(S\)</span> 完全有界: 　　<span class="math inline">\(\forall\epsilon&gt;0\)</span>, 由 <span class="math inline">\(M\)</span> 的完全有界性可知, <span class="math inline">\(\exists N_0\in\mathbb{N}\)</span> 及 <span class="math inline">\(\{x_n\}_{n=1}^{N_0}\subset M\)</span>, s.t. <span class="math inline">\(S\subset M\subset\bigcup\limits_{N=1}^{N_0}B(x_n,\frac{\epsilon}{2})\)</span>. 　　令 <span class="math inline">\(I_s=\{i:B(x_i,\frac{\epsilon}{2})\cap S\neq\varnothing\}\)</span>, 显然 <span class="math inline">\(I_s\)</span> 为有限集. 进一步, 对 <span class="math inline">\(\forall i\in I_s\)</span>, 取 <span class="math inline">\(y_i\in S\cap B(x_i,\frac{\epsilon}{2})\)</span>, 易有 <span class="math inline">\(B(x_i,\frac{\epsilon}{2})\subset B(y_i,\epsilon)\)</span>. 　　由此及 <span class="math inline">\(I_s\)</span> 的定义可知 <span class="math inline">\(S\subset\bigcup\limits_{i\in I_s}B(x_i,\frac{\epsilon}{2})\subset\bigcup\limits_{i\in I_s}B(y_i,\epsilon)\)</span>, 即 <span class="math inline">\(S\)</span> 完全有界.</p><blockquote><p><strong>命题 2</strong> 在有限维 <span class="math inline">\(B^*\)</span> 空间中, 有界集 <span class="math inline">\(\Leftrightarrow\)</span> 完全有界集.</p></blockquote><p><strong>证明</strong>: 　　&quot;<span class="math inline">\(\Leftarrow\)</span>&quot; 是显然的, 以下证明 &quot;<span class="math inline">\(\Rightarrow\)</span>&quot;. 　　由于 <span class="math inline">\(\mathscr{X}\)</span> 为有限维空间, <span class="math inline">\(M\)</span> 有界, 以及<span title="B*空间是有限维的当且仅当其任意有界集列紧."> 课本P37, Col1.4.30 </span>可知 <span class="math inline">\(M\)</span> 列紧. 再由 <span title="Hausdorff: 度量空间中的列紧集一定是完全有界集.">Th1.3.7</span> 知 <span class="math inline">\(M\)</span> 完全有界. 　　综上, 有界 <span class="math inline">\(\Leftrightarrow\)</span> 完全有界.</p><h2 id="紧集与完全有界闭集">紧集与完全有界闭集</h2><div class="text" style=" text-align:center;"><strong>紧集与完全有界闭集<font color="red">只差完备性</font></strong>.</div><blockquote><p><strong>命题 3</strong> 在 <span class="math inline">\(B^*\)</span> 空间中, 紧集一定是完全有界闭集, 反之不一定成立.</p></blockquote><p><strong>证明</strong>: 　　由<span title="度量空间中的紧集等价于自列紧集.">Th1.3.11</span>, 在 <span class="math inline">\(B^*\)</span> 空间中, <span class="math inline">\(A\)</span> 为紧集当且仅当 <span class="math inline">\(A\)</span> 是自列紧集. 从而 <span class="math inline">\(A\)</span> 是闭的, 再由 <span title="Hausdorff: 度量空间中的列紧集一定是完全有界集.">Th1.3.7</span> 知 <span class="math inline">\(A\)</span> 完全有界.</p><p>　　即: 紧 <span class="math inline">\(\Rightarrow\)</span> 完全有界 <span class="math inline">\(+\)</span> 闭 在 <span class="math inline">\(B^*\)</span> 空间中成立.</p><p>　　<strong>但反之不成立, <font color="red">反例</font>如下:</strong> 　　<span class="math display">\[x_n(t)=\begin{cases}　　1, &amp;t\in [a,\frac{a+b}{2}-\frac{1}{n});\\　　n(\frac{a+b}{2}-x), &amp;t\in [\frac{a+b}{2}-\frac{1}{n},\frac{a+b}{2}+\frac{1}{n});\\　　-1, &amp;t\in [\frac{a+b}{2}+\frac{1}{n},b].　　\end{cases}\]</span> 　　<span class="math display">\[x_n(t)=\begin{cases}　　1, &amp;t\in [a,\frac{a+b}{2});\\　　0, &amp;t=\frac{a+b}{2};\\　　-1, &amp;t\in (\frac{a+b}{2},b].　　\end{cases}\]</span> 　　记 <span class="math inline">\(\mathscr{X}=(C[a,b],\Vert\cdot\Vert_{L^1})\)</span>, 并记 <span class="math inline">\(\{x_n\}_{n\in\mathbb{N}}\subset C[a,b]\)</span>, 如下构造: 　　易证 <span class="math inline">\(\{x_n\}_{n\in\mathbb{N}}\)</span> 依 <span class="math inline">\(\Vert\cdot\Vert_{L^1}\)</span> 有极限 <span class="math inline">\(x\)</span>, 且 <span class="math inline">\(x\notin C[a,b]\)</span>. 考虑到 <span class="math inline">\(x\in L^1[a,b]\)</span>, 故 <span class="math inline">\(\{x_n\}_{n\in\mathbb{N}}\)</span> 为 <span class="math inline">\(L^1[a,b]\)</span> 中的列紧集, 从而由 <span title="Hausdorff: 度量空间中的列紧集一定是完全有界集.">Th1.3.7</span>, <span class="math inline">\(\{x_n\}_{n\in\mathbb{N}}\)</span> 为 <span class="math inline">\(L^1[a,b]\)</span> 中的完全有界集. 　　故 <span class="math inline">\(\forall\epsilon&gt;0\)</span>, <span class="math inline">\(\exists N\in\mathbb{N}\)</span> 以及 <span class="math inline">\(\{f_k\}_{k=1}^N\subset L^1[a,b]\)</span>, s.t. <span class="math inline">\(\{x_n\}_{n\in\mathbb{N}}\subset\bigcup\limits_{k=1}^NB(f_k,\frac{\epsilon}{2})\)</span>. 不妨设 <span class="math inline">\(B(f_k,\frac{\epsilon}{2})\cap\{x_n\}_{n\in\mathbb{N}}\neq\varnothing\)</span>(否则去掉 <span class="math inline">\(B(f_k,\frac{\epsilon}{2})\)</span> 即可). 对 <span class="math inline">\(\forall k\in\{1,2,\cdots,N\}\)</span>, 取 <span class="math inline">\(g_k\in\{x_n\}_{n\in\mathbb{N}}\cap B(f_k,\frac{\epsilon}{2})\)</span>, 则 <span class="math inline">\(\{x_n\}_{n\in\mathbb{N}}\subset\bigcup\limits_{k=1}^NB(f_k,\frac{\epsilon}{2})\subset\bigcup\limits_{k=1}^NB(g_k,\epsilon)\)</span>. 从而 <span class="math inline">\(\{g_k\}_{k=1}^N\)</span> 为 <span class="math inline">\(\{x_n\}_{n\in\mathbb{N}}\)</span> 的有穷 <span class="math inline">\(\epsilon\)</span> 网. 故 <span class="math inline">\(\{x_n\}_{n\in\mathbb{N}}\)</span> 为 <span class="math inline">\(\mathscr{X}\)</span> 的完全有界集. 　　又由于 <span class="math inline">\(\{x_n\}_{n\in\mathbb{N}}\)</span> 在 <span class="math inline">\(\mathscr{X}\)</span> 中闭, 故 <span class="math inline">\(\{x_n\}_{n\in\mathbb{N}}\)</span> 为 <span class="math inline">\(\mathscr{X}\)</span> 中的完全有界集, 但不紧.</p><p><strong>但在完备空间: Banach空间中有更强的结论.</strong></p><blockquote><p><strong>命题 3</strong> 在Banach空间中, 紧集 <span class="math inline">\(\Leftrightarrow\)</span> 完全有界集.</p></blockquote><p><strong>证明</strong>: 　　上文中已证紧集 <span class="math inline">\(\Rightarrow\)</span> 完全有界闭集. 又由 <span class="math inline">\(B\)</span> 空间中, 完全有界集必定列紧. 从而完全有界集必定是自列紧的. 从而由 <span title="度量空间中的紧集等价于自列紧集.">Th1.3.11</span> 可知该集合必定是紧集. 综上, Banach空间中的集合是紧集, 当且仅当它是完全有界闭集.</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 泛函分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2017年概率测度小测一题目</title>
      <link href="/2017/10/19/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62017%E5%B9%B4%E6%A6%82%E7%8E%87%E6%B5%8B%E5%BA%A6%E5%B0%8F%E6%B5%8B%E4%B8%80%E9%A2%98%E7%9B%AE/"/>
      <content type="html"><![CDATA[<h2 id="郑重声明">郑重声明</h2><p>完全凭记忆写的=_=有差错不负任何责任...</p><h2 id="题目">题目</h2><h3 id="判断题">判断题</h3><p>正确须证明, 错误须举反例, 没有理由不得分.</p><ol style="list-style-type: decimal"><li><p><span class="math inline">\(f:\Omega\rightarrow E\)</span>, <span class="math inline">\(\forall~B\subset E\)</span>, <span class="math inline">\(f^{-1}(B^c)=(f^{-1}(B))^c\)</span>;</p></li><li><p>设 <span class="math inline">\((\Omega,\mathcal{F},\mu)\)</span> 为测度空间, 取 <span class="math inline">\(\{A_n\}_{n\in\mathbb{N}}\downarrow\subset\mathcal{F}\)</span>. s.t. <span class="math inline">\(A_n\to\varnothing\)</span>, 有 <span class="math inline">\(\lim\limits_{n\to\infty}\mu(A_n)=0\)</span>;</p></li><li><p>设 <span class="math inline">\((\Omega,\mathcal{F},\mu)\)</span> 为测度空间, 取 <span class="math inline">\(A\in\mathcal{F}\)</span>, s.t. <span class="math inline">\(\mu(A)=0\)</span>, 取 <span class="math inline">\(B\subset A\)</span>, 则有 <span class="math inline">\(\mu(B)=0\)</span>;</p></li><li><p>若 <span class="math inline">\(\Omega\)</span> 的子集类 <span class="math inline">\(\mathcal{C}\)</span> 既是 <span class="math inline">\(\lambda\)</span> 系又是 <span class="math inline">\(\pi\)</span> 系, 则 <span class="math inline">\(\mathcal{C}\)</span> 为 <span class="math inline">\(\sigma\)</span> 代数.</p></li></ol><h3 id="证明题">证明题</h3><p>叙述测度扩张定理, 并证明其中的唯一性部分.</p><h2 id="简略解答">简略解答</h2><p>同样...有差错不负任何责任.</p><h3 id="判断题-1">判断题</h3><ol style="list-style-type: decimal"><li>正确. 直接验证即可;</li><li>错误. 取 <span class="math inline">\(\mathbb{R}\)</span> 上的Lebesgue测度, <span class="math inline">\(A_n=(n,+\infty)\)</span>, 即有 <span class="math inline">\(\bigcap\limits_{n=1}^\infty A_n=\varnothing\)</span>, 但 <span class="math inline">\(\mu(A_n)=\infty\)</span>, <span class="math inline">\(\forall n\in\mathbb{N}\)</span>, 矛盾;</li><li>错误. 取 <span class="math inline">\(\Omega=\{0,1,2\}\)</span> 上的 <span class="math inline">\(\sigma\)</span> 代数 <span class="math inline">\(\mathcal{F}=\{\varnothing,\{0,1\},\{2\},\Omega\}\)</span>, 取集函数 <span class="math inline">\(\mu(\{\varnothing\})=\mu(\{0,1\})=0\)</span>, <span class="math inline">\(\mu(\{2\})=\mu(\Omega)=1\)</span>, 容易验证 <span class="math inline">\(\mu\)</span> 是一个测度. 取 <span class="math inline">\(B=\{0\}\subset A=\{0,1\}\)</span>, 则 <span class="math inline">\(B\notin\mathcal{F}\)</span>, 矛盾;</li><li>正确. 直接验证即可(由 <span class="math inline">\(\lambda\)</span> 系可直接得到 <span class="math inline">\(\Omega\)</span> 和余运算封闭, 证明对有限并运算封闭时继续构造部分和即可).</li></ol><h3 id="证明题-1">证明题</h3><p>见课本...</p><h2 id="图片版">图片版</h2><p>发卷子了==其实回忆基本没错.</p><div class="figure"><img src="http://static.zybuluo.com/lzcwr/8mqxcw5s4s1hputqvhko8psy/IMG_20171027_002952.jpg" alt="IMG_20171027_002952.jpg-4482.6kB"><p class="caption">IMG_20171027_002952.jpg-4482.6kB</p></div>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 概率论 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 测度论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>次序统计量的联合分布</title>
      <link href="/2017/10/09/%E6%AC%A1%E5%BA%8F%E7%BB%9F%E8%AE%A1%E9%87%8F%E7%9A%84%E8%81%94%E5%90%88%E5%88%86%E5%B8%83/"/>
      <content type="html"><![CDATA[<blockquote><p>设 <span class="math inline">\(X_1,\cdots,X_n\)</span> 为来自总体 <span class="math inline">\(X\sim F\)</span> 的iid样本, 总体概率密度函数为 <span class="math inline">\(f(x)\)</span>, 则对于给定的 <span class="math inline">\(1\leqslant i\leqslant j\leqslant n\)</span>, 求统计量 <span class="math inline">\(X_{(i)}\)</span> 与 <span class="math inline">\(X_{(j)}\)</span> 的联合密度.</p></blockquote><p>首先注意到, <span class="math inline">\(X_{(1)},\cdots,X_{(n)}\)</span> 的联合密度为 <span class="math display">\[f_{(X_{(1)},\cdots,X_{(n)})}(x_1,\cdots,x_n)=n!\cdot f(x_1)\cdots f(x_n).\]</span></p><p>于是只需要求 <span class="math inline">\((X_{(i)}, X_{(j)})\)</span> 的边缘密度.</p><p>利用结果 <span class="math display">\[\idotsint\limits_{a&lt;x_1&lt;\cdots&lt;x_k&lt;b}f(x_1)\cdots f(x_k){\rm d}x_1\cdots {\rm d}x_k=\frac{1}{k!}(F(b)-F(a))^k\]</span></p><p>可得 <span class="math display">\[\begin{align}f_{(X_{(i)}, X_{(j)})}(x,y) &amp;= \idotsint\limits_{x_k\in\mathbb{R},k\neq i,j}n!\cdot f(x_1)\cdots f(x_n){\rm d}x_1\cdots{\rm d}x_{i-1}{\rm d}x_{i+1}\cdots{\rm d}x_{j-1}{\rm d}x_{j+1}{\rm d}x_n \\&amp;= n!\times\idotsint\limits_{0&lt;x_1\cdots&lt;x_{i-1}&lt;x}f(x_1)\cdots f(x_{i-1}){\rm d}x_1\cdots{\rm d}x_{i-1}\times \idotsint\limits_{x&lt;x_{i+1}&lt;\cdots&lt;x_{j-1}&lt;y}f(x_{i+1})\cdots f(x_{j-1}){\rm d}x_{i+1}\cdots{\rm d}x_{j-1}\times \idotsint\limits_{y&lt;x_{j+1}&lt;\cdots&lt;x_n&lt;+\infty}f(x_{j+1})\cdots f(x_n){\rm d}x_{j+1}{\rm d}x_n\times f(x)f(y) \\&amp;= n!\times \frac{F^{j-1}(x)}{(j-1)!}\times\frac{[F(y)-F(x)]^{k-j-1}}{(k-j-1)!}\times\frac{[1-F(y)]^{n-k}}{(n-k)!}\times f(x)f(y) \\&amp;= \frac{n!}{(j-1)!(k-j-1)!(n-k)!}F^{j-1}(x)[F(y)-F(x)]^{k-j-1}[1-F(y)]^{n-k}f(x)f(y)\end{align}\]</span></p><p>同样可以求出任意多个次序统计量的联合密度.</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 概率论 </tag>
            
            <tag> 统计学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>泛函——自然数集上的Lp范数</title>
      <link href="/2017/10/08/%E6%B3%9B%E5%87%BD%E2%80%94%E2%80%94%E8%87%AA%E7%84%B6%E6%95%B0%E9%9B%86%E4%B8%8A%E7%9A%84Lp%E8%8C%83%E6%95%B0/"/>
      <content type="html"><![CDATA[<h2 id="lpomegamu-空间"><span class="math inline">\(L^p(\Omega,\mu)\)</span> 空间</h2><p><span class="math inline">\(1\leqslant p&lt;\infty\)</span>, 设 <span class="math inline">\((\Omega,\mathscr{B},\mu)\)</span> 是一个测度空间, <span class="math inline">\(u\)</span> 是 <span class="math inline">\(\Omega\)</span> 上的可测函数且 <span class="math inline">\(|u(x)^p|\)</span> 在 <span class="math inline">\(\Omega\)</span> 可积. 则记这样 <span class="math inline">\(u\)</span> 的全体为 <span class="math inline">\(L^p(\Omega,\mu)\)</span>.</p><p>在 <span class="math inline">\(L^p(\Omega,\mu)\)</span> 中几乎处处相等的函数视为同一个函数后, <span class="math inline">\(L^p(\Omega,\mu)\)</span> 仍为线性空间. 定义 <span class="math display">\[\Vert u\Vert=\left(\int\nolimits_\Omega \vert u(x)^p\vert {\rm d}\mu\right)^\frac{1}{p}\]</span> 则 <span class="math inline">\(\Vert\cdot\Vert\)</span> 为一个范数. 事实上 <span class="math inline">\(L^p(\Omega,\mu)\)</span> 还是一个Banach空间.</p><h2 id="mathbbn-上的-lp-范数"><span class="math inline">\(\mathbb{N}\)</span> 上的 <span class="math inline">\(L^p\)</span> 范数</h2><p>以上的空间在 <span class="math inline">\(\mathbb{N}\)</span> 上的特殊情形如下:</p><p><span class="math inline">\(\Omega=\mathbb{N}, \mu(\{n\})=1~(\forall n\in\mathbb{N})\)</span>, 此时 <span class="math inline">\(L^p(\Omega,\mu)\)</span> 由满足 <span class="math inline">\(\sum\limits_{n=1}^\infty\vert u_n\vert^p&lt;\infty\)</span> 的所有序列组成, 记为 <span class="math inline">\(l^p\)</span>.</p><p>此时其范数为 <span class="math display">\[\Vert u\Vert=\left(\sum\limits_{n=1}^\infty \vert u_n\vert^p\right)^\frac{1}{p}.\]</span></p><p>对于 <span class="math inline">\(\forall N\in\mathbb{N}\)</span>, 记 <span class="math inline">\(f_N(x)=\sum\limits_{n=1}^Nu_n\chi_{\{n\}}\)</span>, 令 <span class="math inline">\(f(x)=\sum\limits_{n=1}^\infty u_n\chi_{\{n\}}\)</span>, <span class="math inline">\(x\in\mathbb{N}\)</span>.</p><p>则有 <span class="math display">\[\begin{align}\int\nolimits_\mathbb{N}\vert f_N(x)\vert^p{\rm d}\mu(x) &amp;= \int\nolimits_\mathbb{N}\sum\limits_{n=1}^Nu_n\chi_{\{n\}}{\rm d}\mu(x) \\&amp;= \sum\limits_{n=1}^N \vert u_n\vert^p\cdot\int\nolimits_\mathbb{N}\chi_{\{n\}}{\rm d}\mu(x) \\&amp;= \sum\limits_{n=1}^N \vert u_n\vert^p\end{align}\]</span></p><p>又显然, <span class="math inline">\(0\leqslant\vert f_N(x)\vert^p\leqslant \vert f_{N+1}(x)\vert^p\)</span>, 且 <span class="math inline">\(\vert f(x)\vert^p=\lim\limits_{N\to\infty}\vert f_N(x)\vert^p\)</span>. 故由非负可测函数的Levi定理有 <span class="math display">\[\begin{align}\int\nolimits_\mathbb{N}\vert f(x)\vert^p{\rm d}\mu(x) &amp;= \int\nolimits_\mathbb{N}\lim\limits_{N\to\infty}\vert f_N(x)\vert^p{\rm d}\mu(x) \\&amp;= \lim\limits_{N\to\infty}\int\nolimits_\mathbb{N}\vert f_N(x)\vert^p{\rm d}\mu(x) \\&amp;= \sum\limits_{n=1}^\infty \vert u_n\vert^p\end{align}\]</span></p><p>即有 <span class="math display">\[ \left(\sum\limits_{N=1}^\infty\vert u_n\vert^p\right)^\frac{1}{p}=\left(\int\nolimits_\mathbb{N}\vert f(x)\vert^p{\rm d}\mu(x)\right)^\frac{1}{p}. \]</span></p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 泛函分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>拓扑学题目</title>
      <link href="/2017/10/08/%E6%8B%93%E6%89%91%E5%AD%A6%E9%A2%98%E7%9B%AE/"/>
      <content type="html"><![CDATA[<h2 id="乘积空间">乘积空间</h2><h3 id="hausdorff空间与对角映射">Hausdorff空间与对角映射</h3><blockquote><p>映射 <span class="math display">\[\Delta: X\rightarrow X\times X,~\Delta(x)=(x,x)\]</span> 称为<strong>对角映射</strong>. 证明: <span class="math inline">\(X\)</span> 是Hausdorff空间当且仅当 <span class="math inline">\(\Delta(X)\)</span> 是 <span class="math inline">\(X\times X\)</span> 的闭集.</p></blockquote><p><strong>证明</strong>:</p><p><strong>充分性</strong>: <span class="math inline">\(\forall x\neq y\in X\)</span>, 有 <span class="math inline">\((x,y)\in \Delta^c\)</span>. 由 <span class="math inline">\(\Delta\)</span> 为闭集有 <span class="math inline">\(\Delta^c\)</span> 为开集. 故由乘积拓扑的定义, 存在 <span class="math inline">\(X\)</span> 的开子集 <span class="math inline">\(U,V\)</span>, s.t. <span class="math inline">\((x,y)\in U\times V\subset\Delta^c\)</span>. (<span class="math inline">\(X\)</span> 上的开集<span class="math inline">\(\times\)</span><span class="math inline">\(X\)</span>上的开集为 <span class="math inline">\(X\times X\)</span> 乘积拓扑的一组拓扑基). 于是此时, <span class="math inline">\(U,V\)</span> 是 <span class="math inline">\(x,y\)</span> 的开邻域并且易得 <span class="math inline">\(U\cap V=\varnothing\)</span>.</p><p><strong>必要性</strong>: 由于 <span class="math inline">\(X\)</span> 是Hausdorff空间, 故 <span class="math inline">\(\forall x\neq y\in X\)</span>, 存在 <span class="math inline">\(X\)</span> 的开子集 <span class="math inline">\(U,V\)</span>, s.t. <span class="math inline">\(x\in U\)</span>, <span class="math inline">\(y\in V\)</span>, 且 <span class="math inline">\(U\cap V=\varnothing\)</span>. 故 <span class="math inline">\((x,y)\in U\times V\)</span>, 又由 <span class="math inline">\(U\cap V=\varnothing\)</span>, 知 <span class="math inline">\((U\times V)\cap\Delta=\varnothing\)</span>, 即 <span class="math inline">\(U\times V\subset\Delta^c\)</span>, 故 <span class="math inline">\(U\times V\)</span> 为 <span class="math inline">\((x,y)\)</span> 在 <span class="math inline">\(\Delta^c\)</span> 中的开邻域. 故 <span class="math inline">\(\Delta^c\)</span> 为开集, 即 <span class="math inline">\(\Delta\)</span> 为闭集.</p><p><strong>综上所述</strong>, <span class="math inline">\(X\)</span> 是Hausdorff空间 <span class="math inline">\(\Longleftrightarrow\)</span> <span class="math inline">\(\Delta(X)\)</span> 是 <span class="math inline">\(X\times X\)</span> 的闭集.</p><h3 id="自然投影不一定是闭映射">自然投影不一定是闭映射</h3><blockquote><p>举例说明 <span class="math inline">\(p_1:X\times Y\to Y\)</span> 不一定是闭映射.</p></blockquote><p><strong>证明</strong>: 取 <span class="math inline">\(\mathbb{E}^2\)</span> 中的闭集 <span class="math inline">\(F=\{(x,\frac{1}{x}):x&gt;0\in\mathbb{R}\}\)</span>, 则 <span class="math inline">\(p_1(F)=\mathbb{R}^+\)</span> 为开集.</p><h2 id="连通性">连通性</h2><h3 id="mathbbe2-上的非无理点集连通"><span class="math inline">\(\mathbb{E}^2\)</span> 上的非无理点集连通</h3><blockquote><p>设 <span class="math inline">\(X=\{(r,s)\in\mathbb{E}^2\vert r\in\mathbb{Q}~或~s\in\mathbb{Q}\}\)</span>, 证明 <span class="math inline">\(X\)</span> 连通.</p></blockquote><p>有各种神奇的想法.</p><p><strong>证明1</strong>: <strong>通过道路连通性考虑</strong>. 取 <span class="math inline">\(x_1=(r_1,s_1),x_2=(r_2,s_2)\in X\)</span>, 有以下两种情况.</p><ol style="list-style-type: decimal"><li>若 <span class="math inline">\(r_1,r_2\in\mathbb{Q}\)</span>, 则存在 <span class="math inline">\(x_1\to x_2\)</span> 的道路 <span class="math inline">\((r_1,s_1)\to(r_1,r_2)\to(r_2,r_2)\to(r_2,s_2)\)</span>;</li><li>若 <span class="math inline">\(r_1,s_2\in\mathbb{Q}\)</span>, 则存在 <span class="math inline">\(x_1\to x_2\)</span> 的道路 <span class="math inline">\((r_1,s_1)\to(r_1,s_2)\to(r_2,s_2)\)</span>.</li></ol><p><strong>综上所述</strong>, <span class="math inline">\(X\)</span> 是道路连通的, 因此 <span class="math inline">\(X\)</span> 连通.</p><p><strong>证明2</strong>: <strong>反证法</strong>. 假设 <span class="math inline">\(X\)</span> 可以写成两个不相交非空开集 <span class="math inline">\(A,B\)</span> 的并. 取 <span class="math inline">\(q\in\mathbb{Q}\)</span>, 则 <span class="math inline">\(X_q=\{(x,q),(q,x)\vert x\in\mathbb{R}\}\)</span> 构成 <span class="math inline">\(X\)</span> 的连通子集. 显然有 <span class="math inline">\(X_q\subset A\)</span> 或者 <span class="math inline">\(X_q\subset B\)</span>, 否则 <span class="math inline">\(X_q\)</span> 可分成不相交的两部分 <span class="math inline">\(X_{q_A}\)</span> 和 <span class="math inline">\(X_{q_B}\)</span>, s.t. <span class="math inline">\(\overline{X_{q_A}}\cap X_{q_B}=\overline{X_{q_B}}\cap X_{q_A}=\varnothing\)</span>, 这与 <span class="math inline">\(X\)</span> 的连通性矛盾. 于是 <span class="math inline">\(\exists q_1,q_2\in\mathbb{Q}\)</span>, s.t. <span class="math inline">\(X_{q_1}\subset A\)</span>, <span class="math inline">\(X_{q_2}\subset B\)</span>. 但 <span class="math inline">\((q_1,q_2)\in X_{q_1}\cap X_{q_2}\)</span>, 与 <span class="math inline">\(A\cap B=\varnothing\)</span> 矛盾. 故 <span class="math inline">\(X\)</span> 连通.</p><p>考虑一个引理:</p><blockquote><p><strong>引理</strong> 若 <span class="math inline">\(X_0\)</span> 是 <span class="math inline">\(X\)</span> 的既开又闭子集, <span class="math inline">\(A\)</span> 是 <span class="math inline">\(X\)</span> 的连通子集, 则 <span class="math inline">\(A\cap X_0=\varnothing\)</span> 或 <span class="math inline">\(A\subset X_0\)</span>.</p></blockquote><p><strong>引理的证明</strong>: <span class="math inline">\(A\cap X_0\)</span> 是 <span class="math inline">\(A\)</span> 的既开又闭子集. 由于 <span class="math inline">\(A\)</span> 连通, 故 <span class="math inline">\(A\cap X_0=\varnothing\)</span> 或 <span class="math inline">\(A\cap X_0=A\)</span>, 即 <span class="math inline">\(A\subset X_0\)</span>.</p><p>由引理可得出以下命题（北大拓扑学讲义P63 Prop 2.23）进而可证原命题.</p><blockquote><p><strong>命题 2.23</strong> 如果 <span class="math inline">\(X\)</span> 有一个连通覆盖 <span class="math inline">\(\mathscr{U}\)</span>, 并且 <span class="math inline">\(X\)</span> 有一连通子集 <span class="math inline">\(A\)</span>, 它与 <span class="math inline">\(\mathscr{U}\)</span> 中每个成员都相交, 则 <span class="math inline">\(X\)</span> 连通.</p></blockquote><p><strong>命题的证明</strong>: 设 <span class="math inline">\(X_0\)</span> 是 <span class="math inline">\(X\)</span> 的既开又闭子集, 只需证明 <span class="math inline">\(X_0=\varnothing\)</span> 或 <span class="math inline">\(X_0=X\)</span>. 由引理, <span class="math inline">\(A\cap X_0=\varnothing\)</span> 或 <span class="math inline">\(A\subset X_0\)</span>.</p><ol style="list-style-type: decimal"><li>若 <span class="math inline">\(A\cap X_0=\varnothing\)</span>, 则 <span class="math inline">\(\forall U\in\mathscr{U}\)</span>, 由于 <span class="math inline">\(U\cap A\neq\varnothing\)</span>, 故 <span class="math inline">\(U\nsubseteq X_0\)</span>. 由引理, <span class="math inline">\(U\cap X_0=\varnothing\)</span>, 则 <span class="math inline">\(X_0=(\bigcup\limits_{U\in\mathscr{U}}U)\cap X_0=\bigcup\limits_{U\in\mathscr{U}}(U\cap X_0)=\varnothing\)</span>.</li><li>若 <span class="math inline">\(A\subset X_0\)</span>, 则 <span class="math inline">\(\forall U\in\mathscr{U}\)</span>, <span class="math inline">\(U\cap X_0\supset U\cap A\neq\varnothing\)</span>. 由引理, <span class="math inline">\(U\subset X_0\)</span>, 则 <span class="math inline">\(X=\bigcup\limits_{U\in\mathscr{U}}U\subset X_0\)</span>, 即有 <span class="math inline">\(X_0=X\)</span>.</li></ol><p><strong>综上所述</strong>, <span class="math inline">\(X\)</span> 连通.</p><p><strong>证明3</strong>: 仍然考虑 <span class="math inline">\(A_q=\{(x,y)\vert x=q~或~y=q\}\)</span>, 则 <span class="math inline">\(A_q\)</span> 连通且 <span class="math inline">\(X=\bigcup\limits_{q\in\mathbb{Q}}A_q\)</span>, 即 <span class="math inline">\(\{A_q\}_{q\in\mathbb{Q}}\)</span> 构成 <span class="math inline">\(X\)</span> 的连通覆盖, 而 <span class="math inline">\(A_q\cap A_0\neq\varnothing, \forall q\in\mathbb{Q}\)</span>, 故由命题2.23, <span class="math inline">\(X\)</span> 连通.</p><p>结合引理, 证法2也会有不同的写法, 不再赘述.</p><h3 id="mathbbr1-上左开右闭区间生成的拓扑不是-c_2-空间"><span class="math inline">\(\mathbb{R}^1\)</span> 上左开右闭区间生成的拓扑不是 <span class="math inline">\(C_2\)</span> 空间</h3><blockquote><p>设 <span class="math inline">\(\mathbb{R}^1\)</span> 的子集族 <span class="math inline">\(\mathcal{B}=\{(a,b]:a,b\in\mathbb{R}^1,a&lt;b\}\)</span>, 则 <span class="math inline">\(\mathcal{B}\)</span> 构成 <span class="math inline">\(\mathbb{R}^1\)</span> 上的一个拓扑基且该拓扑不是第二可数空间.</p></blockquote><p><strong>证明</strong>: <span class="math inline">\(\mathcal{B}\)</span> 构成拓扑基的证明是平凡的, 不再赘述. 以下证明该空间不是第二可数的. <strong>反证法.</strong> 设有可数拓扑基 <span class="math inline">\(\{\alpha_i\}\)</span>, 设 <span class="math inline">\(a_i=\sup\limits_{x\in\alpha_i}x\)</span> (<span class="math inline">\(a_i\)</span> 可取 <span class="math inline">\(\infty\)</span>), 则 <span class="math inline">\(a_i\)</span> 只有可数个, 于是 <span class="math inline">\(\exists\)</span> 无理数 <span class="math inline">\(\beta\notin\{a_i\}_{i\in\mathbb{N}}\)</span>. 由条件, 可设 <span class="math inline">\((\beta^{-1},\beta]=\bigcup\limits_{j} \alpha_j\)</span>. 于是 <span class="math inline">\(\beta=\sup\limits_{x\in\bigcup_j\alpha_j}x=\max\limits_j a_j\)</span>, 与 <span class="math inline">\(\beta\notin\{a_i\}_{i\in\mathbb{N}}\)</span> 矛盾. 于是不存在可数拓扑基, 因而不是 <span class="math inline">\(C_2\)</span> 空间.</p><h3 id="mathbbq-作为-mathbbe1-的子空间不是局部紧的"><span class="math inline">\(\mathbb{Q}\)</span> 作为 <span class="math inline">\(\mathbb{E}^1\)</span> 的子空间不是局部紧的</h3><blockquote><p>证明有理数作为 <span class="math inline">\(\mathbb{E}^1\)</span> 不是局部紧致的.</p></blockquote><p><strong>证明</strong>: 取 <span class="math inline">\(q\in \mathbb{Q}\)</span>, 只需要证明 <span class="math inline">\(q\)</span> 的任意邻域都不紧即可. 任取 <span class="math inline">\(\mathbb{Q}\)</span> 中包含 <span class="math inline">\(q\)</span> 的一个邻域, 则该邻域具有 <span class="math inline">\(U_q\cap\mathbb{Q}\)</span> 的形式, 其中 <span class="math inline">\(U_q\)</span> 是 <span class="math inline">\(q\)</span> 在 <span class="math inline">\(\mathbb{R}\)</span> 中的邻域. 故 <span class="math inline">\(U_q\)</span> 包含 <span class="math inline">\(q\)</span> 的连通分支必定具有区间 <span class="math inline">\(|a,b|\)</span> 的形式（开区间或闭区间）. 取无理数 <span class="math inline">\(\xi\in|a,b|\)</span>, 记 <span class="math inline">\(|a,b|\)</span> 中比 <span class="math inline">\(\xi\)</span> 小的有理数为 <span class="math inline">\(\{a_1,a_2\cdots\}\)</span>, 比 <span class="math inline">\(\xi\)</span> 大的有理数为 <span class="math inline">\(\{b_1,b_2,\cdots\}\)</span>, 则 <span class="math inline">\(\{\mathbb{Q}\cap|a,a_i)\}_{i\in\mathbb{N}}\cup\{\mathbb{Q}\cap(b_j,b|\}_{j\in\mathbb{N}}\)</span> 构成 <span class="math inline">\(|a,b|\)</span> 的一个开覆盖, 且没有有限子覆盖. 于是 <span class="math inline">\(|a,b|\)</span> 不紧. 命题得证.</p><h3 id="师大拓扑学p47-8.">师大《拓扑学》P47 8.</h3><blockquote><p>设拓扑空间 <span class="math inline">\(X\)</span> 可以写成两个开集 <span class="math inline">\(X_1\)</span>, <span class="math inline">\(X_2\)</span> 的并, 并且 <span class="math inline">\(X_0=X_1\cap X_2\neq\varnothing\)</span> 道路连通, 证明 <span class="math inline">\(X\)</span> 道路连通当且仅当 <span class="math inline">\(X_1\)</span> 和 <span class="math inline">\(X_2\)</span> 都道路连通.</p></blockquote><p><strong>证明</strong>: 只需要证明 <span class="math inline">\(X_1\)</span> 道路连通. 由于 <span class="math inline">\(X_1\cap X_2\)</span> 道路连通, 以下只需证明 <span class="math inline">\(\forall p\in X_1\backslash X_2\)</span>, 存在 <span class="math inline">\(p\)</span> 到 <span class="math inline">\(X_1\cap X_2\)</span> 中某点的道路. 取 <span class="math inline">\(q\in X_2\)</span>, 则由 <span class="math inline">\(X\)</span> 道路连通, 任取 <span class="math inline">\(q\in X_2\)</span>, <span class="math inline">\(X\)</span> 中存在 <span class="math inline">\(p\to q\)</span> 的一条道路 <span class="math inline">\(a\)</span>, 即 <span class="math inline">\(a:X\to I\)</span>, s.t. <span class="math inline">\(a(0)=p\)</span>, <span class="math inline">\(a(1)=q\)</span>. 则 <span class="math inline">\(a^{-1}(X_1\cap X_2)\neq\varnothing\)</span>, 否则由 <span class="math inline">\(a\)</span> 的连续性, <span class="math inline">\(a^{-1}(X_1)\)</span> 和 <span class="math inline">\(a^{-1}(X_2)\)</span> 为 <span class="math inline">\(I\)</span> 的两个非空开集且 <span class="math inline">\(a^{-1}(X_1)\cup a^{-1}(X_2)=I\)</span>, 从而与 <span class="math inline">\(I\)</span> 的连通性矛盾. 取 <span class="math inline">\(t=\inf a^{-1}(X_1)\cap a^{-1}(X_2)\)</span>, 则 <span class="math inline">\([0,t]\subset a^{-1}(X_1)\)</span>. 由 <span class="math inline">\(a^{-1}(X_1)\)</span> 是开集知 <span class="math inline">\(\exists\epsilon&gt;0\)</span>, s.t. <span class="math inline">\([t,t+\epsilon)\subset a^{-1}(X_1)\)</span>. 于是 <span class="math inline">\(\exists t_1\in[t,t+\epsilon)\)</span>, s.t. <span class="math inline">\(a(t_1)\in X_1\cap X_2\)</span>. 即存在 <span class="math inline">\(p\to t_1\)</span> 的道路, 因而 <span class="math inline">\(X_1\)</span> 道路连通.</p><h3 id="粘合拓扑与并集的子空间拓扑">粘合拓扑与并集的子空间拓扑</h3><blockquote><p>若 <span class="math inline">\(X_\alpha\)</span> 是 <span class="math inline">\(Z\)</span> 的子空间, 给 <span class="math inline">\(\bigcup\limits_\alpha X_\alpha\)</span> 以 <span class="math inline">\(Z\)</span> 的子空间拓扑. 若 <span class="math inline">\(\alpha\)</span> 个数有限, 并且每个 <span class="math inline">\(X_\alpha\)</span> 在 <span class="math inline">\(\bigcup\limits_\alpha X_\alpha\)</span> 中闭, 则 <span class="math inline">\(\bigcup\limits_\alpha X_\alpha\)</span> 的子空间拓扑与粘合拓扑一致. 若 <span class="math inline">\(\alpha\)</span> 个数无限, 则结论不一定成立.</p></blockquote><p><strong>证明1</strong>: 平凡的构造是很容易的: 考虑 <span class="math inline">\(Z=\mathbb{E}^1\)</span>, <span class="math inline">\(X_\alpha=\{\alpha\}\)</span>, <span class="math inline">\(\forall\alpha\in\mathbb{R}\)</span>, 则 <span class="math inline">\(Z=\bigcup\limits_\alpha X_\alpha\)</span>. 并集的子空间拓扑显然就是欧氏拓扑, 但粘合拓扑为 <span class="math inline">\(\mathbb{R}\)</span> 上的离散拓扑, 因而不相同.</p><p><strong>证明2</strong>: 非平凡的例子: 待补.</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 拓扑学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>单调类定理</title>
      <link href="/2017/09/21/%E5%8D%95%E8%B0%83%E7%B1%BB%E5%AE%9A%E7%90%86/"/>
      <content type="html"><![CDATA[<h2 id="基础定义">基础定义</h2><h3 id="sigma-代数"><span class="math inline">\(\sigma\)</span> 代数</h3><p>称 <span class="math inline">\(\Omega\)</span> 的子集类 <span class="math inline">\(\mathscr{F}\)</span> 为 <span class="math inline">\(\Omega\)</span> 的 <span class="math inline">\(\sigma\)</span> 代数, 如果它满足:</p><ol style="list-style-type: decimal"><li><span class="math inline">\(\Omega\in\mathcal{F}\)</span>;</li><li>若 <span class="math inline">\(A\in\mathcal{F}\)</span>, 则 <span class="math inline">\(A^c\in\mathcal{F}\)</span>;</li><li>若 <span class="math inline">\(A_n\in\mathcal{F}\)</span>, <span class="math inline">\(n\in\mathbf{N}\)</span>, 则 <span class="math inline">\(\bigcup\limits_{n=1}^\infty A_n\in\mathcal{F}\)</span>.</li></ol><h3 id="lambda-pi-系"><span class="math inline">\(\lambda-\pi\)</span> 系</h3><h4 id="pi-系"><span class="math inline">\(\pi\)</span> 系</h4><p>称 <span class="math inline">\(\Omega\)</span> 的子集类 <span class="math inline">\(\Pi\)</span> 称为 <span class="math inline">\(\pi\)</span> 系, 如果它对交运算封闭.</p><h4 id="lambda-系"><span class="math inline">\(\lambda\)</span> 系</h4><p>称 <span class="math inline">\(\Omega\)</span> 的子集类 <span class="math inline">\(\Lambda\)</span> 称为 <span class="math inline">\(\lambda\)</span> 系, 如果:</p><ol style="list-style-type: decimal"><li><span class="math inline">\(\Omega\in\Lambda\)</span>;</li><li>对真差封闭: 即 <span class="math inline">\(\forall~A,B\in\Lambda\)</span>, s.t. <span class="math inline">\(A\subset B\)</span>, 总有 <span class="math inline">\(B\backslash A\in\Lambda\)</span>;</li><li>对不降序列的并封闭: 即 <span class="math inline">\(\{A_n:n\in\mathbf{N}\}\)</span>, <span class="math inline">\(A_n\uparrow\)</span>, 则 <span class="math inline">\(\bigcup\limits_{n=1}^\infty A_n\in\Lambda\)</span>.</li></ol><h2 id="集合形式的单调类定理">集合形式的单调类定理</h2><h3 id="引理-lambdapisigma">引理: <span class="math inline">\(\lambda+\pi=\sigma\)</span></h3><blockquote><p>若 <span class="math inline">\(\Omega\)</span> 子集类 <span class="math inline">\(\mathcal{C}\)</span> 同时为 <span class="math inline">\(\lambda\)</span> 系和 <span class="math inline">\(\pi\)</span> 系, 则 <span class="math inline">\(\mathcal{C}\)</span> 为 <span class="math inline">\(\sigma\)</span> 代数.</p></blockquote><p><strong>证明</strong>: 首先, 由 <span class="math inline">\(\mathcal{C}\)</span> 为 <span class="math inline">\(\lambda\)</span> 系可知 <span class="math inline">\(\Omega\in\mathcal{C}\)</span>, 且 <span class="math inline">\(\forall~A\in\mathcal{C}\)</span>, 均有 <span class="math inline">\(A\subset\Omega\)</span>, 于是 <span class="math inline">\(A^c=\Omega\backslash A\in\mathcal{C}\)</span>. 另一方面, 取 <span class="math inline">\(A_n\in\mathcal{C}\)</span>, <span class="math inline">\(n\in\mathbf{N}\)</span> 则 <span class="math inline">\(B_n=\bigcup\limits_{n=1}^\infty A_k\)</span>, <span class="math inline">\(n\in\mathbf{N}\)</span> 是不降集列, 于是由 <span class="math inline">\(A_k^c\in\mathcal{C}\)</span> 以及 <span class="math inline">\(\mathcal{C}\)</span> 是 <span class="math inline">\(\pi\)</span> 系, 可知 <span class="math inline">\(B_n^c=\bigcap\limits_{n=1}^\infty A_k^c\in\mathcal{C}\)</span>.</p><p>于是 <span class="math inline">\(B_n\in\mathcal{C}\)</span>, 由定义知, <span class="math inline">\(\bigcup\limits_{n=1}^\infty A_n=\bigcup\limits_{n=1}^\infty B_n\in\mathcal{C}\)</span>, 于是 <span class="math inline">\(\mathcal{C}\)</span> 为 <span class="math inline">\(\sigma\)</span> 代数.</p><h3 id="单调类定理">单调类定理</h3><blockquote><p>设 <span class="math inline">\(\Omega\)</span> 的子集类 <span class="math inline">\(\mathcal{C}\)</span> 是 <span class="math inline">\(\pi\)</span> 系, <span class="math inline">\(\Lambda(\mathcal{C})\)</span> 是包含 <span class="math inline">\(\mathcal{C}\)</span> 的最小 <span class="math inline">\(\lambda\)</span> 系, 则 <span class="math inline">\(\Lambda(\mathcal{C})=\sigma(\mathcal{C})\)</span>.</p></blockquote><p><strong>证明</strong>: 由于 <span class="math inline">\(\sigma\)</span> 代数一定是 <span class="math inline">\(\lambda\)</span> 系, 故 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 为 <span class="math inline">\(\lambda\)</span> 系, 由 <span class="math inline">\(\Lambda(\mathcal{C})\)</span> 的最小性, 有 <span class="math inline">\(\sigma(\mathcal{C})\supset\Lambda(\mathcal{C})\)</span>.</p><p>于是只需要证明 <span class="math inline">\(\sigma(\mathcal{C})\subset\Lambda(\mathcal{C})\)</span>, 由 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 的最小性, 只需要证明 <span class="math inline">\(\Lambda(\mathcal{C})\)</span> 为 <span class="math inline">\(\sigma\)</span> 代数. 又由于 <span class="math inline">\(\Lambda(\mathcal{C})\)</span> 为 <span class="math inline">\(\lambda\)</span> 系, 故只需要证明 <span class="math inline">\(\Lambda(\mathcal{C})\)</span> 为一个 <span class="math inline">\(\pi\)</span> 系.</p><p>即只需证明 <span class="math inline">\(\forall~A, B\in\Lambda(\mathcal{C})\)</span>, <span class="math inline">\(A\cap B\in\Lambda(\mathcal{C})\)</span>.</p><p><strong>令 <span class="math inline">\(\Lambda_A=\{B\in\Lambda(\mathcal{C}): A\cap B\in\Lambda(\mathcal{C})\}\)</span>, 则只需证明 <span class="math inline">\(\forall~A\in\Lambda(\mathcal{C})\)</span>, 有 <span class="math inline">\(\Lambda_A=\Lambda(\mathcal{C})\)</span> 即可.</strong> 由于显然有 <span class="math inline">\(\Lambda_A\subset\Lambda(\mathcal{C})\)</span>, 故只需要证明 <span class="math inline">\(\Lambda_A\supset\Lambda(\mathcal{C})\)</span>.</p><p>考虑到 <span class="math inline">\(\Lambda(\mathcal{C})\)</span> 的最小性, 可按照如下三步证明:</p><ol style="list-style-type: decimal"><li><span class="math inline">\(\forall~A\in\Lambda(\mathcal{C})\)</span>, <span class="math inline">\(\Lambda_A\)</span> 是 <span class="math inline">\(\lambda\)</span> 系;</li><li><span class="math inline">\(\forall~A\in\mathcal{C}\)</span>, <span class="math inline">\(\Lambda_A=\Lambda(\mathcal{C})\)</span>;</li><li><span class="math inline">\(\forall~A\in\Lambda(\mathcal{C})\)</span>, <span class="math inline">\(\Lambda_A=\Lambda(\mathcal{C})\)</span>.</li></ol><p>证明第一条:</p><ol style="list-style-type: decimal"><li>由 <span class="math inline">\(\Lambda_A\)</span> 的定义, <span class="math inline">\(\Omega\in\Lambda_A\)</span>;</li><li><span class="math inline">\(\forall~B, C\in\Lambda_A\)</span>, s.t. <span class="math inline">\(B\subset C\)</span>, 则由 <span class="math inline">\(\Lambda_A\)</span> 的定义有 <span class="math inline">\(A\cap C,A\cap B\in\Lambda(\mathcal{C})\)</span>, 同时易得 <span class="math inline">\(A\cap B\subset A\cap C\)</span>. 由于 <span class="math inline">\(\Lambda(\mathcal{C})\)</span> 是 <span class="math inline">\(\lambda\)</span> 系, 故对真差封闭, 即 <span class="math inline">\(A\cap(C\backslash B)=(A\cap C)\backslash(A\cap B)\in\Lambda(\mathcal{C})\)</span>, 于是 <span class="math inline">\(C\backslash B\in\Lambda_A\)</span>;</li><li><span class="math inline">\(\forall~\{A_n\}\subset\Lambda_A\)</span>, <span class="math inline">\(A_n\uparrow\)</span>, 则 <span class="math inline">\(A\cap A_n\in\Lambda(\mathcal{C})\)</span> 且 <span class="math inline">\(A\cap A_n\uparrow\)</span>. 因此有 <span class="math inline">\(A\cap(\bigcup_{n=1}^\infty A_n)=\bigcup_{n=1}^\infty(A\cap A_n)\in\Lambda(\mathcal{C})\)</span>.</li></ol><p>于是 <span class="math inline">\(\forall~A\in\Lambda(\mathcal{C})\)</span>, <span class="math inline">\(\Lambda_A\)</span> 是 <span class="math inline">\(\lambda\)</span> 系.</p><p>证明第二条: <strong>只需要证明 <span class="math inline">\(\Lambda_A\supset\mathcal{C}\)</span>.</strong> <span class="math inline">\(\forall~B\in\mathcal{C}\)</span>, 由于 <span class="math inline">\(\mathcal{C}\)</span> 是 <span class="math inline">\(\pi\)</span> 系, 故 <span class="math inline">\(A\cap B\in\mathcal{C}\subset\Lambda(\mathcal{C})\)</span>, 于是 <span class="math inline">\(\mathcal{C}\subset\Lambda_A\)</span>.</p><p>证明第三条: 仍然只需要证明 <span class="math inline">\(\mathcal{C}\subset\Lambda_A\)</span>. <strong>即需要证明 <span class="math inline">\(\forall~B\in\mathcal{C}\)</span>, <span class="math inline">\(B\in\Lambda_A\)</span>. 由于此时 <span class="math inline">\(A\)</span> 不一定在 <span class="math inline">\(\mathcal{C}\)</span> 中, 故无法对 <span class="math inline">\(A\)</span> 使用第二条中的方法. 但由于 <span class="math inline">\(B\in\mathcal{C}\)</span>, 故可以对 <span class="math inline">\(B\)</span> 使用第二条中使用的方法, 操作如下:</strong></p><p>取 <span class="math inline">\(A\in\Lambda(\mathcal{C})\)</span>, 则 <span class="math inline">\(\forall~B\in\mathcal{C}\)</span>, 由上条可知 <span class="math inline">\(A\in\Lambda_B\)</span>, 又由 <span class="math inline">\(\Lambda_B\)</span> 的定义可知 <span class="math inline">\(A\cap B\in\Lambda(\mathcal{C})\)</span>, 于是由 <span class="math inline">\(\Lambda_A\)</span> 的定义, <span class="math inline">\(B\in\Lambda_A\)</span>, 于是 <span class="math inline">\(\mathcal{C}\subset\Lambda_A\)</span>.</p><p>综上所述, 原命题得证.</p><h2 id="lambda-pi-系方法"><span class="math inline">\(\lambda-\pi\)</span> 系方法</h2><h3 id="lambda-pi-系方法-1"><span class="math inline">\(\lambda-\pi\)</span> 系方法</h3><p>在定理的证明过程中, &quot;要证明一些元素的集合满足性质 <span class="math inline">\(p\)</span>, 就先把满足性质 <span class="math inline">\(p\)</span> 的元素集合设出来, 再证明该集合与原集合相等&quot; 的方法常常按照如下方法操作:</p><p>已知 <span class="math inline">\(\mathcal{C}\)</span> 中元素具有性质 <span class="math inline">\(p\)</span>, 要证明 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 中元素也具有性质 <span class="math inline">\(p\)</span>, 则可以令 <span class="math inline">\(\Lambda=\{B\subset\Omega:B\text{具有性质}p\}\)</span>, 则 <span class="math inline">\(\Lambda\supset\mathcal{C}\)</span>, 然后证明 <span class="math inline">\(\mathcal{C}\)</span> 是 <span class="math inline">\(\pi\)</span> 系, 再证明 <span class="math inline">\(\Lambda\)</span> 是 <span class="math inline">\(\lambda\)</span> 系, 即可证明 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 中元素满足性质 <span class="math inline">\(p\)</span>.</p><p>这样的方法称为 <span class="math inline">\(\lambda-\pi\)</span> 系方法.</p><h3 id="lambda-pi-系方法的应用"><span class="math inline">\(\lambda-\pi\)</span> 系方法的应用</h3><h4 id="测度扩张定理的证明">测度扩张定理的证明</h4><p>证明见《测度与概率》（严士健、刘秀芳. 北京师范大学出版社.）P66-67 部分. 不再赘述.</p><h4 id="pi-系上的有限测度"><span class="math inline">\(\pi\)</span> 系上的有限测度</h4><blockquote><p>设 <span class="math inline">\(\mu,\nu\)</span> 是可测空间 <span class="math inline">\((\Omega,\mathcal{F})\)</span> 上的两个有限测度, <span class="math inline">\(\mathcal{C}\)</span> 为 <span class="math inline">\(\pi\)</span> 系, <span class="math inline">\(\Omega\in\mathcal{C}\)</span> 且 <span class="math inline">\(\sigma(\mathcal{C})=\mathcal{F}\)</span>. 若 <span class="math inline">\(\mu, \nu\)</span> 在 <span class="math inline">\(\mathcal{C}\)</span> 上一致, 则 <span class="math inline">\(\mu,\nu\)</span> 在 <span class="math inline">\(\mathcal{F}\)</span> 上也一致.</p></blockquote><p><strong>分析</strong>: 　　<span class="math inline">\(\mathcal{C}\subset\Lambda\)</span>, 要证明 <span class="math inline">\(\sigma(\mathcal{C})\subset\Lambda\)</span>, 考虑到 <span class="math inline">\(\mathcal{C}\)</span> 为 <span class="math inline">\(\pi\)</span> 系, 显然此处适用单调类定理.</p><p><strong>证明</strong>: 　　故证明 <span class="math inline">\(\Lambda\)</span> 是 <span class="math inline">\(\lambda\)</span> 系即可. 由单调类定理即得 <span class="math inline">\(\mathcal{F}\subset\Lambda\)</span>.</p><h4 id="另一形式的单调类定理">另一形式的单调类定理</h4><blockquote><p>　<span class="math inline">\(\Omega\)</span> 的子集类 <span class="math inline">\(\mathscr{M}\)</span> 称为 <span class="math inline">\(\Omega\)</span> 的<strong>单调类</strong>, 如果它满足:</p></blockquote><blockquote><ol style="list-style-type: decimal"><li>对不降集列的并封闭: 即 <span class="math inline">\(\{A_n\}_{n\in\mathbb{N}}\uparrow\subset\mathscr{M}\)</span>, 有 <span class="math inline">\(\bigcup\limits_{n=1}^\infty A_n\in\mathscr{M}\)</span>;</li><li>对不降集列的并封闭: 即 <span class="math inline">\(\{A_n\}_{n\in\mathbb{N}}\downarrow\subset\mathscr{M}\)</span>, 有 <span class="math inline">\(\bigcap\limits_{n=1}^\infty A_n\in\mathscr{M}\)</span>; 若 <span class="math inline">\(\mathscr{A}\)</span> 为 <span class="math inline">\(\Omega\)</span> 的集代数, 记包含 <span class="math inline">\(\mathscr{A}\)</span> 的最小单调类为 <span class="math inline">\(\mathfrak{M}(\mathscr{A})\)</span>, 则 <span class="math inline">\(\mathfrak{M}(\mathscr{A})=\sigma(\mathscr{A})\)</span>. 因而包含 <span class="math inline">\(\mathscr{A}\)</span> 的单调类必定包含 <span class="math inline">\(\sigma(\mathscr{A})\)</span>.</li></ol></blockquote><p><strong>分析</strong>: 　　先证明两个命题:</p><p>　　1. 若 <span class="math inline">\(\mathscr{A}\)</span> 同时为集代数和单调类, 则 <span class="math inline">\(\mathscr{A}\)</span> 是 <span class="math inline">\(\sigma\)</span> 代数; 　　2. <span class="math inline">\(\Omega\)</span> 的任意子集类 <span class="math inline">\(\mathcal{C}\)</span> 上的最小单调类存在.</p><p>其中第2条保证了单调类的 <span class="math inline">\(\mathfrak{M}(\mathscr{A})\)</span> 存在, 进而可利用第1条进行证明:</p><p>　　显然 <span class="math inline">\(\sigma(\mathscr{A})\)</span> 是单调类, 故 <span class="math inline">\(\sigma(\mathscr{A})\supset\mathfrak{M}(\mathscr{A})\)</span>, 故只需证 <span class="math inline">\(\sigma(\mathscr{A})\subset\mathfrak{M}(\mathscr{A})\)</span>;</p><p>　　为此只需证明 <span class="math inline">\(\mathfrak{M}(\mathscr{A})\)</span> 为包含 <span class="math inline">\(\sigma(\mathscr{A})\)</span> 的<span class="math inline">\(\sigma\)</span> 代数, 由命题 2, 只需证明 <span class="math inline">\(\mathfrak{M}(\mathscr{A})\)</span> 为集代数;</p><p>　　显然有 <span class="math inline">\(\Omega\in\mathscr{A}\subset\mathfrak{M}(\mathscr{A})\)</span>, 故只需证明 <span class="math inline">\(\mathfrak{M}(\mathscr{A})\)</span> 对差运算封闭.</p><p>接下来便是 <span class="math inline">\(\lambda-\pi\)</span> 证明的标准技巧: 　　令 <span class="math inline">\(M_A=\{B:B\in\mathfrak{M}(\mathscr{A}), A-B,B-A\in\mathfrak{M}(\mathscr{A})\}\)</span>, 接下来分三步证明:</p><ol style="list-style-type: decimal"><li>证明 <span class="math inline">\(M_A\)</span> 是单调类, <span class="math inline">\(\forall A\)</span>;</li><li><span class="math inline">\(\forall A\in\mathscr{A}\)</span>, <span class="math inline">\(M_A=\mathfrak{M}(\mathscr{A})\)</span>;</li><li><span class="math inline">\(\forall A\in\mathfrak{M}(\mathscr{A})\)</span>, <span class="math inline">\(M_A=\mathfrak{M}(\mathscr{A})\)</span>.</li></ol><p>以上即为证明思路.</p><p><strong>证明</strong>: 　　先证明两个引理.</p><blockquote><p><strong>引理 1</strong> 若 <span class="math inline">\(\mathscr{A}\)</span> 为 <span class="math inline">\(\Omega\)</span> 的集代数且是单调类, 则 <span class="math inline">\(\mathscr{A}\)</span> 为 <span class="math inline">\(\sigma\)</span> 代数.</p></blockquote><p><strong>引理 1的证明</strong>: 　　只需证明对于可列并封闭: 对 <span class="math inline">\(\forall \{A_n\}_{n\in\mathbb{N}}\subset\mathscr{A}\)</span> 构造部分和集列 <span class="math inline">\(B_n=\bigcup\limits_{i=1}^n A_i\)</span> 即可.</p><blockquote><p><strong>引理 2</strong> <span class="math inline">\(\Omega\)</span> 的任意子集类 <span class="math inline">\(\mathcal{C}\)</span> 上的最小单调类存在.</p></blockquote><p><strong>引理 2的证明</strong>:</p><p>　　首先证明非空: <span class="math inline">\(\Omega\)</span> 的全体子集 <span class="math inline">\(\mathcal{C}\subset\mathscr{P}(\Omega)\)</span> 显然构成单调类, 故非空;</p><p>　　其次构造出来: 取包含 <span class="math inline">\(\mathcal{C}\)</span> 的所有单调类的交, 容易验证该集类是一个单调类.</p><p>　　综上, 包含 <span class="math inline">\(\mathcal{C}\)</span> 的最小单调类存在且为所有包含 <span class="math inline">\(\mathcal{C}\)</span> 的单调类的交.</p><p>由这两个引理即可证明定理:</p><p>　　令 <span class="math inline">\(M_A=\{B:B\in\mathfrak{M}(\mathscr{A}), A-B,B-A\in\mathfrak{M}(\mathscr{A})\}\)</span>, 只需证明 <span class="math inline">\(M_A=\mathfrak{M}(\mathscr{A})\)</span>, <span class="math inline">\(\forall A\in\mathfrak{M}(\mathscr{A})\)</span>. 接下来分三步证明:</p><ol style="list-style-type: decimal"><li>证明 <span class="math inline">\(M_A\)</span> 是单调类, <span class="math inline">\(\forall A\)</span>;</li><li><span class="math inline">\(\forall A\in\mathscr{A}\)</span>, 证明 <span class="math inline">\(M_A=\mathfrak{M}(\mathscr{A})\)</span>;</li><li><span class="math inline">\(\forall A\in\mathfrak{M}(\mathscr{A})\)</span>, 证明 <span class="math inline">\(M_A=\mathfrak{M}(\mathscr{A})\)</span>. 　　 <strong>1. 证明 <span class="math inline">\(M_A\)</span> 是单调类, <span class="math inline">\(\forall A\)</span></strong> 　　取 <span class="math inline">\(A\in\mathfrak{M}(\mathscr{A})\)</span>, <span class="math inline">\(\forall\{B_n\}_{n\in\mathbb{N}}\uparrow\subset M_A\)</span>, 由 <span class="math inline">\(\mathfrak{M}(\mathscr{A})\)</span> 的定义即有 <span class="math inline">\(A-B_n,B_n-A,B_n\in\)</span>, 同时显然有 <span class="math inline">\(B_n-A\uparrow\)</span>, <span class="math inline">\(A-B_n\downarrow\)</span>. 由于 <span class="math inline">\(\mathfrak{M}(\mathscr{A})\)</span> 是单调类, 故 <span class="math inline">\(\bigcup\limits_{n=1}^\infty B_n\in\mathfrak{M}(\mathscr{A})\)</span>.</li></ol><p>　　同时还有: <span class="math display">\[\begin{align}A-\bigcup\limits_{n=1}^\infty B_n &amp;= A\cap\left(\bigcap\limits_{n=1}^\infty B_n^c\right) \\&amp;= \bigcap_{n=1}^\infty (A\cap B_n^c) \\&amp;= \bigcap_{n=1}^\infty (A-B_n) \in\mathfrak{M}(\mathscr{A})~; \\\left(\bigcup\limits_{N=1}^\infty B_n\right)-A &amp;= \bigcup\limits_{n=1}^\infty (B_n-A)\in\mathfrak{M}(\mathscr{A})~.\end{align}\]</span> 　　于是有 <span class="math inline">\(\bigcup\limits_{n=1}^\infty B_n\in M_A\)</span>, 即 <span class="math inline">\(M_A\)</span> 对上升集列的并封闭.</p><p>　　同理可证 <span class="math inline">\(M_A\)</span> 对下降集列的交也封闭. 即 <span class="math inline">\(M_A\)</span> 是单调类.</p><p><strong>2. <span class="math inline">\(\forall A\in\mathscr{A}\)</span>, 证明 <span class="math inline">\(M_A=\mathfrak{M}(\mathscr{A})\)</span></strong></p><p>　　若 <span class="math inline">\(A\in\mathscr{A}\)</span>, 则对 <span class="math inline">\(\forall B\in\mathscr{A}\)</span>, 有 <span class="math inline">\(A-B,B-A\in\mathscr{A}\subset\mathfrak{M}(\mathscr{A})\)</span>, 由 <span class="math inline">\(M_A\)</span> 的定义知 <span class="math inline">\(B\in M_A\)</span>, 即 <span class="math inline">\(\mathfrak{M}(\mathscr{A})\subset M_A\)</span>.</p><p>　　另一方面, 由上条知 <span class="math inline">\(M_A\)</span> 为包含 <span class="math inline">\(\mathscr{A}\)</span> 的单调类, 故 <span class="math inline">\(\mathfrak{M}(\mathscr{A})\subset M_A\)</span>, 故有 <span class="math inline">\(M_A=\mathfrak{M}(\mathscr{A})\)</span>.</p><p><strong>3. <span class="math inline">\(\forall A\in\mathfrak{M}(\mathscr{A})\)</span>, 证明 <span class="math inline">\(M_A=\mathfrak{M}(\mathscr{A})\)</span></strong></p><p>　　考虑 <span class="math inline">\(B\in\mathfrak{M}(\mathscr{A})\)</span>, 则对 <span class="math inline">\(\forall A\in\mathscr{A}\)</span>, 由上条知 <span class="math inline">\(M_A=\mathfrak{M}(\mathscr{A})\)</span>, 于是 <span class="math inline">\(B\in M_A\)</span>. 进一步由 <span class="math inline">\(M_A\)</span> 的定义有 <span class="math inline">\(B-A,A-B\in\mathfrak{M}(\mathscr{A})\)</span>.</p><p>　　又由于 <span class="math inline">\(\mathscr{A}\subset\mathfrak{M}(\mathscr{A})\)</span>, 故 <span class="math inline">\(A\in\mathfrak{M}(\mathscr{A})\)</span>, 结合 <span class="math inline">\(M_B\)</span> 的定义有 <span class="math inline">\(A\in M_B\)</span>.</p><p>　　即 <span class="math inline">\(\forall A\in\mathscr{A}\)</span>, 总有 <span class="math inline">\(A\in M_B\)</span>. 于是 <span class="math inline">\(\mathscr{A}\subset M_B\)</span>. 即 <span class="math inline">\(M_B\)</span> 是包含 <span class="math inline">\(\mathscr{A}\)</span> 的单调类, 于是 <span class="math inline">\(\mathfrak{M}(\mathscr{A})\subset M_B\)</span>.</p><p>　　结合 <span class="math inline">\(M_B\subset \mathfrak{M}(\mathscr{A})\)</span>, 即有 <span class="math inline">\(M_B=\mathfrak{M}(\mathscr{A})\)</span>, <span class="math inline">\(\forall B\in\mathfrak{M}(\mathscr{A})\)</span>. 　　 <strong>综上所述,</strong> 若 <span class="math inline">\(\mathscr{A}\)</span> 为集代数, 则包含 <span class="math inline">\(\mathscr{A}\)</span> 的最小 <span class="math inline">\(\sigma\)</span> 代数与包含 <span class="math inline">\(\mathscr{A}\)</span> 的最小单调类相同.</p><h2 id="函数形式的单调类定理">函数形式的单调类定理</h2><h3 id="mathscrl-系"><span class="math inline">\(\mathscr{L}\)</span> 系</h3><p>设 <span class="math inline">\(\mathscr{L}\)</span> 是定义在 <span class="math inline">\(\Omega\)</span> 上的广义实函数类, 满足: <span class="math inline">\(f\in\mathscr{L}\Rightarrow f^+,f^-\in\mathscr{L}\)</span>. 函数族 <span class="math inline">\(L\)</span> 称为 <span class="math inline">\(\mathscr{L}\)</span> 系, 如果满足:</p><ol style="list-style-type: decimal"><li><span class="math inline">\(1\in L\)</span>;</li><li><span class="math inline">\(L\)</span> 中有限个函数的线性组合(如果有意义)属于 <span class="math inline">\(L\)</span>;</li><li>若 <span class="math inline">\(f_n\in L\)</span>, <span class="math inline">\(n\in\mathbb{N}\)</span>, <span class="math inline">\(0\leqslant f_n\uparrow f\)</span>, <span class="math inline">\(f\)</span> 有界或 <span class="math inline">\(f\in\mathscr{L}\)</span>, 则 <span class="math inline">\(f\in L\)</span>.</li></ol><h3 id="单调类定理-1">单调类定理</h3><blockquote><p>若 <span class="math inline">\(\mathscr{L}\)</span> 系 <span class="math inline">\(L\)</span> 包含一 <span class="math inline">\(\pi\)</span> 系 <span class="math inline">\(\mathcal{C}\)</span> 中任意集合的示性函数, 则 <span class="math inline">\(L\)</span> 包含所有属于 <span class="math inline">\(\mathscr{L}\)</span> 的 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 可测函数.</p></blockquote><p><strong>证明</strong>:</p><p>　　令 <span class="math inline">\(\Lambda=\{A\subset\Omega: I_A\in L\}\)</span>, 则由 <span class="math inline">\(\mathscr{L}\)</span> 系定义可知 <span class="math inline">\(\Omega\in\Lambda\)</span>, <span class="math inline">\(\Lambda\)</span> 对真差封闭并且对不降集列的并封闭, 因而 <span class="math inline">\(\Lambda\)</span> 为 <span class="math inline">\(\lambda\)</span> 系. 又由于 <span class="math inline">\(\mathcal{C}\subset\Lambda\)</span>, 且 <span class="math inline">\(\mathcal{C}\)</span> 为 <span class="math inline">\(\pi\)</span> 系, 结合集合形式的单调类定理可知 <span class="math inline">\(\sigma(\mathcal{C})\subset\Lambda\)</span>, 故 <span class="math inline">\(\{I_A: A\in\sigma(\mathcal{C})\}\subset L\)</span>. 由定义可知 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 上的任意简单函数在 <span class="math inline">\(L\)</span> 中.</p><p>　　设 <span class="math inline">\(f\)</span> 为 <span class="math inline">\(\mathscr{L}\)</span> 中非负 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 可测函数, 则存在非负不降 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 简单函数列 <span class="math inline">\(f_n\uparrow f\)</span>. 由于 <span class="math inline">\(L\)</span> 是 <span class="math inline">\(\mathscr{L}\)</span> 系, 故 <span class="math inline">\(f\in L\)</span>.</p><p>　　若 <span class="math inline">\(f\in\mathscr{L}\)</span> 且 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 可测, 则由 <span class="math inline">\(\mathscr{L}\)</span> 的定义可知 <span class="math inline">\(f^+,f^-\in\mathscr{L}\)</span> 且非负 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 可测, 于是 <span class="math inline">\(f^+,f^-\in L\)</span>, 结合 <span class="math inline">\(f=f^+-f^-\)</span> 有意义及定义可知 <span class="math inline">\(f\in L\)</span>. 定理得证.</p><h2 id="mathscrl-系方法"><span class="math inline">\(\mathscr{L}\)</span> 系方法</h2><h3 id="mathscrl-系方法-1"><span class="math inline">\(\mathscr{L}\)</span> 系方法</h3><p>要想证明某一函数族 <span class="math inline">\(F\)</span> 具有某种性质 <span class="math inline">\(p\)</span>, 为此设一个函数族 <span class="math inline">\(\mathscr{L}\)</span>, s.t. <span class="math inline">\(L=\{f: 函数 f 具有性质 p\}\)</span> 为一个 <span class="math inline">\(\mathscr{L}\)</span> 系. 再引入一个 <span class="math inline">\(\pi\)</span> 系 <span class="math inline">\(\mathcal{C}\)</span>, s.t. <span class="math inline">\(\mathscr{L}\)</span> 中的 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 可测函数类包含 <span class="math inline">\(F\)</span>.</p><p>以上两步完成之后, 由单调类定理, 只要证明 <span class="math inline">\(\forall A\in\mathcal{C}\)</span>, <span class="math inline">\(I_A\in L\)</span> 即可. 这种方法被称为 <span class="math inline">\(\mathscr{L}\)</span> 系方法.</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 概率论 </tag>
            
            <tag> 测度论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GRE阅读题目分析[4]</title>
      <link href="/2017/07/25/GRE%E9%98%85%E8%AF%BB%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%5B4%5D/"/>
      <content type="html"><![CDATA[<p>GRE 阅读的一点小小的总结.</p><a id="more"></a><h2 id="题型辨识">题型辨识</h2><h3 id="事实信息类">事实信息类</h3><h4 id="事实信息">事实信息</h4><ol style="list-style-type: decimal"><li>单纯事实信息<ul><li>The passage makes which of the following claims (about X)?</li><li>The passage claims which of the following (about X)?</li><li>The passage suggests which of the following about X?</li><li>The passage would probably agree with which of the following claims (about X)?</li><li>(According to the passage,) which of the following claims (about X) is true?</li><li>(According to the passage,) X.</li><li>Which of the following best characterizes the &quot;X&quot; that the author refers to?</li><li>Which of the following claims about X can be inferred from the passage?</li><li>It can be inferred from the passage that X.</li><li>It can be inferred that the author would agree with which of the following (claims about X)?</li><li>Information presented in the passage suggests which of the following about X?</li><li>Information in the passage best supports which of the following claims about X?</li><li>With which of the following claims (about X) (discussed in the passage) would the author most likely agree?</li></ul></li><li>结合逻辑的事实信息<ul><li>According to the passage, X had which of the following effects for ...?</li><li>According to the passage, the primary purpose of X is to ...</li><li>The passage mentions which of the following as one of the reasons X?</li><li>According to the passage, X in that ...</li></ul></li><li>结合视角的事实信息<ul><li>According to the passage, S would agree that X.</li><li>According to the passage, which of the following is the most accurate statement of what S about Earth's X?</li><li>The passage implies that S1 attributed which of the following beliefs to S2?</li><li>The author of the passage and S would most likely agree/disagree with which of the following (claims about X)?</li></ul></li></ol><h4 id="反事实信息">反事实信息</h4><ul><li>Each of the following is mentioned in the passage as X EXCEPT for the ...</li></ul><h4 id="问题">问题</h4><ul><li>The passage supplies information for answering which of the following questions?</li></ul><h4 id="反问题">反问题</h4><ul><li>The passage supplies information for answering all of the folliwing questions EXCEPT:</li></ul><h4 id="加强">加强</h4><ul><li>Which of the following statements, if true, wuold provide the strongest support/most strengthen X?</li></ul><h4 id="削弱">削弱</h4><ul><li>Which of the following if true, would most call into question/pose the greatest challenge to/most tend to weaken X?</li><li>Which of the following is the most logical objection to X?</li><li>X would be most seriously undermined if which of the following were true?</li><li>Which of the following, if true, would provide the LEAST support for X?</li></ul><h4 id="假设">假设</h4><ul><li>In the highlighted portion of the passage, the S assumes that ...</li><li>The claim in the highlighted sentence assumes which of the following about X?</li></ul><h4 id="态度">态度</h4><ul><li>The attitude of the author of the passage toward X can best be described as ...</li><li>Which of the following best describes the author's attitude toward X?</li></ul><h4 id="有保留的支持">有保留的支持</h4><ul><li>Qualified approval: 有让步存在.</li></ul><h3 id="信息功能类">信息功能类</h3><h4 id="信息功能">信息功能</h4><ul><li>The author mentions X most primarily/probably/most likely in order to ...</li><li>By quoting X, the author of the passage most clearly succeeds in ...</li><li>Which of the following best describes the function of the highlighted sentence (in the passage)?</li><li>(In the passage,) the function of the highlighted portion is to ...</li><li>(In the passage,) the mention of X serves primarily to ...</li><li>(In the passage,) the highlighted portion servers primarily to ...</li><li>The highlighted sentence has which of the following functions in the passage?</li><li>The highlighted sentence exemplifies which of the following?</li><li>X is presented in the poassage primarily as [存疑]</li></ul><h4 id="选句子">选句子</h4><ul><li>Select the sentence that ...</li><li>Click on the sentence in the passage that ...</li></ul><h4 id="论证结构">论证结构</h4><ul><li>Which of the following best characterizes/describes the organization of the passage as a whole?</li></ul><h3 id="主旨">主旨</h3><ul><li>Which of the following best describes the main/central idea of the passage?</li><li>The primary purpose of the passage is to (discuss which of the following?)</li><li>The passage is primarily concerned with (doing which of the following)</li><li>The passage is structured to lead to the conclusion that ...</li><li>Which of the following generalizations most directly underlies the author's central point?</li></ul><h3 id="词汇">词汇</h3><ul><li>In the context in which it appears, &quot;X&quot; most nearly means ...</li><li>Replacement of the word &quot;X&quot; with which of the following results in the least change in meaning for the passage?</li></ul><h3 id="类比">类比</h3><ul><li>Which of the following is most similar to/is most closely analogous to/most closely parallels X?</li></ul>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
            <tag> GRE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GRE填空思路分析[3]——推理的线索来源·同义线索</title>
      <link href="/2017/07/24/GRE%E5%A1%AB%E7%A9%BA%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90%5B3%5D%E2%80%94%E2%80%94%E6%8E%A8%E7%90%86%E7%9A%84%E7%BA%BF%E7%B4%A2%E6%9D%A5%E6%BA%90%C2%B7%E5%90%8C%E4%B9%89%E7%BA%BF%E7%B4%A2/"/>
      <content type="html"><![CDATA[<p>GRE 填空的一点小小的总结.</p><blockquote><p>同义重复线索一般有四种: <strong>简单重复解释、因果关系、递进关系、指代关系</strong>.</p></blockquote><a id="more"></a><h2 id="简单重复解释">简单重复解释</h2><p>尽管是&quot;简单&quot;重复解释, 但此类题目并不简单.</p><p>简单重复解释的标志一般有以下几种:</p><ul><li>冒号: 对相关线索的解释;</li><li>分号: 表示分号前后信息的重复;</li><li>修饰解释结构:<ul><li>......, 解释成分, (定语从句/同位语从句/分词短语);</li><li>...... n., 解释成分.</li></ul></li></ul><p>直白地说, 简单重复解释就是两部分内容一致.</p><p>例如下面一道难题:</p><blockquote><p>例: In modern times, friendship has become a ____ relationship: a form of connection in terms of which all are understood and against which all are measured.<br>A. conciliatory<br>B. mercenary<br>C. paradigmatic<br>D. contentious<br>E. supplementary</p></blockquote><p>文章在冒号前的部分指出: 现在, 友谊成为了一种 X 的关系. 冒号后则指出: 所有的东西都是通过友谊来理解和度量的. 本题的难点主要就在于冒号后句子的理解. in terms of 后面的 which 指代的是之前的 a form of connection. 同理, against 后的 which 也指的是这种特定的 connection. 由于 against 与 in terms of 中间用 and 连接, 实际上意思是类似的. 所以冒号后的整个句子意思为: 所有的(all)东西都是通过 friendship 来理解和度量的, 所以 X 应该是一个表示&quot;标准&quot;的词语. 故选择 C. paradigmatic 意为&quot;典范&quot;.</p><p>一道容易错的题目如下:</p><blockquote><p>例: Scholarly works on detective stories often begin with (i)____, suggesting that there is something vaguely wrong with adults who spend their time reading such f iction and certainly something (ii)____ those who devote energy to its analysis.</p></blockquote><table><thead><tr class="header"><th align="left">Blank(i)</th><th align="left">Blank(ii)</th></tr></thead><tbody><tr class="odd"><td align="left">A. chronologies</td><td align="left">D. awry in</td></tr><tr class="even"><td align="left">B. apologies</td><td align="left">E. astute about</td></tr><tr class="odd"><td align="left">C. synopses</td><td align="left">F. courageous about</td></tr></tbody></table><p>文中虽然没有出现冒号和分号, 但在第一空后有一个 suggesting, 说明 suggesting 前后说的是同一件事.</p><ul><li>前: 关于侦探小说的研究时常以 X 开头;</li><li>后: and 前后同样应该说的是同一件事.<ul><li>前: adults 读侦探小说是错误的;</li><li>后: 在侦探小说的分析上耗费能量是 Y 的.</li></ul></li></ul><p>由 suggesting 后的句子的内部结构即可选出第二空为 D. awry in, 意为&quot;错误&quot;. 至此 suggesting 后的部分已经完整, 意为&quot;读侦探小说是错误的&quot;. 考虑第一空的答案, 只有 B. apologies 满足条件.</p><p>还有两道难题如下:</p><blockquote><p>例: The new art museum's (i)____ building a ugurs well for that ambitious institution because it speaks of (ii)____ contemporary architecture on the part of the board of directors that may (iii)____ equal astuteness about contemporary art.</p></blockquote><table><thead><tr class="header"><th align="left">Blank(i)</th><th align="left">Blank(ii)</th><th align="left">Blank(iii)</th></tr></thead><tbody><tr class="odd"><td align="left">A. nondescript</td><td align="left">D. a discernment about</td><td align="left">G. conceal</td></tr><tr class="even"><td align="left">B. outstanding</td><td align="left">E. a hostility toward</td><td align="left">H. supplant</td></tr><tr class="odd"><td align="left">C. outdated</td><td align="left">F. an intoxication by</td><td align="left">I. promise</td></tr></tbody></table><p>首先考虑第一空. 文章首先指出了博物馆的建筑具有 X 特点, 这预示着他们很有野心. 从这个很有野心出发, 可知他们的建筑也一定是具有一些很厉害的特点, 容易选出 A 选项.</p><p>文章随后开始解释原因. 整句话是一个 it speaks of ... that ... 的结构, 于是 that 前后说的应该是同一件事情:</p><ul><li>前: 董事会就现代建筑的 X 而言 <span class="math inline">\(\Rightarrow\)</span> 董事会对于现代建筑具有 X;</li><li>后: 可能会 Y 董事会对当代艺术同等的机智.</li></ul><p>其实本来挺明白的意思稍微翻译一下变得狗屁不通。。在 that 后边出现了一个 equal astuteness, 说明 that 之前也一定得有一个 astuteness, 于是只能在空格处, 故第二空应选 D. a discernment about. 至此 that 前的部分已经完整, 意为&quot;董事会对现代建筑具有机智(什么垃圾东西)&quot;. 故 that 后的部分也应表达这个方向的意思, 故 that 之后的部分意思应为&quot;董事会对当代艺术也有着同等的机智&quot;, 这中间的连接词便应选择 I. promise. 完整的意思便是&quot;董事会对现代建筑所表现出的机智暗示着他们可能对当代艺术也有着同等的机智.&quot;</p><p>与前一部分合并起来, 整句话的意思就是: <strong>新美术馆杰出的建筑预示着他们很有野心, 因为董事会对现代建筑所表现出的机智暗示着他们可能对当代艺术也有着同等的机智.</strong> MD, 真别扭.</p><blockquote><p>例: Belanger dances with an (i)____ that draws ones attention as if by seeking to (ii)____ it; through finesse and understatement, he manages to seem at once intensely present and curiously detached.</p></blockquote><table><thead><tr class="header"><th align="left">Blank(i)</th><th align="left">Blank(ii)</th></tr></thead><tbody><tr class="odd"><td align="left">A. undermonstrative panache</td><td align="left">D. focus</td></tr><tr class="even"><td align="left">B. unrestrained enthusiasm</td><td align="left">E. overwhelm</td></tr><tr class="odd"><td align="left">C. unattractive gawkiness</td><td align="left">F. deflect</td></tr></tbody></table><p>文章中有分号出现, 说明前后两部分说的是同一件事:</p><ul><li>前: Belanger 的舞蹈伴随着一种 X, 通过 Y 的方式吸引着人们的注意;</li><li>后: 通过故意设计出的技巧和 understatement, 他能够非常神奇地既保持 detached, 又表现出强烈的感情.</li></ul><p>考虑前后两部分之间的对应, finesse and understatement 的对应点应是第一空 understatement 在这里的意思应是&quot;不完全的展现&quot;, 故对比语义可以选出 A. undemonstrative panache.</p><p>接下来考虑第二空, Belanger 为了吸引大家的关注, 用了 Y 手段. it 指代的是前文的 attention, 正常情况下, 吸引大家的关注应采取 focus 的手段. 但考虑到后文的 curiously 以及 undemonstrative panache, 这种低调的炫酷, 应该选择 focus 的反面, 即 F.</p><h2 id="因果关系">因果关系</h2><p><strong>因果关系的基本原则</strong>: 因果等价——有什么原因, 就有什么结果(因为爱, 所以爱). <strong>因果关系的重要标志</strong>:</p><ul><li>given...: 考虑到, 由于;</li><li>in that...: 因为;</li><li>so...that...: 非常...因为... .</li></ul><p>以下是两个例子:</p><blockquote><p>例: The politician's record while in office, though (i)____, hardly accounts for her high standing three decades later--a standing all the more (ii)____ because of continuing assaults on her reputation during those years.</p></blockquote><table><thead><tr class="header"><th align="left">Blank(i)</th><th align="left">Blank(ii)</th></tr></thead><tbody><tr class="odd"><td align="left">A. bewildering</td><td align="left">D. unusual</td></tr><tr class="even"><td align="left">B. admirable</td><td align="left">E. regrettable</td></tr><tr class="odd"><td align="left">C. unappreciated</td><td align="left">F. persistent</td></tr></tbody></table><p>文章的大概结构为: 这个政客在办公室里的纪录尽管非常 X, 但仍然很难对她在30年之后如此高的地位做出解释——这些年来对她持续不断的批评攻击使得这个地位更加的 Y.</p><p>破折号前边是一个转折, 前后意思应相反, 故 X 应该是&quot;牛b&quot;的意思, 故选择 B, 令人尊敬.</p><p>破折号后边是一个因果关系, 原因的部分指出这些年来她遭受着持续不断的攻击, 但仍然能到达了如此高的地位, 所以这应该是很不寻常的, 选择 D.</p><blockquote><p>例: The gaps in existing accounts of the playwright's life are not (i)____, since much of the documentary evidence on which historians have relied is (ii)____.</p></blockquote><table><thead><tr class="header"><th align="left">Blank(i)</th><th align="left">Blank(ii)</th></tr></thead><tbody><tr class="odd"><td align="left">A. trifling</td><td align="left">D. credible</td></tr><tr class="even"><td align="left">B. obvious</td><td align="left">E. extent</td></tr><tr class="odd"><td align="left">C. implicit</td><td align="left">F. incomplete</td></tr></tbody></table><p>文章在第一空的后边出现了 since, 意味着前后的部分存在对应关系, 故可以寻找两部分之间的对应.</p><ul><li>since 前: 对剧作家生平的解释中的 gap 并不 X;</li><li>since 后: 很多被历史学家所相信的证据都是 Y 的.</li></ul><p>两句话的结构都非常简单, 都是&quot;A 具有特征 B&quot;, 由此可以得到, 两个空格之间是互相关联的. 于是无法直接求解两个空格的答案, 只能逐个考虑.</p><p>第一空显然是不能选择 C 的, C 选项意为&quot;含蓄&quot;, 用来形容 gap 显然是不恰当的.</p><p>若第一空选择 A, 则前半句的意思为&quot;对于剧作家生平的解释之间, 差异并不是很小的&quot;, 也就是在说&quot;这些解释是完全不靠谱的&quot;, 因为彼此之间差异很大. 于是后半句也应表示&quot;这些解释压根儿不靠谱&quot;, 故第二空选择 F. 至此, AF 是可行的方案.</p><p>若第二空选择 B, 则前半句的意思为&quot;对于剧作家生平的解释之间, 差异并不明显&quot;, 后半句应选择一个&quot;靠谱的证据&quot;, 故选择 D 选项. 此时 BD 看起来也是很合理的一个答案...</p><p>嗯 官方给出的答案是 AF...</p><h2 id="递进关系">递进关系</h2><p><strong>递进关系的基本原则</strong>: 表示前后程度的加深或变浅. <strong>递进关系的重要标志</strong>:</p><ul><li><strong>Even</strong>: 句首让步, 句中递进;</li><li><strong>indeed</strong>: 进一步地讨论;</li><li><strong>almost, not only...but also...</strong>;</li><li><strong>not just...but downright</strong>: 不仅...更是彻底的...;</li><li><strong>at best..., at worst...</strong>: 说好听了..., 说不好听了...;</li><li><strong>at least</strong>: 至少, 表示对前面的削弱.</li></ul><p>以下是一道很长的题...:</p><blockquote><p>例: The order applies to all Federal agency whose actions may affect the status of invasive species and requires agencies to identify such actions and to the extent parcticable and permitted by law, and since invasive species severely reduce the number of native species and <strong>even</strong> (i)____ their existence, the agency has determined and made public its determination that the benefits of such actions clearly outweigh the potential harm caused by invasive species; and that all feasible <strong>and</strong> (ii)____ measures to (iii)____ risk of harm of the introduction of invasive species will be taken in conjunction with the actions.</p></blockquote><table><thead><tr class="header"><th align="left">Blank(i)</th><th align="left">Blank(ii)</th><th align="left">Blank(iii)</th></tr></thead><tbody><tr class="odd"><td align="left">A. escalate</td><td align="left">D. prudent</td><td align="left">G. remedy</td></tr><tr class="even"><td align="left">B. preclude</td><td align="left">E. mawkish</td><td align="left">H. counterbalance</td></tr><tr class="odd"><td align="left">C. diminish</td><td align="left">F. braggart</td><td align="left">I. minimize</td></tr></tbody></table><p>第一空之前有一个 even, 说明 X their existence 是对 severely reduce 的程度加深, 故应选择 B, 阻碍它们的生存. 第二空与 feasible 之间用 and 连接, 说明 Y 与 feasible 方向相同, 故选择 D, 意为谨慎. 前文一直在讲物种入侵的内容, 那么这些方法必然是降低物种入侵带来的危害的, 故之坑考虑 HI 选项. 若选 H, 则意为&quot;抵消风险&quot;, 从根本上来将, 风险是不能抵消的, 因为风险是客观存在的一种东西, 无法被抵消, 只能被弱化. 故第三空应选择 I.</p><p>综上所述, 选择 BDI.</p><p>以下是 not just... but downright... 的一个例子:</p><blockquote><p>例: Making loans and fighting poverty are normally two of the least glamorous pursuits around, but remarkable enough put the two together, and you have an economic innovation that has become not just (i)____ but downright ____.</p></blockquote><table><thead><tr class="header"><th align="left">Blank(i)</th><th align="left">Blank(ii)</th></tr></thead><tbody><tr class="odd"><td align="left">A. popular</td><td align="left">D. chic</td></tr><tr class="even"><td align="left">B. pointless</td><td align="left">E. unfathomable</td></tr><tr class="odd"><td align="left">C. dangerous</td><td align="left">F. sensible</td></tr></tbody></table><p>看到 not just... but downright... 的结构, 很容易知道 X→Y 是递进的关系, 观察选项只能选择 A(流行) 和 D(时髦).</p><h2 id="指代关系">指代关系</h2><p><strong>指代关系的基本原则</strong>:</p><ul><li>such..., this..., the former..., the equal..., the same... 这些词后提及的名词一定在前文出现过;</li><li>物主代词+空格, 则前文一定提到过.</li></ul><p>以下是一个例子:</p><blockquote><p>例: Though extremely (i)____ about his own plans, the man allowed his associates no such privacy and was constantly (ii)____ information about what they intended to do next.</p></blockquote><table><thead><tr class="header"><th align="left">Blank(i)</th><th align="left">Blank(ii)</th></tr></thead><tbody><tr class="odd"><td align="left">A. candid</td><td align="left">D. soliciting</td></tr><tr class="even"><td align="left">B. idiosyncratic</td><td align="left">E. altering</td></tr><tr class="odd"><td align="left">C. reticent</td><td align="left">F. eschewing</td></tr></tbody></table><p>文章整体是一个转折的结构: 尽管他对于自己的计划非常 X, 但他却总是 Y 别人下一步的动作.</p><p>考虑到转折, 前后的意思一定是相反的, 而后半句中出现了 such privacy, 故这个 privacy 一定在前文出现过, 故只能是在空格处, 故第一空应选择表示&quot;保护隐私&quot;的词语, 故选择 C 沉默寡言. 考虑到转折, 后文一定是&quot;不尊重隐私&quot;的意思, 故选择 D 渴求, 不断打听. 整体的意思为: 尽管他对自己的计划保持沉默, 但他却不遗余力地打听其他人下一步的动作.</p><p>一道难题如下:</p><blockquote><p>例: To label Hamilton a foreigner because he was born outside what later became the United States is to assume anachornistically the existence of the nation before the fact. It is true that Hamilton ame to believe that he was a (i)____ the United States, but his (ii)____ was stemmed not from his (iii)____ but from his confrontation with American democracy which he considered to be a disease afflicting the nation.</p></blockquote><table><thead><tr class="header"><th align="left">Blank(i)</th><th align="left">Blank(ii)</th><th align="left">Blank(iii)</th></tr></thead><tbody><tr class="odd"><td align="left">A. symbol of</td><td align="left">D. alienation</td><td align="left">G. ideology</td></tr><tr class="even"><td align="left">B. stranger in</td><td align="left">E. ambition</td><td align="left">H. profession</td></tr><tr class="odd"><td align="left">C. citizen of</td><td align="left">F. patriotism</td><td align="left">I. birthplace</td></tr></tbody></table><p>文章的第一句话没有设空, 意思为: 因 Hamilton 没有出生在这个后来叫做美国的地方就称 Hamilton 为外国人是不恰当的, 因为在美国建立之前就将这个地方成为美国是时代错误的. 由此我们可以得到:</p><ol style="list-style-type: decimal"><li>Hamilton 确实没有出生在美国的土地上;</li><li>不能直接称 Hamilton 为外国人.</li></ol><p>考察第一空, 整句为 It is true that... but... 的结构, 故 It is true... 的部分应是一个让步, 故这句话表达的意思应是&quot;Hamilton 确实有些像个外国人&quot;, 故第一空应填 B.</p><p>第二空是题目的难点. 前半句说了&quot;尽管 Hamilton 看起来确实很奇怪&quot;, 故后半句应回到文章的管线&quot;Hamilton 不能因为不生在美国土地就被称为外国人&quot;上面来. 考虑至此, 第三空的答案已经得出, 应选择 I 选项. 继续推断, 可推测出第二空应选择 D.</p><p>第二句整体的意思为: 虽然 Hamilton 在美国看起来确实很奇怪, 但他的疏离并非源于他的出生地, 而是他对于美国民主的反对.</p><p>综上所述, 本题应选择 BDI.</p><p>另一道难题也是三空题:</p><blockquote><p>例: Recent proposals for fixing the climate have taken the form of large-scale geoengineering projects such as launching mirrors into space to reflect solar radiation away from Earth, undertaking that are vastly more (i)____ than anything a nineteenth-century rainmaker could have cooked up. What is unclear, as one looks back at the history of weather modification research, is whether this resourceful ambition will be (ii)____, or if, by contrast, it serves to make the scientific community's (iii)____ that much more devastating.</p></blockquote><table><thead><tr class="header"><th align="left">Blank(i)</th><th align="left">Blank(ii)</th><th align="left">Blank(iii)</th></tr></thead><tbody><tr class="odd"><td align="left">A. effective</td><td align="left">D. anticipate</td><td align="left">G. avidity</td></tr><tr class="even"><td align="left">B. enterprising</td><td align="left">E. challenged</td><td align="left">H. impotence</td></tr><tr class="odd"><td align="left">C. accessible</td><td align="left">F. productive</td><td align="left">I. resignation</td></tr></tbody></table><p>最近&quot;向空中发射一个镜子反射太阳辐射以改善气候&quot;的提案是远比19世纪的 rainmaker 编造的东西更 X 的任务. 但当你回头审视人们对于修改天气的研究的时候, this resourceful ambition 是否会 Y 依然不甚清楚, 或者相反, 他会使得科学界的 Z 更加具有破坏力.</p><p>注意到文中有 this resourceful ambition... 存在指代关系, 于是 resourceful ambition 一定在前文提到过, 经过比较可以确定对应位置在第一空处. 接下来需要明确 resourceful ambition 的含义, resourceful 的意思是&quot;能在困难中有效地处理&quot;, 一般有两种解读, 一种是有效的(effective), 一种是有创造力的(imaginative). 对应到第一空的选项, 分别可以选择 A. 有效 和 B. 创新. 至此还没有有效的证据对此处的意思进行推定.</p><p>继续考虑第二和第三空, 第三空后的 that 此处等价于 so, 表示强调. 能使得 Z 更具有破坏力, 说明 Z 本身就具有破坏力, 故此处应填负面评价的词汇, 考察选项, 应选择 H. 此处应注意, G. avidity 不能翻译为&quot;贪婪&quot;, 事实上 avidity 约等于 ambition. 由 by contrast, 反推第二空应填正面评价的词, 考察选项可选出 F, 事实上 productive 也恰好就是 impotence 的反义词.</p><p>现在回头去思考第一空, 我们已经大约知道了 X = resourceful, 故第二空所在的句子意思为&quot;这种 X 的 ambition 是否有效还不清楚&quot;. 若第一空选择 A, 则与该句矛盾, 故第一空只能选择 B.</p><p>总结以下, 解题的思路是:</p><ol style="list-style-type: decimal"><li>this resourceful ambition... → X=resourceful → X=A/B;</li><li>Z 是有破坏力的 → Z=H;</li><li>by contrast... + 2 → Y=F → ambition是否有效还不清楚;</li><li>3 + 1 → X<span class="math inline">\(\neq\)</span>A → X=B.</li></ol><p>综上所述, 本题答案为 BFH.</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
            <tag> GRE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GRE阅读题目分析[3]</title>
      <link href="/2017/07/23/GRE%E9%98%85%E8%AF%BB%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%5B3%5D/"/>
      <content type="html"><![CDATA[<p>GRE 阅读的一点小小的总结.</p><a id="more"></a><h2 id="如何读信息">如何读信息</h2><h3 id="意群信息提取原则">意群信息提取原则</h3><p>始终默认所读的逻辑关系是成立的, 寻找概括、补充、修正关键信息次, 以验证已经确定的关系.</p><h4 id="顺-3种情况">顺: 3种情况</h4><ol style="list-style-type: decimal"><li>同义改写: =——前后完全相同;</li><li>举例: <span class="math inline">\(\in\)</span>——例子符合逻辑;</li><li>理由: 联系, 补足理由与观点之间的gap<ul><li>e.g. 万炜会成功的, 因为他很努力. (努力就会成功)</li><li>e.g. 万炜一定会成功的, 因为努力的人都成功了. (万炜一定很努力)</li></ul></li></ol><h4 id="转-质疑挑双方的异同补足反驳理由和结论之间的gap">转: 质疑——挑双方的异同/补足反驳理由和结论之间的gap</h4><ul><li>e.g. 主流观点认为万炜帅, 但其实只在学校比较帅.</li><li>e.g. 主流观点认为万炜聪明, 但他GRE挂了. (聪明人不会挂GRE)</li><li>e.g. 主流观点认为万炜聪明, 可聪明的人应该过了GRE. (万炜一定没有过GRE)</li></ul><h4 id="比-类比对比">比: 类比/对比</h4><ol style="list-style-type: lower-alpha"><li>对比: A vs B.</li><li>类比: A <span class="math inline">\(\approx\)</span> B.</li></ol><h2 id="观点单一的文章">观点单一的文章</h2><blockquote><p>George Milner cites three primary problems with the labeling of Cahokia, the large archeological site by the Mississippi River, as a state rather than a chiefdom. First, finds at Cahokia are essentially similar to finds at other Mississippian chiefdoms, except that the amount of earth moved in building the mounds at Cahokia was greater than else where. Second, fewer people lived at Cahokia than is commonly estimated (Milner estimates that there were only a few thousand inhabitants, more common estimates are 10,000 or 20,000 inhabitants); therefore, extensive taxes, and tribute were not necessary to support them. Finally, while there is evidence of extensive earth movement, craftwork, trade, and elite at Cahokia, this does not indicate that Cahokia was politically centralized, economically specialized of aggressively expansionistic.</p></blockquote><blockquote><p>The passage implies that political centralization is a feature that<br>A. has not historically tended to emerge in centers with fewer than 20,000 inhabitants<br>B. distinguished other Mississippian chiefdoms from Cahokia<br>C. is considered characteristic of state but not of chiefdoms<br>D. often results from aggressive expansionism and sconomic specialization<br>E. has historically been necessary for extensive trade to occur</p></blockquote><p>文章开头指出, George Milner 认为, Cahokia 应该是 chiefdom, 而不是 state. 需要注意 &quot;cite three problems&quot; 的意思应该是负面的, 认为后面的句子是不正确的. 故 GM 应该不认同 Cah 是 state, 而认为 Cah 是 chief 的. 简记为 GM: cah=chief vs. state.</p><p>随后文章开始逐一解释 GM 的三个问题:</p><ol style="list-style-type: decimal"><li>Cah 与 chief 很相似, 除了土比较多. 把握住文章的第一句话, 考虑到本句不可能是新信息, 故GM不具备的特点应该就是 state 的特点. 于是可以建立符号对应: state: 土多;</li><li>cah 具有人少的特点, 并且不需要 tax, trade 和 tribute (记为 3t). 继续扣住文章第一句话, 本句就是在说 chief→人少, 不需要3t. 继续推理可得, state→人多, 需要3t;</li><li>尽管 cah 存在 em, cr, tr, el, 但是 cah 并不是 pe, es, ae 的. 这里出现了一个让步, 故前半句应该是对另一方的妥协, 即前半句是在说&quot;尽管cah具有一些state的特点&quot;, 故 em, cr, tr, el 均为 state 的特点. 同理, 后半句在说&quot;但cah仍然是chief&quot;. 故 chief 一定是非pe, 非es, 非ae的.</li></ol><p>总结一下, 本篇文章的结构如下:</p><p>GM: Cah=chief vs. state</p><ol style="list-style-type: decimal"><li>cah像chief　　　state土多</li><li>人少, <span class="math inline">\(\neg\)</span> 3t　　　人多, 3t</li><li><span class="math inline">\(\neg\)</span>pe, <span class="math inline">\(\neg\)</span>es, <span class="math inline">\(\neg\)</span>ae　　　em, cr, tr, el</li></ol><h2 id="存在观点冲突的文章">存在观点冲突的文章</h2><blockquote><p>Astronomers studying a certain kind of supernova (exploding star) were surprised to find the supernovas were fainter than expected. Seeking explanations, they discounted the possibility that cosmic dust might be screening out some of the light, because it would filter out blue light more than red, causing the supernovas to appear redder than they really are. Also, unless spread very smoothly throughout space, the dust would introduce large variations in the <strong>measurements</strong>. Another possibility is gravitational lensing, the bending of light rays as they skirt galaxies <em>en route</em>. Such lensing occasionally causes brightening, but most often it contributes to the dimness of distant supernovas. Calculations show, however, that this effect becomes important only for sources more distant than the supernovas studied.</p></blockquote><blockquote><ol style="list-style-type: decimal"><li>According to the passage, the astronomers rejected gravitational lensing as an explanation for their findings because<br>A. gravitational lensing can cause supernovas to appear brighter than they really are.<br>B. their calculations showed a negligible effect of gravitational lensing for light rays from distant sources.<br>C. light rays trabeling from the supernovas studied did not have to skirt galaxies.<br>D. the effect of gravitational lensing on the appearance of supernovas is unpredictable.<br>E. the supernovas studied were too near for gravitational lensing to have the observed dimming effect.</li></ol></blockquote><blockquote><ol start="2" style="list-style-type: decimal"><li>The passage implies which of the following about the measurements made by the astronomers?<br>A. There were small calculation errors in their measurements.<br>B. There were no large variations in their measurements.<br>C. Their measurements were skewed by unevenly spread cosmic dust.<br>D. Their measurements were incomplete because cosmos dust screened out some of the light.<br>E. It was possible to take more measurements of red light than of blue light.</li></ol></blockquote><p>文章开头是一个事实——supernova 比看起来要暗一些, 那么后文一定是在对这件事情进行解释. 下文指出, 宇航员们首先排除了宇宙尘埃的影响, 因为比起红光, 尘埃会过滤更多的蓝光. &lt;???&gt;这个句子很迷, 至此还没有非常有效的信息, 但是可以初步得到一个类似于&quot;尘埃使得supernova变红并不能使之变暗&quot;的结论. 后文的 Also, unless ... 指出, 在一般情况下, 尘埃会带来很大的边数. 这个地方与问题看起来联系仍然不是非常紧密. 这里的内容读起来非常迷, 留在分析题目时继续讨论.</p><p>下文的 Another possibility is ... 一句指出, 除了尘埃之外还有一种可能的原因, 就是 gravitational lensing, 简记为 GL. 但是接下来突然出现了 Such lensing occasionally causes brightening. (??? 作者在搞什么? GL 不是 supernova 变弱的原因吗? 怎么忽然又能使之变亮了?) 继续阅读后文, 发现后文存在一个 but, 即可知上文的 brighten 其实是一个让步. but 后指出, 多数情况下, GL 还是会使 supernova 变暗的.</p><p>文章到这里还没有结束. 最后一句中的 however 看起来就像一个大大的&quot;卧槽&quot;. 忍住骂人的冲动继续读, 大概可以了解到最后一句的意思是&quot;尽管..., 但是计算表明 GL 只对那些比supernova更远的星星有效果.&quot; 此处应有&quot;卧槽&quot;, 读了这么半天, 原来问题还是没有解决. 先提到了尘埃, 然后说尘埃被排除了. 提到GL这个高大上的东西的时候, 读者一定看到了希望, 然后...GL就被证明是错误的了.</p><p>综上所述, 这篇文章的内容可以简化为:</p><p>super faint → dust? × → GL? → contribute to dimness: √ → 适用距离太远: ×.</p><p>文章的第一题显然出题点就是最后一句, 所以该题的答案一定是&quot;supernova 太近了, GL 适用距离太远了&quot;. 很容易选出E选项.</p><p>第二题比较困难, 考察的就是事实与观点之间的gap. 在分析文章时, 尘埃附近的内容读起来比较迷, 原因就在于<strong>作者只提供了最终结果和做出判断的前提, 没有给出二者之间的详尽推理</strong>. 文中指出, dust 被排除在外, 言下之意就是 dust 对于 supernova 变暗没有贡献. 而下文的 Also, unless ... 一句指出, 除非光线的传播非常顺畅, 否则观测一定有很大变数. 上文提到 dust 是可以阻碍光线传播的, 于是光线顺畅地传播等价于没有尘埃. 所以这句话实际上应该理解为: 除非尘埃不存在, 否则观测会存在很大的变数. 至此, 我们得到的信息是: 宇航员认为 supernova 的黯淡不是 dust 造成的, 并且若 dust 存在, 则一定会给观测带来很大的变数. 那么这两件事情之间需要补充的gap就是: 在观测中没有遇到很大的变数. 这里宇航员的推理就是一个典型的 <span class="math inline">\(p\to q, \neg q\Rightarrow \neg p\)</span> 的推理过程. 在这里, <span class="math inline">\(p\)</span> dust 的存在, <span class="math inline">\(q\)</span> 观测存在很大的变数. 已知 <span class="math inline">\(p\to q\)</span>, 宇航员一定是观测到了 <span class="math inline">\(\neg q\)</span>, 才敢断言 <span class="math inline">\(\neg p\)</span>. 于是这道题的答案应是 B.</p><p>顺带一提第二题中令人费解的事实和结论. 文章指出:</p><blockquote><p>宇航员排除了 dust 的影响, 因为 dust 会使得 supernova 变红. 并且, 除非 dust 不存在, 否则 dust 会给观测带来很大的变数.</p></blockquote><p>这里的原理是: 红光的波长比较长, 于是在传播时不容易衰减. 于是距离比较远的天体看起来也比较偏红, 因为波长短的光在长距离传播中被散射掉了. 尘埃会使得 supernova 变红, 自然也就会使得人们对于距离的观测值变大, 即给 measurement 带来 large variation. 所以, dust 的存在, 一定会给观测带来巨大的影响. 基于这些原理, 文中的宇航员才会做出如此的判断.</p><p>第二题的难度较高, 难的原因主要在于逻辑的推导. <strong>常见的一些逻辑如下</strong>:</p><ol style="list-style-type: decimal"><li>If p, q. —— <span class="math inline">\(p\to q\)</span>;</li><li>Only if p, q. —— <span class="math inline">\(\neg p\to\neg q\)</span>;</li><li>Unless p, q. —— <span class="math inline">\(\neg p\to q\)</span>.</li></ol><p>关于<strong>因果和转折中的条件的真假性</strong>, 有如下分类:</p><ul><li><strong>因果:</strong><ol style="list-style-type: decimal"><li>Because p, q. —— p 为真;</li><li>If p, q. —— p 不确定;</li><li>If p were true, q would have been true. —— p 为假.</li></ol></li><li><strong>转折:</strong><ol style="list-style-type: decimal"><li>Even though p, q. —— p 为真;</li><li>Even if p, q. —— p 不确定;</li><li>Even if p were true, q would have been true. —— p 为假.</li></ol></li></ul>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
            <tag> GRE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GRE填空思路分析[2]——推理的线索来源·反义线索</title>
      <link href="/2017/07/20/GRE%E5%A1%AB%E7%A9%BA%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90%5B2%5D%E2%80%94%E2%80%94%E6%8E%A8%E7%90%86%E7%9A%84%E7%BA%BF%E7%B4%A2%E6%9D%A5%E6%BA%90%C2%B7%E5%8F%8D%E4%B9%89%E7%BA%BF%E7%B4%A2/"/>
      <content type="html"><![CDATA[<p>GRE 填空的一点小小的总结.</p><blockquote><p>反义线索主要有对比和让步转折两种.</p></blockquote><a id="more"></a><h2 id="对比">对比</h2><h3 id="情况1-矛盾词">情况1: 矛盾词</h3><p><strong>irony, ironical, ironically.</strong></p><p><strong>paradox, paradoxical, paradoxically.</strong></p><p><strong>contradiction, contradictiony.</strong></p><p><strong>opposite, oppositior.</strong></p><p><strong>contrast, contrary.</strong></p><blockquote><p><strong>例</strong>: The concept of timelessness is paradoxical from the start, for adult consciousness is permeated by the awareness of duration.</p></blockquote><p>例句中的 timelessness 理解为&quot;永恒的&quot;是没有意义的, timelessness的真实含义应为&quot;无始无终的&quot;. 而 duration 显然是有始有终的一段时间, 故 timelessness 与 duration 形成对立.</p><p>如下面的三题:</p><blockquote><p><strong>例</strong>: Paradoxically, Robinson's excessive denials of the worth of early works of science fiction suggest that she has become quite ____ them.<br>A. enchanted by<br>B. enamored of<br>C. skeptical of<br>D. exasperated by<br>E. offended by<br>F. reflective about</p></blockquote><p>题目很简单, 前半句抛出了对比的一半信息: Robinson 认为科幻作品没有价值. 故后半句应表示出&quot;Robinson 认为科幻作品有价值&quot; 的意思. 故选择 AB 选项.</p><blockquote><p><strong>例</strong>: An apparent paradox led the scientists to pursue their present line of research. They were struck by the fact that a single mathematic formula can be used to describe physical phenomena that appears to be so ____.<br>A. rudimentary (基本的, basic)<br>B. interdependent (相互依赖)<br>C. interrelated (相互关联)<br>D. complex<br>E. heterogeneous (不同)<br>F. dissimilar</p></blockquote><p>题目中有 be struck by... 的结构, 表明后面存在对比. a single formula 能够用以描述一些物理现象. 此处似乎无法直接确定选项, 于是可以将前文的single直接取反, 即可得到后面的物理现象应该是&quot;不同的&quot;. 故选 EF 选项.</p><blockquote><p><strong>例</strong>: From the outset, the concept of freedom of the seas from the proprietary claims of nations was challenged by a contrary notion--that of the ____ of the oceans for reasons of national security and profit.<br>A. promotion<br>B. exploration<br>C. enclosure<br>D. appropriation<br>E. conservation<br>F. surveying</p></blockquote><p>句首的 from the outset 等价于 from the beginning. 随后文章指出, 自由的概念被一个 contrary notion 所挑战, 故后面应该是说的如何不自由. 选项中可以找到 freedom 的广义反义词为 CD.</p><h3 id="情况2-强烈情感词">情况2: 强烈情感词</h3><p><strong>surprisingly, astoundingly, weird, startling, curiously (莫名其妙), remarkable (异乎寻常), be struck by.</strong></p><blockquote><p><strong>例</strong>: Thomas Painem whose political writing was often flamboyant, was in private life a <strong>surprisingly</strong> simple man: he lived in rented rooms, ate little, and wore drab clothes.</p></blockquote><p>文章中 Thomas Paine 的作品酷炫与生活简单形成了对比. 信号词就是surprisingly.</p><p>在出现对比的时候一定要理清文章的逻辑和内容, 否则可能会因此选错. 如以下的两题</p><blockquote><p><strong>例</strong>: While in many ways their personalities could not have been more different--she was ebulliend where he was glum, relaxed where he was awkward, garrulous where he was ____--they were surprisingly well suited.<br>A. solicitous (渴求的)<br>B. munificent (大方的)<br>C. irresolute (犹豫不决)<br>D. laconic (言简意赅, concise)<br>E. fastidious (小心谨慎, 一丝不苟, 挑剔苛求)<br>F. taciturn (沉默寡言)</p></blockquote><p>文章中很容易看到 surprisingly 的存在, surprisingly 后指出两人很般配, 于是可知前文应该是说两人是不般配, 甚至相对立的. 文章在空格前指出了 she was garrulous, garrulous 意为&quot;啰嗦&quot;, 故后文应表示&quot;他话很少&quot;的意思, 故选择 DF 选项.</p><blockquote><p><strong>例</strong>: Scholars have marveled over the (i)____ that Shakespeare displays in his works, noting that such broad learning is all the more remarkable given that books were relatively (ii)____ in Shakespeare's time.</p></blockquote><table><thead><tr class="header"><th align="left">Blank (i)</th><th align="left">Blank (ii)</th></tr></thead><tbody><tr class="odd"><td align="left">A. meticulousness (一丝不苟, fastidious)</td><td align="left">D. edifying (有教育意义的)</td></tr><tr class="even"><td align="left">B. humor</td><td align="left">E. scarce</td></tr><tr class="odd"><td align="left">C. erudition (博学)</td><td align="left">F.inexpensive</td></tr></tbody></table><p>文章的前半部分有一个 noting that such broad learning..., 此处的 broad learning 是新提出的, 故前文一定提到过. 浏览前文, 并没有提到相关内容, 故一定是空格处提出的. 于是(i)空应选C项. 结合marvel 和remarkable, 可知前后两部分形成了对比, 于是莎士比亚读的书应该是很少, 才能与他的博学形成对比. 故第(ii)空应填 E.</p><h3 id="情况3-其他常见对比关系">情况3: 其他常见对比关系</h3><p>其他常见对比关系:</p><ul><li>时间点前后: recently, previous, before, current, now, today, yesterday, later, future, initially, no longer;</li><li>表象和实质: in fact, in reality, ostensible(表面上的), normally;</li><li>一般对特殊;</li><li>整体对个体;</li><li>结构对比:<ul><li>不是A, 而是B: not A but B, far from A to B, less A than B;</li><li>是A, 而不是B: more A than B, A rather than B.</li></ul></li></ul><p>以下是两道比较难的题目, 都是双空题.</p><blockquote><p><strong>例</strong>: The museum's compelling new architechural exhibition looks at eleven projects around the world that have had major (i)____ impacts despite modest budget. It is part of (ii)____ in the museum's architecture and design department, which in the past has championed architecture's artistic value over its real- world consequences.</p></blockquote><table><thead><tr class="header"><th align="left">Blank(i)</th><th align="left">Blank(ii)</th></tr></thead><tbody><tr class="odd"><td align="left">A. social</td><td align="left">D. an emphasis on theory</td></tr><tr class="even"><td align="left">B. aesthetic</td><td align="left">E. a shift in philosophy</td></tr><tr class="odd"><td align="left">C. critical</td><td align="left">F. a rejection of programatism</td></tr></tbody></table><p>文章首句指出了博物馆的展览关注的是11座造价不高的建筑, 而 despite 表明了空格与 modest budget 之间存在对比关系, 但至此仍然无法在 ABC 中找到正确选项. 第二句中的 it 指代的应是前文提到的展览, 接下来空格附近的内容也无法确定, 但下文出现了 which, 一定会对这里的内容进行解释. 注意到 in the past 的存在表明了此处应该存在一种时间上的今昔对比, champion A over B 意为&quot;支持 A 而不支持 B&quot;, 即曾经不重视 real- world consequences, 故如今应当重视. 注意这里谈论的内容仍然是与展览相关, 故此处的信息一定是前文提到的, 于是第(i)空应选择 A 选项, 以表示该展览重视了 real- world consequences.</p><p>第二空附近的内容被后面 which 引导的从句所解释, 故两方面内容应该是基本等价的, 概括从句内容可知是博物馆对于 artistic value 和 real- world consequences 的态度发生了转变, 故第二空选择 E 选项. 此处的 philosophy 不表示&quot;哲学&quot;的意思, 而是表示一种&quot;理念&quot;的意思.</p><p>值得注意的是, in the past 在整个文章中的地位极其重要, 如果没有看到 in the past, 则第(i)空选择 B. aesthetic 也可以说得通, 而第二个空也会错误理解为&quot;博物馆仍然不重视real- world consequences&quot;, 从而错选为 F. a rejection of pragmatism, 意为&quot;对实用主义的消极态度.&quot;</p><blockquote><p><strong>例</strong>: Britain's deteriorating economy after 1945 was (i)____ by policians who favored the manufacuring sector over the service sector: rather than attempting to (ii)____ the decline of manufacturing, they should have promoted service industries.</p></blockquote><table><thead><tr class="header"><th align="left">Blank(i)</th><th align="left">Blank(ii)</th></tr></thead><tbody><tr class="odd"><td align="left">A. mishandled</td><td align="left">D. augment</td></tr><tr class="even"><td align="left">B. bolstered</td><td align="left">E. arrest</td></tr><tr class="odd"><td align="left">C. forestalled</td><td align="left">F. escalate</td></tr></tbody></table><p>文章在第(i)空之前的部分提到了英国恶化的经济状况, 空格后的 by politicians... 表明空格表示的是政客的一些操作. 随后文章指出了政客的想法是 favored the manufacturing sector over the service sector, 意为&quot;把制造业看得比服务业更重要.&quot; 至此仍然没有清晰的线索指向第(i)空的操作.</p><p>接下来出现了冒号, 则冒号后的内容方向一定是与前文一致的. 不妨设第(ii)空的内容为 X, 则冒号后的内容为, 政客本应该促进服务业的发展, 而非 X 制造业的衰落. 至此第(ii)空的线索已经明确. 政客们的操作目的应是拯救英国衰退的经济, 故 X 应表达&quot;阻止制造业的衰退&quot;的意思, 故应选择 E 选项. 最后的虚拟语气 they should have promoted... 是非常关键的线索. 一般来说, 虚拟语气暗含着对比: &quot;他们本应该...&quot;, 实际上是在表明&quot;他们如果不这样就会很好, 但他们搞砸了.&quot; 所以这句话实际上表明了&quot;政客们使得英国本就不景气的经济雪上加霜.&quot; 于是第一空应选择 A. mishandled, 意为经营不善.</p><p>综上所述, 题目应选择 AE 选项.</p><h2 id="让步转折">让步转折</h2><p>让步转折的主要标志: <strong>but, while, though, although, despite, in spite of, notwithstanding, nonetheless, nevertheless, for all, yet, unless, however, whatever, regardless of, albeit</strong>.</p><p>其中有一些注意事项:</p><ol style="list-style-type: decimal"><li>despite 是介词, 后面需要接词, 不能直接跟句子, 如果需要跟句子, 则需要 despite that... ;</li><li>notwithsatnding 可以做副词或介词, 意为&quot;尽管&quot;;</li><li>forall = despite;</li><li>albeit = although;</li><li>nonethless 和 nevertheless 的用法:<ul><li>若二者单独出现, 则意为&quot;然而&quot;;</li><li>若前文已有转折词, 则二者无意义.</li></ul></li><li>but 用法的一个特例: but...more... 表示&quot;进一&quot;, &quot;更多的&quot;.</li></ol><p>在做题时要通过各种信号词来推测空格与已知信息的正负关系, 不能忽略掉任何一个, 否则就容易理解错误. 如下面的例子:</p><blockquote><p><strong>例</strong>: Clearly the government faced a dilemma: it could hardly ____ trials, especially in the absence of irrefutable evidence, but it also would not welcome, in the midst of war, the scandal that would raise if trials were avoided.<br>A. be keen on<br>B. be inclined to<br>C. arrange<br>D. dispense with<br>E. turn its back on<br>F. credit</p></blockquote><p>开头提到了一个困境, 暗示后文是两件事情的对立. 设空格为 X, 则容易分析出 hardly X trials 与 would not welcome the scandal 是矛盾的. 考虑到 scandal 是在避免 trials 的情况下出现的, 故 scandal = <span class="math inline">\(\neg\)</span> welcome trials. 于是之前得到的结论, <span class="math inline">\(\neg\)</span> X trials =<span class="math inline">\(\neg\)</span><span class="math inline">\(\neg\)</span><span class="math inline">\(\neg\)</span> welcome trials. 故 X trials = welcome trials. 于是应选择正向的选项, 即AB.</p><p>如果在分析过程将 welcome 的宾语错当为 trials, 或漏掉转折的标志, 则有可能会错选DE.</p><p>值得一提的是, dilemma 专指的是左右两难的困境. 即 dilemma 一定是两件事情之间的纠结状态.</p><p>一个难题如下:</p><blockquote><p><strong>例</strong>: As serious as she is about the bullfight, she does not allow respect to ____ her sense of whimsy when painting it.<br>A. inspire<br>B. provoke<br>C. suppress<br>D. attack<br>E. satisfy</p></blockquote><p>题目中出现了 As 引导的半倒装句, 一般来说表示让步. 后面的 allow respect to ... 也是一个比较难以分析的地方. 事实上, 此处的结构为 allow sb to ..., 若理解为 allow (respect to ...) ... 则题目无法下手. 关系和内容明确后, 文章变为了 serious to bullfight=<span class="math inline">\(\neg\)</span> not allow to X her sense of whimsy while paint it. 即 X = <span class="math inline">\(\neg\)</span> serious. 即应选择负面的词语, 为 C 选项.</p><p><strong>关于 as, 有如下几条:</strong></p><ul><li>as 引导的半倒装句表示让步.<ul><li>Student as she is, she does not study hard.</li><li>尽管她是个学生, 她并不好好学习.</li></ul></li><li>As ... as ... = So ... as ...<ul><li>As: adv. = so;</li><li>as: conj. 正如, 就像.</li></ul></li></ul><p>再次回到题目, 文章中相对应的部分实际上是 So serious 和 respect.</p><h2 id="同主体让步转折">同主体让步转折</h2><p>同主体让步转折, 顾名思义就是主体不变的情况下进行让步和转折. 但前后不可能完全对立, 即不可能出现&quot;他很帅, 但很丑&quot;这样明显错误的句子. 但考虑到不完全对立, 可以有&quot;我很丑但我很温柔&quot;这样的句子, 这样的情形就被称为同主体让步转折. 可以总结为以下几条:</p><ul><li>形式: Although A..., A...<ul><li>前后转折主体为统一事物, 并处于同一时空范围内.</li></ul></li><li>原则<ul><li>前后两个空格不能截然相反;</li><li>前后两个空格可以是正负相对但意思无关的概念. (丑-温柔, 聪明-懒惰)</li></ul></li></ul><p>以下是一道难题:</p><blockquote><p><strong>例</strong>: His affection for his sister, though not ____, was plainly too great to permit a painless departure.<br>A. unsteady<br>B. noticeable<br>C. ambivalent<br>D. careless<br>E. unbounded</p></blockquote><p>此处的 affection 意为&quot;爱&quot;. 观察到文中的 though, 结合语义可得到 not X = <span class="math inline">\(\neg\)</span> great. 故 X 为正向的词语. 符合要求的有 BE 两项.</p><p>此题很容易错选B选项. B. noticeable 带入文章中意为&quot;尽管他对姐姐的爱不是那么明显, 但仍然足够great.&quot; 虽然情感方向正确, 但后文的plainly 意为&quot;明显的, 显然的&quot;, 与此处的 not noticeable 矛盾. 故综合考虑应选择 E. unbounded.</p><p>以下是另一道难题:</p><blockquote><p><strong>例</strong>: While not completely nonplussed by the unusually caustic responses from members of the audience, the speaker was nonetheless visibly ____ by their criticism.<br>A. humiliated<br>B. discomfited<br>C. deluded<br>D. disgraced<br>E. embarrassed<br>F. tantalized</p></blockquote><p>文章的大概意思为&quot;尽管speaker还没有被完全弄得困惑, 但他显然还是被弄得 X.&quot; 值得注意的是文章中 nonetheless 不表示转折, 意为&quot;仍然&quot;. 于是 X 应是负面的词, 但强烈程度不及&quot;nonplussed&quot;. 单纯考虑情感方向, 可以选择 AD. 羞辱 或者 BE. 不爽/尴尬. 继续考虑到强烈程度的问题, 应选择 BE.</p><p>本题的 F 选项 tantalized 意为&quot;挑逗&quot;. <strong>GRE中常出现的&quot;挑逗&quot;共有3个: tantalized &lt; allure &lt; seduce. 引诱程度依次加深</strong>. 其中 seduce 意为&quot;色诱&quot;.</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
            <tag> GRE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GRE填空思路分析[1]——词句推理</title>
      <link href="/2017/07/20/GRE%E5%A1%AB%E7%A9%BA%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90%5B1%5D/"/>
      <content type="html"><![CDATA[<p>GRE 填空的一点小小的总结.</p><a id="more"></a><h2 id="verbal-reasoning-的特点">Verbal Reasoning 的特点</h2><ul><li>第一个记分的语文的填空部分一定是2个单空, 3个双空, 1个三空.</li><li>建议用时: 10min填空, 20min阅读.</li><li>填空题目不考察背景知识, 所有线索均来自于题目.</li></ul><h2 id="词汇问题">词汇问题</h2><h3 id="第一类问题-词义理解有误">第一类问题: 词义理解有误:</h3><p>韦氏词典+美国传统辞典;</p><h3 id="第二类问题-望文生义">第二类问题: 望文生义:</h3><table><thead><tr class="header"><th align="left">单词</th><th align="left">真实含义</th></tr></thead><tbody><tr class="odd"><td align="left">invaluable/priceless</td><td align="left">特别值钱</td></tr><tr class="even"><td align="left">impassive</td><td align="left">消极冷漠</td></tr><tr class="odd"><td align="left">impassion</td><td align="left">热情</td></tr><tr class="even"><td align="left">effortless</td><td align="left">不费力的</td></tr><tr class="odd"><td align="left">ignorance</td><td align="left">无知</td></tr><tr class="even"><td align="left">salient</td><td align="left">显著的</td></tr><tr class="odd"><td align="left">appraise</td><td align="left">评价</td></tr><tr class="even"><td align="left">acclaim</td><td align="left">喝彩</td></tr><tr class="odd"><td align="left">servered</td><td align="left">切开</td></tr><tr class="even"><td align="left">reserve/reverse</td><td align="left">保留/相反</td></tr><tr class="odd"><td align="left">guild</td><td align="left">协会</td></tr></tbody></table><h3 id="第三类问题-熟词僻义">第三类问题: 熟词僻义:</h3><table><thead><tr class="header"><th align="left">单词</th><th align="left">熟词生义</th></tr></thead><tbody><tr class="odd"><td align="left">turf</td><td align="left">地盘</td></tr><tr class="even"><td align="left">list</td><td align="left">倾斜</td></tr><tr class="odd"><td align="left">licence</td><td align="left">自由</td></tr></tbody></table><h3 id="第四类问题-纯难词词根猜测">第四类问题: 纯难词/词根猜测</h3><p>背单词...Orz</p><h2 id="长难句理解">长难句理解</h2><h3 id="长句">长句</h3><p>三个概念:</p><ul><li>that 的作用:<ol style="list-style-type: decimal"><li>代词, 表示&quot;那个&quot;;</li><li>引导从句.</li></ol></li><li>同位语: 跟在名词后, 表示对其的修饰;</li><li>分词短语:<ol style="list-style-type: decimal"><li>做定语, 表示对前面名词的修饰;</li><li>做状语, 与主语用逗号隔开表示主语的状态. <strong>用逗号隔开的必定是状语, 反之可能是定语.</strong></li></ol></li></ul><blockquote><p>例: The increase in the numbers of married women employed outside the home in the twentieth century had less to do with the mechanization of housework and an increase in leisure time for these women than it did with their own economic necessity and with high marriage rates that shrank the available pool of single women workers, previously, in many cases, the only women employers would hire.</p></blockquote><p>例句中, The increase 是主语, had less to do with 是谓语, than it did with... and with 是宾语. 至此主干已经清楚, 最后的 the only women 是同位语.</p><h3 id="难句">难句</h3><blockquote><p>例: For some time now, ____ has been persumed not to exist: the cynical conviction that everybody has an angle is considered wisdom.<br>A. rationality<br>B. flexibility<br>C. diffidence<br><strong>D</strong>. disinterestedness<br>E. insincerity</p></blockquote><p>例句的最后部分 everybody has an angle is considered wisdom 的意思是&quot;每个人都很自私.&quot; 考虑到冒号前的not, 前后两部分意思应相反, 故选择D, 意为&quot;无私.&quot;</p><blockquote><p>例: The current ____ of package music under Miles Davis' name might prompt ant reasonable person to conclude that the recording vault has been plundered bare.<br><strong>A</strong>. glut (过量)<br>B. revival (复活)<br><strong>C</strong>. hodgepodge (大杂烩)<br>D. surfeit (过量)<br>E. modicum (少量)<br>F. dearth (少量)</p></blockquote><p>例句的最后部分 the recording valut has been plundered bare 直译为&quot;唱片金库被掠夺一空.&quot; 此处的意思为&quot;Miles Davis 已经江郎才尽.&quot; 于是题目应选择 AD 选项.</p><h2 id="推理的步骤与注意事项">推理的步骤与注意事项</h2><h3 id="逻辑和语义">逻辑和语义</h3><p>逻辑的判断方法:</p><ol style="list-style-type: decimal"><li>是否有反义: 首先判断分句与分句之间是否有反义转折词;</li><li>是否有否定: 其次判断空格或抑制信息前后是否有否定;</li><li>有几个否定: 转折词汇也算作否定, 判断否定的层数;</li></ol><p>常见的否定词: <strong>no/not, less, little, anything but, few, never, hardly=barely, rarely=seldom</strong>.</p><p>语义的判断方法: 判断广义同反义.</p><p>广义同义概念:</p><ul><li>严格同义词;</li><li>感情色彩相同的词, 如: 勤奋-善良, 邪恶-懒惰;</li><li>正负方向相同的词, 如: 增高-变多;</li><li>逻辑相关词, 如: 艺术-艺术家, 科学-科学报告.</li></ul><p>广义反义概念:</p><ul><li>严格反义词;</li><li>感情色彩相反的词;</li><li>正负方向相反的词;</li><li>与极端词相对应的中性词, 如: 上升-下降, 上升-静止 均可.</li></ul><h3 id="推理的步骤">推理的步骤</h3><p>一般有以下的五步:</p><ul><li>通读题干, 明确哪一空最好做;</li><li>明确空格作用: 如表示谁的动作, 修饰的是谁的属性;</li><li>判断逻辑同反义关系;</li><li>判断空格的语义对应线索;</li><li>对空格做出预测, 选出正确选项.</li></ul><p><strong>填空的后半句一定没有新概念出现, 若有, 则一定在前半部分出现过.</strong></p><h3 id="推理的注意事项">推理的注意事项</h3><ul><li>一定要以文章的剩余信息为依据, 解题线索一定来自题目本身, 不要带入主观假设和偏见;</li><li>需要有必要的常识 common sense</li></ul><blockquote><p>例: Nature's energy efficiency often (i)____ human technology: despite the intensity of the light fireflied produce, the amount of heat is negligible (可忽略的); only recently have humans developed chemical light-producing systems whose efficiency (ii)____ the firefly's system.</p></blockquote><table><thead><tr class="header"><th align="left">Blank (i)</th><th align="left">Blank (ii)</th></tr></thead><tbody><tr class="odd"><td align="left">A. outstrips (超过)</td><td align="left">D.rivals (与...相匹敌)</td></tr><tr class="even"><td align="left">B. reflects</td><td align="left">E. manipulates</td></tr><tr class="odd"><td align="left">C. determines</td><td align="left">F. inhibits (抑制)</td></tr></tbody></table><p>例句中首先说明了萤火虫的光很强但发热很少, 下文又提到了能量效率. 能量效率=有用能量/总能量 就是一个常识, 于是容易知道萤火虫的发光效率非常高. 而萤火虫是冒号后新出现的东西, 故一定是前文所提到的, 可知萤火虫所属的阵营是自然, 于是可以猜测下文要说的是人类的能量效率比较低. 于是本题应选择 AD 选项.</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
            <tag> GRE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GRE阅读题目分析[2]</title>
      <link href="/2017/07/16/GRE%E9%98%85%E8%AF%BB%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%5B2%5D/"/>
      <content type="html"><![CDATA[<p>GRE 阅读的一点小小的总结.</p><a id="more"></a><h2 id="文章内容">文章内容</h2><blockquote><p>　　Many scholars have argued that government investment in manufacturing in the southern United States during the Second World War spurred a regional economic boom that lasted into the postwar period. But much of this investment went to specialized plants, many of them unsuitable for postwar production. Large-scale, wartime government funding led to a massive increase in the number and scale of munitions facilities. By the war’s end, 216 munitions establishment costing more than $3.5 billion had been built, many of them located in the south. Indeed, according to one estimate, more than 70 percent of federally financed manufacturing construction capital in Alabama, Arkansas, Mississippi, and Tennessee went into munitions plants.<br>　　Even in the northern regions with strong prewar manufacturing economics, these plants were difficult to deal with once the imperative of war had been removed. In the south few industrialists had the capacity or desire to transform these factories to a peacetime function. Accordingly, at war’s end almost all of the southern munitions facilities were shut down, placed on standby, operated at a very low capacity, or converted to nonmanufacturing functions, usually storage. Although some reopened a few years later for use during the Korean War, the impact of the special plants on the South’s postwar economy was marginal at best.</p></blockquote><h2 id="结构分析">结构分析</h2><h3 id="文章开头">文章开头</h3><p>由文章的第一句中 &quot;many scholars have argued that...&quot; 可知该句为引用观点, 故该文章很有可能是一个质疑型的文章. 首句指出: <strong>很多学者认为, 二战期间, 政府对美国南方在工业方面的投资刺激了经济的发展, 并持续到了战后</strong>. 这一句所包含的信息量很大, 作者可以质疑很多方面, 比如, 作者可以质疑投资是否真的能刺激经济发展, 也可以质疑这种发展能否持续到战后. 所以文章的方向目前为止还不甚明朗, 需要继续阅读.</p><p>接下来出现了 but, 表示作者开始了自己的质疑. 作者指出, 这些受益的工厂有很多都是特殊的工厂, 不适合于战后的情形. 至此, 作者的态度已经比较明朗, 就是在质疑经济的发展能否持续到战后的问题. 目前为止文章的内容框架已经可以概括为:</p><blockquote><p>很多学者认为, 二战期间, 政府对美国南方在工业方面的投资刺激了经济的发展, 并持续到了战后. 但由于这些工厂的特殊性, 这种经济的发展不能持续到战后.</p></blockquote><h3 id="后文展开">后文展开</h3><p>接下来的 Large-scale... 一句, 行文的方向显然没有发生变化, 于是这句话不会与作者的观点产生冲突, 也不会产生新的信息. 本句谈到的信息为政府把钱投资给了军工厂, 那么这个信息一定是旧信息, 那么前文提到的&quot;特殊的&quot;工厂指的也就应该是军工厂了. 下一句 By the war's end... 也是在谈政府为军工厂投资的事情, 仍然没有新信息出现.</p><p>随后是 Indeed 引导的句子, 可知该句话中行文的方向不发生变化, 于是其内容仍然不会脱离框架所的涉指范围. 结合语义, 可知本句仍在谈论投资对象的问题.</p><h3 id="第二段">第二段</h3><p>在第二段的开头提到了北方的情况(可以出题考为什么在此处提到北方的情况), 指出这些战后的军工厂在北方同样难以处理. 那么作者为什么要在此处提及北方的情况呢? 显然南方才是全文的重点, 整个文章都应该是围绕着南方展开的. 所以显然这个北方的情况也是服务于南方的, 实际上是在表明 &quot;连北方的都难以处理, 更不用说南方的情况了, 一定更糟糕&quot;. 所以此处提及北方的情况, 实际上仍然是在为作者自己得观点所服务.</p><p>接下来讨论回到了南方, 指出几乎没有人愿意处理南方的军工厂, 仍然在强调战后军工厂的副作用. 接下来的 Accordingly... 一句, 更是直接指出了, 在战后, 几乎所有的军工厂都废掉了.</p><p>在下文出现了 although 一词, 显然是一个让步. 故前半句应该是一个小小的妥协, 后半句仍然回到自己的观点. 故此处在读句子之前就完全可以猜出这句话的意思是&quot;尽管有些军工厂还没有废掉, 但是它们也废掉了&quot;. 至此, 整篇文章的内容已经结束.</p><h3 id="整体结构">整体结构</h3><p>文章比较长, 但最核心的其实只有两句话:</p><blockquote><p>Many scholars have argued that government investment in manufacturing in the southern United States during the Second World War spurred a regional economic boom that lasted into the postwar period. But much of this investment went to specialized plants, many of them unsuitable for postwar production. 许多学者认为经济发展能够持续至战后, 但是并不能.</p></blockquote><h2 id="问题分析">问题分析</h2><h3 id="问题一">问题一</h3><p>文章的问题是针对 Indeed, according to one estimate, more than 70 percent of federally financed manufacturing construction capital in Alabama, Arkansas, Mississippi, and Tennessee went into munitions plants 一句提出的, 该句是对上文观点的展开, 故功能应该是支持前文的观点.</p><p>事实上, 原题目如下:</p><blockquote><p>In the passage, the mention of “Alabama, Arkansas, Mississippi, and Tennessee” serves primarily to<br>　　A. suggest that some states were better than others at anticipating postwar economic needs<br>　　B. identify evidence used to support a view held by scholars mentioned at the beginning of the passage<br>　　C. suggest that federal investment in some kinds of manufacturing was excessive<br>　　D. identify the states that received the largest allocations of federal funds<br>　　<strong>E</strong>. provide information to support a point about the nature of government investment made earlier in the paragraph</p></blockquote><p>根据以上分析, 本题应选择 E.</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
            <tag> GRE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GRE阅读题目分析[1]</title>
      <link href="/2017/07/16/GRE%E9%98%85%E8%AF%BB%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%5B1%5D/"/>
      <content type="html"><![CDATA[<p>GRE 阅读的一点小小的总结.</p><a id="more"></a><h2 id="文章内容">文章内容</h2><blockquote><p>In 1755 British writer Samuel Johnson published an acerbic letter to Lord Chesterfield rebuking his patron for neglecting and declining further support. Johnson’s rejection of his patron’s belated assistance has often been identified as a key moment in the history of publishing, marking the end of the culture of patronage. However, <strong>patronage had been in decline for 50 years, yet would survive, in attenuated form, for another 50</strong>. Indeed, Johnson was in 1762 awarded a pension by the Crown — a subtle form of sponsorship, tantamount to state patronage. The importance of Johnson’s letter is not so much historical as emotional; it would become a touchstone for all who repudiated patrons and for all who embraced the laws of the marketplace.</p></blockquote><h2 id="结构分析">结构分析</h2><h3 id="文章开头">文章开头</h3><p>文章前两句指出, 有观点认为: &quot;SJ 喷 LC 的事件标志着 patronage 的结束&quot;. 随后文中出现 However, 由于前文是引用观点, 故 However 可能起到质疑的作用, 于是本句的核心方向应该是 &quot;partonage 并没有结束&quot;. 后文中又出现了一个 yet, 表明该句中存在让步, 于是前半句应是对于引用观点的妥协, 结合语义, 可理解为 &quot;partonage 虽然在变弱&quot;. 后半句显然与引用观点意思相反, 应为 &quot;partonage 还没有结束&quot;.</p><p>到这里, 文章已经抛出了一个观点, 文章的大概走势是:</p><blockquote><p>有人认为 SJ 喷 LC 的事件标志着 patronage 的结束, 但实际上, 尽管 patronage 削弱了, 却没有结束.</p></blockquote><p>按照常理, 下文应该对作者自己的观点进行展开.</p><h3 id="后文展开">后文展开</h3><p>下文首先出现的是 indeed, 考虑语义, indeed 意为&quot;确实&quot;, 不改变文章的观点方向, 故下文的意思仍应该是&quot;partonage 没有结束&quot;, 结合 &quot;tantamount to state patronage&quot;, 可知该句确实表明了类似的意思. 最后一句仍然是作者自己观点的展开, &quot;not so much ... as ...&quot; 指出 SJ 喷 LC 的事件, 在 emotional 方面的重要性要大于 historical 方面的重要性, 实际上也是在说这件事不能标志着 patronage 的结束.</p><h3 id="整体结构">整体结构</h3><p>总体看来, 这篇文章的核心意思就是上文提到的走势, 而核心的两句话就是:</p><blockquote><p>Johnson’s rejection of his patron’s belated assistance has often been identified as a key moment in the history of publishing, marking the end of the culture of patronage. However, patronage had been in decline for 50 years, yet would survive, in attenuated form, for another 50. 许多人认为 SJ 喷 LC 标志着 patronage 的结束, 但实际上并没有.</p></blockquote><h2 id="问题分析">问题分析</h2><h3 id="问题一">问题一</h3><p>首先从加粗句出发考虑, 涉及到的就是 however 的功能. 由以上的分析, 该句的功能为质疑前文的引用观点, 故可以如下设计正确选项:</p><ol style="list-style-type: decimal"><li>Present a view that chanllenges a understanding of Johnson’s rejection of his patron’s belated assistance.</li><li>Outline an opposing interpretation of Johnson’s rejection of his patron’s belated assistance.</li><li>Qualify the declaration that Johnson’s rejection was the end of patronage.</li><li>......</li></ol><p>事实上, 原题目如下:</p><blockquote><p>Which of the following best describes the function of the highlighted sentence in the context of the passage as a whole?<br>　　A. It points out the <del> most obvious</del> implications of Johnson’s letter to his patron<br>　　B. It suggests a <del>motivation</del> for Johnson’s rejection of Chesterfield’s patronage<br>　　<strong>C</strong>. It provides information that qualifies the assertion that Johnson’s letter sharply defined the end of a publishing era<br>　　D. It provides a possible <del>defense</del> for Chesterfield’s alleged neglect of Johnson<br>　　E. It refutes the notion that <del>patrons are found primarily among the nobility</del></p></blockquote><p>根据以上分析, 本题应选择 C.</p><h3 id="问题二">问题二</h3><p>文章的另一道题目是针对 1762 的事件 (Indeed, Johnson was in 1762 awarded a pension by the Crown — a subtle form of sponsorship, tantamount to state patronage) 提出的.</p><p>这句话是对作者自己观点的展开, 所以从功能上来就是对自己观点的加强, 很容易设计出如下的正确选项:</p><ul><li>Support that Johnson’s rejection was not the end of patronage.</li></ul><p>原题目如下:</p><blockquote><p>The author of the passage mentions Johnson’s 1762 pension award in order to<br>　　A：Reveal that Johnson remained consistent in his rebuke of Lord Chesterfield well after 1755<br>　　B：Provide evidence for a general trend in the later half of the eighteenth century of private patronage’s being replaced by state sponsorship<br>　　C：Situated the debate over the end of patronage within the wider realm of eighteenth-century economic history<br>　　D：Suggest that Johnson’s letter to Chesterfield was noticed by the crown only years after it was published<br>　　<strong>E</strong>：Emphasize that patronage still helped support Johnson’s writing after his letter to chesterfield</p></blockquote><p>根据以上分析, 本题最合适的选项应为 E 选项. 值得注意的是 C 选项中 debate 一词的使用. Debate 的存在必然是有两派对立的引用观点, 否则不足以构成 debate. 注意作者观点与引用观点的对立并不算做 debate, 因为从作者的角度出发, 自己的观点一定是正确的, 不存在争论的必要.</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
            <tag> GRE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2015年数学分析期末考试试卷</title>
      <link href="/2017/07/04/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62015%E5%B9%B4%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7/"/>
      <content type="html"><![CDATA[<h2 id="试题">试题</h2><h3 id="计算题">计算题</h3><p>共40分, 每题5分.</p><ol style="list-style-type: decimal"><li><p>求极限 <span class="math inline">\(\lim\limits_{n\to\infty}\sqrt{n}(\sqrt{n+1}-\sqrt{n})\)</span>;</p></li><li><p>求极限 <span class="math inline">\(\lim\limits_{x\to\infty}\sqrt{(a+x)(b+x)}-\sqrt{(a-x)(b-x)}\)</span>;</p></li><li><p>求不定积分 <span class="math inline">\(\int e^{\sqrt{x}}dx\)</span>;</p></li><li><p>求不定积分 <span class="math inline">\(\int \frac{1}{1+x^4}dx\)</span>;</p></li><li><p>求广义积分 <span class="math inline">\(\int\nolimits_0^1 lnxdx\)</span>;</p></li><li><p>求广义积分 <span class="math inline">\(\int\nolimits_0^{+\infty}\frac{dx}{1+x^3}\)</span>;</p></li><li><p>求二重积分 <span class="math inline">\(\iint\nolimits_D [x+y]dxdy\)</span>, 其中 <span class="math inline">\(D=[0,2]\times[0,2]\)</span>, <span class="math inline">\([x+y]\)</span> 是取整函数;</p></li><li><p>设二阶偏导数连续的二元函数 <span class="math inline">\(z=f(x,y)\)</span> 满足方程 <span class="math display">\[\frac{\partial^2 f}{\partial x^2}(x,y)-\frac{\partial^2 f}{\partial y^2}(x,y)=0\]</span> 且 <span class="math inline">\(f(x,2x)=x\)</span>, <span class="math inline">\(\frac{\partial f}{\partial x}(x,y)\)</span> 当 <span class="math inline">\(y=2x\)</span> 时等于 <span class="math inline">\(x^2\)</span>. 求 <span class="math inline">\(\frac{\partial^2 f}{\partial x^2}(x,y)\)</span> 当 <span class="math inline">\(y=2x\)</span> 时的值.</p></li></ol><h3 id="证明题">证明题</h3><p>共60分, 每题10分.</p><ol style="list-style-type: decimal"><li><p>求证数列 <span class="math inline">\(x_n=(-1)^n\)</span> 当 <span class="math inline">\(n\to\infty\)</span> 时发散;</p></li><li><p>设 <span class="math inline">\(f,g\)</span> 在闭区间 <span class="math inline">\([a,b]\)</span> 连续, 证明 <span class="math display">\[\int\nolimits_a^b f(x)g(x)dx\leqslant\frac{1}{2}\left[\int\nolimits_a^bf^2(x)dx+\int\nolimits_a^bg^2(x)dx\right];\]</span></p></li><li><p>设广义积分 <span class="math inline">\(\int\nolimits_0^{+\infty}\frac{\sin^2 x}{x^2}dx\)</span> 和 <span class="math inline">\(\int\nolimits_0^{+\infty}\frac{\sin x}{x}dx\)</span> 都收敛, 证明: <span class="math display">\[\int\nolimits_0^{+\infty}\frac{\sin^2 x}{x^2}dx=\int\nolimits_0^{+\infty}\frac{\sin x}{x}dx;\]</span></p></li><li><p>设 <span class="math display">\[f(x,y)=\begin{cases} \frac{xy}{x^2+y^2}, &amp; (x,y)\neq(0,0), \\ 0, &amp; (x,y)=(0,0). \\ \end{cases}\]</span></p></li><li><p>设函数 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\(x=0\)</span> 连续, 且 <span class="math inline">\(\lim\limits_{x\to\infty}\frac{f(2x)-f(x)}{x}=a\)</span>. 求证: <span class="math inline">\(f&#39;(0)\)</span> 存在, 且 <span class="math inline">\(f&#39;(0)=a\)</span>.</p></li><li><p>设 <span class="math display">\[P_n(x)=\frac{1}{n!2^n}\frac{d^n}{dx^n}(x^2-1)^n,\]</span> 证明: <span class="math display">\[\int\nolimits_{-1}^1 P_n(x)P_m(x)dx = \begin{cases} 0, &amp; m\neq n,\\ \frac{2}{2n+1}, &amp; m=n. \\ \end{cases}\]</span></p></li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 数学分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2016年高等代数期中考试试卷</title>
      <link href="/2017/07/04/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62016%E5%B9%B4%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0%E6%9C%9F%E4%B8%AD%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7/"/>
      <content type="html"><![CDATA[<h2 id="试题">试题</h2><p>以下各题中, 所指的向量空间都是有限的.</p><ol style="list-style-type: decimal"><li><p>假设域 <span class="math inline">\(F\)</span> 上的2维向量空间 <span class="math inline">\(V\)</span> 有一组基 <span class="math inline">\(v_1,v_2\)</span>. 设 <span class="math inline">\(\sigma:V\rightarrow V\)</span> 是一个线性变换, 且满足 <span class="math inline">\(\sigma(v_1)=0\)</span>, <span class="math inline">\(\sigma(v_2)=v_1\)</span>. 证明: 如果 <span class="math inline">\(W\)</span> 是 <span class="math inline">\(V\)</span> 的一个 <span class="math inline">\(\sigma\)</span>-不变子空间, 则或者 <span class="math inline">\(W=0\)</span>, 或者 <span class="math inline">\(W\)</span> 是由 <span class="math inline">\(v_1\)</span> 生成的1维子空间, 或者 <span class="math inline">\(W=V\)</span>.</p></li><li><p>设 <span class="math inline">\(V\)</span> 是域 <span class="math inline">\(F\)</span> 上的向量空间, <span class="math inline">\(W\)</span> 是 <span class="math inline">\(V\)</span> 的一个子空间. 证明: 存在 <span class="math inline">\(V\)</span> 的子空间 <span class="math inline">\(W&#39;\)</span>, s.t. <span class="math inline">\(V=W\oplus W&#39;\)</span>.</p></li><li><p>判断下列域 <span class="math inline">\(F\)</span> 上的 <span class="math inline">\(n\)</span> 阶方阵 <span class="math inline">\(A\)</span> 能否对角化, 并说明理由.</p><ol style="list-style-type: decimal"><li><p><span class="math inline">\(A\)</span> 满足 <span class="math inline">\(A\neq 0\)</span>, <span class="math inline">\(A^2=0\)</span>.</p></li><li><p><span class="math inline">\(A\)</span> 满足 <span class="math inline">\(A^2=A\)</span>.</p></li></ol></li><li><p>设 <span class="math inline">\(\sigma:V\rightarrow V&#39;\)</span> 是一个线性映射. 证明 <span class="math inline">\(\sigma\)</span> 诱导出向量空间的同构 <span class="math display">\[\overline{\sigma}:V/\ker\sigma \xrightarrow{\sim} {\rm Im}\sigma,\quad v+\ker\sigma\mapsto\sigma(v).\]</span></p></li><li><p>试用向量组的线性相关性理论证明线性方程组有解的判别准则.</p></li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2016年数学分析期中考试试卷</title>
      <link href="/2017/07/04/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62016%E5%B9%B4%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E6%9C%9F%E4%B8%AD%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7/"/>
      <content type="html"><![CDATA[<h2 id="试题">试题</h2><h3 id="计算题">计算题</h3><p>共50分, 前4题每题5分, 后3题每题10分.</p><ol style="list-style-type: decimal"><li><p><span class="math inline">\(\lim\limits_{(x,y)\to(0,0)}\frac{\sin(xy)}{xy}\)</span>.</p></li><li><p><span class="math inline">\(\lim\limits_{(x,y)\to(0,0)}(x+y)\sin\frac{1}{x^2+y^2}\)</span>.</p></li><li><p><span class="math inline">\(\lim\limits_{x\to\infty}\lim\limits_{y\to\infty}\frac{xy}{x+y}\)</span>.</p></li><li><p><span class="math inline">\(\lim\limits_{(x,y)\to(+\infty,+\infty)}\left(\frac{xy}{x^2+y^2}\right)^{x^2}\)</span>.</p></li><li><p>设 <span class="math inline">\(f(x,y)=(x+y,x-y,xy)\in\mathbb{R}^3\)</span>, <span class="math inline">\(g(x,y,z)=(xyz,ze^{xy})\in\mathbb{R}^2\)</span>. 记 <span class="math inline">\(F=f\circ g\)</span>, 求 <span class="math inline">\(F\)</span> 的Frechet导数 <span class="math inline">\(F&#39;(x,y,z)\)</span>.</p></li><li><p>求 <span class="math inline">\(f(x,y)=x^3+y^3-3xy\)</span> 的普通极值.</p></li><li><p>设方程 <span class="math inline">\(y-\frac{1}{2}\sin y=x\)</span> 能确定隐函数 <span class="math inline">\(y=f(x)\)</span>, 令 <span class="math inline">\(z=e^{x+y}\)</span>, 求 <span class="math inline">\(\frac{dz}{dx}\)</span>, <span class="math inline">\(\frac{d^2z}{dx^2}\)</span>.</p></li></ol><h3 id="证明题">证明题</h3><p>共50分, 每题10分.</p><ol style="list-style-type: decimal"><li><p>证明: <span class="math inline">\(f(x,y)=\frac{xy}{x+y}\)</span> 在 <span class="math inline">\((x,y)=(0,0)\)</span> 处极限不存在.</p></li><li><p>设数值函数 <span class="math inline">\(f(x)\)</span> 在紧集 <span class="math inline">\(D\subset\mathbb{R}^n\)</span> 上连续, 且恒为正值, 求证: <span class="math inline">\(\exists~K&gt;0\)</span>, s.t. <span class="math inline">\(\forall~x\in D\)</span>, 有 <span class="math inline">\(f(x)&gt;K\)</span>.</p></li><li><p>证明: <span class="math display">\[f(x,y)=\begin{cases}\frac{xy}{\sqrt{x^2+y^2}}, &amp; (x,y)\neq(0,0) \\ 0, &amp; (x,y)=(0,0) \\ \end{cases}\]</span> 在 <span class="math inline">\((0,0)\)</span> 的邻域中连续且有有界的偏导数 <span class="math inline">\(f_x&#39;(x,y)\)</span> 和 <span class="math inline">\(f&#39;_y(x,y)\)</span>, 但函数在点 <span class="math inline">\((0,0)\)</span> 不可微 .</p></li><li><p>设 <span class="math inline">\(f:\mathbf{R}^n\rightarrow\mathbf{R}^n\)</span> 是开集 <span class="math inline">\(G\)</span> 上的 <span class="math inline">\(C^1\)</span> 类函数, 且 <span class="math inline">\(J_f(x_0)=0\)</span>, 记 <span class="math inline">\(y_0=f(x_0)\)</span>. 如果 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(x_0\)</span> 存在反函数 <span class="math inline">\(f^{-1}\)</span>, 求证 <span class="math inline">\(f^{-1}\)</span> 在 <span class="math inline">\(y_0\)</span> 不可微.</p></li><li><p>证明: 由方程 <span class="math display">\[y=x\varphi(x)+\psi(z)\]</span> 所定义的隐函数 <span class="math inline">\(z=z(x,y)\)</span> 满足方程 <span class="math display">\[\left(\frac{\partial z}{\partial y}\right)^2\frac{\partial^2 z}{\partial x^2}-2\frac{\partial z}{\partial x}\frac{\partial z}{\partial y}\frac{\partial^2 z}{\partial x\partial y}+\left(\frac{\partial z}{\partial x}\right)^2\frac{\partial^2 z}{\partial y^2}=0.\]</span></p></li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 数学分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2016年数学分析期末考试试卷</title>
      <link href="/2017/07/03/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62016%E5%B9%B4%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7/"/>
      <content type="html"><![CDATA[<h2 id="试题">试题</h2><h3 id="计算题">计算题</h3><p>共20分, 前四题每题5分, 后3题每题10分.</p><ol style="list-style-type: decimal"><li><p>计算二重积分 <span class="math inline">\(\iint\limits_E xydxdy\)</span>, 其中 <span class="math inline">\(E\)</span> 是四条抛物线 <span class="math display">\[y^2=px,~y^2=qx,~x^2=ay,~x^2=by\]</span> 所围成的区域, <span class="math inline">\(0&lt;p&lt;q\)</span>, <span class="math inline">\(0&lt;a&lt;b\)</span>.</p></li><li><p>计算三重积分 <span class="math inline">\(\iiint\limits_Vxyzdxdydz\)</span>, 其中 <span class="math inline">\(V\)</span> 是由曲面 <span class="math display">\[x^2+y^2+z^2=1,x\geqslant,y\geqslant0,z\geqslant0\]</span> 所围成的区域.</p></li><li><p>计算第一型曲线积分 <span class="math inline">\(\int\nolimits_C(x^2+y^2)ds\)</span>, 其中 <span class="math inline">\(C\)</span> 为曲线 <span class="math display">\[x=a(\cos t+t\sin t),y=a(\sin t-t\cos t)~(0\leqslant t \leqslant 2\pi).\]</span></p></li><li><p>计算第一型曲面积分 <span class="math inline">\(\iint\limits_S(x+y+z)dS\)</span>, 其中 <span class="math inline">\(S\)</span> 为曲面 <span class="math inline">\(x^2+y^2+z^2=a^2\)</span>, <span class="math inline">\(z\geqslant0\)</span>.</p></li><li><p>设 <span class="math inline">\(\sin z-xyz=0\)</span>, 当 <span class="math inline">\(\cos z-xy\neq0\)</span> 时, 求 <span class="math inline">\(\frac{\partial z}{\partial x}\)</span>, <span class="math inline">\(\frac{\partial^2 z}{\partial y\partial x}\)</span>.</p></li><li><p>求函数 <span class="math inline">\(f(x,y,z)=x-2y+2z\)</span> 在球面 <span class="math inline">\(x^2+y^2+z^2=1\)</span> 上的最大、最小值.</p></li><li><p>计算第二型曲线积分 <span class="math inline">\(\oint\nolimits_C e^x[(1-\cos y)dx-(y-\sin y)dy]\)</span>, 其中 <span class="math inline">\(C\)</span> 是曲线 <span class="math inline">\(y=\sin x\)</span> 介于 <span class="math inline">\([0,1]\)</span> 的一段, <span class="math inline">\(C\)</span> 的方向对应于 <span class="math inline">\(x\)</span> 增加的方向.</p></li></ol><h3 id="证明题">证明题</h3><p>共50分, 每题10分.</p><ol style="list-style-type: decimal"><li><p>设二元数值函数 <span class="math inline">\(f(x,y)\)</span> 在 <span class="math inline">\([a,b]\times[c,d]\)</span> 上连续, 一元数值函数序列 <span class="math inline">\(\{\phi_n(x)\}\)</span> 在 <span class="math inline">\([a,b]\)</span> 上一致收敛, 且 <span class="math inline">\(\phi_n(x)\in [c,d]\)</span>. 则 <span class="math inline">\(g_n=f(x,\phi_n(x))\)</span> 在 <span class="math inline">\([a,b]\)</span> 上一致收敛.</p></li><li><p>设数值函数 <span class="math inline">\(z=f(x,y)\)</span> 在矩形区域 <span class="math inline">\(D=[a,b]\times[c,d]\subset\mathbb{R}^2\)</span> 上偏导数有界, 求证: <span class="math inline">\(f\)</span> 在 <span class="math inline">\(D\)</span> 上一致连续.</p></li><li><p>设三重积分 <span class="math inline">\(\iiint\limits_D f(x,y,z)dxdydz\)</span> 存在, 区域 <span class="math inline">\(D\)</span> 关于 <span class="math inline">\(xOy\)</span> 平面对称, 被积函数 <span class="math inline">\(f\)</span> 关于 <span class="math inline">\(x\)</span> 是一个奇函数, 即 <span class="math inline">\(f(-x,y,z)=-f(x,y,z)\)</span>, 求证: <span class="math inline">\(\iiint\limits_D f(x,y,z)dxdydz=0\)</span>.</p></li><li><p>设 <span class="math inline">\(f\in C[0,a]\)</span>, 即 <span class="math inline">\(f\)</span> 在区间 <span class="math inline">\([0,1]\)</span> 上连续, 证明: <span class="math display">\[\int\nolimits_0^a dx_1\int\nolimits_0^{x_1}dx_2\cdots\int_0^{x_{n-1}} f(x_1)f(x_2)\cdots f(x_n)dx_n=\frac{1}{n!}\left[\int\nolimits_0^a f(x)dx\right]^n.\]</span></p></li><li><ol style="list-style-type: lower-roman"><li>设 <span class="math inline">\(S\)</span> 为 <span class="math inline">\(\mathbb{R}^3\)</span> 空间中分片光滑的封闭定向曲面, <span class="math inline">\(\nu_0\)</span> 为任意固定的方向, <span class="math inline">\(N\)</span> 为 <span class="math inline">\(S\)</span> 的单位外法向量, 求证 <span class="math display">\[\iint\limits_S \cos(\nu_0, N)dS=0.\]</span></li><li>证明Lebesgue引理: 设 <span class="math inline">\(\mathbb{R}^n\)</span> 中的紧集 <span class="math inline">\(D\)</span> 有一个开覆盖 <span class="math inline">\(\mathfrak{C}=\{G_\alpha\}\)</span>, 则存在正数 <span class="math inline">\(l&gt;0\)</span>, 对于 <span class="math inline">\(\forall~x\in D\)</span>, <span class="math inline">\(\exists~G_\alpha\in\mathfrak{C}\)</span>, s.t. <span class="math inline">\(x\)</span> 的球(方)邻域 <span class="math inline">\(U(x,l)\subset G_\alpha\)</span>.</li></ol></li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 数学分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2016年近世代数期末考试试卷</title>
      <link href="/2017/07/03/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62016%E5%B9%B4%E8%BF%91%E4%B8%96%E4%BB%A3%E6%95%B0%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7/"/>
      <content type="html"><![CDATA[<h2 id="试题">试题</h2><ol style="list-style-type: decimal"><li>(20分) 整数集 <span class="math inline">\(\mathbb{Z}\)</span> 关于普通加法构成有理数集 <span class="math inline">\(\mathbb{Q}\)</span> 的子群. 任取 <span class="math inline">\(q\in\mathbb{Q}\)</span>, 用 <span class="math inline">\([q]=q+\mathbb{Z}\)</span> 表示商群 <span class="math inline">\(\mathbb{Q}/\mathbb{Z}\)</span> 中对应的元素.<ol style="list-style-type: decimal"><li>写出商群 <span class="math inline">\(\mathbb{Q}/\mathbb{Z}\)</span> 的单位元.</li><li>求元素 <span class="math inline">\([\frac{9}{4}]\)</span> 在群 <span class="math inline">\(\mathbb{Q}/\mathbb{Z}\)</span> 的阶.</li><li>证明: 群 <span class="math inline">\(\mathbb{Q}/\mathbb{Z}\)</span> 中每个元素的阶都有限.</li><li><span class="math inline">\(\mathbb{Q}/\mathbb{Z}\)</span> 是不是循环群? 为什么?</li></ol></li><li>(15分) 下列三个群互相同构吗? 说明理由. 其中, <span class="math inline">\(A_4\)</span> 代表4次交错群, <span class="math inline">\(\mathbb{Z}_{12}\)</span> 代表模12的剩余类加群, 等等.<ol style="list-style-type: decimal"><li><span class="math inline">\(\mathbb{Z}_{12}\)</span>.</li><li><span class="math inline">\(\mathbb{Z}_3\times\mathbb{Z}_4\)</span>. (群的外直积)</li><li><span class="math inline">\(A_4\)</span>.</li></ol></li><li><p>(10分) 设 <span class="math inline">\(G\)</span> 是一个群, 任取 <span class="math inline">\(x\in G\)</span>, 称 <span class="math inline">\(C_x=\{gxg^{-1}|g\in G\}\)</span> 为元素 <span class="math inline">\(x\)</span> 所在的共轭类. 每个共轭类 <span class="math inline">\(C_x\)</span> 中所含元素的个数一定整除群的阶 <span class="math inline">\(|G|\)</span>, 为什么?</p></li><li>(20分) 令 <span class="math inline">\(\mathbb{Z}[i]=\{a+bi|a,b\in\mathbb{Z}\}\)</span> 代表高斯整环. 在 <span class="math inline">\(\mathbb{Z}[i]\)</span> 中定义范数如下: <span class="math display">\[N(a+bi)=a^2+b^2.\]</span><ol style="list-style-type: decimal"><li>求出 <span class="math inline">\(\mathbb{Z}[i]\)</span> 中的所有单位 (即乘法可逆元).</li><li>求出 <span class="math inline">\(\mathbb{Z}[i]\)</span> 的商域.</li><li>素数2是 <span class="math inline">\(\mathbb{Z}[i]\)</span> 中的逆元吗? 为什么?</li><li>有人说, <span class="math inline">\(\mathbb{Z}[i]\)</span> 中的非零素理想也是极大理想. 你认为对吗? 为什么?</li></ol></li><li>(10分) 设 <span class="math inline">\(E=\mathbb{Q}(\sqrt{2},i)\)</span> 是有理数域 <span class="math inline">\(\mathbb{Q}\)</span> 的扩域.<ol style="list-style-type: decimal"><li>求扩域的次数 <span class="math inline">\([E:\mathbb{Q}]\)</span>.</li><li>证明: <span class="math inline">\(E=\mathbb{Q}(\sqrt{2}+i)\)</span>.</li></ol></li><li>(20分) 考虑有限域 <span class="math inline">\(\mathbb{Z}_3\)</span> 上的不可约多项式 <span class="math inline">\(p(x)=x^2+x-1\)</span>.<ol style="list-style-type: decimal"><li>设 <span class="math inline">\(\alpha\)</span> 是 <span class="math inline">\(p(x)\)</span> 在它的分裂域中的一个根. 单扩域 <span class="math inline">\(\mathbb{Z}_3(\alpha)\)</span> 是 <span class="math inline">\(\mathbb{Z}_3\)</span> 上的几次扩域?</li><li>写出 <span class="math inline">\(\mathbb{Z}_3(\alpha)\)</span>作为 <span class="math inline">\(\mathbb{Z}_3\)</span> 上的向量空间的一组基.</li><li>用这组基表达 <span class="math inline">\(\alpha\)</span> 和 <span class="math inline">\(1+\alpha\)</span> 在 <span class="math inline">\(\mathbb{Z}_3(\alpha)\)</span> 中的逆元.</li><li>证明: <span class="math inline">\(p(x)\)</span> 整除 <span class="math inline">\(x^9-x\)</span> (在 <span class="math inline">\(\mathbb{Z}_3[x]\)</span> 中).</li></ol></li><li><p>(5分) 考虑81元域 <span class="math inline">\(F\)</span> 的非零元乘法群 <span class="math inline">\(F^\times\)</span>. 设 <span class="math inline">\(\alpha\)</span> 是 <span class="math inline">\(F^\times\)</span> 的生成元. 证明: <span class="math inline">\(\alpha^{40}=-1\)</span>.</p></li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 抽象代数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2016年近世代数期中考试试卷</title>
      <link href="/2017/07/03/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62016%E5%B9%B4%E8%BF%91%E4%B8%96%E4%BB%A3%E6%95%B0%E6%9C%9F%E4%B8%AD%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7/"/>
      <content type="html"><![CDATA[<h2 id="试题">试题</h2><ol style="list-style-type: decimal"><li><p>(10分) 用 <span class="math inline">\(S_4\)</span> 代表4次对称群. 按共轭类写出 <span class="math inline">\(S_4\)</span> 的全部元素.</p></li><li>(10分)<ol style="list-style-type: decimal"><li>循环群 <span class="math inline">\(\mathbb{Z}_{28}\)</span> 中的7阶元有几个?</li><li><span class="math inline">\(\mathbb{Z}_{28}\)</span> 有几个7阶子群?</li></ol></li><li>(15分) 令 <span class="math inline">\(\varphi:(\mathbb{R},+)\longrightarrow (\mathbb{C}^\times,\cdot)\)</span> 是由 <span class="math inline">\(\varphi(x)=e^{ix}\)</span> 定义的函数, 其中 <span class="math inline">\((\mathbb{R},+)\)</span> 和 <span class="math inline">\((\mathbb{C}^\times,+)\)</span> 分别代表实数的加法群和非零复数的乘法群.<ol style="list-style-type: decimal"><li>证明: <span class="math inline">\(\varphi\)</span> 是一个群同态.</li><li>求 <span class="math inline">\(\ker\varphi\)</span> 和 <span class="math inline">\({\rm Im}~\varphi\)</span>.</li><li>根据同态基本定理, 你能得到什么结论?</li></ol></li><li><p>(15分) 应用群作用证明: 8阶群的中心至少有两个元素.</p></li><li>(10分) 求下列环中的(乘法)可逆元:<ol style="list-style-type: decimal"><li>模8的剩余类环 <span class="math inline">\(\mathbb{Z}/8\mathbb{Z}\)</span>.</li><li>高斯整环 <span class="math inline">\(\mathbb{Z}[i]\)</span>.</li></ol></li><li>(20分)<ol style="list-style-type: decimal"><li><span class="math inline">\(\mathbb{Z}_{10}\)</span> 与 <span class="math inline">\(\mathbb{Z}_2\times\mathbb{Z}_5\)</span> 作为环同构吗? 为什么?</li><li><span class="math inline">\(\mathbb{Z}_9\)</span> 与 <span class="math inline">\(\mathbb{Z}_3\times\mathbb{Z}_3\)</span> 作为环同构吗? 为什么?</li></ol></li><li>(20分)<ol style="list-style-type: decimal"><li>利用环的同态基本定理证明: <span class="math inline">\(\mathbb{Z}[x]/\langle x^2+1\rangle\cong\mathbb{Z}[i]\)</span>.</li><li><span class="math inline">\(\langle x^2+1 \rangle\)</span> 是 <span class="math inline">\(\mathbb{Z}[i]\)</span> 的素理想吗? 是极大理想吗?</li></ol></li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 抽象代数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2017年实变函数期末考试试卷</title>
      <link href="/2017/07/02/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62017%E5%B9%B4%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7/"/>
      <content type="html"><![CDATA[<h2 id="试题">试题</h2><ol style="list-style-type: decimal"><li><p>(15分) 设 <span class="math inline">\(\{E_k\}\)</span> 是 <span class="math inline">\([0,1]\)</span> 中的可测集列, <span class="math inline">\(m(E_k)=1~(k=1,2,\cdots)\)</span>, 试证明 <span class="math display">\[m\left(\bigcap_{k=1}^\infty E_k\right)=1.\]</span></p></li><li><p>(15分) 试证明点集 <span class="math inline">\(E\)</span> 可测的充分必要条件是: 对于任给的 <span class="math inline">\(\epsilon&gt;0\)</span>, 存在开集 <span class="math inline">\(G_1,G_2\)</span>: <span class="math display">\[G_1\supset E,\quad G_2\supset E^C\]</span> 使得 <span class="math inline">\(m(G_1\cap G_2)&lt;\epsilon\)</span>.</p></li><li><p>(15分) 设 <span class="math inline">\(E\subset \mathbb{R}\)</span> 上可测函数列 <span class="math inline">\(\{f_k(x)\}\)</span> 满足 <span class="math display">\[f_k(x)\geqslant f_{k+1}(x),(k=1,2,\cdots).\]</span> 若 <span class="math inline">\(f_k\)</span> 在 <span class="math inline">\(E\)</span> 上依测度收敛到0, 试问 <span class="math inline">\(f_k\)</span> 在 <span class="math inline">\(E\)</span> 上是否几乎处处收敛到0.</p></li><li><p>(15分) 设 <span class="math inline">\(f(x)\)</span> 是 <span class="math inline">\((0,1)\)</span> 上的非负可测函数, 若存在 <span class="math inline">\(c\)</span> 使得 <span class="math display">\[\int\nolimits_{[0,1]}[f(x)]^ndx=c,(n=1,2,\cdots)\]</span> 试证明存在非负可测集 <span class="math inline">\(E\subset(0,1)\)</span>, s.t. <span class="math inline">\(f(x)=\chi_E(x)\)</span>, a.e. 若 <span class="math inline">\(f(x)\)</span> 不是非负的, 结论又如何?</p></li><li><p>(15分) 设 <span class="math inline">\(f\in L(0,a)\)</span>, <span class="math inline">\(g(x)=\int\nolimits_x^a \frac{f(t)}{t}dt\)</span>, <span class="math inline">\(a&gt;x&gt;0\)</span>. 试证明 <span class="math inline">\(g\in L(0,a)\)</span>, 且有 <span class="math display">\[\int\nolimits_0^a g(x)dx=\int\nolimits_0^a f(x)dx.\]</span></p></li><li><p>(15分) 设 <span class="math inline">\(f\in L^2(0,\infty)\)</span>, 且 <span class="math inline">\(f\geqslant 0\)</span>. 设 <span class="math inline">\(F(x)=\int\nolimits_0^x f(t)dt\)</span>, 试证明 <span class="math display">\[F(x)=o(\sqrt{x})~(x\to0,x\to\infty).\]</span></p></li><li>(10分) 设 <span class="math inline">\(f\in L^1(\mathbb{R}^n)\)</span>, 对 <span class="math inline">\(x\in\mathbb{R}^n\)</span>, 称 <span class="math display">\[\hat{f}(x)=\int\nolimits_{\mathbb{R}^n} f(t)e^{-2\pi x\cdot t}dx\]</span> 为 <span class="math inline">\(f\)</span> 的Fourier变换. 请验证以下几个性质:<ol style="list-style-type: lower-alpha"><li><span class="math inline">\(||\hat{f}||_{L^\infty(\mathbb{R}^n)}\leqslant ||f||_{L^1(\mathbb{R}^n)}\)</span>.</li><li><span class="math inline">\(\hat{f}\)</span> 在 <span class="math inline">\(\mathbb{R}^n\)</span> 上一致连续.</li><li><span class="math inline">\(\lim\limits_{|x|\to\infty}\hat{f}(x)=0\)</span>. (提示: 计算阶梯函数的Fourier变换, 再应用阶梯函数在 <span class="math inline">\(L^1(\mathbb{R}^n)\)</span> 的稠密性).</li></ol></li></ol><p>记号说明: <span class="math inline">\(x,t\in\mathbb{R}^n\)</span>, 那么 <span class="math inline">\(x\cdot t=x_1t_1+x_2t_2+\cdots+x_nt_n\)</span>. 欧拉公式: <span class="math display">\[e^{i\theta}=\cos\theta+i\sin\theta.\]</span></p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 实变函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2017年复变函数期末考试试卷</title>
      <link href="/2017/07/02/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62017%E5%B9%B4%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7/"/>
      <content type="html"><![CDATA[<h2 id="试题">试题</h2><ol style="list-style-type: decimal"><li><p>(15分)叙述函数 <span class="math inline">\(f(z)=u(x,u)+iv(x,y)\)</span> 在一点的(复)可微和解析的定义且讨论函数 <span class="math inline">\(f(z)=x^3y+iy^3x\)</span> 的(复)可微性和解析性(在何处(复)可微和解析).</p></li><li>(25分)将下列函数在指定圆环内展成洛朗级数:<ol style="list-style-type: decimal"><li><span class="math inline">\(\frac{1}{z^2(z^2-9)},\quad 3&lt;|z|&lt;+\infty\)</span>;</li><li><span class="math inline">\(\cos(\frac{1}{z-1}),\quad 1&lt;|z-1|&lt;+\infty\)</span>;</li><li><span class="math inline">\(\frac{f(z)}{z^5}\)</span>, <span class="math inline">\(f(z)\)</span> 为 <span class="math inline">\({\rm Ln}(1-z)\)</span> 在 <span class="math inline">\(|z|&lt;1\)</span> 中满足 <span class="math inline">\(f(0)=0\)</span> 的解析分支.</li></ol></li><li><p>(25分) (1)求函数 <span class="math inline">\(\frac{z^2-4}{z(z^2-1)^2}\)</span> 和 <span class="math inline">\(\frac{1}{z^4\sin z}\)</span> 在复平面 <span class="math inline">\(\mathbb{C}\)</span> (不含 <span class="math inline">\(\infty\)</span> 点)中的孤立奇点, 孤立奇点各属于哪一种类型(极点要指明阶数); (2)求函数 <span class="math inline">\(\frac{1}{\sin z}\)</span>, <span class="math inline">\(\frac{1}{z^2\sin z}\)</span>, <span class="math inline">\(\frac{1}{z^4\sin z}\)</span> 在 <span class="math inline">\(0\)</span> 处的留数.</p></li><li><p>(10分)分式线性映射 <span class="math inline">\(w=T(z)=\frac{z+i}{z-i}\)</span> 将指定区域 <span class="math inline">\(\Omega=\{z:{\rm Re}~z&lt;0,{\rm Im}~z&lt;0\}\)</span> 映射为什么区域? ( <span class="math inline">\(T(\Omega)=~?\)</span> 作草图标明原像区域和像区域, 并说明理由.)</p></li><li><p>(15分)计算积分 <span class="math display">\[(1)~\int\nolimits_{-\infty}^{+\infty}\frac{x^2\cos x}{x^4+1}dx;\quad (2)\int\nolimits_0^{+\infty}\frac{x^\alpha}{4+x^2}dx~~(-1&lt;\alpha&lt;1).\]</span></p></li><li><p>(10分)说明多值函数 <span class="math inline">\((z^2(1+z)^3)^\frac{1}{5}\)</span> 在割去线段 <span class="math inline">\([-1,0]\)</span> 的 <span class="math inline">\(z\)</span> 平面上可以分出五个单值连续分支. 求出在 <span class="math inline">\([-1,0]\)</span> 的上沿取正值的那个单值解析分支 <span class="math inline">\(g_0(z)\)</span> 在 <span class="math inline">\(z=1\)</span> 点处的值和在点 <span class="math inline">\(z=i\)</span> 处的值.</p></li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 复变函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>组合数学复习重点</title>
      <link href="/2017/06/24/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/"/>
      <content type="html"><![CDATA[<h2 id="第二章-抽屉原理">第二章 抽屉原理</h2><p>吧 <span class="math inline">\(n+1\)</span> 个物体放入 <span class="math inline">\(n\)</span> 个抽屉, 则至少存在一个抽屉里面有至少两个物体.</p><h2 id="第三章-排列组合">第三章 排列组合</h2><h3 id="重集的排列">重集的排列</h3><p><span class="math inline">\(k\)</span> 种元素, 个数无限: <span class="math inline">\(r\)</span>-排列数为 <span class="math inline">\(k^r\)</span>. <span class="math inline">\(k\)</span> 种元素, 第 <span class="math inline">\(i\)</span> 种有 <span class="math inline">\(n_i\)</span> 个: 全排列为 <span class="math inline">\(\frac{(n_1+\cdots+n_k)!}{n_1!\cdots n_k!}\)</span>.</p><h3 id="重集的组合">重集的组合</h3><p><span class="math inline">\(x_1+\cdots+x_k=r\)</span> 的非负整数解个数为 <span class="math inline">\(\binom{r+k-1}{r}\)</span>.</p><h2 id="第四章-二项式系数">第四章 二项式系数</h2><h3 id="组合恒等式">组合恒等式</h3><ol style="list-style-type: decimal"><li>(帕斯卡公式): <span class="math inline">\(\binom{\alpha}{k}=\binom{\alpha-1}{k}+\binom{\alpha-1}{k-1}\)</span>;</li><li><span class="math inline">\(\binom{\alpha}{k}\binom{k}{p}=\binom{\alpha}{p}\binom{\alpha-p}{k-p}=\binom{\alpha}{k-p}\binom{\alpha+p-k}{p}\)</span>;</li><li><span class="math inline">\(\binom{\alpha+k}{p+k}\binom{p+k}{k}=\binom{\alpha+k}{k}\binom{\alpha}{p}\)</span>;</li><li><span class="math inline">\(\sum\limits_{k=0}^n\binom{n}{k}=\sum\limits_k\binom{n}{k}=2^n\)</span>;</li><li><span class="math inline">\(\sum\limits_{k=0}^n(-1)^k\binom{\alpha}{k}=(-1)^m\binom{\alpha-1}{m}\)</span>;</li><li><span class="math inline">\(\sum\limits_{k=0}^n\binom{\alpha}{k}\binom{\beta}{n-k}=\binom{\alpha+\beta}{n}\)</span>;</li><li><span class="math inline">\(\sum\limits_{k=0}^n\binom{\alpha+k}{k}\binom{\beta-k}{n-k}=\binom{\alpha+\beta+1}{n}\)</span>.</li></ol><h2 id="第五章-容斥原理">第五章 容斥原理</h2><h3 id="符号说明">符号说明</h3><ul><li><span class="math inline">\(A_i\)</span>: <span class="math inline">\(S\)</span> 中满足性质 <span class="math inline">\(P_i\)</span> 的元素集合;</li><li><span class="math inline">\(N(i)\)</span>: <span class="math inline">\(S\)</span> 中恰好具有 <span class="math inline">\(i\)</span> 个性质的元素集合;</li><li><span class="math inline">\(L(i)\)</span>: <span class="math inline">\(S\)</span> 中至少具有 <span class="math inline">\(i\)</span> 个性质的元素集合;</li><li><span class="math inline">\(W(i)\)</span>: <span class="math inline">\(A_1,\cdots,A_m\)</span> 中所有 <span class="math inline">\(i\)</span> 个交集的元素个数之和.</li></ul><h3 id="容斥原理">容斥原理</h3><ol style="list-style-type: decimal"><li><span class="math inline">\(N(0)=W(0)-W(1)+W(2)-\cdots+(-1)^mW(m)\)</span>;</li><li><span class="math inline">\(L(1)=|S|-N(0)=W(1)-W(2)+W(3)-\cdots+(-1)^{m-1}W(m)\)</span>.</li></ol><h3 id="重集的组合-1">重集的组合</h3><blockquote><p>求方程 <span class="math inline">\(x_1+\cdots+x_n=r\)</span> 带上下界 <span class="math inline">\((a_i\leqslant x_i\leqslant b_i)\)</span> 的整数解个数.</p></blockquote><p><strong>解答</strong>: 先做变换 <span class="math inline">\(y_i=x_i-a_i\)</span>, 则方程变形为 <span class="math inline">\(y_1+\cdots+y_n=r-a_1-\cdots-a_n\)</span>. 记 <span class="math inline">\(y_i\leqslant b_i-a_i\)</span> 为条件 <span class="math inline">\(P_i\)</span>, 用容斥原理即可.</p><h3 id="错位排列与禁位排列">错位排列与禁位排列</h3><h4 id="错位排列">错位排列</h4><ul><li>递推: <span class="math inline">\(D_n=(n-1)(D_{n-1}+D_{n-2})\)</span>, <span class="math inline">\(D_1=0\)</span>, <span class="math inline">\(D_2=1\)</span>;</li><li>通项: <span class="math inline">\(D_n=n!\cdot\left(1-\frac{1}{1!}+\frac{1}{2!}-\cdots+\frac{1}{n!}\right)\)</span>.</li></ul><h4 id="禁位排列">禁位排列</h4><ul><li>递推: <span class="math inline">\(Q_n=(n-1)Q_{n-1}+(n-2)Q_{n-2}\)</span>;</li><li>组合证明: 考虑去掉 <span class="math inline">\(n\)</span> 的情况, 若前 <span class="math inline">\(n-1\)</span> 项本身就能构成禁位排列, 则只需要 <span class="math inline">\(n\)</span> 不在 <span class="math inline">\(n-1\)</span> 后即可, 方案数 <span class="math inline">\((n-1)Q_{n-1}\)</span>; 若前 <span class="math inline">\(n-1\)</span> 项本身不能构成禁位排列, 则只能有一个 <span class="math inline">\(i\)</span> 使得 <span class="math inline">\(a_{i+1}=a_i+1\)</span>, 则此时 <span class="math inline">\(n\)</span> 只能放在此处, 考虑到 <span class="math inline">\(i\)</span> 有 <span class="math inline">\(n-2\)</span> 种选择, 并且去掉 <span class="math inline">\(i+1\)</span> 后, 序列构成长度为 <span class="math inline">\(n-2\)</span> 的禁位排列, 此时方案数为 <span class="math inline">\((n-2)Q_{n-2}\)</span>, 得证.</li></ul><h2 id="第六章-递推关系与生产函数">第六章 递推关系与生产函数</h2><h3 id="递推关系">递推关系</h3><h4 id="线性-齐次-常系数">线性 齐次 常系数</h4><p><span class="math inline">\(h_n-a_1h_{n-1}-\cdots-a_kh_{n-k}=0\)</span> 的特征方程为 <span class="math inline">\(q_k-a_1q_{k-1}-\cdots-a_k=0\)</span></p><ol style="list-style-type: decimal"><li>若特征方程有 <span class="math inline">\(k\)</span> 个单根, 则通解为 <span class="math inline">\(h_n=C_1q_1^n+\cdots+C_kq_k^n\)</span>;</li><li>若 <span class="math inline">\(q_i\)</span> 的重数为 <span class="math inline">\(s_i\)</span>, 则通解为 <span class="math inline">\(n^jq_i,~0\leqslant j\leqslant s_i,~1\leqslant i\leqslant k\)</span> 的线性组合.</li></ol><h4 id="非齐次">非齐次</h4><p>求一个特解, 然后求齐次方程的通解. 设 <span class="math inline">\(f(n)=D_r(n)q^n\)</span>, <span class="math inline">\(D_r\)</span> 为 <span class="math inline">\(r\)</span> 次多项式, 则有特解 <span class="math display">\[h(n)=n^sF_r(n)q^n\]</span> 其中 <span class="math inline">\(F_r\)</span> 为多项式, <span class="math inline">\(s\)</span> 是 <span class="math inline">\(q\)</span> 的重数.</p><h3 id="生成函数">生成函数</h3><p>生成函数: <span class="math inline">\(h(x)=\sum\limits_{n=0}^\infty h_nx^n\)</span>.</p><blockquote><p>若递推式为 <span class="math inline">\(h_n+a_1h_{n-1}+\cdots+a_kh_{n-k}=0\)</span>, 则其生成函数为 <span class="math display">\[h(x)=\frac{b_0+b_1x+\cdots+b_{k-1}x^{k-1}}{1+a_1x+\cdots+a_kx^k}.\]</span> 其中 <span class="math inline">\(b_n=\sum\limits_{i=0}^n a_ih_{n-i}\)</span>, <span class="math inline">\(a_0=1\)</span>.</p></blockquote><h2 id="第八章-二分图匹配">第八章 二分图匹配</h2><h3 id="最大匹配">最大匹配</h3><p>找 <span class="math inline">\(M\)</span>-交错链, 标记算法求最大匹配.</p><blockquote><p>König定理: 最大匹配 <span class="math inline">\(=\)</span> 最小点覆盖.</p></blockquote><p><span class="math inline">\(p\)</span>-正则: 每个点度都是 <span class="math inline">\(p\)</span>. 完美匹配: 若二分图 <span class="math inline">\(G\)</span> 满足 <span class="math inline">\(|X|=|Y|=n\)</span>, 且一个匹配含 <span class="math inline">\(n\)</span> 条边, 则称其为完美匹配.</p><blockquote><p>定理: <span class="math inline">\(p\geqslant 1\)</span> 的 <span class="math inline">\(p\)</span>-正则二分图一定有完美匹配.</p></blockquote><h3 id="稳定匹配">稳定匹配</h3><p>延迟认可算法.</p><blockquote><p>定理: 由延迟认可算法得到的匹配是稳定匹配.</p></blockquote><h2 id="第九章-组合设计">第九章 组合设计</h2><h3 id="pk-元域的构造"><span class="math inline">\(p^k\)</span> 元域的构造</h3><p>取 <span class="math inline">\(\mathbb{Z}_p\)</span> 的 <span class="math inline">\(k\)</span> 次不可约多项式 <span class="math inline">\(f\)</span>, 令其 <span class="math inline">\(k\)</span> 个根为 <span class="math inline">\(a_1,\cdots,a_k\)</span>, 则 <span class="math inline">\(\mathbb{Z}_p\)</span> 的 <span class="math inline">\(k\)</span> 次扩张 <span class="math inline">\(\mathbb{Z}_p(a_1,\cdots,a_k)\)</span> 即为 <span class="math inline">\(p^k\)</span> 元域.</p><h3 id="区组设计">区组设计</h3><h4 id="bibd-的性质">BIBD 的性质</h4><ul><li>每一组含 <span class="math inline">\(k\)</span> 个元素;</li><li>每一对都恰好出现在 <span class="math inline">\(\lambda\)</span> 个区组中, 则为平衡区组设计(Balanced);</li><li><span class="math inline">\(k&lt;v\)</span>, 不完全(Incomplete);</li></ul><blockquote><p>定理: BIBD 中, <span class="math inline">\(r(k-1)=\lambda(v-1)\)</span>.</p></blockquote><p>可利用包含 <span class="math inline">\(x_i\)</span> 的元素对的个数来组合证明.</p><blockquote><p>定理: BIBD 中, <span class="math inline">\(bk=vr\)</span>.</p></blockquote><p>可利用 BIBD 的关联矩阵中 <span class="math inline">\(1\)</span> 的个数来组合证明.</p><blockquote><p>定理: BIBD 中, <span class="math inline">\(b\geqslant v\)</span>.</p></blockquote><p><span class="math inline">\(b=v\)</span> 时称为 SBIBD (symmetric).</p><h4 id="符号说明-1">符号说明</h4><ul><li><span class="math inline">\(b\)</span>: 区组的个数;</li><li><span class="math inline">\(v\)</span>: 集合元素总数;</li><li><span class="math inline">\(k\)</span>: 每个区组中的元素个数;</li><li><span class="math inline">\(r\)</span>: 包含任何一个特定元素的不同区组的个数;</li><li><span class="math inline">\(\lambda\)</span>: 包含任何一对特定元素的不同区组的个数.</li></ul><h4 id="sbibd-的构造">SBIBD 的构造</h4><blockquote><p>定理: 若 <span class="math inline">\(B\)</span> 是 <span class="math inline">\(\mathbb{Z}_v\)</span> 的差分集, 则 <span class="math inline">\(B\)</span> 生成的区组构成一个指标为 <span class="math inline">\(\lambda=\frac{k(k-1)}{v-1}\)</span> 的 SBIBD.</p></blockquote><p>如 <span class="math inline">\(\mathbb{Z}_7\)</span> 中取 <span class="math inline">\(B=\{0,1,3\}\)</span>, 则 <span class="math display">\[\begin{align}B+0 &amp;=\{0,1,3\}, \\B+1 &amp;=\{1,2,4\}, \\B+2 &amp;=\{2,3,5\}, \\B+3 &amp;=\{3,4,6\}, \\B+4 &amp;=\{4,5,0\}, \\B+5 &amp;=\{5,6,1\}, \\B+6 &amp;=\{6,0,2\}, \\\end{align}\]</span> 构成一个 <span class="math inline">\(b=v=7,~k=r=3,~\lambda=1\)</span> SBIBD.</p><h3 id="steiner三元系统">Steiner三元系统</h3><blockquote><p>定理: STS 中, <span class="math inline">\(r=\frac{\lambda(v-1)}{2},~b=\frac{\lambda v(v-1)}{6}\)</span>.</p></blockquote><p>一个 <span class="math inline">\(v=9,~\lambda=1\)</span> 的 STS: <span class="math display">\[\begin{align}&amp;\{0,1,2\},\{3,4,5\},\{6,7,8\}, \\&amp;\{0,3,6\},\{1,4,7\},\{2,5,8\}, \\&amp;\{0,4,8\},\{1,5,6\},\{2,3,7\}, \\&amp;\{0,5,7\},\{1,3,8\},\{2,4,6\}. \\\end{align}\]</span></p><h3 id="拉丁方">拉丁方</h3><p><span class="math inline">\(n\)</span> 阶拉丁方: 由 <span class="math inline">\(n\)</span> 个元素构成的 <span class="math inline">\(n\times n\)</span> 方阵, 每行每列都包含了所有 <span class="math inline">\(n\)</span> 个元素.</p><blockquote><p>定理: <span class="math inline">\((r,n)=1\)</span>, 则 <span class="math inline">\(a_{ij}=r\times i+j\)</span> 构成 <span class="math inline">\(\mathbb{Z}_n\)</span> 的拉丁方, 记作 <span class="math inline">\(\mathbf{L}_n^r\)</span>.</p></blockquote><h4 id="正交拉丁方">正交拉丁方</h4><p>将两个 <span class="math inline">\(n\)</span> 阶拉丁方对应位置的元素组成二元有序组, 可以构成一个新的 <span class="math inline">\(n\)</span> 阶方阵. 如果该方阵中, <span class="math inline">\((0,0)\sim (n-1,n-1)\)</span> 都恰好出现一次, 则称这两个拉丁方正交. 称两两正交的拉丁方为MOLS. 第一行为 <span class="math inline">\(0,\cdots,n-1\)</span> 的MOLS由如下定理给出:</p><blockquote><p>定理: 设 <span class="math inline">\(F\)</span> 是一个 <span class="math inline">\(n=p^k\)</span> 元域, 其中元素为 <span class="math inline">\(f_i\)</span>, 则 <span class="math inline">\(a_{ij}=r\times a_i+a_j\)</span> 为拉丁方, <span class="math inline">\(\forall~r\neq 0\in F\)</span>, 记作 <span class="math inline">\(\mathbf{L}_n^r\)</span>. 当 <span class="math inline">\(r\)</span> 取遍所有 <span class="math inline">\(F\)</span> 中非零值时, 可以得到 <span class="math inline">\(n-1\)</span> 个两两正交的拉丁方.</p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 期末复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微分几何复习重点</title>
      <link href="/2017/06/23/%E5%BE%AE%E5%88%86%E5%87%A0%E4%BD%95%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/"/>
      <content type="html"><![CDATA[<h2 id="重要的定义">重要的定义</h2><h3 id="正则曲线">正则曲线</h3><p>给定参数曲线 <span class="math inline">\(C:r=r(t),~t\in(a,b)\)</span>. 若 <span class="math inline">\(r&#39;(t)\neq 0\)</span> 对于 <span class="math inline">\(\forall~t\)</span> 成立, 则称 <span class="math inline">\(C\)</span> 为<strong>正则曲线</strong>.</p><h3 id="曲线的容许参数变换">曲线的容许参数变换</h3><p>给定正则曲线 <span class="math inline">\(C:r=r(t)\)</span>, 若参数变换 <span class="math inline">\(t=t(u)\)</span> 满足</p><ol style="list-style-type: decimal"><li><span class="math inline">\(t(u)\)</span> 是 <span class="math inline">\(C^3\)</span> 阶的;</li><li><span class="math inline">\(t&#39;(u)\)</span> 处处非零,</li></ol><p>则称之为<strong>容许的参数变换</strong>. 当 <span class="math inline">\(t&#39;(u)&gt;0\)</span> 时称为保向的, <span class="math inline">\(t&#39;(u)&lt;0\)</span> 时称为反向的.</p><h3 id="曲率向量">曲率向量</h3><p>正则曲线 <span class="math inline">\(C:r=r(t)\)</span> 的单位切向量场 <span class="math inline">\(T(t(s))\)</span> 关于弧长 <span class="math inline">\(s\)</span> 的导向量 <span class="math inline">\(\frac{dT}{ds}=\frac{d^2r}{ds^2}\)</span> 称为曲线 <span class="math inline">\(C\)</span> 在 <span class="math inline">\(r(t(s))\)</span> 处的<strong>曲率向量</strong>; 曲率向量的模长 <span class="math inline">\(\kappa=|\frac{dT}{ds}|\)</span> 称为 <span class="math inline">\(C\)</span> 在 <span class="math inline">\(r(t(s))\)</span> 处的<strong>曲率</strong>.</p><h3 id="相对曲率">相对曲率</h3><p>给定二阶连续可微的弧长参数化平面曲线 <span class="math inline">\(C:r=r(s)=(x(s),y(s))\)</span>, 局部可取到切向角 <span class="math inline">\({\rm Arctan}\frac{y&#39;}{x&#39;}\)</span> 的可微单值支, 定义其对 <span class="math inline">\(s\)</span> 的导数 <span class="math inline">\(\kappa_r=\theta&#39;(s)\)</span> 为<strong>相对曲率</strong>.</p><h3 id="正则曲面">正则曲面</h3><p>给定参数曲面 <span class="math inline">\(S:r=r(u,v),~(u,v)\in U\)</span>. 若处处有 <span class="math inline">\(r_u(u,v)\times r_v(u,v)\neq 0\)</span>, 则称 <span class="math inline">\(S\)</span> 为<strong>正则曲面</strong>.</p><h3 id="曲面的容许参数变换">曲面的容许参数变换</h3><p>给定正则曲面 <span class="math inline">\(S:r=r(u,v)\)</span>, 若参数变换 <span class="math inline">\((u,v)=(u(x,y),v(x,y))\)</span> 满足:</p><ol style="list-style-type: decimal"><li>是连续可微的一一对应;</li><li>Jacobi 行列式 <span class="math inline">\(\frac{\partial(u,v)}{\partial(x,y)}\)</span> 处处非零,</li></ol><p>则称之为<strong>容许的参数变换</strong>, 若 <span class="math inline">\(\frac{\partial(u,v)}{\partial(x,y)}&gt;0\)</span>, 称为保向的, 若 <span class="math inline">\(\frac{\partial(u,v)}{\partial(x,y)}&lt;0\)</span>, 称为反向的.</p><h3 id="局部等距对应">局部等距对应</h3><p>对于两张对应的曲面, 若它们对应着的弧段总是具有相等的弧段长度, 则称这个对应是两张曲面的一个<strong>局部等距对应</strong>.</p><h3 id="内蕴量和内蕴几何体">内蕴量和内蕴几何体</h3><p>在曲面上, 由其第一基本形式可完全确定的几何量, 称为曲面的<strong>内蕴量</strong>; 由其第一基本形式可完全确定属性的几何体, 称为曲面的<strong>内蕴几何体</strong>.</p><h3 id="主曲率和主方向">主曲率和主方向</h3><p>曲面 <span class="math inline">\(S\)</span> 上的点 <span class="math inline">\(P\)</span> 处的法曲率关于切方向的两个最值, 分别称为曲面 <span class="math inline">\(S\)</span> 在 <span class="math inline">\(P\)</span> 处的<strong>主曲率</strong>, 使得法曲率达到最值的两个方向称为<strong>主方向</strong>.</p><h3 id="脐点">脐点</h3><p>若曲面 <span class="math inline">\(S\)</span> 在 <span class="math inline">\(P\)</span> 处的两个主曲率相等, 则称 <span class="math inline">\(P\)</span> 为曲面 <span class="math inline">\(S\)</span> 的<strong>脐点</strong>. 若脐点处的主曲率均为0, 称为平点, 否则称为圆点.</p><h3 id="极小曲面">极小曲面</h3><p>若曲面的平均曲率恒为零, 称之为<strong>极小曲面</strong>.</p><h3 id="抽象曲面">抽象曲面</h3><p>称二元有序组 <span class="math inline">\((D,ds^2)\)</span> 为一张<strong>抽象曲面</strong>, 其中 <span class="math inline">\(D\subset\mathbf{R}^2\)</span> 是参数平面 <span class="math inline">\(\mathbf{R}^2\)</span> 上指定的区域, <span class="math inline">\(ds^2\)</span> 是定义域上的正定的二次微分形式.</p><h2 id="重要的定理">重要的定理</h2><h3 id="曲线论基本定理">曲线论基本定理</h3><p>给定区间 <span class="math inline">\(I=(a,b)\)</span> 上的连续可微函数 <span class="math inline">\(\overline{\kappa}(s)&gt;0\)</span> 和连续函数 <span class="math inline">\(\overline{\tau}(s)\)</span>, 则在 <span class="math inline">\(E^3\)</span> 中</p><ol style="list-style-type: decimal"><li>存在弧长 <span class="math inline">\(s\)</span> 参数化曲线 <span class="math inline">\(C:r=r(s)\)</span>, 使其曲率函数 <span class="math inline">\(\kappa(s)=\overline{\kappa}(s)\)</span>, 并且其挠率函数 <span class="math inline">\(\tau(s)=\overline{\tau}(s)\)</span>;</li><li>上述曲线 <span class="math inline">\(C\)</span> 在合同的意义下是唯一的.</li></ol><h3 id="可展曲面的分类定理">可展曲面的分类定理</h3><p>可展曲面必是煮面、锥面和切线面之一或由它们沿直母线所适当拼接而成.</p><h3 id="局部等距对应的条件">局部等距对应的条件</h3><p>两张曲面能建立局部等距对应的充要条件是按照对应关系有相同的第一基本形式.</p><h3 id="gauss绝妙定理">Gauss绝妙定理</h3><p>曲面 <span class="math inline">\(S\)</span> 的Gauss曲率是内蕴量, 可表示为 <span class="math display">\[K=\frac{-R_{1212}}{g_{11}g_{22}-(g_{12})^2}.\]</span> 在正交网下, 有 <span class="math display">\[K=\frac{-1}{\sqrt{EG}}\left(\left[\frac{(\sqrt{E})_2}{\sqrt{G}}\right]_2+\left[\frac{(\sqrt{G})_1}{\sqrt{G}}\right]_1\right).\]</span></p><h3 id="曲面论基本定理">曲面论基本定理</h3><p>给定 <span class="math inline">\((u^1,u^2)\)</span> 平面上的单连通区域 <span class="math inline">\(U\)</span>. 给定 <span class="math inline">\(U\)</span> 上的 <span class="math inline">\(C^2\)</span> 函数 <span class="math inline">\(\overline{g}_{ij}\)</span> 和 <span class="math inline">\(\overline{\Omega}_{ij}\)</span>, s.t. <span class="math inline">\(\overline{g}\)</span> 正定, <span class="math inline">\(\overline{\Omega}\)</span> 对称, 并且 <span class="math inline">\(\overline{g}\)</span> 和 <span class="math inline">\(\overline{\Omega}\)</span> 满足 Gauss-Codazzi方程, 则在 <span class="math inline">\(E^3\)</span> 中</p><ol style="list-style-type: decimal"><li>存在正则曲面 <span class="math inline">\(S:r=r(u^1,u^2),~(u^1,u^2)\in U\)</span>, s.t. 其第一第二基本形式分别为 <span class="math inline">\(\overline{g}\)</span> 和 <span class="math inline">\(\overline{\Omega}\)</span>;</li><li>上述曲面 <span class="math inline">\(S\)</span> 在合同的意义下是唯一的.</li></ol><h3 id="测地线存在唯一性定理">测地线存在唯一性定理</h3><p>给定正则曲面 <span class="math inline">\(S:(u^1,u^2)\)</span> 上任意一点 <span class="math inline">\(P_0(u_0^1,u_0^2)\)</span>, 则存在 <span class="math inline">\(P_0\)</span> 的某个邻域 <span class="math inline">\(\Sigma_0\subset S\)</span>, s.t. 在 <span class="math inline">\(\Sigma_0\)</span> 内从点 <span class="math inline">\(P_0\)</span> 出发沿指定单位切向 <span class="math inline">\(T_0\in T_{P_0}\)</span> 存在唯一一条测地线 <span class="math inline">\(C:r(u^1(s),u^2(s))\)</span>, s.t. <span class="math display">\[\left(r_i\frac{du^i}{ds}\right)\Bigg|_{s=s_0}=T_0,~u^i(s_0)=u_0^i,~i=1,2.\]</span></p><h2 id="重要的式子">重要的式子</h2><h3 id="euler公式">Euler公式</h3><p><span class="math display">\[\kappa_n(P,a)=\kappa_1|_P\cos^2\theta+\kappa_2|_P\sin^2\theta.\]</span></p><h3 id="rodriques公式">Rodriques公式</h3><p>已知正则曲面 <span class="math inline">\(S:r(u^1,u^2)\)</span> 的弧长参数化曲线 <span class="math inline">\(C:r(u^1(s),u^2(s))\)</span>, 则 <span class="math inline">\(C\)</span> 是曲率线等价于沿 <span class="math inline">\(C\)</span> 存在 <span class="math inline">\(\lambda(s)\)</span>, s.t. <span class="math display">\[\frac{dn}{ds}=-\lambda(s)\frac{dr}{ds}.\]</span> 即, 沿 <span class="math inline">\(C\)</span> 有 <span class="math inline">\(dn=-\lambda(s)dr\)</span>.</p><h3 id="正交曲率线网下的gauss-codazzi方程">正交曲率线网下的Gauss-Codazzi方程</h3><p><span class="math display">\[\begin{cases}L_2 &amp;= HE_2, \\N_1 &amp;= HG_1. \\\end{cases}\]</span></p><h2 id="判断内蕴量几何体">判断内蕴量(几何体)</h2><h3 id="常见的内蕴量内蕴几何体">常见的内蕴量(内蕴几何体)</h3><p>曲线的弧段长度, 曲线的测地曲率, 曲线的交角, 曲面的第一基本形式, 曲线的区域面积, Gauss曲率, 测地线, 测地圆周, 测地开圆盘, 抛物点, 黎曼曲率张量, 联络系数.</p><h3 id="常见的不是内蕴量的东西">常见的不是内蕴量的东西</h3><p>曲线的曲率, 曲线的挠率, 法曲率, 直线, 圆周, <strong>第一基本形式的系数矩阵</strong>, 第二基本形式, 主曲率, 主方向, 脐点, 平点, 圆点, 平均曲率, Weingarten矩阵, 第三基本形式, 渐近曲线.</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 期末复习 </tag>
            
            <tag> 微分几何 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>概率论复习重点</title>
      <link href="/2017/06/23/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/"/>
      <content type="html"><![CDATA[<h2 id="第二章-概率空间">第二章 概率空间</h2><h3 id="性质和定理">性质和定理</h3><p>设 <span class="math inline">\((\Omega,\mathscr{F},\mathbb{P})\)</span> 为概率空间, 有如下性质和定理成立.</p><h4 id="可列可加性和次可加性">可列可加性和次可加性</h4><p><span class="math inline">\(\forall~\{A_n\}\subset\mathscr{F}\)</span>, 有 <span class="math display">\[\mathbb{P}\left(\bigcup_{n=1}^\infty A_n\right)\leqslant\sum\limits_{n=1}^\infty \mathbb{P}(A_n).\]</span> 对于两两不相容的集合列 <span class="math inline">\(\{A_n\}\subset\mathscr{F}\)</span>, 有 <span class="math display">\[\mathbb{P}\left(\bigcup_{n=1}^\infty A_n\right)=\sum\limits_{n=1}^\infty \mathbb{P}(A_n).\]</span></p><h4 id="连续性">连续性</h4><p>若事件 <span class="math inline">\(A_n\subset A_{n+1}\)</span>, <span class="math inline">\(n\geqslant 1\)</span>, 则 <span class="math display">\[\mathbb{P}\left(\bigcup\limits_{n=1}^\infty A_n\right)=\lim\limits_{n\to\infty}\mathbb{P}(A_n).\]</span> 若事件 <span class="math inline">\(A_n\supset A_{n+1}\)</span>, <span class="math inline">\(n\geqslant 1\)</span>, 则 <span class="math display">\[\mathbb{P}\left(\bigcap\limits_{n=1}^\infty A_n\right)=\lim\limits_{n\to\infty}\mathbb{P}(A_n).\]</span></p><h4 id="全概率公式">全概率公式</h4><p>设 <span class="math inline">\(\{B_n\}\)</span> 为 <span class="math inline">\(\Omega\)</span> 的一个分割, 则 <span class="math display">\[\mathbb{P}(A)=\sum\limits_n \mathbb{P}(B_n)\mathbb{P}(A|B_n),\quad\forall~A\in\mathscr{F}.\]</span></p><h4 id="bayes公式">Bayes公式</h4><p>设 <span class="math inline">\(\{B_n\}\)</span> 为 <span class="math inline">\(\Omega\)</span> 的一个分割, 对于 <span class="math inline">\(\forall~A\in\mathscr{F}\)</span>, 如果 <span class="math inline">\(\mathbb{P}(A)&gt;0\)</span>, 则对于 <span class="math inline">\(\forall~1\leqslant k\leqslant n\)</span>, 有 <span class="math display">\[\mathbb{P}(B_k|A)=\frac{\mathbb{P}(B_k)\mathbb{P}(A|B_k)}{\sum\limits_{n=1}^\infty \mathbb{P}(B_n)\mathbb{P}(A|B_n)}.\]</span></p><h4 id="事件的独立性">事件的独立性</h4><p>若 <span class="math inline">\(\mathbb{P}(AB)=\mathbb{P}(A)\mathbb{P}(B)\)</span>, 则称 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 独立.</p><h2 id="第三章-随机变量及其分布">第三章 随机变量及其分布</h2><h3 id="正态分布">正态分布</h3><h4 id="密度函数">密度函数</h4><p><span class="math display">\[\varphi_{a,\sigma}(x)=\frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{(x-a)^2}{2\sigma^2}},\quad a\in\mathbb{R},~\sigma&gt;0;\]</span></p><h4 id="分布函数">分布函数</h4><p><span class="math display">\[\Phi_{a,\sigma}(x)=\int\nolimits_{-\infty}^x \varphi_{a,\sigma}(t)dt;\]</span></p><h4 id="标准正态分布">标准正态分布</h4><p><span class="math display">\[\varphi(x)=\varphi_{0,1}(x)=\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}};\]</span></p><h4 id="正态分布的性质">正态分布的性质</h4><p><span class="math display">\[\Phi_{a,\sigma}(x)=\Phi(\frac{x-a}{\sigma}),\quad \Phi(x)=1-\Phi(-x).\]</span></p><h3 id="联合分布">联合分布</h3><h4 id="联合分布函数">联合分布函数</h4><p><span class="math display">\[F(x_1,\cdots,x_n)=\mathbb{P}(\xi_1\leqslant x_1,\cdots,\xi_n\leqslant x_n);\]</span></p><h4 id="联合密度函数">联合密度函数</h4><p><span class="math display">\[F(x_1,\cdots,x_n)=\int\cdots\int\nolimits_{\mathbf{R}^n}p(x_1,\cdots,x_n)dx_1\cdots dx_n;\]</span></p><h4 id="边缘分布函数">边缘分布函数</h4><p><span class="math display">\[F_1(x)=\lim\limits_{y\to\infty}F(x,y),\quad F_2(y)=\lim\limits_{x\to\infty}F(x,y);\]</span></p><h4 id="边缘密度">边缘密度</h4><ol style="list-style-type: decimal"><li>离散情形: <span class="math display">\[p_{i\bullet}=\sum\limits_j p_{ij},\quad p_{\bullet j}=\sum\limits_i p_{ij};\]</span></li><li>连续情形: <span class="math display">\[p_1(x)=\int\nolimits_{-\infty}^\infty p(x,y)dy,\quad p_2(y)=\int\nolimits_{-\infty}^\infty p(x,y)dx;\]</span></li></ol><h4 id="随机变量的独立">随机变量的独立</h4><p>联合密度等于边缘密度的乘积. 1. 离散情形: <span class="math display">\[p_{ij}=p_{i\bullet}p_{\bullet j},\quad\forall~i,j;\]</span> 2. 连续情形: <span class="math display">\[p(x,y)=p_1(x)p_2(y);\]</span> 若 <span class="math inline">\(\xi_1\)</span> 与 <span class="math inline">\(\xi_2\)</span> 独立, 则对于任何Borel可测函数 <span class="math inline">\(f_1\)</span> 与 <span class="math inline">\(f_2\)</span>, <span class="math inline">\(\eta_1=f_1(\xi_1)\)</span> 与 <span class="math inline">\(\eta_2=f_2(\xi_2)\)</span> 独立.</p><h3 id="随机变量函数的分布">随机变量函数的分布</h3><h4 id="分布函数-1">分布函数</h4><p>设 <span class="math inline">\(f(x_1,\cdots,x_n)\)</span> 为 <span class="math inline">\(n\)</span> 元Borel可测函数, <span class="math inline">\(p\)</span> 为 <span class="math inline">\((\xi_1\cdots,\xi_n)\)</span> 的密度函数, 则 <span class="math inline">\(\eta=f(\xi_1,\cdots,\xi_n)\)</span> 的分布函数为 <span class="math display">\[F_\eta(y)=\underset{f(x_1,\cdots,x_n)\leqslant y}{\int\cdots\int}p(x_1,\cdots,x_n)dx_1\cdots dx_n.\]</span></p><h4 id="卷积公式">卷积公式</h4><p>设 <span class="math inline">\((\xi,\eta)\)</span> 的联合密度函数为 <span class="math inline">\(p\)</span>, 则 <span class="math inline">\(\xi+\eta\)</span> 的密度函数为 <span class="math display">\[p_{\xi+\eta}(z)=\int\nolimits_{-\infty}^\infty p(x,z-x)dx=\int\nolimits_{-\infty}^\infty p(z-y,y)dy.\]</span></p><h4 id="商密度公式">商密度公式</h4><p>设 <span class="math inline">\((\xi,\eta)\)</span> 的联合密度为 <span class="math inline">\(p\)</span>, 则 <span class="math inline">\(\xi/\eta\)</span> 的密度函数为 <span class="math display">\[p_{\xi/\eta}(z)=\int\nolimits_{-\infty}^\infty |y|p(zy,y)dy.\]</span></p><h4 id="高维情形">高维情形</h4><p>设 <span class="math inline">\(n\)</span> 维随机向量 <span class="math inline">\(\xi\)</span> 的联合密度为 <span class="math inline">\(p\)</span>, <span class="math inline">\(f_i(x)\)</span> 为 <span class="math inline">\(n\)</span> 维Borel可测函数, <span class="math inline">\(\eta=(f_1(\xi),\cdots,f_n(\xi))\)</span>. 若对于 <span class="math inline">\(\eta\)</span> 的像空间 <span class="math inline">\(D\)</span> 中任何一个 <span class="math inline">\(y\)</span>, 方程组 <span class="math inline">\(y_i=f_i(x)\)</span>有唯一的可微解 <span class="math inline">\(x_i=h_i(y)\)</span>, 则 <span class="math inline">\(\eta\)</span> 的联合密度函数为 <span class="math display">\[q(y)==p(h_1(y),\cdots,h_n(y))|J|,\quad y\in D,\]</span> 其中 <span class="math inline">\(J=\frac{\partial(h_1(y),\cdots,h_n(y))}{\partial (y_1,\cdots,y_2)}\)</span> 为Jacobi行列式.</p><h2 id="第四章-数字特征与特征函数">第四章 数字特征与特征函数</h2><h3 id="数学期望">数学期望</h3><p>定义: 简单随机变量 <span class="math inline">\(\mathbb{E}(\xi)=\sum\limits_{i=1}^n x_i\mathbb{P}(\xi=x_i)\rightarrow\)</span> 非负随机变量用简单随机变量逼近 <span class="math inline">\(\mathbb{E}(\xi)=\lim\limits_{n\to\infty}\mathbb{E}(\xi_n)\rightarrow\)</span>, 一般随机变量 <span class="math inline">\(\mathbb{E}(\xi)=\mathbb{E}(\xi^+)-\mathbb{E}(\xi^-).\)</span></p><h4 id="单调收敛定理">单调收敛定理</h4><p>若 <span class="math inline">\(\xi_n\)</span> 为非负随机变量, 且 <span class="math inline">\(\xi_n\uparrow\xi\)</span>, 则 <span class="math inline">\(\lim\limits_{n\to\infty}\mathbb{E}(\xi_n)=\mathbb{E}(\xi)\)</span>.</p><h4 id="数学期望的性质">数学期望的性质</h4><ol style="list-style-type: decimal"><li>线性性质: <span class="math inline">\(\mathbb{E}(a\xi+b\eta)=a\mathbb{E}(\xi)+b\mathbb{E}(\eta)\)</span>;</li><li>若 <span class="math inline">\(\xi\)</span> 与 <span class="math inline">\(\eta\)</span> 独立, 则 <span class="math inline">\(\mathbb{E}(\xi\eta)=\mathbb{E}(\xi)\mathbb{E}(\eta).\)</span></li></ol><h4 id="数学期望的计算">数学期望的计算</h4><ol style="list-style-type: decimal"><li>离散型: <span class="math inline">\(\mathbb{E}(\xi)=\sum\limits_{k=1}^n x_kp_k\)</span> 或 <span class="math inline">\(\mathbb{E}(\xi)=\sum\limits_{k=1}^\infty x_kp_k\)</span>;</li><li>连续型: <span class="math inline">\(\mathbb{E}(\xi)=\int\nolimits_{-\infty}^\infty xp(x)dx\)</span>.</li></ol><h4 id="条件期望">条件期望</h4><ol style="list-style-type: decimal"><li>离散型: <span class="math inline">\(\mathbb{E}(\xi|\eta=y)=\sum\limits_{i=1}^n\mathbb{P}(\xi=x_i|\eta=y)\)</span>,</li><li>连续型: <span class="math inline">\(\mathbb{E}(\xi|\eta=y)=\int\nolimits_{-\infty}^\infty xp(x|\eta=y)dx\)</span>.</li><li>条件期望的平滑性: <span class="math inline">\(\mathbb{E}(\xi)=\mathbb{E}(\mathbb{E}(\xi|\eta))\)</span>.</li></ol><h3 id="方差">方差</h3><p>计算: <span class="math inline">\(D(\xi)=\mathbb{E}(\xi-\mathbb{E}(\xi))^2\)</span>; 协方差: <span class="math inline">\({\rm cov}(\xi_i,\xi_j)=\mathbb{E}((\xi_1-\mathbb{E}(\xi_1))(\xi_2-\mathbb{E}(\xi_2)))\)</span>. 容易证明协方差具有如下性质: <span class="math display">\[D(\xi+\eta)=D(\eta)+D(\xi)\Longleftrightarrow {\rm cov}(\xi,\eta)=0,\]</span> <span class="math display">\[{\rm cov}(\xi_1+\xi_2,\eta)={\rm cov}(\xi_1,\eta)+{\rm cov}(\xi_2,\eta).\]</span></p><h2 id="第五章-大数定律和中心极限定理">第五章 大数定律和中心极限定理</h2><h3 id="收敛性">收敛性</h3><h4 id="几乎处处收敛">几乎处处收敛</h4><p>若 <span class="math inline">\(\mathbb{P}(\lim\limits_{n\to\infty}\xi_n=\xi)=1\)</span>, 则称 <span class="math inline">\(\xi_n\)</span> 几乎处处收敛到 <span class="math inline">\(\xi\)</span>, 记作 <span class="math inline">\(\xi_n\xrightarrow{a.e.}\xi\)</span>.</p><h4 id="依概率收敛">依概率收敛</h4><p>若 <span class="math inline">\(\lim\limits_{n\to\infty}\mathbb{P}(|\xi_n-\xi|\geqslant\epsilon)=0\)</span>, <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, 则称 <span class="math inline">\(\xi_n\)</span> 依概率收敛于 <span class="math inline">\(\xi\)</span>, 记作 <span class="math inline">\(\xi_n\xrightarrow{\mathbb{P}}\xi\)</span>.</p><h4 id="弱收敛">弱收敛</h4><p>设 <span class="math inline">\(\xi_n\)</span> 和 <span class="math inline">\(\xi\)</span> 的分布函数分别为 <span class="math inline">\(F_n(x)\)</span> 和 <span class="math inline">\(F(x)\)</span>, 若 <span class="math inline">\(\lim\limits_{n\to\infty}F_n(x)=F(x)\)</span>, <span class="math inline">\(\forall~x\in C_F\)</span>, 其中 <span class="math inline">\(C_F\)</span> 为 <span class="math inline">\(F\)</span> 的连续点全体, 则称 <span class="math inline">\(\xi_n\)</span> 弱收敛于 <span class="math inline">\(\xi\)</span>, 记作 <span class="math inline">\(\xi_n\xrightarrow{w}\xi\)</span>.</p><h4 id="r-阶矩收敛"><span class="math inline">\(r\)</span> 阶矩收敛</h4><p>给定 <span class="math inline">\(r&gt;0\in\mathbb{R}\)</span>, 若 <span class="math inline">\(\xi\)</span> 和 <span class="math inline">\(\xi_n\)</span> 的 <span class="math inline">\(r\)</span> 阶矩均存在, 并且 <span class="math inline">\(\lim\limits_{n\to\infty}\mathbb{E}(|\xi_n-\xi|^r)=0\)</span>, 则称 <span class="math inline">\(\xi_n\)</span> <span class="math inline">\(r\)</span> 阶矩收敛于 <span class="math inline">\(\xi\)</span>, 记作 <span class="math inline">\(\xi_n\xrightarrow{L_r}\xi\)</span>.</p><h3 id="几种收敛的关系">几种收敛的关系</h3><p><span class="math inline">\(\xi_n\xrightarrow{a.e.}\)</span> 或 <span class="math inline">\(\xi_n\xrightarrow{L_r}\xi\Rightarrow\)</span> <span class="math inline">\(\xi_n\xrightarrow{\mathbb{P}}\xi\Rightarrow\)</span> <span class="math inline">\(\xi_n\xrightarrow{w}\xi\)</span>. 特别地, <span class="math inline">\(\forall~c\in\mathbb{R}\)</span>, <span class="math inline">\(\xi_n\xrightarrow{w} c\Rightarrow c_n\xrightarrow{\mathbb{P}} c\)</span>.</p><h3 id="大数定律">大数定律</h3><h4 id="大数定律-1">大数定律</h4><p>设 <span class="math inline">\(\xi_n\)</span> 为数学期望均有限的随机变量列, 若:</p><p><span class="math display">\[\frac{1}{n}\sum\limits_{k=1}^n (\xi_k-\mathbb{E}(\xi_k))\xrightarrow{\mathbb{P}}0~,\]</span> 则称 <span class="math inline">\(\xi_n\)</span> 满足弱大数定律. <span class="math display">\[\frac{1}{n}\sum\limits_{k=1}^n (\xi_k-\mathbb{E}(\xi_k))\xrightarrow{\text{a.e.}}0~,\]</span> 则称 <span class="math inline">\(\xi_n\)</span> 满足强大数定律.</p><h4 id="markov条件">Markov条件</h4><p>设随机变量列 <span class="math inline">\(\xi_n\)</span> 满足 <span class="math display">\[\frac{1}{n^2}D\left(\sum\limits_{k=1}^n \xi_k\right)\xrightarrow{n\to\infty}0~,\]</span> 则 <span class="math inline">\(\xi_n\)</span> 满足大数定律.</p><h4 id="bernoulli大数定律">Bernoulli大数定律</h4><p>设 <span class="math inline">\(\mu_n\)</span> 为 <span class="math inline">\(n\)</span> 重Bernoulli试验中成功的次数, <span class="math inline">\(p\)</span> 为单次成功概率, 则 <span class="math inline">\(\frac{\mu_n}{n}\xrightarrow{\mathbb{P}}p\)</span>.</p><h4 id="辛钦大数定律">辛钦大数定律</h4><p>设 <span class="math inline">\(\xi_n\)</span> 为独立同分布随机变量列, 弱大数定律成立的充要条件是 <span class="math inline">\(\mathbb{E}(\xi_1)=a\)</span> 为有限实数.</p><h4 id="kolmogorov强大数定律">Kolmogorov强大数定律</h4><p>设 <span class="math inline">\(\{\xi_n\}\)</span> 是独立随机变量列, 满足 <span class="math inline">\(\sum\limits_{k=1}^\infty \frac{D(\xi_n)}{n^2}&lt;\infty\)</span>, 则 <span class="math inline">\(\{\xi_n\}\)</span> 满足大数定律.</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 概率论 </tag>
            
            <tag> 期末复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>复变复习重点</title>
      <link href="/2017/06/22/%E5%A4%8D%E5%8F%98%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/"/>
      <content type="html"><![CDATA[<h2 id="重要的定义和定理">重要的定义和定理</h2><h3 id="实可微的定义">实可微的定义</h3><p>设 <span class="math inline">\(f\)</span> 是从开集 <span class="math inline">\(\Omega\)</span> 到 <span class="math inline">\(\mathbb{C}\)</span> 中的函数, <span class="math inline">\(a\in\Omega\)</span>, 如果有复常数 <span class="math inline">\(A,b\)</span>, s.t. <span class="math display">\[\lim\limits_{z\to\infty}\frac{f(a+z)-f(a)-Ax-By}{z}=0,\]</span> 则称 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(a\)</span> 处<strong>实可微</strong>.</p><h3 id="复可微">复可微</h3><p>设 <span class="math inline">\(f\)</span> 是定义在开集 <span class="math inline">\(\Omega\)</span> 上的复变函数, <span class="math inline">\(a\in\Omega\)</span>, 如果有常数 <span class="math inline">\(\alpha\)</span>, s.t. <span class="math display">\[\lim\limits_{z\to\infty}\frac{f(a+z)-f(a)}{z}=\alpha\]</span> 存在, 我们称 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(a\in\Omega\)</span> 处<strong>复可微</strong>或称 <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(a\)</span> 可导, 并把 <span class="math inline">\(\alpha\)</span> 记作 <span class="math inline">\(f&#39;(a)\)</span>.</p><h3 id="cauchy-riemann方程">Cauchy-Riemann方程</h3><p>如果 <span class="math inline">\(f(z)=u(x,y)+iv(x,y)\)</span> 在 <span class="math inline">\(a\in\Omega\)</span> 处实可微, <span class="math inline">\(u,v\)</span> 为实值函数, 则 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(a\)</span> 处复可微当且仅当 <span class="math display">\[\frac{\partial f}{\partial \overline{z}}(a)=0~或~\begin{cases}\frac{\partial u}{\partial x}=\frac{\partial y}{\partial y} \\\frac{\partial u}{\partial y}=-\frac{\partial v}{\partial x} \\\end{cases}\]</span> 以上式子被称为Cauchy-Riemann方程, 简称C-R方程.</p><h3 id="复解析">复解析</h3><p>如果存在 <span class="math inline">\(a\)</span> 的一个邻域 <span class="math inline">\(D(a,r)\subset\Omega\)</span>, 使得 <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(D(a,r)\)</span> 中每点都有导数, 则称 <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(a\)</span> 点<strong>解析</strong>. 如果 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(\Omega\)</span> 上的每点解析, 则称 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(\Omega\)</span> 中<strong>解析</strong>或<strong>全纯</strong>.</p><h3 id="cauchy高阶求导公式">Cauchy高阶求导公式</h3><p>设 <span class="math inline">\(\Omega\)</span> 是一个单连通区域, <span class="math inline">\(C\)</span> 是全在区域 <span class="math inline">\(\Omega\)</span> 中的闭Jordan分段光滑曲线, <span class="math inline">\(C\)</span> 所围区域是 <span class="math inline">\(\omega\)</span>. 如果 <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 中解析, 则有如下<strong>Cauchy公式</strong> <span class="math display">\[f(z_0)=\frac{1}{2\pi i}\int\nolimits_C\frac{f(z)dz}{z-z_0}\qquad(z_0\in\omega)\]</span> 且对于任意整数 <span class="math inline">\(m\)</span>, <span class="math inline">\(f\)</span> 的 <span class="math inline">\(m\)</span> 阶复导数 <span class="math inline">\(f^{(m)}(z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 中存在解析, 且有如下的Cauchy高阶求导公式 <span class="math display">\[f^{(m)}(z_0)=\frac{m!}{2\pi i}\int\nolimits_C\frac{f(z)dz}{(z-z_0)^{m+1}}\qquad(z_0\in\omega,~m\in\mathbb{N}^+)\]</span></p><h3 id="泰勒taylor定理">泰勒(Taylor)定理</h3><p>设 <span class="math inline">\(f\)</span> 在区域 <span class="math inline">\(\Omega\)</span> 内解析, <span class="math inline">\(a\in\Omega\)</span>, 只要 <span class="math inline">\(D(a,R)=\{z:|z-a|&lt;R\}\)</span> 包含在 <span class="math inline">\(\Omega\)</span> 中, 则 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(D(a,R)\)</span> 内能展成幂级数 <span class="math display">\[f(z)=\sum\limits_{n=0}^\infty c_n(z-a)^n=c_0+c_1(z-a)+\cdots+c_n(z-a)^n+\cdots,\]</span> 其中系数 <span class="math display">\[c_n=\frac{f^{(n)}(a)}{n!}=\frac{1}{2\pi i}\int\nolimits_{\partial D(a,\rho)}\frac{f(\zeta)d\zeta}{(\zeta-a)^{n+1}},\quad (0&lt;\rho&lt;R,n\in\mathbb{N})\]</span> 且如果 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(D(a,R)\)</span> 内能展成幂级数, 则其系数一定满足上述要求.</p><h3 id="解析函数唯一性定理">解析函数唯一性定理</h3><p>设函数 <span class="math inline">\(g\)</span> 和 <span class="math inline">\(h\)</span> 在区域 <span class="math inline">\(\Omega\)</span> 内解析, <span class="math inline">\(a\in\Omega\)</span>, 且 <span class="math inline">\(\Omega\)</span> 内有一个收敛于 <span class="math inline">\(a\in\Omega\)</span> 的点列 <span class="math inline">\(\{z_n\}~(z_n\neq a)\)</span>, s.t. <span class="math inline">\(g(z_k)=h(z_k)~(k\in\mathbb{N})\)</span>, 则 <span class="math inline">\(g\)</span> 和 <span class="math inline">\(h\)</span> 在 <span class="math inline">\(\Omega\)</span> 内恒等.</p><h3 id="洛朗laurent定理">洛朗(Laurent)定理</h3><p>设 <span class="math inline">\(f\)</span> 在区域 <span class="math inline">\(\Omega\)</span> 内解析, 只要 <span class="math inline">\(B(r,R)=\{z:r&lt;|z-a|&lt;R\}\subset\Omega\)</span>, 则 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(B(r,R)\)</span> 内能展成洛朗级数, 其中系数 <span class="math display">\[c_n=\frac{1}{2\pi i}\int\nolimits_{\partial D(a,\rho)}\frac{f(\zeta)d\zeta}{(\zeta-a)^{n+1}}\quad (r&lt;\rho&lt;R,~n\in\mathbb{Z}),\]</span> 且展式是唯一的(即系数 <span class="math inline">\(c_n\)</span> 由 <span class="math inline">\(f(z)\)</span> 和圆环 <span class="math inline">\(B(r,R)\)</span> 唯一确定).</p><h3 id="孤立奇点">孤立奇点</h3><p>设函数 <span class="math inline">\(f\)</span> 在点 <span class="math inline">\(a\)</span> 的某一去心邻域 <span class="math inline">\(D(a,r)\backslash\{a\}=\{z:0&lt;|z-a|&lt;r\}\)</span> 内解析, 则点 <span class="math inline">\(a\)</span> 称为 <span class="math inline">\(f\)</span> 的<strong>孤立奇点</strong>.</p><h3 id="留数定理">留数定理</h3><p>考虑 <span class="math inline">\(n+1\)</span> 条Jordan闭分段光滑曲线 <span class="math inline">\(C_0,C_1,\cdots,C_n\)</span>, 其中 <span class="math inline">\(C_1,C_2,\cdots,C_n\)</span> 中每一条都在其余各条的外部, 而它们又都在 <span class="math inline">\(C_0\)</span> 的内部. 在 <span class="math inline">\(C_0\)</span> 的内部同时又在 <span class="math inline">\(C_1,C_2,\cdots,C_n\)</span> 外部的点集构成一个多界的多连通区域 <span class="math inline">\(\Omega\)</span>, 以 <span class="math inline">\(C_1,C_2,\cdots,C_n\)</span> 为它的边界. <span class="math inline">\(z_k\in\Omega,~k=1,2,\cdots,m\)</span>, 函数 <span class="math inline">\(f\)</span> 在闭域 <span class="math inline">\(\overline{\Omega}=\Omega\cup\partial\Omega\)</span> 上除去孤立奇点 <span class="math inline">\(z_1,z_2,\cdots,z_k\)</span> 外是解析的, 则 <span class="math display">\[\int\nolimits_{\partial\Omega}f(z)dz=2\pi i\sum\limits_{k=1}^n {\rm Res}(f,z_k).\]</span></p><h3 id="儒歇rouche定理">儒歇(Rouche)定理</h3><p>设 <span class="math inline">\(\Omega\)</span> 是区域, <span class="math inline">\(\omega\subset\Omega\)</span> 是有界区域, 其边界 <span class="math inline">\(C=\partial\omega\subset\Omega\)</span> 是一条Jordan闭分段光滑曲线, 如果 <span class="math inline">\(f\)</span> 和 <span class="math inline">\(g\)</span> 在开集 <span class="math inline">\(\Omega\)</span> 中解析且在 <span class="math inline">\(C\)</span> 上有 <span class="math inline">\(|f(z)|&gt;|g(z)|\)</span>, 则函数 <span class="math inline">\(f(z)\)</span> 与 <span class="math inline">\(f(z)+g(z)\)</span> 在 <span class="math inline">\(C\)</span> 的内部 <span class="math inline">\(\omega\)</span> 有相同的( <span class="math inline">\(k\)</span> 阶零点算 <span class="math inline">\(k\)</span> 次)零点个数, 即 <span class="math display">\[N(f+g,C)=N(f,C).\]</span></p><h2 id="典型题目">典型题目</h2><h3 id="证明复级数的cauchy乘积收敛">证明复级数的Cauchy乘积收敛</h3><h4 id="师大复变习题一-31">师大复变习题一 31</h4><blockquote><p>设复级数 <span class="math inline">\(s=\sum\limits_{n=0}^\infty\alpha_n\)</span>, <span class="math inline">\(s&#39;=\sum\limits_{n=0}^\infty\alpha_n&#39;\)</span> 收敛, 且其中一个绝对收敛, 则其 Cauchy 乘积 <span class="math display">\[\sum\limits_{n=0}^\infty(\alpha_0\alpha_n&#39;+\alpha_1\alpha_{n-1}&#39;+\cdots+\alpha_n\alpha_0&#39;)=\sum\limits_{n=0}^\infty\sum\limits_{k=0}^n\alpha_k\alpha_{n-k}&#39;\]</span>也收敛, 且其和为 <span class="math inline">\(ss&#39;\)</span>.</p></blockquote><p><strong>证明</strong>: 不妨设 <span class="math inline">\(\sum\limits_{n=0}^\infty|\alpha_n|\)</span> 收敛, 记 <span class="math inline">\(S_m=\sum\limits_{n=0}^m\alpha_n\)</span>, <span class="math inline">\(S_m&#39;=\sum\limits_{n=0}^m\alpha_n&#39;\)</span>, <span class="math inline">\(\gamma_n=\alpha_0\alpha_n&#39;+\alpha_1\alpha_{n-1}&#39;+\cdots+\alpha_n\alpha_0&#39;\)</span>, <span class="math inline">\(\tau_m=\sum\limits_{n=0}^m\gamma_n\)</span>, 则有 <span class="math inline">\(S_m\to s\)</span>, <span class="math inline">\(S_m&#39;\to s&#39;\)</span>.</p><p>于是, <span class="math inline">\(\tau_m=\sum\limits_{n=0}^m\gamma_n=\alpha_0S_m&#39;+\cdots+\alpha_nS_0&#39;=S_ms&#39;+\delta_m\)</span></p><p>其中, <span class="math inline">\(\delta_m=\alpha_0(S_m&#39;-s&#39;)+\alpha_1(S_{m-1}&#39;-s&#39;)+\cdots+\alpha_n(S&#39;-s&#39;)\)</span></p><p>由于 <span class="math inline">\(\{S_m&#39;\}\)</span> 收敛, 故 <span class="math inline">\(\{S_m&#39;\}\)</span> 有界, 故 <span class="math inline">\(\exists~M&gt;0\)</span>, s.t. <span class="math inline">\(\forall~m\in\mathbb{N}\)</span>, <span class="math inline">\(|S_m&#39;-s&#39;|&lt;M\)</span></p><p>又由 <span class="math inline">\(\sum\limits_{n=0}^m\alpha_n\)</span> 绝对收敛, 知 <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, <span class="math inline">\(\exists~N_1\in\mathbb{N}\)</span>, s.t. <span class="math inline">\(\sum\limits_{k=N_1+1}^m|\alpha_k|&lt;\frac{\epsilon}{4M+1}\)</span>.</p><p>再记 <span class="math inline">\(L=\sum\limits_{k=0}^{N_1}|\alpha_k|\)</span>, 同理由 <span class="math inline">\(S_m&#39;\to s&#39;\)</span> 可得 <span class="math inline">\(\exists~N_2\in\mathbb{N}\)</span>, s.t. <span class="math inline">\(\forall~m&gt;N_2\)</span>, <span class="math inline">\(|S_m&#39;-s&#39;|&lt;\frac{\epsilon}{4L+1}\)</span>.</p><p>于是当 <span class="math inline">\(m&gt;N_1+N_2\)</span> 时有: <span class="math display">\[|\delta_m|\leq\sum\limits_{k=0}^m|\alpha_k||S_{m-k}&#39;-s&#39;|+(|\alpha_{N_1}|+\cdots+|\alpha_m|)M\leq\frac{\epsilon}{4L+1}\times L+\frac{\epsilon}{4M+1}&lt;\frac{\epsilon}{2}\]</span></p><p>故: <span class="math display">\[|\tau_m-ss&#39;|=|S_ms&#39;-ss&#39;+\delta_m|\leq |s&#39;||S_m-s|+|\delta_m|&lt;\frac{\epsilon}{2|s&#39;|}|s&#39;|+\frac{\epsilon}{2}=\epsilon\]</span></p><p>即 <span class="math inline">\(\sum\limits_{n=0}^\infty\sum\limits_{k=0}^n\alpha_k\alpha_{n-k}&#39;\)</span> 收敛到 <span class="math inline">\(ss&#39;\)</span>.</p><h3 id="分式线性映射映像区域">分式线性映射映像区域</h3><h4 id="师大复变习题五-5.1">师大复变习题五 5.(1)</h4><blockquote><p>求区域 <span class="math inline">\(\Omega=\{z:{\rm Re}~z&gt;0,{\rm Im}~z&gt;0\}\)</span> 在分式线性映射 <span class="math inline">\(w=\frac{z-i}{z+i}\)</span> 下的映像区域.</p></blockquote><p><strong>解答</strong>: 记 <span class="math inline">\(L_1=\{z:{\rm Im}~z=0\}\)</span>, <span class="math inline">\(L_2=\{z:{\rm Re}~z=0\}\)</span>. 由于 <span class="math inline">\(T(z)=\infty\Leftrightarrow z=-i\)</span>, 并且 <span class="math inline">\(-i\)</span> 在 <span class="math inline">\(L_2\)</span> 上, 不在 <span class="math inline">\(L_1\)</span> 上, 故 <span class="math inline">\(T(L_1)\)</span> 为圆, <span class="math inline">\(T(L_2)\)</span> 为直线.</p><p><strong>一方面</strong>, <span class="math inline">\(T(-i)=\infty\)</span>, <span class="math inline">\(T(i)=0\)</span>, 并且 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(-i\)</span> 关于 <span class="math inline">\(L_1\)</span> 对称, 故 <span class="math inline">\(\infty\)</span> 和 <span class="math inline">\(0\)</span> 关于 <span class="math inline">\(T(L_1)\)</span> 对称. 即 <span class="math inline">\(T(L_1)\)</span> 以 <span class="math inline">\(0\)</span> 为心. 取 <span class="math inline">\(0\in L_1\)</span>, 则有 <span class="math inline">\(T(0)=-1\in T(L_1)\)</span>, 故 <span class="math inline">\(T(L_1)=\{z:|z|=1\}\)</span>.</p><p><strong>另一方面</strong>, <span class="math inline">\(T(-1)=\frac{-1-i}{-1+i}=i\)</span>, <span class="math inline">\(T(1)=-i\)</span>, 故 <span class="math inline">\(T(L_2)\)</span> 为过原点的直线. 取 <span class="math inline">\(0\in L_2\)</span>, 有 <span class="math inline">\(-1\in T(L_2)\)</span>, 即 <span class="math inline">\(T(L_2)\)</span> 为实轴. 取 <span class="math inline">\(1+i\in\Omega\)</span>, 则 <span class="math inline">\(T(1+i)=\frac{1}{1+2i}=\frac{1}{5}-\frac{2}{5}i\in T(\Omega)\)</span>, 即可确定像区域.</p><h3 id="已知原区域和像区域求映射">已知原区域和像区域求映射</h3><h4 id="师大复变习题五-12">师大复变习题五 12</h4><blockquote><p>求把区域 <span class="math inline">\(\{z:|z-3i|&gt;2,~|z-4|&gt;2\}\)</span> 映射为同心圆环 <span class="math inline">\(\{w:1&lt;|w|&lt;R\}\)</span> 的分式线性映射 <span class="math inline">\(w=T(z)\)</span> 并求 <span class="math inline">\(R\)</span>.</p></blockquote><p><strong>解答</strong>: 记 <span class="math inline">\(L_1=\{z:|z-3i|=2\}\)</span>, <span class="math inline">\(L_2=\{z:|z-4|=2\}\)</span>. 由于 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(\infty\)</span> 为 <span class="math inline">\(T(L_1)\)</span> 和 <span class="math inline">\(T(L_2)\)</span> 的公共对称点, 故只需要寻找一对 <span class="math inline">\(L_1\)</span> 和 <span class="math inline">\(L_2\)</span> 的公共对称点. 考虑在圆心连线上寻找, 可以找到 <span class="math inline">\(\frac{4}{5}+\frac{12}{5}i\)</span> 和 <span class="math inline">\(\frac{16}{5}+\frac{3}{5}i\)</span> 为 <span class="math inline">\(L_1\)</span> 和 <span class="math inline">\(L_2\)</span> 的公共对称点.</p><p>于是可令 <span class="math inline">\(T(z)=\lambda\frac{z-\frac{16}{5}-\frac{3}{5}i}{z-\frac{4}{5}-\frac{12}{5}i}=\lambda\frac{5z-16-3i}{5z-4-12i}\)</span>. 此时只差 <span class="math inline">\(\lambda\)</span> 确定表达式. 不妨取 <span class="math inline">\(\{w:|w|=1\}\)</span> 为 <span class="math inline">\(T(L_2)\)</span>, 则 <span class="math inline">\(|T(2)|=1\)</span>, 可得 <span class="math inline">\(|\lambda|\cdot|\frac{10-16-3i}{10-4-12i}|=1\)</span>, 即 <span class="math inline">\(|\lambda|=2\)</span>. 故由 <span class="math inline">\(T(i)=R\)</span> 可知 <span class="math inline">\(|\lambda|\cdot|\frac{5i-16-3i}{5i-4-12i}|=R\)</span>, 即 <span class="math inline">\(R=4\)</span>.</p><p>至此, 映射的放大倍数已经确定, 只需要取一个点来确定方向, 不妨取 <span class="math inline">\(T(2)=-1\)</span>, 则 <span class="math inline">\(\lambda\cdot\frac{-6-3i}{6-12i}=-1\)</span>, 可得 <span class="math inline">\(\lambda=-2i\)</span>. 即 <span class="math inline">\(T(z)=-2i\cdot\frac{5z-16-3i}{5z-4-12i}\)</span>.</p><p>最后一步中, 如不取 <span class="math inline">\(T(2)=-1\)</span>, 则最后所得表达式与原表达式之间相差一个旋转, 映像区域仍然不变.</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 复变函数 </tag>
            
            <tag> 期末复习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2015年复变函数期末考试试卷</title>
      <link href="/2017/06/14/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62015%E5%B9%B4%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7/"/>
      <content type="html"><![CDATA[<h2 id="试题">试题</h2><ol style="list-style-type: decimal"><li>(20分)<ol style="list-style-type: decimal"><li>叙述孤立奇点的定义.</li><li>求下列各函数在复平面 <span class="math inline">\(\mathbb{C}\)</span> (不含 <span class="math inline">\(\infty\)</span> 点)中的孤立奇点, 孤立奇点各属于哪一种类型(极点指明阶数); <span class="math display">\[(a)~\frac{1}{z(z^2+1)^2};~(b)~\frac{e^z-1-z}{z^2(\cos z-1)}~;~(c)\frac{1}{z^3\sin(1/z)}\]</span></li><li>求 (a) 和 (b) 中函数在孤立奇点 <span class="math inline">\(0\)</span> 的留数.</li></ol></li><li><p>(20分) 叙述留数定理并计算下列积分: <span class="math display">\[(1)~\int\nolimits_{|z|=2}\frac{z-6}{z^2(z^2-1)}dz;~(2)\int\nolimits_{-\infty}^{+\infty}\frac{x\sin xdx}{(1+x^2)(4+x^2)}.\]</span></p></li><li><p>(15分)分式线性映射 <span class="math inline">\(w=T(z)=\frac{z-1}{z+1}\)</span> 将区域 <span class="math inline">\(\Omega=\{z:{\rm Re}~z&lt;0,{\rm Im}~z&lt;0\}\)</span> 映射为什么区域？即求 <span class="math inline">\(T(\Omega)=?\)</span> (作图标明原像区域和像区域.)</p></li><li><p>(20分)叙述儒歇(Rouche)定理并求方程 <span class="math inline">\(z^5-5z^2+z+1=0\)</span> 在圆环 <span class="math inline">\(1&lt;|z|&lt;2\)</span> 内根的个数.</p></li><li><p>(15分)设 <span class="math inline">\(f(z)\)</span> 在区域 <span class="math inline">\(\Omega\)</span> 内解析, 且 <span class="math inline">\(|f(z)|\)</span> 在区域 <span class="math inline">\(\Omega\)</span> 内为常数. 试证明 <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 中为常数.</p></li><li>(10分)<ol style="list-style-type: decimal"><li>说明多值函数 <span class="math inline">\((z(1-z)^2)^{\frac{1}{3}}\)</span> 在割去线段 <span class="math inline">\([0,1]\)</span> 的 <span class="math inline">\(z\)</span> 平面上可以分出三个单值解析分支;</li><li>求出在 <span class="math inline">\([0,1]\)</span> 的上沿取正值的那个单值解析分支 <span class="math inline">\(g_0(z)\)</span> 在点 <span class="math inline">\(z=-1\)</span> 处的值 <span class="math inline">\(g_0(-1)=?\)</span>;</li><li>计算积分 <span class="math inline">\(\int\nolimits_0^1\frac{\sqrt[3]{x(1-x)^2}dx}{(1+x)}\)</span>.</li></ol></li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 复变函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2011年概率论期末考试试卷</title>
      <link href="/2017/06/14/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62011%E5%B9%B4%E6%A6%82%E7%8E%87%E8%AE%BA%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7/"/>
      <content type="html"><![CDATA[<h2 id="试题">试题</h2><ol style="list-style-type: decimal"><li>(20分)设某地区成年居民中肥胖者占 <span class="math inline">\(10\%\)</span>, 不胖不瘦者占 <span class="math inline">\(82\%\)</span>, 瘦者占 <span class="math inline">\(8\%\)</span>. 又知道肥胖者患高血压的概率为 <span class="math inline">\(20\%\)</span>, 不胖不瘦者患高血压的概率为 <span class="math inline">\(10\%\)</span>, 瘦者患高血压的概率为 <span class="math inline">\(5\%\)</span>, 试求<ol style="list-style-type: decimal"><li>该地区居民患高血压的概率;</li><li>若知某人患高血压, 则他属于肥胖者的概率有多大?</li></ol></li><li>(20分)设 <span class="math inline">\(\{\xi_i,~i=1,2,\cdots\}\)</span> 为一列独立同分布的随机变量, 它们都服从 <span class="math inline">\([-1,1]\)</span> 上的均匀分布.<ol style="list-style-type: decimal"><li>求 <span class="math inline">\(\xi_1\)</span> 的特征函数;</li><li>设 <span class="math inline">\(\eta\)</span> 服从参数为 <span class="math inline">\(\lambda\)</span> 的Possion分布, 即 <span class="math inline">\(\mathbb{P}(\eta=k)=\frac{\lambda^k}{k!}e^{-\lambda},~k=0,1,2,\cdots\)</span>. 求 <span class="math inline">\(\eta\)</span> 的母函数;</li><li>假定 <span class="math inline">\(\eta_n\)</span> 服从参数为 <span class="math inline">\(3n\)</span> 的Possion分布, 并且与 <span class="math inline">\(\{\xi_i,~i=1,2,\cdots\}\)</span> 相互独立. 证明 <span class="math inline">\(X_n:=\sum\nolimits_{i=1}^{\eta_n}\xi_i\)</span> 的特征函数为 <span class="math inline">\(f_n(x)=e^{3n(\frac{\sin t}{t}-1)}\)</span> (约定 <span class="math inline">\(\sum\nolimits_{i=1}^0\xi_i=0\)</span>).</li><li>证明: 当 <span class="math inline">\(n\to\infty\)</span> 时, <span class="math inline">\(\frac{1}{\sqrt{n}}X_n\stackrel{w}{\rightarrow}N(0,1)\)</span>.</li></ol></li><li>(30分)若 <span class="math inline">\(\xi\sim N(0,\sigma^2)\)</span>,<ol style="list-style-type: decimal"><li>给出 <span class="math inline">\(\xi\)</span> 的特征函数表达式;</li><li>对于 <span class="math inline">\(\forall~b\in\mathbb{R}\)</span>, 证明 <span class="math display">\[\mathbb{P}(\xi=b)=0~\text{或}~1;\]</span></li><li>若 <span class="math inline">\(\vec{\xi}=(\xi_1,\xi_2,\cdots,\xi_n)\sim N(0,A&#39;A)\)</span>, 其中 <span class="math inline">\(A\)</span> 为 <span class="math inline">\(n\times n\)</span> 矩阵, 其 <span class="math inline">\((s,t)\)</span> 位置的元素 <span class="math display">\[a_{st}=   \begin{cases}   1, &amp; s = t - 1 \\   0, &amp; s\neq t - 1   \end{cases}\]</span> 利用 <span class="math inline">\(\xi\)</span> 的特征函数计算 <span class="math inline">\(\vec{\xi}\)</span> 的特征函数;</li><li><span class="math inline">\(\vec{\xi}\)</span> 是 <span class="math inline">\(n\)</span> 维连续型随机变量吗? 证明你的结果;</li><li><span class="math inline">\(\{\xi_n\}_{n=1}^{\infty}\)</span> 满足大数定律吗? 证明你的结果;</li><li><span class="math inline">\(\{\xi_n\}_{n=1}^{\infty}\)</span> 满足中心极限定理吗? 证明你的结果.</li></ol></li><li>(15分)<ol style="list-style-type: decimal"><li>证明依概率收敛的极限在几乎必然的意义下唯一, 即: 若 <span class="math inline">\(\xi_n\stackrel{\mathbb{P}}{\rightarrow}{\xi},~\xi_n\stackrel{\mathbb{P}}{\rightarrow}{\eta}\)</span>, 必有 <span class="math inline">\(\mathbb{P}(\xi=\eta)=1\)</span>;</li><li>设 <span class="math inline">\(\xi\sim N(0,1)\)</span>, 证明: <span class="math inline">\(-\xi\sim N(0,1)\)</span>;</li><li>距离说明: 弱收敛的极限在几乎必然的意义下不唯一, 即: 如果 <span class="math inline">\(\xi_n\stackrel{w}{\rightarrow}{\xi},~\xi_n\stackrel{w}{\rightarrow}{\eta}\)</span>, 未必有 <span class="math inline">\(\mathbb{P}(\xi=\eta)=1\)</span>.</li></ol></li><li>设 <span class="math inline">\(\{\xi_n\}\)</span> 为独立随机变量列, <span class="math inline">\(\mathbb{E}(\xi_n)=0\)</span>, <span class="math inline">\(D(\xi_n)&lt;\infty\)</span>, <span class="math inline">\(n\geqslant 1\)</span>.<ol style="list-style-type: decimal"><li><span class="math inline">\(\forall~\epsilon&gt;0\)</span>, 记 <span class="math inline">\(A_1=\{|S_1|\geq\epsilon\}\)</span>, <span class="math display">\[A_k=\{|S_k|\geq\epsilon\}\cap\left(\bigcap\limits_{k=1}^{k-1}\{|S_j|&lt;\epsilon\}\right),\quad k=2,\cdots,n.\]</span> 证明 <span class="math inline">\(A_1,A_2,\cdots,A_n\)</span> 互不相容;</li><li>证明 <span class="math inline">\(S_n-S_k\)</span> 与 <span class="math inline">\(S_k\chi_{A_k}\)</span> 相互独立, 其中 <span class="math inline">\(\chi_{A_k}\)</span> 表示事件 <span class="math inline">\(A_k\)</span> 的示性函数;</li><li>记 <span class="math inline">\(S_n=\sum\limits_{k=1}^n\xi_k\)</span>, 证明 <span class="math display">\[\mathbb{P}\left(\max_{1\leq k\leq n}|S_k|\geq\epsilon\right)\leq\frac{D(S_n)}{\epsilon^2},\qquad\forall~\epsilon&gt;0.\]</span></li></ol></li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 概率论 </tag>
            
            <tag> 各种试卷 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2016年高等代数期末考试试卷</title>
      <link href="/2017/06/11/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62016%E5%B9%B4%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7/"/>
      <content type="html"><![CDATA[<h2 id="试题">试题</h2><ol style="list-style-type: decimal"><li>(20分)设 <span class="math inline">\(\alpha\)</span> 为 <span class="math inline">\(n\)</span> 维欧氏空间 <span class="math inline">\(V\)</span> 中的一个单位向量, 定义映射 <span class="math display">\[\sigma_\alpha:~V\longrightarrow V,\quad\xi\longmapsto\xi-2(\xi,\alpha)\alpha.\]</span><ol style="list-style-type: decimal"><li>证明 <span class="math inline">\(\sigma_\alpha\)</span> 为一个正交变换. 这样的正交变换称为由 <span class="math inline">\(\alpha\)</span> 定义的镜面反射.</li><li>证明: 存在 <span class="math inline">\(V\)</span> 的规范正交基, 使得 <span class="math inline">\(\sigma_\alpha\)</span> 在这组基下的矩阵为: <span class="math display">\[\begin{bmatrix}-1 &amp; &amp; &amp; \\ &amp; 1 &amp; &amp; \\   &amp; &amp; \ddots &amp; \\    &amp; &amp; &amp; 1 \\  \end{bmatrix}\]</span></li></ol></li><li><p>(10分)设 <span class="math inline">\(A\)</span> 是3阶实对称矩阵，<span class="math inline">\(A\)</span> 的特征值为0, 3, 3. 已知 <span class="math inline">\(\xi_1=(1,1,1)^T,~\xi_2=(-1,1,0)^T\)</span> 分别是属于特征值0和3的特征向量. 求属于特征值3的与 <span class="math inline">\(\xi_2\)</span> 线性无关的另一个特征向量 <span class="math inline">\(\xi_3\)</span>.</p></li><li>(20分)设3元实二次型 <span class="math display">\[q(x_1,x_2,x_3)=2x_1^2+x_2^2-4x_1x_2-4x_2x_3.\]</span><ol style="list-style-type: decimal"><li>求 <span class="math inline">\(q\)</span> 的秩和正惯性指数.</li><li>求一个正交替换，将 <span class="math inline">\(q\)</span> 化为典范形.</li></ol></li><li>(20分)设矩阵 <span class="math display">\[A=\begin{bmatrix}2 &amp; 0 &amp; 0 \\0 &amp; 2 &amp; 0 \\1 &amp; 0 &amp; 2 \\ \end{bmatrix}\]</span><ol style="list-style-type: decimal"><li>分别求 <span class="math inline">\(A\)</span> 的特征多项式和最小多项式.</li><li>矩阵 <span class="math inline">\(A\)</span> 能否对角化？如不能, 求出它的若尔当标准型.</li></ol></li><li><p>(15分)设 <span class="math inline">\(q(x_1,x_2,\cdots,x_n)=x^TAx\)</span> 是一实二次型, 其中 <span class="math inline">\(A=(a_{ij})\)</span> 是 <span class="math inline">\(n\)</span> 阶实对称矩阵. 设 <span class="math inline">\(\lambda\)</span> 与 <span class="math inline">\(\mu\)</span> 分别是 <span class="math inline">\(A\)</span> 的最大与最小特征值. 证明: 对于 <span class="math inline">\(\mathbf{R}^n\)</span> 中任一列向量 <span class="math inline">\(\alpha\)</span>, 有 <span class="math display">\[\mu|\alpha|^2\leqslant\alpha^TA\alpha\leqslant\lambda|\alpha|^2.\]</span></p></li><li><p>(15分)证明: 如果 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 都是 <span class="math inline">\(n\)</span> 阶实对称矩阵, 并且 <span class="math inline">\(A\)</span> 正定, 那么存在 <span class="math inline">\(n\)</span> 阶实可逆矩阵 <span class="math inline">\(P\)</span>, 使得 <span class="math inline">\(P^TAP\)</span> 和 <span class="math inline">\(P^TBP\)</span> 都是对角矩阵.</p></li></ol><h2 id="简略解答">简略解答</h2><ol style="list-style-type: decimal"><li>一定记得先验证它是一个线性变换, 再验证其正交性, 否则会丢掉4分.</li><li>早就不记得了, 其余全略.</li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2017年复变函数期中考试试卷</title>
      <link href="/2017/06/11/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62017%E5%B9%B4%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E6%9C%9F%E4%B8%AD%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7/"/>
      <content type="html"><![CDATA[<h2 id="试题">试题</h2><ol style="list-style-type: decimal"><li><p>(20分)设 <span class="math inline">\(z_1,z_2\)</span> 是任意两个复数, 证明 <span class="math display">\[|z_1+z_2|^2+|z_1-z_2|^2=2(|z_1|^2+|z_2|^2),\]</span> 并说明其几何意义(画图说明).</p></li><li><p>(20分)叙述函数 <span class="math inline">\(f(z)=u(x,y)+iv(x,y)\)</span> 在一点的(复)可微和解析的定义且讨论函数 <span class="math inline">\(f(z)=x^2y+ixy^2\)</span> 的(复)可微性和解析性(在何处(复)可微和解析).</p></li><li><p>(25分)将函数 <span class="math inline">\(\frac{z}{z^2+8z+20}\)</span> 按 <span class="math inline">\(z+4\)</span> 的幂展出, 并指出其收敛半径.</p></li><li>(25分)在下了区域中, 哪些区域存在 <span class="math inline">\(\sqrt{(z^2-1)(z^2-4)}\)</span> 的解析分支？请说明理由.<ol style="list-style-type: decimal"><li><span class="math inline">\(\mathbb{C}\backslash((-\infty,-1]\cup[1,+\infty))\)</span>;</li><li><span class="math inline">\(\mathbb{C}\backslash[-2,2]\)</span>;</li><li><span class="math inline">\(\mathbb{C}\backslash([-2,-1]\cup[1,2))\)</span>;</li><li><span class="math inline">\(\mathbb{C}\backslash((-\infty,-2]\cup[-1,2))\)</span>.</li></ol></li><li><p>(10分)设 <span class="math inline">\(\Omega\)</span> 为平面上的一个非空区域(区域 <span class="math inline">\(\Omega\)</span> 是连通开集, <span class="math inline">\(\Omega\)</span> 中任意两点可以用曲线连接), 如果 <span class="math inline">\(D\subset\Omega\)</span>, <span class="math inline">\(D\)</span> 是一个非空开集且 <span class="math inline">\(D\neq\Omega\)</span>, 证明存在 <span class="math inline">\(D\)</span> 的边界点 <span class="math inline">\(c\in\partial\Omega\)</span> 满足 <span class="math inline">\(c\in\Omega\)</span>.</p></li></ol><h2 id="粗略解答">粗略解答</h2><ol style="list-style-type: decimal"><li>显然. 几何意义: 平行四边形四边的平方和等于对角线的平方和.</li><li>由C-R方程可知, 函数只在原点可微, 处处不解析.</li><li>拆成分式即可直接展开，此处只列出前几项以供参考: <span class="math display">\[-1+\frac{x+4}{4}+\frac{1}{4} (x+4)^2-\frac{1}{16} (x+4)^3-\frac{1}{16} (x+4)^4+\frac{1}{64} (x+4)^5+O\left((x+4)^6\right).\]</span></li><li>(1)存在, (2)存在, (3)不存在, (4)存在.</li><li>证明从略.</li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 复变函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mathematica学习[2]——修改输入和输出字体</title>
      <link href="/2017/05/09/Mathematica%E6%8A%80%E5%B7%A7%5B2%5D%E2%80%94%E2%80%94%E4%BF%AE%E6%94%B9%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E5%AD%97%E4%BD%93/"/>
      <content type="html"><![CDATA[<p><code>Mathematica</code> 自带的修改字体功能似乎并没有什么用……如果想修改的话，需要手动运行代码修改。代码分为两部分</p><h2 id="函数定义">函数定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">setFont[fontFamily_, fontSize_] := With[</span><br><span class="line">    &#123;</span><br><span class="line">        styleNB = Notebook[</span><br><span class="line">            &#123;</span><br><span class="line">                Cell[StyleData[StyleDefinitions -&gt; &quot;Default.nb&quot;]],</span><br><span class="line">                Cell[StyleData[&quot;StandardForm&quot;],</span><br><span class="line">                FontFamily -&gt; ToString[fontFamily],</span><br><span class="line">                FontSize -&gt; ToExpression[fontSize]]</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        styleSheetName = FileNameJoin[</span><br><span class="line">            &#123;</span><br><span class="line">                $UserBaseDirectory, </span><br><span class="line">                &quot;SystemFiles&quot;, </span><br><span class="line">                &quot;FrontEnd&quot;, </span><br><span class="line">                &quot;StyleSheets&quot;, </span><br><span class="line">                &quot;myStyle.nb&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    If[</span><br><span class="line">    FileExistsQ[styleSheetName], </span><br><span class="line">    SetOptions[$FrontEnd,</span><br><span class="line">    DefaultStyleDefinitions -&gt; &quot;Default.nb&quot;]</span><br><span class="line">    ];</span><br><span class="line">    Export[styleSheetName, styleNB];</span><br><span class="line">    SetOptions[$FrontEnd, DefaultStyleDefinitions -&gt; styleSheetName]</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="函数运行">函数运行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setFont[&quot;字体名称&quot;, 字体大小]</span><br><span class="line">比如：</span><br><span class="line">setFont[&quot;Consolas&quot;, 12]</span><br><span class="line">或者</span><br><span class="line">setFont[&quot;Monaco&quot;, 13]</span><br></pre></td></tr></table></figure><h2 id="用法">用法</h2><p>将以上函数和运行的代码粘贴进一个<code>.nb</code>文档，运行即可修改字体。</p>]]></content>
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> Mathematica </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>几篇TOEFL独立写作范文</title>
      <link href="/2017/04/13/%E5%87%A0%E7%AF%87TOEFL%E7%8B%AC%E7%AB%8B%E5%86%99%E4%BD%9C%E8%8C%83%E6%96%87/"/>
      <content type="html"><![CDATA[<h2 id="第一篇">第一篇</h2><p>In such a competitive society with ceaseless changes, there is a heated debate of the most fundamental factor of keeping close bond with people we love. Obviously, opinions vary from person to person in accordance with their inner preference. After a scrupulous assessment, I would render my support to spending time with them as much as possible.</p><p>To begin with, regarding the potential harm brought by being apart from the closest people, to say that moving far away is crucial for everyone to attach importance to valuable relationships is an exaggeration. Admittedly, whenever we step into a totally unfamiliar cultural background, it is likely that we would suffer in nostalgia and feel it hard to adapt to new environment immediately, which allows us to realize the indispensable role they play in our life. However, when analyzing this issue from an objective angle, we would find that the benefits caused by getting away from our parents are dwarfed by its negative influences. Even if the technological development enables us to keep in touch with our friends and families across a long distance, there are still emotional feelings and genuine expressions that cannot be discerned by others through the Internet.</p><p>In addition, compared with living in a great distance, spending time together provides a greater opportunity for us to enhance our mutual relationship much more effectively. Living in a fast paced society, young generation has been suffered overwhelming pressure from daily work and intensive study, which means that hardly can they squeeze time to accompany their families and friends. As a result, they will definitely treasure the scarce chance of holiday to have fun with their beloved friends and relatives. For instance, in Spring Festival in China, which is one of the most grandeur festivals for Chinese people, not only will people set off firecrackers to celebrate the important moment, but also they can share the latest information with each other and enjoy the harmonious atmosphere together. Consequently, it would benefit their relationship in the long run.</p><p>Last but not least, living with our close friends or families together paves a good way for us to give them cares and unconditioned help, so that we would not regret for not standing besides them in their darkest time. Numerous people post their regretful comments on Facebook because of their families death and their absence in their tough times. There is no denying that facing challenges together and forming a unity fortress are the most effective ways to establish the solid relationships in everyone's life. Since during the process of figuring out best solutions, we are likely to stand in others shoes to analyze problems and get deeper understanding of others. Generally speaking, people tend to cherish those friends who lend them a hand whenever they are stuck in dilemma.</p><p>In conclusion, considering the details mentioned above, it is a better choice for us to take time to accompany people who are important to us, instead of being far away from them. (498)</p><h2 id="第二篇">第二篇</h2><p>独立写作题目：Do you agree or disagree with the following statement? Workers would be much happier if they are doing different types of tasks at the same time than doing the same task. </p><p>范文立场选择：Disagree</p><h3 id="opening-60-100-words">Opening (60-100 Words)</h3><h4 id="intro">Intro</h4><p>Reasonable schedule arrangement and patient handling of each task demonstrate a person’s overall potential in his career. Especially in such a society with intensive competition, working pressures urge employees to devote much to the fulfillment of numerous projects. Therefore, some people would like to do several projects at a time for adjusting to a stressful working condition. </p><h4 id="thesis">Thesis</h4><p>However, as far as I am concerned, finishing one task completely then to another should be more efficient because attentiveness is crucial to the performance of any projects. </p><h3 id="body-120-150-words">Body (120-150 Words)</h3><h4 id="topic">Topic</h4><p>Last but not least, the focus of attention determines the final result of a project and is immediately related to working quality.</p><h4 id="state">State</h4><p>Doing several projects at the same time might divert attentiveness and may also undermine the general progress subsequently.</p><h4 id="e.g.">e.g.</h4><p>To illustrate, in the field of architecture which I am majoring in, there is sufficient evidence to show that treating each progress, from scheme design to construction documentation, with attention continually might keep each step more efficient and prepare more fruitful outcomes in the upcoming phase. In other words, it is more reliable for an architect to finish one design and then proceed to the next as well as an unnecessary mix-up of various programs can be a drag on the whole plan. </p><h4 id="close">Close</h4><p>It is no exaggeration to say that stopping one temporarily and changing to others might incur some undesirable accidents.</p><h2 id="第三篇">第三篇</h2><p>Facing the fierce competition in modern society, the pursuit for the success has been the essence of the education. There are multiple choices to promote students' academic performance and accomplish final goals for students. Personally speaking, I would regard receiving support from families and friends as the most important element to be an elite.</p><p>First and foremost, modern society has witnessed that the career of private tutorship is developing at an alarming rate recently. Admittedly, knowledgeable advisors enable students to enlarge their knowledge base. However, this solution should be not considered as a wise choice. After all, parents and friends are the ones who know us best, because they have experienced every moment of our life with us. No matter what dilemma students are trapped in, it is their closest friends and families who are able to render solid support and lead them step out of woods. What's more, considering the crucial role played by parents and friends, hiring private advisors would turn out to be a huge drain of parents' money.</p><p>In addition, it is admitted that attending high school is an imperative factor, which defines students' educational background and shapes their value. However, it is less rigorous to say that high school education holds the key to accomplish one's dream. Tracing back to our childhood, whenever we were stuck in a disappointed situation, only if our parents spotted our anomaly, there is no doubt that they would reach out to us and have a deep conversation with us. All they want to do was to encourage us to step out of the shade with a positive attitude and embrace the bright life bravely. Comparatively speaking, high school teachers are only aiming at the promotion of students' grades. Hardly can they teach students in accordance with their aptitude.</p><p>Last but not least, unconditional support of our families and friends constitutes the steppingstone towards further achievement. No one can substitute their imperative position in our life. For instance, after graduation from high school, not until I packed up my baggage and went abroad for study did I realize how important it is to master fundamental skills, such as financial management, car maintenance and cooking by myself, all of which are taught by my mother. Also, living in a foreign and unfamiliar environment is a huge challenge faced by international students, including me. However, in the darkest and hardest time, my friends always make video call through the convenient Internet, which enables me to receive their warm greetings and erase the severe nostalgia. It is because of their love that I have enough strength and faith to rise above the obstacles.</p><p>In conclusion, with respect to the most effective factor of success, nothing can be compared with the generous love and care from our families and beloved friends. (467)</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
            <tag> TOEFL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LaTeX技巧[1]——打生僻字</title>
      <link href="/2017/04/04/LaTeX%E6%8A%80%E5%B7%A7%5B2%5D%E2%80%94%E2%80%94%E6%89%93%E7%94%9F%E5%83%BB%E5%AD%97/"/>
      <content type="html"><![CDATA[<h2 id="几句废话">几句废话</h2><p>按照惯例还是要来一两句废话的。</p><p>作为一个名字里边有“喆”字的人，经常面临着打不出来“喆”字的问题，比如在使用 xeCJK 包时，就面临着无法直接输入“喆”字的问题，非常坑爹。</p><p>幸好有些办法搞定……</p><h2 id="左右结构的生僻字">左右结构的生僻字</h2><p>既然打不出来“喆”，那“吉”总可以搞定吧，那我打两个一半宽度的“吉”不就好了吗？</p><p>实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\hbox&#123;\resizebox&#123;1.1ex&#125;&#123;1.8ex&#125;&#123;吉&#125;&#125;\hbox&#123;\resizebox&#123;1.1ex&#125;&#123;1.8ex&#125;&#123;吉&#125;&#125;</span><br></pre></td></tr></table></figure><p>其中的高度和宽度可以自行调整。</p><p>类似“喆”的左右结构的生僻字都可以用这种方法解决。</p>]]></content>
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LaTeX技巧[2]——修改数学公式字体</title>
      <link href="/2017/04/04/LaTeX%E6%8A%80%E5%B7%A7%5B1%5D%E2%80%94%E2%80%94%E4%BF%AE%E6%94%B9%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%AD%97%E4%BD%93/"/>
      <content type="html"><![CDATA[<h2 id="几句废话">几句废话</h2><p><span class="math inline">\(\LaTeX\)</span> 的公式环境总的来说不难看，但同一个字体看的次数多了，也难免审美疲劳。加上有些环境下编译的时候字体也比较难看，所以了解一下怎么修改公式的字体就是必须的了。</p><h2 id="修改方法">修改方法</h2><p><span class="math inline">\(\LaTeX\)</span> 中修改公式字体的方法就是把对应的包加上就可以了，我用过的不错的字体有以下几种：</p><h3 id="mathptmx">Mathptmx</h3><p><strong>设置方法</strong>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\usepackage&#123;amsmath&#125;</span><br><span class="line">\usepackage&#123;amssymb&#125;</span><br><span class="line">\usepackage&#123;mathptmx&#125;</span><br><span class="line">\usepackage&#123;bm&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><div class="figure"><img src="http://static.zybuluo.com/lzcwr/byvnq0i9n5z08k52qby9jf2g/image_1bcq9rkcm1e1e18v3s5aiu337l9.png" alt="image_1bcq9rkcm1e1e18v3s5aiu337l9.png-21.5kB"><p class="caption">image_1bcq9rkcm1e1e18v3s5aiu337l9.png-21.5kB</p></div><h3 id="fourier">Fourier</h3><p>别把这个和傅里叶联系起来哈……虽然好像确实是傅里叶。。</p><p><strong>设置方法</strong>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\usepackage&#123;amsmath&#125;</span><br><span class="line">\usepackage&#123;amssymb&#125;</span><br><span class="line">\usepackage&#123;fourier&#125;</span><br><span class="line">\usepackage&#123;bm&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><div class="figure"><img src="http://static.zybuluo.com/lzcwr/byn049o08zgpwt3i7qwqr5eo/image_1bcq9v8ll3g192i8n7kvi1c9jm.png" alt="image_1bcq9v8ll3g192i8n7kvi1c9jm.png-20.9kB"><p class="caption">image_1bcq9v8ll3g192i8n7kvi1c9jm.png-20.9kB</p></div><h3 id="eulervm">Eulervm</h3><p><strong>设置方法</strong>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\usepackage&#123;amsmath&#125;</span><br><span class="line">\usepackage&#123;amssymb&#125;</span><br><span class="line">\usepackage&#123;ccfonts&#125;</span><br><span class="line">\usepackage[euler-digits]&#123;eulervm&#125;</span><br><span class="line">\usepackage&#123;bm&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><div class="figure"><img src="http://static.zybuluo.com/lzcwr/wnn2y9xvridffmxvepsfauqt/image_1bcqa813i155614ba12h11hk0n2u13.png" alt="image_1bcqa813i155614ba12h11hk0n2u13.png-23kB"><p class="caption">image_1bcqa813i155614ba12h11hk0n2u13.png-23kB</p></div><h2 id="参考资料">参考资料</h2><ul><li><a href="http://blog.sina.com.cn/s/blog_5e16f1770100g593.html" target="_blank" rel="noopener">LaTeX技巧86：常用的数学公式字体（含代码）一</a></li></ul>]]></content>
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>组合杂题</title>
      <link href="/2017/03/21/%E7%BB%84%E5%90%88%E6%9D%82%E9%A2%98/"/>
      <content type="html"><![CDATA[<h2 id="年03月21日">2017年03月21日</h2><h3 id="保险箱问题">保险箱问题</h3><p>这个题是老师在课上提出来的，比较有意思，随手记录一下.</p><blockquote><p><span class="math inline">\(6\)</span> 个人共用一个保险箱，要求任意 <span class="math inline">\(3\)</span> 人在一起时都可以打开保险箱，并且最少需要 <span class="math inline">\(3\)</span> 人才能打开. 请问至少需要多少把锁？每个人至少需要多少把钥匙？</p></blockquote><p><strong>解答</strong>：先估计一个锁数量的下界. 由题意，每 <span class="math inline">\(2\)</span> 个人都不能打开该保险箱， 故每 <span class="math inline">\(2\)</span> 个人都至少有一把不能打开的锁，且对于不同的两人组，不能打开的锁互不相同，故锁的数量不能少于 <span class="math inline">\(2\)</span> 元子集的个数，即 <span class="math inline">\(\binom{6}{2}=15\)</span>.</p><p>再考虑钥匙的数量. 由于任意 <span class="math inline">\(3\)</span> 个人都能打开保险箱，故每个人都需要有<strong>不包括自己的所有二人组所没有的钥匙</strong>，即每个人至少要有 <span class="math inline">\(\binom{5}{2}=10\)</span> 把钥匙.</p><p>以上只是对于下界的估计，要证明其最小性还需构造一组情况来证明最小值可以取到. 构造很容易，不多赘述.</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一些概率论题目</title>
      <link href="/2017/03/10/%E4%B8%80%E4%BA%9B%E6%A6%82%E7%8E%87%E8%AE%BA%E9%A2%98%E7%9B%AE/"/>
      <content type="html"><![CDATA[<h2 id="几句废话">几句废话</h2><p>本来觉得概率论是比较简单的课，学了几节课才知道原来简单的是别人家的概率论...我们自家的概率论其实很蛋疼...据刘伟说他当时概率论分比较低...弱菜非常恐慌...于是便在学习中顺便整理一下给自己启发的题目. 由于教材采用师大版概率论（李勇 主编），故题目大多来自于该书.</p><h2 id="年03月10日">2017年03月10日</h2><h3 id="师大概率论-练习-1.2.4">师大概率论 练习 1.2.4</h3><blockquote><p>甲乙两人抛硬币，甲抛 <span class="math inline">\(n+1\)</span> 枚，乙抛 <span class="math inline">\(n\)</span> 枚，求甲的正面比乙多的概率.</p></blockquote><p><strong>解答</strong>：考虑甲乙都抛 <span class="math inline">\(n\)</span> 枚硬币的情形，设甲正面比乙多的概率为 <span class="math inline">\(p\)</span>，则由对称性可知，乙比甲正面多的概率也为 <span class="math inline">\(p\)</span>. 故两人正面一样多的概率为 <span class="math inline">\(1-2p\)</span>. 再考虑甲抛的第 <span class="math inline">\(n+1\)</span> 枚硬币，有 <span class="math inline">\(\frac{1}{2}\)</span> 概率为正面，<span class="math inline">\(\frac{1}{2}\)</span> 为反面，则有如下讨论：</p><ul><li>若都抛 <span class="math inline">\(n\)</span> 枚时，甲比乙正面多，则无论甲的第 <span class="math inline">\(n+1\)</span> 枚为正面还是反面，甲的正面都会比乙多. 该情况出现的概率为 <span class="math inline">\(p_1=p\times1=p\)</span>；</li><li>若都抛 <span class="math inline">\(n\)</span> 枚时，甲比乙正面少，则无论甲的第 <span class="math inline">\(n+1\)</span> 枚为正面还是反面，甲的正面都无法比乙多. 该情况出现的概率为 <span class="math inline">\(p_2=p\times1=p\)</span>；</li><li>若都抛 <span class="math inline">\(n\)</span> 枚时，甲乙正面一样多，且甲的第 <span class="math inline">\(n+1\)</span> 枚为正面，甲的正面就会比乙多. 该情况出现的概率为 <span class="math inline">\(p_3=\frac{1-2p}{2}\times\frac{1}{2}\)</span>；</li><li>若都抛 <span class="math inline">\(n\)</span> 枚时，甲乙正面一样多，且甲的第 <span class="math inline">\(n+1\)</span> 枚为正面，甲的正面就会比乙少. 该情况出现的概率为 <span class="math inline">\(p_3=\frac{1-2p}{2}\times\frac{1}{2}\)</span>.</li></ul><p>以上情况中，第一种和第三种出现时，甲的正面会比乙多，否则不会. 故甲正面比乙多的概率为 <span class="math inline">\(p_1+p_3=\frac{1}{2}\)</span>.</p><hr><p>兔子提出了一种很好玩儿的解答.</p><p><strong>解答</strong>：甲抛 <span class="math inline">\(n+1\)</span> 枚，乙抛 <span class="math inline">\(n\)</span> 枚，只可能有两种情况出现：</p><ul><li>甲的正面比乙多；</li><li>甲的反面比乙多.</li></ul><p>两种情况不会同时发生，并且概率和为 <span class="math inline">\(1\)</span>，又由对称性可知两种情况出现的概率相同，故都为 <span class="math inline">\(\frac{1}{2}\)</span>.</p><h3 id="师大概率论-练习-1.2.9">师大概率论 练习 1.2.9</h3><blockquote><p>在单位圆周上任取三点 <span class="math inline">\(A,B,C\)</span>，试求事件 <span class="math inline">\(E=\{\triangle ABC\text{成锐角三角形}\}\)</span> 的概率.</p></blockquote><p><strong>解答</strong>：设 <span class="math inline">\(\triangle ABC\)</span> 的三个内角分别为 <span class="math inline">\(x,y,z\)</span>，则能构成三角形的条件为：</p><p><span class="math display">\[x+y+z=\pi\qquad x,y,z&gt;0\]</span></p><p>在三维坐标系中，“能构成三角形”所对应的样本空间为一个三角形，三个顶点分别为 <span class="math inline">\(D(0,0,\pi),E(0,\pi,0),F(0,0,\pi)\)</span>. 而能构成锐角三角形的条件为：</p><p><span class="math display">\[x+y+z=\pi\qquad 0&lt;x,y,z&lt;\frac{\pi}{2}\]</span></p><p>也会构成一个三角形，三个顶点分别为 <span class="math inline">\(G(0,\frac{\pi}{2},\frac{\pi}{2}),H(\frac{\pi}{2},0,\frac{\pi}{2}),I(\frac{\pi}{2},\frac{\pi}{2},0)\)</span>. 于是 <span class="math inline">\(\triangle ABC\)</span> 为锐角三角形的概率为 <span class="math inline">\(\frac{S_{\triangle GHI}}{S_{\triangle DEF}}=\frac{1}{4}\)</span> .</p><h2 id="年03月22日">2017年03月22日</h2><h3 id="师大概率论-练习-2.1.7">师大概率论 练习 2.1.7</h3><blockquote><p>设 <span class="math inline">\(\mathbb{P}(A)+\mathbb{P}(B)=1\)</span>，证明 <span class="math inline">\(\mathbb{P}(AB)=\mathbb{P}(\overline{A}\overline{B})\)</span>.</p></blockquote><p><strong>证明</strong>：由于事件“<strong><span class="math inline">\(A,B\)</span> 中有且仅有一个发生</strong>”和事件“<strong><span class="math inline">\(A,B\)</span> 中有且仅有一个不发生</strong>”是相同的事件，故其概率也应该相同.</p><p>由容斥原理，事件“<span class="math inline">\(A,B\)</span> 中至少有一个发生”的概率为 <span class="math inline">\(\mathbb{P}(A\cup B)=\mathbb{P}(A)+\mathbb{P}(B)-\mathbb{P}(AB)\)</span>.</p><p>故事件“<strong><span class="math inline">\(A,B\)</span> 中有且仅有一个发生</strong>”的概率为 <span class="math inline">\(\mathbb{P}(A)+\mathbb{P}(B)-\mathbb{P}(AB)\)</span>.</p><p>同理，事件“<span class="math inline">\(A,B\)</span> 中至少有一个不发生”的概率为 <span class="math inline">\(\mathbb{P}(\overline{A}\cup\overline{B})=\mathbb{P}(\overline{A})+\mathbb{P}(\overline{B})-\mathbb{P}(\overline{A}\overline{B})\)</span>.</p><p>故事件“<span class="math inline">\(A,B\)</span> 中有且仅有一个不发生”的概率为 <span class="math inline">\(\mathbb{P}(\overline{A})+\mathbb{P}(\overline{B})-\mathbb{P}(\overline{A}\overline{B})\)</span>.</p><p>于是有，<span class="math display">\[\mathbb{P}(A)+\mathbb{P}(B)-\mathbb{P}(AB)=\mathbb{P}(\overline{A})+\mathbb{P}(\overline{B})-\mathbb{P}(\overline{A}\overline{B}).\]</span></p><p>又由于 <span class="math inline">\(\mathbb{P}(A)+\mathbb{P}(B)=1\)</span>，故 <span class="math inline">\(\mathbb{P}(\overline{A})+\mathbb{P}(\overline{B})=1\)</span>，故有：<span class="math display">\[\mathbb{P}(AB)=\mathbb{P}(\overline{A}\overline{B}).\]</span></p><h2 id="年03月25日">2017年03月25日</h2><h3 id="师大概率论-练习-2.3.2">师大概率论 练习 2.3.2</h3><blockquote><p>试证明事件 <span class="math inline">\(A_1,A_2,\cdots,A_n\)</span> 相互独立的充要条件为：对每个事件 <span class="math inline">\(\hat{A}_{k}=A_k\)</span> 或者 <span class="math inline">\(\overline{A_k}(k=1,2,\cdots,n)\)</span>，总有 <span class="math display">\[\mathbb{P}(\hat{A}_{1}\hat{A}_{2}\cdots\hat{A}_{n})=\mathbb{P}(\hat{A}_{1})\mathbb{P}(\hat{A}_{2})\cdots\mathbb{P}(\hat{A}_{n}).\]</span></p></blockquote><p><strong>证明</strong>：显然 <span class="math inline">\(n=2\)</span> 时成立.</p><p>假设 <span class="math inline">\(n=k\)</span> 时结论成立，则有：</p><p><strong>必要性</strong>：令 <span class="math inline">\(B=A_k\cap A_{k+1}\)</span>，则 <span class="math inline">\(A_1,A_2,\cdots,A_{k-1},B\)</span> 相互独立. 于是有</p><p><span class="math display">\[\mathbb{P}(\hat{A}_{1}\hat{A}_{2}\cdots\hat{A}_{n-1}\hat{B})=\mathbb{P}(\hat{A}_{1})\mathbb{P}(\hat{A}_{2})\cdots\mathbb{P}(\hat{A}_{n-1})\mathbb{P}(\hat{B}).\]</span></p><p>即</p><p><span class="math display">\[\mathbb{P}(\hat{A}_{1}\hat{A}_{2}\cdots\hat{A}_{n-1}A_k A_{k+1})=\mathbb{P}(\hat{A}_{1})\mathbb{P}(\hat{A}_{2})\cdots\mathbb{P}(\hat{A}_{n-1})\mathbb{P}(A_k)\mathbb{P}(A_{k+1}).\]</span></p><p>同理也有：</p><p><span class="math display">\[\mathbb{P}(\hat{A}_{1}\hat{A}_{2}\cdots\hat{A}_{n-1}\overline{A_k} A_{k+1})=\mathbb{P}(\hat{A}_{1})\mathbb{P}(\hat{A}_{2})\cdots\mathbb{P}(\hat{A}_{n-1})\mathbb{P}(\overline{A_k})\mathbb{P}(A_{k+1}).\]</span></p><p><span class="math display">\[\mathbb{P}(\hat{A}_{1}\hat{A}_{2}\cdots\hat{A}_{n-1}A_k \overline{A_{k+1}})=\mathbb{P}(\hat{A}_{1})\mathbb{P}(\hat{A}_{2})\cdots\mathbb{P}(\hat{A}_{n-1})\mathbb{P}(A_k)\mathbb{P}(\overline{A_{k+1}}).\]</span></p><p><span class="math display">\[\mathbb{P}(\hat{A}_{1}\hat{A}_{2}\cdots\hat{A}_{n-1}\overline{A_k} \overline{A_{k+1}})=\mathbb{P}(\hat{A}_{1})\mathbb{P}(\hat{A}_{2})\cdots\mathbb{P}(\hat{A}_{n-1})\mathbb{P}(\overline{A_k})\mathbb{P}(\overline{A_{k+1}}).\]</span></p><p>即有 <span class="math inline">\(\mathbb{P}(\bigcap\limits_{i=1}^{k+1}\hat{A}_{i})=\prod\limits_{i=1}^{k+1}\mathbb{P}(\hat{A}_{i})\)</span>. 必要性得证.</p><p><strong>充分性</strong>：对于 <span class="math inline">\(\forall~1&lt;s&lt;k+1\)</span>，<span class="math inline">\(\forall~1\leq i_1&lt;i_2&lt;\cdots&lt;i_s\leq k+1\)</span>，由条件，对于 <span class="math inline">\(\forall~j\)</span> s.t. <span class="math inline">\(1\leq j\leq k+1\)</span> 且 <span class="math inline">\(j\notin\{i_1,i_2,\cdots,i_s\}\)</span>，总有：</p><p><span class="math display">\[\mathbb{P}(\hat{A}_{1}\cdots\hat{A}_{j-1}A_j\hat{A}_{j+1}\cdots\hat{A}_{k+1})=\mathbb{P}(\hat{A}_{1})\cdots\mathbb{P}(\hat{A}_{j-1})\mathbb{P}(A_j)\mathbb{P}(\hat{A}_{j+1})\cdots\mathbb{P}(\hat{A}_{k+1})\]</span></p><p>且</p><p><span class="math display">\[\mathbb{P}(\hat{A}_{1}\cdots\hat{A}_{j-1}\overline{A_j}\hat{A}_{j+1}\cdots\hat{A}_{k+1})=\mathbb{P}(\hat{A}_{1})\cdots\mathbb{P}(\hat{A}_{j-1})\mathbb{P}(\overline{A_j})\mathbb{P}(\hat{A}_{j+1})\cdots\mathbb{P}(\hat{A}_{k+1})\]</span></p><p>由于 <span class="math inline">\(\mathbb{P}(A_j)+\mathbb{P}(\overline{A_j})=1\)</span>，将以上两式相加即得：</p><p><span class="math display">\[\mathbb{P}(\hat{A}_{1}\cdots\hat{A}_{j-1}\hat{A}_{j+1}\cdots\hat{A}_{k+1})=\mathbb{P}(\hat{A}_{1})\cdots\mathbb{P}(\hat{A}_{j-1})\mathbb{P}(\hat{A}_{j+1})\cdots\mathbb{P}(\hat{A}_{k+1})\]</span></p><p>式中共有 <span class="math inline">\(k\)</span> 个事件，故由假设可知这 <span class="math inline">\(k\)</span> 个事件相互独立. 又由于 <span class="math inline">\(\{\hat{A}_{i_1},\cdots,\hat{A}_{i_s}\}\subset\{\hat{A}_{1},\cdots,\hat{A}_{k+1}\}\)</span>，故有 <span class="math inline">\(\mathbb{P}(\bigcap\limits_{j=1}^{s}A_{i_j})=\prod\limits_{j=1}^{s}\mathbb{P}(A_{i_j})\)</span>，<span class="math inline">\(\forall~1\leq i_1&lt;\cdots&lt;i_s\leq k+1\)</span>. 充分性得证.</p><p><strong>综上所述</strong>，原命题成立.</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 概率论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一些实变函数题目</title>
      <link href="/2017/03/09/%E4%B8%80%E4%BA%9B%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0%E9%A2%98%E7%9B%AE/"/>
      <content type="html"><![CDATA[<h2 id="符号说明">符号说明</h2><p><span class="math inline">\(m^*(E)\)</span> 表示 <span class="math inline">\(E\)</span> 的外测度; <span class="math inline">\(m(E)\)</span> 表示 <span class="math inline">\(E\)</span> 的测度.</p><h2 id="年03月09日">2017年03月09日</h2><h3 id="习题1-第一组-7">习题1 第一组 7</h3><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 是定义在 <span class="math inline">\([0,1]\)</span> 上的实值函数, 且存在常数 <span class="math inline">\(M\)</span>, 使得对于 <span class="math inline">\([0,1]\)</span> 中的任意有限个数 <span class="math inline">\(x_1,x_2,\cdots,x_n\)</span>, 均有 <span class="math inline">\(\vert f(x_1)+f(x_2)+\cdots+f(x_n)\vert\leqslant M\)</span>, 试证下述集合是可数集: <span class="math display">\[E=\{x\in[0,1]~\vert~f(x)\neq0\}\]</span></p></blockquote><p><strong>证明</strong>: 考虑如下的两族集合:</p><p><span class="math display">\[A_n=\{x\in[0,1]~\vert~f(x)&gt;\frac{1}{n}\}\]</span> <span class="math display">\[B_n=\{x\in[0,1]~\vert~f(x)&lt;-\frac{1}{n}\}\]</span></p><p>则有:</p><p><span class="math display">\[E=\bigcup_{n=1}^\infty\{x\in[0,1]~\vert~\vert f(x)\vert&gt;\frac{1}{n}\}=\bigcup_{n=1}^\infty(A_n\cup B_n)\]</span></p><p>而对于 <span class="math inline">\(A_n\)</span>, 任取其中的 <span class="math inline">\(p\)</span> 个数 <span class="math inline">\(x_1,x_2,\cdots,x_p\)</span>, 均有:</p><p><span class="math display">\[p\times\frac{1}{n}&lt;\vert f(x_1)+f(x_2)+\cdots+f(x_n)\vert\leqslant M\]</span></p><p>于是有 <span class="math inline">\(p&lt;nM\)</span>, 即 <span class="math inline">\(\forall~n\)</span>, <span class="math inline">\(A_n\)</span> 只含有限个数. 同理 <span class="math inline">\(\forall~n\)</span>, <span class="math inline">\(B_n\)</span> 也只含有限个数. 故 <span class="math inline">\(\forall~n\)</span>, <span class="math inline">\(A_n\cup B_n\)</span> 只含有限个数. 于是 <span class="math inline">\(E\)</span> 为可数个有限集合的并, 故 <span class="math inline">\(E\)</span> 是可数集.</p><h3 id="习题1-第一组-12">习题1 第一组 12</h3><blockquote><p>设 <span class="math inline">\(E=\bigcup\limits_{n=1}^\infty A_n\)</span>. 若 <span class="math inline">\(\vert E\vert=\aleph\)</span>, 试证明 <span class="math inline">\(\exists~n_0\)</span>, s.t. <span class="math inline">\(\vertA_{n_0}\vert=\aleph\)</span>.</p></blockquote><p><strong>证明</strong>: 显然 <span class="math inline">\(\forall~n\)</span>, <span class="math inline">\(\vertA_n\vert\leqslant\aleph\)</span>. 若 <span class="math inline">\(\forall~n\)</span>, <span class="math inline">\(\vertA_n\vert&lt;\aleph\)</span>, 则每个 <span class="math inline">\(A_n\)</span> 都是至多可数集. 即 <span class="math inline">\(E\)</span> 为至多可数个至多可数集的并集, 即 <span class="math inline">\(E\)</span> 至多可数, 与 <span class="math inline">\(\vert E\vert=\aleph\)</span> 矛盾. 故 <span class="math inline">\(\exists~n_0\)</span>, s.t. <span class="math inline">\(\vert A_{n_0}\vert=\aleph\)</span>.</p><h3 id="习题1-第一组-13">习题1 第一组 13</h3><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 是定义在 <span class="math inline">\(\mathbf{R}^1\)</span> 上的单调上升函数, 试证明点集 <span class="math display">\[E=\{x:\forall~\epsilon&gt;0,~f(x+\epsilon)-f(x-\epsilon)&gt;0\}\]</span> 是 <span class="math inline">\(\mathbf{R}^1\)</span> 中的闭集.</p></blockquote><p><strong>证明</strong>: 考虑 <span class="math inline">\(\forall~x\in E&#39;\)</span>, <span class="math inline">\(\exists~\{x_n\}\subset E\)</span>, s.t. <span class="math inline">\(\lim\limits_{n\to\infty}x_n=x\)</span>. 故 <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, <span class="math inline">\(\exists~N\)</span>, s.t. <span class="math inline">\(\forall~n&gt;N\)</span>, <span class="math inline">\(\vert x-x_n\vert&lt;\frac{\epsilon}{2}\)</span>. 于是由条件有 <span class="math inline">\(f(x_{N+1}+\frac{\epsilon}{2})-f(x_{N+1}-\frac{\epsilon}{2})&gt;0\)</span>, 由 <span class="math inline">\(f\)</span> 的单调性, 有 <span class="math display">\[(f(x+\epsilon)-f(x-\epsilon))-(f(x_{N+1}+\frac{\epsilon}{2})-f(x_{N+1}-\frac{\epsilon}{2}))&gt;0\]</span> 即 <span class="math inline">\(x\in E\)</span>. 故 <span class="math inline">\(E\)</span> 为闭集.</p><h3 id="习题1-第一组-14">习题1 第一组 14</h3><blockquote><p>设 <span class="math inline">\(F\subset\mathbf{R}^n\)</span> 为有界闭集, <span class="math inline">\(E\)</span> 是 <span class="math inline">\(F\)</span> 中的一个无限子集, 试证明: <span class="math inline">\(E&#39;\cap F\neq\varnothing\)</span>. 反之, 若 <span class="math inline">\(F\subset\mathbf{R}^n\)</span> 且对 <span class="math inline">\(F\)</span> 中任一无限子集 <span class="math inline">\(E\)</span>, 有 <span class="math inline">\(E&#39;\cap F\neq\varnothing\)</span>, 试证明 <span class="math inline">\(F\)</span> 是有界闭集.</p></blockquote><p><strong>证明</strong>: 一方面, 由于 <span class="math inline">\(E\subset F\)</span>, 故 <span class="math inline">\(E\)</span> 中存在收敛子列, 故 <span class="math inline">\(E&#39;\neq\varnothing\)</span>. 由于 <span class="math inline">\(F\)</span> 是有界闭集, 故 <span class="math inline">\(E&#39;\subset F&#39;\subset F\)</span>, 于是 <span class="math inline">\(E&#39;\cap F\neq\varnothing\)</span>. 另一方面, <strong>首先证明 <span class="math inline">\(F\)</span> 是闭集</strong>: <span class="math inline">\(\forall~x\in F&#39;\)</span>, <span class="math inline">\(\exists~E=\{x_n\}_{n=1}^{+\infty}\subset F\)</span>, s.t. <span class="math inline">\(\lim\limits_{n\to\infty}x_n=x\)</span>, 即 <span class="math inline">\(E&#39;=\{x\}\)</span>. 又由于 <span class="math inline">\(\forall~E\subset F\)</span>, 均有 <span class="math inline">\(E&#39;\cap F\neq\varnothing\)</span>, 故 <span class="math inline">\(x\in F\)</span>, 即 <span class="math inline">\(F\)</span> 为闭集. <strong>其次证明 <span class="math inline">\(F\)</span> 有界</strong>: 若 <span class="math inline">\(F\)</span> 无界, 则任取 <span class="math inline">\(E\)</span> 为 <span class="math inline">\(F\)</span> 中的发散序列, 即可得到 <span class="math inline">\(E&#39;=\varnothing\)</span>, 此时显然有 <span class="math inline">\(E&#39;\cap F=\varnothing\)</span>, 矛盾. 故 <span class="math inline">\(F\)</span> 有界. <strong>综上</strong>, <span class="math inline">\(F\)</span> 有界闭集.</p><h3 id="习题1-第一组-15">习题1 第一组 15</h3><blockquote><p>设 <span class="math inline">\(F\subset\mathbf{R}^n\)</span> 为闭集, <span class="math inline">\(r&gt;0\)</span>, 证明点集: <span class="math display">\[E=\{t\in\mathbf{R^n}:~\exists~x\in F,~\vertt-x\vert=r\}\]</span> 是闭集.</p></blockquote><p><strong>证明</strong>: <span class="math inline">\(\forall~t\in E&#39;\)</span>, <span class="math inline">\(\exists~\{t_n\}_{n=1}^{+\infty}\subset E\)</span>, s.t. <span class="math inline">\(\lim\limits_{n\to\infty}t_n=t\)</span>, 由 <span class="math inline">\(E\)</span> 的定义: <span class="math inline">\(\forall~n\)</span>, <span class="math inline">\(\exists~x_n\in F\)</span>, s.t. <span class="math inline">\(\vert t_n-x_n\vert=r\)</span>. 由于 <span class="math inline">\(\{t_n\}\)</span> 是收敛子列, 故 <span class="math inline">\(\{t_n\}\)</span> 有界, 于是 <span class="math inline">\(\{x_n\}\)</span> 也是有界数列, 故 <span class="math inline">\(\{x_n\}\)</span> 有收敛子列, 不妨设为 <span class="math inline">\(\{x_{n_k}\}\)</span>. 取 <span class="math inline">\(x=\lim\limits_{k\to\infty}x_{n_k}\)</span>, 则有 <span class="math inline">\(\vert t-x\vert=r\)</span>, 并且 <span class="math inline">\(x\in F\)</span>（由 <span class="math inline">\(F\)</span> 是闭集可知）, 即 <span class="math inline">\(t\in E\)</span>. 即 <span class="math inline">\(E\)</span> 是闭集.</p><h2 id="年03月15日">2017年03月15日</h2><h3 id="习题1-第一组-25">习题1 第一组 25</h3><blockquote><p>设 <span class="math inline">\(f:\mathbf{R}\to\mathbf{R}\)</span>, 令$G_1= \{ (x,y):~y<f(x) \\}="" $,="" $g_2="\\{" (x,y):~y="">f(x) \} $, 试证明 <span class="math inline">\(f\in C(\mathbf{R})\)</span> 当且仅当 <span class="math inline">\(G_1\)</span> 与 <span class="math inline">\(G_2\)</span> 是开集.</f(x)></p></blockquote><p><strong>证明</strong>: <strong>必要性</strong>是显然的, 以下证明<strong>充分性</strong>:</p><p>假设 <span class="math inline">\(f\notin C(\mathbf{R})\)</span>, 则 <span class="math inline">\(\exists~x_0\in\mathbf{R}\)</span>, <span class="math inline">\(\epsilon&gt;0\)</span>, 和 <span class="math inline">\(x_n\)</span>, 满足 <span class="math inline">\(\vert x_n-x_0\vert&lt;\frac{1}{n}\)</span>, 但 <span class="math inline">\(\vert f(x_n)-f(x_0)\vert\geqslant\epsilon\)</span>. 不妨设 <span class="math inline">\(f(x_n)\geqslant f(x_0)+\epsilon\)</span>, 则 <span class="math inline">\((x_n,f(x_0)+\epsilon)\in G_2^c\)</span>. 由于满足条件的 <span class="math inline">\(x_n\)</span> 构成数列 <span class="math inline">\(\{x_n\}\)</span> 且满足 <span class="math inline">\(\lim\limits_{n\to\infty}x_n=x_0\)</span>, 故 <span class="math inline">\(\lim\limits_{n\to\infty}(x_n,f(x_0)+\epsilon)=(x_0,f(x_0)+\epsilon)\)</span>, 又由 <span class="math inline">\(G_2\)</span> 为开集可知 <span class="math inline">\(G_2^c\)</span> 为闭集. 即有 <span class="math inline">\((x_0,f(x_0)+\epsilon)\in G_2^c\)</span>. 故 <span class="math inline">\(f(x_0)\geqslant f(x_0)+\epsilon\)</span>, 矛盾. 故 <span class="math inline">\(f\in C(\mathbf{R})\)</span>.</p><p><strong>综上</strong>, <span class="math inline">\(f\in C(\mathbf{R})\Longleftrightarrow G_1,~G_2\)</span> 为开集.</p><h3 id="证明完全集是不可数集">证明完全集是不可数集</h3><p>这个题目完全是在做周《实变函数论》1.5 的 思考题1 时相到的, <span class="math inline">\(n=2\)</span> 的情况可以参考周《实变函数论》1.5 的 例23.</p><blockquote><p>已知 <span class="math inline">\(E\subset\mathbf{R}^n\)</span> 为完全集, 证明 <span class="math inline">\(E\)</span> 不可数.</p></blockquote><p><strong>证明</strong>: 假设 <span class="math inline">\(E\)</span> 是可数集, 令 <span class="math inline">\(E=\{x_1,x_2,\cdots,x_n\}\)</span>. 则可如下构造一个开球列 <span class="math inline">\(\{B_n\}\)</span>:</p><ol style="list-style-type: decimal"><li>取 <span class="math inline">\(B_1=B(x_1,r_1)\subset E\)</span>, 则 <span class="math inline">\(\exists~x_{k_1}\in E\)</span>, s.t. <span class="math inline">\(x_{k_1}\in B_1\)</span>, 但 <span class="math inline">\(\forall~i\)</span>, s.t. <span class="math inline">\(2\leqslant i\leqslant k_1-1\)</span>, 均有 <span class="math inline">\(x_i\notin E\)</span>;</li><li>取 <span class="math inline">\(B_1=B(x_{k_1},r_2)\)</span>, s.t. <span class="math inline">\(B_2\subset B_1\)</span>, 且 <span class="math inline">\(r_2&lt;\frac{r_1}{2}\)</span>, 则 <span class="math inline">\(\exists~x_{k_2}\in E~(k_2&gt;k_1)\)</span>, s.t. <span class="math inline">\(x_{k_2}\in B_2\)</span>, 但 <span class="math inline">\(\forall~i\)</span>, s.t. <span class="math inline">\(k_1+1\leqslant i\leqslant k_2-1\)</span>, 均有 <span class="math inline">\(x_i\notin E\)</span>;</li><li><span class="math inline">\(\cdots\cdots\)</span></li><li>取 <span class="math inline">\(B_n=B(x_{k_{n-1}},r_n)\)</span>, s.t. <span class="math inline">\(B_n\subset B_{n-1}\)</span>, 且 <span class="math inline">\(r_n&lt;\frac{r_{n-1}}{2}\)</span>, 则 <span class="math inline">\(\exists~x_{k_n}\in E~(k_n&gt;k_{n-1})\)</span>, s.t. <span class="math inline">\(x_{k_n}\in B_n\)</span>, 但 <span class="math inline">\(\forall~i\)</span>, s.t. <span class="math inline">\(k_{n-1}+1\leqslant i\leqslant k_n-1\)</span>, 均有 <span class="math inline">\(x_i\notin E\)</span>;</li></ol><p>考虑 <span class="math inline">\(\{B_n\}\)</span> 的闭包构成的集合列 <span class="math inline">\(\{\overline{B_n}\}\)</span>, 显然有 <span class="math inline">\(\lim\limits_{n\to\infty}\vert\overline{B_n}\vert=0\)</span>, 即 <span class="math inline">\(\{\overline{B_n}\}\)</span> 形成了一个闭集套, 令 <span class="math inline">\(\bigcap\limits_{n=1}^\infty\overline{B_n}=\{a\}\)</span>.</p><p>则应有 <span class="math inline">\(a\in E\)</span>, 而由 <span class="math inline">\(\{B_n\}\)</span> 的定义可知 <span class="math inline">\(a\notin E\)</span>, 矛盾. 故 <span class="math inline">\(E\)</span> 为不可数集.</p><h3 id="习题1-第一组-26">习题1 第一组 26</h3><blockquote><p>设 <span class="math inline">\(\mathbf{R}\)</span> 中的一切开集构成的集合族为 <span class="math inline">\(\mathscr{G}\)</span>, 证明 <span class="math inline">\(\vert\mathscr{G}\vert=\aleph\)</span>. （<span class="math inline">\(\vert\mathscr{G}\vert\)</span> 表示 <span class="math inline">\(\mathscr{G}\)</span> 的基数）.</p></blockquote><p><strong>证明</strong>: <strong>一方面</strong>, 令 <span class="math inline">\(\mathscr{A}=\{(0,x)~\vert~x\in\mathbf{R}\}\)</span>, 则 <span class="math inline">\(\vert\mathscr{A}\vert\subset\mathscr{G}\)</span>, 且 <span class="math inline">\(\vert\mathscr{A}\vert=\aleph\)</span>. 故 <span class="math inline">\(\vert\mathscr{G}\vert\geqslant\aleph\)</span>.</p><p><strong>另一方面</strong>, 设 <span class="math inline">\(E\)</span> 为 <span class="math inline">\(\mathbf{R}\)</span> 中以有理数为端点的开区间的全体, 则由 <span class="math inline">\(E\subset\mathbf{Q}^2\)</span> 可知 <span class="math inline">\(E\)</span> 为可数集, 于是有 <span class="math inline">\(\vert\mathscr{P}(E)\vert=\aleph\)</span>.</p><p>由于 <span class="math inline">\(\mathbf{R}\)</span> 中的每个开区间都可以表示为可数个有理开区间的并, 故对于 <span class="math inline">\(G\in\mathscr{G}\)</span>, 设 <span class="math inline">\(G=\bigcup\limits_{n=1}^\infty(\alpha_n,\beta_n)\)</span>, 其中 <span class="math inline">\((\alpha_n,\beta_n)\in E\)</span>. 据此可构造如下映射:</p><p><span class="math display">\[\varphi:~\mathscr{P}(E)\longrightarrow\mathscr{G},\quad\{(\alpha_n,\beta_n)\}_{n=1}^{+\infty}\longmapsto G~.\]</span></p><p>由于数列的极限唯一, 故 <span class="math inline">\(\varphi\)</span> 是良好定义的, 又由于 <span class="math inline">\(G\)</span> 的逼近方法不唯一, <span class="math inline">\(\overline{\mathbf{Q}}=\mathbf{R}\)</span>, 故 <span class="math inline">\(\varphi\)</span> 为满射但不为单射. 故 <span class="math inline">\(\vert\mathscr{G}\vert\leqslant\vert\mathscr{P}(E)\vert=\aleph\)</span>.</p><p><strong>综上</strong>, <span class="math inline">\(\vert\mathscr{G}\vert=\aleph\)</span>.</p><h2 id="年03月27日">2017年03月27日</h2><h3 id="思考题-2-ii">2.1 思考题 2 (ii)</h3><blockquote><p>设 <span class="math inline">\(A,B,C\)</span> 是 <span class="math inline">\(\mathbf{R}^n\)</span> 中的点集, 且有 <span class="math display">\[m^*(A\triangle B)=m^*(B\triangle C)=0\]</span> 求证 <span class="math inline">\(m^*(A\triangle C)=0\)</span>.</p></blockquote><p><strong>证明</strong>: 注意到 <span class="math display">\[A\backslash C=(A\cap C^c)\cap(B\cup B^c)=[A\cap (B\backslash C)]\cup[C^c\cap(A\backslash B)]\]</span> 又由条件有 <span class="math display">\[m^*(A\backslash B)=m^*(B\backslash A)=m^*(B\backslash C)=m^*(C\backslash B)=0\]</span> 可以很容易地得到 <span class="math inline">\(m^*(A\backslash C)=0\)</span>, 类似可得 <span class="math inline">\(m^*(C\backslash A)=0\)</span>, 故 <span class="math inline">\(m^*(A\triangle C)=0\)</span>.</p><h3 id="思考题-3">2.1 思考题 3</h3><blockquote><p>设 <span class="math inline">\(E\subset\mathbf{R}^n\)</span>, 若对于 <span class="math inline">\(\forall~x\in E\)</span>, 总存在开球 <span class="math inline">\(B(x,\delta_x)\)</span>, 使得 <span class="math inline">\(m^*(E\cap B(x,\delta_x))=0\)</span>, 试证明 <span class="math inline">\(m^*(E)=0\)</span>.</p></blockquote><p><strong>证明</strong>: 有条件, 存在一个开球族 <span class="math inline">\(\mathscr{B}\)</span>, s.t. <span class="math inline">\(x\in E\)</span>, 并且 <span class="math inline">\(E=\bigcup\limits_{B_x\in\mathscr{B}}(E\cap B_x)\)</span>. 可以取适当的 <span class="math inline">\(\delta_x\)</span>, 使得 <span class="math inline">\(B\)</span> 中的开球两两不相交, 此时 <span class="math inline">\(\mathscr{B}\)</span> 为 <span class="math inline">\(\mathbf{R}^n\)</span> 中互不相交的开集族, 即 <span class="math inline">\(\mathscr{B}\)</span> 至多可数, 且 <span class="math inline">\(\forall~B_x\in\mathscr{B}\)</span>, 总有 <span class="math inline">\(m^*(B_x\cap E)=0\)</span>.</p><p>故由测度的 <span class="math inline">\(\sigma\)</span>-可加性, <span class="math inline">\(m^*(E)=\sum\limits_{B_x\in\mathscr{B}}m^*(E\cap B_x)=0\)</span>.</p><p><strong>这个证法是错误的……以后再修改</strong></p><p>(翻到一个叫 <strong>lindelof 定理</strong> 的东西……这个题目好像就是定理的直接推论.）</p><h3 id="思考题-2">2.2 思考题 2</h3><blockquote><p>设 <span class="math inline">\(\{A_n\}\)</span> 是互不相交的可测集列, <span class="math inline">\(B_n\subset A_n~(n=1,2,\cdots)\)</span>, 证明: <span class="math display">\[m^*\left(\bigcup\limits_{n=1}^\infty B_n\right)=\sum\limits_{n=1}^\infty m^*(B_n).\]</span></p></blockquote><p><strong>证明</strong>: 由于 <span class="math inline">\(m^*\left(\bigcup\limits_{n=1}^\infty B_n\right)\leqslant\sum\limits_{n=1}^\infty m^*(B_n)\)</span> 显然成立, 故只需证明 <span class="math display">\[m^*\left(\bigcup\limits_{n=1}^\infty B_n\right)\geqslant\sum\limits_{n=1}^\infty m^*(B_n).\]</span></p><p>对于有限项的 <span class="math inline">\(B_k\)</span>, 由于 <span class="math inline">\(B_k\)</span> 两两不交, 由外测度的定义有 <span class="math display">\[\sum\limits_{k=1}^n m^*(B_k)=m^*\left(\bigcup\limits_{k=1}^n B_k\right).\]</span></p><p>显然 <span class="math inline">\(m^*\left(\bigcup\limits_{k=1}^n B_k\right)\)</span> 对于 <span class="math inline">\(n\)</span> 显然是递增集合列, 故对上式取极限可得:</p><p><span class="math display">\[\sum\limits_{k=1}^n m^*(B_k)=m^*\left(\bigcup\limits_{k=1}^n B_k\right)\leqslant m^*\left(\bigcup\limits_{k=1}^\infty B_k\right).\]</span></p><p>即有 <span class="math inline">\(\forall~n\in\mathbf{N}\)</span>, 均有 <span class="math display">\[\sum\limits_{k=1}^n m^*(B_k)\leqslant m^*\left(\bigcup\limits_{k=1}^\infty B_k\right),\]</span></p><p>对上式左侧也取极限, 有 <span class="math display">\[\sum\limits_{k=1}^\infty m^*(B_k)\leqslant m^*\left(\bigcup\limits_{k=1}^\infty B_k\right).\]</span> 即结论成立.</p><h3 id="思考题-3-1">2.2 思考题 3</h3><blockquote><p>设有点集 <span class="math inline">\(E_1,E_2\)</span>, 且 <span class="math inline">\(E_1\in\mathscr{M}\)</span>. 若 <span class="math inline">\(m(E_1\triangle E_2)=0\)</span>, 求证 <span class="math inline">\(E_2\in\mathscr{M}\)</span>, 且 <span class="math inline">\(m(E_1)=m(E_2)\)</span>.</p></blockquote><p><strong>证明</strong>: 考虑 <span class="math inline">\(E_2=[E_1\backslash(E_1\backslash E_2)]\cup(E_2\backslash E_1)\)</span>, 则易得结论.</p><h2 id="年04月20日">2017年04月20日</h2><h3 id="思考题-4">2.2 思考题 4</h3><blockquote><p>设点集 <span class="math inline">\(B\)</span> 满足: 对于 <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, <span class="math inline">\(\exists~A\in\mathscr{M}\)</span>, s.t. <span class="math inline">\(m^*(A\triangle B)&lt;\epsilon\)</span>, 试证明 <span class="math inline">\(B\)</span> 是可测集.</p></blockquote><p><strong>证明</strong>: 由条件, <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, <span class="math inline">\(\exists~\{A_k\}_{k=1}^{+\infty}\subset\mathscr{M}\)</span>, s.t. <span class="math inline">\(m^*(B\triangle A_k)&lt;\frac{\epsilon}{2^k}\)</span>, (<span class="math inline">\(k\in\mathbf{N})\)</span>.</p><p>故 <span class="math inline">\(m^*(B\backslash A_k)&lt;\frac{\epsilon}{2^k}\)</span>, 且 <span class="math inline">\(m^*(A_k\backslash B)&lt;\frac{\epsilon}{2^k}\)</span>.</p><p>令 <span class="math inline">\(A=\bigcup\limits_{k=1}^{\infty}A_k\)</span>, 则由任意 <span class="math inline">\(A_k\)</span> 均为可测集可知, <span class="math inline">\(A\)</span> 为可测集.</p><p>又有 <span class="math inline">\(B\backslash A=\bigcap\limits_{k=1}^{\infty}(B\backslash A_k)\)</span>, <span class="math inline">\(A\backslash B=\bigcap\limits_{k=1}^{\infty}(A_k\backslash B)\)</span>, 故 <span class="math inline">\(m^*(B\backslash A)\leqslant m^*(B\backslash A_k)\)</span>, 且 <span class="math inline">\(m^*(A\backslash B) \leqslant\sum\limits_{k=1}^{\infty}m^*(A_k\backslash B)\)</span>.</p><p>故 <span class="math inline">\(m^*(B\backslash A)\leqslant\frac{\epsilon}{2^k}\)</span>, <span class="math inline">\(m^*(A\backslash B)\leqslant\sum\limits_{k=1}^{\infty}\frac{\epsilon}{2^k}=\epsilon\)</span>, 即 <span class="math inline">\(m^*(A\backslash B)=m^*(B\backslash A)=0\)</span>.</p><p>于是 <span class="math inline">\(A\backslash B\)</span> 和 <span class="math inline">\(B\backslash A\)</span> 可测. 故由 <span class="math inline">\(B=(B\backslash A)\cup(A\backslash(A\backslash B))\)</span>, 故 <span class="math inline">\(B\)</span> 为可测集.</p><h3 id="思考题-8">2.2 思考题 8</h3><blockquote><p>设有 <span class="math inline">\(\mathbf{R}^1\)</span> 中可测集列 <span class="math inline">\(\{E_k\}\)</span>, 且当 <span class="math inline">\(k\geqslant k_0\)</span> 时, <span class="math inline">\(E_k\subset[a,b]\)</span>. 若存在 <span class="math inline">\(\lim\limits_{k\to\infty}E_k=E\)</span>, 试证明: <span class="math inline">\(m(E)=\lim\limits_{k\to\infty}m(E_k)\)</span>.</p></blockquote><p><strong>证明</strong>: <strong>一方面</strong>, 由于 <span class="math inline">\(\varlimsup\limits_{k\to\infty}E_k=\bigcap\limits_{j=1}^{\infty}\bigcup\limits_{k=j}^{\infty}E_k=\lim\limits_{k\to\infty}(\bigcup\limits_{j=k}^{\infty}E_j)\)</span>.</p><p>故 <span class="math inline">\(m\left(\varlimsup\limits_{k\to\infty}E_k\right)=m\left(\lim\limits_{k\to\infty}(\bigcup\limits_{j=k}^{\infty}E_j)\right)\geqslant\varlimsup\limits_{k\to\infty}m(E_k)\)</span>.</p><p>又由于 <span class="math inline">\(\{E_k\}\)</span> 收敛, 故有:</p><p><span class="math display">\[m(E)=m(\lim\limits_{k\to\infty}E_k)=m(\varlimsup\limits_{k\to\infty}E_k)\geqslant\varlimsup\limits_{k\to\infty}m(E_k)\geqslant\lim\limits_{k\to\infty}m(E_k).\]</span></p><p>即 <span class="math inline">\(m(E)\geqslant\lim\limits_{k\to\infty}m(E_k)\)</span>.</p><p><strong>另一方面</strong>, <span class="math inline">\(\varliminf\limits_{k\to\infty}E_k=\bigcup\limits_{j=1}^{\infty}\bigcap\limits_{k=j}^{\infty}E_k=\lim\limits_{k\to\infty}(\bigcup\limits_{j=k}^{\infty}E_j)\)</span>.</p><p>故 <span class="math inline">\(m\left(\varliminf\limits_{k\to\infty}E_k\right)=m\left(\lim\limits_{k\to\infty}(\bigcap\limits_{j=k}^{\infty}E_j)\right)\leqslant\varliminf\limits_{k\to\infty}m(E_k)\)</span>.</p><p>故 <span class="math inline">\(m(E)\leqslant\varliminf\limits_{k\to\infty}m(E_k)\leqslant\lim\limits_{k\to\infty}m(E_k)\)</span>.</p><p><strong>综上所述</strong>, <span class="math inline">\(m(E)=\lim\limits_{k\to\infty}m(E_k)\)</span>.</p><h2 id="年04月24日">2017年04月24日</h2><h3 id="习题2-第一组-8">习题2 第一组 8</h3><blockquote><p>设 <span class="math inline">\(\{E_k\}\)</span> 是 <span class="math inline">\([0,1]\)</span> 中的可测集列, <span class="math inline">\(m(E_k)=1\)</span>, <span class="math inline">\((k=0,1,\cdots)\)</span>, 试证明: <span class="math inline">\(m\left(\bigcap\limits_{k=1}^{\infty}E_k\right)=1\)</span>.</p></blockquote><p><strong>证明</strong>: 由于 <span class="math inline">\(\{E_k\}\)</span> 可测, 且 <span class="math inline">\(m(E_k)=1\)</span>, <span class="math inline">\(\forall~k\in\mathbf{N}_+\)</span>, 又 <span class="math inline">\(E_k\subset[0,1]\)</span>, 故 <span class="math inline">\(m([0,1]\backslash E_k)=0\)</span>, <span class="math inline">\(\forall~k\in\mathbf{N}_+\)</span>.</p><p>于是 <span class="math display">\[m\left(\bigcap\limits_{k=1}^{\infty}E_k\right)=1-\left([0,1]\backslash\bigcap\limits_{k=1}^{\infty}E_k\right)=1-\left(\bigcup\limits_{k=1}^{\infty}([0,1]\backslash E_k)\right)=1-\sum\limits_{k=1}^{\infty}m([0,1]\backslash E_k)=1.\]</span></p><p>又由于 <span class="math inline">\(m(\bigcap\limits_{k=1}^{\infty}E_k)\leqslant m(E_1)=1\)</span>, 故 <span class="math inline">\(m\left(\bigcap\limits_{k=1}^{\infty}E_k\right)=1\)</span>.</p><h3 id="习题2-第一组-11">习题2 第一组 11</h3><blockquote><p>设 <span class="math inline">\(\{B_\alpha\}_{\alpha\in I}\)</span> 是 <span class="math inline">\(\mathbf{R}^n\)</span> 中一族开球, 记 <span class="math inline">\(G=\bigcup\limits_{\alpha\in I}B_\alpha\)</span>. 若有 <span class="math inline">\(0&lt;\lambda&lt;m(G)\)</span>, 试证明存在有限个互不相交的开球 <span class="math inline">\(B_{\alpha_1},B_{\alpha_2},\cdots,B_{\alpha_m}\)</span>, 使得 <span class="math inline">\(\sum\limits_{k=1}^m m(B_{\alpha_k})\)</span> 大于 <span class="math inline">\(\frac{\lambda}{3^n}.\)</span></p></blockquote><p><strong>证明</strong>: 取紧集 <span class="math inline">\(K\subset G\)</span>, s.t. <span class="math inline">\(m(K)&gt;\lambda\)</span>, 则 <span class="math inline">\(\{B_\alpha\}\)</span> 构成 <span class="math inline">\(K\)</span> 的一个开覆盖. 于是存在有限子覆盖 <span class="math inline">\(B_1,B_2\cdots,B_k\)</span>.</p><p>取其中半径最大者为 <span class="math inline">\(B_{\alpha_1}\)</span>, 则将 <span class="math inline">\(B_{\alpha_1}\)</span> 的半径扩大三倍即可将 <span class="math inline">\(B_i\)</span> 中所有与 <span class="math inline">\(B_{\alpha_1}\)</span> 相交的开球全部覆盖;</p><p>再取 <span class="math inline">\(B_i\)</span> 中与 <span class="math inline">\(B_{\alpha_1}\)</span> 不相交的球中半径最大者为 <span class="math inline">\(B_{\alpha_2}\)</span>, 则将其半径扩大三倍即可将与其相交的开球全部覆盖.</p><p>如此继续下去可以选出有限个开球 <span class="math inline">\(B_{\alpha_1},B_{\alpha_2}\cdots,B_{\alpha_m}\)</span>, s.t. 将其中的每一个球半径扩大三倍可以构成 <span class="math inline">\(K\)</span> 的覆盖.</p><p>于是 <span class="math inline">\(\sum\limits_{i=1}^m 3^n\times m(B_{\alpha_i})&gt;\lambda\)</span>, 即 <span class="math inline">\(\sum\limits_{k=1}^m m(B_{\alpha_k})&gt;\frac{\lambda}{3^n}\)</span>, 原命题得证.</p><h2 id="年04月25日">2017年04月25日</h2><h3 id="习题2-第一组-12">习题2 第一组 12</h3><blockquote><p>设 <span class="math inline">\(\{B_k\}\)</span> 是 <span class="math inline">\(\mathbf{R}^n\)</span> 中递减可测集列, <span class="math inline">\(m^*(A)&lt;\infty\)</span>. 令 <span class="math inline">\(E_k=A\cap B_k~(k=0,1,\cdots)\)</span>, <span class="math inline">\(E=\bigcap\limits_{k=1}^\infty E_k\)</span>, 试证明 <span class="math display">\[\lim\limits_{k\to\infty}m^*(E_k)=m^*(E).\]</span></p></blockquote><p><strong>证明</strong>: 令 <span class="math inline">\(A\)</span> 的等测包为 <span class="math inline">\(H\)</span>, 则 <span class="math inline">\(\{B_k\cap H\}\)</span> 为递减可测集列.</p><p>于是 <span class="math inline">\(\lim\limits_{k\to\infty} m(H\cap B_k)=m\left(\lim\limits_{k\to\infty}(H\cap B_k)\right)=m\left((\bigcap\limits_{k=1}^\infty B_k)\cap H\right)\)</span>.</p><p>而对于 <span class="math inline">\(\forall~k\)</span>, <span class="math inline">\(m(H\cap B_k)-m\left(\bigcap\limits_{k=1}^\infty(H\cap B_k)\cap H\right)=m\left((H\cap B_k)\backslash\bigcap\limits_{k=1}^\infty(H\cap B_k)\right)\)</span>.</p><p>又由于 <span class="math inline">\(H\)</span> 和 <span class="math inline">\(B_k\)</span> 均为可测集, 故 <span class="math inline">\(m\left((H\cap B_k)\backslash\bigcap\limits_{k=1}^\infty(H\cap B_k)\right)=m^*\left((H\cap B_k)\backslash\bigcap\limits_{k=1}^\infty(H\cap B_k)\right)\)</span>.</p><p>即 <span class="math inline">\(m(H\cap B_k)-m\left(\bigcap\limits_{k=1}^\infty(H\cap B_k)\right)=m^*\left((H\cap B_k)\backslash\bigcap\limits_{k=1}^\infty(H\cap B_k)\right)\)</span>.</p><p>由于 <span class="math inline">\(A\subset H\)</span>, 故 <span class="math display">\[\begin{align}m(H\cap B_k)-m\left(\bigcap\limits_{k=1}^\infty(H\cap B_k)\right) &amp;\geqslant m^*\left(A\cap (B_k\backslash\bigcap\limits_{k=1}^{\infty}B_k)\right) \\ &amp;= m^*\left((A\cap B_k) \backslash \bigcap\limits_{k=1}^{\infty}(A\cap B_k)\right) \\ &amp;= m^*(E_k\backslash\bigcap\limits_{k=1}^{\infty} E_k) = m^*(E_k\backslash E) \\ &amp;\geqslant m^*(E_k)-m^*(E).\end{align}\]</span></p><p>由于 <span class="math inline">\(E_k\)</span> 递减, 故 <span class="math inline">\(m^*(E_k)\geqslantm^*(E)\)</span>, <span class="math inline">\(\forall~k\in\mathbf{N}_+\)</span>, 即 <span class="math inline">\(m^*(E_k)-m^*(E)\geqslant 0\)</span>.</p><p>又由于 <span class="math inline">\(\lim\limits_{k\to\infty}\left(m(H\cap B _k)-m(\bigcap\limits_{k=1}^{\infty}(H\cap B_k)\right)=0\)</span>.</p><p>故 <span class="math inline">\(\lim\limits_{k\to\infty}m^*(E_k)-m^*(E)=0\)</span>, 即 <span class="math inline">\(\lim\limits_{k\to\infty}m^*(E_k)=m^*(E)\)</span>.</p><h2 id="年04月26日">2017年04月26日</h2><h3 id="习题2-第一组-14">习题2 第一组 14</h3><blockquote><p>试证明点集 <span class="math inline">\(E\)</span>　可测的充要条件是: 对任意 <span class="math inline">\(\epsilon&gt;0\)</span>, 存在开集 <span class="math inline">\(G_1,G_2\)</span>: <span class="math display">\[G_1\supset E,\quad G_2\supset E^c,\]</span> 使得 <span class="math inline">\(m(G_1\cap G_2)&lt;\epsilon\)</span>.</p></blockquote><p><strong>证明</strong>: <strong>必要性</strong>: 由于 <span class="math inline">\(E\)</span> 为可测集, 故:</p><ol style="list-style-type: decimal"><li>存在开集 <span class="math inline">\(G\supset E\)</span>, s.t. <span class="math inline">\(m(G)-m(E)&lt;\frac{\epsilon}{2}\)</span>.</li><li>存在闭集 <span class="math inline">\(F\subset E\)</span>, s.t. <span class="math inline">\(m(E)-m(F)&lt;\frac{\epsilon}{2}\)</span>.</li></ol><p>取 <span class="math inline">\(G_1=G\)</span>, <span class="math inline">\(G_2=F^c\)</span>, 则 <span class="math inline">\(m^*(G_1\cap G_2)=m(G\backslash F)=m(G)-m(F)&lt;\epsilon\)</span>.</p><p><strong>充分性</strong>: 取递减开集列 <span class="math inline">\(G_{1n}\)</span> 和 <span class="math inline">\(G_{2n}\)</span>, s.t. <span class="math inline">\(\forall~n\)</span>, 有 <span class="math inline">\(E\subset G_{1n}\)</span>, <span class="math inline">\(E^c\subset G_{2n}\)</span> 且 <span class="math inline">\(m(G_{1n}-G_{2n})&lt;\frac{1}{n}\)</span>.</p><p>则取 <span class="math inline">\(G=\lim\limits_{n\to\infty} G_{1n}\)</span>, 即可使得 <span class="math inline">\(G\)</span> 为可测集, 且 <span class="math inline">\(m^*(G\backslash E)\leqslant m^*(G_{1n}\cap G_{2n})\)</span>. 取极限, 即有 <span class="math inline">\(m^*(G\backslash E)=0\)</span>.</p><p>于是 <span class="math inline">\(G\backslash E\)</span> 为零测集, 即 <span class="math inline">\(E\)</span> 可测.</p><h3 id="习题2-第一组-15">习题2 第一组 15</h3><blockquote><p>设 <span class="math inline">\(E\subset[0,1]\)</span> 是可测集且有 <span class="math display">\[m(E)\geqslant\epsilon &gt;0,\quad x_i\in[0,1],~i=1,2,\cdots,n,\]</span> 其中 <span class="math inline">\(n&gt;\frac{2}{\epsilon}\)</span>. 试证明 <span class="math inline">\(E\)</span> 中存在两个点, 其距离等于 <span class="math inline">\(\{x_1,x_2,\cdots,x_n\}\)</span> 中某两个点的距离.</p></blockquote><p><strong>证明</strong>: 由于 <span class="math inline">\(\forall~i\in\mathbf{N}\)</span>, s.t. <span class="math inline">\(1\leqslant i\leqslant n\)</span>, 总有 <span class="math inline">\(x_i\in[0,1]\)</span>. 于是 <span class="math inline">\(E+\{x_i\}\subset[0,2]\)</span>, <span class="math inline">\(\forall~i\)</span>.</p><p>故 <span class="math inline">\(\bigcup\limits_{i=1}^n (E+\{x_i\})\subset[0,2]\)</span>, 故 <span class="math inline">\(m\left(\bigcup\limits_{i=1}^n (E+\{x_i\})\right)\leqslant 2\)</span>.</p><p>由于 <span class="math inline">\(n&gt;\frac{2}{\epsilon}\)</span>, 故 <span class="math inline">\(\exists~i\neq j\)</span>, s.t. <span class="math inline">\((E+\{x_i\})\cap(E+\{x_j\})\neq\varnothing\)</span>. （否则 <span class="math inline">\(\sum\limits_{i=1}^n m(E+\{x_i\})\leqslant 2\)</span>, 即 <span class="math inline">\(n\leqslant\frac{\epsilon}{2}\)</span>, 矛盾.） 原命题得证.</p><h2 id="年05月11日">2017年05月11日</h2><h3 id="思考题-3-2">3.2 思考题 3</h3><blockquote><p>设 <span class="math inline">\(\{f_k(x)\}\)</span> 在 <span class="math inline">\(E\)</span>上依测度收敛于零, <span class="math inline">\(g(x)\)</span> 是 <span class="math inline">\(E\)</span> 上实值可测函数. 若 <span class="math inline">\(m(E)=+\infty\)</span>, 试说明 <span class="math inline">\(\{g(x)f_k(x)\}\)</span> 在 <span class="math inline">\(E\)</span> 上不一定依测度收敛于零.</p></blockquote><p><strong>证明</strong>: 取 <span class="math inline">\(g(x)=x,~f_k(x)=\frac{1}{k}\)</span> 即可.</p><h3 id="习题3-第一组-4">习题3 第一组 4</h3><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 是 <span class="math inline">\(E\subset\mathbf{R}^n\)</span> 上几乎处处有限的可测函数, <span class="math inline">\(m(E)&lt;\infty\)</span>, 试证明对于 <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, 存在 <span class="math inline">\(E\)</span> 上的有界可测函数 <span class="math inline">\(g(x)\)</span>, s.t. <span class="math inline">\(m(\{x\in E:\vert f(x)-g(x)\vert&gt;0\})&lt;\epsilon\)</span>.</p></blockquote><p><strong>证明</strong>: 令 <span class="math inline">\(E_\infty=\{x\in E:\vert f(x)\vert=\infty\}\)</span>, <span class="math inline">\(E_n=\{x\in E:\vert f(x)\vert\geqslant n\}\)</span>, <span class="math inline">\(n=1,2,\cdots\)</span>, 则 <span class="math inline">\(E\supset E_1\supset E_2\supset\cdots\)</span>, <span class="math inline">\(E_\infty=\bigcap\limits_{n=1}^\infty E_n\)</span>. 又由于 <span class="math inline">\(f(x)\)</span> 几乎处处有限, 故 <span class="math inline">\(\lim\limits_{n\to\infty}m(E_n)=m(\lim\limits_{n\to\infty}E_n)=0\)</span>. 故 <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, <span class="math inline">\(\exists~N\)</span>, s.t. <span class="math inline">\(m(E_N)=m(\{x\in E:\vert f(x)\vert\geqslant N\})&lt;\epsilon\)</span>, 故可以取函数 <span class="math display">\[g(x)=   \begin{cases}   f(x), &amp; x\in E\backslash E_N \\   0, &amp; x\in E_N   \end{cases}\]</span> 则 <span class="math inline">\(g(x)\)</span> 有界可测, 并且 <span class="math inline">\(m(\{x\in E:\vert f(x)-g(x)\vert&gt;0\})\leqslant m(E_N)&lt;\epsilon\)</span>.</p><h3 id="习题3-第一组-5">习题3 第一组 5</h3><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 及 <span class="math inline">\(f_n(x)~(n=1,2,\cdots)\)</span> 都是 <span class="math inline">\(A\subset\mathbf{R}^1\)</span> 上几乎处处有限的可测函数. 若对于 <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, 存在 <span class="math inline">\(A\)</span> 的可测子集 <span class="math inline">\(B:m(A\backslash B)&lt;\epsilon\)</span>, s.t. <span class="math inline">\(f_n(x)\)</span> 在 <span class="math inline">\(B\)</span> 上一致收敛于 <span class="math inline">\(f(x)\)</span>, 试证明 <span class="math inline">\(f_n(x)\)</span> 在 <span class="math inline">\(A\)</span> 上几乎处处收敛于 <span class="math inline">\(f(x)\)</span>.</p></blockquote><p><strong>证明</strong>: 由条件, 对于 <span class="math inline">\(\epsilon_m=\frac{1}{2^m}\)</span>, 存在 <span class="math inline">\(A\)</span> 的可测子集 <span class="math inline">\(B_m\)</span>, s.t. <span class="math inline">\(m(A\backslash B_m)&lt;\epsilon_m\)</span>, 且 <span class="math inline">\(f_n(x)\)</span> 在 <span class="math inline">\(B_m\)</span> 上一致收敛于 <span class="math inline">\(f(x)\)</span>. 令 <span class="math inline">\(B=\bigcap\limits_{j=1}^\infty\bigcup\limits_{m=j}^\infty(A\backslash B_m)\)</span>, 由于 <span class="math display">\[m(B)\leqslant m(\bigcup\limits_{m=j}^\infty(A\backslash B_m))\leqslant\sum\limits_{m=j}^\infty m(A\backslash B_m)&lt;\sum\limits_{m=j}^\infty\frac{1}{2^m},\quad\forall~j.\]</span> 故 <span class="math inline">\(m(B)=0\)</span>. 故 <span class="math inline">\(\forall~x\in A\backslash B=\bigcap\limits_{j=1}^\infty\bigcup\limits_{m=j}^\infty B_m\)</span>, <span class="math inline">\(\exists~j_0\)</span>, s.t. <span class="math inline">\(x\in\bigcap\limits_{m=j_0}^\infty B_m\)</span>, 由于 <span class="math inline">\(f_n\)</span> 在 <span class="math inline">\(B_m\)</span> 上一致收敛, 故在 <span class="math inline">\(x\)</span> 处应收敛. 由于 <span class="math inline">\(m(B)=0\)</span>, 故 <span class="math inline">\(f_n\)</span> 在 <span class="math inline">\(A\)</span> 上几乎处处收敛于 <span class="math inline">\(f\)</span>.</p><h3 id="习题3-第一组-6">习题3 第一组 6</h3><blockquote><p>设 <span class="math inline">\(\{f_k(x)\}\)</span> 是 <span class="math inline">\(E\subset\mathbf{R}^n\)</span> 上的实值可测函数列, <span class="math inline">\(m(E)&lt;\infty\)</span>, 试证明 <span class="math display">\[\lim\limits_{k\to\infty}f_k(x)=0,\quad\text{a.e.}~x\in E\]</span> 的充要条件是 <span class="math display">\[\forall~\epsilon&gt;0,~\lim\limits_{k\to\infty}m(\{x\in E:\sup\limits_{k\geqslant j}\{\vert f_k(x)\vert\}\geqslant\epsilon\})=0.\]</span></p></blockquote><p><strong>证明</strong>: 记 <span class="math inline">\(I=\{x\in E:f_k(x)\nrightarrow0~(k\to\infty)\}\)</span>, <span class="math inline">\(I_m=\varlimsup\limits_{k\to\infty}\{\vert f_k(x)\vert\geqslant\frac{1}{m}\}\)</span>, 则 <span class="math inline">\(I=\bigcup\limits_{m=1}^\infty I_m\)</span>. <strong>充分性</strong>: 若 <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, 总有 <span class="math inline">\(\lim\limits_{j\to\infty} m\left(\{x\in E:\sup\limits_{k\geqslant}\{f_k(x)\}\geqslant\epsilon\}\right)=0\)</span>, 则 <span class="math display">\[\begin{align}m^*(I) &amp;\leqslant \sum\limits_{m=1}^\infty m(I_m) \\&amp;= \sum\limits_{m=1}^\infty m\left( \bigcap\limits_{j=1}^\infty\bigcup\limits_{k=j}^\infty\{x\in E:\vert f_k(x)\vert\geqslant\frac{1}{m}\} \right) \\&amp;= \sum\limits_{m=1}^\infty \left( \lim\limits_{j\to\infty}m(\bigcup\limits_{k=j}^\infty \{x\in E:\vert f_k(x)\vert\geqslant\frac{1}{m}\}) \right) \\&amp;\leqslant \sum\limits_{m=1}^\infty \lim\limits_{j\to\infty}m\left(\{x\in E:\sup\limits_{k\geqslant j}\vert f_k(x)\vert\geqslant\frac{1}{m}\}\right) \\&amp;= 0 \\\end{align}\]</span> 即有 <span class="math inline">\(m^*(I)=0\)</span>, 故 <span class="math inline">\(\lim\limits_{k\to\infty}f_k(x)=0\)</span>, a.e. <span class="math inline">\(x\in E\)</span>. <strong>必要性</strong>: 由于 <span class="math inline">\(\lim\limits_{k\to\infty}f_k(x)=0\)</span>, a.e. <span class="math inline">\(x\in E\)</span>, 故 <span class="math inline">\(m(I)=0\)</span>. 而 <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, 总有 <span class="math display">\[\begin{align}\varlimsup\limits_{j\to\infty}m\left(\{x\in E:\sup\limits_{k\geqslant j}\vert f_k(x)\vert\geqslant\epsilon\}\right)&amp;\geqslant \varlimsup\limits_{j\to\infty}m\left(\bigcup\limits_{k=j}^\infty \{x\in E:\vert f_k(x)\vert\geqslant\frac{\epsilon}{2}\}\right) \\&amp;= m\left(\bigcap\limits_{j=1}^\infty \bigcup\limits_{k=j}^\infty\{x\in E:\vert f_k(x)\vert\geqslant\frac{\epsilon}{2}\}\right) \\&amp;\leqslant m(I) \\&amp; =0 \\\end{align}\]</span> <strong>综上</strong>: <span class="math inline">\(\lim\limits_{k\to\infty}f_k(x)=0,~\text{a.e.}~x\in E\Longleftrightarrow\forall~\epsilon&gt;0,~\lim\limits_{k\to\infty}m(\{x\in E:\sup\limits_{k\geqslant j}\{\vert f_k(x)\vert\}\geqslant\epsilon\})=0\)</span>.</p><h3 id="习题3-第一组-7">习题3 第一组 7</h3><blockquote><p>设 <span class="math inline">\(f(x),f_1(x),f_2(x),\cdots\)</span> 是 <span class="math inline">\([a,b]\)</span> 上几乎处处有限的可测函数, 且有 <span class="math display">\[\lim\limits_{k\to\infty}f_k(x)=f(x),\quad\text{a.e.}~x\in[a,b],\]</span> 试证明 <span class="math inline">\(\exists~E_n\subset[a,b]~(n=1,2,\cdots)\)</span>, s.t. <span class="math inline">\(m\left([a,b]\backslash\bigcup\limits_{n=1}^\infty E_n\right)=0\)</span>, 而 <span class="math inline">\(\{f_k(x)\}\)</span> 在每个 <span class="math inline">\(E_n\)</span> 上一致收敛于 <span class="math inline">\(f(x)\)</span>.</p></blockquote><p><strong>证明</strong>: 由Egorov定理, <span class="math inline">\(\forall~n\)</span>, <span class="math inline">\(\exists~E_n\subset[a,b]\)</span>, s.t. <span class="math inline">\(m([a,b]\backslash E_n)\leqslant\frac{1}{n}\)</span>, 且在 <span class="math inline">\(E_n\)</span> 上, <span class="math inline">\(f_k(x)\rightrightarrows f(x)\)</span>. 又有 <span class="math display">\[\begin{align}m\left([a,b]\backslash\bigcup\limits_{n=1}^\infty E_n\right)&amp;= m\left(\bigcap_{n=1}^\infty ([a,b]\backslash E_n)\right) \\&amp;\leqslant \lim\limits_{n\to\infty}([a,b]\backslash E_n) \\&amp;\leqslant \lim\limits_{n\to\infty}\frac{1}{n}=0.\\\end{align}\]</span> 原命题得证.</p><h2 id="年05月12日">2017年05月12日</h2><h3 id="习题4-第一组-1">习题4 第一组 1</h3><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 是 <span class="math inline">\(E\subset\mathbf{R}^n\)</span> 上几乎处处大于零的可测函数, 且满足 <span class="math inline">\(\int_Ef(x){\rm d}x=0\)</span>, 试证明 <span class="math inline">\(m(E)=0\)</span>.</p></blockquote><p><strong>证明</strong>: <strong>反证法</strong> 假设 <span class="math inline">\(m(E)&gt;0\)</span>, 记 <span class="math inline">\(E_n=\{x\in E:f(x)&gt;\frac{1}{n}\}\)</span>, 并令 <span class="math inline">\(F=\bigcup\limits_{n=1}^\infty E_n\)</span>, 则由 <span class="math inline">\(E=(E\backslash F)\cup F\)</span> 且 <span class="math inline">\(m(E\backslash F)=0\)</span> 可知, <span class="math inline">\(\exists n_0\)</span>, s.t. <span class="math inline">\(m(E_{n_0})&gt;0\)</span>. 于是有 <span class="math inline">\(0=\int_Ef(x){\rm d}x\geqslant\int_{E_{n_0}}f(x){\rm d}x\geqslant\frac{1}{n_0}m(E_{n_0})\)</span>, 得 <span class="math inline">\(m(E_{n_0})=0\)</span>, 矛盾. 于是 <span class="math inline">\(m(E)=0\)</span>.</p><h3 id="习题4-第一组-4">习题4 第一组 4</h3><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 是 <span class="math inline">\(\mathbf{R}^1\)</span> 上的非负可测函数, 令 <span class="math display">\[F(x)=\int\nolimits_{(-\infty,x]}f(t)dt,\quad x\in\mathbf{R}^1.\]</span> 若 <span class="math inline">\(F\in L(\mathbf{R}^1)\)</span>, 试证明 <span class="math inline">\(\int\nolimits_{\mathbf{R}^1}f(x)dx=0\)</span>.</p></blockquote><p><strong>证明</strong>: 由于 <span class="math inline">\(F\in L(\mathbf{R}^1)\)</span>, 故 <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, <span class="math inline">\(\exists~N\)</span> s.t. <span class="math inline">\(\int\nolimits_{\{x:\vert x\vert&gt;N\}}F(x)dx&lt;\epsilon\)</span>. 又由于 <span class="math inline">\(f(x)\geqslant0\)</span>, 故 <span class="math inline">\(F(x)\)</span> 随 <span class="math inline">\(x\)</span> 递增, 且 <span class="math inline">\(\lim\limits_{x\to\infty}F(x)=\int\nolimits_{\mathbf{R}^1}f(x)dx\)</span>. 于是 <span class="math inline">\(\forall~y&gt;N\)</span>, 均有: <span class="math display">\[F(y)=\int\nolimits_{y}^{y+1}F(y)dx\leqslant\int\nolimits_y^{y+1}F(x)dx\leqslant\int\nolimits_{\{x:\vert x\vert&gt;N\}}F(x)dx&lt;\epsilon\]</span>, 于是 <span class="math inline">\(\lim\limits_{y\to\infty}F(y)=0\)</span>. 即 <span class="math inline">\(\int\nolimits_{\mathbf{R}^1}f(x)dx=0\)</span>.</p><h3 id="习题4-第一组-5">习题4 第一组 5</h3><blockquote><p>设 <span class="math inline">\(f_k(x)~(k=1,2,\cdots)\)</span> 是 <span class="math inline">\(\mathbf{R}^n\)</span> 上非负可积函数列, 若对于任何一可测集 <span class="math inline">\(E\subset\mathbf{R}^n\)</span>, 总有 <span class="math display">\[\int\nolimits_Ef_k(x)dx\leqslant\int\nolimits_Ef_{k+1}(x)dx,\]</span> 试证明 <span class="math display">\[\lim\limits_{k\to\infty}\int\nolimits_Ef_k(x)dx=\int\nolimits_E \lim\limits_{k\to\infty} f_k(x)dx.\]</span></p></blockquote><p><strong>证明</strong>: 取 <span class="math inline">\(E_k=\{x:f_k(x)&gt;f_{k+1}(x)\}~(k=1,2,\cdots)\)</span>, 则由条件有 <span class="math inline">\(\int\nolimits_{E_k}(f_k(x)-f_{k+1}(x))dx\leqslant0\)</span>. 又由 <span class="math inline">\(E_k\)</span> 的定义可知 <span class="math inline">\(f_k(x)-f_{k+1}(x)&gt;0\)</span>, 故 <span class="math inline">\(m(E_k)=0\)</span>, <span class="math inline">\(\forall~k\)</span>. 于是 <span class="math inline">\(m\left(\bigcup\limits_{k=1}^\infty E_k \right)=0\)</span>, 故 <span class="math inline">\(f_k(x)\)</span> 在 <span class="math inline">\(E\)</span> 上几乎处处满足Levi定理的使用条件, 故在 <span class="math inline">\(E\)</span> 上由Levi定理有 <span class="math display">\[\lim\limits_{k\to\infty}\int\nolimits_Ef_k(x)dx=\int\nolimits_E \lim\limits_{k\to\infty} f_k(x)dx.\]</span></p><h2 id="年06月07日">2017年06月07日</h2><h3 id="习题4-第一组-7">习题4 第一组 7</h3><blockquote><p>假设有定义在 <span class="math inline">\(\mathbf{R}^n\)</span> 上的函数 <span class="math inline">\(f(x)\)</span>, 如果对于 <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, <span class="math inline">\(\exists~g,h\in L(\mathbf{R}^n)\)</span>, s.t. <span class="math inline">\(g(x)\leqslant f(x)\leqslant h(x)~(x\in\mathbf{R}^n)\)</span>, 并且 <span class="math inline">\(\int\nolimits_{\mathbf{R}^n}[h(x)-g(x)]dx&lt;\epsilon\)</span>, 试证明 <span class="math inline">\(f\in L(\mathbf{R}^n).\)</span></p></blockquote><p><strong>证明</strong>: 由条件, 取可积函数列 <span class="math inline">\(g_k(x),h_k(x)\)</span>, s.t. <span class="math inline">\(g_k(x)\leqslant f(x)\leqslant h_k(x)\)</span> 且 <span class="math inline">\(\int\nolimits_{\mathbf{R}^n}[h_k(x)-g_k(x)]dx&lt;\frac{1}{k}\)</span>. 故 <span class="math inline">\(\{h_k(x)-g_k(x)\}\)</span> 为非负可积函数列. 又由于 <span class="math inline">\(\lim\limits_{k\to\infty}\int\nolimits_{\mathbf{R}^n}[h_k(x)-g_k(x)]dx=0\)</span>, 故 <span class="math inline">\(h_k(x)-g_k(x)\)</span> 依测度收敛于0. 故由Riesz定理, 存在子列 <span class="math inline">\(\{h_{k_j}-g_{k_j}\}\)</span>, s.t. <span class="math inline">\(\lim\limits_{j\to\infty}[h_{k_j}(x)-g_{k_j}(x)]=0\)</span>, a.e. <span class="math inline">\(x\in\mathbf{R}^n\)</span>. 又 <span class="math inline">\(\vert f(x)\vert\leqslant \max\{\vert g_k(x)\vert,\vert h_k(x)\vert\}\leqslant\vert g_k(x)\vert+\vert h_k(x)\vert\)</span>. 故 <span class="math inline">\(\vert f\vert\in L(\mathbf{R}^n)\)</span>, 故 <span class="math inline">\(f\in L(\mathbf{R}^n)\)</span>.</p><h3 id="习题4-第一组-8">习题4 第一组 8</h3><blockquote><p>设 <span class="math inline">\(\{E_k\}\)</span> 是 <span class="math inline">\(\mathbf{R}^n\)</span> 中测度有限的可测集列, 且有 <span class="math display">\[\lim\limits_{k\to\infty}\int\nolimits_{\mathbf{R}^n}\vert\chi_{E_k}(x)-f(x)\vert=0,\]</span> 试证明存在可测集 <span class="math inline">\(E\)</span> s.t. <span class="math inline">\(f(x)=\chi_E(x)\)</span>, a.e. <span class="math inline">\(x\in\mathbf{R}^n\)</span>.</p></blockquote><p><strong>证明</strong>: 由条件, <span class="math inline">\(\chi_{E_k}(x)\)</span> 依 <span class="math inline">\(L^1\)</span> 范数收敛于 <span class="math inline">\(f(x)\)</span>, 故 <span class="math inline">\(\chi_{E_k}(x)\)</span> 依测度收敛于 <span class="math inline">\(f(x)\)</span>. 由Riesz定理, 存在其几乎处处收敛于 <span class="math inline">\(f(x)\)</span> 的子列 <span class="math inline">\(\chi_{E_{k_i}}(x)\)</span>. 令 <span class="math inline">\(E_{k_i}\to E\)</span>, 则应有 <span class="math inline">\(f(x)=\chi_E(x)\)</span>, a.e. <span class="math inline">\(x\in\mathbf{R}^n\)</span>.</p><h2 id="年06月20日">2017年06月20日</h2><h3 id="习题4-第一组-13">习题4 第一组 13</h3><blockquote><p>设 <span class="math inline">\(f\in L(\mathbf{R}^1),p&gt;0\)</span>, 试证明 <span class="math display">\[\lim\limits_{n\to\infty}n^{-p}f(nx)=0,\quad\text{a.e.}~x\in\mathbf{R}^1.\]</span></p></blockquote><p><strong>证明</strong>: 考虑级数 <span class="math inline">\(\sum\limits_{n=1}^\infty\vert n^{-p}f(nx)\vert\)</span>, 则 <span class="math inline">\(n^{-p}f(nx)\)</span> 为非负可测函数, 即 <span class="math display">\[\begin{align}\int\nolimits_{\mathbf{R}^1}\left(\sum\limits_{n=1}^\infty\vert n^{-p}f(nx)\vert\right)dx&amp;= \sum\limits_{n=1}^\infty\int\nolimits_{\mathbf{R}^1}\vert n^{-p}f(nx)\vert dx \\&amp;= \sum\limits_{n=1}^\infty\int\nolimits_{\mathbf{R}^1}\vert n^{-p-1}f(nx)\vert d(nx) \\&amp;= \sum\limits_{k=1}^\infty\frac{1}{n^{p+1}}\cdot\int\nolimits_{\mathbf{R}^1}\vert f(x)\vert dx \\\end{align}\]</span> 由于 <span class="math inline">\(1+p&gt;1\)</span>, 故 <span class="math inline">\(\sum\limits_{k=1}^\infty\frac{1}{n^{p+1}}\)</span> 收敛, 又由于 <span class="math inline">\(\int\nolimits_{\mathbf{R}^1}\vert f(x)\vert dx\)</span> 有限, 故 <span class="math inline">\(\int\nolimits_{\mathbf{R}^1}\left(\sum\limits_{n=1}^\infty\vert n^{-p}f(nx)\vert\right)dx\)</span> 有限, 故 <span class="math inline">\(\sum\limits_{n=1}^\infty\vert n^{-p}f(nx)\vert\)</span> 有限, 即有 <span class="math inline">\(\lim\limits_{n\to\infty}n^{-p}f(nx)=0\)</span>, a.e. <span class="math inline">\(x\in\mathbf{R}^1\)</span>.</p><h3 id="习题4-第一组-21">习题4 第一组 21</h3><blockquote><p><strong>依测度收敛的Fatou引理</strong> 设 <span class="math inline">\(\{f_k(X)\}\)</span> 是 <span class="math inline">\(E\)</span> 上依测度收敛于 <span class="math inline">\(f(x)\)</span> 的非负可测函数列, 试证明 <span class="math display">\[\int\nolimits_E f(x)dx\leqslant \varliminf\limits_{k\to\infty}\int\nolimits_E f_k(x)dx.\]</span></p></blockquote><p><strong>证明</strong>: 由Riesz定理, 存在子列 <span class="math inline">\(\{f_{k_i}(x)\}\)</span>, s.t. <span class="math inline">\(\lim\limits_{i\to\infty}f_{k_i}(x)=f(x)\)</span>, a.e. <span class="math inline">\(x\in\mathbf{R}^n\)</span>. 故由Fatou引理, 有: <span class="math display">\[\begin{align}\int\nolimits_Ef(x)dx &amp;= \int\nolimits_E \lim\limits_{i\to\infty}f_{k_i}(x)dx \\&amp;= \int\nolimits_E \varliminf\limits_{i\to\infty}f_{k_i}(x)dx \\&amp;\leqslant \varliminf\limits_{i\to\infty}\int\nolimits_{E} f_{k_i}(x)dx \\&amp;= \varliminf\limits_{k\to\infty}\int\nolimits_E f_k(x)dx.\\\end{align}\]</span> 即 <span class="math inline">\(\int\nolimits_E f(x)dx\leqslant \varliminf\limits_{k\to\infty}\int\nolimits_E f_k(x)dx\)</span>. <strong>这个证法可能有问题, 慢慢解决.</strong></p><h3 id="习题4-第一组-23">习题4 第一组 23</h3><blockquote><p>设 <span class="math inline">\(f\in L(\mathbf{R}^n)\)</span>, <span class="math inline">\(f_k\in L(\mathbf{R}^n)~(k=1,2,\cdots)\)</span>, 且对任一可测集 <span class="math inline">\(E\subset\mathbf{R}^n\)</span>, 均有 <span class="math display">\[\int\nolimits_Ef_k(x)dx\leqslant \int\nolimits_Ef_{k+1}(x)dx~(k=1,2,\cdots),\]</span> <span class="math display">\[\lim\limits_{k\to\infty}\int\nolimits_Ef_k(x)dx=\int\nolimits_Ef(x)dx,\]</span> 试证明 <span class="math inline">\(\lim\limits_{k\to\infty}f_k(x)=f(x)\)</span>, a.e. <span class="math inline">\(x\in\mathbf{R}^n\)</span>.</p></blockquote><p><strong>证明</strong>: 易由 <span class="math inline">\(\int\nolimits_Ef_k(x)dx\leqslant \int\nolimits_Ef_{k+1}(x)dx\)</span> 知 <span class="math inline">\(f_k(x)\leqslant f_{k+1}(x)\)</span>, a.e. <span class="math inline">\(x\in\mathbf{R}^n\)</span>. 于是 <span class="math inline">\(\{f_k(x)-f_1(x)\{\)</span> 为非负渐升列, 由Levi定理, 有 <span class="math display">\[\begin{align}\int\nolimits_Ef(x)dx-\int\nolimits_Ef_1(x)dx&amp;= \lim\limits_{k\to\infty}\int\nolimits_Ef_k(x)dx-\int\nolimits_Ef_1(x)dx \\&amp;= \lim\limits_{k\to\infty}\int\nolimits_E\left(f_k(x)-f_1(x)\right)dx \\&amp;= \int\nolimits_E\lim\limits_{k\to\infty}(f_k(x)-f_1(x))dx \\&amp;= \int\nolimits_E\lim\limits_{k\to\infty}f_k(x)dx-\int\nolimits_Ef_1(x)dx \\\end{align}\]</span> 即 <span class="math inline">\(\int\nolimits_Ef(x)dx=\int\nolimits_E\lim\limits_{k\to\infty}f_k(x)dx\)</span>, 故 <span class="math inline">\(\lim\limits_{k\to\infty}f_k(x)=f(x)\)</span>, a.e. <span class="math inline">\(x\in\mathbf{R}^n\)</span>.</p><h2 id="年06月21日">2017年06月21日</h2><h3 id="习题4-第一组-30">习题4 第一组 30</h3><blockquote><p>计算下列积分: 1. <span class="math inline">\(\int\nolimits_{x&gt;0}\int\nolimits_{y&gt;0}\frac{dxdy}{(1+y)(1+x^2Y)}\)</span>; 2. <span class="math inline">\(\int\nolimits_0^\infty\frac{\ln x}{x^2-1}dx\)</span></p></blockquote><p><strong>解答</strong>:</p><ol style="list-style-type: decimal"><li>由Tonelli定理, <span class="math display">\[\begin{align}\int\nolimits_{x&gt;0}\int\nolimits_{y&gt;0}\frac{dxdy}{(1+y)(1+x^2y)} &amp;= \int\nolimits_{x&gt;0}\int\nolimits_{y&gt;0}\frac{\sqrt{y}dx}{1+x^2y}\frac{dy}{\sqrt{y}(1+y)} \\&amp;= 2\int\nolimits_{x&gt;0}\frac{dx}{1+x^2}\int\nolimits_{y&gt;0}\frac{dy}{1+y^2} \\&amp;= \frac{\pi^2}{2}.\end{align}\]</span></li><li><span class="math display">\[\begin{align}\frac{\pi^2}{2} &amp;= \int\nolimits_{x&gt;0}\frac{1}{x^2-1}\int\nolimits_{y&gt;0}\left(\frac{x^2}{1+x^2y}-\frac{1}{1+y}\right)dxdy \\&amp;= \int\nolimits_{x&gt;0}\frac{1}{x^2-1}\left(\ln \frac{1+x^2y}{1+y}\vert_0^\infty\right)dx \\&amp;= 2\int\nolimits_0^\infty\frac{\ln x}{x^2-1}dx.\end{align}\]</span> 故 <span class="math inline">\(\int\nolimits_0^\infty\frac{\ln x}{x^2-1}dx=\frac{\pi^2}{4}\)</span>.</li></ol>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 实变函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo与Mathjax的冲突及解决方案</title>
      <link href="/2017/03/08/Hexo%E4%B8%8EMathjax%E7%9A%84%E5%86%B2%E7%AA%81%E5%8F%8A%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89%E8%A7%A3%E5%86%B3/"/>
      <content type="html"><![CDATA[<h2 id="问题出现的原因蛋疼的转义">问题出现的原因：蛋疼的转义</h2><p>Markdwon本身的特殊符号与Latex中的符号会出现冲突：</p><table><thead><tr class="header"><th align="center">符号</th><th align="center">Markdown中意义</th><th align="center">LaTeX中意义</th></tr></thead><tbody><tr class="odd"><td align="center"><code>_</code></td><td align="center">斜体</td><td align="center">下标</td></tr><tr class="even"><td align="center"><code>\\</code></td><td align="center">转义为<code>\</code></td><td align="center">换行</td></tr><tr class="odd"><td align="center"><code>*</code></td><td align="center">加粗</td><td align="center">无变化</td></tr></tbody></table><p>这些问题是存在于Markdown语法中的，然而辣鸡Hexo默认使用marked.js解析markdown，于是表示斜体的<code>_</code>会被处理为<code>&lt;em&gt;</code>标签，如<code>x_i</code>在开始被渲染的时候，处理为<code>x&lt;em&gt;i&lt;/em&gt;</code>，这个时候Mathjax就无法将其渲染成下标了。 类似的问题还有很多，比如<code>*</code>和<code>\</code>字符。 所以从根本上来讲，是辣鸡Hexo使用的Markdown引擎造成的。。垃圾Hexo。。</p><h2 id="解决方案一手动转义">解决方案一：手动转义</h2><p>手动转义的意思很明确，你不是把我的<code>\\</code>转成了<code>\</code>么？那好，我输<code>\\\\</code>还不行么？你总得给我转成<code>\\</code>了吧？ 同理，在下标的地方写成<code>\_</code>，也同样能够避免这个问题。 听起来很棒耶，但手动转义的缺点其实是很明显的：无法移植。你辛辛苦苦改了很久的文章也许往其他平台上面一贴就面目全非了，因为大多数的Markdown解释引擎都没有这个毛病（垃圾Hexo）<del>这你不就傻逼了么</del>，所以手动转义需谨慎。。</p><h2 id="解决方案二保护公式">解决方案二：保护公式</h2><p>另一个听起来很棒的想法就是用代码环境来保护公式，并且在解析的时候，只要发现<code>$...$</code>字样就按照公式来解析。 听起来不错耶！既解决了转义的问题，又不会破坏兼容性。但是这种方法也会带来一个很严重的问题：如果你要插入的某段代码中也含有<code>$...$</code>的字样，就会出现错误。。 该方法详见 <a href="http://liam0205.me/2015/09/09/fix-conflict-between-mathjax-and-markdown/" target="_blank" rel="noopener">解决 MathJax 与 Markdown 的冲突</a>。</p><h2 id="解决方案三更换引擎">解决方案三：更换引擎</h2><p>既然这个marked.js这么烂，我们干脆把它换掉好了，简单粗暴没有后患。替代marked.js的方案有很多，只以<code>Hexo-renderer-pandoc</code>为例：</p><ul><li>安装Pandoc，官网提供了deb安装包，按照官网教程就可以安装完成。</li><li>卸载Hexo默认的markd,再安装新的:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall Hexo-renderer-marked --save</span><br><span class="line">npm install Hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure><p>这种解决方案的一点小瑕疵是语法与Markdown有很小的差别，需要注意一下。</p><h2 id="解决方案四修改引擎">解决方案四：修改引擎</h2><p>这个marked.js虽然烂，可是你说不定觉得它还是可以抢救一下的。。按照如下方法进行抢救也能一定程度上解决问题：</p><ul><li>找到<code>marked.js</code>，路径为<code>\nodes_modules/marked/lib/marked.js</code>；</li><li>将marked.js中的如下第一行代码改为第二行以去掉<code>\</code>的转义：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">escape: /^\\([\\`*&#123;&#125;\[\]()#+\-.!_&gt;])/,</span><br><span class="line">escape: /^\\([`*&#123;&#125;\[\]()# +\-.!_&gt;])/,</span><br></pre></td></tr></table></figure><ul><li>将marked.js中的如下第一行代码改为第二行以更改<code>&lt;em&gt;</code>符号：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br><span class="line">em:/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><ul><li><a href="https://segmentfault.com/a/1190000007261752" target="_blank" rel="noopener">SegmentFault——Hexo下mathjax的转义问题</a></li><li><a href="http://lukang.me/2014/mathjax-for-hexo.html" target="_blank" rel="noopener">空念远兮——在 Hexo 中完美使用 Mathjax 输出数学公式</a></li></ul><table><tbody><tr class="odd"><td><strong>垃圾Hexo！！！</strong></td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 计算机 </tag>
            
            <tag> Hexo </tag>
            
            <tag> Mathjax </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数学系转专业考试题及解答不完全版（2015.04）</title>
      <link href="/2017/03/08/%E6%95%B0%E5%AD%A6%E7%B3%BB%E8%BD%AC%E4%B8%93%E4%B8%9A%E8%80%83%E8%AF%95%E9%A2%98%E5%8F%8A%E8%A7%A3%E7%AD%94%E4%B8%8D%E5%AE%8C%E5%85%A8%E7%89%88%EF%BC%882015-04%EF%BC%89/"/>
      <content type="html"><![CDATA[<h2 id="几句废话">几句废话</h2><p>又是一年转专业的时候, 转专业这件事也又一次被提起。最初的转专业想法是在刚入校形成的, 经历了一些波折之后最终确定了转专业的事情, 于是在2015年的4月（其实也可能是3月, 记不清了）参加了转专业的考试。 笔试结果出来之后得知洲洲没有通过笔试, 洲洲希望我能整理一份题目和解答给他（或许是留作纪念）。但由于考完之后没有很及时地整理, 导致了个别问题的遗漏（至多两个）。 整理完之后将纸质版交给了洲洲, 为了保存一下相关内容, 我便将该文档拍照发到了<a href="https://tieba.baidu.com/lzcwr" target="_blank" rel="noopener">我的贴吧：lzcwr吧</a>里边。但是由于我当时过于naive, 还不懂得“图像压缩”的问题, 便直接将画质很差的图像上传到了网上。。导致帖子里边的图片全部是AV画质。。有兴趣可以点击<a href="https://tieba.baidu.com/p/3726485475" target="_blank" rel="noopener">原帖地址</a>看看。。现在想起来有点后悔, 于是决定重新整理一份（在较大程度上能还原原试卷）。</p><h2 id="试题">试题</h2><ol style="list-style-type: decimal"><li>设数列 $ { x_n } $ 满足 <span class="math inline">\(x_n&gt;0\)</span>, 且 <span class="math inline">\(\forall n\in \mathbb{N}\)</span>, 都有 <span class="math inline">\(x_{n+1}+\frac{1}{x_n}&lt;2\)</span>, 求证：<span class="math display">\[\lim_{n\to\infty}x_n=1\]</span></li><li>若函数 <span class="math inline">\(f(x)\)</span> 满足 <span class="math display">\[f(x+y)=f(x)\times f(y)\]</span>且 <span class="math inline">\(f(0)=1\)</span>, <span class="math inline">\(f&#39;(0)=2\)</span>, 求 <span class="math inline">\(f(x)\)</span> 的表达式.</li><li>求极限：<span class="math display">\[\lim\limits_{x\to0}\frac{\sin x^6}{x^2-\arcsin x^2}\]</span></li><li>设 <span class="math inline">\(f(x)=x^3\sin2x\)</span>, 求：<span class="math inline">\(f^{(10)}(0)\)</span>.</li><li>求积分：<span class="math display">\[\int_0^{\frac{\pi}{4}}\frac{x\sec^2x{\rm d}x}{(1+\tan x)^2}\]</span></li><li>求证：<span class="math display">\[\frac{2}{3}n\sqrt{n}&lt;1+\sqrt{2}+\sqrt{3}+\cdots+\sqrt{n}&lt;\frac{4n+3}{6}\sqrt{n}\]</span></li><li>令 <span class="math inline">\(f(x)=xe^{-x}\)</span>, 设 <span class="math inline">\(f(x)\)</span> 有极值点 <span class="math inline">\((x_1,y_1)\)</span>, 拐点 <span class="math inline">\((x_2,y_2)\)</span>：<ol style="list-style-type: decimal"><li>求 <span class="math inline">\((x_1,y_1)\)</span> 和 <span class="math inline">\((x_2,y_2)\)</span>.</li><li>求函数与 <span class="math inline">\(x\)</span> 轴在 <span class="math inline">\(x=x_1\)</span> 与 <span class="math inline">\(x=x_2\)</span> 之间围成的面积.</li></ol></li><li>令 <span class="math inline">\(f(x)\)</span> 为定义在 <span class="math inline">\((-\infty,+\infty)\)</span> 上的函数, 且对 <span class="math inline">\(\forall x\in\mathbb{R}\)</span>, 均有 <span class="math inline">\(|f(x)|\leq M_1\)</span>, <span class="math inline">\(|f&#39;&#39;(x)|\leq M_2\)</span>, 求证：<span class="math display">\[|f&#39;(x)|\leq \sqrt{2M_1M_2}\]</span></li></ol><h2 id="解答">解答</h2><p>因为我比较懒。。一些简单题目就不做详细的解答了。。一定要看详细解答的可以去原帖看av画质的图片, 应该能看懂。。（别问我为什么不用有序列表）</p><p>1.由条件, <span class="math inline">\(x_{n+1}-x_n&lt;2-(x_n+\frac{1}{x_n})\)</span>, 而由均值不等式有 <span class="math inline">\(x_n+\frac{1}{x_n}\geq 2\)</span>, 于是 <span class="math inline">\(x_{n+1}-x_n&lt;0\)</span>, 即数列 $ { x_n } $递减。于是数列 $ { x_n } $单调有界, 有极限。由 <span class="math inline">\(x_{n+1}+\frac{1}{x_n}&lt;2\)</span> 易得结论；</p><p>2.两边同时取对数即变为 Cauchy 方程 <span class="math inline">\(g(x+y)=g(x)+g(y)\)</span>, 用 Cauchy 方法即可求解；</p><p>3.换元 <span class="math inline">\(y=x^2\)</span> 后将分子分母分别泰勒展开至 <span class="math inline">\(y^3\)</span> 即可得答案为 <span class="math inline">\(-6\)</span>；</p><p>4.这个题不会做自觉面壁；</p><p>5.无脑积分：md劳资怎么改都generate不了, 只好截个图算了。。</p><div class="figure"><img src="http://static.zybuluo.com/lzcwr/xqwm7m3zaqlzycg19g7gpg6q/image_1ban69j2711o8rs1c56bip16on9.png" alt="image_1ban69j2711o8rs1c56bip16on9.png-56.3kB"><p class="caption">image_1ban69j2711o8rs1c56bip16on9.png-56.3kB</p></div><p>6.一方面考虑 <span class="math inline">\(f(x)=\sqrt{x}\)</span> 在 <span class="math inline">\([0,n]\)</span> 的积分, 有 <span class="math inline">\(\sum_{i=1}^{n}\sqrt{i}&gt;\int_0^n\sqrt{x}{\rm d}x=\frac{2}{3}n\sqrt{n}\)</span>；另一边不等式只需给右边做差, 证明 <span class="math inline">\(\sqrt{k}&lt;\frac{4k+3}{6}\sqrt{k}-\frac{4k-1}{6}\sqrt{k-1}\)</span> 即可（不会做的自觉面壁）；</p><p>7.这个题不会做的继续面壁吧；</p><p>8.考场上没做出来, 后来问会了但是现在也不记得了……比较难, 这样的题考场上做不出来可以理解。</p><p>祝要转专业的各位转专业成功！</p><hr><p>不能忍。。存一下第五题的公式代码……问题解决了再贴上去……</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;align&#125;</span><br><span class="line">\int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;\frac&#123;x\sec^2x&#125;&#123;(1+\tan x)^2&#125;&#123;\rm d&#125;x &amp;= \int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;\frac&#123;x&#125;&#123;(1+\tan x)^2&#125;&#123;\rm d&#125;(1+\tan x) \\</span><br><span class="line"> &amp;= -\int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;x&#123;\rm d&#125;(\frac&#123;1&#125;&#123;1+\tan x&#125;) \\</span><br><span class="line"> &amp;= -(\frac&#123;x&#125;&#123;1+\tan x&#125;\Big|_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;-\int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;\frac&#123;&#123;\rm d&#125;x&#125;&#123;1+\tan x&#125;) \\</span><br><span class="line"> &amp;= -\frac&#123;\pi&#125;&#123;8&#125;+\int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;\frac&#123;\cos x&#125;&#123;\sin x+\cos x&#125;&#123;\rm d&#125;x \\</span><br><span class="line"> &amp;= -\frac&#123;\pi&#125;&#123;8&#125;+\int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;\frac&#123;\frac&#123;1&#125;&#123;2&#125;(\cos x+\sin x)+\frac&#123;1&#125;&#123;2&#125;(\cos x-\sin x)&#125;&#123;\sin x+\cos x&#125;&#123;\rm d&#125;x \\</span><br><span class="line"> &amp;= -\frac&#123;\pi&#125;&#123;8&#125;+\int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;\frac&#123;1&#125;&#123;2&#125;&#123;\rm d&#125;x+\frac&#123;1&#125;&#123;2&#125;\int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;\frac&#123;&#123;\rm d&#125;(\sin x+\cos x)&#125;&#123;\sin x+\cos x&#125; \\</span><br><span class="line"> &amp;= \frac&#123;1&#125;&#123;2&#125;\ln(\sin x+\cos x)\vert_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125; \\</span><br><span class="line"> &amp;= \frac&#123;1&#125;&#123;2&#125;\ln\sqrt&#123;2&#125; = \frac&#123;\ln2&#125;&#123;4&#125;</span><br><span class="line">\end&#123;align&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 师大 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 各种试卷 </tag>
            
            <tag> 数学分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构——树状数组 Binary Indexed Tree</title>
      <link href="/2017/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%20Binary%20Indexed%20Tree/"/>
      <content type="html"><![CDATA[<h2 id="树状数组概述">树状数组概述</h2><p>树状数组(binary indexed tree)能够高效地获取数组的子段和。 一般来说，树状数组可以用于解决数组子段和的动态查询或高效查询问题。</p><blockquote><p>传统的数组单点修改的复杂度为<span class="math inline">\(~O(1)~\)</span>，查询子段和的复杂度为<span class="math inline">\(~O(n)~\)</span>。 而树状数组的修改和查询子段和复杂度均为<span class="math inline">\(~O(\log n)~\)</span>。 所以在多组查询或动态查询时，用树状数组可以有效减小耗时，提高程序效率。</p></blockquote><h2 id="树状数组的操作">树状数组的操作</h2><h3 id="构建">构建</h3><p>从已知数组构建树状数组就是把线性的数组变成一棵树。那么，树状数组是如何把线性结构的数组变成一棵树的呢？以下以一个长度为8的数组为例：</p><p>原始数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[8]</span><br></pre></td></tr></table></figure><p>在修改和查询子段和时，很容易想到一种类似二分的想法来构建一棵树状的数组来保存原数组的所有信息。 用这种方法构造出的数组具有如下的结构（图片来自<a href="http://baike.baidu.com/link?url=MWXznqHrg5WOaQXOilx_IgGzC_YzDNcwVqbMqltULN9YUIPgB75WQU2xpoIfPXsq7z21_2LSn3wILiRRZXC97xYZleNY6LkqUEIlsCsOLeUEamNkjYhEvMKisCmKMNXK" target="_blank" rel="noopener">百度百科-树状数组</a>）：</p><div class="figure"><img src="http://static.zybuluo.com/lzcwr/cygbcza2ann0629f6fanea4n/image_1b9ho5pkm1vdbnld1hkc551nji9.png" alt="image_1b9ho5pkm1vdbnld1hkc551nji9.png-86.1kB"><p class="caption">image_1b9ho5pkm1vdbnld1hkc551nji9.png-86.1kB</p></div><p>这样的一棵树满足如下的条件：</p><ul><li><span class="math inline">\(C_1=A_1\)</span></li><li><span class="math inline">\(C_2=A_1+A_2\)</span></li><li><span class="math inline">\(C_3=A_3\)</span></li><li><span class="math inline">\(C_4=A_1+A_2+A_3+A_4\)</span></li><li><span class="math inline">\(C_5=A_5\)</span></li><li><span class="math inline">\(C_6=A_5+A_6\)</span></li><li><span class="math inline">\(C_7=A_7\)</span></li><li><span class="math inline">\(C_8=A_1+A_2+A_3+A_4+A_5+A_6+A_7+A_8\)</span></li></ul><p>从中可以发现，若结点的标号为<span class="math inline">\(~n~\)</span>，则该结点的求和区域长度为<span class="math inline">\(~2^k~\)</span>，此处的<span class="math inline">\(~k~\)</span>为<span class="math inline">\(~n~\)</span>的二进制表示的末尾<span class="math inline">\(~0~\)</span>的个数。 由于<span class="math inline">\(~n~\)</span>号结点求和区域的最末一位一定是<span class="math inline">\(~A_n~\)</span>，于是有：</p><p><span class="math display">\[ C[n] = \sum_{i = n - 2^k + 1}^{n} A[i] = A[n-2^k+1]+A[n-2^k+1]+\cdots+A[n-1]+A[n] \]</span></p><p>于是构建树状数组的问题就变成了如何求<span class="math inline">\(~2^k~\)</span>的问题。 利用位运算的性质，有一个非常漂亮的解答（<span class="math inline">\(\oplus\)</span>表示异或）：</p><p><span class="math display">\[2^k=n\&amp;(n\oplus (n-1))=n\&amp;(-n)\]</span></p><p>这就是树状数组构建的核心：<code>lowbit()</code>函数，代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int lowbit(int x)   </span><br><span class="line">&#123;   </span><br><span class="line">    return x &amp; (-x);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单点修改">单点修改</h3><p>树状数组的单点修改过程很简单：修改需要修改的点，然后沿着树上的路径把受到牵连的点一并修改。 由于树高为<span class="math inline">\(~O(\log n)~\)</span>，故复杂度<span class="math inline">\(~O(\log n)~\)</span>。 示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void add(int x, int y) // 在x位置上加上y</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = x; i &lt;= n; i += lowbit(i)) // 找到与x相关的所有位置</span><br><span class="line">        c[i] += y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求前n项和">求前<span class="math inline">\(~n~\)</span>项和</h3><p>求前<span class="math inline">\(~n~\)</span>项和时，由于在<span class="math inline">\(~C_n~\)</span>记录了下标从<span class="math inline">\(~n-lowbit(n)+1~\)</span>到<span class="math inline">\(~n~\)</span>的子段和，故可以直接在结果中加上<span class="math inline">\(~C_n~\)</span>，接下来只需要计算<span class="math inline">\(~C[n-lowbit(n)]~\)</span>的值。一直循环下去即可。 由于树高为<span class="math inline">\(~O(\log n)~\)</span>，故复杂度<span class="math inline">\(~O(\log n)~\)</span>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int sum(int x) // 前x项和</span><br><span class="line">&#123;</span><br><span class="line">    int ret(0);</span><br><span class="line">    for(int i = x; i &gt;= 1; i -= lowbit(i))</span><br><span class="line">        ret += c[i];</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维树状数组">二维树状数组</h2><p>其结构与普通的树状数组相同，只不过在求前<span class="math inline">\(~n~\)</span>项和时是从<span class="math inline">\(~(1,1)~\)</span>到<span class="math inline">\(~(x,y)~\)</span>求和。 示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int lowbit(int x)</span><br><span class="line">&#123;</span><br><span class="line">return x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line">void add(int x, int y, int val) // 将[x][y]的值增加val</span><br><span class="line">&#123;</span><br><span class="line">for(int i = x; i &lt; N; i += lowbit(i))</span><br><span class="line">for(int j = y; j &lt; N; j += lowbit(j))</span><br><span class="line">sum[i][j] += val;</span><br><span class="line">&#125;</span><br><span class="line">int sum(int x, int y) // 求以[1][1]为左上角端点,[x][y]为右下角端点的矩阵和</span><br><span class="line">&#123;</span><br><span class="line">int ret(0);</span><br><span class="line">for(int i = x; i &gt; 0; i -= lowbit(i))</span><br><span class="line">for(int j = y; j &gt; 0; j -= lowbit(j))</span><br><span class="line">ret += sum[i][j];</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树状数组的应用">树状数组的应用</h2><ul><li>动态查询子段和——HDU 1166 敌兵布阵；</li><li>求逆序数——HDU 1349 Minimum Inversion Number；</li></ul><h3 id="练习题目">练习题目</h3><ul><li>POJ 1195 Mobile phones</li><li>POJ 2481 Cows</li><li>POJ 2155 Matrix</li><li>POJ 3321 Apple Tree</li><li>HDU 1556 color the ball</li><li>POJ 2299 Ultra-QuickSort</li></ul><h3 id="参考资料">参考资料</h3><ul><li><a href="http://blog.csdn.net/matrix_reloaded/article/details/32101509" target="_blank" rel="noopener">Matrix_Reloaded——树状数组题目集</a></li><li><a href="http://dongxicheng.org/structure/binary_indexed_tree/" target="_blank" rel="noopener">董的博客——树状数组</a></li><li><a href="http://blog.csdn.net/x_iya/article/details/8943264" target="_blank" rel="noopener">晚晴小筑——树状数组学习笔记</a></li></ul>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构——平衡树 Treap</title>
      <link href="/2017/02/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%B9%B3%E8%A1%A1%E6%A0%91%20Treap/"/>
      <content type="html"><![CDATA[<h2 id="treap概述">Treap概述</h2><p>Treap是一种平衡二叉树，不过Treap会记录一个优先级（一般来说是随机生成），即Treap在以关键码构成二叉搜索树的同时，还会按照优先级的高低满足堆的性质，因此得名Treap（Tree + Heap）。 Treap不是二叉堆，二叉堆必须是完全二叉树，但Treap不必是。</p><p>对于每个结点，该结点的优先级不大于其所有孩子的优先级。Treap引入优先级的原因就是防止BST（二叉搜索树）退化成一条链，从而影响查询效率。</p><p>所以对于结点上的关键字来说，它是一颗BST，而对于结点上的优先级来讲，它是一个小顶堆。其平均查找长度为<span class="math inline">\(~O(\log n)~\)</span>。 Treap有插入、删除、旋转和查询等基本操作，进而可以实现查询第<span class="math inline">\(~k~\)</span>大和查询关键字<span class="math inline">\(~x~\)</span>排名等功能。</p><h2 id="treap的结构">Treap的结构</h2><p>Treap是一颗BST，所以Treap的每一个结点都需要记录一个关键字和两个儿子指针； Treap又是一个小顶堆，所以需要记录一个优先级。 结点的构建方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Treap_Node</span><br><span class="line">&#123;</span><br><span class="line">    Treap_Node *left, *right; // 儿子指针</span><br><span class="line">    int value, fix; // 值和优先级</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="treap的操作">Treap的操作</h2><h3 id="旋转">旋转</h3><p>Treap本身对于关键字的构建和二叉查找树相同，但为对优先级维持其最小堆的性质，需要对树的结构进行调整，称为旋转，其操作方式如下：</p><ul><li><strong>左旋</strong>：将子树的根结点旋转到其根的左子树位置，同时根节点的右子节点成为该子树的根；</li><li><strong>右旋</strong>：将子树的根结点旋转到其根的右子树位置，同时根节点的左子节点成为该子树的根。</li></ul><p>例如下面这两棵树（表示方法为<code>[关键字-优先级]</code>）可以互相对根结点旋转得到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      [<span class="number">4</span><span class="number">-3</span>]                       [<span class="number">2</span><span class="number">-1</span>]</span><br><span class="line">      /   \     ==== 左旋 ===&gt;    /   \</span><br><span class="line">   [<span class="number">3</span><span class="number">-1</span>] [<span class="number">5</span><span class="number">-5</span>]                 [<span class="number">1</span><span class="number">-2</span>] [<span class="number">4</span><span class="number">-3</span>]</span><br><span class="line">   /   \        &lt;=== 右旋 ====       /   \</span><br><span class="line">[<span class="number">1</span><span class="number">-2</span>] [<span class="number">2</span><span class="number">-4</span>]                       [<span class="number">3</span><span class="number">-4</span>] [<span class="number">5</span><span class="number">-5</span>]</span><br></pre></td></tr></table></figure><p>旋转的实例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Left_Rotate</span><span class="params">(Treap_Node *&amp;a)</span> <span class="comment">//左旋 节点指针一定要传递引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Treap_Node *b = a -&gt; right;</span><br><span class="line">  a -&gt; right = b -&gt; left;</span><br><span class="line">  b -&gt; left = a;</span><br><span class="line">  a = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Right_Rotate</span><span class="params">(Treap_Node *&amp;a)</span> <span class="comment">//右旋 节点指针一定要传递引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Treap_Node *b = a -&gt; left;</span><br><span class="line">  a -&gt; left = b -&gt; right;</span><br><span class="line">  b -&gt; right = a;</span><br><span class="line">  a = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用下标来压缩代码量，具体实现方法在后边的模板给出。</p><h3 id="插入">插入</h3><p>在Treap中插入元素的法则与在BST中插入的法则相同，但插入完成后可能会破坏堆的性质，所以插入完成后要进行旋转，具体方法如下：</p><ol style="list-style-type: decimal"><li>从根结点开始访问；</li><li>若当前结点为空，则直接插入，否则执行下一步；</li><li>递归访问左右子树：</li></ol><ul><li>若插入的关键字小于当前访问结点，则访问其左子树，若插入后左子结点的优先级小于当前访问结点的优先级，则对当前结点进行右旋；</li><li>若插入的关键字大于当前访问结点，则访问其右子树，若插入后右子结点的优先级小于当前访问结点的优先级，则对当前结点进行左旋；</li></ul><p>以下是一个例子：</p><p>先在Treap中按照BST的方法插入<code>[3-2]</code>结点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                                          [2-1]</span><br><span class="line">   [2-1]                                  /   \</span><br><span class="line">   /   \                               [1-3] [5-4]</span><br><span class="line">[1-3] [5-4]      ==== 插入[3-2] ===&gt;          /   \</span><br><span class="line">      /   \                      不平衡 =&gt; [4-5] [6-6]</span><br><span class="line">   [4-5] [6-6]                            /</span><br><span class="line">                                       [3-2]</span><br></pre></td></tr></table></figure><p>由于当前访问结点<code>[4-5]</code>的左子结点<code>[3-2]</code>的优先级小于当前结点的优先级，需要进行右旋操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   [2-1]                                [2-1]</span><br><span class="line">   /   \                                /   \</span><br><span class="line">[1-3] [5-4]                          [1-3] [5-4] &lt;= 不平衡</span><br><span class="line">      /   \      == 对[4-5]右旋 =&gt;          /   \</span><br><span class="line">   [4-5] [6-6]                           [3-2] [6-6]</span><br><span class="line">   /                                        \</span><br><span class="line">[3-2]                                      [4-5]</span><br></pre></td></tr></table></figure><p>至此<code>[3-2]</code>和<code>[4-5]</code>已经调整完毕，向上回溯发现<code>[5-4]</code>的左子结点<code>[3-2]</code>优先级低于<code>[5-4]</code>，故对<code>[5-4]</code>进行一次右旋操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   [2-1]                                [2-1]      </span><br><span class="line">   /   \                                /   \      </span><br><span class="line">[1-3] [5-4]                          [1-3] [3-2]   </span><br><span class="line">      /   \      == 对[5-4]右旋 =&gt;              \  </span><br><span class="line">   [3-2] [6-6]                                [5-4]</span><br><span class="line">       \                                      /   \      </span><br><span class="line">      [4-5]                                [4-5] [6-6]</span><br></pre></td></tr></table></figure><p>至此，整个树调整完毕，插入操作结束。</p><p>插入的示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Treap_Node *root;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Treap_Node *&amp;P, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!P) <span class="comment">// 找到位置，建立节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        P = <span class="keyword">new</span> Treap_Node;</span><br><span class="line">        P -&gt; value = value;</span><br><span class="line">        P -&gt; fix = rand(); <span class="comment">// 生成优先级</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(value &lt;= P -&gt; value)</span><br><span class="line">    &#123;</span><br><span class="line">        Treap_Insert(P -&gt; left, r);</span><br><span class="line">        <span class="keyword">if</span>(P -&gt; left -&gt; fix &lt; P -&gt; fix)</span><br><span class="line">            Right_Rotate(P); <span class="comment">// 左子结点优先级低，右旋</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Treap_Insert(P -&gt; right, r);</span><br><span class="line">        <span class="keyword">if</span>(P -&gt; right -&gt; fix &lt; P -&gt; fix)</span><br><span class="line">            Left_Rotate(P); <span class="comment">// 右子结点优先级低，左旋</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询">查询</h3><p>与BST相同的二分查找，查询复杂度为<span class="math inline">\(~O(\log n)~\)</span>。</p><h3 id="删除">删除</h3><p>Treap的删除是基于旋转操作的，很容易理解的便是，只需要将要删除的结点旋转为叶子结点，再执行删除，具体步骤如下：</p><ul><li>先在Treap中找到该结点，则有两种情况分述如下；</li></ul><ol style="list-style-type: decimal"><li>该节点为叶节点或链节点；</li><li>该节点有两个非空子节点；</li></ol><ul><li>针对情况1，若该节点有非空子结点，则用非空子节点代替该结点，否则用空节点代替该结点，然后删除该结点；</li><li>针对情况2，要先通过旋转使该结点使之可以直接删除，针对旋转有两种情况，分述如下：</li></ul><ol style="list-style-type: decimal"><li>如果该结点的左子结点的优先级比右子结点低，需要右旋该结点，使该结点降为右子树的根结点，然后跳转到右子树的根结点，重新判断；</li><li>反之，则左旋该结点，使该结点降为左子树的根结点，然后访问左子树的根，不断操作下去，直到该结点可以直接删除。</li></ol><p>以上操作复杂度为<span class="math inline">\(~O(\log N)~\)</span>。</p><p>示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Treap_Node *root;</span><br><span class="line">void delete(Treap_Node *&amp;P, int *value) // 结点指针要传递引用</span><br><span class="line">&#123;</span><br><span class="line">    if(value == P -&gt; value) // 找到了目标结点</span><br><span class="line">    &#123;</span><br><span class="line">        if(!P -&gt; right || !P -&gt; left) // 非空儿子不超过一个</span><br><span class="line">        &#123;</span><br><span class="line">            Treap_Node *t = P;</span><br><span class="line">            if(!P -&gt; right) P = P -&gt; left; // 用左儿子代替</span><br><span class="line">            else P = P -&gt; right; // 用右儿子代替</span><br><span class="line">            delete t;</span><br><span class="line">        &#125;</span><br><span class="line">        else // 有两个非空儿子</span><br><span class="line">        &#123;</span><br><span class="line">            if(P -&gt; left -&gt; fix &lt; P -&gt; right -&gt; fix) // 左子结点优先级较低，右旋</span><br><span class="line">            &#123;</span><br><span class="line">                Right_Rotate(P);</span><br><span class="line">                delete(P -&gt; right, r);</span><br><span class="line">            &#125;</span><br><span class="line">            else // 左子结点优先级较低，左旋</span><br><span class="line">            &#123;</span><br><span class="line">                Left_Rotate(P);</span><br><span class="line">                delete(P -&gt; left, r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(value &lt; P -&gt; value) delete(P -&gt; left, r); // 查找左子树</span><br><span class="line">    else delete(P -&gt; right, r); // 查找右子树</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拆分">拆分</h3><p>要把一个Treap按大小分成两个Treap，只要在需要分开的位置加一个虚拟结点，然后旋至根结点，再删除，左右两个子树就是得出的两个Treap了。根据BST的性质，这时左子树的所有节点都小于右子树的节点。 拆分操作的复杂度与插入相同，也是<span class="math inline">\(~O(\log N)~\)</span>。</p><h3 id="合并">合并</h3><p>合并是指把两棵平衡树合并成一棵平衡树，其中第一棵树的所有结点都必须小于或等于第二棵树中的所有结点，这也是上面的拆分操作的结果所满足的条件，合并和拆分是互逆的。 Treap的合并操作的过程和分离完全相反，只要加一个虚拟的根，把两棵树分别作为左右子树，然后把根删除就可以了。 合并操作的复杂度与删除相同，也是<span class="math inline">\(~O(\log N)~\)</span>。</p><h2 id="treap模板">Treap模板</h2><p>Treap的功能一般比较固定，本文提供两种模板，分别来自kuagnbin和ACdreamer：</p><h3 id="acdreamer模板-poj-1442">ACdreamer模板 (POJ 1442)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct Treap</span><br><span class="line">&#123;</span><br><span class="line">    int size;</span><br><span class="line">    int key, fix;</span><br><span class="line">    Treap *ch[2];</span><br><span class="line">    Treap(int key)</span><br><span class="line">    &#123;</span><br><span class="line">        size=1;</span><br><span class="line">        fix=rand();</span><br><span class="line">        this-&gt;key=key;</span><br><span class="line">        ch[0]=ch[1]=NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    int compare(int x) const</span><br><span class="line">    &#123;</span><br><span class="line">        if(x==key) return -1;</span><br><span class="line">        return x&lt;key? 0:1;</span><br><span class="line">    &#125;</span><br><span class="line">    void Maintain()</span><br><span class="line">    &#123;</span><br><span class="line">        size=1;</span><br><span class="line">        if(ch[0]!=NULL) size+=ch[0]-&gt;size;</span><br><span class="line">        if(ch[1]!=NULL) size+=ch[1]-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void Rotate(Treap* &amp;t, int d)</span><br><span class="line">&#123;</span><br><span class="line">    Treap *k=t-&gt;ch[d^1];</span><br><span class="line">    t-&gt;ch[d^1]=k-&gt;ch[d];</span><br><span class="line">    k-&gt;ch[d]=t;</span><br><span class="line">    t-&gt;Maintain();  </span><br><span class="line">    k-&gt;Maintain();</span><br><span class="line">    t=k;</span><br><span class="line">&#125;</span><br><span class="line">void Insert(Treap* &amp;t, int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(t==NULL) t=new Treap(x);</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        int d=x &lt; t-&gt;key ? 0 : 1;  </span><br><span class="line">        Insert(t-&gt;ch[d], x);</span><br><span class="line">        if(t-&gt;ch[d]-&gt;fix &gt; t-&gt;fix)</span><br><span class="line">            Rotate(t, d^1);</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;Maintain();</span><br><span class="line">&#125;</span><br><span class="line">void Delete(Treap* &amp;t, int x)</span><br><span class="line">&#123;</span><br><span class="line">    int d=t-&gt;compare(x);</span><br><span class="line">    if(d==-1)</span><br><span class="line">    &#123;</span><br><span class="line">        Treap *tmp=t;</span><br><span class="line">        if(t-&gt;ch[0]==NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            t=t-&gt;ch[1];</span><br><span class="line">            delete tmp;</span><br><span class="line">            tmp=NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(t-&gt;ch[1]==NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            t=t-&gt;ch[0];</span><br><span class="line">            delete tmp;</span><br><span class="line">            tmp=NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            int k=t-&gt;ch[0]-&gt;fix &gt; t-&gt;ch[1]-&gt;fix ? 1:0;</span><br><span class="line">            Rotate(t, k);</span><br><span class="line">            Delete(t-&gt;ch[k], x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else Delete(t-&gt;ch[d], x);</span><br><span class="line">    if(t!=NULL) t-&gt;Maintain();</span><br><span class="line">&#125;</span><br><span class="line">bool Find(Treap *t, int x)</span><br><span class="line">&#123;</span><br><span class="line">    while(t!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        int d=t-&gt;compare(x);</span><br><span class="line">        if(d==-1) return true;</span><br><span class="line">        t=t-&gt;ch[d];</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int Kth(Treap *t, int k)</span><br><span class="line">&#123;</span><br><span class="line">    if(t==NULL||k&lt;=0||k&gt;t-&gt;size)</span><br><span class="line">        return -1;</span><br><span class="line">    if(t-&gt;ch[0]==NULL&amp;&amp;k==1)</span><br><span class="line">        return t-&gt;key;</span><br><span class="line">    if(t-&gt;ch[0]==NULL)</span><br><span class="line">        return Kth(t-&gt;ch[1], k-1);</span><br><span class="line">    if(t-&gt;ch[0]-&gt;size&gt;=k)</span><br><span class="line">        return Kth(t-&gt;ch[0], k);</span><br><span class="line">    if(t-&gt;ch[0]-&gt;size+1==k)</span><br><span class="line">        return t-&gt;key;</span><br><span class="line">    return Kth(t-&gt;ch[1], k-1-t-&gt;ch[0]-&gt;size);</span><br><span class="line">&#125;</span><br><span class="line">int Rank(Treap *t, int x)</span><br><span class="line">&#123;</span><br><span class="line">    int r;</span><br><span class="line">    if(t-&gt;ch[0]==NULL) r=0;</span><br><span class="line">    else  r=t-&gt;ch[0]-&gt;size;</span><br><span class="line">    if(x==t-&gt;key) return r+1;</span><br><span class="line">    if(x&lt;t-&gt;key)</span><br><span class="line">        return Rank(t-&gt;ch[0], x);</span><br><span class="line">    return r+1+Rank(t-&gt;ch[1], x);</span><br><span class="line">&#125;</span><br><span class="line">void DeleteTreap(Treap* &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">    if(t==NULL) return;</span><br><span class="line">    if(t-&gt;ch[0]!=NULL) DeleteTreap(t-&gt;ch[0]);</span><br><span class="line">    if(t-&gt;ch[1]!=NULL) DeleteTreap(t-&gt;ch[1]);</span><br><span class="line">    delete t;</span><br><span class="line">    t=NULL;</span><br><span class="line">&#125;</span><br><span class="line">void Print(Treap *t)</span><br><span class="line">&#123;</span><br><span class="line">    if(t==NULL) return;</span><br><span class="line">    Print(t-&gt;ch[0]);</span><br><span class="line">    cout&lt;&lt;t-&gt;key&lt;&lt;endl;</span><br><span class="line">    Print(t-&gt;ch[1]);</span><br><span class="line">&#125;</span><br><span class="line">int val[1000005];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, x, m;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;val[i]);</span><br><span class="line">        int idx=1;</span><br><span class="line">        Treap *root=NULL;</span><br><span class="line">        for(int i=1; i&lt;=m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">            for(int j=idx; j&lt;=x; j++)</span><br><span class="line">                Insert(root, val[j]);</span><br><span class="line">            idx=x+1;</span><br><span class="line">            printf(&quot;%d\n&quot;, Kth(root, i));</span><br><span class="line">        &#125;</span><br><span class="line">        DeleteTreap(root);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="kuangbin模板-zoj-3765">kuangbin模板 (ZOJ 3765)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line">long long gcd(long long a, long long b)</span><br><span class="line">&#123;</span><br><span class="line">    if(b == 0)return a;</span><br><span class="line">    else return gcd(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line">const int MAXN = 300010;</span><br><span class="line">int num[MAXN], st[MAXN];</span><br><span class="line">struct Treap</span><br><span class="line">&#123;</span><br><span class="line">    int tot1;</span><br><span class="line">    int s[MAXN], tot2;</span><br><span class="line">    int ch[MAXN][1];</span><br><span class="line">    int key[MAXN], size[MAXN];</span><br><span class="line">    int sum0[MAXN], sum1[MAXN];</span><br><span class="line">    int status[MAXN];</span><br><span class="line">    void Init()</span><br><span class="line">    &#123;</span><br><span class="line">        tot1 = tot2 = 0;</span><br><span class="line">        size[0] = 0;</span><br><span class="line">        ch[0][0] = ch[0][2] = 0;</span><br><span class="line">        sum0[0] = sum1[0] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    bool random(double p)</span><br><span class="line">    &#123;</span><br><span class="line">        return (double)rand() / RAND_MAX &lt; p;</span><br><span class="line">    &#125;</span><br><span class="line">    int newnode(int val, int _status)</span><br><span class="line">    &#123;</span><br><span class="line">        int r;</span><br><span class="line">        if(tot2)r = s[tot2--];</span><br><span class="line">        else r = ++tot1;</span><br><span class="line">        size[r] = 1;</span><br><span class="line">        key[r] = val;</span><br><span class="line">        status[r] = _status;</span><br><span class="line">        ch[r][0] = ch[r][3] = 0;</span><br><span class="line">        sum0[r] = sum1[r] = 0;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">    void del(int r)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!r)return;</span><br><span class="line">        s[++tot2] = r;</span><br><span class="line">        del(ch[r][0]);</span><br><span class="line">        del(ch[r][4]);</span><br><span class="line">    &#125;</span><br><span class="line">    void push_up(int r)</span><br><span class="line">    &#123;</span><br><span class="line">        int lson = ch[r][0],  rson = ch[r][5];</span><br><span class="line">        size[r] = size[lson] + size[rson] + 1;</span><br><span class="line">        sum0[r] = gcd(sum0[lson], sum0[rson]);</span><br><span class="line">        sum1[r] = gcd(sum1[lson], sum1[rson]);</span><br><span class="line">        if(status[r] == 0)</span><br><span class="line">            sum0[r] = gcd(sum0[r], key[r]);</span><br><span class="line">        else sum1[r] = gcd(sum1[r], key[r]);</span><br><span class="line">    &#125;</span><br><span class="line">    void merge(int &amp;p, int x, int y)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!x || !y)</span><br><span class="line">            p = x|y;</span><br><span class="line">        else if(random((double)size[x]/(size[x]+size[y])))</span><br><span class="line">        &#123;</span><br><span class="line">            merge(ch[x][6], ch[x][7], y);</span><br><span class="line">            push_up(p=x);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            merge(ch[y][0], x, ch[y][0]);</span><br><span class="line">            push_up(p=y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void split(int p, int &amp;x, int &amp;y, int k)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!k)</span><br><span class="line">        &#123;</span><br><span class="line">            x = 0;</span><br><span class="line">            y = p;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(size[ch[p][0]] &gt;= k)</span><br><span class="line">        &#123;</span><br><span class="line">            y = p;</span><br><span class="line">            split(ch[p][0], x, ch[y][0], k);</span><br><span class="line">            push_up(y);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            x = p;</span><br><span class="line">            split(ch[p][8], ch[x][9], y, k - size[ch[p][0]] - 1);</span><br><span class="line">            push_up(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void build(int &amp;p, int l, int r)</span><br><span class="line">    &#123;</span><br><span class="line">        if(l &gt; r)return;</span><br><span class="line">        int mid = (l + r)/2;</span><br><span class="line">        p = newnode(num[mid], st[mid]);</span><br><span class="line">        build(ch[p][0], l, mid-1);</span><br><span class="line">        build(ch[p][10], mid+1, r);</span><br><span class="line">        push_up(p);</span><br><span class="line">    &#125;</span><br><span class="line">    void debug(int root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root == 0)return;</span><br><span class="line">        printf(&quot;%d 左儿子：%d 右儿子: %d size = %d key</span><br><span class="line">               = %d\n&quot;, root, ch[root][0], ch[root][11], size[root], key[root]);</span><br><span class="line">        debug(ch[root][0]);</span><br><span class="line">        debug(ch[root][12]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Treap T;</span><br><span class="line">char op[10];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, q;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;q) == 2)</span><br><span class="line">    &#123;</span><br><span class="line">        int root = 0;</span><br><span class="line">        T.Init();</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)</span><br><span class="line">            scanf(&quot;%d%d&quot;, &amp;num[i], &amp;st[i]);</span><br><span class="line">        T.build(root, 1, n);</span><br><span class="line">        while(q--)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%s&quot;, op);</span><br><span class="line">            if(op[0] == &apos;Q&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                int l, r, s;</span><br><span class="line">                scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;s);</span><br><span class="line">                int x, y, z;</span><br><span class="line">                T.split(root, x, z, r);</span><br><span class="line">                T.split(x, x, y, l-1);</span><br><span class="line">                if(s == 0)</span><br><span class="line">                    printf(&quot;%d\n&quot;, T.sum0[y] == 0? -1:T.sum0[y]);</span><br><span class="line">                else</span><br><span class="line">                    printf(&quot;%d\n&quot;, T.sum1[y] == 0?-1:T.sum1[y]);</span><br><span class="line">                T.merge(x, x, y);</span><br><span class="line">                T.merge(root, x, z);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(op[0] == &apos;I&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                int v, s, loc;</span><br><span class="line">                scanf(&quot;%d%d%d&quot;, &amp;loc, &amp;v, &amp;s);</span><br><span class="line">                int x, y;</span><br><span class="line">                T.split(root, x, y, loc);</span><br><span class="line">                T.merge(x, x, T.newnode(v, s));</span><br><span class="line">                T.merge(root, x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(op[0] == &apos;D&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                int loc;</span><br><span class="line">                scanf(&quot;%d&quot;, &amp;loc);</span><br><span class="line">                int x, y, z;</span><br><span class="line">                T.split(root, x, z, loc);</span><br><span class="line">                T.split(x, x, y, loc-1);</span><br><span class="line">                T.del(y);</span><br><span class="line">                T.merge(root, x, z);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(op[0] == &apos;R&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                int loc;</span><br><span class="line">                scanf(&quot;%d&quot;, &amp;loc);</span><br><span class="line">                int x, y, z;</span><br><span class="line">                T.split(root, x, z, loc);</span><br><span class="line">                T.split(x, x, y, loc-1);</span><br><span class="line">                T.status[y] = 1-T.status[y];</span><br><span class="line">                T.push_up(y);</span><br><span class="line">                T.merge(x, x, y);</span><br><span class="line">                T.merge(root, x, z);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                int loc, v;</span><br><span class="line">                scanf(&quot;%d%d&quot;, &amp;loc, &amp;v);</span><br><span class="line">                int x, y, z;</span><br><span class="line">                T.split(root, x, z, loc);</span><br><span class="line">                T.split(x, x, y, loc-1);</span><br><span class="line">                T.key[y] = v;</span><br><span class="line">                T.push_up(y);</span><br><span class="line">                T.merge(x, x, y);</span><br><span class="line">                T.merge(root, x, z);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习题目和参考资料">练习题目和参考资料</h2><h3 id="练习题目">练习题目</h3><ul><li>POJ 1442 Black Box</li><li>SPOJ 3273 Order statistic set</li><li>POJ 2761 Feed the dogs</li><li>Hohocoder 1325 平衡树·Treap</li><li>POJ 2985 The k-th LargestGroup</li><li>HDU 4585 ShaoLin</li><li>hdu 5096 ACM Rank</li></ul><h3 id="参考资料">参考资料</h3><ul><li><a href="http://blog.csdn.net/acdreamers/article/details/11309971" target="_blank" rel="noopener">ACdreamer的博客——Treap原理和实现方法</a></li><li><a href="http://dongxicheng.org/structure/treap/" target="_blank" rel="noopener">董的博客——数据结构之Treap</a></li><li><a href="http://blog.csdn.net/yang_yulei/article/details/46005845" target="_blank" rel="noopener">菜鸟的自留地——图文详解Treap</a></li><li><a href="http://www.nocow.cn/index.php/Treap" target="_blank" rel="noopener">NOCOW——Treap</a></li></ul>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构——线段树 Segment Tree</title>
      <link href="/2017/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%BA%BF%E6%AE%B5%E6%A0%91%20Segment%20Tree/"/>
      <content type="html"><![CDATA[<h2 id="线段树的概述">线段树的概述</h2><p>线段树是一颗完全二叉树，它的每个结点都表示一条线段，可以用来解决连续区间的动态查询问题。 线段树<strong>只支持区间信息可以由子区间信息合并而来的问题</strong>（如最值、乘积、区间和等）。</p><ul><li>线段树的结构：一般来说，区间<span class="math inline">\(~[a,b]~\)</span>的左儿子是<span class="math inline">\(~[a,m]~\)</span>，右儿子是<span class="math inline">\(~[m+1,b]~\)</span>；</li><li>线段树的空间：若数组长度是<span class="math inline">\(~N~\)</span>，线段树需要的最大空间为<span class="math inline">\(~4N~\)</span>；</li><li>线段树的效率：由于二叉树的性质，二叉树的操作时间复杂度基本保持在<span class="math inline">\(~O(\log N)~\)</span>。</li></ul><h2 id="线段树的操作">线段树的操作</h2><p>线段树的主要操作有：建树、更新、查询。</p><h3 id="建树">建树</h3><p>线段树的构造过程主要是递归构造：如果当前结点的区间<strong>左右端点相等</strong>，则给该节点<strong>赋值</strong>；若该结点区间<strong>左右端点不相等</strong>，则<strong>递归构造它的两个子树</strong>，构造完毕它的两个子树后再给该节点赋值。 建树的实例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[N], tree[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) tree[rt] = arr[l]; <span class="comment">// 左右端点相等，为叶子结点，直接赋值</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(l, m, rt &lt;&lt; <span class="number">1</span>); <span class="comment">// 构建左子树</span></span><br><span class="line">        build(m + <span class="number">1</span>, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>); <span class="comment">// 构建右子树</span></span><br><span class="line">    <span class="comment">// 由于不明确线段树存储的内容，故用push up函数来表示两个子区间的合并</span></span><br><span class="line">        push_up(rt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如下面的这段序列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">5</span>] = &#123;<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;;</span><br></pre></td></tr></table></figure><p>记录其区间和的线段树如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                         ([0, 4]=65)</span><br><span class="line">                       /            \</span><br><span class="line">            ([0, 2]=36)             ([3, 4]=29)</span><br><span class="line">            /          \            /         \</span><br><span class="line">      ([0, 1]=23) ([2, 2]=13) ([3, 3]=14) ([4, 4]=15)</span><br><span class="line">      /         \</span><br><span class="line">([0, 0]=11) ([1, 1]=12)</span><br></pre></td></tr></table></figure><p>记录其区间最大值的线段树如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                        ([0, 4]=15)</span><br><span class="line">                       /            \</span><br><span class="line">            ([0, 2]=13)             ([3, 4]=15)</span><br><span class="line">            /          \            /         \</span><br><span class="line">      ([0, 1]=12) ([2, 2]=13) ([3, 3]=14) ([4, 4]=15)</span><br><span class="line">      /         \</span><br><span class="line">([0, 0]=11) ([1, 1]=12)</span><br></pre></td></tr></table></figure><h3 id="查询">查询</h3><p>由于单点查询也可以视为左右端点相等的区间查询，故以下只讨论区间查询。 对于区间<span class="math inline">\(~[a,b]~\)</span>，可以从根结点开始，递归地判断查询区间与当前结点的关系。 由线段树的特性可知，查询的过程中，在每一层选择的区间个数不会多余两个（如果一层选择了三个区间，则一定会有两个相邻的区间是同一个结点的儿子，因此这两个区间可以直接合并为它们的父结点区间。） 区间查询的示例代码如下（以记录区间和为例）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [L, R]表示查询区间，rt表示当前区间标号，[l, r]为当前访问区间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 查询区间包含当前访问区间，直接返回当前区间的值</span></span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> tree[rt];</span><br><span class="line">    <span class="comment">// 否则，查询当前区间的两个儿子区间，再合并</span></span><br><span class="line">    <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>， ret(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(m &gt;= L) ret = query(L, R, l, m, rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(m &lt; R) ret += query(L, R, m + <span class="number">1</span>, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度的估计</strong>：由于该树共有<span class="math inline">\(~O(\log N)~\)</span>层，每层最多选择两个结点，故选择的结点个数也是<span class="math inline">\(~O(\log N)~\)</span>，即查询的时间复杂度为<span class="math inline">\(~O(\log N)~\)</span>。</p><h3 id="更新">更新</h3><p>更新是线段树的核心操作，线段树需要维护的一切信息都要由更新操作来体现。 对于更新，一个关键的操作是把儿子的信息合并到父结点上，以求和为例，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[rt] = tree[rt &lt;&lt; <span class="number">1</span>] + tree[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单点更新">单点更新</h4><p>单点更新的步骤非常简单：</p><ol style="list-style-type: decimal"><li>找到需要更新的单点，进行更新操作；</li><li>利用<code>push_up()</code>函数更新相关区间信息。</li></ol><p>仍然以区间求和为例，给出如下示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// idx为更新的下标，val为更新的值，[l, r]为更新区间，rt为更新区间标号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> val, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="comment">// 左右端点相等，进行更新</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree[rt] += val;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>; <span class="comment">// 递归地搜索左右子树</span></span><br><span class="line">    <span class="keyword">if</span>(m &gt;= idx) updata(idx, val, l, m, rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> updata(idx, val, m + <span class="number">1</span>, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    push_up(rt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="区间更新">区间更新</h4><p>线段树更新中<strong>最难理解的内容就是区间更新</strong>。 区间更新需要用到<strong>延迟标记</strong>，即给每个结点新增一个标记，记录这个结点是否被做过修改。 对于任意区间的修改，我们按照如下方式进行操作：</p><ol style="list-style-type: decimal"><li>按查询的方式将其划分成线段树中的结点；</li><li>修改这些结点的信息，并打上标记；</li><li>在修改和查询的时候，每访问到一个结点，如果该结点有标记，则执行<code>push_down</code>；</li><li><code>Push_Down</code>操作：</li></ol><ul><li>按标记对子结点进行更新；</li><li>给子结点都打上相同标记；</li><li>消掉该结点的标记。</li></ul><p>实例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> c,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R)</span><br><span class="line">    &#123;  </span><br><span class="line">        lazy[rt] += ...;</span><br><span class="line">        tree[rt] += ...;</span><br><span class="line">        <span class="keyword">return</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    PushDown(rt , r - l + <span class="number">1</span>); <span class="comment">// 向下更新</span></span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">if</span> (L &lt;= m) update(L , R , c , l, m, rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (m &lt; R) update(L , R , c , m + <span class="number">1</span>, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    PushUp(rt); <span class="comment">// 向上更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简化代码">简化代码</h3><p>在线段树中频繁用到的就是访问左儿子和访问右儿子两个操作，而查询等操作最常使用的就是根结点，我们可以利用宏定义将其简化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> root 1, n, 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br></pre></td></tr></table></figure><h2 id="基础练习题目">基础练习题目</h2><h3 id="hdu-4116-敌兵布阵">HDU 4116 敌兵布阵</h3><p>单点修改，区间查询：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> root 1, n, 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e4</span>;</span><br><span class="line"><span class="keyword">int</span> sum[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[rt] = sum[rt &lt;&lt; <span class="number">1</span>] + sum[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;sum[rt]);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(lson); build(rson);</span><br><span class="line">    push_up(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> d, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[rt] += d;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(m &gt;= k) updata(k, d, lson);</span><br><span class="line">    <span class="keyword">else</span> updata(k, d, rson);</span><br><span class="line">    push_up(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> sum[rt];</span><br><span class="line">    <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>, res(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(m &gt;= L) res = query(L, R, lson);</span><br><span class="line">    <span class="keyword">if</span>(m &lt; R) res += query(L, R, rson);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ca = <span class="number">1</span>; ca &lt;= T; ca++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>, ca);</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        build(root);</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>, op) &amp;&amp; op[<span class="number">0</span>] != <span class="string">'E'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'A'</span>) updata(a, b, root);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'S'</span>) updata(a, -b, root);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(a, b, root));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hdu-1754-i-hate-it">HDU 1754 I hate it</h3><p>单点更新，区间查询：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">222222</span>;</span><br><span class="line"><span class="keyword">int</span> MAX[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushUP</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MAX[rt] = max(MAX[rt &lt;&lt; <span class="number">1</span>], MAX[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;MAX[rt]);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build(lson); build(rson);</span><br><span class="line">PushUP(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> sc, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r)</span><br><span class="line">&#123;</span><br><span class="line">MAX[rt] = sc;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p &lt;= m) update(p, sc, lson);</span><br><span class="line"><span class="keyword">else</span> update(p, sc, rson);</span><br><span class="line">PushUP(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> MAX[rt];</span><br><span class="line"><span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>, ret(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(L &lt;= m) ret = max(ret , query(L, R, lson));</span><br><span class="line"><span class="keyword">if</span>(R &gt; m) ret = max(ret , query(L, R, rson));</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))</span><br><span class="line">&#123;</span><br><span class="line">build(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>, op, &amp;a, &amp;b);</span><br><span class="line"><span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'Q'</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(a, b, <span class="number">1</span>, n, <span class="number">1</span>));</span><br><span class="line"><span class="keyword">else</span> update(a, b, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hdu-1394-minimum-inversion-number">HDU 1394 Minimum Inversion Number</h3><p>单点更新，区间查询：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5555</span>;</span><br><span class="line"><span class="keyword">int</span> sum[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushUP</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sum[rt] = sum[rt &lt;&lt; <span class="number">1</span>] + sum[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sum[rt] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build(lson); build(rson);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r)</span><br><span class="line">&#123;</span><br><span class="line">sum[rt]++;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p &lt;= m) update(p, lson);</span><br><span class="line"><span class="keyword">else</span> update(p, rson);</span><br><span class="line">PushUP(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> sum[rt];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>, ret(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(L &lt;= m) ret += query(L, R, lson);</span><br><span class="line"><span class="keyword">if</span>(R &gt; m) ret += query(L, R, rson);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n))</span><br><span class="line">&#123;</span><br><span class="line">build(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x[i]);</span><br><span class="line">sum += query(x[i], n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">update(x[i], <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ret = sum;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">sum += n - x[i] - x[i] - <span class="number">1</span>;</span><br><span class="line">ret = min(ret, sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span> ,ret);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="poj-3468-a-simple-problem-with-integers">POJ 3468 A Simple Problem with Integers</h3><p>区间修改，区间求和（注意乘法会爆int）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">111111</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> lazy[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[rt] = sum[rt &lt;&lt; <span class="number">1</span>] + sum[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushDown</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lazy[rt])</span><br><span class="line">    &#123;</span><br><span class="line">        lazy[rt &lt;&lt; <span class="number">1</span>] += lazy[rt];</span><br><span class="line">        lazy[rt &lt;&lt; <span class="number">1</span>|<span class="number">1</span>] += lazy[rt];</span><br><span class="line">        sum[rt &lt;&lt; <span class="number">1</span>] += lazy[rt] * (m - (m &gt;&gt; <span class="number">1</span>));</span><br><span class="line">        sum[rt &lt;&lt; <span class="number">1</span>|<span class="number">1</span>] += lazy[rt] * (m &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        lazy[rt] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lazy[rt] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;sum[rt]);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">    PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> c, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        lazy[rt] += c;</span><br><span class="line">        sum[rt] += (<span class="keyword">long</span> <span class="keyword">long</span>)c * (r - l + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    PushDown(rt, r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= m) update(L, R, c, lson);</span><br><span class="line">    <span class="keyword">if</span> (m &lt; R) update(L, R, c, rson);</span><br><span class="line">    PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> sum[rt];</span><br><span class="line">    &#125;</span><br><span class="line">    PushDown(rt, r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= m) ret += query(L, R, lson);</span><br><span class="line">    <span class="keyword">if</span> (m &lt; R) ret += query(L, R, rson);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, Q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;Q);</span><br><span class="line">    build(<span class="number">1</span>, N, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (Q --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, op);</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">'Q'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(a, b, <span class="number">1</span>, N, <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">            update(a, b, c, <span class="number">1</span>, N, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他基础题目">其他基础题目</h3><ul><li>POJ 3667 Hotel：区间更新；</li><li>HDU 1540 Tunnel Warfare：单点更新，查询结点所在区间；</li><li>HDU 2871 Memory Control：与POJ 3667类似；</li></ul><h2 id="进阶题目">进阶题目</h2><p>这类题目或是写起来比较复杂，或是思维上有难度。</p><h3 id="bnuoj-51636-squared-permutation">BNUOJ 51636 Squared Permutation</h3><p>一次更新需要更新多个点，不容易刻画更新的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, i &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, i &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">111111</span>; </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[maxn], b[maxn]; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> left, right, value; </span><br><span class="line">&#125;   t[maxn &lt;&lt; <span class="number">2</span>]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     t[i].value = t[i &lt;&lt; <span class="number">1</span>].value+t[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].value; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[i].left = l; </span><br><span class="line">    t[i].right = r; </span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        t[i].value = a[a[l]]; </span><br><span class="line">        <span class="keyword">return</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>; </span><br><span class="line">    build(lson);  build(rson); </span><br><span class="line">    push_up(i); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> val, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == t[i].left &amp;&amp; k == t[i].right)</span><br><span class="line">    &#123;</span><br><span class="line">        t[i].value=val; </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (t[i].left + t[i].right) &gt;&gt; <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">if</span>(k &lt;= m) update(k, val, i &lt;&lt; <span class="number">1</span>); </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m + <span class="number">1</span> &lt;= k) update(k, val, i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>); </span><br><span class="line">    push_up(i); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == t[i].left &amp;&amp; r == t[i].right) <span class="keyword">return</span> t[i].value; </span><br><span class="line">    <span class="keyword">int</span> m = (t[i].left+t[i].right) &gt;&gt; <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">if</span>(r &lt;= m)</span><br><span class="line">        <span class="keyword">return</span> query(l, r, i &lt;&lt; <span class="number">1</span>); </span><br><span class="line">    <span class="keyword">if</span>(m + <span class="number">1</span> &lt;= l)</span><br><span class="line">        <span class="keyword">return</span> query(l, r, i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> query(lson) + query(rson); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T); </span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n, q; </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]); </span><br><span class="line">            b[a[i]] = i; </span><br><span class="line">        &#125;</span><br><span class="line">        build(<span class="number">1</span>, n, <span class="number">1</span>); </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q); </span><br><span class="line">        <span class="keyword">int</span> op, l, r; </span><br><span class="line">        <span class="keyword">while</span>(q--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;op, &amp;l, &amp;r); </span><br><span class="line">            <span class="keyword">if</span>(op == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(a[l], a[r]); </span><br><span class="line">                swap(b[a[l]], b[a[r]]); </span><br><span class="line">                update(l, a[a[l]], <span class="number">1</span>); </span><br><span class="line">                update(b[l], a[l], <span class="number">1</span>); </span><br><span class="line">                update(r, a[a[r]], <span class="number">1</span>); </span><br><span class="line">                update(b[r], a[r], <span class="number">1</span>); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(l, r, <span class="number">1</span>)); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="codeforces-gym-101116g-ground-defense">Codeforces gym 101116G Ground Defense</h3><p>区间更新，实现起来比较麻烦。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> root 1, n, 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500005</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> va[maxn &lt;&lt; <span class="number">2</span>], vd[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> lazy_a[maxn &lt;&lt; <span class="number">2</span>], lazy_d[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va[rt] = vd[rt] = lazy_a[rt] = lazy_d[rt] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va[rt &lt;&lt; <span class="number">1</span>] += lazy_a[rt];     lazy_a[rt &lt;&lt; <span class="number">1</span>] += lazy_a[rt];</span><br><span class="line">    va[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += lazy_a[rt]; lazy_a[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += lazy_a[rt];</span><br><span class="line">    lazy_a[rt] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    vd[rt &lt;&lt; <span class="number">1</span>] += lazy_d[rt];     lazy_d[rt &lt;&lt; <span class="number">1</span>] += lazy_d[rt];</span><br><span class="line">    vd[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += lazy_d[rt]; lazy_d[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += lazy_d[rt];</span><br><span class="line">    lazy_d[rt] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> d, <span class="keyword">long</span> <span class="keyword">long</span> L, <span class="keyword">long</span> <span class="keyword">long</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(R == r &amp;&amp; L == l)</span><br><span class="line">    &#123;</span><br><span class="line">        va[rt] += a; lazy_a[rt] += a;</span><br><span class="line">        vd[rt] += d; lazy_d[rt] += d;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(rt);</span><br><span class="line">    <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(R &lt;= m) update(a, d, L, R, lson);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L &gt; m) update(a, d, L, R, rson);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        update(a, d, L, m, lson);</span><br><span class="line">        update(a, d, m + <span class="number">1</span>, R, rson);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> va[rt] + l * vd[rt];</span><br><span class="line">    push_down(rt);</span><br><span class="line">    <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p &lt;= m) <span class="keyword">return</span> query(p, lson);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(p, rson);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n);</span><br><span class="line">        build(root);</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> op[<span class="number">5</span>];</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, op);</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'Q'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> idx;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;idx);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(idx, root));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'U'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> dir[<span class="number">5</span>];</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%s"</span>, dir);</span><br><span class="line">                <span class="keyword">int</span> idx, d, l, r;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> s, a;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%lld%lld%d"</span>, &amp;idx, &amp;s, &amp;a, &amp;d);</span><br><span class="line">                <span class="keyword">if</span>(dir[<span class="number">0</span>] == <span class="string">'E'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    l = idx;</span><br><span class="line">                    r = l + d - <span class="number">1</span>;</span><br><span class="line">                    s -= l * a;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    r = idx;</span><br><span class="line">                    l = r - d + <span class="number">1</span>;</span><br><span class="line">                    s += r * a;</span><br><span class="line">                    a = -a;</span><br><span class="line">                &#125;</span><br><span class="line">                update(s, a, l, r, root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hdu-5023-a-corrupt-mayors-performance-art">HDU 5023 A Corrupt Mayor's Performance Art</h3><p>区间修改的又一典型例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __WINDOWS_</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> showtime printf(<span class="meta-string">"time = %.15f\n"</span>, clock() / (double)CLOCKS_PER_SEC);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> root 1, n, 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e6</span> + <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x, lz;</span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line">    Node(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">long</span> <span class="keyword">long</span> c, <span class="keyword">long</span> <span class="keyword">long</span> d)</span><br><span class="line">    &#123;</span><br><span class="line">        l = a; r = b; x = c; lz = d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; a[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans, b[<span class="number">45</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[rt].l == a[rt].r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(a[rt].lz == <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    a[rt &lt;&lt; <span class="number">1</span>].lz = a[rt &lt;&lt; <span class="number">1</span>].x = a[rt].lz;</span><br><span class="line">    a[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lz = a[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].x = a[rt].lz;</span><br><span class="line">    a[rt].lz = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[rt] = Node(l, r, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt, <span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[rt].l == l &amp;&amp; a[rt].r == r)</span><br><span class="line">    &#123;</span><br><span class="line">        a[rt].lz = b[op];</span><br><span class="line">        a[rt].x = b[op];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(rt);</span><br><span class="line">    <span class="keyword">int</span> m = (a[rt].l + a[rt].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= m) update(l, r, rt &lt;&lt; <span class="number">1</span>, op);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l &gt; m) update(l, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, op);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        update(lson, op);</span><br><span class="line">        update(rson, op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a[rt &lt;&lt; <span class="number">1</span>].x == a[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].x)</span><br><span class="line">        a[rt].x = a[rt &lt;&lt; <span class="number">1</span>].x;</span><br><span class="line">    <span class="keyword">else</span> a[rt].x = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[rt].x != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans |= a[rt].x;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (a[rt].l + a[rt].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    push_down(rt);</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= m) query(l, r, rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l &gt; m) query(l, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        query(lson);</span><br><span class="line">        query(rson);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">30</span>; i++)</span><br><span class="line">        b[i] = b[i - <span class="number">1</span>] * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span> &amp;&amp; n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        build(root);</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> op[<span class="number">5</span>];</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, op);</span><br><span class="line">            <span class="keyword">int</span> l, r;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'P'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">                update(l, r, <span class="number">1</span>, x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'Q'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = <span class="number">0</span>;</span><br><span class="line">                query(l, r, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> first = <span class="number">1</span>, x;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(ans &amp; <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(first == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">                        first = <span class="number">0</span>;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"%d"</span>, i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans /= <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他线段树进阶题目">其他线段树进阶题目</h3><ul><li>HDU 3308 LCIS：细节很多，非常容易错；</li><li>POJ 1436 Horizontally Visible Segments：转化为区间染色；</li><li>HDU 4747 Mex： 区间更新，区间求和；</li><li>HDU 4601 Letter Tree：线段树+字典树；</li><li>Codeforces 258E Little Elephant and Tree：DFS+线段树；</li><li>Codeforces 269D Maximum Waterfall：线段树+dp。</li></ul>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mathematica学习[1]——图像复原与处理</title>
      <link href="/2017/02/16/Mathematica%E6%8A%80%E5%B7%A7%5B1%5D%E2%80%94%E2%80%94%E5%9B%BE%E5%83%8F%E5%A4%8D%E5%8E%9F%E4%B8%8E%E5%A4%84%E7%90%86/"/>
      <content type="html"><![CDATA[<h2 id="函数介绍">函数介绍</h2><p>官方文档中对该函数的翻译是“润饰”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inpaint[image, region]</span><br><span class="line">    润饰 region 中非零元素的 image 部分</span><br></pre></td></tr></table></figure><p>Inpaint函数在使用时，需要两个参数，分别是<em>image</em>和<em>region</em>。一般来说，<em>image</em>就是需要处理的原始图像，而<em>region</em>更像是一个mask。所以Inpaint一般需要接受两个大小相同的图像，也总是会返回和image有着相同大小和类型的图片。</p><hr><p>Inpaint函数有接受Method选项，并给出如下方法：</p><table><thead><tr class="header"><th align="center">方法</th><th align="center">含义</th></tr></thead><tbody><tr class="odd"><td align="center">&quot;Diffusion&quot;</td><td align="center">迭代各向同性扩散方法</td></tr><tr class="even"><td align="center">&quot;TotalVariation&quot;</td><td align="center">迭代全变差方法</td></tr><tr class="odd"><td align="center">&quot;FastMarching&quot;</td><td align="center">快速行进方法</td></tr><tr class="even"><td align="center">&quot;NavierStokes&quot;</td><td align="center">Navier-Stokes 方法</td></tr><tr class="odd"><td align="center">&quot;TextureSynthesis&quot;</td><td align="center">利用随机采样的最佳拟合纹理合成方法</td></tr></tbody></table><p>默认情况下，使用TextureSynthesis方法。</p><hr><p>设置 Method-&gt;{&quot;TotalVariation&quot;, <em>subopt</em>} 下，可以指定下列子选项：</p><table><thead><tr class="header"><th align="center">子操作</th><th align="center">值</th><th align="center">含义</th></tr></thead><tbody><tr class="odd"><td align="center">&quot;NoiseModel&quot;</td><td align="center">&quot;Gaussian&quot;</td><td align="center">&quot;Gaussian&quot;、&quot;Laplacian&quot;或&quot;Poisson&quot;</td></tr><tr class="even"><td align="center">&quot;Regularization&quot;</td><td align="center">Automatic</td><td align="center">正则化参数</td></tr></tbody></table><hr><p>设置 Method-&gt;{&quot;TextureSynthesis&quot;, <em>subopt</em>} 下，可以指定下列子选项：</p><table><thead><tr class="header"><th align="center">子操作</th><th align="center">值</th><th align="center">含义</th></tr></thead><tbody><tr class="odd"><td align="center">Masking</td><td align="center">Automatic</td><td align="center">为二元掩模，可指定用于求出最佳拟合纹理的像素</td></tr><tr class="even"><td align="center">&quot;MaxSamples&quot;</td><td align="center">300</td><td align="center">用于求出最佳拟合纹理的样本最大数量</td></tr><tr class="odd"><td align="center">&quot;NeighborCount&quot;</td><td align="center">30</td><td align="center">用于纹理比较的邻近像素的数目</td></tr></tbody></table><hr><p>Inpaint 接受 MaxIterations 选项，指定使用迭代方法执行迭代的最大数. 默认设置是 MaxIterations-&gt;100。关于参数，本文不再详谈。</p><h2 id="两个应用">两个应用</h2><p>Inpaint函数有着强大的功能，在图形处理中有着不可思议的作用，以下依据<a href="http://reference.wolfram.com/language/ref/Inpaint.html" target="_blank" rel="noopener">官方文档</a>介绍Inpaint的两个较为直接的应用。</p><h3 id="修复图像损坏的部分">修复图像损坏的部分</h3><p>用合适的Mask图片传入Inpaint可以修复图像的损坏部分：</p><div class="figure"><img src="http://static.zybuluo.com/lzcwr/acvr1e10vda50lld9excuywm/image_1b95789ipkjg1gudqgq9mqrmg57.png" alt="image_1b95789ipkjg1gudqgq9mqrmg57.png-182.4kB"><p class="caption">image_1b95789ipkjg1gudqgq9mqrmg57.png-182.4kB</p></div><p>在处理中也可以使用其他的Method选项：</p><div class="figure"><img src="http://static.zybuluo.com/lzcwr/xzw3f225yjm0ggjr98sfi3sr/image_1b9579v3t1mvv1nc0163e18ps27q5k.png" alt="image_1b9579v3t1mvv1nc0163e18ps27q5k.png-83.3kB"><p class="caption">image_1b9579v3t1mvv1nc0163e18ps27q5k.png-83.3kB</p></div><h3 id="去除图片中较大的对象">去除图片中较大的对象</h3><p>通过调整Mask图片的形状和黑白区域分配，可以去除图片中较大的对象。以下是官方文档中的两个例子：</p><p><img src="http://static.zybuluo.com/lzcwr/3qjuejedy1c4s4ztljrc40h7/image_1b957fb3hjgqv46l3q1af9l761.png" alt="image_1b957fb3hjgqv46l3q1af9l761.png-55.6kB"> <img src="http://static.zybuluo.com/lzcwr/xbwvvxwxmytb0o8rl9uyc159/image_1b957g7671akai2lt7hsu358n6e.png" alt="image_1b957g7671akai2lt7hsu358n6e.png-99.4kB"></p><h2 id="mask图片的生成技巧">Mask图片的生成技巧</h2><p>从以上例子中可以看出，关于图像的修复和改动，最关键最核心的就是函数中的region参数，也就是Mask图片的生成。以下讨论两种生成Mask图片的方法：</p><h3 id="掩模工具">掩模工具</h3><p>利用“去除较大对象”的功能以及<code>Mathematica</code>自带的掩模工具，可以去除图片上的水印。 例如下面这张图片，也就是我的头像。来源是<a href="http://baike.baidu.com/link?url=KT1OSCvJNCAtnTD8lciSq6sfiH8Zd2hDvqy93GIykGWVhQ2sDAVivz4fyu41sHA-vu1ZWB_LDp61jTpd6GodvrEWPS9Fndw9lrQ_ek6-0xDlHnj7v4LuH5S9TmCUUIHnfPhhmYJogwklspdtxiq-HeAaWAdvJ2MZDjM3Y8v8klW" target="_blank" rel="noopener">百度百科-正一百二十胞体</a>。但图片左下角带有百度百科的水印：</p><div class="figure"><img src="http://static.zybuluo.com/lzcwr/xh1jopg1uuaq5f5k2uqoamvn/image_1b93g3b6r1ac3qugnj33q4pgj1f.png" alt="image_1b93g3b6r1ac3qugnj33q4pgj1f.png-75kB"><p class="caption">image_1b93g3b6r1ac3qugnj33q4pgj1f.png-75kB</p></div><p>利用Inpaint函数可以很好地处理这件事情，以下是处理的方法：</p><ul><li>先将图片导入<code>Mathematica</code>：<img src="http://static.zybuluo.com/lzcwr/s4c1yxtq4yrk05qzuqr0wcnr/mma1-1.jpg" alt="mma1-1.jpg-20kB"></li><li>然后进行掩模，即生成一个黑白的图片，其中黑色的部分保留，白色的部分去除：<img src="http://static.zybuluo.com/lzcwr/bqzwzw262qdhi0ocq4lco285/mma1-2.jpg" alt="mma1-2.jpg-18.5kB"></li><li>掩模完成后就可以直接调用Inpaint函数将左下角的水印去掉了（<code>Mathematica</code>可以直接把图片作为参数，非常便捷）：<img src="http://static.zybuluo.com/lzcwr/hunbysi0g3gojegdgdlmmuay/mma1-3.jpg" alt="mma1-3.jpg-9.7kB"></li><li>然后将图像导出，即可得到一个没有水印的图片（如下图所示）。</li></ul><div class="figure"><img src="http://static.zybuluo.com/lzcwr/05x06nkjuw8oztloswld5zgs/image_1b93giupt1321lqv26p1b2r183p3j.png" alt="image_1b93giupt1321lqv26p1b2r183p3j.png-75.7kB"><p class="caption">image_1b93giupt1321lqv26p1b2r183p3j.png-75.7kB</p></div><p>在很多情况下，用掩模工具生成Mask图片作为region参数对图像进行处理都是非常方便的。</p><h3 id="利用颜色的值自动从原图生成mask">利用颜色的值自动从原图生成Mask</h3><p>还有一种方法能够直接从原图中生成Mask图片，以下是官方文档中非常具有启发性的一个例子：</p><div class="figure"><img src="http://static.zybuluo.com/lzcwr/qfsl33sfd2l7a44mv4cdnz8a/image_1b958k6rv1mg1ai41lafg3abd26r.png" alt="image_1b958k6rv1mg1ai41lafg3abd26r.png-104.6kB"><p class="caption">image_1b958k6rv1mg1ai41lafg3abd26r.png-104.6kB</p></div><p>在这个例子中，非常完美地地去掉了图片右下的日期标记，而且在命令中没有直接出现Mask图片，而是用了一行命令来自动生成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dilation[Binarize[ColorSeparate[img][[1]], 0.93], 1]</span><br></pre></td></tr></table></figure><p>其含义是：用ColorSeperate函数将图片分为RGB三层，然后将Red层像素值大于255×0.93的设为白色，其余为黑色，然后用二值化函数Binarize来生成黑白图片作为region参数。其中的Dilation函数是一个处理函数，本文不多赘述。</p><p>由这个例子，我们可以产生一种想法： 用图像处理的软件很简单地将图片中不想要的部分染色（染成一个图片当中没有的颜色），然后用上面的方法生成一个region参数，再对原图进行处理。此时便不再需要掩模：</p><ul><li>比如这样一张照片： <img src="http://static.zybuluo.com/lzcwr/o2ihbg3nlnrfe0qtvvkza3u9/image_1b94pcrduqe51l2h1k4c12hq10g240.png" alt="image_1b94pcrduqe51l2h1k4c12hq10g240.png-242.1kB"></li><li>用工具把不想要的部分染色，作为Mask <img src="http://static.zybuluo.com/lzcwr/3tin320gpf8dhifgxvor4rf9/image_1b94pkcvg9q7705s4r1fdtupo4d.png" alt="image_1b94pkcvg9q7705s4r1fdtupo4d.png-199.2kB"></li><li>运行代码可得如下结果，效果 <del>不咋地</del> 很好，但是确实能去掉该部分。（原因是像素值筛选范围的设定出现了问题，不过我比较懒，没有进行更好的调整） <img src="http://static.zybuluo.com/lzcwr/g1t9y9iqf73nf3vnxwcm08x9/image_1b94qh78nbpvmfq6tm1e471d5h4q.png" alt="image_1b94qh78nbpvmfq6tm1e471d5h4q.png-234.6kB"></li></ul><p>原理和官方文献中的类似，于是处理这样的问题<strong>只需要一行代码</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Inpaint[#1,ImageResize[Binarize[#2,#==&#123;1,0,0&#125;&amp;], ImageDimensions@#1]]&amp;[img,mask]</span><br></pre></td></tr></table></figure><h2 id="纹理和画作分析">纹理和画作分析</h2><p>如果说刚刚的功能看起来也比较平常的话，那么根据一幅画来创作一幅风格相近的画，或是分析图片中的纹理，总应该是看起来很高端很厉害的功能了。以下是官方文档中的例子：</p><ul><li>纹理合成：</li></ul><div class="figure"><img src="http://static.zybuluo.com/lzcwr/1od15epr9dwdghtqpttbo7jz/image_1b95a50op1m0h14pbs74fjdp6978.png" alt="image_1b95a50op1m0h14pbs74fjdp6978.png-125.8kB"><p class="caption">image_1b95a50op1m0h14pbs74fjdp6978.png-125.8kB</p></div><ul><li>画作分析：</li></ul><div class="figure"><img src="http://static.zybuluo.com/lzcwr/00ngpy90vzmlfb2zgn2jw2l0/image_1b95auqqggfh1lic1f5k1qsq16tc7l.png" alt="image_1b95auqqggfh1lic1f5k1qsq16tc7l.png-267.5kB"><p class="caption">image_1b95auqqggfh1lic1f5k1qsq16tc7l.png-267.5kB</p></div><p>有关<code>Mathematica</code>的其他资料请自行查阅。本文只做普及，不做详解。</p>]]></content>
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> Mathematica </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>github+hexo 搭建个人博客</title>
      <link href="/2017/02/12/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <content type="html"><![CDATA[<p><code>github + hexo 搭建博客详细过程.</code></p><blockquote><p><strong>本文针对的主要是Windows用户，不过总体步骤和Linux/Mac大同小异。</strong></p></blockquote><a id="more"></a><ul><li><strong>本文中所有需要打开文件编辑的地方均不推荐记事本，推荐使用<a href="https://notepad-plus-plus.org/" target="_blank" rel="noopener">nodepad++</a>或<a href="http://www.sublimetext.com/" target="_blank" rel="noopener">sublime text</a>。</strong></li></ul><h2 id="环境配置">环境配置</h2><h3 id="安装git-bash">安装git bash</h3><p>直接在<a href="https://git-for-windows.github.io/" target="_blank" rel="noopener">官网</a>下载最新版本并安装；</p><h3 id="申请github账号">申请github账号</h3><p>在<a href="https://github.com/" target="_blank" rel="noopener">github</a>填写信息注册账号；</p><ul><li><strong>方便起见，以下均假设你的github用户名为 XXX.</strong></li><li><strong>方便起见，以下均假设你的github邮箱为 aa@bb.com</strong></li></ul><h3 id="建立github仓库">建立github仓库</h3><ul><li>建立一个仓库来存博客的源码，假设标题为“blog”；</li><li>建立一个github仓库，标题是<code>XXX.github.io</code>；</li></ul><h3 id="安装node.js">安装Node.js</h3><ul><li>安装Node.js：直接在Node.js<a href="https://nodejs.org/en/" target="_blank" rel="noopener">官网</a>下载最新版本并安装；</li></ul><h3 id="安装hexo">安装hexo</h3><ul><li>在git bash中执行如下命令以安装hexo（必须在安装Node.js之后进行）；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><ul><li>执行以下语句以安装hexo所需的依赖包； <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></li></ul><h2 id="搭建博客">搭建博客</h2><h3 id="本地搭建">本地搭建</h3><ul><li>任意建一个名为“hexo”文件夹，并在该文件夹下运行git bash（右键菜单中选择运行git bash）；</li><li>git bash中执行如下命令，hexo会自动将搭建所需的所有初始材料放入hexo文件夹中；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><ul><li>在git bash中运行如下命令，即可将博客的静态页面生成在<code>\hexo\public</code>目录下；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate #(或简写为 hexo g)</span><br></pre></td></tr></table></figure><ul><li>generate完毕后即可运行如下指令，成功后即可在<code>localhost:4000</code>浏览博客； <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server #(或简写为 hexo s)</span><br></pre></td></tr></table></figure></li></ul><h3 id="部署到github">部署到github</h3><ul><li>修改hexo文件夹中的<code>_config.yml</code>文件：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git #用git来部署</span><br><span class="line"># 以下两个&quot;repo&quot;任选一种即可</span><br><span class="line">    repo: https://github.com/XXX/XXX.github.io.git</span><br><span class="line">    repo: git@github.com:XXX/XXX.github.io.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure><p>保存后即可将本地博客与<code>XXX.github.io</code>建立关联；</p><ul><li>本地浏览确认无误后运行如下命令即可将博客部署到<code>XXX.github.io</code>；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy #(或简写为 hexo d)</span><br></pre></td></tr></table></figure><ul><li>部署完毕后即可在<code>XXX.github.io</code>浏览页面。</li></ul><h3 id="可能出现的问题及解决办法">可能出现的问题及解决办法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在执行 hexo d 时，可能会出现提示：</span><br><span class="line">    ERROR Deployer not found: git</span><br><span class="line">此时，需要执行如下命令：</span><br><span class="line">    npm install hexo-deployer-git --save</span><br><span class="line">完成后再执行 hexo d 即可。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在执行 hexo s 时，可能会出现提示：</span><br><span class="line">    ERROR Plugin load failed: hexo-server</span><br><span class="line">此时需要执行如下命令：</span><br><span class="line">    npm install hexo-server</span><br></pre></td></tr></table></figure><h2 id="博客源码备份">博客源码备份</h2><h3 id="git配置">git配置</h3><p>初次使用git，需要进行如下配置：</p><h4 id="全局配置">全局配置</h4><p>在git bash中依次执行如下语句以完成全局配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name XXX</span><br><span class="line">git config --global user.email aa@bb.com</span><br></pre></td></tr></table></figure><h4 id="配置ssh-key">配置ssh-key</h4><ul><li>在git bash中执行以下语句：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot; #(在github注册的邮箱)</span><br></pre></td></tr></table></figure><ul><li>添加key到ssh： 将<code>C:/Users/xxxx/.ssh/github_rsa.pub</code>中的全文复制，添加到github。 （浏览器登录github，找到<code>settings -&gt; SSH and GPG keys -&gt; new SSH key</code>粘贴进去确认即可）</li></ul><p>至此，你的github账户已经和你的电脑建立了关联。 有关SSH的更详尽步骤可以参考<a href="http://www.jianshu.com/p/21234432c94e" target="_blank" rel="noopener">这里</a>，本文不再细化。</p><h3 id="git仓库更新">git仓库更新</h3><ul><li>在hexo目录下运行git bash；</li><li>运行如下命令即可将该文件夹初始化为git仓库；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><ul><li>运行如下命令，将本地仓库至连接远程仓库(blog)；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:XXX/blog</span><br></pre></td></tr></table></figure><ul><li>依次运行如下命令，即可将源码更新至github的blog仓库，至此备份已经完成。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;message here&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>每次写新文章之后，都可以按照相同方式将源码再次更新一遍。 更多git操作可以查阅相关文档（例如<a href="http://www.liaoxuefeng.com/" target="_blank" rel="noopener">这里</a>），本文不再赘述。</p><h2 id="后续操作">后续操作</h2><h3 id="主题的选择">主题的选择</h3><p>hexo默认的主题是landscape，<del>样子比较难看</del>，网络上有各种其他样式的主题：</p><ul><li><a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">litten：yilia</a>，一个简洁优雅的hexo主题.</li><li><a href="https://github.com/forsigner/fexon/hexo-theme-yilia" target="_blank" rel="noopener">forsigner：fexo</a>，一个极简主义风格的hexo主题.</li><li><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">iissnan：next</a>，An elegant theme for Hexo.</li><li><a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="noopener">MOxFIVE：yelee</a>，简而不减Hexo双栏博客主题.</li></ul><p>例如你想用的主题是yilia，那么需要先执行如下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure><p>然后将hexo目录中的<code>_config.yml</code>文件修改为<code>theme: yilia</code>，再重新部署一次即可使用yilia主题。</p><p>在使用各种主题时，可以按照自己的需要修改主题中的<code>_config.yml</code>文件。 <strong>修改主题的各项操作均可在该主题的说明文档中查阅，本文不再赘述。</strong></p><h3 id="撰写新文章">撰写新文章</h3><ul><li>运行如下命令，在<code>hexo\source\_posts</code>文件夹中就会出现一个名为<code>AAA.md</code>的文件；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;AAA&quot;</span><br></pre></td></tr></table></figure><ul><li>按照markdown语法编辑该文件并保存；</li><li>依次运行如下命令即可完成部署。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>关于markdown语法以及编辑器可自行查阅相关资料，本文不再赘述。</p><h3 id="将博客绑定在自己的域名上">将博客绑定在自己的域名上</h3><p><strong>方便起见，假定域名为<code>www.domain.com</code>。</strong> 绑定域名步骤如下：</p><ul><li>进入仓库<code>github.com/XXX/XXX.github.io</code>，进入settings页面，在custom domain一项中填写<code>www.domain.com</code>（也可以在<code>hexo</code>目录下直接新建一个名为CNAME的文件，内容为<code>www.domain.com</code>，然后更新博客源码即可）；</li><li>然后在域名的设置页面设置解析为<code>lzcwr.github.io</code>即可。 具体解析步骤可在自己购买域名后查看，本文不再赘述。</li></ul><h3 id="hexo的常用命令">hexo的常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot; # 新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; # 新建页面</span><br><span class="line">hexo generate # 生成静态页面至public目录</span><br><span class="line">hexo server # 开启预览端口</span><br><span class="line">hexo deploy # 将.deploy目录部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  # 查看Hexo的版本</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>以上谈到的步骤按照顺序大概是：</p><ul><li>安装所需要的软件：git bash，Node.js，hexo；</li><li>申请github账号并新建仓库储存源码和博客页面；</li><li>本地配置好git：全局配置（用户名和邮箱），和SSH-key配置；</li><li>本地搭建博客：<code>hexo init</code>，<code>hexo g</code>，<code>hexo s</code>预览；</li><li>将博客部署至github：修改<code>_config.yml</code>中的<code>deploy</code>部分，执行<code>hexo g</code>，<code>hexo d</code>；</li><li>可能会出现无法部署至git的问题：安装<code>git-deployer</code>；</li><li>撰写新文章：<code>hexo new &quot;postName&quot;</code>，<code>hexo g</code>，<code>hexo d</code>；</li><li>更新源码：git操作（<code>add</code>，<code>commit</code>，<code>push</code>）。</li></ul><p>## 可能遇到的其他问题</p><h3 id="hexo与mathjax的冲突">Hexo与Mathjax的冲突</h3><p>参见<a href="http://www.lizhechen.com/2017/03/08/Hexo%E4%B8%8EMathjax%E7%9A%84%E5%86%B2%E7%AA%81%E5%8F%8A%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89%E8%A7%A3%E5%86%B3/" target="_blank" rel="noopener">Lzcwr——Hexo与Mathjax的冲突及（部分）解决</a>。</p>]]></content>
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 计算机 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
