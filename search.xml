<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>数学分析拾遗[2]——积分中值定理</title>
      <link href="/2018/03/13/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E6%8B%BE%E9%81%97-2-%E2%80%94%E2%80%94%E7%A7%AF%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/"/>
      <content type="html"><![CDATA[<h2 id="积分第一中值定理">积分第一中值定理</h2><h3 id="定理内容">定理内容</h3><blockquote><p><strong>积分第一中值定理</strong> 设函数 <span class="math inline">\(f(x)\in C[a,b]\)</span>, <span class="math inline">\(g(x)\in R[a,b]\)</span> <font color="red"><strong>且在 <span class="math inline">\([a,b]\)</span> 不变号</strong></font>, 则 <span class="math inline">\(\exists\xi\in[a,b]\)</span>, s.t. <span class="math display">\[\int_a^b f(x)g(x){\rm d}x=f(\xi)\int_a^b g(x){\rm d}x.\]</span></p></blockquote><h3 id="几何意义的探讨">几何意义的探讨</h3><p><span class="math inline">\(g(x)\equiv 1\)</span> 且 <span class="math inline">\(f(x)\geqslant 0\)</span> 时, 其形式变为: <span class="math display">\[\int_a^b f(x){\rm d}x=f(\xi)(b-a).\]</span> 此时几何意义是很显然的: 由 <span class="math inline">\(x=a\)</span>, <span class="math inline">\(x=b\)</span>, <span class="math inline">\(y=f(x)\)</span> 所围成的曲边梯形的面积与由 <span class="math inline">\(x=a,\)</span>, <span class="math inline">\(x=b\)</span>, <span class="math inline">\(y=f(\xi)\)</span> 围成的矩形面积相等, 如图所示:</p><center><img src="http://olgwnj89q.bkt.clouddn.com/1st%20m-v%20theorem%20of%20int.png"></center><h2 id="积分第二中值定理">积分第二中值定理</h2><h3 id="定理内容-1">定理内容</h3><p>　 &gt; <strong>积分第二中值定理</strong> 设函数 <span class="math inline">\(g(x)\in R[a,b]\)</span>, 有以下三种情况: 　　 　　(1) 若函数 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> <font color="red"><strong>单调增</strong></font>, 且对于 <span class="math inline">\(\forall x\in[a,b]\)</span>, 有 <span class="math inline">\(f(x)\geqslant 0\)</span>, 则 <span class="math inline">\(\exists\xi_1\in[a,b]\)</span>, s.t. <span class="math display">\[\int_a^b f(x)g(x){\rm d}x=f(b)\int_{\xi_1}^b g(x){\rm d}x.\]</span> 　　(2) 若函数 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> <font color="red"><strong>单调减</strong></font>, 且对于 <span class="math inline">\(\forall x\in[a,b]\)</span>, 有 <span class="math inline">\(f(x)\geqslant 0\)</span>, 则 <span class="math inline">\(\exists\xi_2\in[a,b]\)</span>, s.t. <span class="math display">\[\int_a^b f(x)g(x){\rm d}x=f(a)\int_a^{\xi_2} g(x){\rm d}x.\]</span> 　　(3) 若函数 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> <font color="red"><strong>单调</strong></font>, 则 <span class="math inline">\(\exists\xi\in[a,b]\)</span>, s.t. <span class="math display">\[\int_a^b f(x)g(x){\rm d}x=f(a)\int_a^\xi g(x){\rm d}x+f(b)\int_\xi^b g(x){\rm d}x.\]</span></p><h2 id="参考文献">参考文献</h2><ol type="1"><li>伍胜建. 数学分析.第2册[M]. 北京大学出版社, 2010.</li><li>裴礼文. 数学分析中的典型问题与方法-第2版[M]. 高等教育出版社, 2006.</li></ol>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数学分析拾遗[1]——一些不等式</title>
      <link href="/2018/03/13/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E6%8B%BE%E9%81%97-1-%E2%80%94%E2%80%94%E4%B8%80%E4%BA%9B%E4%B8%8D%E7%AD%89%E5%BC%8F/"/>
      <content type="html"><![CDATA[<h2 id="均值不等式">均值不等式</h2><center><font color="red"><strong>平方 <span class="math inline">\(\geqslant\)</span> 算数 <span class="math inline">\(\geqslant\)</span> 几何 <span class="math inline">\(\geqslant\)</span> 调和</strong><font></font></font></center><h3 id="定理内容">定理内容</h3><blockquote><p><strong>均值不等式</strong> <span class="math inline">\(\forall a_1,\cdots,a_n\geqslant 0\)</span>, 有 <span class="math display">\[\frac{n}{\sum\nolimits_{i=1}^n\frac{1}{a_i}}\leqslant \sqrt[n]{\prod\nolimits_{i=1}^n a_i}\leqslant \frac{\sum\nolimits_{i=1}^n a_i}{n}\leqslant \sqrt{\frac{\sum\nolimits_{i=1}^n a_i^2}{n}}.\]</span>取等号当且仅当 <span class="math inline">\(a_1=\cdots=a_n\)</span>.</p></blockquote><h3 id="简略证明">简略证明</h3><p>只证算术 <span class="math inline">\(\leqslant\)</span> 几何部分: 1. 先证对于 <span class="math inline">\(n=2^k\)</span> 成立: 由二元均值不等式可得<span class="math display">\[\begin{align}\sqrt[2^k]{a_1\cdots a_{2^k}} &amp;\leqslant \sqrt[2^{k-1}]{\frac{a_1+a_2}{2}+\frac{a_3+a_4}{2}+\cdots+\frac{a_{2^k-1}+a_{2^k}}{2}} \\&amp;\leqslant \cdots\leqslant \frac{a_1+\cdots+a_{2^k}}{2^k}.\end{align}\]</span> 2. <strong>反向归纳</strong>: 记 <span class="math inline">\(A=\frac{a_1+\cdots+a_n}{n}\)</span>, 则 <span class="math inline">\(nA=\sum a_i\)</span>. 设 <span class="math inline">\(n+1\)</span> 时不等式成立, 下证 <span class="math inline">\(n\)</span> 时成立: <span class="math display">\[\begin{align}A=\frac{nA+A}{n+1} &amp;= \frac{a_1+\cdots+a_n+A}{n+1} \\&amp;\geqslant  \sqrt[n+1]{a_1\cdots a_n A}.\end{align}\]</span> 于是 <span class="math inline">\(A^{n+1}\geqslant a_1\cdots a_nA\)</span>, 即 <span class="math display">\[A\geqslant \sqrt[n]{a_1\cdots a_n}.\]</span></p><h2 id="hölder不等式">Hölder不等式</h2><h3 id="定理内容-1">定理内容</h3><p><font color="red"><span class="math display">\[a\cdot b\leqslant \Vert a\Vert_p\cdot\Vert b\Vert_q,~\frac{1}{p}+\frac{1}{q}=1\]</span><font></font></font></p><blockquote><p><strong>Hölder不等式</strong> 设 <span class="math inline">\(a_i,b_i\geqslant 0\)</span>, <span class="math inline">\(\frac{1}{p}+\frac{1}{q}=1\)</span>, 则 (1) 当 <span class="math inline">\(p&gt;1\)</span> 时, <span class="math display">\[\sum\limits_{i=1}^n a_ib_i\leqslant (\sum\limits_{i=1}^n a_i^p)^{1/p}(\sum\limits_{i=1}^n a_i^q)^{1/q}.\]</span> (2) 当 <span class="math inline">\(p&lt;1\)</span> 时, <span class="math display">\[\sum\limits_{i=1}^n a_ib_i\geqslant (\sum\limits_{i=1}^n a_i^p)^{1/p}(\sum\limits_{i=1}^n a_i^q)^{1/q}.\]</span> 等号当且仅当 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(b_i\)</span> 成比例时取得.</p></blockquote><h3 id="简略证明-1">简略证明</h3><p>只证 (1): 当 <span class="math inline">\(p&gt;1\)</span> 时, 易有 <span class="math inline">\(q&lt;1\)</span>. 此时有 <span class="math display">\[\begin{align}\frac{a\cdot b}{\Vert a\Vert_p\cdot\Vert b\Vert_q} &amp;= \sum \left(\frac{a_i^p}{\sum a_i^p}\right)^{1/p}\left(\frac{b_i^q}{\sum b_i^q}\right)^{1/q} \\&amp;\leqslant \sum \left[\frac{1}{p}\left(\frac{a_i^p}{\sum a_i^p}\right)+\frac{1}{q}\left(\frac{b_i^q}{\sum b_i^q}\right)\right] \\&amp;= \frac{1}{p}\sum\frac{a_i^p}{\sum a_i^p}+\frac{1}{q}\sum\frac{b_i^q}{\sum b_i^q} \\&amp;= \frac{1}{p}+\frac{1}{q} =1.\end{align}\]</span></p><h2 id="minkowski不等式">Minkowski不等式</h2><h3 id="定理内容-2">定理内容</h3><p><font color="red"><span class="math display">\[\Vert a+b\Vert_p\leqslant \Vert a\Vert_p\cdot\Vert b\Vert_p\]</span><font></font></font></p><blockquote><p><strong>Minkowski不等式</strong> 对于 <span class="math inline">\(\forall r\neq 0,1\in\mathbb{R}\)</span>, 以及 <span class="math inline">\(a_i,b_i\geqslant 0\)</span>, 有 (1) 当 <span class="math inline">\(r&gt;1\)</span> 时, <span class="math display">\[(\sum\limits_{i=1}^n(a_i+b_i)^r)^{1/r}\leqslant (\sum\limits_{i=1}^n a_i^r)^{1/r}+(\sum\limits_{i=1}^n b_i^r)^{1/r}\]</span> (2) 当 <span class="math inline">\(r&lt;1\)</span> 时, <span class="math display">\[(\sum\limits_{i=1}^n(a_i+b_i)^r)^{1/r}\geqslant (\sum\limits_{i=1}^n a_i^r)^{1/r}+(\sum\limits_{i=1}^n b_i^r)^{1/r}\]</span></p></blockquote><h3 id="简略证明-2">简略证明</h3><p>只证 (1): 当 <span class="math inline">\(r&gt;1\)</span> 时, 令 <span class="math inline">\(s_i=a_i+b_i\)</span>, 则有 <span class="math display">\[\begin{align}\sum s_i^r &amp;= \sum (a_i+b_i)^r \\&amp;= \sum (a_i+b_i)(a_i+b_i)^{r-1} \\&amp;= \sum a_is_i^{r-1}+\sum b_is_i^{r-1}.\end{align}\]</span> 令 <span class="math inline">\(p=r\)</span>, <span class="math inline">\(q=\frac{r}{r-1}\)</span>, 则 <span class="math inline">\(\frac{1}{p}+\frac{1}{q}=1\)</span>, 由Hölder不等式可得: <span class="math display">\[\begin{align}\sum s_i^r &amp;\leqslant (\sum a_i^r)^{\frac{1}{r}}(\sum s_i^r)^{\frac{r-1}{r}}+(\sum b_i^r)^{\frac{1}{r}}(\sum s_i^r)^{\frac{r-1}{r}} \\&amp;= [(\sum a_i^r)^{\frac{1}{r}}+(\sum b_i^r)^{\frac{1}{r}}]\cdot (\sum s_i^r)^{1-\frac{1}{r}}.\end{align}\]</span> 两边同乘 <span class="math inline">\((\sum s_i^r)^{1-\frac{1}{r}}\)</span> 即可得到Minkowski不等式.</p><h2 id="young不等式">Young不等式</h2><h3 id="定理内容-3">定理内容</h3><blockquote><p><strong>Young不等式</strong> 设 <span class="math inline">\(f(x)\in[0,+\infty)\)</span> 单调增, <span class="math inline">\(f(0)=0\)</span>, <span class="math inline">\(a,b&gt;0\)</span>, 则 <span class="math display">\[ab\leqslant \int_0^a f(x){\rm d}x+\int_0^b f^{-1}(x){\rm d}x.\]</span> 等号当且仅当 <span class="math inline">\(f(a)=b\)</span> 时成立.</p></blockquote><h3 id="简略证明-3">简略证明</h3><p>从几何上看十分直观.</p><h2 id="参考文献">参考文献</h2><ol type="1"><li>裴礼文. 数学分析中的典型问题与方法-第2版[M]. 高等教育出版社, 2006.</li><li>伍胜建. 数学分析.第2册[M]. 北京大学出版社, 2010.</li></ol>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>范畴论学习笔记</title>
      <link href="/2018/03/02/%E8%8C%83%E7%95%B4%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <content type="html"><![CDATA[<h2 id="何为范畴">何为范畴</h2><h3 id="范畴-category">范畴: category</h3><h4 id="范畴的定义">范畴的定义</h4><p>一个范畴 <span class="math inline">\(\mathscr{C}\)</span> 包含一些对象和一些箭头:</p><ol type="1"><li><strong>对象</strong>(Objects): 记作 <span class="math inline">\(A,B,C,\cdots\)</span>;</li><li><strong>箭头</strong>(Morphism): 记作 <span class="math inline">\(f,g,h,\cdots\)</span>.</li></ol><p>这些对象和箭头需要满足以下几个条件:</p><ul><li><strong>箭头有唯一的源和目标</strong>: <span class="math inline">\(\forall f\in\mathscr{C}\)</span>, <span class="math inline">\(\exists\)</span> 唯一 <span class="math inline">\({\rm src}f,{\rm tar} f\in\mathscr{C}\)</span>. 若 <span class="math inline">\({\rm scr}f = A\)</span>, <span class="math inline">\({\rm tar}f = B\)</span>, 则可以记为 <span class="math inline">\(f:A\to B\)</span>.</li><li><strong>箭头可以复合</strong>: <span class="math inline">\(\forall f,g\in\mathscr{C}\)</span>, 设 <span class="math inline">\(f:A\to B\)</span>, <span class="math inline">\(g:B\to C\)</span>, <span class="math inline">\(\exists h=g\circ f:A\to C\)</span>. 称为 “<span class="math inline">\(g\)</span> following <span class="math inline">\(f\)</span>”, 即二者的复合.</li><li><strong>每个对象必须有单位箭头</strong>: <span class="math inline">\(\forall A\in\mathscr{C}\)</span>, <span class="math inline">\(\exists {\rm id}_A:A\to A\in\mathscr{C}\)</span>.</li></ul><p>箭头还满足以下两条性质:</p><ol type="1"><li><strong><span class="math inline">\(\circ\)</span> 的结合律</strong>: <span class="math inline">\(\forall f:A\to B,~g:B\to C,~h:C\to D\)</span>, 有 <span class="math display">\[h\circ(g\circ f)=(h\circ g)\circ f.\]</span></li><li><strong><span class="math inline">\({\rm id}_A\)</span> 是 <span class="math inline">\(\circ\)</span> 运算的单位元</strong>: <span class="math inline">\(\forall f:A\to B\)</span>, 有 <span class="math display">\[f\circ {\rm id}_A=f={\rm id}_B\circ f.\]</span></li></ol><h4 id="范畴的例子">范畴的例子</h4><ul><li><strong>幺半群 Monoid</strong></li></ul><p>幺半群 <span class="math inline">\((M,\cdot)\)</span> 指不满足“所有元素可逆”的群:</p><ol type="1"><li><strong>存在单位元</strong>: <span class="math inline">\(\exists e\)</span>, s.t. <span class="math inline">\(\forall a\in M\)</span>, <span class="math inline">\(a\cdot e=a=e\cdot a\)</span>;</li><li><strong>乘法结合律</strong>: <span class="math inline">\(\forall a,b,c\in M\)</span>, <span class="math inline">\((a\cdot b)\cdot c=a\cdot (b\cdot c)\)</span>.</li></ol><p>在幺半群 <span class="math inline">\(M\)</span> 的基础上, 可定义范畴 <span class="math inline">\(\mathscr{M}\)</span> 如下:</p><ol type="1"><li><strong><span class="math inline">\(\mathscr{M}\)</span>-对象</strong>: 任取一个集合 <span class="math inline">\(S\)</span> 作为 <span class="math inline">\(\mathscr{M}\)</span> 的对象;</li><li><strong><span class="math inline">\(\mathscr{M}\)</span>-箭头</strong>: 用 <span class="math inline">\(M\)</span> 中的元素表示 <span class="math inline">\(\mathscr{M}\)</span> 上的箭头:<ol type="1"><li>箭头的复合定义为元素的乘积: <span class="math display">\[(a\circ b)_\mathscr{M}=(a\cdot b)_M;\]</span></li><li>单位箭头定义为 <span class="math inline">\(M\)</span> 的单位元: <span class="math display">\[{\rm id}_\mathscr{M}=e_M.\]</span></li></ol></li></ol><ul><li><strong>幺半范畴</strong></li></ul><p>考虑所有幺半群组成的集合, 可如下定义范畴 <span class="math inline">\(\mathscr{M}\)</span>:</p><ol type="1"><li><strong><span class="math inline">\(\mathscr{M}\)</span>-对象</strong>: 幺半群全体作为 <span class="math inline">\(\mathscr{M}\)</span> 的对象;</li><li><strong><span class="math inline">\(\mathscr{M}\)</span>-箭头</strong>: 所有的幺半群同态作为 <span class="math inline">\(\mathscr{M}\)</span> 的箭头.</li></ol><p>该范畴称为<strong>幺半范畴</strong>, 记作 <span class="math inline">\({\tt Mon}\)</span>.</p><ul><li><strong>偏序集</strong></li></ul><p>在一个集合 <span class="math inline">\(S\)</span> 上, 一个偏序 <span class="math inline">\(\leqslant\)</span> 的定义如下:</p><ol type="1"><li><strong>自反性</strong>: <span class="math inline">\(\forall x\in S\)</span>, <span class="math inline">\(x\leqslant x\)</span>;</li><li><strong>反对称性</strong>: <span class="math inline">\(x\leqslant y~\text{且}~y\leqslant x\iff x=y\)</span>;</li><li><strong>传递性</strong>: <span class="math inline">\(x\leqslant y,~y\leqslant z\Longrightarrow x\leqslant z\)</span>.</li></ol><p>集合 <span class="math inline">\(S\)</span> 定义了偏序后, 就称为一个<strong>偏序集</strong>. 在偏序集 <span class="math inline">\(S\)</span> 的基础上可以如下定义范畴 <span class="math inline">\(\mathscr{C}\)</span>:</p><ol type="1"><li><strong><span class="math inline">\(\mathscr{C}\)</span>-对象</strong>: <span class="math inline">\(S\)</span> 中的元素作为 <span class="math inline">\(\mathscr{C}\)</span> 的对象;</li><li><strong><span class="math inline">\(\mathscr{C}\)</span>-箭头</strong>: 若 <span class="math inline">\(A\leqslant B\in S\)</span>, 则存在唯一的箭头 <span class="math inline">\(f:A\to B\)</span>.</li></ol><p>容易验证这样定义的 <span class="math inline">\(\mathscr{C}\)</span> 是一个范畴.</p><ul><li><strong>偏序范畴</strong></li></ul><p>考虑所有偏序集组成的集合, 可如下定义范畴 <span class="math inline">\(\mathscr{C}\)</span>:</p><ol type="1"><li><strong><span class="math inline">\(\mathscr{C}\)</span>-对象</strong>: 偏序集全体作为 <span class="math inline">\(\mathscr{C}\)</span> 的对象;</li><li><strong><span class="math inline">\(\mathscr{C}\)</span>-箭头</strong>: 所有的保序映射作为 <span class="math inline">\(\mathscr{C}\)</span> 的箭头.</li></ol><p>如此定义的范畴, 称为<strong>偏序范畴</strong>, 记作 <span class="math inline">\({\tt Pos}\)</span>.</p><h4 id="几个特殊的范畴">几个特殊的范畴</h4><ul><li><strong>空范畴: empty category</strong></li></ul><p>没有对象也没有箭头的范畴, 称为<strong>空范畴</strong>.</p><ul><li><strong>一元范畴: <span class="math inline">\(1\)</span></strong></li></ul><p>只有一个单位对象和一个单位箭头的范畴, 记作 <span class="math inline">\(1\)</span>.</p><ul><li><strong>二元范畴: von Neumann ordinal <span class="math inline">\(2\)</span></strong></li></ul><p>集合 $ &amp;#123; , &amp;#123; &amp;#125; &amp;#125; $ 上赋予单位箭头以及 $&amp;#123; &amp;#125; $ 箭头的范畴.</p><ul><li>集合范畴</li></ul><p>考虑如下范畴 <span class="math inline">\({\tt Set}\)</span>: 1. 对象: 所有集合<strong>(注意所有集合全体不是一个集合)</strong>; 2. 箭头: 集合间的映射(原文为set-function) <span class="math inline">\(f:X\to Y\)</span>. (1) 单位箭头是恒等映射, 显然存在且唯一; (2) 箭头的复合也是很自然的.</p><p>该范畴被称为集合范畴.</p><ul><li>逻辑范畴</li></ul><p>在形式语言 <span class="math inline">\(T\)</span> 中考虑如下范畴 <span class="math inline">\({\tt Proof}_T\)</span>: 1. 对象: 所有 <span class="math inline">\(T\)</span> 中的语句; 2. 箭头: <span class="math inline">\(\forall\varphi,\psi\in T\)</span>, 存在箭头 <span class="math inline">\(\varphi\to\psi\iff\varphi\vdash\psi\)</span>. (1) 单位箭头是恒等映射, 显然存在且唯一; (2) 箭头的复合根据 <span class="math inline">\(\vdash\)</span> 的定义显然.</p><p>该范畴称为 <span class="math inline">\(T\)</span> 上的逻辑范畴.</p><h4 id="一些常见范畴的定义和记号">一些常见范畴的定义和记号</h4><p>如下表所示, 整理自<a href="http://www.logicmatters.net/resources/pdfs/GentleIntro.pdf" target="_blank" rel="noopener">Category Theory: A Gentle Introductio</a>.</p><table><thead><tr class="header"><th style="text-align: center;">范畴</th><th style="text-align: center;">记号</th><th style="text-align: center;">对象</th><th style="text-align: center;">箭头</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">群范畴</td><td style="text-align: center;"><span class="math inline">\({\tt Grp}\)</span></td><td style="text-align: center;">所有的群</td><td style="text-align: center;">群同态</td></tr><tr class="even"><td style="text-align: center;">交换群范畴</td><td style="text-align: center;"><span class="math inline">\({\tt Ab}\)</span></td><td style="text-align: center;">所有的交换群</td><td style="text-align: center;">群同态</td></tr><tr class="odd"><td style="text-align: center;">环范畴</td><td style="text-align: center;"><span class="math inline">\({\tt Rng}\)</span></td><td style="text-align: center;">所有的环</td><td style="text-align: center;">环同态</td></tr><tr class="even"><td style="text-align: center;">布尔范畴</td><td style="text-align: center;"><span class="math inline">\({\tt Bool}\)</span></td><td style="text-align: center;">所有的布尔代数</td><td style="text-align: center;">结构保存映射</td></tr><tr class="odd"><td style="text-align: center;">偏序/全序范畴</td><td style="text-align: center;"><span class="math inline">\({\tt Pos/Tot}\)</span></td><td style="text-align: center;">所有的偏序/全序集</td><td style="text-align: center;">保序映射</td></tr><tr class="even"><td style="text-align: center;">拓扑/度量空间范畴</td><td style="text-align: center;"><span class="math inline">\({\tt Top/Met}\)</span></td><td style="text-align: center;">所有的拓扑/度量空间</td><td style="text-align: center;">连续映射</td></tr><tr class="odd"><td style="text-align: center;">场 <span class="math inline">\(K\)</span> 上的向量空间范畴</td><td style="text-align: center;"><span class="math inline">\({\tt Vect}_K\)</span></td><td style="text-align: center;">所有的向量空间</td><td style="text-align: center;">线性映射</td></tr><tr class="even"><td style="text-align: center;">集合/有限集范畴</td><td style="text-align: center;"><span class="math inline">\({\tt Set/FinSet}\)</span></td><td style="text-align: center;">所有的集合/有限集</td><td style="text-align: center;">集合映射 <span class="math inline">\(f:X\to Y\)</span></td></tr><tr class="odd"><td style="text-align: center;">逻辑范畴</td><td style="text-align: center;"><span class="math inline">\({\tt Proof}_T\)</span></td><td style="text-align: center;"><span class="math inline">\(T\)</span> 中的所有语句</td><td style="text-align: center;">按照逻辑推出关系 <span class="math inline">\(\vdash\)</span> 定义箭头</td></tr></tbody></table><h2 id="范畴生范畴">范畴生范畴</h2><p>从已有的一个范畴可以构建出新的范畴, 有以下的一些方法</p><h3 id="逆范畴-opposite-category">逆范畴: opposite category</h3><p>一个范畴 <span class="math inline">\(\mathscr{C}\)</span> 的逆范畴 <span class="math inline">\(\mathscr{C}^{op}\)</span> 定义如下: 1. <span class="math inline">\(\mathscr{C}^{op}\)</span>-对象: <span class="math inline">\(\mathscr{C}\)</span> 的对象; 2. <span class="math inline">\(\mathscr{C}^{op}\)</span>-箭头: <span class="math inline">\(f:B\to A~\text{in}~\mathscr{C}^{op}\iff f:A\to B~\text{in}~\mathscr{C}\)</span> (1) 单位箭头: <span class="math inline">\({\rm id}_A^{op}={\rm id}_A\)</span>, <span class="math inline">\(\forall A\)</span>; (2) 复合箭头: <span class="math inline">\(f\circ^{op}g=g\circ f\)</span>.</p><p>根据定义可知:</p><ol type="1"><li>每个范畴 <span class="math inline">\(\mathscr{C}\)</span> 都存在一个对偶 <span class="math inline">\(\mathscr{C}^{op}\)</span>;</li><li>对偶的对偶就是自身: <span class="math inline">\((\mathscr{C}^{op})^{op}=\mathscr{C}\)</span>.</li></ol><h3 id="子范畴-subcategory">子范畴: subcategory</h3><p>对于一个范畴 <span class="math inline">\(\mathscr{C}\)</span>, 若 <span class="math inline">\(\exists\)</span> 范畴 <span class="math inline">\(\mathscr{S}\)</span>, s.t.</p><ol type="1"><li><span class="math inline">\(\mathscr{S}\)</span> 的对象全部都是 <span class="math inline">\(\mathscr{C}\)</span> 的(全部或部分)对象;</li><li><span class="math inline">\(\mathscr{S}\)</span> 的箭头全部都是 <span class="math inline">\(\mathscr{C}\)</span> 的(全部或部分)箭头.</li></ol><p>且满足:</p><ol type="1"><li><span class="math inline">\(\mathscr{S}\)</span> 继承 <span class="math inline">\(\mathscr{C}\)</span> 中的单位箭头;</li><li><span class="math inline">\(\mathscr{S}\)</span> 继承 <span class="math inline">\(\mathscr{C}\)</span> 的结合律.</li></ol><p>则称 <span class="math inline">\(\mathscr{S}\)</span> 是 <span class="math inline">\(\mathscr{C}\)</span> 的一个<strong>子范畴</strong>.</p><p>由定义立即得到:</p><ul><li><span class="math inline">\({\tt FinSet}\)</span> 是 <span class="math inline">\({\tt Set}\)</span> 的子范畴;</li><li><span class="math inline">\({\tt Ab}\)</span> 是 <span class="math inline">\({\tt Grp}\)</span> 的子范畴.</li></ul><p>特别地, 若对于 <span class="math inline">\(\forall\mathscr{S}\)</span> 对象 <span class="math inline">\(A,B\)</span>, <span class="math inline">\(\mathscr{S}\)</span> 中包含了 <span class="math inline">\(\mathscr{C}\)</span> 中所有的 <span class="math inline">\(A\to B\)</span> 的箭头, 则称 <span class="math inline">\(\mathscr{S}\)</span> 是 <span class="math inline">\(\mathscr{C}\)</span> 的一个<strong>满子范畴</strong>.</p><h3 id="积范畴-product-category">积范畴: product category</h3><p>设 <span class="math inline">\(\mathscr{C}\)</span> 和 <span class="math inline">\(\mathscr{D}\)</span> 是范畴, 如下定义二者的积范畴 <span class="math inline">\(\mathscr{C}\times\mathscr{D}\)</span>:</p><ol type="1"><li><span class="math inline">\(\mathscr{C}\times\mathscr{D}\)</span>-对象: <span class="math inline">\((C,D)\)</span>, 其中 <span class="math inline">\(C,D\)</span> 分别是 <span class="math inline">\(\mathscr{C},\mathscr{D}\)</span> 的对象;</li><li><span class="math inline">\(\mathscr{C}\times\mathscr{D}\)</span>-箭头: <span class="math inline">\((f,g):(C_1,D_1)\to (C_2,D_2)\iff f:C_1\to C_2~\text{in}~\mathscr{C},g:D_1\to D_2~\text{in}~\mathscr{D}\)</span><ol type="1"><li>单位箭头: <span class="math inline">\({\rm id}_{(C,D)}=({\rm id}_C,{\rm id}_D)\)</span>;</li><li>复合箭头: <span class="math inline">\((f_1,g_1)\circ (f_2,g_2)=(f_1\circ_\mathscr{C} f_2,g_1\circ_\mathscr{D} g_2)\)</span>.</li></ol></li></ol><h3 id="商范畴-quotient-category">商范畴: quotient category</h3><p>设 <span class="math inline">\(\mathscr{C}\)</span> 是一个范畴, <span class="math inline">\(\sim\)</span> 是其上的一个同余关系, 则 <span class="math inline">\(\mathscr{C}/\sim\)</span> 是一个以 <span class="math inline">\(\mathscr{C}\)</span> 对象为对象, <span class="math inline">\(\sim\)</span> 等价类为箭头的一个范畴.</p><p>例如对于拓扑范畴 <span class="math inline">\({\tt Top}\)</span>, 考虑其上的同伦关系, 所得的商空间 <span class="math inline">\({\tt Top}/\sim\)</span> 称为同伦拓扑范畴, 记作 <span class="math inline">\({\tt hTop}\)</span>.</p><h3 id="箭头范畴-arrow-category">箭头范畴: arrow category</h3><p>设 <span class="math inline">\(\mathscr{C}\)</span> 是一个范畴, 其箭头范畴 <span class="math inline">\(\mathscr{C}^\to\)</span> 定义如下:</p><ol type="1"><li><span class="math inline">\(\mathscr{C}^\to\)</span>-对象: <span class="math inline">\(\mathscr{C}\)</span> 中的箭头;</li><li><span class="math inline">\(\mathscr{C}^\to\)</span>-箭头: 对于两个 <span class="math inline">\(\mathscr{C}^\to\)</span> 对象 <span class="math inline">\(f_1, f_2\)</span>, 一个 <span class="math inline">\(\mathscr{C}^\to\)</span> 箭头 <span class="math inline">\(f_1\to f_2\)</span> 是一个使得下图交换的一个二元组 <span class="math inline">\((j,k)\)</span>:<span class="math display">\[\begin{matrix}X_1~~ &amp; \xrightarrow{j} &amp; X_2~~ \\\downarrow \tiny{f_1} &amp; &amp; \downarrow \tiny{f_2} \\Y_1~~ &amp; \xrightarrow{k} &amp; Y_2~~ \\\end{matrix}\]</span><ol type="1"><li>单位箭头: <span class="math inline">\(f:X\to Y\)</span> 的单位箭头为 <span class="math inline">\(({\rm id}_X,{\rm id}_Y)\)</span>;</li><li>复合箭头: <span class="math inline">\((j_1,k_1):f_1 \to f_2\)</span> 和 <span class="math inline">\((j_2,k_2):f_2 \to f_3\)</span> 的复合为:<span class="math display">\[(j_2\circ j_1,~k_2\circ k_1):f_1\to f_3.\]</span></li></ol></li></ol><h3 id="切片范畴-slice-category">切片范畴: slice category</h3><p>设 <span class="math inline">\(\mathscr{C}\)</span> 是一个范畴, <span class="math inline">\(I\)</span> 是 <span class="math inline">\(\mathscr{C}\)</span> 的一个对象, 则 <span class="math inline">\(\mathscr{C}\)</span> 在 <span class="math inline">\(I\)</span> 的切片范畴 <span class="math inline">\(\mathscr{C}/I\)</span> 定义如下:</p><ol type="1"><li><span class="math inline">\(\mathscr{C}/I\)</span>-对象: 二元组 <span class="math inline">\((A,f)\)</span>, 其中 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(\mathscr{C}\)</span> 的对象, <span class="math inline">\(f:A\to I\)</span> 是 <span class="math inline">\(\mathscr{C}\)</span> 的箭头;</li><li><span class="math inline">\(\mathscr{C}/I\)</span>-箭头: 箭头 <span class="math inline">\((A,f)\to (B,g)\)</span> 是在 <span class="math inline">\(\mathscr{C}\)</span> 中满足 <span class="math inline">\(g\circ j=f\)</span> 的箭头 <span class="math inline">\(j:A\to B\)</span>.<ol type="1"><li>单位箭头: 对象 <span class="math inline">\((A,f)\)</span> 的单位箭头是 <span class="math inline">\(\mathscr{C}\)</span> 的单位箭头 <span class="math inline">\({\rm id}_A\)</span>;</li><li>复合箭头: 箭头 <span class="math inline">\(j:(A,f)\to(B,g)\)</span> 和 <span class="math inline">\(k:(B,g)\to(C,h)\)</span> 的复合为 <span class="math display">\[k\circ_{\mathscr{C}/I} j:(A,f)\to(C,h)=k\circ_\mathscr{C} j:A\to C.\]</span></li></ol></li></ol><h2 id="箭头的种类">箭头的种类</h2><p>用范畴的语言来定义单射和满射.</p><h3 id="单态-monomorphism">单态: monomorphism</h3><h4 id="定义">定义</h4><blockquote><p><strong>单态</strong>: 设 <span class="math inline">\(\mathscr{C}\)</span> 是一个范畴, 其中的一个箭头 <span class="math inline">\(f:B\to C\)</span> 是一个单态<strong>当且仅当</strong>它满足左消去律. 即对于 <span class="math inline">\(\forall\)</span> 映射 <span class="math inline">\(g:A\to B,~h:A\to B\)</span>, 有<span class="math display">\[f\circ g=f\circ h\iff g=h.\]</span></p></blockquote><h4 id="例子">例子</h4><ol type="1"><li><span class="math inline">\({\tt Set}\)</span> 中的箭头是单态当且仅当其对应的映射是单射;</li><li><span class="math inline">\({\tt Grp}\)</span> 中的箭头是单态当且仅当其对应的同态是单同态;</li><li>单位箭头 <span class="math inline">\({\rm id}_A\)</span> 是单态.</li></ol><h4 id="性质">性质</h4><ol type="1"><li>如果 <span class="math inline">\(f,g\)</span> 是单态, 则 <span class="math inline">\(f\circ g\)</span> 是单态;</li><li>如果 <span class="math inline">\(f\circ g\)</span> 是单态, 则 <span class="math inline">\(g\)</span> 是单态.</li></ol><h3 id="满态-epimorphism">满态: epimorphism</h3><h4 id="定义-1">定义</h4><blockquote><p><strong>满态</strong>: 设 <span class="math inline">\(\mathscr{C}\)</span> 是一个范畴, 其中的一个箭头 <span class="math inline">\(f:B\to C\)</span> 是一个满态<strong>当且仅当</strong>它满足右消去律. 即对于 <span class="math inline">\(\forall\)</span> 映射 <span class="math inline">\(g:C\to D,~h:C\to D\)</span>, 有<span class="math display">\[g\circ f=h\circ f\iff g=h.\]</span></p></blockquote><h4 id="例子-1">例子</h4><ol type="1"><li><span class="math inline">\({\tt Set}\)</span> 中的箭头是满态当且仅当其对应的映射是满射;</li><li><span class="math inline">\({\tt Grp}\)</span> 中的箭头是满态当且仅当其对应的同态是满同态;</li><li>单位箭头 <span class="math inline">\({\rm id}_A\)</span> 是满态.</li></ol><h4 id="性质-1">性质</h4><ol type="1"><li>如果 <span class="math inline">\(f,g\)</span> 是满态, 则 <span class="math inline">\(f\circ g\)</span> 是满态;</li><li>如果 <span class="math inline">\(f\circ g\)</span> 是满态, 则 <span class="math inline">\(f\)</span> 是满态.</li></ol>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 范畴论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018MCM乱搞</title>
      <link href="/2018/02/09/2018MCM%E4%B9%B1%E6%90%9E/"/>
      <content type="html"><![CDATA[<table><thead><tr class="header"><th style="text-align: center;">IDX</th><th style="text-align: center;">ABBR</th><th style="text-align: center;">FULL</th><th style="text-align: center;">TRANS</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">C1</td><td style="text-align: center;">SA</td><td style="text-align: center;">Security Apparatus</td><td style="text-align: center;">安全机构</td></tr><tr class="even"><td style="text-align: center;">C2</td><td style="text-align: center;">FE</td><td style="text-align: center;">Factionalized Elites</td><td style="text-align: center;">精英派系斗争</td></tr><tr class="odd"><td style="text-align: center;">C3</td><td style="text-align: center;">GG</td><td style="text-align: center;">Group Grievance</td><td style="text-align: center;">集团/ 种族矛盾</td></tr><tr class="even"><td style="text-align: center;">E1</td><td style="text-align: center;">ED</td><td style="text-align: center;">Economic Decline</td><td style="text-align: center;">经济下滑</td></tr><tr class="odd"><td style="text-align: center;">E2</td><td style="text-align: center;">EC</td><td style="text-align: center;">Uneven Economic Development</td><td style="text-align: center;">经济发展不均衡</td></tr><tr class="even"><td style="text-align: center;">E3</td><td style="text-align: center;">UD</td><td style="text-align: center;">Human Flight and Brain Drain</td><td style="text-align: center;">人力及智力的海外流失</td></tr><tr class="odd"><td style="text-align: center;">P1</td><td style="text-align: center;">SL</td><td style="text-align: center;">State Legitimacy</td><td style="text-align: center;">政府的正当性</td></tr><tr class="even"><td style="text-align: center;">P2</td><td style="text-align: center;">HF</td><td style="text-align: center;">Public Services</td><td style="text-align: center;">公共服务</td></tr><tr class="odd"><td style="text-align: center;">P3</td><td style="text-align: center;">SL</td><td style="text-align: center;">Human Rights and Rule of Law</td><td style="text-align: center;">人权法治</td></tr><tr class="even"><td style="text-align: center;">S1</td><td style="text-align: center;">DP</td><td style="text-align: center;">Demographic Pressures</td><td style="text-align: center;">人口压力</td></tr><tr class="odd"><td style="text-align: center;">S2</td><td style="text-align: center;">PS</td><td style="text-align: center;">Refugees and IDPs</td><td style="text-align: center;">国际难民及国内流浪者</td></tr><tr class="even"><td style="text-align: center;">X1</td><td style="text-align: center;">HR</td><td style="text-align: center;">External Intervention</td><td style="text-align: center;">外界干预</td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建模 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2017年拓扑学期末考试试卷</title>
      <link href="/2018/01/11/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62017%E5%B9%B4%E6%8B%93%E6%89%91%E5%AD%A6%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7/"/>
      <content type="html"><![CDATA[<h2 id="试题">试题</h2><ol type="1"><li><p>叙述 <span class="math inline">\(T_0\)</span>, <span class="math inline">\(T_1\)</span>, <span class="math inline">\(T_2\)</span> 的定义, 并分别举出 <span class="math inline">\(T_0\)</span> 但不 <span class="math inline">\(T_1\)</span>, 以及 <span class="math inline">\(T_1\)</span> 但不 <span class="math inline">\(T_2\)</span> 的空间的例子.</p></li><li><p>在 <span class="math inline">\(X\times X\)</span> 上定义映射 <span class="math inline">\(\Delta: X\rightarrow X\times X,~\Delta(x)=(x,x)\)</span>, 证明: <span class="math inline">\(X\)</span> 是Hausdorff空间当且仅当 <span class="math inline">\(\Delta(X)\)</span> 是 <span class="math inline">\(X\times X\)</span> 的闭集.</p></li><li><p>设 <span class="math inline">\(\mathcal{T}\)</span> 是 <span class="math inline">\(\mathbb{R}^1\)</span> 上的余有限拓扑, 讨论其紧性、连通性和道路连通性.</p></li><li>考虑拓扑群作用 <span class="math inline">\(\mathbb{S}^1\times B^2\to B^2,~(z,w)\mapsto zw\)</span>.<ol type="1"><li>求 <span class="math inline">\(B^2\)</span> 中一点 <span class="math inline">\(w\)</span> 的迷向群;</li><li>证明其轨道空间同构于单位闭区间 <span class="math inline">\(I\)</span>.</li></ol></li><li><p><span class="math inline">\(X\)</span> 是道路连通曲面, 证明: 连续映射 <span class="math inline">\(f: X\to T^2\)</span> 零伦当且仅当 <span class="math inline">\(f\)</span> 诱导的同态平凡.</p></li></ol><h2 id="简略解答">简略解答</h2><center><strong>有差错不负任何责任.</strong></center><ol type="1"><li>定义参见课本P19: Def 2.28. 例子参见课本 P19: Ex 1, Ex 2.<ol type="1"><li><span class="math inline">\(T_0\)</span> 但不 <span class="math inline">\(T_1\)</span>: <span class="math inline">\(X=\{0,1\}\)</span>, <span class="math inline">\(\mathcal{T}=\{\varnothing, \{0\}, X\}\)</span>;</li><li><span class="math inline">\(T_1\)</span> 但不 <span class="math inline">\(T_2\)</span>: <span class="math inline">\(\mathbb{R}^1\)</span> 上的余有限拓扑.</li></ol></li><li><p>题目参见课本 P35 习题3.2 第5题. 解答参见 <a href="http://www.lizhechen.com/2017/10/08/%E6%8B%93%E6%89%91%E5%AD%A6%E9%A2%98%E7%9B%AE/" target="_blank" rel="noopener">Zhechen: 拓扑学题目</a>.</p></li><li><p>紧致, 连通, 且道路连通. 证明略. 参见课本P47 习题3.4 第7题.</p></li><li>简略证明:<ol type="1"><li>迷向群平凡, 直接按照定义求即可;</li><li>考虑映射 <span class="math inline">\(f: B^2\to I,~re^{i\theta}\mapsto r\)</span>. 则 <span class="math inline">\(f\)</span> 是紧空间到Hausdorff空间的连续满射, 因而是商映射. 于是 <span class="math inline">\(f/\sim\cong I\)</span>. 只需要研究其轨道空间, 说明轨道空间就是 <span class="math inline">\(X/\sim\)</span> 即可.</li></ol></li><li><p>题目类似于课本 P125 习题6.2 的 1,2 题. 简略解答: 考虑复叠映射 <span class="math inline">\(P: \mathbb{E}^2\to T^2\)</span>. 若诱导的同态平凡, 则 <span class="math inline">\(\mathrm{Im}f_&amp;#42;\subset \mathrm{Im}p_&amp;#42;\)</span>, 因而 <span class="math inline">\(f\)</span> 有提升 <span class="math inline">\(\tilde{f}\)</span>. 又由于 <span class="math inline">\(\mathbb{E}^2\)</span> 是凸集, 故 <span class="math inline">\(\tilde{f}\)</span> 零伦, 故 <span class="math inline">\(f=p\circ\tilde{f}\)</span> 零伦. 反方向略.</p></li></ol>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 各种试卷 </tag>
            
            <tag> 拓扑学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2017年泛函分析期末考试试卷</title>
      <link href="/2018/01/11/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62017%E5%B9%B4%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7/"/>
      <content type="html"><![CDATA[<h2 id="试题">试题</h2><center><strong>7, 8, 9 题目不保证与原文完全一致.</strong></center><ol type="1"><li><p>设 <span class="math inline">\(\mathscr{X}\)</span> 是 <span class="math inline">\(B^&amp;#42;\)</span> 空间, <span class="math inline">\(\mathscr{X}_0\)</span> 是 <span class="math inline">\(\mathscr{X}\)</span> 的子空间, 假定 <span class="math inline">\(\exists c\in(0,1)\)</span>, s.t. <span class="math display">\[\inf\limits_{x\in\mathscr{X}_0}\Vert y-x\Vert\leqslant c\Vert y\Vert\quad (\forall y\in\mathscr{X}).\]</span> 求证: <span class="math inline">\(\mathscr{X}_0\)</span> 在 <span class="math inline">\(\mathscr{X}\)</span> 中稠.</p></li><li><p>设 <span class="math inline">\(M\)</span> 是Hilbert空间 <span class="math inline">\(\mathscr{H}\)</span> 的子集, 求证: <span class="math display">\[(M^\perp)^\perp=\overline{\mathrm{span}M}.\]</span></p></li><li><p>设 <span class="math inline">\(\mathscr{H}\)</span> 是Hilbert空间, <span class="math inline">\(A\in\mathscr{L}(\mathscr{H})\)</span>, 且 <span class="math inline">\(\exists m&gt;0\)</span>, s.t. <span class="math display">\[\vert (Ax,x) \vert\geqslant m\Vert x\Vert^2\quad (\forall x\in\mathscr{H}).\]</span> 求证: <span class="math inline">\(\exists A^{-1}\in\mathscr{L}(\mathscr{H})\)</span>.</p></li><li>设 <span class="math inline">\(\mathscr{X}\)</span> 是复线性空间, <span class="math inline">\(p\)</span> 是 <span class="math inline">\(\mathscr{X}\)</span> 上的半模. <span class="math inline">\(\forall x_0\in\mathscr{X}\)</span>, <span class="math inline">\(p(x_0)\neq 0\)</span>. 求证: 存在 <span class="math inline">\(\mathscr{X}\)</span> 上的线性泛函 <span class="math inline">\(f\)</span> s.t.<ol type="1"><li><span class="math inline">\(f(x_0)=1\)</span>;</li><li><span class="math inline">\(\vert f(x)\vert\leqslant p(x)/p(x_0)~(\forall x\in\mathscr{X})\)</span>.</li></ol></li><li><p>设 <span class="math inline">\(\mathscr{X}\)</span> 是 <span class="math inline">\(B^&amp;#42;\)</span> 空间, <span class="math inline">\(E\subset\mathscr{X}\)</span> 是非空均衡闭凸集, <span class="math inline">\(\forall x\in\mathscr{X}\backslash E\)</span>. 求证: <span class="math inline">\(\exists f\in\mathscr{X}^&amp;#42;\)</span> 及 <span class="math inline">\(\alpha&gt;0\)</span>, s.t. <span class="math display">\[\vert f(x)\vert&amp;#60;\alpha&amp;#60;\vert f(x_0)\vert\quad (\forall x\in E).\]</span></p></li><li><p>求证: <span class="math inline">\(B\)</span> 空间是自反的当且仅当其共轭空间是自反的.</p></li><li><p>(不保证与原题完全一致) 设 <span class="math inline">\(\mathscr{X},\mathscr{Y}\)</span> 是Banach空间, 设 <span class="math inline">\(\mathscr{L}(\mathscr{X},\mathscr{Y})\)</span> 是连续线性算子全体, 证明: 一一映射在其中构成一个开集.</p></li><li><p>设 <span class="math inline">\(\mathscr{H}\)</span> 是Hilbert空间, <span class="math inline">\(A,B\in\mathscr{L}(\mathscr{H})\)</span>, 若对 <span class="math inline">\(\forall x,y\in\mathscr{X}\)</span>, 有 <span class="math inline">\((Ax,y)=(x,By)\)</span>, 证明: <span class="math inline">\(A\)</span> 连续.</p></li><li><p>(不保证与原题完全一致) 设 <span class="math inline">\(\mathscr{X}\)</span> 是自反空间, <span class="math inline">\(E\)</span> 是其中的闭凸集, 证明: <span class="math display">\[\exists x_0\in E,~\text{s.t.}~\Vert x_0\Vert=\inf\limits_{x\in E}\Vert x\Vert.\]</span></p></li></ol><h2 id="部分简略解答">部分简略解答</h2><center><strong>7, 8, 9 解答不保证正确性.</strong></center><ol type="1"><li><p>用 F.Riesz 引理, 参见习题1.4.13;</p></li><li><p>参见习题1.6.5;</p></li><li><p>用 Banach 逆映射定理, 参见习题2.3.3;</p></li><li><p>用复 Hahn-Banach 定理, 参见习题2.4.3;</p></li><li><p>用 Ascoli 定理, 参见习题2.4.10;</p></li><li><p>利用自然映射和共轭算子, 参见习题2.5.5;</p></li><li><p>对于 <span class="math inline">\(T\in\mathscr{L}(\mathscr{X},\mathscr{Y})\)</span>, 取 <span class="math inline">\(\epsilon&lt; \inf\limits_{x\in B(0,1)}\Vert Tx\Vert\)</span> 即可.</p></li><li><p>由闭图像定理, 只需证明 <span class="math inline">\(A\)</span> 是闭算子且定义域闭. 考虑到定义域 <span class="math inline">\(\mathscr{H}\)</span> 显然闭, 只需要证明 <span class="math inline">\(A\)</span> 是闭算子. 取 <span class="math inline">\(x_n\to x\in \mathscr{H}\)</span>, 设 <span class="math inline">\(Ax_n\to z\)</span>, 则只需证 <span class="math inline">\(Ax=z\)</span>. (由闭算子的定义即可得, 参见课本P96: Def 2.3.9) <strong>一方面</strong>, 由内积的连续性, 即有 <span class="math inline">\((Ax_n,y)\to (z,y)\)</span>. 而<strong>另一方面</strong>又由条件有 <span class="math inline">\((Ax_n,y)=(x_n,By)\to (x,By)=(Ax,y)\)</span>. 于是由极限的唯一性即有 <span class="math inline">\(Ax=y\)</span>, 得证.</p></li><li><p>(瞎写的) 设 <span class="math inline">\(d=\inf\limits_{x\in E}\Vert x\Vert\)</span>, 由定义可取 <span class="math inline">\(x_n\in E\)</span>, s.t. <span class="math inline">\(d&lt;\Vert x_n\Vert&lt;d+\frac{1}{n}\)</span>. 由于自反空间中闭集是弱自列紧的, 取其收敛子列的弱极限即可.</p></li></ol>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 各种试卷 </tag>
            
            <tag> 泛函分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>拓扑学复习重点</title>
      <link href="/2018/01/08/%E6%8B%93%E6%89%91%E5%AD%A6%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/"/>
      <content type="html"><![CDATA[<h2 id="点集拓扑">点集拓扑</h2><h3 id="拓扑空间">拓扑空间</h3><h4 id="拓扑空间-1">拓扑空间</h4><ul><li>拓扑: 包含全集和空集, 对任意并和有限交封闭的集类;</li><li>开集: 拓扑中包含的集合为开集.</li></ul><h4 id="几个拓扑的例子">几个拓扑的例子</h4><ol type="1"><li><p><strong>平凡拓扑</strong>: $ &amp;#123; , X &amp;#125; $(最粗拓扑);</p></li><li><p><strong>离散拓扑</strong>: $ &amp;#123; U: UX &amp;#125; $(最细拓扑);</p></li><li><p><strong>欧式拓扑</strong>: $ &amp;#123; U: xUB(x,)U &amp;#125; $;</p></li><li><p><strong>余有限拓扑</strong>: $ &amp;#123; U: U=或 U^c 是有限集 &amp;#125; $(类似有余可数拓扑).</p></li></ol><h3 id="邻域与开集">邻域与开集</h3><h4 id="邻域">邻域</h4><p>对于包含 <span class="math inline">\(x\)</span> 的集合 <span class="math inline">\(N\)</span>, 若存在开集 <span class="math inline">\(O\)</span>, s.t. <span class="math inline">\(x\in O\subset N\)</span>, 则称 <span class="math inline">\(N\)</span> 是 <span class="math inline">\(x\)</span> 的邻域.</p><blockquote><p><strong>命题</strong> 设 <span class="math inline">\(X\)</span> 是拓扑空间, 则 <span class="math inline">\(W\)</span> 是 <span class="math inline">\(X\)</span> 的开集当且仅当 <span class="math inline">\(W\)</span> 是其中每点的邻域.</p></blockquote><h4 id="闭集">闭集</h4><p>开集的补集称为闭集, 由此可以立刻得到:</p><ul><li>闭集对任意交和有限并封闭;</li><li>全集和空集是闭集;</li></ul><h4 id="导集">导集</h4><ul><li><strong>聚点</strong>: 若 <span class="math inline">\(p\)</span> 的任意邻域都包含 $A- &amp;#123; p &amp;#125; $ 中的至少一点, 则称 <span class="math inline">\(p\)</span> 为 <span class="math inline">\(A\)</span> 的聚点;</li><li><strong>导集</strong>: <span class="math inline">\(A\)</span> 的聚点全体称为 <span class="math inline">\(A\)</span> 的导集, 记作 <span class="math inline">\(A&#39;\)</span>;</li><li><strong>闭包</strong>: <span class="math inline">\(\overline{A}=A\cup A&#39;\)</span>.</li></ul><p>一个例子: <span class="math display">\[A= \&amp;#123; (x,\sin(\frac{\pi}{x}))~\vert~0&amp;#60;x\leqslant 1 \&amp;#125; ,\quad B= \&amp;#123; (0,y)~\vert~-1\leqslant y\leqslant 1 \&amp;#125; \Rightarrow \]</span></p><p>关于闭集, 容易得到下列命题:</p><blockquote><p><strong>命题</strong> <span class="math inline">\(A\)</span> 闭 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(\overline{A}=A\)</span>.</p></blockquote><h4 id="拓扑基">拓扑基</h4><ul><li>拓扑基: 设 <span class="math inline">\(X\)</span> 是拓扑空间, <span class="math inline">\(\mathcal{B}\)</span> 是一组开集, s.t. <span class="math inline">\(X\)</span> 中的任意非空开集可以写成 <span class="math inline">\(\mathcal{B}\)</span> 中集合的并, 则称 <span class="math inline">\(\mathcal{B}\)</span> 为该拓扑的一组拓扑基;</li><li>拓扑基的定义等价于 <span class="math inline">\(\forall x\in X\)</span> 以及 <span class="math inline">\(x\)</span> 的开邻域 <span class="math inline">\(N\)</span>, <span class="math inline">\(\exists B\in\mathcal{B}\)</span>, s.t. <span class="math inline">\(x\in B\subset N\)</span>.</li></ul><p>关于拓扑基有如下定理:</p><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\mathcal{B}\)</span> 是集合 <span class="math inline">\(X\)</span> 的子集构成的子集类, s.t. 1. 设 <span class="math inline">\(U_1,U_2\in\mathcal{B}\)</span>, <span class="math inline">\(\forall x\in U_1\cap U_2\)</span>, <span class="math inline">\(\exists V\in \mathcal{B}\)</span>, s.t. <span class="math inline">\(x\in V\subset U_1\cap U_2;\)</span> 2. <span class="math inline">\(\mathcal{B}\)</span> 覆盖 <span class="math inline">\(X\)</span>. 则 <span class="math inline">\(\mathcal{B}\)</span> 是 <span class="math inline">\(X\)</span> 中某个拓扑的拓扑基.</p></blockquote><h4 id="子空间拓扑">子空间拓扑</h4><ul><li><strong>子空间拓扑</strong>: 子空间中的开集是全空间中开集与 <span class="math inline">\(A\)</span> 的交.</li><li>子空间中的闭集也是全空间中闭集与 <span class="math inline">\(A\)</span> 的交.</li><li>子空间中的开集也是全空间中的开集.</li></ul><h3 id="连续性">连续性</h3><h4 id="连续性-1">连续性</h4><ul><li><strong>连续性</strong>: 开集的原像是开集.</li></ul><h4 id="关于与连续性等价的几个命题">关于与连续性等价的几个命题</h4><ol type="1"><li>开集的原像是开集;</li><li>拓扑基中集合的原像是开集;</li><li>闭集的原像是闭集.</li></ol><h4 id="连续性的其他结论">连续性的其他结论</h4><ol type="1"><li>连续映射的复合映射连续;</li><li>连续映射在子空间的限制连续;</li></ol><h4 id="同胚">同胚</h4><ul><li><strong>同胚</strong>: 若连续映射 <span class="math inline">\(f: X\to Y\)</span> 是 <span class="math inline">\(1-1\)</span> 映射且 <span class="math inline">\(f^{-1}\)</span> 连续, 则称其为同胚.</li></ul><p>关于同胚有以下等价命题:</p><ol type="1"><li><span class="math inline">\(f\)</span> 是同胚;</li><li><span class="math inline">\(f\)</span> 是连续的一一映射并且是开映射;</li><li><span class="math inline">\(f\)</span> 是连续的一一映射并且是闭映射.</li></ol><h3 id="分离性">分离性</h3><h4 id="分离性-1">分离性</h4><ul><li><span class="math inline">\(T_0\)</span>: 任意一点与另一点分离;</li><li><span class="math inline">\(T_1\)</span>: 任意两点互相分离 <span class="math inline">\(\Leftrightarrow\)</span> 单点集是闭集;</li><li><span class="math inline">\(T_2\)</span>: 任意两点存在各自的开邻域不相交(Hausdorff);</li><li><span class="math inline">\(T_3\)</span>: 任意闭集与其外一点存在开邻域不相交;</li><li><span class="math inline">\(T_4\)</span>: 任意两个不相交闭集存在各自开邻域不相交.</li></ul><p>一些分离性的例子如下:</p><ol type="1"><li><p>$X= &amp;#123; 0,1 &amp;#125; $, $= &amp;#123; X,, &amp;#123; 0 &amp;#125; &amp;#125; $: 是 <span class="math inline">\(T_0\)</span> 但不是 <span class="math inline">\(T_1\)</span>;</p></li><li><p><span class="math inline">\(\mathbb{R}^1\)</span> 上的余有限拓扑是 <span class="math inline">\(T_1\)</span> 但不是 <span class="math inline">\(T_2\)</span>.</p></li></ol><p>对于Hausdorff空间还有如下命题:</p><blockquote><p><strong>命题</strong> Hausdorff空间 <span class="math inline">\(X\)</span> 是 <span class="math inline">\(T_3\)</span> 的当且仅当对于 <span class="math inline">\(\forall x\)</span> 以及 <span class="math inline">\(U_x\)</span>, <span class="math inline">\(\exists V_x\)</span>, s.t. <span class="math display">\[x\in V\subset\overline{V}\subset U.\]</span></p></blockquote><h4 id="tietze-扩张定理">Tietze 扩张定理</h4><blockquote><p><strong>Urysohn引理</strong> 设 <span class="math inline">\(X\)</span> 是Hausdorff空间, 则 <span class="math inline">\(X\)</span> 是 <span class="math inline">\(T_4\)</span> 的当且仅当对于 <span class="math inline">\(X\)</span> 内任意不相交的闭集 <span class="math inline">\(A,B\)</span>, 存在 <span class="math inline">\(X\)</span> 上的连续实函数 <span class="math inline">\(f\)</span>, s.t. <span class="math display">\[f\vert_A=1,~f\vert_B=-1,~-1 &amp;#60; f\vert_{X-(A\cup B)} &amp;#60; 1.\]</span></p></blockquote><p>进一步有 Tietze 扩张定理:</p><blockquote><p><strong>Tietze扩张定理</strong> 设 <span class="math inline">\(X\)</span> 是Hausdorff空间, 则 <span class="math inline">\(X\)</span> 是 <span class="math inline">\(T_4\)</span> 的当且仅当对于 <span class="math inline">\(X\)</span> 内任意闭子集 <span class="math inline">\(A\)</span> 及任意连续函数 <span class="math inline">\(f: A\to \mathbb{E}^1\)</span>, 存在连续函数 <span class="math inline">\(g: X\to \mathbb{E}^1\)</span>, s.t. <span class="math inline">\(g\vert_A=f\)</span>. 进一步, 若在 <span class="math inline">\(A\)</span> 上有 <span class="math inline">\(\vert f\vert\leqslant M\)</span>, 则可做到 <span class="math inline">\(\vert g\vert\leqslant M\)</span>.</p></blockquote><h3 id="紧致性">紧致性</h3><h4 id="紧致性-1">紧致性</h4><ul><li><strong>紧致性</strong>: 任意开覆盖含有限子覆盖.</li></ul><blockquote><p><strong>Heine-Borel定理</strong> <span class="math inline">\(\mathbb{E}^1\)</span> 上的闭区间是紧集.</p></blockquote><ul><li>紧致空间的闭子集是紧的.</li><li>Hausdorff空间中的紧集是闭集.</li><li>紧空间到Hausdorff空间的既单又满的连续映射是同胚.</li></ul><blockquote><p><strong>Bolzano-Weierstrass定理</strong> 紧空间的无穷点集必有聚点.</p></blockquote><h4 id="局部紧致">局部紧致</h4><ul><li>局部紧致: <span class="math inline">\(\forall x\in X\)</span>, 存在 <span class="math inline">\(x\)</span> 的紧致邻域.</li><li>紧致 <span class="math inline">\(\Rightarrow\)</span> 局部紧.</li></ul><h3 id="乘积空间">乘积空间</h3><h4 id="乘积拓扑">乘积拓扑</h4><ul><li>开集 <span class="math inline">\(\times\)</span> 开集 构成一组拓扑基 <span class="math inline">\(\mathcal{B}\)</span>;</li><li>乘积拓扑: <span class="math inline">\(\mathcal{B}\)</span> 决定的拓扑称为乘积拓扑.</li></ul><h4 id="自然投影">自然投影</h4><p>称映射 <span class="math display">\[p_1: X\times Y\to X,~(x,y)\to x;\]</span> <span class="math display">\[p_2: X\times Y\to X,~(x,y)\to y;\]</span> 为自然投影.</p><ul><li><span class="math inline">\(X\times Y\)</span> 的乘积拓扑是使得自然投影都连续的最粗拓扑;</li><li><span class="math inline">\(f:Z\to X\times Y\)</span> 连续 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(p_1\circ f\)</span> 和 <span class="math inline">\(p_2\circ f\)</span> 都连续;</li><li><span class="math inline">\(X\times Y\)</span> 是Hausdorff空间当且仅当 <span class="math inline">\(X\)</span>, <span class="math inline">\(Y\)</span> 都是Hausdorff空间;</li><li><span class="math inline">\(X\times Y\)</span> 紧致当且仅当<span class="math inline">\(X\)</span>, <span class="math inline">\(Y\)</span> 都紧致.</li></ul><h3 id="连通性">连通性</h3><h4 id="连通性-1">连通性</h4><p>以下命题等价:</p><ol type="1"><li><span class="math inline">\(X\)</span> 连通;</li><li><span class="math inline">\(X\)</span> 内既开又闭的子集只有 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(\varnothing\)</span>;</li><li><span class="math inline">\(X\)</span> 不能表示为两个不相交的非空开集的并;</li><li>不存在从 <span class="math inline">\(X\)</span> 到多于一点的离散拓扑空间的连续满射.</li></ol><blockquote><p><strong>命题</strong> <span class="math inline">\(\mathbb{E}^1\)</span> 的非空子集连通当且仅当它是一个区间.</p></blockquote><p>关于连通还有如下命题:</p><ul><li>连通空间的连续像连通;</li><li><span class="math inline">\(X\times Y\)</span> 连通当且仅当 <span class="math inline">\(X\)</span>, <span class="math inline">\(Y\)</span> 都连通;</li></ul><h4 id="连通分支">连通分支</h4><ul><li><strong>连通分支</strong>: 极大连通子集.</li></ul><p>有如下例子:</p><ul><li>离散拓扑空间的每一个点是一个连通分支;</li><li>有理数作为欧氏空间的子空间, 每个点是一个连通分支.</li></ul><blockquote><p><strong>中间值定理</strong> 设 <span class="math inline">\(f: X\to\mathbb{E}^1\)</span> 是一个连续函数, 若 <span class="math inline">\(f\)</span> 可以取到 <span class="math inline">\(a,b\)</span>, 则 <span class="math inline">\(f\)</span> 可以取到 <span class="math inline">\(a,b\)</span> 中间的任何值.</p></blockquote><h4 id="局部连通">局部连通</h4><ul><li>局部连通: 任意 <span class="math inline">\(x\)</span>, 任意 <span class="math inline">\(x\)</span> 的邻域 <span class="math inline">\(U\)</span>, 存在连通邻域 <span class="math inline">\(V\)</span>, s.t. <span class="math inline">\(x\in V\subset U\)</span>.</li><li>连通未必局部连通. (例子: <span class="math inline">\((x,\sin(\frac{\pi}{x}))\)</span>)</li></ul><h3 id="道路连通性">道路连通性</h3><h4 id="道路">道路</h4><ul><li><strong>道路</strong>: 连续映射 <span class="math inline">\(\alpha: I\to X\)</span>: 起点为 <span class="math inline">\(\alpha(0)\)</span>, 终点为 <span class="math inline">\(\alpha(1)\)</span>.</li><li><strong>逆道路</strong>: <span class="math inline">\(\overline{\alpha}(t)=\alpha(1-t)\)</span>.</li><li><strong>道路的乘积</strong>: 设 <span class="math inline">\(\alpha: x\to y\)</span>, <span class="math inline">\(\beta: y\to z\)</span>, 定义 <span class="math display">\[\gamma(t)=\begin{cases} \alpha(2t), &amp; 0\leqslant t\leqslant\frac{1}{2}, \\\\ s\beta(2t-1), &amp; \frac{1}{2}\leqslant t\leqslant 1, \end{cases}\]</span> 则 <span class="math inline">\(\gamma\)</span> 为 <span class="math inline">\(\alpha\)</span> 与 <span class="math inline">\(\beta\)</span> 的乘积道路.</li><li><strong>道路的连续像是道路</strong>: <span class="math inline">\(f: X\to Y\)</span> 连续, 则 <span class="math inline">\(f\circ \alpha\)</span> 是 <span class="math inline">\(Y\)</span> 中的道路.</li></ul><h4 id="道路连通">道路连通</h4><ul><li><strong>道路连通空间</strong>: 任意两点都有道路连接的空间;</li><li><strong>道路连通空间必定是连通的</strong> (反证法: 若不然, 则与 <span class="math inline">\(I\)</span> 的连通性矛盾);</li><li><strong>连通空间未必道路连通</strong>: <span class="math inline">\(\sin(x,\sin(\frac{\pi}{x}))\)</span> (证明 <span class="math inline">\((0,0)\)</span> 与 <span class="math inline">\((1,0)\)</span> 之间无道路);</li><li><strong>道路连通分支</strong>: 极大道路连通子集.</li></ul><h4 id="局部道路连通">局部道路连通</h4><ul><li>局部道路连通: 任意 <span class="math inline">\(x\)</span>, 任意 <span class="math inline">\(x\)</span> 的邻域 <span class="math inline">\(U\)</span>, 存在道路连通邻域 <span class="math inline">\(V\)</span>, s.t. <span class="math inline">\(x\in V\subset U\)</span>;</li><li>道路连通未必局部道路连通. (例子: <span class="math inline">\((\frac{1}{n},t)\cup (0,t)\cup (t,0)~t\in I\)</span>)</li><li>连通+局部道路连通 <span class="math inline">\(\Rightarrow\)</span> 道路连通.</li></ul><h3 id="商空间">商空间</h3><h4 id="商空间-1">商空间</h4><ul><li><strong>商空间</strong>: 设 <span class="math inline">\(X\)</span> 上有等价关系, 则可定义商空间 <span class="math inline">\(Y=X/\sim\)</span> (把一个等价类捏成一点);</li><li><strong>投影映射</strong>: <span class="math inline">\(\pi: X\to Y\)</span>, <span class="math inline">\(x\mapsto [x]\)</span>;</li><li><strong>商拓扑</strong>: 在商空间 <span class="math inline">\(Y\)</span> 定义拓扑: <span class="math display">\[U\subset Y 是开集 \Leftrightarrow \pi^{-1}(U) 是 X 中的开集\]</span> 则称该拓扑为 <span class="math inline">\(Y\)</span> 上的商拓扑;</li></ul><p>关于商空间, 一个重要的性质如下:</p><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(X\)</span> 是拓扑空间, <span class="math inline">\(Y\)</span> 是 <span class="math inline">\(X\)</span> 的商空间, <span class="math inline">\(Z\)</span> 是任意空间, 则: <span class="math display">\[f: Y\to Z ~连续~\Leftrightarrow~f\circ\pi: X\to Z~连续.\]</span></p></blockquote><h4 id="商空间的例子">商空间的例子</h4><p><span class="math inline">\(I^2\)</span> 上商空间的几个例子如下:</p><ol type="1"><li>平环 <span class="math inline">\(S^1\times I\)</span>: <span class="math inline">\((0,y)\sim(1,y)\)</span>;</li><li>Mobius带: <span class="math inline">\((0,y)\sim(1,1-y)\)</span>.</li><li>球面 <span class="math inline">\(\mathbb{S}^2\)</span>: <span class="math inline">\((0,y)\sim(1,y)\sim(x,0)\sim(x,1)~\forall x,y\)</span>.</li></ol><p>粘合两组对边可得环面 <span class="math inline">\(T^2\)</span> 和Klein瓶:</p><ol type="1"><li>环面 <span class="math inline">\(T^2\)</span>: <span class="math inline">\((x,0)\sim (x,1)\)</span>, <span class="math inline">\((0,y)\sim (1,y)\)</span>; (<span class="math inline">\(T^2\cong \mathbb{S}^1\times\mathbb{S}^1\)</span>)</li><li>Klein瓶: <span class="math inline">\((x,0)\sim (x,1)\)</span>, <span class="math inline">\((0,y)\sim (1,1-y)\)</span>.</li></ol><p>在 <span class="math inline">\(S^n\)</span> 上, 重要的商空间是实投影空间:</p><ol type="1"><li>实投影空间 <span class="math inline">\(\mathbb{P}^n\)</span>: <span class="math inline">\(x\sim -x\)</span>, <span class="math inline">\(\forall x\in\mathbb{S}^n\)</span>.</li></ol><h4 id="商映射">商映射</h4><p><strong>商映射</strong>: <span class="math inline">\(f\)</span> 是连续满射, 且 <span class="math inline">\(U\subset Y\)</span> 是开集 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(f^{-1}(U)\subset X\)</span> 是开集, 则称 <span class="math inline">\(f\)</span> 是商映射.</p><p>有如下命题:</p><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(f: X\to Y\)</span> 是商映射, 则 1. 映射 <span class="math inline">\(g: Y\to Z\)</span> 连续 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(g\circ f: X\to Z\)</span> 连续; 2. <span class="math inline">\(Y\cong X/\sim\)</span>.</p></blockquote><p>关于商映射的判断, 有如下两条常见的定理:</p><ol type="1"><li><strong>连续满射若同时是开映射或闭映射, 则是商映射</strong>;</li><li><strong>紧空间到Hausdorff空间的连续满射是商映射</strong>.</li></ol><h4 id="拓扑锥与双角锥">拓扑锥与双角锥</h4><ul><li>拓扑锥: <span class="math inline">\(X\times I\)</span> 上定义 <span class="math display">\[(x,1)\sim (x&#39;,1),~\forall x,x&#39;\in X;\]</span> <span class="math display">\[(x,t)\sim(x,t), ~\forall x,\forall t&amp;#60;1.\]</span> 而成的商空间称为 <span class="math inline">\(X\)</span> 的拓扑锥, 记作 <span class="math inline">\(CX\)</span>.</li></ul><p>容易知道 <span class="math inline">\(C\mathbb{S}^{n-1}\cong B^n\)</span>.</p><ul><li>双角锥: <span class="math inline">\(X\times[-1,1]\)</span> 上定义 <span class="math display">\[(x,1)\sim(x&#39;,1),~\forall x,x&#39;\]</span> <span class="math display">\[(x,-1)\sim(x&#39;,-1),~\forall x,x&#39;\]</span> <span class="math display">\[(x,t)\sim (x,t), \text{otherwise}.\]</span></li></ul><p>容易知道 <span class="math inline">\(S\mathbb{S}^{n-1}\cong \mathbb{S}^n\)</span>.</p><h3 id="拓扑群与轨道空间">拓扑群与轨道空间</h3><h4 id="拓扑群">拓扑群</h4><ul><li><strong>拓扑群</strong>: 设 <span class="math inline">\(G\)</span> 是一个Hausdorff空间, 同时也是一个群. 若 <span class="math inline">\(G\)</span> 的乘法和求逆都连续, 则称 <span class="math inline">\(G\)</span> 为拓扑群.</li><li><strong>子群</strong>: 子空间+子群.</li><li><strong>同态</strong>: 连续+同态. (同构=同胚+同构).</li></ul><p>拓扑群的例子:</p><ol type="1"><li>四元数空间 <span class="math inline">\(\mathbb{H}=\mathbb{C}^2\)</span>;</li><li>一般线性群 <span class="math inline">\(GL(n,\mathbb{R})\subset \mathbb{E}^{n^2}\)</span>.</li><li>正交群 <span class="math inline">\(O(n)\)</span>, <span class="math inline">\(SO(n)\)</span> 和 酉群 <span class="math inline">\(U(n)\)</span>, <span class="math inline">\(SU(n)\)</span>.</li></ol><h4 id="拓扑群作用">拓扑群作用</h4><ul><li>拓扑群作用: 连续映射 <span class="math inline">\(\phi: G\times X\to X\)</span>, s.t.</li></ul><ol type="1"><li><span class="math inline">\(\phi(hg,x)=\phi(h,\phi(g,x))\)</span>, <span class="math inline">\(\forall g,h,x\)</span>;</li><li><span class="math inline">\(\phi(e,x)=x\)</span>, <span class="math inline">\(\forall x\)</span></li></ol><p>可以简写为:</p><ol type="1"><li><span class="math inline">\((hg)x=h(gx)\)</span>;</li><li><span class="math inline">\(ex=x\)</span>.</li></ol><h4 id="轨道空间">轨道空间</h4><ul><li><strong>轨道</strong>: $O(x)= &amp;#123; gx<sub></sub>gG &amp;#125; $, 显然轨道相交等价于轨道重合;</li><li><strong>轨道空间</strong>: <span class="math inline">\(x\sim y: O(x)=O(y)\)</span>. 记作 <span class="math inline">\(X/G\)</span>.</li><li><strong>可迁作用</strong>: <span class="math inline">\(\forall x,y\in X\)</span>, <span class="math inline">\(\exists g\in G\)</span>, s.t. <span class="math inline">\(gx=y\)</span>;</li><li><strong>自由作用</strong>: <span class="math inline">\(\forall g\neq h\in G\)</span>, <span class="math inline">\(\forall x\in X\)</span>, <span class="math inline">\(gx\neq hx\)</span>.</li><li><strong>迷向群</strong>: <span class="math inline">\(G_x= \&amp;#123; g\in G~\vert~gx=x \&amp;#125; \subset G\)</span>.</li></ul><blockquote><p><span class="math inline">\(G\)</span> 是自由作用当且仅当每点的迷向群是平凡群.</p></blockquote><p>关于轨道空间的连通性有如下命题:</p><blockquote><p><strong>命题</strong> 设 <span class="math inline">\(G\)</span> 是拓扑群, 作用于 <span class="math inline">\(X\)</span> 上. 若 <span class="math inline">\(G\)</span> 与 <span class="math inline">\(G/X\)</span> 连通, 则 <span class="math inline">\(X\)</span> 连通. 反证法: 取开集 <span class="math inline">\(X=A\cup B\)</span>, 则 <span class="math inline">\(U=\pi(A)\cap\pi(B)\)</span> 非空, 取 <span class="math inline">\([p]\in U\)</span>, 考虑 <span class="math inline">\(O_p\)</span> 的连通性即可得结论.</p></blockquote><h2 id="代数拓扑">代数拓扑</h2><h3 id="映射与空间的同伦">映射与空间的同伦</h3><h4 id="映射的同伦">映射的同伦</h4><ul><li><strong>映射同伦</strong>: 设 <span class="math inline">\(X,Y\)</span> 是拓扑空间, <span class="math inline">\(f,g:X\to Y\)</span> 是连续映射, 则 <span class="math inline">\(f\)</span> 到 <span class="math inline">\(g\)</span> 的同伦是指连续映射 <span class="math display">\[F: X\times I\to Y,~\text{s.t.}~F(x,0)=f(x),~F(x,1)=g(x).\]</span> 此时称 <span class="math inline">\(f\)</span> 与 <span class="math inline">\(g\)</span> 同伦, 记作 <span class="math inline">\(f\underset{F}{\simeq} g\)</span>.</li><li><strong>相对子集的同伦</strong>: 若对于 <span class="math inline">\(A\subset X\)</span> 有 <span class="math display">\[F(a,t)=f(a),~\forall a\in A,t\in I,\]</span> 则称 <span class="math inline">\(f\)</span> 与 <span class="math inline">\(g\)</span> 相对于 <span class="math inline">\(A\)</span> 同伦, 记作 <span class="math inline">\(f\underset{F}{\simeq} g, rel A\)</span>.</li><li><strong>线性同伦</strong>: <span class="math inline">\(C\)</span> 是 <span class="math inline">\(\mathbb{E}^n\)</span> 中的凸集, 映射 <span class="math inline">\(f,g: X\to C\)</span> 连续, 取 <span class="math display">\[F(x,t)=(1-t)f(x)+tg(x),\]</span> 则 <span class="math inline">\(f\underset{F}{\simeq} g\)</span>.</li><li><strong>零伦</strong>: 同伦于常值映射的映射称为是零伦的. <strong><span class="math inline">\(X\)</span> 到 <span class="math inline">\(\mathbb{E}^n\)</span> 中凸集的连续映射是零伦的.</strong></li><li><strong>环路</strong>: <span class="math inline">\(\alpha: I\to X\)</span> 是一条道路, 且 <span class="math inline">\(\alpha(0)=\alpha(1)=p\)</span>, 则称 <span class="math inline">\(\alpha\)</span> 是以 <span class="math inline">\(p\)</span> 为基点的环路.</li><li><strong>保基点同伦</strong>: $,~rel &amp;#123; 0,1 &amp;#125; $.</li></ul><h4 id="空间的同伦等价">空间的同伦等价</h4><ul><li><strong>同伦等价</strong>: 存在连续映射 <span class="math display">\[f: X\to Y,\quad g:Y\to X,\]</span> s.t. <span class="math display">\[g\circ f\simeq id_X: X\to X,\quad f\circ g\simeq Y\to Y.\]</span> 则称 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 同伦等价, 记作 <span class="math inline">\(X\simeq Y\)</span>.</li></ul><p>几个例子如下:</p><ol type="1"><li><span class="math inline">\(\mathbb{E}^n- \&amp;#123; 0 \&amp;#125; \simeq\mathbb{S}^{n-1}\)</span>, <span class="math inline">\(f(x)=\frac{x}{\Vert x\Vert}\)</span>, <span class="math inline">\(g(x)=x\)</span>;</li><li>$CX&amp;#123; p(锥顶) &amp;#125; $, <span class="math inline">\(f(x)=p\)</span>, <span class="math inline">\(g(p)\)</span> 为包含映射.</li></ol><h4 id="收缩">收缩</h4><ul><li><strong>可缩空间</strong>: 与单点同伦等价的空间;</li><li><strong>收缩核</strong>: <span class="math inline">\(A\subset X\)</span>, 若存在连续映射 <span class="math inline">\(r: X\to A\)</span>, s.t. <span class="math inline">\(r\vert_A=id_A\)</span>, 则称 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(X\)</span> 的收缩核;</li><li><strong>形变收缩</strong>: <span class="math inline">\(A\subset X\)</span>, <span class="math inline">\(i: A\to X\)</span> 是包含映射, <span class="math inline">\(r\)</span> 是 <span class="math inline">\(X\)</span> 到 <span class="math inline">\(A\)</span> 的收缩. 若 <span class="math inline">\(id_X\underset{F}{\simeq} i\circ r\)</span>, 则称 <span class="math inline">\(F\)</span> 是 <span class="math inline">\(X\)</span> 到 <span class="math inline">\(A\)</span> 的形变收缩, <span class="math inline">\(A\)</span> 是 <span class="math inline">\(X\)</span> 的形变收缩核;</li><li><strong>强形变收缩</strong>: 若 <span class="math inline">\(id_X\underset{F}{\simeq} i\circ r,~rel A\)</span> 则称 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(X\)</span> 的强形变收缩核.</li></ul><blockquote><p><strong>命题</strong> <span class="math inline">\(X\)</span> 可缩 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(X\)</span> 可形变收缩到其中一点.</p></blockquote><p>几个例子: 1. <span class="math inline">\(\mathbb{S}^1\)</span> 是平环和Mobius带的强形变收缩核; 2. <span class="math inline">\(\mathbb{S}^{n-1}\)</span> 是 $^n- &amp;#123; 0 &amp;#125; $ 的强形变收缩核.</p><h3 id="基本群">基本群</h3><h4 id="基本群-1">基本群</h4><ul><li><strong>基本群</strong>: 拓扑空间上以 <span class="math inline">\(p\)</span> 点为基点的环路的保基点同伦类关于同伦类的乘积构成一个群, 称为基本群 <span class="math inline">\(\pi_1(X,p)\)</span>. &gt; <strong>道路连通空间的基本群</strong> 若 <span class="math inline">\(X\)</span> 道路连通, 则 <span class="math inline">\(\pi_1(X,p)\cong \pi_1(X,q)\)</span>, <span class="math inline">\(\forall p,q\)</span>.</li></ul><h4 id="基本群的不变性">基本群的不变性</h4><p>设 <span class="math inline">\(f: X\to Y\)</span> 连续, 且 <span class="math inline">\(f(p)=q\)</span>, 则 <span class="math inline">\(f\)</span> 可以诱导映射 <span class="math display">\[g: \pi_1(X,p)\to \pi_1(Y,q),~&amp;#60;\alpha &amp;#62; \mapsto &amp;#60;f\circ\alpha &amp;#62; .\]</span> 且由 <span class="math display">\[g\circ(\alpha\cdot\beta)=(f\circ\alpha)\cdot(f\circ\beta)\]</span> 可知 <span class="math inline">\(g\)</span> 是同态.</p><h4 id="乘积空间的基本群">乘积空间的基本群</h4><blockquote><p><strong>命题</strong> 若 <span class="math inline">\(X,Y\)</span> 道路连通, 则 <span class="math display">\[\pi_1(X\times Y,(x_0,y_0))\cong \pi_1(X,x_0)\times \pi_1(Y,y_0).\]</span></p></blockquote><h3 id="mathbbsn-的基本群"><span class="math inline">\(\mathbb{S}^n\)</span> 的基本群</h3><h4 id="道路提升定理">道路提升定理</h4><blockquote><p><strong>道路提升</strong> <span class="math inline">\(\alpha\)</span> 是 <span class="math inline">\(\mathbb{S}^1\)</span> 内以 <span class="math inline">\(1\)</span> 为起点的道路, 则存在 <span class="math inline">\(\mathbb{E}^1\)</span> 中唯一一条以 <span class="math inline">\(0\)</span> 为起点的道路<span class="math inline">\(\tilde{\alpha}\)</span>, s.t. <span class="math inline">\(\pi\circ\tilde{\alpha}=\alpha\)</span>.</p></blockquote><h4 id="同伦提升定理">同伦提升定理</h4><blockquote><p><strong>同伦提升</strong> <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(\beta\)</span> 是 <span class="math inline">\(\mathbb{S}^1\)</span> 中的两条道路, 且 <span class="math inline">\(\exists F:I\times I\to \mathbb{S}^1\)</span>, s.t. <span class="math inline">\(\alpha\underset{F}{\simeq}\beta\)</span>, 若 <span class="math inline">\(\alpha\)</span> 有提升, 则 <span class="math inline">\(F\)</span> 有唯一提升 <span class="math inline">\(\tilde{F}: I\times I\to\mathbb{E}^1\)</span>, s.t. <span class="math inline">\(\tilde{F}(0,0)=0\)</span>.</p></blockquote><h4 id="mathbbsn-的基本群-1"><span class="math inline">\(\mathbb{S}^n\)</span> 的基本群</h4><ol type="1"><li><span class="math inline">\(\mathbb{S}^1\)</span> 的基本群为 <span class="math inline">\(\mathbb{Z}\)</span>;</li><li><span class="math inline">\(\mathbb{S}^n~(n&gt;2)\)</span> 的基本群为平凡群.</li></ol><h4 id="基本群的应用">基本群的应用</h4><ol type="1"><li><strong>代数学基本定理</strong>: <span class="math inline">\(\mathbb{C}\)</span> 上的 <span class="math inline">\(n\)</span> 次多项式存在零点;</li><li><strong>Brouwer 不动点定理</strong>: <span class="math inline">\(\mathbb{B}^n\)</span> 具有不动点性质(任意到自身的连续映射有不动点).</li></ol><h4 id="van-kampen-定理">Van Kampen 定理</h4><blockquote><p><strong>van kampen</strong> 设 <span class="math inline">\(X\)</span> 可以写成非空开集 <span class="math inline">\(X_1\)</span>, <span class="math inline">\(X_2\)</span> 的并集且 <span class="math inline">\(X_0=X_1\cap X_2\neq\varnothing\)</span>. 设 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(X_0\)</span> 道路连通, 取 <span class="math inline">\(x_0\in X_0\)</span>, 则 <span class="math display">\[\pi_1(X,x_0)\cong\pi_1(X_1,x_0)*\pi_1(X_2,x_0)/\sim,\]</span> 其中 <span class="math inline">\(\sim\)</span> 是等价关系 <span class="math display">\[ \&amp;#123; i_{1 &amp;#42; }(\alpha)=i_{2 &amp;#42; }(\alpha)~\vert~\alpha\in\pi_1(X_0,x_0) \&amp;#125; ~(i_k~是~X_0\to X_k~的包含映射).\]</span></p></blockquote><p>两个特殊情形如下:</p><blockquote><p><strong>推论 1</strong> 若 <span class="math inline">\(X_0\)</span> 单连通, 则 <span class="math display">\[\pi_1(X,x_0)\cong\pi_1(X_1,x_0) &amp;#42; \pi_1(X_2,x_0).\]</span> <strong>推论 2</strong> 若 <span class="math inline">\(X_2\)</span> 单连通, 则 <span class="math display">\[\pi_1(X,x_0)\cong\pi_1(X_1,x_0)/\sim,\]</span> 其中 <span class="math inline">\(\sim\)</span> 为等价关系 $ &amp;#123; i_{1 * }()=e<sub></sub>_1(X_0,x_0) &amp;#125; $.</p></blockquote><h4 id="闭曲面分类定理">闭曲面分类定理</h4><ul><li><strong>曲面</strong>: 第二可数的Hausdorff空间 <span class="math inline">\(S\)</span> 称为曲面当且仅当 <span class="math inline">\(\forall x\in S\)</span>, 存在 <span class="math inline">\(x\)</span> 的邻域 <span class="math inline">\(U\)</span>, s.t. <span class="math inline">\(U\)</span> 同胚于圆盘 <span class="math inline">\(D^2\)</span> 或 半圆盘<span class="math inline">\(D^2_+\)</span>;</li><li><strong>内部</strong>: 存在邻域同胚于圆盘的点称为内点, 内点的全体称为内部;</li><li><strong>边界</strong>: 存在邻域同胚于半圆盘的点称为边界点, 边界点的全体称为边界.</li><li><strong>闭曲面</strong>: 紧致无边界的曲面称为闭曲面.</li></ul><p>关于曲面还有如下结论:</p><ol type="1"><li>曲面间的同胚把内点映射到内点, 边界点映射到边界点;</li><li>同胚的曲面具有同胚的边界. (由上一条可得到)</li></ol><p>如下定义曲面的可定向性:</p><ul><li><strong>不可定向曲面</strong>: 存在一个同胚于Mobius带的子空间. (否则称为可定向的)</li></ul><blockquote><p><strong>闭曲面分类定理</strong> <span class="math inline">\(\mathbb{S}^2\)</span>, <span class="math inline">\(nT^2~(n\in\mathbb{N})\)</span>, <span class="math inline">\(m\mathbb{P}^2~(m\in \mathbb{N})\)</span> 是两两不同胚的闭曲面, 且所有的闭曲面都可以归为这三类. 进一步, 1. 可定向曲面必定同胚于 <span class="math inline">\(\mathbb{S}^2\)</span> 或 <span class="math inline">\(nT^2~(n\in\mathbb{N})\)</span>; 2. 不可定向曲面必定同胚于 <span class="math inline">\(m\mathbb{P}^2~(m\in \mathbb{N})\)</span>.</p></blockquote><h3 id="复叠空间">复叠空间</h3><h4 id="复叠空间-1">复叠空间</h4><ul><li><strong>复叠映射</strong>: 设 <span class="math inline">\(E,B\)</span> 是道路连通且局部道路连通的空间, <span class="math inline">\(p: E\to B\)</span> 是连续映射. 若对 <span class="math inline">\(\forall b\in B\)</span>, 存在 <span class="math inline">\(b\)</span> 的开邻域 <span class="math inline">\(U\)</span>, s.t. <span class="math inline">\(p^{-1}(U)\)</span> 是 <span class="math inline">\(E\)</span> 中一族两两不交的开集 $ &amp;#123; V_&amp;#125; $ 的并集, 且 <span class="math inline">\(p\vert_{V_\alpha}: V_\alpha\to U\)</span> 是同胚, 则称 <span class="math inline">\(p\)</span> 是复叠映射.</li><li><strong>复叠空间</strong>: <span class="math inline">\((E,p)\)</span> 称为 <span class="math inline">\(B\)</span> 上的复叠空间.</li><li><strong>基本邻域</strong>: 上述定义中的 <span class="math inline">\(U\)</span> 称为基本邻域. <span class="math inline">\(U\)</span> 的逆像可以拆成若干与 <span class="math inline">\(U\)</span> 同胚的集合的不交并.</li><li><strong>纤维</strong>: <span class="math inline">\(b\in B\)</span>, 称 <span class="math inline">\(p^{-1}(b)\)</span> 为 <span class="math inline">\(b\)</span> 的纤维. 其基数称为复叠空间的重数/叶数.</li></ul><p>简单来说, 复叠映射就是把一族同胚的不交开集映射到同一开集的映射, 原空间就称为复叠空间. 如果该映射是 <span class="math inline">\(n\)</span> 对 <span class="math inline">\(1\)</span> 的, 则该空间是 <span class="math inline">\(n\)</span> 重的.</p><h4 id="复叠空间上的道路提升与同伦提升">复叠空间上的道路提升与同伦提升</h4><blockquote><p><strong>道路提升</strong> 若 <span class="math inline">\(\alpha\)</span> 是以 <span class="math inline">\(b_0\in B\)</span> 为起点的一条道路, <span class="math inline">\(e_0\in p^{-1}(b_0)\)</span>, 则存在 <span class="math inline">\(E\)</span> 内唯一一条以 <span class="math inline">\(e_0\)</span> 为起点的道路 <span class="math inline">\(\tilde{\alpha}\)</span>, s.t. <span class="math display">\[\alpha=p\circ\tilde{\alpha}.\]</span> <font color="red"> <strong>这说明 <span class="math inline">\(B\)</span> 中以 <span class="math inline">\(b_0\)</span> 为起点的道路与 <span class="math inline">\(E\)</span> 中以 <span class="math inline">\(e_0\)</span> 为起点的道路一一对应.</strong></font> <strong>同伦提升</strong> 若 <span class="math inline">\(\alpha_1,\alpha_2\)</span> 是 <span class="math inline">\(B\)</span> 内两条道路, 且 <span class="math display">\[\alpha_1\underset{F}{\simeq}\alpha_2.\]</span> 设 <span class="math inline">\(\tilde{\alpha}_1\)</span> 是 <span class="math inline">\(\alpha_1\)</span> 的提升, 且 <span class="math inline">\(\tilde{\alpha}_1(0)=e_0\in E\)</span>, 则 <span class="math inline">\(F\)</span> 有唯一提升 <span class="math display">\[\tilde{F}: I\times I\to E,~\text{s.t.}~\tilde{F}(0,0)=e_0.\]</span> <strong>推论</strong> 若 <span class="math inline">\(\alpha_1,\alpha_2\)</span> 是 <span class="math inline">\(B\)</span> 内两条道路, 且 <span class="math display">\[\alpha_1\simeq\alpha_2,~rel \&amp;#123; 0,1 \&amp;#125; .\]</span> 设 <span class="math inline">\(\tilde{\alpha}_i\)</span> 是 <span class="math inline">\(\alpha_i\)</span> 的提升, 且 <span class="math inline">\(\tilde{\alpha_1}(0)=\tilde{\alpha_2}(0)\)</span>, 则 <span class="math display">\[\alpha_1\simeq\alpha_2,~rel \&amp;#123; 0,1 \&amp;#125; .\]</span> <font color="red"><strong>这说明道路提升中产生的一一对应能够保持保端点同伦.</strong></font></p></blockquote><h4 id="复叠空间的基本群">复叠空间的基本群</h4><ul><li>复叠映射 <span class="math inline">\(p\)</span> 可诱导单同态 <span class="math inline">\(p_&amp;#42;: \pi_1(E,e_0)\to\pi_1(B,b_0)\)</span>, 且 <span class="math inline">\(p_&amp;#42;(\pi_1(E,e_0))\)</span> 在 <span class="math inline">\(\pi_1(B,b_0)\)</span> 中的指数等于 <span class="math inline">\((E,p)\)</span> 的重数.</li></ul><blockquote><p><strong>命题</strong> 集合 $ &amp;#123; p_*(_1(E,e))<sub></sub>ep^{-1}(b_0) &amp;#125; $ 是 <span class="math inline">\(\pi_1(B,b_0)\)</span> 的某个子群的共轭类. <font color="red"> <strong>这说明复叠空间 <span class="math inline">\((E,p)\)</span> 决定了 <span class="math inline">\(\pi_1(B,b_0)\)</span> 中的一个子群共轭类.</strong> </font></p></blockquote><h4 id="映射的提升">映射的提升</h4><blockquote><p><strong>映射提升的唯一性</strong> 设 <span class="math inline">\((E,p)\)</span> 是 <span class="math inline">\(B\)</span> 上的复叠空间, <span class="math inline">\(X\)</span> 连通, 映射 <span class="math inline">\(\tilde{f_i}: X\to E\)</span>, <span class="math inline">\(i=1,2\)</span> 都是 <span class="math inline">\(f: X\to B\)</span> 的提升. 若 <span class="math display">\[\exists x_0\in X,~\text{s.t.}~\tilde{f}_1(x_0)=\tilde{f}_2(x_0),\]</span> 则 <span class="math inline">\(\tilde{f}_1=\tilde{f}_2\)</span>. <font color="red"> <strong>这说明对于 <span class="math inline">\(f(x_0)=b_0\)</span>, 满足 <span class="math inline">\(\tilde{f}(x_0)=e_0\)</span> 的提升若存在必唯一.</strong> </font></p></blockquote><p>对于提升的存在性, 有如下定理:</p><blockquote><p><strong>映射提升定理</strong> 设 <span class="math inline">\(X\)</span> 是道路连通且局部道路连通空间, <span class="math inline">\(f: X\to B\)</span> 连续, <span class="math inline">\(f(x_0)=b_0\)</span>, <span class="math inline">\(e_0\in p^{-1}(b_0)\)</span>, 则: <span class="math display">\[\exists~提升~\tilde{f},~\text{s.t.}~\tilde{f}(x_0)=e_0~\Leftrightarrow~f_ &amp;#42; (\pi_1(X, x_0))\subset p_ &amp;#42; (\pi_1(E,e_0)).\]</span></p></blockquote><h4 id="复叠空间的分类">复叠空间的分类</h4><ul><li><strong>复叠空间的同态</strong>: <span class="math inline">\((E_i, p_i)\)</span>, <span class="math inline">\(i=1,2\)</span> 是 <span class="math inline">\(B\)</span> 上的复叠空间, 若连续映射 <span class="math inline">\(h: E_1\to E_2\)</span> 满足 <span class="math inline">\(p_2\circ h=p_1\)</span>, 则称 <span class="math inline">\(h\)</span> 是复叠空间 <span class="math inline">\((E_1,p_1)\to (E_2,p_2)\)</span> 的同态. 当 <span class="math inline">\(h\)</span> 是同胚时, 则称 <span class="math inline">\(h\)</span> 是同构.</li></ul><blockquote><p><strong>定理</strong> <span class="math inline">\((E_1,p_1)\)</span> 与 <span class="math inline">\((E_2,p_2)\)</span> 等价 <span class="math inline">\(\Leftrightarrow\)</span> 它们决定 <span class="math inline">\(\pi_1(B,b_0)\)</span> 的同一个子群共轭类.</p></blockquote><h4 id="复叠变换">复叠变换</h4><ul><li><strong>复叠变换</strong>: <span class="math inline">\((E,p)\)</span> 上的自同构;</li><li><strong>复叠变换群</strong>: <span class="math inline">\((E,p)\)</span> 上自同构全体关于映射的复合构成一个群, 记作 <span class="math inline">\(D(E,p)\)</span>.</li></ul><h4 id="正则复叠空间">正则复叠空间</h4><p>以下命题等价:</p><ol type="1"><li><span class="math inline">\((E,p)\)</span> 是正则复叠空间;</li><li><span class="math inline">\(\forall b\in B\)</span>, <span class="math inline">\(e\in p^{-1}(b)\)</span>, <span class="math inline">\(p_&amp;#42;(\pi_1(E,e))\)</span> 是 <span class="math inline">\(\pi_1(B,p(e))\)</span> 的正规子群;</li><li><span class="math inline">\(\forall b\in B\)</span>, <span class="math inline">\(e,e&#39;\in p^{-1}(b)\)</span>, <span class="math inline">\(p_&amp;#42;(\pi_1(E,e))=p_&amp;#42;(\pi_1(E,e&#39;))\)</span>;</li><li><span class="math inline">\(\forall b\in B\)</span>, <span class="math inline">\(e,e&#39;\in p^{-1}(b)\)</span>, <span class="math inline">\(\exists h\in D(E,p)\)</span>, s.t. <span class="math inline">\(h(e)=e&#39;\)</span>.</li></ol><h4 id="万有复叠空间">万有复叠空间</h4><ul><li><strong>万有复叠空间</strong>: 单连通的复叠空间.(显然正则)</li></ul><blockquote><p><strong>命题</strong> 设 <span class="math inline">\(p:E\to B\)</span> 是复叠空间, <span class="math inline">\(p&#39;: E&#39;\to B\)</span> 是万有复叠空间, 则有复叠映射 <span class="math inline">\(\tilde{p}: E&#39;\to E\)</span>, s.t. <span class="math inline">\(p&#39;=p\circ\tilde{p}\)</span>.</p></blockquote>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拓扑学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数理统计复习重点</title>
      <link href="/2018/01/06/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/"/>
      <content type="html"><![CDATA[<h2 id="基本概念">基本概念</h2><h3 id="chi2-分布"><span class="math inline">\(\chi^2\)</span> 分布</h3><h4 id="定义">定义</h4><p>设 <span class="math inline">\(X_1,\cdots,X_n\)</span> 为来自 <span class="math inline">\(N(0,1)\)</span> 的iid样本, 则称随机变量</p><p><span class="math display">\[\xi=\sum\limits_{i=1}^nX_i^2\]</span></p><p>所服从的分布为自由度为 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(\chi^2\)</span> 分布, 记为 <span class="math inline">\(\xi\sim\chi^2(n)\)</span>.</p><h4 id="性质">性质</h4><ol type="1"><li><p><span class="math inline">\(E\xi=n\)</span>, <span class="math inline">\({\rm Var}~\xi=2n\)</span>;</p></li><li><p>设 <span class="math inline">\(\xi\sim\chi^2(m)\)</span>, <span class="math inline">\(\eta\sim\chi^2(n)\)</span>, 且二者独立, 则 <span class="math inline">\(\xi+\eta\sim\chi^2(m+n)\)</span>;</p></li><li><p><font color="red"><span class="math inline">\((n-1)S_n^2/\sigma^2\sim\chi^2(n-1)\)</span></font>.</p></li></ol><h3 id="t-分布"><span class="math inline">\(t\)</span> 分布</h3><h4 id="定义-1">定义</h4><p>设 <span class="math inline">\(\xi\sim N(0,1)\)</span>, <span class="math inline">\(\eta\sim\chi^2(n)\)</span>, 且 <span class="math inline">\(\xi\)</span>, <span class="math inline">\(\eta\)</span> 相互独立, 则称随机变量</p><p><span class="math display">\[T=\frac{\xi}{\sqrt{\eta/n}}\]</span></p><p>服从自由度为 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(t\)</span> 分布, 记为 <span class="math inline">\(T\sim t(n)\)</span>.</p><h4 id="性质-1">性质</h4><ol type="1"><li><p>设 <span class="math inline">\(\xi\sim t(n)\)</span>, <span class="math inline">\(n&gt;2\)</span>, 则 <span class="math inline">\(E\xi=0\)</span>, <span class="math inline">\({\rm Var}~\xi=\frac{n}{n-2}\)</span>;</p></li><li><p><span class="math inline">\(t(1)\)</span> 分布为Cauchy分布, 期望不存在;</p></li><li><p><font color="red"> <span class="math inline">\(\frac{\sqrt{n}(\overline{X}-\mu)}{S}\sim t(n-1)\)</span> </font>;</p></li></ol><h3 id="f-分布"><span class="math inline">\(F\)</span> 分布</h3><h4 id="定义-2">定义</h4><p>设 <span class="math inline">\(\xi,\eta\)</span> 是自由度分别为 <span class="math inline">\(m,n\)</span> 的独立的 <span class="math inline">\(\chi^2\)</span> 随机变量, 则称随机变量</p><p><span class="math display">\[F=\frac{\xi/m}{\eta/n}\]</span></p><p>服从自由度为 <span class="math inline">\((m,n)\)</span> 的 <span class="math inline">\(F\)</span> 分布, 记为 <span class="math inline">\(F\sim F(m,n)\)</span>.</p><h4 id="性质-2">性质</h4><ol type="1"><li><span class="math inline">\(X\sim F(m,n) \Longleftrightarrow \frac{1}{X}\sim F(n,m)\)</span>.</li></ol><h3 id="gamma-分布族"><span class="math inline">\(\Gamma\)</span> 分布族</h3><h4 id="定义-3">定义</h4><p>PDF 为 <span class="math display">\[\Gamma(x;\alpha,\lambda)=\frac{\lambda^\alpha}{\Gamma(\alpha)}x^{\alpha-1}e^{-\lambda x},\quad x&gt;0\]</span> 的分布称为 <span class="math inline">\(\Gamma\)</span> 分布, 记作 <span class="math inline">\(\Gamma(\alpha,\lambda)\)</span>.</p><h4 id="性质-3">性质</h4><ol type="1"><li><p><font color="red"><span class="math inline">\(\Gamma(\frac{n}{2},\frac{1}{2})=\chi^2(n)\)</span></font>;</p></li><li><p><font color="red"><span class="math inline">\(\Gamma(1,\lambda)=E(\lambda)\)</span>, PDF 为 <span class="math inline">\(f(x)=\lambda e^{-\lambda x},~x&gt;0\)</span></font>;</p></li><li><p><font color="red"><span class="math inline">\(\xi\sim\Gamma(\alpha_1,\lambda)\)</span>, <span class="math inline">\(\eta\sim\Gamma(\alpha_2,\lambda)\)</span>, <span class="math inline">\(\eta\)</span> 与 <span class="math inline">\(\xi\)</span> 独立 <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(\xi+\eta\sim\Gamma(\alpha_1+\alpha_2,\lambda)\)</span></font>;</p></li><li><p><font color="red"><span class="math inline">\(\xi\sim\Gamma(\alpha,\lambda)\)</span>, <span class="math inline">\(k&gt;0\in\mathbb{R}\)</span> <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(\xi/k\sim\Gamma(\alpha,k\lambda)\)</span></font>.</p></li></ol><h3 id="充分统计量">充分统计量</h3><h4 id="因子分解定理">因子分解定理</h4><blockquote><p><strong>定理</strong> 对于参数分布族 <span class="math display">\[\mathcal{F}= \&amp;#123; f_\theta(x):\theta\in\Theta \&amp;#125; ,\]</span> 设 <span class="math inline">\(X_1,\cdots,X_n\)</span> 是其中一组iid样本, <span class="math inline">\(T\)</span> 是一统计量, 且其样本分布 <span class="math inline">\(f_\theta\)</span> 满足 <span class="math display">\[f_\theta(x_1,\cdots,x_n)=g_\theta(T(x_1,\cdots,x_n))\cdot h(x_1,\cdots,x_n),\]</span> 其中 <span class="math inline">\(h(x)\)</span> 不依赖于 <span class="math inline">\(\theta\)</span>.</p></blockquote><h4 id="常见的充分统计量">常见的充分统计量</h4><ol type="1"><li><p>均匀分布 <span class="math inline">\(U(0,\theta)\)</span> 中 , <span class="math inline">\(X_{(n)}\)</span> 为 <span class="math inline">\(\theta\)</span> 的充分统计量;</p></li><li><p>正态分布 <span class="math inline">\(N(\mu,\sigma^2)\)</span> 中, <span class="math inline">\((\overline{X},\sum\limits_{i=1}^n (X_i-\overline{X})^2)\)</span> 为 <span class="math inline">\((\mu,\sigma^2)\)</span> 的充分统计量;</p></li><li><p>均匀分布 <span class="math inline">\(U(-\frac{1}{2}+\theta, \frac{1}{2}+\theta)\)</span> 中, <span class="math inline">\((X_{(1)},X_{(n)})\)</span> 为 <span class="math inline">\(\theta\)</span> 的充分统计量.</p></li></ol><h2 id="点估计">点估计</h2><h3 id="矩估计">矩估计</h3><h4 id="矩估计-1">矩估计</h4><p>对于样本 <span class="math inline">\(X_1,\cdots,X_n\)</span> 和 <span class="math inline">\(k\in\mathbb{N}\)</span>, 称 <span class="math display">\[a_k=\frac{1}{n}\sum\limits_{i=1}^n X_i^k,\quad m_k=\frac{1}{n}\sum\limits_{i=1}^n (X_i-\overline{X})^k\]</span> 为 <span class="math inline">\(k\)</span> 阶中心矩和 <span class="math inline">\(k\)</span> 阶原点矩.</p><p>而总体的原点矩和中心矩分别为 <span class="math display">\[\mu_k=\mathbb{E}X^k,\quad \nu_k=\mathbb{E}(X-\mu_1)^k\]</span></p><p>矩估计就是用样本矩来估计总体矩, 即令 <span class="math inline">\(a_k=\mu_k\)</span>, <span class="math inline">\(m_k=\nu_k\)</span>.</p><h4 id="几个矩估计的例子">几个矩估计的例子</h4><ol type="1"><li><p>总体均值和总体方差: <span class="math display">\[\hat{\mu}=\overline{X},\quad \hat{\sigma}^2=\frac{n-1}{n}S_n^2;\]</span></p></li><li><p>正态分布 <span class="math inline">\(U(0,\theta)\)</span> 中, <span class="math inline">\(\theta\)</span> 的矩估计为 <span class="math inline">\(\hat{\theta}=2\overline{X}\)</span>;</p></li></ol>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 统计学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>测度与概率复习重点</title>
      <link href="/2018/01/02/%E6%B5%8B%E5%BA%A6%E4%B8%8E%E6%A6%82%E7%8E%87%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/"/>
      <content type="html"><![CDATA[<h2 id="测度空间">测度空间</h2><h3 id="各种集类">各种集类</h3><h4 id="半集代数">半集代数</h4><ol type="1"><li><span class="math inline">\(\Omega\in\mathscr{S}\)</span>, <span class="math inline">\(\varnothing\in\mathscr{S}\)</span>;</li><li>若 <span class="math inline">\(A,B\in\mathscr{S}\)</span>, 则 <span class="math inline">\(A\cap B\in\mathscr{S}\)</span>;</li><li>若 <span class="math inline">\(A,A_1\in\mathscr{S}\)</span>, <span class="math inline">\(A_1\subset A\)</span>, 则 <span class="math inline">\(\exists A_2,\cdots,A_n\subset\mathscr{S}\)</span>, <span class="math inline">\(A_1,\cdots,A_n\)</span> 两两不交, 且 <span class="math inline">\(A=\bigcup\limits_{k=1}^nA_k\)</span>.</li></ol><h4 id="集代数">集代数</h4><ol type="1"><li><span class="math inline">\(\Omega\in\mathscr{A}\)</span>;</li><li>若 <span class="math inline">\(A,B\in\mathscr{A}\)</span>, 则 <span class="math inline">\(A\cap B, A\cup B\in\mathscr{A}\)</span>;</li><li>若 <span class="math inline">\(A\in\mathscr{A}\)</span>, 则 <span class="math inline">\(A^c\in\mathscr{A}\)</span>.</li></ol><ul><li>包含半集代数 <span class="math inline">\(\mathscr{S}\)</span> 的最小集代数为 $()= &amp;#123; _{k=1}^n A_k:A_1,,A_n &amp;#125; $.</li></ul><h4 id="sigma-代数"><span class="math inline">\(\sigma\)</span> 代数</h4><ol type="1"><li><span class="math inline">\(\Omega\in\mathcal{F}\)</span>;</li><li>若 <span class="math inline">\(A\in\mathcal{F}\)</span>, 则 <span class="math inline">\(A^c\in\mathcal{F}\)</span>;</li><li>若 <span class="math inline">\(A_n\in\mathcal{F}~(n\in\mathbb{N})\)</span>, 则 <span class="math inline">\(\bigcup\limits_{n=1}^\infty A_n\in\mathcal{F}\)</span>.</li></ol><ul><li>任意一族 <span class="math inline">\(\sigma\)</span> 代数的交仍然是 <span class="math inline">\(\sigma\)</span> 代数;</li><li>所有包含 <span class="math inline">\(\mathcal{C}\)</span> 的 <span class="math inline">\(\sigma\)</span> 代数的交称为包含 <span class="math inline">\(\mathcal{C}\)</span> 的<strong>最小 <span class="math inline">\(\sigma\)</span> 代数</strong>, 记作 <span class="math inline">\(\sigma(\mathcal{C})\)</span>.</li></ul><h3 id="单调类定理">单调类定理</h3><h4 id="lambda-系"><span class="math inline">\(\lambda\)</span> 系</h4><ol type="1"><li><span class="math inline">\(\Omega\in\Lambda\)</span>;</li><li>对真差封闭: <span class="math inline">\(A,B\in\Lambda\)</span>, <span class="math inline">\(A\subset B\)</span>, 则 <span class="math inline">\(B\backslash A\in\Lambda\)</span>;</li><li>对不降序列的并封闭: $ &amp;#123; A_n:n &amp;#125; $, <span class="math inline">\(A_n\uparrow\)</span>, 则 <span class="math inline">\(\bigcup\limits_{n=1}^\infty A_n\in\Lambda\)</span>.</li></ol><h4 id="pi-系"><span class="math inline">\(\pi\)</span> 系</h4><ol type="1"><li>对交封闭: <span class="math inline">\(A,B\in\Lambda\)</span>, 则 <span class="math inline">\(A\cap B\in\Lambda\)</span>.</li></ol><h4 id="单调类定理-1">单调类定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\Omega\)</span> 的子集类 <span class="math inline">\(\mathcal{C}\)</span> 是 <span class="math inline">\(\pi\)</span> 系, 则 <span class="math inline">\(\Lambda(\mathcal{C})=\sigma(\mathcal{C})\)</span>.</p></blockquote><p>证明思路:</p><ol type="1"><li>令 $_A= &amp;#123; B():AB() &amp;#125; $;</li><li><span class="math inline">\(\forall A\in\Lambda(\mathcal{C})\)</span>, 证明 <span class="math inline">\(\Lambda_A\)</span> 是 <span class="math inline">\(\lambda\)</span> 系;</li><li><span class="math inline">\(\forall A\in\mathcal{C}\)</span>, 证明 <span class="math inline">\(\Lambda_A=\Lambda(\mathcal{C})\)</span>;</li><li><span class="math inline">\(\forall A\in\Lambda(\mathcal{C})\)</span>, 证明 <span class="math inline">\(\Lambda_A=\Lambda(\mathcal{C})\)</span>.</li></ol><h3 id="测度的构造">测度的构造</h3><h4 id="有限可加测度">有限可加测度</h4><ul><li>可加: <span class="math inline">\(\forall A,B\in\mathcal{C}\)</span>, <span class="math inline">\(A\cup B\in\mathcal{C}\)</span>, <span class="math inline">\(A\cap B=\varnothing\)</span>, 有 <span class="math inline">\(\mu(A\cup B)=\mu(A)+\mu(B)\)</span>.</li><li>可加测度 <span class="math inline">\(\Leftrightarrow\)</span> 有限可加测度.</li></ul><h4 id="sigma-可加测度"><span class="math inline">\(\sigma\)</span> 可加测度</h4><ul><li><span class="math inline">\(\forall A_n\in\mathcal{C}\)</span>, <span class="math inline">\(n\in\mathbb{N}\)</span> 两两不交且 <span class="math inline">\(\bigcup\limits_{n=1}^\infty A_n\in\mathcal{C}\)</span>, 有 <span class="math inline">\(\mu(\bigcup\limits_{n=1}^\infty A_n)=\sum\limits_{n=1}^\infty\mu(A_n)\)</span>.</li></ul><h4 id="sigma-有限测度"><span class="math inline">\(\sigma\)</span> 有限测度</h4><p>若 <span class="math inline">\(\forall A\in\mathcal{C}\)</span>, <span class="math inline">\(\exists \&amp;#123; A_n:n\in\mathbb{N} \&amp;#125; \subset\mathcal{C}\)</span>, s.t. <span class="math inline">\(\bigcup\limits_{n=1}^\infty A_n=A\)</span> 且 <span class="math inline">\(\mu(A_n)&lt;\infty\)</span>, <span class="math inline">\(\forall n\in\mathbb{N}\)</span>, 则称其为 <span class="math inline">\(\sigma\)</span> 有限的.</p><h3 id="测度扩张定理">测度扩张定理</h3><h4 id="半集代数上的测度">半集代数上的测度</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(F\)</span> 为 <span class="math inline">\(\mathbb{R}\)</span> 上的右连续增函数, 则在半集代数 <span class="math display">\[\mathscr{S}:= \&amp;#123; (a,b]:-\infty\leqslant a\leqslant b\leqslant\infty \&amp;#125; \]</span> 上有唯一的测度 <span class="math inline">\(\mu=\mu_F\)</span>, s.t. <span class="math display">\[\mu((a,b])=F(b)-F(a),~a\leqslant b\leqslant a,b\in\mathbb{R},\]</span> 并且 <span class="math inline">\(\mu\)</span> 在有限区间上的值有限(因而 <span class="math inline">\(\sigma\)</span> 有限).</p></blockquote><h4 id="测度扩张定理-1">测度扩张定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\mu\)</span> 为 <span class="math inline">\(\Omega\)</span> 的半集代数 <span class="math inline">\(\mathscr{S}\)</span> 上的测度, 则 <span class="math inline">\(\mu\)</span> 在 <span class="math inline">\(\mathscr{S}\)</span> 生成的 <span class="math inline">\(\sigma\)</span> 代数 <span class="math inline">\(\sigma(\mathscr{S})\)</span> 上存在一个扩张. 若 <span class="math inline">\(\mu\)</span> 是 <span class="math inline">\(\sigma\)</span> 有限的, 则扩张唯一.</p></blockquote><ul><li>唯一性证明: <span class="math inline">\(\lambda-\pi\)</span> 系方法.</li></ul><h4 id="外测度">外测度</h4><ol type="1"><li><span class="math inline">\(\mu^&amp;#42;(\varnothing)=0\)</span>;</li><li>不降性: <span class="math inline">\(\forall A\subset B\subset\Omega\)</span>, 有 <span class="math inline">\(\mu^&amp;#42;(A)\leqslant \mu^&amp;#42;(B)\)</span>;</li><li>次 <span class="math inline">\(\sigma\)</span> 可加性: <span class="math inline">\(\forall A_n\subset\Omega\)</span>, <span class="math inline">\(n\in\mathbb{N}\)</span>, 有 <span class="math display">\[\mu^&amp;#42;(\bigcup\limits_{N=1}^\infty A_n)\leqslant \sum\limits_{n=1}^\infty \mu^&amp;#42;(A_n).\]</span></li></ol><ul><li><span class="math inline">\(\mu^&amp;#42;\)</span> 可测集: <span class="math inline">\(\mu^&amp;#42;(D)=\mu^&amp;#42;(A\cap D)+\mu^&amp;#42;(A^c\cap D)\)</span>.</li></ul><h3 id="测度空间-1">测度空间</h3><h4 id="测度空间-2">测度空间</h4><p><span class="math inline">\((\Omega,\mathcal{F},\mu)\)</span> 是测度空间当且仅当 <span class="math inline">\(\mathcal{F}\)</span> 是 <span class="math inline">\(\sigma\)</span> 代数且 <span class="math inline">\(\mu\)</span> 是 <span class="math inline">\(\Omega\)</span> 上的 <span class="math inline">\(\sigma\)</span> 可加测度.</p><ul><li>若 <span class="math inline">\(\mu(\Omega)=1\)</span> 则称为概率空间, <span class="math inline">\(\mu\)</span> 即为概率 <span class="math inline">\(\mathbb{P}\)</span>.</li></ul><h4 id="可加性的提升">可加性的提升</h4><blockquote><p><strong>定理</strong> <span class="math inline">\(\mu\)</span> 为集代数 <span class="math inline">\(\mathscr{A}\)</span> 上的<strong>可加</strong>测度, 若 <span class="math inline">\(\mu\)</span> 还满足以下条件之一: 1. <span class="math inline">\(\mu\)</span> 下方连续: 即对 <span class="math inline">\(\forall \&amp;#123; A_n \&amp;#125; \subset\mathscr{A}\)</span>, <span class="math inline">\(A_n\uparrow A\)</span>, 总有 <span class="math inline">\(\lim\limits_ {n\to\infty}\mu(A_n)=\mu(A)\)</span>; 2. <span class="math inline">\(\mu\)</span> 有限且在 <span class="math inline">\(\varnothing\)</span> 上方连续: 即对 <span class="math inline">\(\forall \&amp;#123; A_n \&amp;#125; \subset\mathscr{A}\)</span>, <span class="math inline">\(A_n\downarrow\varnothing\)</span>, 都有 <span class="math inline">\(\lim\limits_{n\to\infty}\mu(A_n)=0\)</span>. 则 <span class="math inline">\(\mu\)</span> 为 <span class="math inline">\(\mathscr{A}\)</span> 上的测度(即有限可加可提升为 <span class="math inline">\(\sigma\)</span> 可加).</p></blockquote><h4 id="测度的完全化">测度的完全化</h4><ul><li><strong><span class="math inline">\(\mu\)</span> 零集</strong>: 零测集的子集称为 <span class="math inline">\(\mu\)</span> 零集;</li><li><strong>完全测度</strong>: 若每一个 <span class="math inline">\(\mu\)</span> 零集都属于 <span class="math inline">\(\mathcal{F}\)</span>, 则称 <span class="math inline">\(\mu\)</span> 为完全测度, 该测度空间为完全测度空间.</li></ul><blockquote><p><strong>定理</strong> 设 <span class="math inline">\((\Omega, \mathcal{F}, \mu)\)</span> 为测度空间, 令 <span class="math display">\[\overline{\mathcal{F}}= \&amp;#123; A\triangle N:A\in\mathcal{F}, N 为 \mu 零集 \&amp;#125; = \&amp;#123; A\cup N:A\in\mathcal{F}, N 为 \mu 零集 \&amp;#125; \]</span> <span class="math display">\[\overline{\mu}(A\triangle N)=\mu(A),~A\in\mathcal{F},~N 为 \mu 零集合\]</span> 则 <span class="math inline">\((\Omega,\overline{\mathcal{F}},\overline{\mu})\)</span> 为一个完全测度空间, 称为原空间的完全化.</p></blockquote><h2 id="可测函数与随机变量">可测函数与随机变量</h2><h3 id="逆像">逆像</h3><h4 id="逆像与集合运算的交换">逆像与集合运算的交换</h4><p>设 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(\Omega\to E\)</span> 的映射, 则 <span class="math inline">\(f^{-1}\)</span> 有如下性质:</p><ol type="1"><li><p><span class="math inline">\(f^{-1}(E)=\Omega\)</span>, <span class="math inline">\(f^{-1}(\varnothing)=\varnothing\)</span>;</p></li><li><p><span class="math inline">\(f^{-1}(B^c)=(f^{-1}(B))^c\)</span>;</p></li><li><p><span class="math inline">\(f^{-1}(\bigcup\limits_{\gamma\in\Gamma}B_\gamma)=\bigcup\limits_{\gamma\in\Gamma}f^{-1}(B_\gamma)\)</span>;</p></li><li><p><span class="math inline">\(f^{-1}(\bigcap\limits_{\gamma\in\Gamma}B_\gamma)=\bigcap\limits_{\gamma\in\Gamma}f^{-1}(B_\gamma)\)</span>;</p></li><li><p><span class="math inline">\(f^{-1}(B_1\backslash B_2)=f^{-1}(B_1)\backslash f^{-1}(B_2)\)</span>.</p></li></ol><h4 id="逆像与集类">逆像与集类</h4><p>进一步, <span class="math inline">\(f^{-1}\)</span> 还对集类有相同的作用:</p><ol type="1"><li><p><span class="math inline">\(\mathscr{E}\)</span> 为 <span class="math inline">\(E\)</span> 的一个 <span class="math inline">\(\sigma\)</span> 代数 <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(f^{-1}(\mathscr{E})\)</span> 是 <span class="math inline">\(\Omega\)</span> 的 <span class="math inline">\(\sigma\)</span> 代数;</p></li><li><p><span class="math inline">\(\mathcal{C}\)</span> 是 <span class="math inline">\(E\)</span> 的任意非空子集类, 则 <span class="math inline">\(f^{-1}(\sigma(\mathcal{C}))=\sigma(f^{-1}(\mathcal{C}))\)</span>. (<strong>证明: <span class="math inline">\(\lambda-\pi\)</span> 系方法</strong>)</p></li></ol><h3 id="随机变量">随机变量</h3><blockquote><p><strong>定理</strong> <span class="math inline">\(X\)</span> 是 <span class="math inline">\((\Omega,\mathcal{F})\to (E,\mathscr{E})\)</span> 的可测映射的充要条件是: 存在 <span class="math inline">\(\mathscr{E}\)</span> 的一个子集类 <span class="math inline">\(\mathcal{C}\)</span>, s.t. 1. <span class="math inline">\(\sigma(\mathcal{C})=\mathscr{E}\)</span>; 2. <span class="math inline">\(\forall A\in\mathcal{C}\)</span>, <span class="math inline">\(X^{-1}(A)\in\mathcal{F}\)</span>.</p></blockquote><h4 id="可测函数的构造">可测函数的构造</h4><center><font color="red"><strong>非负简单函数→非负可测函数→可测函数</strong></font></center><h3 id="单调类定理-2">单调类定理</h3><h4 id="mathscrl-系"><span class="math inline">\(\mathscr{L}\)</span> 系</h4><p>设 <span class="math inline">\(\mathscr{L}\)</span> 是定义在 <span class="math inline">\(\Omega\)</span> 上的广义实函数类, 满足: <span class="math inline">\(f\in\mathscr{L}\Rightarrow f^+,f^-\in\mathscr{L}\)</span>. 函数族 <span class="math inline">\(L\)</span> 称为 <span class="math inline">\(\mathscr{L}\)</span>, 如果满足: 1. <span class="math inline">\(1\in L\)</span>; 2. <span class="math inline">\(L\)</span> 中有限个函数的线性组合(如果有意义)属于 <span class="math inline">\(L\)</span>; 3. 若 <span class="math inline">\(f_n\in L\)</span>, <span class="math inline">\(n\in\mathbb{N}\)</span>, <span class="math inline">\(0\leqslant f_n\uparrow f\)</span>, <span class="math inline">\(f\)</span> 有界或 <span class="math inline">\(f\in\mathscr{L}\)</span>, 则 <span class="math inline">\(f\in L\)</span>.</p><h4 id="单调类定理-3">单调类定理</h4><blockquote><p>若 <span class="math inline">\(\mathscr{L}\)</span> 系 <span class="math inline">\(L\)</span> 包含一 <span class="math inline">\(\pi\)</span> 系 <span class="math inline">\(\mathcal{C}\)</span> 中任意集合的示性函数, 则 <span class="math inline">\(L\)</span> 包含所有属于 <span class="math inline">\(\mathscr{L}\)</span> 的 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 可测函数.</p></blockquote><ul><li>证明: <span class="math inline">\(\lambda-\pi\)</span> 系方法.</li></ul><h2 id="积分与数学期望">积分与数学期望</h2><center><font color="red"><strong>非负简单函数→非负可测函数→可测函数</strong></font></center><h3 id="积分的性质">积分的性质</h3><h4 id="单调收敛">单调收敛</h4><blockquote><p><strong>定理</strong> 若 <span class="math inline">\(f_n\)</span>, <span class="math inline">\(n\in\mathbb{N}\)</span> 是<strong>非负</strong>(可举反例)可测函数列, 且 <span class="math inline">\(f_n\uparrow f\)</span>, 则 <span class="math inline">\(\lim\limits_{n\to\infty}\int f_n=\int f\)</span>.</p></blockquote><h4 id="积分的序性质">积分的序性质</h4><ol type="1"><li><p>若 <span class="math inline">\(f,g\)</span> 为实函数, <span class="math inline">\(\int f\)</span>, <span class="math inline">\(\int g\)</span> 存在, 且 <span class="math inline">\(f\geqslant g\)</span>, a.e. 则 <span class="math inline">\(\int_A f\geqslant \int_A g\)</span>, <span class="math inline">\(\forall A\in\mathcal{F}\)</span>.</p></li><li><p>若 <span class="math inline">\(\int f\)</span> 存在, 则 <span class="math inline">\(\vert\int f\vert\leqslant \int\vert f\vert\)</span>,</p></li><li><p><span class="math inline">\(f\geqslant 0\)</span>, 则 <span class="math inline">\(\int f=0\Leftrightarrow f=0\)</span>, a.e..</p></li></ol><h4 id="可积性质">可积性质</h4><p>给定可测函数 <span class="math inline">\(f,g\)</span> 有:</p><ol type="1"><li><p><span class="math inline">\(f\)</span> 可积 <span class="math inline">\(\Leftrightarrow\)</span> $f&lt;$; 当 <span class="math inline">\(f\)</span> 可积时, <span class="math inline">\(f\)</span> a.e. 有限;</p></li><li><p>若 <span class="math inline">\(\vert f\vert\leqslant g\)</span> 可积, 则 <span class="math inline">\(f\)</span> 可积;</p></li><li><p>若 <span class="math inline">\(f,g\)</span> 可积, 则 <span class="math inline">\(f+g\)</span> 可积.</p></li></ol><h3 id="期望的性质">期望的性质</h3><h4 id="独立事件类的扩张">独立事件类的扩张</h4><p>独立事件类可以由 <span class="math inline">\(\pi\)</span> 系扩张至其生成的 <span class="math inline">\(\sigma\)</span> 代数.</p><blockquote><p><strong>定理</strong> <span class="math inline">\(\mathcal{C}_k\subset\mathcal{F}\)</span> 为包含 <span class="math inline">\(\Omega\)</span> 的 <span class="math inline">\(\pi\)</span> 系, 若 <span class="math inline">\(\forall A_k\in\mathcal{C}_k\)</span>, <span class="math inline">\(k=1,\cdots,n\)</span>, 有 <span class="math display">\[\mathbb{P}(\bigcap\limits_{k=1}^n A_k)=\prod\limits_{k=1}^n \mathbb{P}(A_k),\]</span> 则上式对 <span class="math inline">\(\forall A_k\in\sigma(\mathcal{C}_k)\)</span>, <span class="math inline">\(k=1,\cdots,n\)</span> 成立.</p></blockquote><h4 id="独立随机变量">独立随机变量</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(X_1,\cdots,X_n\)</span> 为独立r.v., 且 <span class="math inline">\(\mathbb{E}X_k\)</span> 有限, 则 <span class="math display">\[\mathbb{E}(X_1\cdots X_n)=\prod\limits_{k=1}^n \mathbb{E}X_k.\]</span></p></blockquote><h3 id="l-s-积分表示">L-S 积分表示</h3><h4 id="分布测度">分布测度</h4><p>设 <span class="math inline">\(f\)</span> 是 <span class="math inline">\((\Omega,\mathcal{F},\mu)\to(E,\mathscr{E})\)</span> 的可测映射, <span class="math inline">\(\mu\)</span> 是 <span class="math inline">\(\mathcal{F}\)</span> 上的测度, 定义 <span class="math display">\[\mu_f(B)=\mu(f^{-1}(B)),\quad \forall B\in\mathscr{E},\]</span> 则 <span class="math inline">\(\mu_f\)</span> 是 <span class="math inline">\(\mathscr{E}\)</span> 上的测度, 也可记作 <span class="math inline">\(\mu_f=\mu\circ f^{-1}\)</span>.</p><h4 id="积分变换定理">积分变换定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(f\)</span> 是 <span class="math inline">\((\Omega,\mathcal{F},\mu)\to(E,\mathscr{E})\)</span> 的可测映射, <span class="math inline">\(g\)</span> 是 <span class="math inline">\((E,\mathscr{E})\)</span> 上的可测函数, 则 <span class="math display">\[\int_{f^{-1}(B)}(g\circ f){\rm d}\mu=\int_B g{\rm d}\mu_f,\quad \forall B\in\mathscr{E}.~(同时存在,~存在即相等)\]</span></p></blockquote><h4 id="积分变换">积分变换</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\mu\)</span> 是 <span class="math inline">\((\Omega,\mathcal{F})\)</span> 上的测度, <span class="math inline">\(p\)</span> 是非负 <span class="math inline">\(\mathcal{F}\)</span> 可测函数, 定义 <span class="math display">\[\nu(A)=\int_A p(w)\mu({\rm d}w),\quad A\in \mathcal{F},\]</span> 则 <span class="math inline">\(\nu\)</span> 是 <span class="math inline">\(\mathcal{F}\)</span> 上的测度, 且有 <span class="math display">\[\int_A g(w)\nu({\rm d}w)=\int_A g(w)p(w)\mu({\rm d}w).~(同时存在,~存在即相等)\]</span></p></blockquote><h3 id="积分的收敛">积分的收敛</h3><h4 id="单调收敛定理">单调收敛定理</h4><blockquote><p><strong>定理</strong> 给定 <span class="math inline">\((\Omega,\mathcal{F},\mu)\)</span>, <span class="math inline">\(g\)</span> 为实可积函数, <span class="math inline">\(f_n\)</span>, <span class="math inline">\(n\in\mathbb{N}\)</span> 是实 <span class="math inline">\(\mathcal{F}\)</span> 可测函数, 若 <span class="math inline">\(g\leqslant f_n\uparrow f\)</span>, a.e. 则 <span class="math display">\[\lim\limits_{n\to\infty}\int f_n=\int\lim\limits_{n\to\infty}f_n.\]</span></p></blockquote><h4 id="fatou引理">Fatou引理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(g,h\)</span> 是可积实函数, $ &amp;#123; f_n:n &amp;#125; $ 是实可测函数列, 有 1. <span class="math inline">\(\forall n\in\mathbb{N}\)</span>, <span class="math inline">\(f_n\geqslant g\)</span>, a.e., 则 <span class="math display">\[\int\varliminf\limits_{n\to\infty} f_n\leqslant \varliminf\limits_{n\to\infty}\int f_n.\]</span> 2. <span class="math inline">\(\forall n\in\mathbb{N}\)</span>, <span class="math inline">\(f_n\leqslant h\)</span>, a.e., 则 <span class="math display">\[\int\varlimsup\limits_{n\to\infty} f_n\geqslant \varlimsup\limits_{n\to\infty}\int f_n.\]</span></p></blockquote><h4 id="控制收敛定理">控制收敛定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(g,h\)</span> 为可积实函数. 1. 若 <span class="math inline">\(f_n\)</span>, <span class="math inline">\(n\in\mathbb{N}\)</span> 为实可测函数序列, 当 <span class="math inline">\(g\leqslant f_n\leqslant h\)</span>, a.e., <span class="math inline">\(\forall n\in\mathbb{N}\)</span>, <span class="math inline">\(f_n\to f\)</span>, a.e. 时, 有 <span class="math inline">\(\int f_n\to\int f\)</span>. 2. 若 <span class="math inline">\(f_n\)</span>, <span class="math inline">\(n\in\mathbb{N}\)</span> 为实或复可测函数序列, 当 <span class="math inline">\(\vert f_n\vert\leqslant g\)</span>, a.e., <span class="math inline">\(\forall n\in\mathbb{N}\)</span>, <span class="math inline">\(f_n\to f\)</span>, a.e. 时, 有 <span class="math inline">\(\int\vert f_n-f\vert\to 0\)</span>, 因而 <span class="math inline">\(\int f_n\to\int f\)</span>.</p></blockquote><h2 id="乘积空间">乘积空间</h2><h3 id="乘积-sigma-代数">乘积 <span class="math inline">\(\sigma\)</span> 代数</h3><p>设 <span class="math inline">\((\Omega_i,\mathcal{F})\)</span>, <span class="math inline">\(i=1,2\)</span> 是可测空间, 称包含可测矩形 <span class="math display">\[\mathcal{C}= \&amp;#123; A_1\times A_2: A_i\in\mathcal{F}, i=1,2 \&amp;#125; \]</span> 的最小 <span class="math inline">\(\sigma\)</span> 代数为 <span class="math inline">\(\mathcal{F}_1,\mathcal{F}_2\)</span> 的乘积 <span class="math inline">\(\sigma\)</span> 代数.</p><ul><li>可测矩形类 <span class="math inline">\(\mathcal{C}\)</span> 是一个半集代数;</li><li><span class="math inline">\(\mathscr{B}^2=\mathscr{B}\times\mathscr{B}\)</span>. (<strong>证明: <span class="math inline">\(\lambda-\pi\)</span> 系方法</strong>)</li></ul><h3 id="截集">截集</h3><h4 id="截集-1">截集</h4><p><span class="math inline">\(A\subset\Omega_1\times\Omega_2\)</span>, <span class="math inline">\(\omega_i\in\Omega_i\)</span>, <span class="math inline">\(i=1,2\)</span>, 称集合 <span class="math display">\[A_{\omega_1}=A(\omega_1)= \&amp;#123; \omega_2\in\Omega_2: (\omega_1,\omega_2)\in A \&amp;#125; ,\]</span> <span class="math display">\[A_{\omega_2}=A(\omega_2)= \&amp;#123; \omega_1\in\Omega_1: (\omega_1,\omega_2)\in A \&amp;#125; ,\]</span> 分别为 <span class="math inline">\(A\)</span> 在 <span class="math inline">\(\omega_1\)</span>, <span class="math inline">\(\omega_2\)</span> 处的截集.</p><h4 id="截集的性质">截集的性质</h4><p>截集与集合的运算可以交换:</p><ol type="1"><li><p><span class="math inline">\(A\cap B=\varnothing\Rightarrow A(\omega_i)\cap B(\omega_i)=\varnothing\)</span>;</p></li><li><p><span class="math inline">\(A\subset B\Rightarrow A(\omega_i)\subset B(\omega_i)\)</span>;</p></li><li><p><span class="math inline">\(A=\bigcup\limits_\alpha A^{(\alpha)}\Rightarrow A(\omega_i)=\bigcup\limits_\alpha A^{(\alpha)}(\omega_i)\)</span>;</p></li><li><p><span class="math inline">\(A=\bigcap\limits_\alpha A^{(\alpha)}\Rightarrow A(\omega_i)=\bigcap\limits_\alpha A^{(\alpha)}(\omega_i)\)</span>;</p></li><li><p><span class="math inline">\(C=A\backslash B\Rightarrow C(\omega_i)=A(\omega_i)\backslash B(\omega_i)\)</span>.</p></li></ol><p>对于截集的可测性有如下定理:</p><blockquote><p><strong>定理</strong> 取 <span class="math inline">\(A\in\mathcal{F}_1\times\mathcal{F}_2\)</span>, 则 <span class="math inline">\(\forall \omega_1\in\mathcal{F}_1\)</span>, 有 <span class="math inline">\(A(\omega_1)\in\mathcal{F}_2\)</span>.</p></blockquote><p><strong>证明: <span class="math inline">\(\lambda-\pi\)</span> 系方法.</strong></p><h4 id="截函数">截函数</h4><ul><li><span class="math inline">\(f_{\omega_1}=f(\omega_1,\cdot)\)</span> 称为 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(\omega_1\)</span> 的截函数;</li><li><span class="math inline">\(f_{\omega_2}=f(\cdot,\omega_2)\)</span> 称为 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(\omega_2\)</span> 的截函数;</li></ul><blockquote><p><strong>定理</strong> 任意 <span class="math inline">\(\mathcal{F}_1\times\mathcal{F}_2\)</span> 可测函数的截函数是可测的.</p></blockquote><p>关于截函数还有如下重要定理:</p><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(\mathcal{F}_1\times\mathcal{F}_2\)</span> 可测函数, <span class="math inline">\(\mu_i\)</span> 是 <span class="math inline">\(\sigma\)</span> 有限测度, 则 <span class="math display">\[f^{(2)}=\int_{\Omega_1}f(\omega_1,\cdot)\mu_1({\rm d}\omega_1)\]</span> <span class="math display">\[f^{(1)}=\int_{\Omega_2}f(\cdot,\omega_2)\mu_2({\rm d}\omega_2)\]</span> 是非负可测函数.</p></blockquote><h3 id="乘积测度">乘积测度</h3><p>设 <span class="math inline">\(\mu_i\)</span> 是 <span class="math inline">\(\sigma\)</span> 有限测度, 若令 <span class="math display">\[\mu(A)=\int_{\Omega_1}\mu_2(A(\omega_1))\mu_1({\rm d}\omega_1),~A\in\mathcal{F}_1\times\mathcal{F}_2,\]</span> 或 <span class="math display">\[\mu(A)=\int_{\Omega_2}\mu_1(A(\omega_2))\mu_2({\rm d}\omega_2),~A\in\mathcal{F}_1\times\mathcal{F}_2,\]</span> 则 <span class="math inline">\(\mu\)</span> 是 <span class="math inline">\(\mathcal{F}_1\times\mathcal{F}_2\)</span> 上唯一满足 <span class="math display">\[\mu(A_1\times A_2)=\mu_1(A_1)\mu_2(A_2),~\forall A_i\in\mathcal{F}_i\]</span> 的 <span class="math inline">\(\sigma\)</span> 有限测度.</p><h3 id="转移测度">转移测度</h3><p>映射 <span class="math inline">\(\lambda:\Omega_1\times\mathcal{F}_2\to [0,\infty]\)</span> 满足下列条件, 就称之为 <span class="math inline">\((\Omega_1,\mathcal{F}_1)\to(\Omega_2,\mathcal{F}_2)\)</span> 的转移测度: 1. <span class="math inline">\(\forall B\in\mathcal{F}_2\)</span>, <span class="math inline">\(\lambda(\cdot,B)\)</span> 是 <span class="math inline">\(\mathcal{F}_1\)</span> 可测函数; 2. <span class="math inline">\(\forall \omega\in\Omega_1\)</span>, <span class="math inline">\(\lambda(\omega,\cdot)\)</span> 是 <span class="math inline">\(\mathcal{F}_2\)</span> 上的测度.</p><p>若 <span class="math inline">\(\exists B_{kn}\in\mathcal{F}_k\)</span>, <span class="math inline">\(n\in\mathbb{N}\)</span> 两两不交, <span class="math inline">\(\Omega_k=\bigcup\limits_{n=1}^\infty B_{kn}\)</span>, <span class="math inline">\(k=1,2\)</span>, s.t. <span class="math display">\[\sup\limits_{\omega\in B_{1m}}\lambda(\omega,B_{2n})&lt;\infty,~\forall m,n\in\mathbb{N},\]</span> 则称 <span class="math inline">\(\lambda\)</span> 为 <span class="math inline">\(\sigma\)</span> 有限转移测度.</p><h3 id="fubini定理">Fubini定理</h3><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(f\)</span> 是非负 <span class="math inline">\(\mathcal{F}_1\times\mathcal{F}_2\)</span> 可测函数, 则 <span class="math display">\[\begin{align}\int_{\Omega_1\times\Omega_2}f{\rm d}(\mu_1\times\mu_2) &amp;= \int_{\Omega_1}\left(\int_{\Omega_2}f(\omega_1,\omega_2)\mu_2({\rm d}\omega_2)\right)\mu_1({\rm d}\omega_1) \\&amp;= \int_{\Omega_2}\left(\int_{\Omega_1}f(\omega_1,\omega_2)\mu_1({\rm d}\omega_1)\right)\mu_2({\rm d}\omega_2).\end{align}\]</span></p></blockquote><h4 id="fubini定理-1">Fubini定理</h4><blockquote><p><strong>Fubini</strong> 设 <span class="math inline">\(f\)</span> 是非负 <span class="math inline">\(\mathcal{F}_1\times\mathcal{F}_2\)</span> 可测函数且 <span class="math inline">\(\int f{\rm d}(\mu_1\times\mu_2)\)</span> 存在, 则 1. 积分函数存在且可测: - <span class="math inline">\(g(\omega_1)=\int_{\Omega_2}f(\omega_1,\omega_2)\mu_2({\rm d}\omega_2)\)</span> 存在且 <span class="math inline">\(\mathcal{F}_1\)</span> 可测; - <span class="math inline">\(h(\omega_2)=\int_{\Omega_1}f(\omega_1,\omega_2)\mu_1({\rm d}\omega_1)\)</span> 存在且 <span class="math inline">\(\mathcal{F}_2\)</span> 可测; 2. <span class="math inline">\(\int_{\Omega_1}g{\rm d}\mu_1\)</span>, <span class="math inline">\(\int_{\Omega_2}h{\rm d}\mu_2\)</span> 存在且 <span class="math display">\[\int_{\Omega_1\times\Omega_2}f({\rm d}\mu_1\times\mu_2)=\int_{\Omega_1}g({\rm d}\mu_1)=\int_{\Omega_2}f({\rm d}\mu_2);\]</span> 3. 若 <span class="math inline">\(f\)</span> 对 <span class="math inline">\(\mu_1\times\mu_2\)</span> 可积, 则 <span class="math inline">\(g\)</span>, <span class="math inline">\(h\)</span> 分别对 <span class="math inline">\(\mu_1\)</span>, <span class="math inline">\(\mu_2\)</span> 可积.</p></blockquote>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率论 </tag>
            
            <tag> 测度论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>泛函——复习重点</title>
      <link href="/2017/12/24/%E6%B3%9B%E5%87%BD%E2%80%94%E2%80%94%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/"/>
      <content type="html"><![CDATA[<h2 id="度量空间">度量空间</h2><h3 id="基础知识">基础知识</h3><h4 id="压缩映像原理">压缩映像原理</h4><blockquote><p><strong>Banach</strong> 设 <span class="math inline">\((\mathscr{X},\rho)\)</span> 是一个完备度量空间, <span class="math inline">\(T\)</span> 是 <span class="math inline">\(\mathscr{X}\)</span> 到自身的一个压缩映射, 则 <span class="math inline">\(T\)</span> 在 <span class="math inline">\(\mathscr{X}\)</span> 上存在唯一的不动点.</p></blockquote><h4 id="完备化">完备化</h4><p><strong>完备化空间</strong>: 包含 <span class="math inline">\(\mathscr{X}\)</span> 的最小完备度量空间. 关于其存在性有如下定理:</p><blockquote><p><strong>定理</strong> 每个度量空间都有一个自身在其中稠的完备化空间.</p></blockquote><h4 id="有界性与列紧性">有界性与列紧性</h4><blockquote><p><strong>定理</strong> 列紧空间的任意子集都是列紧集. 进一步, 任意闭子集都是自列紧的. <strong>定理</strong> 列紧空间必定完备. 反之不成立, 如 <span class="math inline">\(\mathbb{R}\)</span>.</p></blockquote><ul><li>完全有界和列紧</li></ul><blockquote><p><strong>定理</strong> 列紧集一定完全有界, 完全有界集必定有界. <strong>定理</strong> 有穷维 <span class="math inline">\(B^&amp;#42;\)</span> 空间的有界集必定完全有界, 完备空间中的完全有界集必定列紧.</p></blockquote><p><span class="math inline">\(\mathscr{X}\)</span> 中的列紧集、完全有界集、有界集三者的关系如下: <font color="red"><span class="math display">\[列紧~\underset{\mathscr{X}~完备}{\rightleftarrows}~完全有界~\underset{有限维B^&amp;#42;}{\rightleftarrows}~有界\]</span></font></p><h4 id="一致有界和等度连续">一致有界和等度连续</h4><p><strong>一致有界</strong>: 设 <span class="math inline">\(F\subset C(M)\)</span>, 若 <span class="math inline">\(\exists M_1&gt;0\)</span>, s.t. <span class="math inline">\(\vert\varphi(x)\vert\leqslant M~(\forall x\in M,\forall \varphi\in F)\)</span>, 则称 <span class="math inline">\(F\)</span> 一致有界.</p><p><strong>等度连续</strong>: 设 <span class="math inline">\(F\subset C(M)\)</span>, 若对 <span class="math inline">\(\forall \epsilon&gt;0\)</span>, <span class="math inline">\(\exists\delta(\epsilon)&gt;0\)</span>, s.t. <span class="math inline">\(\vert\varphi(x_1)-\varphi(x_2)\vert&lt; \epsilon~(\forall x_1,x_2\in M, \rho(x_1,x_2)&lt;\delta,\forall\varphi\in F)\)</span>, 则称 <span class="math inline">\(F\)</span> 等度连续.</p><p>关于等度连续, 有如下的Arzela-Ascoli定理:</p><blockquote><p><strong>A-A</strong> <span class="math inline">\(F\subset C(M)\)</span> 列紧 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(F\)</span> 一致有界且等度连续.</p></blockquote><h3 id="准范数与frechet空间">准范数与Frechet空间</h3><h4 id="准范数">准范数</h4><p>线性空间 <span class="math inline">\(\mathscr{X}\)</span> 上的<strong>准范数</strong>定义为这个空间上的一个函数 <span class="math inline">\(\Vert\cdot\Vert:\mathscr{X}\to\mathbb{R}^1\)</span>, s.t.</p><ol type="1"><li><span class="math inline">\(\Vert x \Vert\geqslant 0\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>; <span class="math inline">\(\Vert x\Vert=0\Leftrightarrow x=\theta\)</span>;</li><li><span class="math inline">\(\Vert x+y\Vert\leqslant \Vert x\Vert+\Vert y\Vert\)</span>, <span class="math inline">\(\forall x,y\in\mathscr{X}\)</span>;</li><li><span class="math inline">\(\Vert -x\Vert=\Vert x\Vert\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>;</li><li><span class="math inline">\(\lim\limits_{\alpha_n\to 0}\Vert\alpha_n x\Vert=0\)</span>, <span class="math inline">\(\lim\limits_{\Vert x_n\Vert\to 0}\Vert\alpha x_n\Vert=0\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>, <span class="math inline">\(\forall\alpha\in\mathbb{K}\)</span>.</li></ol><h4 id="frechet空间">Frechet空间</h4><p>用准范数 <span class="math inline">\(\Vert x_n-x\Vert\to 0\)</span> 来定义极限 <span class="math inline">\(x_n\to x\)</span> 的线性空间 <span class="math inline">\(\mathscr{X}\)</span>, 称为 <span class="math inline">\(F^&amp;#42;\)</span> 空间. 完备的 <span class="math inline">\(F^&amp;#42;\)</span> 空间称为Frechet空间.</p><h3 id="范数与banach空间">范数与Banach空间</h3><h4 id="范数">范数</h4><p>线性空间 <span class="math inline">\(\mathscr{X}\)</span> 上的<strong>范数</strong> <span class="math inline">\(\Vert\cdot\Vert\)</span> 是一个非负值函数: <span class="math inline">\(\mathscr{X}\to\mathbb{R}^1\)</span>, s.t. 1. <span class="math inline">\(\Vert x\Vert\geqslant 0\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>, 且 <span class="math inline">\(\Vert x\Vert=0\Leftrightarrow x=\theta\)</span>; 2. <span class="math inline">\(\Vert x+y\Vert\leqslant \Vert x \Vert+ \Vert y\Vert\)</span>, <span class="math inline">\(\forall x,y\in\mathscr{X}\)</span>; 3. <span class="math inline">\(\Vert\alpha x\Vert=\vert\alpha\vert\Vert x\Vert\)</span>, <span class="math inline">\(\forall\alpha\in\mathbb{K}\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>.</p><h4 id="banach空间">Banach空间</h4><p>具有范数的 <span class="math inline">\(F^&amp;#42;\)</span> 空间称为 <span class="math inline">\(B^&amp;#42;\)</span> 空间, 完备的 <span class="math inline">\(B^&amp;#42;\)</span> 空间称为Banach空间.</p><h4 id="范数的等价">范数的等价</h4><p>范数 <span class="math inline">\(\Vert\cdot\Vert_1\)</span> 与 <span class="math inline">\(\Vert\cdot\Vert_2\)</span> 等价是指: <span class="math inline">\(\Vert x_n\Vert_1\Leftrightarrow \Vert x_n\Vert_2\)</span>, <span class="math inline">\(n\to\infty\)</span>. 即: <span class="math inline">\(\exists C_1,C_2&amp;#60;0\)</span>, s.t. <span class="math inline">\(C_1\Vert x\Vert_1\leqslant\Vert x\Vert_2\leqslant C_2\Vert x\Vert_1\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>.</p><blockquote><p><strong>定理</strong> 有穷维 <span class="math inline">\(B^&amp;#42;\)</span> 空间的任意范数都等价.</p></blockquote><blockquote><p><strong>推论</strong> 相同维数的有穷维 <span class="math inline">\(B^&amp;#42;\)</span> 空间代数上同构, 拓扑上同胚.</p></blockquote><blockquote><p><strong>推论</strong> 有穷维 <span class="math inline">\(B^&amp;#42;\)</span> 空间必定完备, <font color="red"><strong>反之不成立</strong></font>.</p></blockquote><h4 id="半模">半模</h4><p>半模是 <span class="math inline">\(P:\mathscr{X}\to\mathbb{R}^1\)</span> 是线性空间 <span class="math inline">\(\mathscr{X}\)</span> 上的一个函数, s.t.</p><ol type="1"><li><span class="math inline">\(P(x)\geqslant 0\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>; <strong><font color="red">注意没有要求 <span class="math inline">\(P(x)=0\Leftrightarrow x=\theta\)</span></font></strong>;</li><li><span class="math inline">\(P(x+y)\leqslant P(x)+P(y)\)</span>, <span class="math inline">\(\forall x,y\in\mathscr{X}\)</span>;</li><li><span class="math inline">\(P(\alpha x)=\vert\alpha\vert P(x)\)</span>, <span class="math inline">\(\forall\alpha\in\mathbb{K}\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>.</li></ol><h4 id="有穷维-b42-空间">有穷维 <span class="math inline">\(B^&amp;#42;\)</span> 空间</h4><blockquote><p><strong>定理</strong> <span class="math inline">\(B^&amp;#42;\)</span> 空间是有穷维的当且仅当其单位球面是列紧的.</p></blockquote><blockquote><p><strong>推论</strong> <span class="math inline">\(B^&amp;#42;\)</span> 空间是有穷维的当且仅当其任意有界集是列紧的.</p></blockquote><p>还有如下的Riesz引理:</p><blockquote><p><strong>Riesz 引理</strong> 如果 <span class="math inline">\(\mathscr{X}_0\)</span> 是 <span class="math inline">\(B^&amp;#42;\)</span> 空间 <span class="math inline">\(\mathscr{X}\)</span> 的一个真闭子空间, 那么对于 <span class="math inline">\(\forall 0&lt;\epsilon&lt;1\)</span>, <span class="math inline">\(\exists y\in\mathscr{X}\)</span>, s.t. <span class="math inline">\(\Vert y\Vert=1\)</span>, 且 <span class="math inline">\(\Vert y-x\Vert\geqslant1-\epsilon\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}_0\)</span>.</p></blockquote><h3 id="凸集与minkowski泛函">凸集与Minkowski泛函</h3><h4 id="凸集和凸包">凸集和凸包</h4><p>凸集: <span class="math inline">\(E\)</span> 是凸集 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(\lambda x+(1-\lambda)y\in E\)</span>, <span class="math inline">\(\forall x,y\in E\)</span>, <span class="math inline">\(\forall 0\leqslant\lambda\leqslant 1\)</span>.</p><p>凸包: $co(A)= &amp;#123; _{i=1}<sup>n<em>i x_i <sub></sub> </em>{i=1}</sup>n _i=1, _i0, x_iA, i=1,2,,n, n &amp;#125; $, 为包含 <span class="math inline">\(A\)</span> 的最小凸集.</p><h4 id="minkowski泛函">Minkowski泛函</h4><p><span class="math inline">\(\mathscr{X}\)</span> 是线性空间, <span class="math inline">\(C\)</span> 是 <span class="math inline">\(\mathscr{X}\)</span> 上含有 <span class="math inline">\(\theta\)</span> 的凸子集, 则如下定义Minkowski泛函:</p><p><span class="math display">\[P(x)=\inf \&amp;#123; \lambda&gt;0 ~\vert~ \frac{x}{\lambda}\in C \&amp;#125; ,\quad \forall x\in\mathscr{X}.\]</span></p><h3 id="内积与hilbert空间">内积与Hilbert空间</h3><h4 id="共轭双线性函数">共轭双线性函数</h4><p>线性空间 <span class="math inline">\(\mathscr{X}\)</span> 上的双线性函数是指一个二元函数 <span class="math inline">\(a(\cdot,~\cdot):\mathscr{X}\times\mathscr{X}\to\mathbb{K}\)</span>, s.t.</p><ol type="1"><li><span class="math inline">\(a(a_1x_1+a_2x_2,y)=a_1a(x_1,y)+a_2a(x_2,y)\)</span>;</li><li><span class="math inline">\(a(x,b_1y_1+b_2y_2)=\overline{b_1}a(x,y_1)+\overline{b_2}a(x,y_2)\)</span>.</li></ol><h4 id="内积">内积</h4><p><span class="math inline">\(\mathscr{X}\)</span> 上的共轭双线性函数 <span class="math inline">\((\cdot,~\cdot)\)</span> 称为一个内积, 如果满足:</p><ol type="1"><li><span class="math inline">\((x,y)=\overline{(y,x)}\)</span>;</li><li><span class="math inline">\((x,x)\geqslant 0\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>, 且 <span class="math inline">\((x,x)=0\Leftrightarrow x=\theta\)</span>.</li></ol><ul><li>若去掉 <span class="math inline">\((x,x)=0\Leftrightarrow x=\theta\)</span> 的要求, 则称为<strong>半内积</strong>.</li><li>定义了内积的空间称为内积空间, 完备的内积空间称为<strong>Hilbert</strong>空间.</li></ul><h4 id="cauchy-schwarz-不等式">Cauchy-Schwarz 不等式</h4><blockquote><p><strong>C-S</strong> 设 <span class="math inline">\((\mathscr{X},(\cdot,~\cdot))\)</span> 是内积空间, 取 <span class="math inline">\(\Vert x\Vert=(x,x)^\frac{1}{2}\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>, 则有 <span class="math display">\[\vert (x,y)\vert\leqslant \Vert x\Vert\Vert y\Vert, \quad \forall x,y\in\mathscr{X}.\]</span>等号当且仅当 <span class="math inline">\(x=\lambda y\)</span> 取得.</p></blockquote><h4 id="内积空间与-b42-空间">内积空间与 <span class="math inline">\(B^&amp;#42;\)</span> 空间</h4><ul><li>内积空间 <span class="math inline">\(\to\)</span> <span class="math inline">\(B^&amp;#42;\)</span> 空间</li></ul><blockquote><p>内积空间 <span class="math inline">\(\mathscr{X}\)</span> 按照 <span class="math inline">\(\Vert x\Vert=(x,x)^\frac{1}{2}\)</span> 定义范数, 是<strong>严格凸的 <span class="math inline">\(B^&amp;#42;\)</span> 空间</strong>, 且内积关于范数连续.</p></blockquote><ul><li><span class="math inline">\(B^&amp;#42;\)</span> 空间 <span class="math inline">\(\to\)</span> 内积空间</li></ul><blockquote><p>在 <span class="math inline">\(B^&amp;#42;\)</span> 空间 <span class="math inline">\(\mathscr{X}\)</span> 中, 为了引入内积满足上式, 范数必须满足 <span class="math display">\[\Vert x+y\Vert^2+\Vert x-y\Vert^2=2\Vert x\Vert^2+2\Vert y\Vert^2,\quad \forall x,y\in\mathscr{X}.\]</span></p></blockquote><h4 id="正交集">正交集</h4><ul><li>完备正交集: <span class="math inline">\(S\)</span> 为正交集, 且 $S^= &amp;#123; &amp;#125; $.</li><li>Bessel 不等式</li></ul><blockquote><p><strong>Bessel</strong>设 <span class="math inline">\(\mathscr{X}\)</span> 是一个内积空间, 若 $S= &amp;#123; e_<sub></sub>A &amp;#125; $ 是其中的正交规范基, 那么 <span class="math inline">\(\forall x\in\mathscr{X}\)</span>, 有 <span class="math display">\[\sum\limits_{\alpha\in A}|(x,e_\alpha)|^2\leqslant \Vert x\Vert^2.\]</span> 事实上, $ &amp;#123; A: (x,e_)0 &amp;#125; $ 至多可数.</p></blockquote><ul><li>Parseval 等式</li></ul><blockquote><p><strong>Parseval</strong> 设 <span class="math inline">\(\mathscr{X}\)</span> 是一个Hilbert空间, <span class="math inline">\(S\)</span> 是正交规范基, 则 <span class="math display">\[S完备\Leftrightarrow \Vert x\Vert^2=\sum\limits_{\alpha\in A}|(x,e_\alpha)|^2,\quad \forall x\in\mathscr{X}.\]</span></p></blockquote><ul><li>正交分解</li></ul><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(M\)</span> 是Hilbert空间上的一个闭子空间, 则 <span class="math inline">\(\forall x\in\mathscr{X}\)</span> 存在唯一的正交分解: <span class="math display">\[x=y+z\quad (y\in M, z\in M^\perp).\]</span></p></blockquote><h2 id="线性算子与线性泛函">线性算子与线性泛函</h2><h3 id="riesz定理">Riesz定理</h3><h4 id="riesz定理-1">Riesz定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(f\)</span> 是Hilbert空间 <span class="math inline">\(\mathscr{X}\)</span> 上的一个连续线性泛函, 则存在唯一的 <span class="math inline">\(y_f\in\mathscr{X}\)</span>, s.t. <span class="math inline">\(f(x)=(x,y_f)\)</span>, <span class="math inline">\(\forall x\in\mathscr{X}\)</span>.</p></blockquote><p>该定理直接说明了: <strong><font color="red">若 <span class="math inline">\(\mathscr{X}\)</span> 是Hilbert空间, 则 <span class="math inline">\(\mathscr{X}=\mathscr{X}^&amp;#42;\)</span>.</font></strong></p><h3 id="开映像定理">开映像定理</h3><h4 id="baire纲定理">Baire纲定理</h4><blockquote><p><strong>Baire</strong> 完备度量空间 <span class="math inline">\((\mathscr{X},\rho)\)</span> 是第二纲集.</p></blockquote><h4 id="开映像定理-1">开映像定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\mathscr{X},\mathscr{Y}\)</span> 都是 <span class="math inline">\(B\)</span> 空间, 若 <span class="math inline">\(T\in\mathscr{L}(\mathscr{X},\mathscr{Y})\)</span> 是一个满射, 则 <span class="math inline">\(T\)</span> 是开映射.</p></blockquote><h3 id="闭图像定理">闭图像定理</h3><h4 id="bounded-linear-transform">Bounded Linear Transform</h4><blockquote><p><strong>B.I.T</strong> 设 <span class="math inline">\(T\)</span> 是 <span class="math inline">\(B^&amp;#42;\)</span> 空间 <span class="math inline">\(\mathscr{X}\)</span> 到 <span class="math inline">\(B\)</span> 空间 <span class="math inline">\(\mathscr{Y}\)</span> 的连续线性算子, 那么 <span class="math inline">\(T\)</span> 能唯一地延拓到 <span class="math inline">\(\overline{D(T)}\)</span> 上称为连续线性算子 <span class="math inline">\(T_1\)</span>, s.t. <span class="math inline">\(T_1\vert_{D(T)}=T\)</span>, 且 <span class="math inline">\(\Vert T_1\Vert=\Vert T\Vert\)</span>.</p></blockquote><blockquote><p><strong>命题</strong> <span class="math inline">\(T\)</span> 是闭算子 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(G_T\)</span> 按照图模 (<span class="math inline">\(\Vert x\Vert_G=\Vert x\Vert+\Vert Tx\Vert\)</span>) 是闭集.</p></blockquote><h4 id="范数等价定理">范数等价定理</h4><blockquote><p><strong>定理</strong> 设线性空间 <span class="math inline">\(\mathscr{X}\)</span> 有范数 <span class="math inline">\(\Vert\cdot\Vert_1\)</span> 和 <span class="math inline">\(\Vert\cdot\Vert_2\)</span>. 若 <span class="math inline">\(\mathscr{X}\)</span> 关于二者都构成 <span class="math inline">\(B\)</span> 空间, 且 <span class="math inline">\(\Vert\cdot\Vert_1\)</span> 比 <span class="math inline">\(\Vert\cdot\Vert_2\)</span> 强, 则二者等价.</p></blockquote><h4 id="闭图像定理-1">闭图像定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\mathscr{X},\mathscr{Y}\)</span> 是 <span class="math inline">\(B\)</span> 空间. 若 <span class="math inline">\(T\)</span> 是 <span class="math inline">\(D(T)\to\mathscr{Y}\)</span> 的闭线性算子, 且 <span class="math inline">\(D(T)\)</span> 闭, 则 <span class="math inline">\(T\)</span> 连续.</p></blockquote><h3 id="共鸣定理">共鸣定理</h3><h4 id="共鸣定理-1">共鸣定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\mathscr{X}\)</span> 是 <span class="math inline">\(B\)</span> 空间, <span class="math inline">\(\mathscr{Y}\)</span> 是 <span class="math inline">\(B^&amp;#42;\)</span> 空间, 如果 <span class="math inline">\(W\subset\mathscr{L}(\mathscr{X},\mathscr{Y})\)</span>, s.t. <span class="math inline">\(\sup\limits_{A\in W}\Vert Ax\Vert&lt;\infty~~(\forall x\in\mathscr{X})\)</span>, 那么存在常数 <span class="math inline">\(M\)</span>, s.t. <span class="math inline">\(\Vert A\Vert\leqslant M\)</span>, <span class="math inline">\(\forall A\in W\)</span>.</p></blockquote><p>立刻有如下推论:</p><blockquote><p><strong>推论</strong> 设 <span class="math inline">\(\mathscr{X}\)</span> 是Banach空间, <span class="math inline">\(A\subset\mathscr{X}^&amp;#42;\)</span>, 则 <span class="math inline">\(A\)</span> 有界 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(\forall x\in\mathscr{X}\)</span>, <span class="math inline">\(\sup\limits_{f\in A}\vert f(x)\vert&lt;\infty\)</span>.</p></blockquote><h4 id="banach-steinhaus定理">Banach-Steinhaus定理</h4><blockquote><p><strong>B-S</strong> 设 <span class="math inline">\(\mathscr{X}\)</span> 是 <span class="math inline">\(B\)</span> 空间, <span class="math inline">\(\mathscr{Y}^&amp;#42;\)</span> 是 <span class="math inline">\(B^&amp;#42;\)</span> 空间, <span class="math inline">\(M\)</span> 是 <span class="math inline">\(\mathscr{X}\)</span> 的稠子集. 取 <span class="math inline">\(A_n~(n=1,2,\cdots)\in\mathscr{L}(\mathscr{X},\mathscr{Y})\)</span>, 则 <span class="math inline">\(\lim\limits_{n\to\infty}A_n x=Ax~(\forall x)\)</span> 当且仅当: 1. <span class="math inline">\(\Vert A_n\Vert\)</span> 有界; 2. 对于 <span class="math inline">\(\forall x\in M\)</span>, 有 <span class="math inline">\(\lim\limits_{n\to\infty}A_n x=Ax\)</span>.</p></blockquote><p>该定理实际上说明了算子列的收敛性和有界性很大程度上决定于其在一个稠子集上的情况.</p><h4 id="lax-milgram定理">Lax-Milgram定理</h4><blockquote><p><strong>L-M</strong> 设 <span class="math inline">\(a(x,y)\)</span> 是Hilbert空间 <span class="math inline">\(\mathscr{X}\)</span> 上的一个共轭双线性函数, s.t. 1. <span class="math inline">\(\exists M&gt;0\)</span>, s.t. <span class="math inline">\(\vert a(x,y)\vert\leqslant M\Vert x\Vert\Vert y\Vert~~(\forall x,y\in\mathscr{X})\)</span>; 2. <span class="math inline">\(\exists\delta&gt;0\)</span>, s.t. <span class="math inline">\(\vert a(x,y)\vert\geqslant\delta\Vert x\Vert^2~~(\forall x\in\mathscr{X})\)</span>.</p></blockquote><blockquote><p>则存在唯一的有连续逆的线性算子 <span class="math inline">\(A\in\mathscr{L}(\mathscr{X},\mathscr{Y})\)</span>, s.t. <span class="math inline">\(a(x,y)=(x,Ay)\)</span>, <span class="math inline">\(\forall x,y\in\mathscr{X}\)</span>, 且 <span class="math inline">\(\Vert A^{-1}\Vert\leqslant\frac{1}{\delta^2}\)</span>.</p></blockquote><h3 id="hahn-banach定理">Hahn-Banach定理</h3><h4 id="实hahn-banach定理">实Hahn-Banach定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\mathscr{X}\)</span> 是实线性空间, <span class="math inline">\(p\)</span> 是定义在 <span class="math inline">\(\mathscr{X}\)</span> 上的次线性泛函, <span class="math inline">\(\mathscr{X}_0\)</span> 是 <span class="math inline">\(\mathscr{X}\)</span> 的实线性子空间, <span class="math inline">\(f_0\)</span> 是 <span class="math inline">\(\mathscr{X}_0\)</span> 上的实线性泛函并满足 <span class="math inline">\(f_0(x)\leqslant p(x)~(\forall x\in\mathscr{X}_0)\)</span>. 则 <span class="math inline">\(\mathscr{X}\)</span> 上存在(<strong>未必唯一</strong>)一个实线性泛函 <span class="math inline">\(f\)</span>, s.t. 1. <span class="math inline">\(f(x)\leqslant p(x)~(\forall x\in\mathscr{X})\)</span>; 2. <span class="math inline">\(f(x)=f_0(x)~(\forall x\in\mathscr{X}_0)\)</span>.</p></blockquote><h4 id="复hahn-banach定理">复Hahn-Banach定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\mathscr{X}\)</span> 是复线性空间, <span class="math inline">\(p\)</span> 是定义在 <span class="math inline">\(\mathscr{X}\)</span> 上的半模, <span class="math inline">\(\mathscr{X}_0\)</span> 是 <span class="math inline">\(\mathscr{X}\)</span> 的线性子空间, <span class="math inline">\(f_0\)</span> 是 <span class="math inline">\(\mathscr{X}_0\)</span> 上的线性泛函并满足 <span class="math inline">\(|f_0(x)|\leqslant p(x)~(\forall x\in\mathscr{X}_0)\)</span>. 则 <span class="math inline">\(\mathscr{X}\)</span> 上存在(<strong>未必唯一</strong>)一个线性泛函 <span class="math inline">\(f\)</span>, s.t. 1. <span class="math inline">\(|f(x)|\leqslant p(x)~(\forall x\in\mathscr{X})\)</span>; 2. <span class="math inline">\(f(x)=f_0(x)~(\forall x\in\mathscr{X}_0)\)</span>.</p></blockquote><h4 id="hahn-banach定理-1">Hahn-Banach定理</h4><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\mathscr{X}\)</span> 是 <span class="math inline">\(B^&amp;#42;\)</span> 空间, <span class="math inline">\(\mathscr{X}_0\)</span> 是 <span class="math inline">\(\mathscr{X}\)</span> 的线性子空间, <span class="math inline">\(f_0\)</span> 是定义在 <span class="math inline">\(\mathscr{X}_0\)</span> 上的有界线性泛函, 则在 <span class="math inline">\(\mathscr{X}\)</span> 上存在有界线性泛函 <span class="math inline">\(f\)</span>, s.t. 1. <span class="math inline">\(f(x)=f_0(x)~(\forall x\in\mathscr{X})\)</span> (在 <span class="math inline">\(\mathscr{X}_0\)</span> 不变); 2. <span class="math inline">\(\Vert f\Vert=\Vert f_0\Vert_0\)</span> (保范).</p></blockquote><p>由此可以立刻得到推论</p><blockquote><p><strong>推论 1</strong> 在 <span class="math inline">\(B^&amp;#42;\)</span> 空间 <span class="math inline">\(\mathscr{X}\)</span> 上, <span class="math inline">\(\forall x_1,x_2\in\mathscr{X}\)</span>, <span class="math inline">\(\exists f\in\mathscr{X}^&amp;#42;\)</span>, s.t. <span class="math inline">\(f(x_1)=f(x_2)\)</span>. <strong>推论 2</strong> 设 <span class="math inline">\(\mathscr{X}\)</span> 是 <span class="math inline">\(B^&amp;#42;\)</span> 空间, $x_0&amp;#123; &amp;#125; $, <span class="math inline">\(\exists f\in\mathscr{X}\)</span>, s.t. <span class="math inline">\(f(x_0)=\Vert x_0\Vert\)</span>, 且 <span class="math inline">\(\Vert f\Vert=1\)</span>.</p></blockquote><p>对于 <span class="math inline">\(B^&amp;#42;\)</span> 空间 <span class="math inline">\(\mathscr{X}\)</span> 的子空间 <span class="math inline">\(M\)</span>, 有如下结论:</p><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(\mathscr{X}\)</span> 是 <span class="math inline">\(B^&amp;#42;\)</span> 空间, <span class="math inline">\(M\)</span> 是其线性子空间. 若 <span class="math inline">\(x_0\in\mathscr{X}\)</span>, 且 <span class="math inline">\(d:=\rho(x_0,M)&gt;0\)</span>, 则 <span class="math inline">\(\exists f\in\mathscr{X}^&amp;#42;\)</span>, s.t. 1. <span class="math inline">\(f(x)=0~~(\forall x\in M)\)</span>; 2. <span class="math inline">\(f(x_0)=d\)</span>; 3. <span class="math inline">\(\Vert f\Vert=1\)</span>.</p></blockquote><h4 id="hahn-banach定理的几何形式">Hahn-Banach定理的几何形式</h4><p>考虑 <span class="math inline">\(B^&amp;#42;\)</span> 空间 <span class="math inline">\(\mathscr{X}\)</span> 中的一个包含 <span class="math inline">\(\theta\)</span> 的真凸子集 <span class="math inline">\(E\)</span> 及 <span class="math inline">\(E\)</span> 外的一点 <span class="math inline">\(x_0\)</span>, 考虑 <span class="math inline">\(E\)</span> 的Minkowski泛函 <span class="math inline">\(p(x)\)</span>, 则 <span class="math inline">\(p\)</span> 是 <span class="math inline">\(\mathscr{X}\)</span> 上的非零连续次线性泛函.</p><p><strong>此时考虑Hahn-Banach定理的应用条件</strong>, 取子空间 $_0= &amp;#123; x_0<sub></sub>^1 &amp;#125; $ 及其上的线性泛函 <span class="math inline">\(f_0(\lambda x_0)=\lambda p(x_0)\)</span>. 则有 <span class="math inline">\(f_0(x)\leqslant p(x)\)</span>.</p><p><strong>至此, Hahn-Banach定理的条件已经全部满足</strong>. 于是存在实线性泛函 <span class="math inline">\(f\)</span>, s.t. <span class="math inline">\(f(x)\leqslant p(x)~(\forall x\in\mathscr{X})\)</span>, 且 <span class="math inline">\(f(x)=f_0(x)~(\forall x\in\mathscr{X}_0)\)</span>. 又由 <span class="math inline">\(f_0\)</span> 定义可知 <span class="math inline">\(f(x_0)\geqslant 0\)</span>, 以及 <span class="math inline">\(f(x)\leqslant 1~(\forall x\in E)\)</span>, 故 <strong><span class="math inline">\(H_f^1\)</span> 分离 <span class="math inline">\(x_0\)</span> 与 <span class="math inline">\(E\)</span></strong>.</p><p>即如下的几何形式的Hahn-Banach定理:</p><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(E\)</span> 是实 <span class="math inline">\(B^&amp;#42;\)</span> 空间 <span class="math inline">\(\mathscr{X}\)</span> 上以 <span class="math inline">\(\theta\)</span> 为内点的真凸子集, 又设 <span class="math inline">\(x_0\overline{\in}E\)</span>, 则必定存在一个超平面 <span class="math inline">\(H_f^r\)</span> 分离 <span class="math inline">\(x_0\)</span> 与 <span class="math inline">\(E\)</span>.</p></blockquote><p>由此可得到如下定理:</p><blockquote><p><strong>定理</strong> 设 <span class="math inline">\(E_1\)</span> 和 <span class="math inline">\(E_2\)</span> 是 <span class="math inline">\(B^&amp;#42;\)</span> 空间中互不相交的非空凸集, 且 <span class="math inline">\(E_1\)</span> 有内点, 那么 <span class="math inline">\(\exists s\in\mathbb{R}^1\)</span> 以及非零线性连续泛函 <span class="math inline">\(f\)</span>, s.t. 超平面 <span class="math inline">\(H_f^s\)</span> 分离 <span class="math inline">\(E_1\)</span> 和 <span class="math inline">\(E_2\)</span>. 换言之, 存在非零连续线性泛函 <span class="math inline">\(f\)</span>, s.t. <span class="math inline">\(f(x)\leqslant s~(\forall x\in E_1)\)</span> 且 <span class="math inline">\(f(x)\geqslant s~(\forall x\in E_2)\)</span>.</p></blockquote><p>进而有如下两条定理:</p><ul><li>Ascoli定理</li></ul><blockquote><p><strong>Ascoli</strong> 设 <span class="math inline">\(E\)</span> 是实 <span class="math inline">\(B^&amp;#42;\)</span> 空间 <span class="math inline">\(\mathscr{X}\)</span> 中的闭凸集, 则 <span class="math inline">\(\forall x_0\in\mathscr{X}\backslash E\)</span>, <span class="math inline">\(\exists f\in\mathscr{X}^&amp;#42;\)</span> 及 <span class="math inline">\(a\in\mathbb{R}^1\)</span>, s.t. <span class="math inline">\(f(x)&lt;a&lt;f(x_0)\)</span>, <span class="math inline">\(\forall x\in E\)</span>.</p></blockquote><ul><li>Mazur定理</li></ul><blockquote><p><strong>Mazur</strong> 设 <span class="math inline">\(E\)</span> 是 <span class="math inline">\(B^&amp;#42;\)</span> 空间 <span class="math inline">\(\mathscr{X}\)</span> 上的一个有内点的闭凸集, <span class="math inline">\(F\)</span> 是 <span class="math inline">\(\mathscr{X}\)</span> 上的一个线性流形, 又设 <span class="math inline">\(E\cap F=\varnothing\)</span>, 则存在一个包含 <span class="math inline">\(F\)</span> 的闭超平面 <span class="math inline">\(L\)</span>, s.t. <span class="math inline">\(E\)</span> 在 <span class="math inline">\(L\)</span> 的一侧.</p></blockquote><h3 id="共轭空间">共轭空间</h3><ul><li>设 <span class="math inline">\(\mathscr{X}\)</span> 是一个 <span class="math inline">\(B^&amp;#42;\)</span> 空间, <span class="math inline">\(\mathscr{X}\)</span> 上的所有连续限行泛函全体 <span class="math inline">\(\mathscr{X}^&amp;#42;\)</span> 按照范数 <span class="math inline">\(\Vert f\Vert=\sup\limits_{\Vert x\Vert=1} \vert f(x)\vert\)</span> 构成一个 <span class="math inline">\(B\)</span> 空间, 称为 <span class="math inline">\(\mathscr{X}\)</span> 的共轭空间.</li></ul><blockquote><p><strong>定理</strong> 有 <span class="math inline">\((L^p[0,1])^&amp;#42;=L^q[0,1]\)</span>, <span class="math inline">\(\frac{1}{p}+\frac{1}{q}=1~(1\leqslant p&lt;\infty)\)</span>.</p></blockquote><p><font color="red"><strong>值得注意的是, <span class="math inline">\((L^\infty[0,1])^&amp;#42;\neq L^1[0,1]\)</span></strong>.</font></p><h4 id="第二共轭空间与自反空间">第二共轭空间与自反空间</h4><p><span class="math inline">\(\mathscr{X}^&amp;#42;\)</span> 的共轭空间 <span class="math inline">\(\mathscr{X}^{&amp;#42;&amp;#42;}\)</span> 称为 <span class="math inline">\(\mathscr{X}\)</span> 的第二共轭空间.</p><p><strong>自然映射</strong>: 对于 <span class="math inline">\(\forall x\in\mathscr{X}\)</span>, 考虑 <span class="math inline">\(X(f)=f(x)~(\forall f\in\mathscr{X}^&amp;#42;)\)</span>, 则 <span class="math inline">\(X\)</span> 是 <span class="math inline">\(\mathscr{X}^&amp;#42;\)</span> 上的线性泛函, 且满足 <span class="math inline">\(\vert X(f)\vert\leqslant \Vert f\Vert\Vert x\Vert\)</span>. 因此 <span class="math inline">\(X\)</span> 是连续的, 满足 <span class="math inline">\(\Vert X\Vert \leqslant \Vert x\Vert\)</span>.</p><p>称上文中的映射 <span class="math inline">\(T:x\mapsto X\)</span> 为<strong>自然映射</strong>. 容易验证 <span class="math inline">\(T\)</span> 是一个等距嵌入, 于是有如下定理</p><blockquote><p><strong>定理</strong> <span class="math inline">\(B^&amp;#42;\)</span> 空间 <span class="math inline">\(\mathscr{X}\)</span> 与它的第二共轭空间 <span class="math inline">\(\mathscr{X}^{&amp;#42;&amp;#42;}\)</span> 的一个子空间等距同构, 即 <span class="math inline">\(\mathscr{X}\subset\mathscr{X}^{&amp;#42;&amp;#42;}\)</span>.</p></blockquote><p><strong>自反空间</strong>: 若自然映射 <span class="math inline">\(T\)</span> 是满射, 则称 <span class="math inline">\(\mathscr{X}\)</span> 是自反的. 即 <span class="math inline">\(\mathscr{X}=\mathscr{X}^{&amp;#42;&amp;#42;}\)</span></p><p>关于自反空间, 有如下定理:</p><blockquote><p><strong>定理</strong> 有限维 <span class="math inline">\(B^&amp;#42;\)</span> 空间是自反的. 特别地, <span class="math inline">\(L^p~(1&amp;#60;p&amp;#60;\infty)\)</span> 是自反的.</p></blockquote><h4 id="弱收敛">弱收敛</h4><p><strong>弱收敛</strong>: 设 <span class="math inline">\(\mathscr{X}\)</span> 是一个 <span class="math inline">\(B^&amp;#42;\)</span> 空间, $ &amp;#123; x_n &amp;#125; $, <span class="math inline">\(x\in\mathscr{X}\)</span>. 若对于 <span class="math inline">\(\forall f\in\mathscr{X}^&amp;#42;\)</span>, 均有 <span class="math inline">\(\lim\limits_{n\to\infty}f(x_n)=f(x)\)</span>, 则称 $ &amp;#123; x_n &amp;#125; $ 弱收敛于 <span class="math inline">\(x\)</span>, 记作 <span class="math inline">\(x_n\rightharpoonup x\)</span>.</p><p>容易得到弱收敛和强收敛有如下关系:</p><ul><li>强收敛蕴含弱收敛, 反之不成立(尽管对于 <span class="math inline">\(\mathbb{R}\)</span> 成立);</li><li>当强极限存在时, 强弱收敛等价, 且极限唯一;</li><li>弱极限若存在必定唯一(利用Hahn-Banach定理可证).</li></ul><p>简单概括如下:</p><p><font color="red"><span class="math display">\[强收敛 \underset{在 \mathbb{R} 上}{\rightleftarrows}~弱收敛\quad\quad 强极限\underset{强极限存在}{\rightleftarrows}~弱极限\]</span></font></p><p>在 <span class="math inline">\(B^&amp;#42;\)</span> 空间上, 有如下的Mazur定理:</p><blockquote><p><strong>Mazur</strong> 设 <span class="math inline">\(\mathscr{X}\)</span> 是一个 <span class="math inline">\(B^&amp;#42;\)</span> 空间, 且 <span class="math inline">\(x_n\rightharpoonup x_0\)</span>(注意是弱收敛), 则 <span class="math inline">\(\forall\epsilon&gt;0\)</span>, <span class="math inline">\(\exists \lambda_i&gt;0~(i=1,2,\cdots,n)\)</span>, <span class="math inline">\(\sum\limits_{i=1}^n\lambda_i=1\)</span> s.t. <span class="math display">\[\Vert x_0-\sum\limits_{i=1}^n\lambda_i x_i\Vert\leqslant \epsilon.\]</span></p></blockquote><h4 id="弱收敛-1"><span class="math inline">\(*\)</span> 弱收敛</h4><p><strong><span class="math inline">\(&amp;#42;\)</span> 弱收敛</strong>: 设 <span class="math inline">\(\mathscr{X}\)</span> 是 <span class="math inline">\(B^&amp;#42;\)</span> 空间, $ &amp;#123; f_n &amp;#125; ^*$, <span class="math inline">\(f\in\mathscr{X}^&amp;#42;\)</span>. 若 <span class="math inline">\(\forall x\in\mathscr{X}\)</span>, 都有 <span class="math inline">\(\lim\limits_{n\to\infty}f_n(x)=f(x)\)</span>, 则称 <span class="math inline">\(f_n~&amp;#42;\)</span> 弱收敛于 <span class="math inline">\(f\)</span>, 记作 <span class="math inline">\(w^&amp;#42;-\lim\limits_{n\to\infty}f_n=f\)</span>.</p><p><strong><span class="math inline">\(\mathscr{X}^&amp;#42;\)</span> 上的弱收敛</strong>: 设 $ &amp;#123; f_n &amp;#125; ^*$, <span class="math inline">\(f\in\mathscr{X}^&amp;#42;\)</span>. 若对 <span class="math inline">\(\forall X\in\mathscr{X}^{&amp;#42;&amp;#42;}\)</span>, 都有 <span class="math inline">\(X(f_n)\to X(f)\)</span>, 则称 <span class="math inline">\(f_n\)</span> 弱收敛于 <span class="math inline">\(f\)</span>.</p><p><strong>可以证明, <span class="math inline">\(\mathscr{X}^&amp;#42;\)</span> 上的弱收敛 <span class="math inline">\(\Rightarrow~&amp;#42;\)</span> 弱收敛.</strong> 特别地, 当 <span class="math inline">\(\mathscr{X}\)</span> 是一个自反空间时, 二者等价.</p><h4 id="弱列紧与-42-弱列紧性">弱列紧与 <span class="math inline">\(&amp;#42;\)</span> 弱列紧性</h4><p>对于 <span class="math inline">\(&amp;#42;\)</span> 弱列紧性, 有如下的定理:</p><blockquote><p><strong>定理</strong>: 可分的 <span class="math inline">\(B^&amp;#42;\)</span> 空间中的有界列必定有 <span class="math inline">\(&amp;#42;\)</span> 弱列紧的子列.</p></blockquote><p>进一步还有如下的定理:</p><ul><li>Banach定理:</li></ul><blockquote><p><strong>Banach</strong> 若 <span class="math inline">\(\mathscr{X}\)</span> 是 <span class="math inline">\(B^&amp;#42;\)</span> 空间, 则 <span class="math inline">\(\mathscr{X}\)</span> 可分 <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(\mathscr{X}^&amp;#42;\)</span> 可分.</p></blockquote><ul><li>Pettis定理:</li></ul><blockquote><p><strong>Pettis</strong> 自反空间 <span class="math inline">\(\mathscr{X}\)</span> 的自反空间 <span class="math inline">\(\mathscr{X}_0\)</span> 也是自反的.</p></blockquote><h2 id="附录">附录</h2><h3 id="几种范数">几种范数</h3><p><strong>范数</strong>: 正定性(<span class="math inline">\(\Vert x\Vert=0\Leftrightarrow x=\theta\)</span>)+三角不等式+齐次性.</p><ul><li>准范数: 与范数差齐次性;</li><li>半范数: 与范数差 <span class="math inline">\(\Vert x\Vert=0\Leftrightarrow x=\theta\)</span>.</li></ul><h3 id="几种收敛">几种收敛</h3><h4 id="mathscrx-的收敛"><span class="math inline">\(\mathscr{X}\)</span> 的收敛</h4><center><font color="red"><strong>强收敛 <span class="math inline">\(\Rightarrow\)</span> 弱收敛</strong></font></center><ul><li><strong>弱收敛</strong>: <span class="math inline">\(\forall f\in\mathscr{X}^&amp;#42;\)</span>, <span class="math inline">\(f(x_n)\to f(x)\)</span>, 记作 <span class="math inline">\(x_n\rightharpoonup x\)</span>;</li><li><strong>强收敛</strong>: <span class="math inline">\(\Vert x_n-x\Vert\to 0\)</span>, 记作 <span class="math inline">\(x_n\to x\)</span>.</li></ul><h4 id="mathscrx42-的收敛"><span class="math inline">\(\mathscr{X}^&amp;#42;\)</span> 的收敛</h4><center><font color="red"><strong>一致收敛 <span class="math inline">\(\Rightarrow\)</span> 强收敛 <span class="math inline">\(\Rightarrow\)</span> 弱收敛 <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(&amp;#42;\)</span> 弱收敛</strong></font></center><ul><li><strong>一致收敛</strong>: <span class="math inline">\(\Vert f_n-f\Vert\to 0\)</span>, 记作 <span class="math inline">\(f_n\rightrightarrows f\)</span>;</li><li><strong>强收敛</strong>: <span class="math inline">\(\Vert (f_n-f)x\Vert\to 0~(\forall x\in\mathscr{X})\)</span>, 记作 <span class="math inline">\(f_n\to f\)</span>;</li><li><strong>弱收敛</strong>: <span class="math inline">\(X(f_n)\to X(f)~(\forall X\in\mathscr{X}^{&amp;#42;&amp;#42;})\)</span>, 记作 <span class="math inline">\(f_n\rightharpoonup f\)</span>;</li><li><strong><span class="math inline">\(&amp;#42;\)</span>弱收敛</strong>: <span class="math inline">\(\forall x\in\mathscr{X}\)</span>, 有 <span class="math inline">\(f_n(x)\to f(x)\)</span>, 记作 <span class="math inline">\(w^&amp;#42;-\lim\limits_{n\to\infty}f_n=f\)</span>;</li><li><strong>以上极限若存在必唯一</strong>.</li></ul><h3 id="几种banach空间">几种Banach空间</h3><ol type="1"><li><span class="math inline">\(\mathbb{C}^n\)</span> 按照范数 <span class="math inline">\(\Vert x\Vert=(\sum\limits_{i=1}^n\vert x_i\vert^2)^{\frac{1}{2}}\)</span> 构成一个Banach空间;</li><li><span class="math inline">\(C(M)\)</span> (<span class="math inline">\(M\)</span> 是一个紧度量空间) 按照范数 <span class="math inline">\(\Vert f\Vert=\max\limits_{x\in M}\vert f(x)\vert\)</span> 构成一个Banach空间;</li><li><span class="math inline">\(L^p(\Omega,\mu)\)</span> 按照范数 <span class="math inline">\(\Vert f\Vert=\left(\int\nolimits_\Omega \vert f(x)\vert^p{\rm d}x\right)^{\frac{1}{p}}\)</span> 构成Banach空间.</li></ol>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 泛函分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2017年概率测度小测二题目</title>
      <link href="/2017/12/20/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62017%E5%B9%B4%E6%A6%82%E7%8E%87%E6%B5%8B%E5%BA%A6%E5%B0%8F%E6%B5%8B%E4%BA%8C%E9%A2%98%E7%9B%AE/"/>
      <content type="html"><![CDATA[<h2 id="题目">题目</h2><h3 id="判断题">判断题</h3><p>正确须证明, 错误须举反例, 没有理由不得分.</p><ol type="1"><li>给定概率空间 <span class="math inline">\((\Omega, \mathcal{F}, P)\)</span>, 如果对于 <span class="math inline">\(\forall A\in\mathcal{F}\)</span>, 有 <span class="math inline">\(P(A)=0 或 1\)</span>, 则:<ol type="1"><li>$= &amp;#123; ,&amp;#125; $;</li><li>对于任意随机变量 <span class="math inline">\(X\in\mathcal{F}\)</span>, 有 <span class="math inline">\(X=C\)</span>, P-a.s..</li></ol></li><li>给定测度空间 <span class="math inline">\((\Omega, \mathcal{F}, \mu)\)</span>, <span class="math inline">\(f\in\mathcal{F}\)</span>. 若 <span class="math inline">\(\mu\)</span> 是 <span class="math inline">\(\sigma\)</span>-有限的, 则 <span class="math inline">\(\mu_f\)</span> 也是 <span class="math inline">\(\sigma\)</span>-有限的.</li></ol><h3 id="计算证明">计算&amp;证明</h3><ol type="1"><li><p>设 <span class="math inline">\(X_1\)</span>, <span class="math inline">\(X_2\)</span> 是独立随机变量, <span class="math inline">\(X_1\sim U[0,1]\)</span>, <span class="math inline">\(X_2\sim B(n,p)\)</span>. 试证 <span class="math inline">\(Y=X_1+X_2\)</span> 是连续型随机变量并求其密度函数.</p></li><li><p>给定测度空间 <span class="math inline">\((\Omega, \mathcal{F}, \mu)\)</span>, <span class="math inline">\(f_n\in\mathcal{F}\)</span> 可积, <span class="math inline">\(\sup\limits_n \int f_n{\rm d}\mu&lt;\infty\)</span>, 且 <span class="math inline">\(f_n\uparrow f\)</span>. 试证: <span class="math inline">\(f\)</span> 可积, 且 <span class="math inline">\(\int f_n{\rm d}\mu\to\int f{\rm d}\mu\)</span>.</p></li></ol><h2 id="简略解答">简略解答</h2><h3 id="判断题-1">判断题</h3><ol type="1"><li><ol type="1"><li>错误, (2) 正确:</li><li>错误. 取 <span class="math inline">\(A\subset\Omega\)</span>, $= &amp;#123; , A, A^c, &amp;#125; $, <span class="math inline">\(\mu( \varnothing)=\mu(A^c)=0\)</span>, <span class="math inline">\(\mu(A)=\mu(\Omega)=1\)</span>, 容易验证是一个反例.</li><li>正确. 注意正测度集存在性的证明.</li></ol></li><li>错误. 考虑 <span class="math inline">\(\mathbb{R}\)</span> 上的Lebesgue测度, $f:&amp;#123; 1 &amp;#125; $, <span class="math inline">\(x\mapsto 1\)</span>. 则 <span class="math inline">\(\mu_f\)</span> 不是 <span class="math inline">\(\sigma\)</span>-有限.</li></ol><h3 id="计算证明-1">计算&amp;证明</h3><ol type="1"><li><p>课后习题.</p></li><li><p><span class="math inline">\(f_1\)</span> 可积, <span class="math inline">\(f_1\leqslant f_n\uparrow f\)</span>, 由单调收敛定理可得结论.</p></li></ol>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 各种试卷 </tag>
            
            <tag> 测度论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>明月杯回忆录</title>
      <link href="/2017/12/05/%E6%98%8E%E6%9C%88%E6%9D%AF%E5%9B%9E%E5%BF%86%E5%BD%95/"/>
      <content type="html"><![CDATA[<h1 id="x00.-2014">0x00. 2014</h1><h2 id="明月杯流水账">明月杯流水账</h2><p>还记得和兄弟们第一次一起打球是军训刚回学校时。那时师大的篮球场还在装修，于是只好跑到北邮的球场。那时北邮还没有门禁，球场的人也不多，正是军训回来放松的好地方。从那以后，虽然经常与同学们一起打球，但<strong>因为抱有转专业的想法，所以没有直接加入篮球队</strong>，<del>不过后来还是被博哥拉进了球队Orz</del>。</p><p>第一次和球队的兄弟们打友谊赛也是在北邮，也是我第一次听说“二三联防”。哇，打篮球竟然还有这么多说法，原来我们之前都是瞎攻瞎防，野球玩家瑟瑟发抖Orz。这次友谊赛就像是给什么也不懂的我开启了新世界的大门，在随后的训练中也了解了许多在野球场上从未有过的战术。</p><p>明月杯如期而至，但<strong>作为菜鸟的我并未入选球队大名单</strong>。值得一提的是，大名单中仅有的两名菜鸟球员分别是擅长突破，转身华丽的明星小前侯彦丞和高中就了解联防的战术专家周月林，加上高年级的明星球员李奕、张博和欧正鑫，信科球队一路高歌猛进，取得小组出线资格进入八强。之后信科在八强碰到了老对手数科，侯彦丞一记绝杀帮助李奕师兄打破了连续三年败给数科的魔咒，同时也宣告了数科时代的结束。</p><p><strong>四强比赛前，由于苏禾师兄有事回家，队长与校会沟通后将我放进了比赛名单中。</strong>我正是在这场球中收获了明月杯的第一分，一个抢到前场篮板后的二次投篮（听说你们内线很能跳）。地遥很强，尽管我们已经全力以赴，但还是难以抵挡地遥的外线双枪，最终大比分输掉比赛，无缘邱季端。</p><p>三四名决赛的对手化学拥有实力强劲的新人王全，还在淘汰赛中战胜了在小组赛中战胜信科的环境，但信科的实力到底还是更胜一筹，经过加时赛的苦战，<strong>信科最终取得比赛胜利，拿下季军。</strong></p><p>关于14年的图片资料大多没有保存下来。。。惨。</p><h2 id="几句废话">几句废话</h2><p>客观地说，<strong>信科2014级可以称得上是信科的黄金一代。</strong>大局观良好+身体强壮的控卫王唯，投篮稳健+弹跳劲爆的射手贾鑫，得分能力出众+突破犀利的锋线大杀器侯彦丞，内线脚步扎实+拼抢积极的强力大前王伟程，虽然技术不大行但是弹跳还可以抢救一下的中锋李喆琛（嗯就是我），这样的阵容足以令每个学院的球队羡慕。加上凶狠敢拼的周月林和球风飘逸的席伟，信科14级正在迎来他们的时代。</p><p>大一的事情总是很难忘。唯神在北邮摔伤膝盖，自己与小小俊打球时摔伤，训练时啦啦队送来冒着热气的早饭……这些场景我至今都清晰地记得。还有总被我称作“高手”的干哥，大个子老乡哲哥，还有喜欢扣篮的涛son……谢谢你们的陪伴和支持( ‘▿’ )。</p><h1 id="x01.-2015">0x01. 2015</h1><h2 id="明月杯流水账-1">明月杯流水账</h2><h3 id="概况">概况</h3><p>第二年明月杯，仍然是熟悉的赛场，但信科男篮的队伍也在悄悄发生着改变：李奕师兄的毕业使得信科内线少了一个强大的进攻点；而2015级新生的到来使得我们收获了灵活的内线球员唐聪以及技术精湛的外线球员王梓晗。<strong>此时我已经转入数学科学学院学习，但由于各种因素的影响，我最终还是选择在信科球队打球。</strong></p><p><strong>这是信科创造历史最佳战绩的一年，信科在欧哥和博哥两位大哥的带领下杀入了邱季端，这也是信科首次进入邱季端。</strong></p><h3 id="小组赛">小组赛</h3><p><strong>小组赛除了惜败给哲社外没有太大的波折。</strong></p><p>首场面对心理学院（现为心理学部），对方显然难以应付欧哥和侯彦丞的疯狂进攻，两人最后分别拿下了13分和8分的数据，信科也以29:9胜出。</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-xinli3.jpg" alt="小组赛对阵心理：赛前"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-xinli1.jpg" alt="小组赛对阵心理：防守（唐聪&amp;欧哥）"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-xinli2.jpg" alt="小组赛对阵心理：暂停（教练赵晓睿）"></center><p>信科遭遇的第一场失利是小组赛面对拥有mvp陈宏礼的哲社球队。由于中锋郑培凯因身体原因无法，故球队在比赛前一天晚上开了很久的会讨论如何防守陈宏礼（Orz），最后决定由我和侯彦丞采用夹击的战术来应对陈的突破。事实证明我们的策略确实生效了，陈宏礼全场仅得到9分（陈宏礼明月杯目前为止场均得分为19.8）。但我们似乎<strong>太过重视陈宏礼，导致对于其他人的防守不够严密，得分机会过多。</strong>其中，对方球员付天睿拿下了全场最高分24分，在最后几分钟的关键争夺中更是命中关键投篮，杀死比赛。最终信科以44:48失利，同时也宣告哲社预定小组第一。值得一提的是，张博和欧正鑫分别成为了信科本场的得分王（14分）和篮板王（12板），侯彦丞本场发挥不佳，24次出手仅命中2球，效率也为全队最低的-16（笑尿）。我虽然在本场中拿到了8分10板和全队最高的效率值14，但仍然存在一些问题，集中体现在不适应中锋站位，补防速度慢。赛后分析中，化院的沈芸稼师兄明确指出：“最后一球肯定是中锋的锅”，在观看录像后，也确实能够看出是我补防不及时，导致了最后时刻付天睿的进球，直接导致了比赛的失利。在比赛的最后时刻，前队长张博在一次进攻扭伤了脚踝，比赛激烈可见一斑。<strong>尽管失利总是令人失望的事，但这场失利对于我们而言并不是坏消息，甚至是将我们送进邱季端的一大助力。</strong></p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-zheshe1.jpg" alt="小组赛对阵哲社：暂停指导"></center><p>球队在后续的小组赛中并没有遇到任何阻力，凯哥火力全开拿下全场最高11分，带领球队47:19轻松击败天文，顺利晋级八强。</p><h3 id="八强">八强</h3><p>八强赛面对教育，对方的主力李尧沣面对信科的铁血防守难以延续小组赛的好状态，多次强打我方大前1号（没错就是我哈哈哈）未果，甚至吃到火锅，最终16投仅有3中，教育也只能吞下失利的苦果。而隔壁的八强赛，经管由于自己的轻敌，败给了艺传，将艺传送上了四强席位。至于另一半区，经过八进四的筛选，哲社与地遥在四强相遇。</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-jiaoyu1.jpg" alt="八强对阵教育：抢板"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-jiaoyu3.jpg" alt="八强对阵教育：暂停"></center><h3 id="四强">四强</h3><p>四强赛中，艺传阵中战胜经管的最大功臣利啓权本场面对信科完全哑火，实力更高一筹的信科以23:11顺利拿下比赛，欧哥更是拿下11分7抢断的数据，统治攻防两端，成功带队进入邱季端。另一边的哲社……就比较惨了，被拥有双枪的朱帕尔（砍下18分7板）和陈星源（砍下13分6助）的地遥成功阻击。信科与地遥会师决赛。</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-yichuan1.jpg" alt="四强对阵艺传：突破"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-yichuan2.jpg" alt="四强对阵艺传：对抗"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-yichuan3.jpg" alt="四强对阵艺传：观众"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-yichuan4.jpg" alt="四强对阵艺传：合影"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-siqiang.jpeg" alt="四强对阵艺传：庆祝"></center><h3 id="决赛">决赛</h3><p>赛前第一次体会了进邱季端的豪华服务：各种拍宣传照，（弱渣瑟瑟发抖Orz），队员们也对决赛充满信心。</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-xinke.JPG" alt="决赛宣传照：信科"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-xiaohui.jpg" alt="决赛宣传照：校会"></center><p>然而，校会宣布比赛日期时所有人都沉默了——<strong>比赛日期恰好与ACM EC-Final冲突。</strong>尽管与校会方面做了沟通，但日期仍然确定在了这一天，经过一番调整，最终的结果是<strong>首发中锋郑培凯无法参赛</strong>，同时我也没能去参加EC-Final。</p><p>比赛当天，又突发变故。首发大前（我Orz）在下午发烧。以缺少主力的阵容面对卫冕冠军地遥球队，信科球队并没有放弃，并在上半场一直保持领先。但在下半场快节奏的攻防转换中没有顶住对方的反扑，最后时刻的追分又有些慌乱，最终37:41不敌地遥。</p><p>本场比赛对我而言意义非凡。第一次在发烧的情况下打比赛，直到上场时仍然手掌冰凉，甚至手指在碰球时会感到轻微的疼痛。这也直接导致了在开场跳球时弹速不够快甚至没有跳过对方的李震（从图上看来高度是足够的，但因弹速不够，所以触球晚……md 生涯耻辱）。</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-js4.jpg" alt="邱季端vs地遥：跳球"></center><p>虽然我没有跳赢，但我方后卫积极拼抢，拿到了第一攻的球权。虽然对方外线球员实力强悍，但内线非常羸弱，这使得我们可以通过冲抢前场篮板来获取更多进攻机会。经过侯彦丞、王伟程的一轮刷板-打铁，我抢到了前场篮板，随后投中了本场第一粒进球。说到这里我就不得不吹一波……这粒进球的难度还是很高的，从下图可以看出，我在投篮时上半身是正对篮筐，而仔细看脚和裤腿的遮挡关系就可以发现，下半身的方向其实和上半身是反着的（是不是做一个商空间就可以得到一条mobius band哈哈哈）。</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-js1.jpg" alt="邱季端vs地遥：本场第一个进球"></center><p>前两节的大部分时间信科都保持了领先，对方的明星球员朱帕尔在高压防守之下表现不佳，屡次出手不中。信科则依靠强大的内线频频冲抢进攻篮板（尽管主力中锋缺席，但在信科弹跳比较好的中锋以及身高较高的外线面前，地遥羸弱的内线仍然难以阻挡）。经过两节的战斗，信科以16：14领先进入下半场。</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-js2.jpg" alt="邱季端vs地遥：侯彦丞罚球"></center><p>到了下半场，地遥内线薄弱造成的犯规压力渐渐显露了出来，包括绝对核心陈星源在内的多名主力球员都背上了3次甚至4次的犯规，但由于命中率等各种原因，双方的比分并没有拉开，甚至地遥在陈星源命中三分之后成功以21:18取得了领先，并继续将比分优势扩大到4分。此时信科球员出现了体力问题，于是将替补球员卢浩然换上了场。<del>随后比赛就进入了转折<code>_(:з」∠)_</code></del> 也许是连续几波运动战没有得分，比分的差距被拉大，使得信科的球员比较着急：核心欧正鑫的出手有些仓促，卢浩然也在短时间内连续出现3次犯规，于是分差被进一步拉大，达到7分。最终信科以14:31落后进入第四节。（附一张拔萝卜式抢板的照片，可看出地遥羸弱的内线）</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-jslb.jpg" alt="邱季端vs地遥：拔萝卜"></center><p>进入第四节，由于地遥的主力朱帕尔因犯规过多被教练换下，因而攻防能力有所下降。刚开场侯彦丞就迅速造成犯规并两罚一中，对方中锋李震拿到后场篮板后立刻被我抢断，经过一轮刷板后我命中本场第二球，将比分追至27:31。但良好的追分态势并没有持续太久。仅仅两分钟后，王伟程就在一次抢球中被吹犯规，并因满犯被罚下。信科并没有立刻因为主力的罚下而受到影响：侯彦丞造成李震犯规，使得其五犯下场。随后在地遥发起的一次快攻中，我直接将陈星源的上篮大帽扇飞（下图中的血帽陈星源，看着很刺激）并继续拿下一次抢断，接着信科在欧哥和贾鑫接连得分后，将比分扳至32:33。接下来又是几分钟的拉锯战，期间裁判将我对陈星源的一个盖帽吹为了犯规（我认为是好帽，不过也不能仅因此过多抱怨裁判），欧哥也因所剩时间不多，心态产生了波动，数次运动战都在我还没有落位时就仓促出手打铁，浪费了较多机会。比赛时间所剩无几，信科以37:39落后，此时对方球员陈小强命中了一粒两分球，形式也因此十分危急。在最后时刻的争夺中，可能是由于体力原因，数次出手机会均没有命中，侯彦丞由于抽筋，罚球也未能命中。最终信科以37:41不敌地遥，无缘冠军。</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-jsgm.jpg" alt="邱季端vs地遥：血帽陈星源"></center><p>对方球员陈星源全场得到28分，展现了其强大的进攻能力，身背4次犯规仍能一直打到最后时刻也体现了对犯规的良好控制，尤其是令我印象颇为深刻的一次切球，在欧哥上篮时干净利落地将欧哥的球切掉，成功阻挡了信科的反扑，这种冷静确实是我们中的许多人所缺乏的。赛后的聚餐我由于身体原因没有参加，不知道博哥是不是又喝哭了哈哈哈。（附一张赛后合影）</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2015myb-js3.jpeg" alt="邱季端vs地遥：赛后合影"></center><h2 id="几句废话-1">几句废话</h2><h3 id="谈数科一">谈数科（一）</h3><p>没有选择加入数科球队的原因是很复杂的，其中比较主要的是两条：</p><ol type="1"><li>和数科球队的同学，师兄都不太熟悉，但和信科这边的人已经非常熟悉；</li><li>在与数科的友谊赛中对于数科12级某师兄非常厌恶。</li></ol><p>当然其中也有信科极力挽留并且信科球队实力很强，有机会冲击更好成绩等很多因素。总之这件事情并不是巧合，现在想起来也并没有后悔，只是觉得“道不同，不相与谋”吧。<strong>数科球队的团队、氛围、文化，本身就不适合我，我又怎么可能加入数科球队呢？</strong>前些日子在与谢老师、魏老师谈话时没有详细地解释这些原因，只谈了最关键的两点，并不是不敢说我对数科球队的看法，也不是不好意思和老师谈，只是觉得没必要。<strong>学生的事情停留在学生这里就好，何必惊动老师</strong>。我不大聪明，不像一些人懂得“我不好直接和你说，我就请老师给你打电话，找你谈话，还可以把事情推给老师”。同样在数科，我怎么没有学到这些聪明的技巧呢( ‘▿’ ) <strong>可能每个人在大学，学到的是不一样的东西( ‘▿’ )？</strong></p><p>顺带一提，在决赛前，数科某球员曾经帮助过我们训练。然而两年后的决赛，正是在他的煽动下，数科使出了盘外招将我禁赛。兄弟情谊？不存在的。其人还在双方球队代表谈判时装模作样抹了几把眼泪，之后借故离场，也许出门后就再也忍不住露出得意的微笑？或许这就是“兄弟”<sub>（此处特意用了此人最喜欢的波浪线</sub>~~）</p><h3 id="谈校会">谈校会</h3><p>对于我们而言，决赛争议颇大的一点是<strong>比赛时间的确定</strong>。事实上，不管是由于什么样的原因，信科在校学生会从来没有得到过公正的待遇。 明月杯决赛的比赛时间是很充裕的（可选取范围的很广），信科方面关于比赛时间也与校会做过沟通。这里我不做太阴暗的猜测（比如地遥与校会有某些交易，专门将时间定在这一天？），容易落人口实。但此事体现出的就是：<strong>信科在校会处没有话语权</strong>。这其中的原因可能有信科学生会的乌烟瘴气（非常乱&amp;非常烂&amp;只代表个人观点），也也可能有信科体育部的原因。但是，<strong>校会这方面的问题是一直存在的[ ‘▿’ ]</strong>。</p><p>记得有一场面对某大院的比赛，信科要求改时间，校会方面要求信科与对方沟通（翻译一下：对方是大院得罪不起，你们自己搞定）；另一场比赛，信科对阵某小院，对方要求改时间，对方球队在校会的要求下来找信科球队沟通（翻译一下：你们小院，校会还没有为了你们得罪信科的必要，你们自己搞定）；可还有一场比赛，是某小院对阵某大院，据说并没有经过太多流程，比赛时间就顺利调整了（翻译一下：大院就是可以为所欲为）。这便是校会一贯的办事风格。</p><p>回到这次比赛，作为主办方，我个人认为校会有必要保障双方的权益，尽量选在双方都同意的时间。本身比赛就在周末，双方队员也很容易就能错开时间。事实上，对于信科而言，唯一不合适的时间就是12.12那一周，如果把比赛时间提前一周或推后一周，相信对方也不会因此受到很大的影响。然而校会可能不会考虑这么多：是呀，挑一个好时间比赛，多麻烦的事情呀，我们直接拍板就好了。于是信科只好以缺少重要球员的残阵迎战。校会很强，我服了。</p><h1 id="x02.-2016">0x02. 2016</h1><h2 id="明月杯流水账-2">明月杯流水账</h2><h3 id="概况-1">概况</h3><p>12级的师兄们在这一年毕业了，于是信科缺少了技术扎实的后卫张博以及内线大闸郑培凯。另一方面，欧哥在家乡实习，也不能回学校参赛，于是信科缺少了去年的绝对核心。在实力下降的情况下，<strong>信科男篮在信科2014级的带领下小组赛保持全胜，出线后不敌数科止步八强。</strong></p><h3 id="稍微详细的版本">稍微详细的版本</h3><p>小组赛首场面对生科（大家都说其实跳球就暗示了比赛结果）</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2016myb-shengketq.jpg" alt="小组赛vs生科：跳球"></center><p>尽管信科的实力严重下滑，但两队的实力差距还是比较大的。尽管如此，慢热的信科还是在开局阶段一度落后4分，但随着信科球员逐渐找回状态，首发球员频频命中投篮，很快就追平了比分，并以13:5领先进入下半场（附一张罚球图片哈哈）。</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2016myb-shengkefq.jpg" alt="小组赛vs生科：罚球"></center><p>下半场刚开始我就有一次失误入账（囧），但对方未能得分。随后我又命中了一粒后仰跳投，进一步拉大了比分，此时比赛悬念已经不大，于是双方球员在球场上都显得放松了一些。最终本场我拿下了全场最高的……7分Orz，这也是我第一次得到全场最高分。信科以28：12顺利拿下首胜。（附赛后双方握手以及信科队伍合影）</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2016myb-shengkews.jpg" alt="小组赛vs生科：握手"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2016myb-shengkehy.jpg" alt="小组赛vs生科：合影"></center><p>第二场小组赛对阵实力一般的政管，本以为能够前三节搞定对手第四节下场休息，但比赛一直到了第四节才分出胜负。于是，很惨，又打满了全场Orz。。赛前还尝试了一次空接扣篮，<del>但是很遗憾扣飞了</del>，我才不告诉你们成功没==</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2016myb-zhengguankl.jpg" alt="小组赛vs政管：训练时尝试空接扣篮"></center><p>跳球仍然是毫无压力，第一节大家的发挥也比较稳健，虽然进攻端效率一般，但防守很强硬，以7:2结束第一节。</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2016myb-zhengguantq.jpg" alt="小组赛vs政管：跳球"></center><p>第二节的比赛中，信科延续了第一节的强硬防守，政管一分未得。但在延续强硬防守的同时，进攻也比第一节更铁。。最后我一记三分打铁结束了上半场的战斗，信科以10:2暂时领先进入下半场。（附一张突破图，可以看出对方的防守也很严密，包夹比较到位。<del>但是无奈哥太强他们防不住</del>）</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2016myb-zhengguantupo.jpg" alt="小组赛vs政管：突破"></center><p>第三节中，信科众将依然手感冰凉，整节只得2分。但政管本节手感回暖，拿下5分，将比分追至12:7后，听着王伟程两罚不中“乒乒乓乓”的打铁声进入了第四节。至此，政管仍有翻盘的希望。感到形势危急的信科球员重新找回了一部分投篮技能包，将比分拉至15:7。最后时刻对方想通过快打三分的战术来做一下最后的挣扎，但传球时遭到我的抢断，并直接完成一条龙快攻，彻底杀死比赛。最终比分定格在17:7，信科取得两连胜。</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2016myb-zhengguankg1.jpg" alt="小组赛vs政管：快攻1"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2016myb-zhengguankg2.jpg" alt="小组赛vs政管：快攻2"></center><p>第三场小组赛对阵教育，本场并没有太大压力，信科以29：15顺利拿下比赛，取得三连胜。至此，信科取得小组出线资格，只差和外文争夺小组第一的位置。（随手附一张抢篮板卡位的照片以及赛后全队的合影）</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2016myb-jiaoyukw.jpg" alt="小组赛vs教育：卡位"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2016myb-jiaoyuhy.jpg" alt="小组赛vs教育：合影"></center><p>最后一场小组赛面对的是拥有在前三场场均20+10的新星庄子晨以及技术精湛的后卫卢明江的外文。面对外文的跳球是我这一年第一次跳球失败Orz，但信科仍然神奇地取得了球权。体力充沛的上半场永远是拉开比分的最好时机，加上我本场手感火热，两次出手全部命中（第二次还是单手扔的，防守人压着我的左手，然而本场的裁判就像瞎了一样），比分很快就来到了11:2。尽管比分领先，但信科的后卫们却遭遇了史无前例的防守压迫：先是王伟程的上篮被庄子晨大力扇飞，然后王梓晗的中距离出手又遭遇庄子晨排球大帽，导致后卫们有些畏手畏脚，不敢突破。就在关键时刻，我趁乱接到了球，站在三分线外空位出手命中，将比分拉大到14:3，分差首次来到两位数。又经过一段时间的拉锯战，信科以14:5结束了上半场。第三节中信科仍然保持了9分的领先优势，以21:12进入末节。</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2016myb-waiwen3f.jpg" alt="小组赛vs外文：三分"></center><p>第四节中，外文后卫卢明江加强了对内线的冲击，加上对方命中了两记神奇的三分球，外文不断追分，一度将比分追至23:19。但此时比赛已经进入尾声，对方也采取了犯规战术。此时正是考验球员素质的时刻，然而对方球员卢明江却动作越来越大。终于，在一次信科的快攻中，气急败坏的卢用一个非篮球动作对信科球员犯规，被吹技术犯规（场下观众都看不下去了哈哈哈），同时也满犯离场，并在离场时脱下自己的球衣狠狠砸在地面上泄愤，随即遭到了全场的嘘声。此时比赛已经没有了悬念，最终信科以32:24拿下比赛，以小组第一身份出线。王伟程凭借最后时刻罚球刷分，成功超越我（11分），取得全场最高的13分Orz。</p><p>淘汰赛面对老冤家数科，开场王梓晗命中2分后，数科球员蔡伯文立刻用一记三分还以颜色，紧接着又顶着防守命中一颗神奇的2分。至此，信科气势已经被全面压倒，赛场也进入了数科的节奏。在追分的过程中，信科的控球者王伟程和侯彦丞显得有些慌乱，也有些着急，最终信科13:21不敌数科，结束了本届明月杯之旅。</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2016myb-shuke.jpg" alt="淘汰赛vs数科"></center><h2 id="几句废话-2">几句废话</h2><h3 id="谈数科二">谈数科（二）</h3><p>整个数科球队我认识的人中，我最欣赏，也最佩服的人，就是頔哥。此处不谈頔哥练球刻苦，打球干净不搞小动作；也不谈頔哥在明月杯的压力之下仍然考上人大统计研究生。这里只谈和我相关的事情。</p><p>在14年败给地遥之后的聚餐中，李奕师兄对（那时）想转系的席伟说“信科转到数科的不少，也有不少打球厉害的转过去了，但他们碰到我们的时候不会上场”。受到这句话的影响，在15年我转入数科，但仍然留在信科打球时，我也说过类似于“如果数科碰到信科，我就不上场”的话。但幸运的是，两队在15年没有碰面，我们也成功创造了历史最佳成绩。但在16年的八进四比赛上，两队碰面了。想起之前的承诺，我当然会说我不上场，信科各位球员的劝说，甚至是欧哥的长篇大论都没有让我动摇。就这样到了比赛前的两天。</p><p>让我改变想法的是頔哥。队长王伟程（应该是他，但不敢确定）给我看了与頔哥的聊天记录，依稀记得頔哥说的两句话：“石睿平和我说lzc不打，我就和他说让他打”，还有“<strong>兄弟之间，该怼就要怼</strong>”。正是頔哥的这番言论让我想清楚，比赛代表的是球队，院系的事情，不应该过多带入到比赛中来。虽然最终在场上也受了一些心态上的影响，但这一年也没有太多遗憾的事情。</p><p>然而，真正奇怪的是，石睿平直到赛前都没有来找我“让我打”，数科也没有一个认识我的球员来找我说明这件事情。我很好奇，难道是頔哥撒谎了？更为可悲的是，一年后，这件事情竟被数科的球员摆在了谈判桌上，将頔哥的意见扯到了自己头上。数科15级队长（不点名）表示：“去年也是淘汰赛，按理来说和总决赛同等重要，但我们让lzc上场了。”言下之意便是“去年是给你们面子才让lzc上场的”。我不知道，实在是不知道，他是抱着怎样的心态说出这句话的。另一边，某人一把鼻涕一把泪地说“我和信科有感情，我和欧哥有感情”，，我也很难理解，这到底是怎样一个人，才能如此惺惺作态。</p><h3 id="谈信科">谈信科</h3><p>这一年的比赛，大多数都有一个共同的特点：<strong>上半场砍分，第三节崩盘</strong>。这种现象的成因我至今都搞不明白。</p><p>如果说是因为信科首发阵容强大，第一节能凭借首发的得分能力将分差拉开，那还算正常。但信科首发偏偏都很<strong>慢热</strong>。首场面对生科是慢热最好的体现。两队实力差距非常大，但在刚开局时，信科手感冰凉，前几次出手均未命中；反观生科，进入状态迅速，韩嘉伟和于翔宇里突外投，很快就拉开了4分的分差。经历了17年的比赛后，我大致明白了，慢热是由于训练强度不够大的原因。而第三节崩盘最好的体现是与政管的比赛，整场手感冰凉，第三节还险些被追平比分。其原因我至今也没有想通Orz。</p><p>信科的另一个严重的问题是<strong>缺乏气势</strong>。这一点最好的体现就是与数科的比赛。虽然信科命中了第一粒进球，但大哥立刻命中三分给出回应，接着又是一颗非常提士气的两分，信科顿时气势全无。。。气势是球场上很重要的一环，只是那时我们不够关注这件事。欧哥也遗憾地告别了明月杯。</p><h1 id="x03.-2017">0x03. 2017</h1><h2 id="明月杯流水账-3">明月杯流水账</h2><h3 id="概况-2">概况</h3><p>信科在这一年迎来了强大的17级，包括全能球星李家和，长臂大前谢清宇，和防守强悍的后卫张指导。小组赛势如破竹，连克外文、历史、和哲社，以小组头名身份闯入八强。在淘汰赛中接连战胜地理学部和卫冕冠军经管，三年内第二次进入邱季端。</p><p>在决赛前的几天，数科使出了一些见不得光的盘外手段，将我禁赛。缺少内线核心的信科以37：44不敌数科，再次获得亚军。想必看球的各位也懂得，冠军应该是谁[手动微笑]。</p><h3 id="邱季端门票">邱季端门票</h3><p>不太客气地讲，这一年的明月杯就是个笑话。</p><p>首先从揭幕战数科vs物理谈起。这是一场精彩的比赛，双方的攻防都很不错，然而一些问题严重影响了这场比赛。比赛进行到最后一分钟时，物理领先6分，围观者大多觉得大局已定。这时为了追分，数科使出了自己的看家本领全场紧逼，物理对此显然准备不足，被对方多次成功防守，分差越来越小。然而，由于物理在重压之下仍然命中了一些投篮，数科始终不能扳回比分。很快，比赛时间就所剩无几，物理仍然领先3分。这时数科球员投篮造成物理犯规，哨响后，数科的9号随意地上了一颗空篮，命中。<strong>这显然是一颗不计分的球</strong>，然而，可能是因为校会的记分员不懂规则（并不敢想象更奇怪的原因），将这一球判为了有效进球。于是在数科两罚全中后，数科成功“反超”，场下观众一脸懵逼。此时比赛时间只剩几秒，物理未能继续得分，数科成功罚球“绝杀”。<em>文字直播地址：http://m.lanqiu.woaoo.net/schedule/59349.html</em></p><p>赛后，物理的同学显然对比赛结果很不服气，于是有同学在蛋蛋网上发帖，引起了非常激烈的讨论。数科石某人在其中摆出的态度再次刷新了我的认知，真是太6了Orz。有没有问题，您自己心里没数么？您有录像也可以自证清白呀，谁不知道数科的比赛每场自己都会录像。墙都不服，就服您。（此处有石某人的精选评论截图[手动微笑]）<em>蛋蛋网微信推送地址：https://mp.weixin.qq.com/s/2RsB6fZ_iB8LiLsejD9TTQ</em></p><center><img src="http://olgwnj89q.bkt.clouddn.com/srp666.jpg" alt="人在zuo 天在看"></center><p>本以为校会能够认识到自己的错误，将比赛办好。但万万没想到，这只是个开始。</p><p>小组赛首场面对老对手外文。外文在17年也迎来了补强：一个又高又壮但技术一般的中锋，这无论对他们的内线防守还是篮板争抢，都是一个明显的提升，所以外界普遍认为这将是一场恶战。</p><p>但首节的战斗却出乎了所有人的意料：信科以14:0碾压了外文。这并不是因为外文首发太弱，而是外文的核心后卫卢明江并没有首发出场（原因不明），导致其羸弱的外线被抢断到心态爆炸，这也直接导致了本场外文的失利。（随手附一张李家和突破照片，此时卢明江[7号]已经上场）</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2017myb-waiwendc.jpg" alt="小组赛vs外文：李家和突破"></center><p>在卢明江上场后，外文在卢与庄子晨的配合下展开了反击。但由于外文在第一节挖的坑太大，信科几乎整场都保持了两位数的领先，最终36:25拿下首胜。李家和本场拿下22分5篮板5盖帽的豪华数据，实力carry全队。（附赛后合影）</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2017myb-waiwenhy.jpg" alt="小组赛vs外文：合影"></center><p>第二场面对实力较弱的历史，全队12人均有得分进账，谢清宇小同学非常兴奋，拿下全场最高21分，信科以58:12轻松拿下第二场胜利。（附赛后合影）</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2017myb-lishihy.jpg" alt="小组赛vs历史：合影"></center><p>两战全胜的信科在第三场面对哲社，与哲社争夺小组头名。信科本场又犯了慢热的老毛病，第二节刚开始不久，就落后了6分之多，但在首发球员的努力下，加强了对于对方球星陈宏礼的防守，以10:15进入下半场。（随手贴一张上篮）</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2017myb-zheshetl1.jpg" alt="小组赛vs哲社：上篮"></center><p>进入下半场，信科渐渐找回了状态，陈宏礼渐渐显得独木难支，双方展开了拉锯战，以18：21进入第四节。（再随手贴一张投篮，感谢侯彦丞dalao妙传）</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2017myb-zheshetl2.jpg" alt="小组赛vs哲社：投篮"></center><p>进入第四节，陈宏礼也出现了体力问题，比赛很快就彻底进入了信科的节奏。哲社在最后相当长的一段时间内，都未能得分，最终信科以29:25战胜哲社。（附赛后合影）</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2017myb-zheshehy.jpg" alt="小组赛vs哲社：合影"></center><p>值得一提的是，信科在终场前两秒执行两次罚球，全部命中后，哲社落后4分。虽然比赛结果已经尘埃落定，但是抱着拼到最后一刻的心态，陈宏礼在发球后直接在后场出手，不中。此时比赛显然已经可以判定为结束，然而哲社又获得了一次两秒的最后一攻的机会，陈宏礼再次超远三分出手不中，比赛才正式结束。对此感到不满的信科教练任挪走向技术台理论，竟然被体育部部长张浩东言语辱骂。原来校会这个样子，是上梁不正下梁歪啊。</p><p>出线后的八强赛中，信科面对的是已经沦为鱼腩球队的老对手地遥。带着14,15败给地遥的旧恨，信科没有给地理任何机会，以41:14干脆利落地拿下比赛。值得一提的是，在最后一节的一次快攻机会中，我过掉了对方的防守球员，然后上空篮不进==囧（全场嘘声Orz），信科众将也被我的这一顿操作惊得目瞪口呆。不过在下一波进攻中，我面对对方的防守投中了一颗干拔三分，嘿嘿嘿，还是这种感觉爽。赛后，当年地遥的小弟-如今地理的大哥：李震同志拒绝与信科握手，宽广的胸襟显露无疑，真是德艺双馨的好典范。（附赛后合影）</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2017myb-diyaohy.jpg" alt="八强vs地遥： 合影"></center><p>四强赛中，面对的是实力仍然强悍的经管。上半场信科占据主动，以14:7领先。下半场经管开始发力，信科的得分势头也开始下降，体力也渐渐出现了问题。第三节马上就要结束时，信科仅有1分入账，领先优势也只剩2分。但在最后一攻中，我接球命中了一粒三分，将分差又拉大到了5分，双方以18:13进入第四节。第四节信科的进攻更加惨不忍睹，正常时间内只有我在篮下的一次打板得手。但经管也没有得到太多机会，没能直接扳平或反超比分，最终信科21:19战胜经管，三年内第二次进入邱季端的舞台。</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2017myb-jingguanfq.jpg" alt="四强vs经管：李家和罚球"></center><p>谈起这次比赛，其实发挥不佳有一个很重要的因素，就是赛前对于对手战术的错误估计。赛前我们研究了经管vs文新的八强比赛录像，发现经管对于文新的闫芳齐采取了一盯四联的防守策略，成功限制了闫芳齐。于是我们推测，经管可能会在比赛中对于李家和采取同样的防守策略。接着，在赛前的训练中，特意设计了两套新的战术来应对一盯四联的防守，名字分别叫“库里”和“五道口”（笑尿）。然而。。经管在比赛中几乎全场都没有使用一盯四联的防守策略，这也一定程度上导致了进攻端的低迷。但最终还是依靠着强硬的防守赢得了比赛的胜利。</p><h3 id="再入邱季端">再入邱季端</h3><p>比赛之前当然是拍了一发宣传照。（只贴了自己的照片和合影，<del>有点丑 将就看</del>）</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2017myb-hy.jpg" alt="2017邱季端：宣传照"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2017myb-geren.jpg" alt="2017邱季端：合影"></center><p>很遗憾没能再次触摸邱季端的地板，事情的始末将在下文详细交待。最终的结果是唐聪替代我出场，缺少主力的信科仍然与对方战斗到最后一刻才分出胜负，最终37:44不敌数科。李家和发挥出色，拿下了28分15板的怪兽级数据，这也是给自己最好的生日礼物。（随手附两张图）</p><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2017myb-jsqiuyi1.jpg" alt="2017-邱季端赛后-1"></center><center><img src="http://olgwnj89q.bkt.clouddn.com/basketball-2017myb-jsqiuyi2.jpg" alt="2017-邱季端赛后-2"></center><h2 id="明月杯史上最大笑话">明月杯史上最大笑话</h2><center><font color="red"><strong>靠改分赢球的队伍，靠禁赛赢球的队伍：冠军，您配吗？</strong></font></center><p>赛前的过程我也懒得详细再写一遍，直接掏出当时发的说说好了。事情的经过如下：</p><ol type="1"><li>信科队长在报名前未开具双方签字的证明;</li><li>按照规则需要开具该证明，但校会并未审查出;</li><li>数科在比赛前四天（划重点 马上就要开赛的时候）对参赛资格提出异议<strong>并怂恿老师给我打电话</strong>;</li><li>校会提出可以补开证明，但数科不同意签字（数科男篮 一支稳健的队伍 此条五毛）。</li></ol><p><strong>怎么说呢，球场上的人得到大家的尊重，未必是因为荣誉。</strong>想起去年赛前我提出遇到数科可以不打，頔哥直接说“让他打，兄弟该怼就要怼”的事情，如今竟是以“我们去年时候就可以不让你上场”的方式被数科提出。事实上，我毫不怀疑如果当年您们坐在頔哥的位置上，肯定不会让我上场的~（此处又用了某人最爱的波浪线）哈哈，可能有些东西是无法传承的吧。借用师大著名球星的话：“篮球本来是很纯粹的事情，但很可惜不是每个人都这样想。”</p><p>同一件事情，君子有君子的解决办法，小人也会有小人的解决办法。既然对面是小人，那我不得不防：<strong>谈判<font color="red">全程录音</font></strong>。</p><p>谈判时，数科队长表示“很尴尬，我始终是不愿意面对琛哥的”。可我想说的是，你既然已经做出了这个决定，我们也就不可能再是什么“兄弟”了，进而想到石某人虚伪的丑陋嘴脸，我更是没来由的一阵干呕：和欧哥有感情，您配么？<strong>关于球赛，类似的事情绝不是没有发生过。但是参与的人不同，结果自然也不同。</strong>据陈宏礼回忆，之前BBA的决赛，他所在的队伍与欧哥所在的队伍相遇，因为他的个人原因请求变更比赛时间，而欧哥方面<strong>同意</strong>了变更的请求。石某人既然与欧哥如此有感情，那么您的奸诈是从哪里学来的？欧哥和您可不是一路人。不过您赢了，一把鼻涕一把泪的表演，着实恶心了我一回。</p><p>接下来数科王队长的一番话更加令我无言以对了。也就是我多次提到的“去年我们就可以禁赛你，但我们没有，是因为我们有情谊”。哇，厉害厉害。正如上文所说，我从未想过这件事情能以这种刁钻的角度提出来。不知道頔哥听了这番话会作何感想，当时没有禁赛的事情，请问和您有半毛钱关系么[手动滑稽]？一路躺赢的感觉相比也很爽吧~事实上，我也丝毫不怀疑，如果当年是您处于頔哥的位置，会毫不犹豫地提出禁赛的事情。没啥特别的原因，就是觉得您比较厉害呀。</p><p><strong>事实证明了，录音非常有必要。数科男篮的无耻早已超出了我的理解范畴</strong>。谈判的最后一点时间，梓晗再也不能忍受对方的无耻，直接发飙。然而数科的石某人，直接将禁赛的原因归结到了梓晗发飙这件事情上。红口白牙，胡说八道？难以想象这到底是怎样一个人。頔哥知道禁赛的事后表示“不知道是谁提出的禁赛，真傻逼”——頔哥不知道吧，你说的就是你的下一任队长呀。对于石某人，我的言论也就到此为止。人在zuo，天在看，祝石某人考研顺利~下半辈子都活在夺冠的美梦里[手动滑稽]。</p><p>最后，我想谈谈关于老师的看法。<strong>首先需要说明，我并不对魏老师以及谢老师抱有敌意，但落到这件事情上，我个人认为二位有拉偏架的嫌疑。</strong>最早是我与魏老师单独谈话时，魏老师已经免不了露出自己的倾向：“考虑最好的结果，数科战胜信科夺冠……”抱歉，我不觉得这是最好的结果。在我们几个还没有进入会议室时，魏老师就已经憋不住得意的笑容了，边笑边说“校会那边已经说了，五点了，他就是不能打”，但还是表示“不过再给你们一个机会，去找他们谈一谈，我作为老师不插手”。然而到了会议室以后，情况却不大相同：老师又扬了扬手机说“虽然我这里已经掌握了可以直接左右战局的信息，不过你们还是先谈一谈”。这句话表面上看着是给你们公平讨论的机会，实则提醒了数科的队员“你们已经是占优势的一方，能坐下来谈已经是给足他们面子了”。这也就注定不是一场“讲道理”的谈判。<strong>数科男篮的无耻、数科老师的倾向，加上校会的甩锅和信科团学的软弱，最终结果实际也在意料之中</strong>。总而言之，就这件事情而言，我不觉得魏老师、谢老师扮演了一个公平的裁决者。至于魏老师称自己为“护犊子”，这护的大概是“数科”，而不是我。<strong>如果这篇文章有幸被老师看到，恕我迟钝，没能在这件事情上体会到您对我的照顾</strong>。</p><h1 id="数科与信科">数科与信科</h1><h2 id="谈数科男篮为保荣誉不择手段的小人团伙">谈数科男篮：为保荣誉不择手段的小人团伙</h2><center><font color="red"> <strong>只针对17阵容，无关人员请勿对号入座。</strong> </font></center><p>前文提过我和数科球队“道不同，不相与谋”，<strong>长期以来，我对数科男篮一直谈不上喜欢</strong>——从12级的王晨笛到13级的郭强，再到14级的石睿平，都不是什么我喜欢的人物。<strong>但由于院系原因，加上数科也有一些相熟的同学，所以我对数科男篮这个团队还抱始终有一丝希望。甚至在17明月杯后仍觉得，数科男篮有一部分人是光明正大打球的人。</strong></p><p><strong>然而现实并不如我所想。</strong>这让我不禁想到了前几日数科吉队长对于我“庆幸留在信科男篮”做出的“我们也不是什么人都收”的精彩评论。在我决定是否加入数科球队的时候，好像数科还没你这个人吧<sub>不知道您有什么资格说这句话？这么急着说强调一下“我们”么</sub>惊讶于队长也会说出如此脑残的言论时，我也懒得多辩驳——因为我忽然想到，吉队长就是这么脑残呀：赛前的一节课后，吉队长对我说“你决赛得分你就死”。对没看错，就是死，可我想说，吉队长决赛场上得分死全家呀<sub>哎，结果就是这么巧，吉队长得分了！想到这里我不禁为吉队长大义灭亲的胆识和魄力鼓起了掌。转念一想，吉队长将来可是人民教师呀，我不禁又对祖国未来的教育事业充满了担忧，同时担心亲人的离世给吉队长带来过大的打击</sub>于是我便罢了手，没有与吉队长过多纠缠。</p><p>再联系到17年的比赛，第一场靠改分赢了物理，数科各位的辩驳不可谓不精彩：“我知道你没有证据，改分赢了也是赢了，你来咬我呀~”数科手里有录像，却不拿来自证清白。校会手里有录像，却不拿来还比赛一个公道。更厉害的是，数科男篮更是摆出了一副不要脸的泼皮姿态，石某人也搬出各种人名来颠倒黑白。那时我竟然还相信数科是清白的，错误只在记分员，真是可笑。后来的比赛中，在意识到信科很有可能碰到数科时，石某人急了。为什么急呢？因为怕呀——软蛋总是缺乏正面面对事情的勇气。于是在哲社vs信科以及经管vs信科的赛后，信科经历了所经历过的最恶毒的诅咒——什么“我在场边一遍遍祈祷……”，什么“一人得道鸡犬升天”，什么“对这个结果感到失望”。然而上天并没有听信小人的胡言乱语，信科也顺利进入了决赛，心有不甘的石某人便精心策划了一手阴谋，最终摘得了这个笑话一般的冠军奖杯。赛后石某人竟然还有脸谈情谊：“我们的情谊是不变的”。这嘴脸与吉队长如出一辙，<strong>不愧是两届队长，连脸皮的厚度都如此相似。</strong></p><p>数科球队的各种趣事还有很多，如某自称杜兰特的软蛋赛前赛后挑衅等，此处都不再赘述。这些事情也只是说明，<strong>如今数科男篮整体的作风，不是个别几人能够形成的。在这个团队里，无耻会像病毒一样传播。很庆幸当年没有加入数科男篮</strong>，若没有这件事我恐怕也很难看清这些人的两幅面孔——当面还称兄道弟，转过身就在暗地里处处下绊。这里也不得不佩服吉队长的演技——事出之前还笑脸相迎，甚至求代码求作业，背后毫不犹豫就是一刀。二位队长的脸皮真乃铜墙铁壁，在下佩服~</p><p>最后，用两句话总结一下17的数科男篮，也算是对偶然看到的頔哥观点的回应：</p><ol type="1"><li>数科男篮够好么？连缺少主力的信科都不能轻松战胜，<strong>当然不够好，看过决赛就知道他们根本没有实力夺冠</strong>；</li><li><strong>数科男篮有光明正大打球的人吗？抱歉我不觉得</strong>。</li></ol><h2 id="谈信科团学软弱的学生组织">谈信科团学：软弱的学生组织</h2><p>随手列几条，不过多评论信科内部事务，我也不想与信科团学有任何瓜葛。</p><ol type="1"><li>体育部部长不强硬，当然这是信科团学的一贯作风；</li><li>粉丝票优先给院会，剩余给球队，一定程度上导致了球队票源短缺；</li><li>老师也并不努力给学生争取权益，尤其是球队一事。</li></ol><h2 id="谈信科男篮不被幸运眷顾的无冕之王">谈信科男篮：不被幸运眷顾的无冕之王</h2><p>14-17四年明月杯，信科男篮四次进入八强，三次进入四强，两次问鼎邱季端。虽然两次都铩羽而归，但其实力不容置疑。两次邱季端，都在赛前生出了不同的变故，于是信科两次邱季端之旅都不是完整阵容。造化弄人，不是么？信科的两次邱季端之旅本身都有实力夺冠，但最后都只能感叹一番时运不济。<strong>也许光明正大打球，在明月杯这赛场上占不到便宜吧[微笑]。</strong>（全文废话完）</p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 篮球 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2016-2017学年春季学期志愿时长录入</title>
      <link href="/2017/11/17/2016-2017%E5%AD%A6%E5%B9%B4%E6%98%A5%E5%AD%A3%E5%AD%A6%E6%9C%9F%E5%BF%97%E6%84%BF%E6%97%B6%E9%95%BF%E5%BD%95%E5%85%A5/"/>
      <content type="html"><![CDATA[<h2 id="一点简单的说明">一点简单的说明</h2><h3 id="几句废话">几句废话</h3><p>抱歉给大家拖了这么久Orz. 之前也和认证部长沟通过几次, 认证可能确实因为人手不够等问题, 没有及时给各位录入时长.</p><p>认证由于人手不够, 只能给大家提供时长码, 大家自己在志愿北京录入时长码获取时长.</p><h3 id="时长码使用说明">时长码使用说明</h3><ul><li>登录<a href="www.bv2008.cn">志愿北京</a>;</li><li>在志愿北京-我的首页中, 点击自己的服务时间, 进入“我的时长”页面; <img src="http://olgwnj89q.bkt.clouddn.com/%E6%97%B6%E9%95%BF-1.png" alt="志愿北京-我的首页"></li><li>在新页面中点击“录入时长码”, 即可录入时长码. <img src="http://olgwnj89q.bkt.clouddn.com/%E6%97%B6%E9%95%BF-2.png" alt="时长码页面"></li></ul><h2 id="时长码查询">时长码查询</h2><script type="text/javascript">function search(){    var list = new Array("李萍", "谢万明昱", "王石安", "蒋雨含", "王雪琪", "杨东芳", "张巧凌", "陈心如", "冯晓科", "贺苑林", "宋研霏", "朱燕琪", "周敬天", "李奕璇", "边珍", "但晴", "贺巧", "李晓霞", "郑逸敏", "付月", "王子璇", "白月", "段婷波", "高珊", "何可人", "李金铭", "苏宁", "王松正", "文艺", "许琳旋", "周佳茜", "张恺琦", "李军逸", "孙漾", "王蔚桐", "杨航", "余跃", "曹梦宇", "查少琛", "陈林涛", "刘子辰", "马玉阁", "王伟初", "孙荣", "周泓宇")    var time = new Array(48, 48, 44, 42, 42, 42, 42, 32, 32, 42, 36, 36, 36, 34, 30, 30, 30, 30, 30, 30, 26, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 20, 18, 18, 18, 18, 18, 12, 12, 12, 12, 12, 10, 9, 3)    var code = new Array(104198280126, 104197959124, 104198444710, 104191633494, 104193443180, 104199997937, 104196008038, 104190659437, 104192963919, 104196143683, 104193955548, 104191780154, 104191422029, 104199202510, 104194994021, 104193868440, 104198971022, 104197237983, 104194009799, 104197768688, 104191560051, 104193005169, 104197725850, 104191360385, 104193523894, 104198523787, 104198383642, 104198262211, 104199021643, 104191333531, 104199998372, 104197447426, 104194687884, 104199153947, 104190342124, 104195364603, 104195467540, 104195030302, 104196284847, 104194794933, 104194622149, 104198082739, 104195705550, 104191401247, 104195020771)    var name = document.getElementById("input").value    var res = "查无此人！"    var ans = "没有查询到您的时长码QAQ"    for (id in list){        console.log(list[id], name)        if(list[id] == name)        {            res = list[id]+", 您的志愿时长为"+time[id]+"小时, 您的时长码已显示"            ans = code[id]        }    }    document.getElementById("output").value = ans    alert(res)}</script><center><p>请在输入框中输入您的姓名, 点击“查询”即可. 姓名: <input type="text" id="input" name="q" placeholder="请在这里输入您的姓名..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false"> <input type="button" value="查询" onclick="search()"> <br></p>时长码: <input type="text" id="output" name="q" placeholder="您的时长码会显示在这里..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false"></center>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>泛函——有界集、完全有界集和紧集</title>
      <link href="/2017/10/25/%E6%B3%9B%E5%87%BD%E2%80%94%E2%80%94%E6%9C%89%E7%95%8C%E9%9B%86%E3%80%81%E5%AE%8C%E5%85%A8%E6%9C%89%E7%95%8C%E9%9B%86%E5%92%8C%E7%B4%A7%E9%9B%86/"/>
      <content type="html"><![CDATA[<h2 id="基础定义">基础定义</h2><p><strong>有界集</strong>: 设 <span class="math inline">\((\mathscr{X},\rho)\)</span> 为度量空间, <span class="math inline">\(A\subset\mathscr{X}\)</span>，如果 <span class="math inline">\(\exists M&lt;\infty\)</span>, s.t. <span class="math inline">\(\forall x,y\in A\)</span>, 总有 <span class="math inline">\(\rho(x,y)\leqslant M\)</span>, 则称 <span class="math inline">\(A\)</span> 为有界集.</p><p><strong>完全有界</strong>: 集合 <span class="math inline">\(M\)</span> 称为完全有界的, 如果 <span class="math inline">\(\forall\epsilon\)</span>, 存在 <span class="math inline">\(M\)</span> 的一个有穷 <span class="math inline">\(\epsilon\)</span> 网.</p><p><strong>紧集</strong>: 在拓扑空间 <span class="math inline">\(\mathscr{X}\)</span> 中, 集合 <span class="math inline">\(M\)</span> 称为紧集, 如果 <span class="math inline">\(\mathscr{X}\)</span> 中每个覆盖 <span class="math inline">\(M\)</span> 的开集族中都有有限个开集覆盖 <span class="math inline">\(M\)</span>.</p><h2 id="有界与完全有界">有界与完全有界</h2>**<div class="text" style=" text-align:center;">有界集与完全有界集本质上<font color="red">只差维数</font>.</div><p>**</p><blockquote><p><strong>命题 1</strong> 在度量空间 <span class="math inline">\((\mathscr{X},\rho)\)</span> 中, 完全有界集的子集也是完全有界的.</p></blockquote><p><strong>证明</strong>: 　　设 <span class="math inline">\(M\)</span> 为 <span class="math inline">\(\mathscr{X}\)</span> 中的完全有界集, <span class="math inline">\(S\subset M\)</span>, 下证 <span class="math inline">\(S\)</span> 完全有界: 　　<span class="math inline">\(\forall\epsilon&gt;0\)</span>, 由 <span class="math inline">\(M\)</span> 的完全有界性可知, <span class="math inline">\(\exists N_0\in\mathbb{N}\)</span> 及 $ &amp;#123; x_n &amp;#125; _{n=1}^{N_0}M$, s.t. <span class="math inline">\(S\subset M\subset\bigcup\limits_{N=1}^{N_0}B(x_n,\frac{\epsilon}{2})\)</span>. 　　令 $I_s= &amp;#123; i:B(x_i,)S&amp;#125; $, 显然 <span class="math inline">\(I_s\)</span> 为有限集. 进一步, 对 <span class="math inline">\(\forall i\in I_s\)</span>, 取 <span class="math inline">\(y_i\in S\cap B(x_i,\frac{\epsilon}{2})\)</span>, 易有 <span class="math inline">\(B(x_i,\frac{\epsilon}{2})\subset B(y_i,\epsilon)\)</span>. 　　由此及 <span class="math inline">\(I_s\)</span> 的定义可知 <span class="math inline">\(S\subset\bigcup\limits_{i\in I_s}B(x_i,\frac{\epsilon}{2})\subset\bigcup\limits_{i\in I_s}B(y_i,\epsilon)\)</span>, 即 <span class="math inline">\(S\)</span> 完全有界.</p><blockquote><p><strong>命题 2</strong> 在有限维 <span class="math inline">\(B^*\)</span> 空间中, 有界集 <span class="math inline">\(\Leftrightarrow\)</span> 完全有界集.</p></blockquote><p><strong>证明</strong>: 　　“<span class="math inline">\(\Leftarrow\)</span>” 是显然的, 以下证明 “<span class="math inline">\(\Rightarrow\)</span>”. 　　由于 <span class="math inline">\(\mathscr{X}\)</span> 为有限维空间, <span class="math inline">\(M\)</span> 有界, 以及<span title="B*空间是有限维的当且仅当其任意有界集列紧."> 课本P37, Col1.4.30 </span>可知 <span class="math inline">\(M\)</span> 列紧. 再由 <span title="Hausdorff: 度量空间中的列紧集一定是完全有界集.">Th1.3.7</span> 知 <span class="math inline">\(M\)</span> 完全有界. 　　综上, 有界 <span class="math inline">\(\Leftrightarrow\)</span> 完全有界.</p><h2 id="紧集与完全有界闭集">紧集与完全有界闭集</h2>**<div class="text" style=" text-align:center;">紧集与完全有界闭集<font color="red">只差完备性</font>.</div><p>**</p><blockquote><p><strong>命题 3</strong> 在 <span class="math inline">\(B^*\)</span> 空间中, 紧集一定是完全有界闭集, 反之不一定成立.</p></blockquote><p><strong>证明</strong>: 　　由<span title="度量空间中的紧集等价于自列紧集.">Th1.3.11</span>, 在 <span class="math inline">\(B^*\)</span> 空间中, <span class="math inline">\(A\)</span> 为紧集当且仅当 <span class="math inline">\(A\)</span> 是自列紧集. 从而 <span class="math inline">\(A\)</span> 是闭的, 再由 <span title="Hausdorff: 度量空间中的列紧集一定是完全有界集.">Th1.3.7</span> 知 <span class="math inline">\(A\)</span> 完全有界.</p><p>　　即: 紧 <span class="math inline">\(\Rightarrow\)</span> 完全有界 <span class="math inline">\(+\)</span> 闭 在 <span class="math inline">\(B^*\)</span> 空间中成立.</p><p>　　<strong>但反之不成立, <font color="red">反例</font>如下:</strong> 　　<span class="math display">\[x_n(t)=\begin{cases}　　1, &amp;t\in [a,\frac{a+b}{2}-\frac{1}{n});\\　　n(\frac{a+b}{2}-x), &amp;t\in [\frac{a+b}{2}-\frac{1}{n},\frac{a+b}{2}+\frac{1}{n});\\　　-1, &amp;t\in [\frac{a+b}{2}+\frac{1}{n},b].　　\end{cases}\]</span> 　　<span class="math display">\[x_n(t)=\begin{cases}　　1, &amp;t\in [a,\frac{a+b}{2});\\　　0, &amp;t=\frac{a+b}{2};\\　　-1, &amp;t\in (\frac{a+b}{2},b].　　\end{cases}\]</span> 　　记 <span class="math inline">\(\mathscr{X}=(C[a,b],\Vert\cdot\Vert_{L^1})\)</span>, 并记 $ &amp;#123; x_n &amp;#125; <em>{n}C[a,b]$, 如下构造: 　　易证 $ &amp;#123; x_n &amp;#125; </em>{n}$ 依 <span class="math inline">\(\Vert\cdot\Vert_{L^1}\)</span> 有极限 <span class="math inline">\(x\)</span>, 且 <span class="math inline">\(x\notin C[a,b]\)</span>. 考虑到 <span class="math inline">\(x\in L^1[a,b]\)</span>, 故 $ &amp;#123; x_n &amp;#125; <em>{n}$ 为 <span class="math inline">\(L^1[a,b]\)</span> 中的列紧集, 从而由 <span title="Hausdorff: 度量空间中的列紧集一定是完全有界集.">Th1.3.7</span>, $ &amp;#123; x_n &amp;#125; </em>{n}$ 为 <span class="math inline">\(L^1[a,b]\)</span> 中的完全有界集. 　　故 <span class="math inline">\(\forall\epsilon&gt;0\)</span>, <span class="math inline">\(\exists N\in\mathbb{N}\)</span> 以及 $ &amp;#123; f_k &amp;#125; <em>{k=1}<sup>NL</sup>1[a,b]$, s.t. $ &amp;#123; x_n &amp;#125; </em>{n}<em>{k=1}^NB(f_k,)$. 不妨设 <span class="math inline">\(B(f_k,\frac{\epsilon}{2})\cap \&amp;#123; x_n \&amp;#125; _{n\in\mathbb{N}}\neq\varnothing\)</span>(否则去掉 <span class="math inline">\(B(f_k,\frac{\epsilon}{2})\)</span> 即可). 对 $k&amp;#123; 1,2,,N &amp;#125; $, 取 <span class="math inline">\(g_k\in \&amp;#123; x_n \&amp;#125; _{n\in\mathbb{N}}\cap B(f_k,\frac{\epsilon}{2})\)</span>, 则 $ &amp;#123; x_n &amp;#125; </em>{n}<em>{k=1}<sup>NB(f_k,)<em>{k=1}^NB(g_k,)$. 从而 $ &amp;#123; g_k &amp;#125; </em>{k=1}</sup>N$ 为 $ &amp;#123; x_n &amp;#125; </em>{n}$ 的有穷 <span class="math inline">\(\epsilon\)</span> 网. 故 $ &amp;#123; x_n &amp;#125; <em>{n}$ 为 <span class="math inline">\(\mathscr{X}\)</span> 的完全有界集. 　　又由于 $ &amp;#123; x_n &amp;#125; </em>{n}$ 在 <span class="math inline">\(\mathscr{X}\)</span> 中闭, 故 $ &amp;#123; x_n &amp;#125; _{n}$ 为 <span class="math inline">\(\mathscr{X}\)</span> 中的完全有界集, 但不紧.</p><p><strong>但在完备空间: Banach空间中有更强的结论.</strong></p><blockquote><p><strong>命题 3</strong> 在Banach空间中, 紧集 <span class="math inline">\(\Leftrightarrow\)</span> 完全有界集.</p></blockquote><p><strong>证明</strong>: 　　上文中已证紧集 <span class="math inline">\(\Rightarrow\)</span> 完全有界闭集. 又由 <span class="math inline">\(B\)</span> 空间中, 完全有界集必定列紧. 从而完全有界集必定是自列紧的. 从而由 <span title="度量空间中的紧集等价于自列紧集.">Th1.3.11</span> 可知该集合必定是紧集. 综上, Banach空间中的集合是紧集, 当且仅当它是完全有界闭集.</p>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 泛函分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2017年概率测度小测一题目</title>
      <link href="/2017/10/19/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62017%E5%B9%B4%E6%A6%82%E7%8E%87%E6%B5%8B%E5%BA%A6%E5%B0%8F%E6%B5%8B%E4%B8%80%E9%A2%98%E7%9B%AE/"/>
      <content type="html"><![CDATA[<h2 id="郑重声明">郑重声明</h2><p>完全凭记忆写的=_=有差错不负任何责任…</p><h2 id="题目">题目</h2><h3 id="判断题">判断题</h3><p>正确须证明, 错误须举反例, 没有理由不得分.</p><ol type="1"><li><p><span class="math inline">\(f:\Omega\rightarrow E\)</span>, <span class="math inline">\(\forall~B\subset E\)</span>, <span class="math inline">\(f^{-1}(B^c)=(f^{-1}(B))^c\)</span>;</p></li><li><p>设 <span class="math inline">\((\Omega,\mathcal{F},\mu)\)</span> 为测度空间, 取 $ &amp;#123; A_n &amp;#125; _{n}$. s.t. <span class="math inline">\(A_n\to\varnothing\)</span>, 有 <span class="math inline">\(\lim\limits_{n\to\infty}\mu(A_n)=0\)</span>;</p></li><li><p>设 <span class="math inline">\((\Omega,\mathcal{F},\mu)\)</span> 为测度空间, 取 <span class="math inline">\(A\in\mathcal{F}\)</span>, s.t. <span class="math inline">\(\mu(A)=0\)</span>, 取 <span class="math inline">\(B\subset A\)</span>, 则有 <span class="math inline">\(\mu(B)=0\)</span>;</p></li><li><p>若 <span class="math inline">\(\Omega\)</span> 的子集类 <span class="math inline">\(\mathcal{C}\)</span> 既是 <span class="math inline">\(\lambda\)</span> 系又是 <span class="math inline">\(\pi\)</span> 系, 则 <span class="math inline">\(\mathcal{C}\)</span> 为 <span class="math inline">\(\sigma\)</span> 代数.</p></li></ol><h3 id="证明题">证明题</h3><p>叙述测度扩张定理, 并证明其中的唯一性部分.</p><h2 id="简略解答">简略解答</h2><p>同样…有差错不负任何责任.</p><h3 id="判断题-1">判断题</h3><ol type="1"><li>正确. 直接验证即可;</li><li>错误. 取 <span class="math inline">\(\mathbb{R}\)</span> 上的Lebesgue测度, <span class="math inline">\(A_n=(n,+\infty)\)</span>, 即有 <span class="math inline">\(\bigcap\limits_{n=1}^\infty A_n=\varnothing\)</span>, 但 <span class="math inline">\(\mu(A_n)=\infty\)</span>, <span class="math inline">\(\forall n\in\mathbb{N}\)</span>, 矛盾;</li><li>错误. 取 $= &amp;#123; 0,1,2 &amp;#125; $ 上的 <span class="math inline">\(\sigma\)</span> 代数 $= &amp;#123; , &amp;#123; 0,1 &amp;#125; , &amp;#123; 2 &amp;#125; ,&amp;#125; $, 取集函数 <span class="math inline">\(\mu( \&amp;#123; \varnothing \&amp;#125; )=\mu( \&amp;#123; 0,1 \&amp;#125; )=0\)</span>, <span class="math inline">\(\mu( \&amp;#123; 2 \&amp;#125; )=\mu(\Omega)=1\)</span>, 容易验证 <span class="math inline">\(\mu\)</span> 是一个测度. 取 $B= &amp;#123; 0 &amp;#125; A= &amp;#123; 0,1 &amp;#125; $, 则 <span class="math inline">\(B\notin\mathcal{F}\)</span>, 矛盾;</li><li>正确. 直接验证即可(由 <span class="math inline">\(\lambda\)</span> 系可直接得到 <span class="math inline">\(\Omega\)</span> 和余运算封闭, 证明对有限并运算封闭时继续构造部分和即可).</li></ol><h3 id="证明题-1">证明题</h3><p>见课本…</p><h2 id="图片版">图片版</h2><p>发卷子了==其实回忆基本没错.</p><figure><img src="http://static.zybuluo.com/lzcwr/8mqxcw5s4s1hputqvhko8psy/IMG_20171027_002952.jpg" alt="IMG_20171027_002952.jpg-4482.6kB"><figcaption>IMG_20171027_002952.jpg-4482.6kB</figcaption></figure>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 各种试卷 </tag>
            
            <tag> 测度论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>次序统计量的联合分布</title>
      <link href="/2017/10/09/%E6%AC%A1%E5%BA%8F%E7%BB%9F%E8%AE%A1%E9%87%8F%E7%9A%84%E8%81%94%E5%90%88%E5%88%86%E5%B8%83/"/>
      <content type="html"><![CDATA[<blockquote><p>设 <span class="math inline">\(X_1,\cdots,X_n\)</span> 为来自总体 <span class="math inline">\(X\sim F\)</span> 的iid样本, 总体概率密度函数为 <span class="math inline">\(f(x)\)</span>, 则对于给定的 <span class="math inline">\(1\leqslant i\leqslant j\leqslant n\)</span>, 求统计量 <span class="math inline">\(X_{(i)}\)</span> 与 <span class="math inline">\(X_{(j)}\)</span> 的联合密度.</p></blockquote><p>首先注意到, <span class="math inline">\(X_{(1)},\cdots,X_{(n)}\)</span> 的联合密度为 <span class="math display">\[f_{(X_{(1)},\cdots,X_{(n)})}(x_1,\cdots,x_n)=n!\cdot f(x_1)\cdots f(x_n).\]</span></p><p>于是只需要求 <span class="math inline">\((X_{(i)}, X_{(j)})\)</span> 的边缘密度.</p><p>利用结果 <span class="math display">\[\idotsint\limits_{a&lt;x_1&lt;\cdots&lt;x_k&lt;b}f(x_1)\cdots f(x_k){\rm d}x_1\cdots {\rm d}x_k=\frac{1}{k!}(F(b)-F(a))^k\]</span></p><p>可得 <span class="math display">\[\begin{align}f_{(X_{(i)}, X_{(j)})}(x,y) &amp;= \idotsint\limits_{x_k\in\mathbb{R},k\neq i,j}n!\cdot f(x_1)\cdots f(x_n){\rm d}x_1\cdots{\rm d}x_{i-1}{\rm d}x_{i+1}\cdots{\rm d}x_{j-1}{\rm d}x_{j+1}{\rm d}x_n \\&amp;= n!\times\idotsint\limits_{0&lt;x_1\cdots&lt;x_{i-1}&lt;x}f(x_1)\cdots f(x_{i-1}){\rm d}x_1\cdots{\rm d}x_{i-1}\times \idotsint\limits_{x&lt;x_{i+1}&lt;\cdots&lt;x_{j-1}&lt;y}f(x_{i+1})\cdots f(x_{j-1}){\rm d}x_{i+1}\cdots{\rm d}x_{j-1}\times \idotsint\limits_{y&lt;x_{j+1}&lt;\cdots&lt;x_n&lt;+\infty}f(x_{j+1})\cdots f(x_n){\rm d}x_{j+1}{\rm d}x_n\times f(x)f(y) \\&amp;= n!\times \frac{F^{j-1}(x)}{(j-1)!}\times\frac{[F(y)-F(x)]^{k-j-1}}{(k-j-1)!}\times\frac{[1-F(y)]^{n-k}}{(n-k)!}\times f(x)f(y) \\&amp;= \frac{n!}{(j-1)!(k-j-1)!(n-k)!}F^{j-1}(x)[F(y)-F(x)]^{k-j-1}[1-F(y)]^{n-k}f(x)f(y)\end{align}\]</span></p><p>同样可以求出任意多个次序统计量的联合密度.</p>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 统计学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>泛函——自然数集上的Lp范数</title>
      <link href="/2017/10/08/%E6%B3%9B%E5%87%BD%E2%80%94%E2%80%94%E8%87%AA%E7%84%B6%E6%95%B0%E9%9B%86%E4%B8%8A%E7%9A%84Lp%E8%8C%83%E6%95%B0/"/>
      <content type="html"><![CDATA[<h2 id="lpomegamu-空间"><span class="math inline">\(L^p(\Omega,\mu)\)</span> 空间</h2><p><span class="math inline">\(1\leqslant p&lt;\infty\)</span>, 设 <span class="math inline">\((\Omega,\mathscr{B},\mu)\)</span> 是一个测度空间, <span class="math inline">\(u\)</span> 是 <span class="math inline">\(\Omega\)</span> 上的可测函数且 <span class="math inline">\(|u(x)^p|\)</span> 在 <span class="math inline">\(\Omega\)</span> 可积. 则记这样 <span class="math inline">\(u\)</span> 的全体为 <span class="math inline">\(L^p(\Omega,\mu)\)</span>.</p><p>在 <span class="math inline">\(L^p(\Omega,\mu)\)</span> 中几乎处处相等的函数视为同一个函数后, <span class="math inline">\(L^p(\Omega,\mu)\)</span> 仍为线性空间. 定义 <span class="math display">\[\Vert u\Vert=\left(\int\nolimits_\Omega \vert u(x)^p\vert {\rm d}\mu\right)^\frac{1}{p}\]</span> 则 <span class="math inline">\(\Vert\cdot\Vert\)</span> 为一个范数. 事实上 <span class="math inline">\(L^p(\Omega,\mu)\)</span> 还是一个Banach空间.</p><h2 id="mathbbn-上的-lp-范数"><span class="math inline">\(\mathbb{N}\)</span> 上的 <span class="math inline">\(L^p\)</span> 范数</h2><p>以上的空间在 <span class="math inline">\(\mathbb{N}\)</span> 上的特殊情形如下:</p><p><span class="math inline">\(\Omega=\mathbb{N}, \mu( \&amp;#123; n \&amp;#125; )=1~(\forall n\in\mathbb{N})\)</span>, 此时 <span class="math inline">\(L^p(\Omega,\mu)\)</span> 由满足 <span class="math inline">\(\sum\limits_{n=1}^\infty\vert u_n\vert^p&lt;\infty\)</span> 的所有序列组成, 记为 <span class="math inline">\(l^p\)</span>.</p><p>此时其范数为 <span class="math display">\[\Vert u\Vert=\left(\sum\limits_{n=1}^\infty \vert u_n\vert^p\right)^\frac{1}{p}.\]</span></p><p>对于 <span class="math inline">\(\forall N\in\mathbb{N}\)</span>, 记 <span class="math inline">\(f_N(x)=\sum\limits_{n=1}^Nu_n\chi_{ \&amp;#123; n \&amp;#125; }\)</span>, 令 <span class="math inline">\(f(x)=\sum\limits_{n=1}^\infty u_n\chi_{ \&amp;#123; n \&amp;#125; }\)</span>, <span class="math inline">\(x\in\mathbb{N}\)</span>.</p><p>则有 <span class="math display">\[\begin{align}\int\nolimits_\mathbb{N}\vert f_N(x)\vert^p{\rm d}\mu(x) &amp;= \int\nolimits_\mathbb{N}\sum\limits_{n=1}^Nu_n\chi_{ \&amp;#123; n \&amp;#125; }{\rm d}\mu(x) \\&amp;= \sum\limits_{n=1}^N \vert u_n\vert^p\cdot\int\nolimits_\mathbb{N}\chi_{ \&amp;#123; n \&amp;#125; }{\rm d}\mu(x) \\&amp;= \sum\limits_{n=1}^N \vert u_n\vert^p\end{align}\]</span></p><p>又显然, <span class="math inline">\(0\leqslant\vert f_N(x)\vert^p\leqslant \vert f_{N+1}(x)\vert^p\)</span>, 且 <span class="math inline">\(\vert f(x)\vert^p=\lim\limits_{N\to\infty}\vert f_N(x)\vert^p\)</span>. 故由非负可测函数的Levi定理有 <span class="math display">\[\begin{align}\int\nolimits_\mathbb{N}\vert f(x)\vert^p{\rm d}\mu(x) &amp;= \int\nolimits_\mathbb{N}\lim\limits_{N\to\infty}\vert f_N(x)\vert^p{\rm d}\mu(x) \\&amp;= \lim\limits_{N\to\infty}\int\nolimits_\mathbb{N}\vert f_N(x)\vert^p{\rm d}\mu(x) \\&amp;= \sum\limits_{n=1}^\infty \vert u_n\vert^p\end{align}\]</span></p><p>即有 <span class="math display">\[ \left(\sum\limits_{N=1}^\infty\vert u_n\vert^p\right)^\frac{1}{p}=\left(\int\nolimits_\mathbb{N}\vert f(x)\vert^p{\rm d}\mu(x)\right)^\frac{1}{p}. \]</span></p>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 泛函分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>拓扑学题目</title>
      <link href="/2017/10/08/%E6%8B%93%E6%89%91%E5%AD%A6%E9%A2%98%E7%9B%AE/"/>
      <content type="html"><![CDATA[<h2 id="乘积空间">乘积空间</h2><h3 id="hausdorff空间与对角映射">Hausdorff空间与对角映射</h3><blockquote><p>映射 <span class="math display">\[\Delta: X\rightarrow X\times X,~\Delta(x)=(x,x)\]</span> 称为<strong>对角映射</strong>. 证明: <span class="math inline">\(X\)</span> 是Hausdorff空间当且仅当 <span class="math inline">\(\Delta(X)\)</span> 是 <span class="math inline">\(X\times X\)</span> 的闭集.</p></blockquote><p><strong>证明</strong>:</p><p><strong>充分性</strong>: <span class="math inline">\(\forall x\neq y\in X\)</span>, 有 <span class="math inline">\((x,y)\in \Delta^c\)</span>. 由 <span class="math inline">\(\Delta\)</span> 为闭集有 <span class="math inline">\(\Delta^c\)</span> 为开集. 故由乘积拓扑的定义, 存在 <span class="math inline">\(X\)</span> 的开子集 <span class="math inline">\(U,V\)</span>, s.t. <span class="math inline">\((x,y)\in U\times V\subset\Delta^c\)</span>. (<span class="math inline">\(X\)</span> 上的开集<span class="math inline">\(\times\)</span><span class="math inline">\(X\)</span>上的开集为 <span class="math inline">\(X\times X\)</span> 乘积拓扑的一组拓扑基). 于是此时, <span class="math inline">\(U,V\)</span> 是 <span class="math inline">\(x,y\)</span> 的开邻域并且易得 <span class="math inline">\(U\cap V=\varnothing\)</span>.</p><p><strong>必要性</strong>: 由于 <span class="math inline">\(X\)</span> 是Hausdorff空间, 故 <span class="math inline">\(\forall x\neq y\in X\)</span>, 存在 <span class="math inline">\(X\)</span> 的开子集 <span class="math inline">\(U,V\)</span>, s.t. <span class="math inline">\(x\in U\)</span>, <span class="math inline">\(y\in V\)</span>, 且 <span class="math inline">\(U\cap V=\varnothing\)</span>. 故 <span class="math inline">\((x,y)\in U\times V\)</span>, 又由 <span class="math inline">\(U\cap V=\varnothing\)</span>, 知 <span class="math inline">\((U\times V)\cap\Delta=\varnothing\)</span>, 即 <span class="math inline">\(U\times V\subset\Delta^c\)</span>, 故 <span class="math inline">\(U\times V\)</span> 为 <span class="math inline">\((x,y)\)</span> 在 <span class="math inline">\(\Delta^c\)</span> 中的开邻域. 故 <span class="math inline">\(\Delta^c\)</span> 为开集, 即 <span class="math inline">\(\Delta\)</span> 为闭集.</p><p><strong>综上所述</strong>, <span class="math inline">\(X\)</span> 是Hausdorff空间 <span class="math inline">\(\Longleftrightarrow\)</span> <span class="math inline">\(\Delta(X)\)</span> 是 <span class="math inline">\(X\times X\)</span> 的闭集.</p><h3 id="自然投影不一定是闭映射">自然投影不一定是闭映射</h3><blockquote><p>举例说明 <span class="math inline">\(p_1:X\times Y\to Y\)</span> 不一定是闭映射.</p></blockquote><p><strong>证明</strong>: 取 <span class="math inline">\(\mathbb{E}^2\)</span> 中的闭集 $F= &amp;#123; (x,):x&gt;0 &amp;#125; $, 则 <span class="math inline">\(p_1(F)=\mathbb{R}^+\)</span> 为开集.</p><h2 id="连通性">连通性</h2><h3 id="mathbbe2-上的非无理点集连通"><span class="math inline">\(\mathbb{E}^2\)</span> 上的非无理点集连通</h3><blockquote><p>设 $X= &amp;#123; (r,s)^2r<sub>或</sub>s &amp;#125; $, 证明 <span class="math inline">\(X\)</span> 连通.</p></blockquote><p>有各种神奇的想法.</p><p><strong>证明1</strong>: <strong>通过道路连通性考虑</strong>. 取 <span class="math inline">\(x_1=(r_1,s_1),x_2=(r_2,s_2)\in X\)</span>, 有以下两种情况.</p><ol type="1"><li>若 <span class="math inline">\(r_1,r_2\in\mathbb{Q}\)</span>, 则存在 <span class="math inline">\(x_1\to x_2\)</span> 的道路 <span class="math inline">\((r_1,s_1)\to(r_1,r_2)\to(r_2,r_2)\to(r_2,s_2)\)</span>;</li><li>若 <span class="math inline">\(r_1,s_2\in\mathbb{Q}\)</span>, 则存在 <span class="math inline">\(x_1\to x_2\)</span> 的道路 <span class="math inline">\((r_1,s_1)\to(r_1,s_2)\to(r_2,s_2)\)</span>.</li></ol><p><strong>综上所述</strong>, <span class="math inline">\(X\)</span> 是道路连通的, 因此 <span class="math inline">\(X\)</span> 连通.</p><p><strong>证明2</strong>: <strong>反证法</strong>. 假设 <span class="math inline">\(X\)</span> 可以写成两个不相交非空开集 <span class="math inline">\(A,B\)</span> 的并. 取 <span class="math inline">\(q\in\mathbb{Q}\)</span>, 则 $X_q= &amp;#123; (x,q),(q,x)x &amp;#125; $ 构成 <span class="math inline">\(X\)</span> 的连通子集. 显然有 <span class="math inline">\(X_q\subset A\)</span> 或者 <span class="math inline">\(X_q\subset B\)</span>, 否则 <span class="math inline">\(X_q\)</span> 可分成不相交的两部分 <span class="math inline">\(X_{q_A}\)</span> 和 <span class="math inline">\(X_{q_B}\)</span>, s.t. <span class="math inline">\(\overline{X_{q_A}}\cap X_{q_B}=\overline{X_{q_B}}\cap X_{q_A}=\varnothing\)</span>, 这与 <span class="math inline">\(X\)</span> 的连通性矛盾. 于是 <span class="math inline">\(\exists q_1,q_2\in\mathbb{Q}\)</span>, s.t. <span class="math inline">\(X_{q_1}\subset A\)</span>, <span class="math inline">\(X_{q_2}\subset B\)</span>. 但 <span class="math inline">\((q_1,q_2)\in X_{q_1}\cap X_{q_2}\)</span>, 与 <span class="math inline">\(A\cap B=\varnothing\)</span> 矛盾. 故 <span class="math inline">\(X\)</span> 连通.</p><p>考虑一个引理:</p><blockquote><p><strong>引理</strong> 若 <span class="math inline">\(X_0\)</span> 是 <span class="math inline">\(X\)</span> 的既开又闭子集, <span class="math inline">\(A\)</span> 是 <span class="math inline">\(X\)</span> 的连通子集, 则 <span class="math inline">\(A\cap X_0=\varnothing\)</span> 或 <span class="math inline">\(A\subset X_0\)</span>.</p></blockquote><p><strong>引理的证明</strong>: <span class="math inline">\(A\cap X_0\)</span> 是 <span class="math inline">\(A\)</span> 的既开又闭子集. 由于 <span class="math inline">\(A\)</span> 连通, 故 <span class="math inline">\(A\cap X_0=\varnothing\)</span> 或 <span class="math inline">\(A\cap X_0=A\)</span>, 即 <span class="math inline">\(A\subset X_0\)</span>.</p><p>由引理可得出以下命题（北大拓扑学讲义P63 Prop 2.23）进而可证原命题.</p><blockquote><p><strong>命题 2.23</strong> 如果 <span class="math inline">\(X\)</span> 有一个连通覆盖 <span class="math inline">\(\mathscr{U}\)</span>, 并且 <span class="math inline">\(X\)</span> 有一连通子集 <span class="math inline">\(A\)</span>, 它与 <span class="math inline">\(\mathscr{U}\)</span> 中每个成员都相交, 则 <span class="math inline">\(X\)</span> 连通.</p></blockquote><p><strong>命题的证明</strong>: 设 <span class="math inline">\(X_0\)</span> 是 <span class="math inline">\(X\)</span> 的既开又闭子集, 只需证明 <span class="math inline">\(X_0=\varnothing\)</span> 或 <span class="math inline">\(X_0=X\)</span>. 由引理, <span class="math inline">\(A\cap X_0=\varnothing\)</span> 或 <span class="math inline">\(A\subset X_0\)</span>.</p><ol type="1"><li>若 <span class="math inline">\(A\cap X_0=\varnothing\)</span>, 则 <span class="math inline">\(\forall U\in\mathscr{U}\)</span>, 由于 <span class="math inline">\(U\cap A\neq\varnothing\)</span>, 故 <span class="math inline">\(U\nsubseteq X_0\)</span>. 由引理, <span class="math inline">\(U\cap X_0=\varnothing\)</span>, 则 <span class="math inline">\(X_0=(\bigcup\limits_{U\in\mathscr{U}}U)\cap X_0=\bigcup\limits_{U\in\mathscr{U}}(U\cap X_0)=\varnothing\)</span>.</li><li>若 <span class="math inline">\(A\subset X_0\)</span>, 则 <span class="math inline">\(\forall U\in\mathscr{U}\)</span>, <span class="math inline">\(U\cap X_0\supset U\cap A\neq\varnothing\)</span>. 由引理, <span class="math inline">\(U\subset X_0\)</span>, 则 <span class="math inline">\(X=\bigcup\limits_{U\in\mathscr{U}}U\subset X_0\)</span>, 即有 <span class="math inline">\(X_0=X\)</span>.</li></ol><p><strong>综上所述</strong>, <span class="math inline">\(X\)</span> 连通.</p><p><strong>证明3</strong>: 仍然考虑 $A_q= &amp;#123; (x,y)x=q<sub>或</sub>y=q &amp;#125; $, 则 <span class="math inline">\(A_q\)</span> 连通且 <span class="math inline">\(X=\bigcup\limits_{q\in\mathbb{Q}}A_q\)</span>, 即 $ &amp;#123; A_q &amp;#125; _{q}$ 构成 <span class="math inline">\(X\)</span> 的连通覆盖, 而 <span class="math inline">\(A_q\cap A_0\neq\varnothing, \forall q\in\mathbb{Q}\)</span>, 故由命题2.23, <span class="math inline">\(X\)</span> 连通.</p><p>结合引理, 证法2也会有不同的写法, 不再赘述.</p><h3 id="mathbbr1-上左开右闭区间生成的拓扑不是-c_2-空间"><span class="math inline">\(\mathbb{R}^1\)</span> 上左开右闭区间生成的拓扑不是 <span class="math inline">\(C_2\)</span> 空间</h3><blockquote><p>设 <span class="math inline">\(\mathbb{R}^1\)</span> 的子集族 $= &amp;#123; (a,b]:a,b^1,a&lt;b &amp;#125; $, 则 <span class="math inline">\(\mathcal{B}\)</span> 构成 <span class="math inline">\(\mathbb{R}^1\)</span> 上的一个拓扑基且该拓扑不是第二可数空间.</p></blockquote><p><strong>证明</strong>: <span class="math inline">\(\mathcal{B}\)</span> 构成拓扑基的证明是平凡的, 不再赘述. 以下证明该空间不是第二可数的. <strong>反证法.</strong> 设有可数拓扑基 $ &amp;#123; _i &amp;#125; $, 设 <span class="math inline">\(a_i=\sup\limits_{x\in\alpha_i}x\)</span> (<span class="math inline">\(a_i\)</span> 可取 <span class="math inline">\(\infty\)</span>), 则 <span class="math inline">\(a_i\)</span> 只有可数个, 于是 <span class="math inline">\(\exists\)</span> 无理数 <span class="math inline">\(\beta\notin \&amp;#123; a_i \&amp;#125; _{i\in\mathbb{N}}\)</span>. 由条件, 可设 <span class="math inline">\((\beta^{-1},\beta]=\bigcup\limits_{j} \alpha_j\)</span>. 于是 <span class="math inline">\(\beta=\sup\limits_{x\in\bigcup_j\alpha_j}x=\max\limits_j a_j\)</span>, 与 <span class="math inline">\(\beta\notin \&amp;#123; a_i \&amp;#125; _{i\in\mathbb{N}}\)</span> 矛盾. 于是不存在可数拓扑基, 因而不是 <span class="math inline">\(C_2\)</span> 空间.</p><h3 id="mathbbq-作为-mathbbe1-的子空间不是局部紧的"><span class="math inline">\(\mathbb{Q}\)</span> 作为 <span class="math inline">\(\mathbb{E}^1\)</span> 的子空间不是局部紧的</h3><blockquote><p>证明有理数作为 <span class="math inline">\(\mathbb{E}^1\)</span> 不是局部紧致的.</p></blockquote><p><strong>证明</strong>: 取 <span class="math inline">\(q\in \mathbb{Q}\)</span>, 只需要证明 <span class="math inline">\(q\)</span> 的任意邻域都不紧即可. 任取 <span class="math inline">\(\mathbb{Q}\)</span> 中包含 <span class="math inline">\(q\)</span> 的一个邻域, 则该邻域具有 <span class="math inline">\(U_q\cap\mathbb{Q}\)</span> 的形式, 其中 <span class="math inline">\(U_q\)</span> 是 <span class="math inline">\(q\)</span> 在 <span class="math inline">\(\mathbb{R}\)</span> 中的邻域. 故 <span class="math inline">\(U_q\)</span> 包含 <span class="math inline">\(q\)</span> 的连通分支必定具有区间 <span class="math inline">\(|a,b|\)</span> 的形式（开区间或闭区间）. 取无理数 <span class="math inline">\(\xi\in|a,b|\)</span>, 记 <span class="math inline">\(|a,b|\)</span> 中比 <span class="math inline">\(\xi\)</span> 小的有理数为 $ &amp;#123; a_1,a_2&amp;#125; $, 比 <span class="math inline">\(\xi\)</span> 大的有理数为 $ &amp;#123; b_1,b_2,&amp;#125; $, 则 $ &amp;#123; |a,a_i) &amp;#125; <em>{i}&amp;#123; (b_j,b| &amp;#125; </em>{j}$ 构成 <span class="math inline">\(|a,b|\)</span> 的一个开覆盖, 且没有有限子覆盖. 于是 <span class="math inline">\(|a,b|\)</span> 不紧. 命题得证.</p><h3 id="师大拓扑学p47-8.">师大《拓扑学》P47 8.</h3><blockquote><p>设拓扑空间 <span class="math inline">\(X\)</span> 可以写成两个开集 <span class="math inline">\(X_1\)</span>, <span class="math inline">\(X_2\)</span> 的并, 并且 <span class="math inline">\(X_0=X_1\cap X_2\neq\varnothing\)</span> 道路连通, 证明 <span class="math inline">\(X\)</span> 道路连通当且仅当 <span class="math inline">\(X_1\)</span> 和 <span class="math inline">\(X_2\)</span> 都道路连通.</p></blockquote><p><strong>证明</strong>: 只需要证明 <span class="math inline">\(X_1\)</span> 道路连通. 由于 <span class="math inline">\(X_1\cap X_2\)</span> 道路连通, 以下只需证明 <span class="math inline">\(\forall p\in X_1\backslash X_2\)</span>, 存在 <span class="math inline">\(p\)</span> 到 <span class="math inline">\(X_1\cap X_2\)</span> 中某点的道路. 取 <span class="math inline">\(q\in X_2\)</span>, 则由 <span class="math inline">\(X\)</span> 道路连通, 任取 <span class="math inline">\(q\in X_2\)</span>, <span class="math inline">\(X\)</span> 中存在 <span class="math inline">\(p\to q\)</span> 的一条道路 <span class="math inline">\(a\)</span>, 即 <span class="math inline">\(a:X\to I\)</span>, s.t. <span class="math inline">\(a(0)=p\)</span>, <span class="math inline">\(a(1)=q\)</span>. 则 <span class="math inline">\(a^{-1}(X_1\cap X_2)\neq\varnothing\)</span>, 否则由 <span class="math inline">\(a\)</span> 的连续性, <span class="math inline">\(a^{-1}(X_1)\)</span> 和 <span class="math inline">\(a^{-1}(X_2)\)</span> 为 <span class="math inline">\(I\)</span> 的两个非空开集且 <span class="math inline">\(a^{-1}(X_1)\cup a^{-1}(X_2)=I\)</span>, 从而与 <span class="math inline">\(I\)</span> 的连通性矛盾. 取 <span class="math inline">\(t=\inf a^{-1}(X_1)\cap a^{-1}(X_2)\)</span>, 则 <span class="math inline">\([0,t]\subset a^{-1}(X_1)\)</span>. 由 <span class="math inline">\(a^{-1}(X_1)\)</span> 是开集知 <span class="math inline">\(\exists\epsilon&gt;0\)</span>, s.t. <span class="math inline">\([t,t+\epsilon)\subset a^{-1}(X_1)\)</span>. 于是 <span class="math inline">\(\exists t_1\in[t,t+\epsilon)\)</span>, s.t. <span class="math inline">\(a(t_1)\in X_1\cap X_2\)</span>. 即存在 <span class="math inline">\(p\to t_1\)</span> 的道路, 因而 <span class="math inline">\(X_1\)</span> 道路连通.</p><h3 id="粘合拓扑与并集的子空间拓扑">粘合拓扑与并集的子空间拓扑</h3><blockquote><p>若 <span class="math inline">\(X_\alpha\)</span> 是 <span class="math inline">\(Z\)</span> 的子空间, 给 <span class="math inline">\(\bigcup\limits_\alpha X_\alpha\)</span> 以 <span class="math inline">\(Z\)</span> 的子空间拓扑. 若 <span class="math inline">\(\alpha\)</span> 个数有限, 并且每个 <span class="math inline">\(X_\alpha\)</span> 在 <span class="math inline">\(\bigcup\limits_\alpha X_\alpha\)</span> 中闭, 则 <span class="math inline">\(\bigcup\limits_\alpha X_\alpha\)</span> 的子空间拓扑与粘合拓扑一致. 若 <span class="math inline">\(\alpha\)</span> 个数无限, 则结论不一定成立.</p></blockquote><p><strong>证明1</strong>: 平凡的构造是很容易的: 考虑 <span class="math inline">\(Z=\mathbb{E}^1\)</span>, $X_= &amp;#123; &amp;#125; $, <span class="math inline">\(\forall\alpha\in\mathbb{R}\)</span>, 则 <span class="math inline">\(Z=\bigcup\limits_\alpha X_\alpha\)</span>. 并集的子空间拓扑显然就是欧氏拓扑, 但粘合拓扑为 <span class="math inline">\(\mathbb{R}\)</span> 上的离散拓扑, 因而不相同.</p><p><strong>证明2</strong>: 非平凡的例子: 待补.</p>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拓扑学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>单调类定理</title>
      <link href="/2017/09/21/%E5%8D%95%E8%B0%83%E7%B1%BB%E5%AE%9A%E7%90%86/"/>
      <content type="html"><![CDATA[<h2 id="基础定义">基础定义</h2><h3 id="sigma-代数"><span class="math inline">\(\sigma\)</span> 代数</h3><p>称 <span class="math inline">\(\Omega\)</span> 的子集类 <span class="math inline">\(\mathscr{F}\)</span> 为 <span class="math inline">\(\Omega\)</span> 的 <span class="math inline">\(\sigma\)</span> 代数, 如果它满足:</p><ol type="1"><li><span class="math inline">\(\Omega\in\mathcal{F}\)</span>;</li><li>若 <span class="math inline">\(A\in\mathcal{F}\)</span>, 则 <span class="math inline">\(A^c\in\mathcal{F}\)</span>;</li><li>若 <span class="math inline">\(A_n\in\mathcal{F}\)</span>, <span class="math inline">\(n\in\mathbf{N}\)</span>, 则 <span class="math inline">\(\bigcup\limits_{n=1}^\infty A_n\in\mathcal{F}\)</span>.</li></ol><h3 id="lambda-pi-系"><span class="math inline">\(\lambda-\pi\)</span> 系</h3><h4 id="pi-系"><span class="math inline">\(\pi\)</span> 系</h4><p>称 <span class="math inline">\(\Omega\)</span> 的子集类 <span class="math inline">\(\Pi\)</span> 称为 <span class="math inline">\(\pi\)</span> 系, 如果它对交运算封闭.</p><h4 id="lambda-系"><span class="math inline">\(\lambda\)</span> 系</h4><p>称 <span class="math inline">\(\Omega\)</span> 的子集类 <span class="math inline">\(\Lambda\)</span> 称为 <span class="math inline">\(\lambda\)</span> 系, 如果:</p><ol type="1"><li><span class="math inline">\(\Omega\in\Lambda\)</span>;</li><li>对真差封闭: 即 <span class="math inline">\(\forall~A,B\in\Lambda\)</span>, s.t. <span class="math inline">\(A\subset B\)</span>, 总有 <span class="math inline">\(B\backslash A\in\Lambda\)</span>;</li><li>对不降序列的并封闭: 即 $ &amp;#123; A_n:n &amp;#125; $, <span class="math inline">\(A_n\uparrow\)</span>, 则 <span class="math inline">\(\bigcup\limits_{n=1}^\infty A_n\in\Lambda\)</span>.</li></ol><h2 id="集合形式的单调类定理">集合形式的单调类定理</h2><h3 id="引理-lambdapisigma">引理: <span class="math inline">\(\lambda+\pi=\sigma\)</span></h3><blockquote><p>若 <span class="math inline">\(\Omega\)</span> 子集类 <span class="math inline">\(\mathcal{C}\)</span> 同时为 <span class="math inline">\(\lambda\)</span> 系和 <span class="math inline">\(\pi\)</span> 系, 则 <span class="math inline">\(\mathcal{C}\)</span> 为 <span class="math inline">\(\sigma\)</span> 代数.</p></blockquote><p><strong>证明</strong>: 首先, 由 <span class="math inline">\(\mathcal{C}\)</span> 为 <span class="math inline">\(\lambda\)</span> 系可知 <span class="math inline">\(\Omega\in\mathcal{C}\)</span>, 且 <span class="math inline">\(\forall~A\in\mathcal{C}\)</span>, 均有 <span class="math inline">\(A\subset\Omega\)</span>, 于是 <span class="math inline">\(A^c=\Omega\backslash A\in\mathcal{C}\)</span>. 另一方面, 取 <span class="math inline">\(A_n\in\mathcal{C}\)</span>, <span class="math inline">\(n\in\mathbf{N}\)</span> 则 <span class="math inline">\(B_n=\bigcup\limits_{n=1}^\infty A_k\)</span>, <span class="math inline">\(n\in\mathbf{N}\)</span> 是不降集列, 于是由 <span class="math inline">\(A_k^c\in\mathcal{C}\)</span> 以及 <span class="math inline">\(\mathcal{C}\)</span> 是 <span class="math inline">\(\pi\)</span> 系, 可知 <span class="math inline">\(B_n^c=\bigcap\limits_{n=1}^\infty A_k^c\in\mathcal{C}\)</span>.</p><p>于是 <span class="math inline">\(B_n\in\mathcal{C}\)</span>, 由定义知, <span class="math inline">\(\bigcup\limits_{n=1}^\infty A_n=\bigcup\limits_{n=1}^\infty B_n\in\mathcal{C}\)</span>, 于是 <span class="math inline">\(\mathcal{C}\)</span> 为 <span class="math inline">\(\sigma\)</span> 代数.</p><h3 id="单调类定理">单调类定理</h3><blockquote><p>设 <span class="math inline">\(\Omega\)</span> 的子集类 <span class="math inline">\(\mathcal{C}\)</span> 是 <span class="math inline">\(\pi\)</span> 系, <span class="math inline">\(\Lambda(\mathcal{C})\)</span> 是包含 <span class="math inline">\(\mathcal{C}\)</span> 的最小 <span class="math inline">\(\lambda\)</span> 系, 则 <span class="math inline">\(\Lambda(\mathcal{C})=\sigma(\mathcal{C})\)</span>.</p></blockquote><p><strong>证明</strong>: 由于 <span class="math inline">\(\sigma\)</span> 代数一定是 <span class="math inline">\(\lambda\)</span> 系, 故 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 为 <span class="math inline">\(\lambda\)</span> 系, 由 <span class="math inline">\(\Lambda(\mathcal{C})\)</span> 的最小性, 有 <span class="math inline">\(\sigma(\mathcal{C})\supset\Lambda(\mathcal{C})\)</span>.</p><p>于是只需要证明 <span class="math inline">\(\sigma(\mathcal{C})\subset\Lambda(\mathcal{C})\)</span>, 由 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 的最小性, 只需要证明 <span class="math inline">\(\Lambda(\mathcal{C})\)</span> 为 <span class="math inline">\(\sigma\)</span> 代数. 又由于 <span class="math inline">\(\Lambda(\mathcal{C})\)</span> 为 <span class="math inline">\(\lambda\)</span> 系, 故只需要证明 <span class="math inline">\(\Lambda(\mathcal{C})\)</span> 为一个 <span class="math inline">\(\pi\)</span> 系.</p><p>即只需证明 <span class="math inline">\(\forall~A, B\in\Lambda(\mathcal{C})\)</span>, <span class="math inline">\(A\cap B\in\Lambda(\mathcal{C})\)</span>.</p><p>**令 $_A= &amp;#123; B(): AB() &amp;#125; $, 则只需证明 <span class="math inline">\(\forall~A\in\Lambda(\mathcal{C})\)</span>, 有 <span class="math inline">\(\Lambda_A=\Lambda(\mathcal{C})\)</span> 即可.** 由于显然有 <span class="math inline">\(\Lambda_A\subset\Lambda(\mathcal{C})\)</span>, 故只需要证明 <span class="math inline">\(\Lambda_A\supset\Lambda(\mathcal{C})\)</span>.</p><p>考虑到 <span class="math inline">\(\Lambda(\mathcal{C})\)</span> 的最小性, 可按照如下三步证明:</p><ol type="1"><li><span class="math inline">\(\forall~A\in\Lambda(\mathcal{C})\)</span>, <span class="math inline">\(\Lambda_A\)</span> 是 <span class="math inline">\(\lambda\)</span> 系;</li><li><span class="math inline">\(\forall~A\in\mathcal{C}\)</span>, <span class="math inline">\(\Lambda_A=\Lambda(\mathcal{C})\)</span>;</li><li><span class="math inline">\(\forall~A\in\Lambda(\mathcal{C})\)</span>, <span class="math inline">\(\Lambda_A=\Lambda(\mathcal{C})\)</span>.</li></ol><p>证明第一条:</p><ol type="1"><li>由 <span class="math inline">\(\Lambda_A\)</span> 的定义, <span class="math inline">\(\Omega\in\Lambda_A\)</span>;</li><li><span class="math inline">\(\forall~B, C\in\Lambda_A\)</span>, s.t. <span class="math inline">\(B\subset C\)</span>, 则由 <span class="math inline">\(\Lambda_A\)</span> 的定义有 <span class="math inline">\(A\cap C,A\cap B\in\Lambda(\mathcal{C})\)</span>, 同时易得 <span class="math inline">\(A\cap B\subset A\cap C\)</span>. 由于 <span class="math inline">\(\Lambda(\mathcal{C})\)</span> 是 <span class="math inline">\(\lambda\)</span> 系, 故对真差封闭, 即 <span class="math inline">\(A\cap(C\backslash B)=(A\cap C)\backslash(A\cap B)\in\Lambda(\mathcal{C})\)</span>, 于是 <span class="math inline">\(C\backslash B\in\Lambda_A\)</span>;</li><li><span class="math inline">\(\forall~ \&amp;#123; A_n \&amp;#125; \subset\Lambda_A\)</span>, <span class="math inline">\(A_n\uparrow\)</span>, 则 <span class="math inline">\(A\cap A_n\in\Lambda(\mathcal{C})\)</span> 且 <span class="math inline">\(A\cap A_n\uparrow\)</span>. 因此有 <span class="math inline">\(A\cap(\bigcup_{n=1}^\infty A_n)=\bigcup_{n=1}^\infty(A\cap A_n)\in\Lambda(\mathcal{C})\)</span>.</li></ol><p>于是 <span class="math inline">\(\forall~A\in\Lambda(\mathcal{C})\)</span>, <span class="math inline">\(\Lambda_A\)</span> 是 <span class="math inline">\(\lambda\)</span> 系.</p><p>证明第二条: <strong>只需要证明 <span class="math inline">\(\Lambda_A\supset\mathcal{C}\)</span>.</strong> <span class="math inline">\(\forall~B\in\mathcal{C}\)</span>, 由于 <span class="math inline">\(\mathcal{C}\)</span> 是 <span class="math inline">\(\pi\)</span> 系, 故 <span class="math inline">\(A\cap B\in\mathcal{C}\subset\Lambda(\mathcal{C})\)</span>, 于是 <span class="math inline">\(\mathcal{C}\subset\Lambda_A\)</span>.</p><p>证明第三条: 仍然只需要证明 <span class="math inline">\(\mathcal{C}\subset\Lambda_A\)</span>. <strong>即需要证明 <span class="math inline">\(\forall~B\in\mathcal{C}\)</span>, <span class="math inline">\(B\in\Lambda_A\)</span>. 由于此时 <span class="math inline">\(A\)</span> 不一定在 <span class="math inline">\(\mathcal{C}\)</span> 中, 故无法对 <span class="math inline">\(A\)</span> 使用第二条中的方法. 但由于 <span class="math inline">\(B\in\mathcal{C}\)</span>, 故可以对 <span class="math inline">\(B\)</span> 使用第二条中使用的方法, 操作如下:</strong></p><p>取 <span class="math inline">\(A\in\Lambda(\mathcal{C})\)</span>, 则 <span class="math inline">\(\forall~B\in\mathcal{C}\)</span>, 由上条可知 <span class="math inline">\(A\in\Lambda_B\)</span>, 又由 <span class="math inline">\(\Lambda_B\)</span> 的定义可知 <span class="math inline">\(A\cap B\in\Lambda(\mathcal{C})\)</span>, 于是由 <span class="math inline">\(\Lambda_A\)</span> 的定义, <span class="math inline">\(B\in\Lambda_A\)</span>, 于是 <span class="math inline">\(\mathcal{C}\subset\Lambda_A\)</span>.</p><p>综上所述, 原命题得证.</p><h2 id="lambda-pi-系方法"><span class="math inline">\(\lambda-\pi\)</span> 系方法</h2><h3 id="lambda-pi-系方法-1"><span class="math inline">\(\lambda-\pi\)</span> 系方法</h3><p>在定理的证明过程中, “要证明一些元素的集合满足性质 <span class="math inline">\(p\)</span>, 就先把满足性质 <span class="math inline">\(p\)</span> 的元素集合设出来, 再证明该集合与原集合相等” 的方法常常按照如下方法操作:</p><p>已知 <span class="math inline">\(\mathcal{C}\)</span> 中元素具有性质 <span class="math inline">\(p\)</span>, 要证明 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 中元素也具有性质 <span class="math inline">\(p\)</span>, 则可以令 $= &amp;#123; B:Bp &amp;#125; $, 则 <span class="math inline">\(\Lambda\supset\mathcal{C}\)</span>, 然后证明 <span class="math inline">\(\mathcal{C}\)</span> 是 <span class="math inline">\(\pi\)</span> 系, 再证明 <span class="math inline">\(\Lambda\)</span> 是 <span class="math inline">\(\lambda\)</span> 系, 即可证明 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 中元素满足性质 <span class="math inline">\(p\)</span>.</p><p>这样的方法称为 <span class="math inline">\(\lambda-\pi\)</span> 系方法.</p><h3 id="lambda-pi-系方法的应用"><span class="math inline">\(\lambda-\pi\)</span> 系方法的应用</h3><h4 id="测度扩张定理的证明">测度扩张定理的证明</h4><p>证明见《测度与概率》（严士健、刘秀芳. 北京师范大学出版社.）P66-67 部分. 不再赘述.</p><h4 id="pi-系上的有限测度"><span class="math inline">\(\pi\)</span> 系上的有限测度</h4><blockquote><p>设 <span class="math inline">\(\mu,\nu\)</span> 是可测空间 <span class="math inline">\((\Omega,\mathcal{F})\)</span> 上的两个有限测度, <span class="math inline">\(\mathcal{C}\)</span> 为 <span class="math inline">\(\pi\)</span> 系, <span class="math inline">\(\Omega\in\mathcal{C}\)</span> 且 <span class="math inline">\(\sigma(\mathcal{C})=\mathcal{F}\)</span>. 若 <span class="math inline">\(\mu, \nu\)</span> 在 <span class="math inline">\(\mathcal{C}\)</span> 上一致, 则 <span class="math inline">\(\mu,\nu\)</span> 在 <span class="math inline">\(\mathcal{F}\)</span> 上也一致.</p></blockquote><p><strong>分析</strong>: 　　<span class="math inline">\(\mathcal{C}\subset\Lambda\)</span>, 要证明 <span class="math inline">\(\sigma(\mathcal{C})\subset\Lambda\)</span>, 考虑到 <span class="math inline">\(\mathcal{C}\)</span> 为 <span class="math inline">\(\pi\)</span> 系, 显然此处适用单调类定理.</p><p><strong>证明</strong>: 　　故证明 <span class="math inline">\(\Lambda\)</span> 是 <span class="math inline">\(\lambda\)</span> 系即可. 由单调类定理即得 <span class="math inline">\(\mathcal{F}\subset\Lambda\)</span>.</p><h4 id="另一形式的单调类定理">另一形式的单调类定理</h4><blockquote><p>　<span class="math inline">\(\Omega\)</span> 的子集类 <span class="math inline">\(\mathscr{M}\)</span> 称为 <span class="math inline">\(\Omega\)</span> 的<strong>单调类</strong>, 如果它满足:</p></blockquote><blockquote><ol type="1"><li>对不降集列的并封闭: 即 $ &amp;#123; A_n &amp;#125; _{n}$, 有 <span class="math inline">\(\bigcup\limits_{n=1}^\infty A_n\in\mathscr{M}\)</span>;</li><li>对不降集列的并封闭: 即 $ &amp;#123; A_n &amp;#125; _{n}$, 有 <span class="math inline">\(\bigcap\limits_{n=1}^\infty A_n\in\mathscr{M}\)</span>; 若 <span class="math inline">\(\mathscr{A}\)</span> 为 <span class="math inline">\(\Omega\)</span> 的集代数, 记包含 <span class="math inline">\(\mathscr{A}\)</span> 的最小单调类为 <span class="math inline">\(\mathfrak{M}(\mathscr{A})\)</span>, 则 <span class="math inline">\(\mathfrak{M}(\mathscr{A})=\sigma(\mathscr{A})\)</span>. 因而包含 <span class="math inline">\(\mathscr{A}\)</span> 的单调类必定包含 <span class="math inline">\(\sigma(\mathscr{A})\)</span>.</li></ol></blockquote><p><strong>分析</strong>: 　　先证明两个命题: 　　1. 若 <span class="math inline">\(\mathscr{A}\)</span> 同时为集代数和单调类, 则 <span class="math inline">\(\mathscr{A}\)</span> 是 <span class="math inline">\(\sigma\)</span> 代数; 　　2. <span class="math inline">\(\Omega\)</span> 的任意子集类 <span class="math inline">\(\mathcal{C}\)</span> 上的最小单调类存在. 其中第2条保证了单调类的 <span class="math inline">\(\mathfrak{M}(\mathscr{A})\)</span> 存在, 进而可利用第1条进行证明: 　　显然 <span class="math inline">\(\sigma(\mathscr{A})\)</span> 是单调类, 故 <span class="math inline">\(\sigma(\mathscr{A})\supset\mathfrak{M}(\mathscr{A})\)</span>, 故只需证 <span class="math inline">\(\sigma(\mathscr{A})\subset\mathfrak{M}(\mathscr{A})\)</span>; 　　为此只需证明 <span class="math inline">\(\mathfrak{M}(\mathscr{A})\)</span> 为包含 <span class="math inline">\(\sigma(\mathscr{A})\)</span> 的<span class="math inline">\(\sigma\)</span> 代数, 由命题 2, 只需证明 <span class="math inline">\(\mathfrak{M}(\mathscr{A})\)</span> 为集代数; 　　显然有 <span class="math inline">\(\Omega\in\mathscr{A}\subset\mathfrak{M}(\mathscr{A})\)</span>, 故只需证明 <span class="math inline">\(\mathfrak{M}(\mathscr{A})\)</span> 对差运算封闭. 接下来便是 <span class="math inline">\(\lambda-\pi\)</span> 证明的标准技巧: 　　令 $M_A= &amp;#123; B:B(), A-B,B-A() &amp;#125; $, 接下来分三步证明: 　　1. 证明 <span class="math inline">\(M_A\)</span> 是单调类, <span class="math inline">\(\forall A\)</span>; 　　2. <span class="math inline">\(\forall A\in\mathscr{A}\)</span>, <span class="math inline">\(M_A=\mathfrak{M}(\mathscr{A})\)</span>; 　　3. <span class="math inline">\(\forall A\in\mathfrak{M}(\mathscr{A})\)</span>, <span class="math inline">\(M_A=\mathfrak{M}(\mathscr{A})\)</span>. 以上即为证明思路.</p><p><strong>证明</strong>: 　　先证明两个引理.</p><blockquote><p><strong>引理 1</strong> 若 <span class="math inline">\(\mathscr{A}\)</span> 为 <span class="math inline">\(\Omega\)</span> 的集代数且是单调类, 则 <span class="math inline">\(\mathscr{A}\)</span> 为 <span class="math inline">\(\sigma\)</span> 代数.</p></blockquote><p><strong>引理 1的证明</strong>: 　　只需证明对于可列并封闭: 对 <span class="math inline">\(\forall \&amp;#123; A_n \&amp;#125; _{n\in\mathbb{N}}\subset\mathscr{A}\)</span> 构造部分和集列 <span class="math inline">\(B_n=\bigcup\limits_{i=1}^n A_i\)</span> 即可.</p><blockquote><p><strong>引理 2</strong> <span class="math inline">\(\Omega\)</span> 的任意子集类 <span class="math inline">\(\mathcal{C}\)</span> 上的最小单调类存在.</p></blockquote><p><strong>引理 2的证明</strong>: 　　首先证明非空: <span class="math inline">\(\Omega\)</span> 的全体子集 <span class="math inline">\(\mathcal{C}\subset\mathscr{P}(\Omega)\)</span> 显然构成单调类, 故非空; 　　其次构造出来: 取包含 <span class="math inline">\(\mathcal{C}\)</span> 的所有单调类的交, 容易验证该集类是一个单调类. 　　综上, 包含 <span class="math inline">\(\mathcal{C}\)</span> 的最小单调类存在且为所有包含 <span class="math inline">\(\mathcal{C}\)</span> 的单调类的交.</p><p>由这两个引理即可证明定理: 　　令 $M_A= &amp;#123; B:B(), A-B,B-A() &amp;#125; $, 只需证明 <span class="math inline">\(M_A=\mathfrak{M}(\mathscr{A})\)</span>, <span class="math inline">\(\forall A\in\mathfrak{M}(\mathscr{A})\)</span>. 接下来分三步证明: 　　1. 证明 <span class="math inline">\(M_A\)</span> 是单调类, <span class="math inline">\(\forall A\)</span>; 　　2. <span class="math inline">\(\forall A\in\mathscr{A}\)</span>, 证明 <span class="math inline">\(M_A=\mathfrak{M}(\mathscr{A})\)</span>; 　　3. <span class="math inline">\(\forall A\in\mathfrak{M}(\mathscr{A})\)</span>, 证明 <span class="math inline">\(M_A=\mathfrak{M}(\mathscr{A})\)</span>. 　　 <strong>1. 证明 <span class="math inline">\(M_A\)</span> 是单调类, <span class="math inline">\(\forall A\)</span></strong> 　　取 <span class="math inline">\(A\in\mathfrak{M}(\mathscr{A})\)</span>, <span class="math inline">\(\forall \&amp;#123; B_n \&amp;#125; _{n\in\mathbb{N}}\uparrow\subset M_A\)</span>, 由 <span class="math inline">\(\mathfrak{M}(\mathscr{A})\)</span> 的定义即有 <span class="math inline">\(A-B_n,B_n-A,B_n\in\)</span>, 同时显然有 <span class="math inline">\(B_n-A\uparrow\)</span>, <span class="math inline">\(A-B_n\downarrow\)</span>. 由于 <span class="math inline">\(\mathfrak{M}(\mathscr{A})\)</span> 是单调类, 故 <span class="math inline">\(\bigcup\limits_{n=1}^\infty B_n\in\mathfrak{M}(\mathscr{A})\)</span>. 　　同时还有: <span class="math display">\[\begin{align}A-\bigcup\limits_{n=1}^\infty B_n &amp;= A\cap\left(\bigcap\limits_{n=1}^\infty B_n^c\right) \\&amp;= \bigcap_{n=1}^\infty (A\cap B_n^c) \\&amp;= \bigcap_{n=1}^\infty (A-B_n) \in\mathfrak{M}(\mathscr{A})~; \\\left(\bigcup\limits_{N=1}^\infty B_n\right)-A &amp;= \bigcup\limits_{n=1}^\infty (B_n-A)\in\mathfrak{M}(\mathscr{A})~.\end{align}\]</span> 　　于是有 <span class="math inline">\(\bigcup\limits_{n=1}^\infty B_n\in M_A\)</span>, 即 <span class="math inline">\(M_A\)</span> 对上升集列的并封闭. 　　同理可证 <span class="math inline">\(M_A\)</span> 对下降集列的交也封闭. 即 <span class="math inline">\(M_A\)</span> 是单调类.</p><p><strong>2. <span class="math inline">\(\forall A\in\mathscr{A}\)</span>, 证明 <span class="math inline">\(M_A=\mathfrak{M}(\mathscr{A})\)</span></strong> 　　若 <span class="math inline">\(A\in\mathscr{A}\)</span>, 则对 <span class="math inline">\(\forall B\in\mathscr{A}\)</span>, 有 <span class="math inline">\(A-B,B-A\in\mathscr{A}\subset\mathfrak{M}(\mathscr{A})\)</span>, 由 <span class="math inline">\(M_A\)</span> 的定义知 <span class="math inline">\(B\in M_A\)</span>, 即 <span class="math inline">\(\mathfrak{M}(\mathscr{A})\subset M_A\)</span>. 　　另一方面, 由上条知 <span class="math inline">\(M_A\)</span> 为包含 <span class="math inline">\(\mathscr{A}\)</span> 的单调类, 故 <span class="math inline">\(\mathfrak{M}(\mathscr{A})\subset M_A\)</span>, 故有 <span class="math inline">\(M_A=\mathfrak{M}(\mathscr{A})\)</span>.</p><p><strong>3. <span class="math inline">\(\forall A\in\mathfrak{M}(\mathscr{A})\)</span>, 证明 <span class="math inline">\(M_A=\mathfrak{M}(\mathscr{A})\)</span></strong> 　　考虑 <span class="math inline">\(B\in\mathfrak{M}(\mathscr{A})\)</span>, 则对 <span class="math inline">\(\forall A\in\mathscr{A}\)</span>, 由上条知 <span class="math inline">\(M_A=\mathfrak{M}(\mathscr{A})\)</span>, 于是 <span class="math inline">\(B\in M_A\)</span>. 进一步由 <span class="math inline">\(M_A\)</span> 的定义有 <span class="math inline">\(B-A,A-B\in\mathfrak{M}(\mathscr{A})\)</span>. 　　又由于 <span class="math inline">\(\mathscr{A}\subset\mathfrak{M}(\mathscr{A})\)</span>, 故 <span class="math inline">\(A\in\mathfrak{M}(\mathscr{A})\)</span>, 结合 <span class="math inline">\(M_B\)</span> 的定义有 <span class="math inline">\(A\in M_B\)</span>. 　　即 <span class="math inline">\(\forall A\in\mathscr{A}\)</span>, 总有 <span class="math inline">\(A\in M_B\)</span>. 于是 <span class="math inline">\(\mathscr{A}\subset M_B\)</span>. 即 <span class="math inline">\(M_B\)</span> 是包含 <span class="math inline">\(\mathscr{A}\)</span> 的单调类, 于是 <span class="math inline">\(\mathfrak{M}(\mathscr{A})\subset M_B\)</span>. 　　结合 <span class="math inline">\(M_B\subset \mathfrak{M}(\mathscr{A})\)</span>, 即有 <span class="math inline">\(M_B=\mathfrak{M}(\mathscr{A})\)</span>, <span class="math inline">\(\forall B\in\mathfrak{M}(\mathscr{A})\)</span>. 　　 <strong>综上所述,</strong> 若 <span class="math inline">\(\mathscr{A}\)</span> 为集代数, 则包含 <span class="math inline">\(\mathscr{A}\)</span> 的最小 <span class="math inline">\(\sigma\)</span> 代数与包含 <span class="math inline">\(\mathscr{A}\)</span> 的最小单调类相同.</p><h2 id="函数形式的单调类定理">函数形式的单调类定理</h2><h3 id="mathscrl-系"><span class="math inline">\(\mathscr{L}\)</span> 系</h3><p>设 <span class="math inline">\(\mathscr{L}\)</span> 是定义在 <span class="math inline">\(\Omega\)</span> 上的广义实函数类, 满足: <span class="math inline">\(f\in\mathscr{L}\Rightarrow f^+,f^-\in\mathscr{L}\)</span>. 函数族 <span class="math inline">\(L\)</span> 称为 <span class="math inline">\(\mathscr{L}\)</span>, 如果满足: 1. <span class="math inline">\(1\in L\)</span>; 2. <span class="math inline">\(L\)</span> 中有限个函数的线性组合(如果有意义)属于 <span class="math inline">\(L\)</span>; 3. 若 <span class="math inline">\(f_n\in L\)</span>, <span class="math inline">\(n\in\mathbb{N}\)</span>, <span class="math inline">\(0\leqslant f_n\uparrow f\)</span>, <span class="math inline">\(f\)</span> 有界或 <span class="math inline">\(f\in\mathscr{L}\)</span>, 则 <span class="math inline">\(f\in L\)</span>.</p><h3 id="单调类定理-1">单调类定理</h3><blockquote><p>若 <span class="math inline">\(\mathscr{L}\)</span> 系 <span class="math inline">\(L\)</span> 包含一 <span class="math inline">\(\pi\)</span> 系 <span class="math inline">\(\mathcal{C}\)</span> 中任意集合的示性函数, 则 <span class="math inline">\(L\)</span> 包含所有属于 <span class="math inline">\(\mathscr{L}\)</span> 的 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 可测函数.</p></blockquote><p><strong>证明</strong>: 　　令 $= &amp;#123; A: I_AL &amp;#125; $, 则由 <span class="math inline">\(\mathscr{L}\)</span> 系定义可知 <span class="math inline">\(\Omega\in\Lambda\)</span>, <span class="math inline">\(\Lambda\)</span> 对真差封闭并且对不降集列的并封闭, 因而 <span class="math inline">\(\Lambda\)</span> 为 <span class="math inline">\(\lambda\)</span> 系. 又由于 <span class="math inline">\(\mathcal{C}\subset\Lambda\)</span>, 且 <span class="math inline">\(\mathcal{C}\)</span> 为 <span class="math inline">\(\pi\)</span> 系, 结合集合形式的单调类定理可知 <span class="math inline">\(\sigma(\mathcal{C})\subset\Lambda\)</span>, 故 $ &amp;#123; I_A: A() &amp;#125; L$. 由定义可知 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 上的任意简单函数在 <span class="math inline">\(L\)</span> 中. 　　设 <span class="math inline">\(f\)</span> 为 <span class="math inline">\(\mathscr{L}\)</span> 中非负 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 可测函数, 则存在非负不降 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 简单函数列 <span class="math inline">\(f_n\uparrow f\)</span>. 由于 <span class="math inline">\(L\)</span> 是 <span class="math inline">\(\mathscr{L}\)</span> 系, 故 <span class="math inline">\(f\in L\)</span>. 　　若 <span class="math inline">\(f\in\mathscr{L}\)</span> 且 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 可测, 则由 <span class="math inline">\(\mathscr{L}\)</span> 的定义可知 <span class="math inline">\(f^+,f^-\in\mathscr{L}\)</span> 且非负 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 可测, 于是 <span class="math inline">\(f^+,f^-\in L\)</span>, 结合 <span class="math inline">\(f=f^+-f^-\)</span> 有意义及定义可知 <span class="math inline">\(f\in L\)</span>. 定理得证. 　　 ## <span class="math inline">\(\mathscr{L}\)</span> 系方法</p><h3 id="mathscrl-系方法"><span class="math inline">\(\mathscr{L}\)</span> 系方法</h3><p>要想证明某一函数族 <span class="math inline">\(F\)</span> 具有某种性质 <span class="math inline">\(p\)</span>, 为此设一个函数族 <span class="math inline">\(\mathscr{L}\)</span>, s.t. $L= &amp;#123; f: 函数 f 具有性质 p &amp;#125; $ 为一个 <span class="math inline">\(\mathscr{L}\)</span> 系. 再引入一个 <span class="math inline">\(\pi\)</span> 系 <span class="math inline">\(\mathcal{C}\)</span>, s.t. <span class="math inline">\(\mathscr{L}\)</span> 中的 <span class="math inline">\(\sigma(\mathcal{C})\)</span> 可测函数类包含 <span class="math inline">\(F\)</span>.</p><p>以上两步完成之后, 由单调类定理, 只要证明 <span class="math inline">\(\forall A\in\mathcal{C}\)</span>, <span class="math inline">\(I_A\in L\)</span> 即可. 这种方法被称为 <span class="math inline">\(\mathscr{L}\)</span> 系方法.</p>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数理统计基础知识</title>
      <link href="/2017/09/17/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <content type="html"><![CDATA[<h2 id="几句废话">几句废话</h2><p>数理统计课程使用的教材是王兆军、邹长亮所著《数理统计教程》内容比较混乱零散, 故将一些内容简单整理.</p><h2 id="基本概念">基本概念</h2><h3 id="统计量">统计量</h3><h4 id="样本均值和样本方差">样本均值和样本方差</h4><p>设 <span class="math inline">\(X_1,\cdots,X_n\)</span> 为样本, 则</p><p><span class="math display">\[\overline{X}=\frac{1}{n}\sum\limits_{i=1}^nX_i,\quad S_n^2=\frac{1}{n-1}\sum\limits_{i=1}^n(X_i-\overline{X})^2\]</span></p><p>分别称为样本均值和样本方差.</p><h4 id="样本相关系数">样本相关系数</h4><p>设 <span class="math inline">\(\binom{X_1}{Y_1},\cdots,\binom{X_n}{Y_n}\)</span>, 则</p><p><span class="math display">\[r(X,Y)=\frac{ \sum\limits_{i=1}^n (X_i-\overline{X})(Y_i-\overline{Y}) }{ \sqrt{ \sum\limits_{i=1}^n(X_i-\overline{X})^2\sum\limits_{i=1}^n(Y_i-\overline{Y})^2 } }\]</span></p><p>称为 <span class="math inline">\((X,Y)\)</span> 间的样本相关系数.</p><h4 id="样本-k-阶矩">样本 <span class="math inline">\(k\)</span> 阶矩</h4><p>称 <span class="math inline">\(a_k=\frac{1}{n}\sum\limits_{i=1}^nX_i^k\)</span> 与 <span class="math inline">\(m_k=\frac{1}{n}\sum\limits_{i=1}^n(X_i-\overline{X})^k\)</span> 为样本<span class="math inline">\(k\)</span>阶原点矩和样本<span class="math inline">\(k\)</span>阶中心矩.</p><h2 id="经验分布函数">经验分布函数</h2><h3 id="定义">定义</h3><p>设 <span class="math inline">\(X_1,\cdots,X_n\)</span> 为取自总体分布函数为 <span class="math inline">\(F(x)\)</span> 的样本, <span class="math inline">\(X_{(1)}\leqslant\cdots\leqslant X_{(n)}\)</span> 为其次序统计量, 则称</p><p><span class="math display">\[F_n(x)=\frac{1}{n}\sum\limits_{i=1}^nI_{X_i&lt; x}=\begin{cases}0, &amp;x\leqslant X_{(1)}, \\\frac{k}{n}, &amp;X_{(k)}&lt; x\leqslant X_{(k+1)},k=1,\cdots,k-1, \\1, &amp; x&gt; X_{(n)}.\end{cases}\]</span></p><p>为样本 <span class="math inline">\(X_1,\cdots,X_n\)</span> 的经验分布函数.</p><h3 id="性质">性质</h3><p>当样本为iid样本时, <span class="math inline">\(F_n(x)\)</span> 有如下性质:</p><ol type="1"><li><p><span class="math inline">\(F_n(x)\xrightarrow{P}F(x),~\forall x\in\mathbf{R}\)</span>;</p></li><li><p><span class="math inline">\(E(F_n(x)-F(x))^2\rightarrow 0,~\forall x\in\mathbf{R}\)</span>;</p></li><li><p><span class="math inline">\(P \&amp;#123; \lim\limits_{n\to\infty}F_n(x)=F(x) \&amp;#125; =1,~\forall x\in\mathbf{R}\)</span>.</p></li></ol><h2 id="抽样分布">抽样分布</h2><h3 id="正态分布的和与均值">正态分布的和与均值</h3><p>设 <span class="math inline">\(X_1,\cdots,X_n\)</span> 为来自 <span class="math inline">\(N(\mu,\sigma^2)\)</span> 的iid样本, 则:</p><p><span class="math display">\[\overline{X}\sim N(\mu,\frac{\sigma^2}{n}),\quad T=\sum\limits_{i=1}^nc_iX_i\sim N(\mu\sum\limits_{i=1}^nc_i,\sigma^2\sum\limits_{i=1}^nc_i^2).\]</span></p><h3 id="chi2-分布"><span class="math inline">\(\chi^2\)</span> 分布</h3><h4 id="定义-1">定义</h4><p>设 <span class="math inline">\(X_1,\cdots,X_n\)</span> 为来自 <span class="math inline">\(N(0,1)\)</span> 的iid样本, 则称随机变量</p><p><span class="math display">\[\xi=\sum\limits_{i=1}^nX_i^2\]</span></p><p>所服从的分布为自由度为 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(\chi^2\)</span> 分布, 记为 <span class="math inline">\(\xi\sim\chi^2(n)\)</span>.</p><h4 id="性质-1">性质</h4><ol type="1"><li><p><span class="math inline">\(E\xi=n\)</span>, <span class="math inline">\({\rm Var}~\xi=2n\)</span>;</p></li><li><p>设 <span class="math inline">\(\xi\sim\chi^2(m)\)</span>, <span class="math inline">\(\eta\sim\chi^2(n)\)</span>, 且二者独立, 则 <span class="math inline">\(\xi+\eta\sim\chi^2(m+n)\)</span>;</p></li><li><p>设 <span class="math inline">\(X_1,\cdots,X_n\)</span> 为来自 <span class="math inline">\(N(\mu,\sigma^2)\)</span> 的iid样本, 则 <span class="math inline">\((n-1)S_n^2/\sigma^2\sim\chi^2(n-1)\)</span> 且 <span class="math inline">\(\overline{X}\)</span> 与 <span class="math inline">\(S_n^2\)</span> 独立.</p></li></ol><h3 id="t-分布"><span class="math inline">\(t\)</span> 分布</h3><h4 id="定义-2">定义</h4><p>设 <span class="math inline">\(\xi\sim N(0,1)\)</span>, <span class="math inline">\(\eta\sim\chi^2(n)\)</span>, 且 <span class="math inline">\(\xi\)</span>, <span class="math inline">\(\eta\)</span> 相互独立, 则称随机变量</p><p><span class="math display">\[T=\frac{\xi}{\sqrt{\eta/n}}\]</span></p><p>服从自由度为 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(t\)</span> 分布, 记为 <span class="math inline">\(T\sim t(n)\)</span>.</p><h4 id="性质-2">性质</h4><ol type="1"><li><p><span class="math inline">\(t(n)\)</span> 的PDF关于 <span class="math inline">\(y\)</span> 轴对称, 且 <span class="math inline">\(\lim\limits_{|x|\to\infty}f(x)=0\)</span>;</p></li><li><p>设 <span class="math inline">\(\xi\sim t(n)\)</span>, <span class="math inline">\(n&gt;2\)</span>, 则 <span class="math inline">\(E\xi=0\)</span>, <span class="math inline">\({\rm Var}~\xi=\frac{n}{n-2}\)</span>;</p></li><li><p>设 <span class="math inline">\(\xi\sim N(\mu,\sigma^2)\)</span>, <span class="math inline">\(\eta/\sigma^2\sim\chi^2(n)\)</span>, 且二者相互独立, 则 <span class="math inline">\(T=\frac{\xi-mu}{\sqrt{\eta/mu}}\sim t(n)\)</span>.</p></li></ol><h3 id="f-分布"><span class="math inline">\(F\)</span> 分布</h3><h4 id="定义-3">定义</h4><p>设 <span class="math inline">\(\xi,\eta\)</span> 是自由度分别为 <span class="math inline">\(m,n\)</span> 的独立的 <span class="math inline">\(\chi^2\)</span> 随机变量, 则称随机变量</p><p><span class="math display">\[F=\frac{\xi/m}{\eta/n}\]</span></p><p>服从自由度为 <span class="math inline">\((m,n)\)</span> 的 <span class="math inline">\(F\)</span> 分布, 记为 <span class="math inline">\(F\sim F(m,n)\)</span>.</p><h4 id="性质-3">性质</h4><ol type="1"><li><p>设 <span class="math inline">\(\xi\sim\chi^2(m)\)</span>, <span class="math inline">\(\eta\sim\chi^2(n)\)</span>, 且二者互相独立, 则 <span class="math inline">\(\xi+\eta\)</span> 与 <span class="math inline">\(\xi/\eta\)</span> 独立;</p></li><li><p>由定义易有 <span class="math inline">\(X\sim F(m,n) \Longleftrightarrow \frac{1}{X}\sim F(n,m)\)</span>.</p></li></ol>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 统计学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GRE阅读题目分析[4]</title>
      <link href="/2017/07/25/GRE%E9%98%85%E8%AF%BB%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%5B4%5D/"/>
      <content type="html"><![CDATA[<h2 id="题型辨识">题型辨识</h2><h3 id="事实信息类">事实信息类</h3><h4 id="事实信息">事实信息</h4><ol type="1"><li>单纯事实信息<ul><li>The passage makes which of the following claims (about X)?</li><li>The passage claims which of the following (about X)?</li><li>The passage suggests which of the following about X?</li><li>The passage would probably agree with which of the following claims (about X)?</li><li>(According to the passage,) which of the following claims (about X) is true?</li><li>(According to the passage,) X.</li><li>Which of the following best characterizes the “X” that the author refers to?</li><li>Which of the following claims about X can be inferred from the passage?</li><li>It can be inferred from the passage that X.</li><li>It can be inferred that the author would agree with which of the following (claims about X)?</li><li>Information presented in the passage suggests which of the following about X?</li><li>Information in the passage best supports which of the following claims about X?</li><li>With which of the following claims (about X) (discussed in the passage) would the author most likely agree?</li></ul></li><li>结合逻辑的事实信息<ul><li>According to the passage, X had which of the following effects for …?</li><li>According to the passage, the primary purpose of X is to …</li><li>The passage mentions which of the following as one of the reasons X?</li><li>According to the passage, X in that …</li></ul></li><li>结合视角的事实信息<ul><li>According to the passage, S would agree that X.</li><li>According to the passage, which of the following is the most accurate statement of what S about Earth’s X?</li><li>The passage implies that S1 attributed which of the following beliefs to S2?</li><li>The author of the passage and S would most likely agree/disagree with which of the following (claims about X)?</li></ul></li></ol><h4 id="反事实信息">反事实信息</h4><ul><li>Each of the following is mentioned in the passage as X EXCEPT for the …</li></ul><h4 id="问题">问题</h4><ul><li>The passage supplies information for answering which of the following questions?</li></ul><h4 id="反问题">反问题</h4><ul><li>The passage supplies information for answering all of the folliwing questions EXCEPT:</li></ul><h4 id="加强">加强</h4><ul><li>Which of the following statements, if true, wuold provide the strongest support/most strengthen X?</li></ul><h4 id="削弱">削弱</h4><ul><li>Which of the following if true, would most call into question/pose the greatest challenge to/most tend to weaken X?</li><li>Which of the following is the most logical objection to X?</li><li>X would be most seriously undermined if which of the following were true?</li><li>Which of the following, if true, would provide the LEAST support for X?</li></ul><h4 id="假设">假设</h4><ul><li>In the highlighted portion of the passage, the S assumes that …</li><li>The claim in the highlighted sentence assumes which of the following about X?</li></ul><h4 id="态度">态度</h4><ul><li>The attitude of the author of the passage toward X can best be described as …</li><li>Which of the following best describes the author’s attitude toward X?</li></ul><h4 id="有保留的支持">有保留的支持</h4><ul><li>Qualified approval: 有让步存在.</li></ul><h3 id="信息功能类">信息功能类</h3><h4 id="信息功能">信息功能</h4><ul><li>The author mentions X most primarily/probably/most likely in order to …</li><li>By quoting X, the author of the passage most clearly succeeds in …</li><li>Which of the following best describes the function of the highlighted sentence (in the passage)?</li><li>(In the passage,) the function of the highlighted portion is to …</li><li>(In the passage,) the mention of X serves primarily to …</li><li>(In the passage,) the highlighted portion servers primarily to …</li><li>The highlighted sentence has which of the following functions in the passage?</li><li>The highlighted sentence exemplifies which of the following?</li><li>X is presented in the poassage primarily as [存疑]</li></ul><h4 id="选句子">选句子</h4><ul><li>Select the sentence that …</li><li>Click on the sentence in the passage that …</li></ul><h4 id="论证结构">论证结构</h4><ul><li>Which of the following best characterizes/describes the organization of the passage as a whole?</li></ul><h3 id="主旨">主旨</h3><ul><li>Which of the following best describes the main/central idea of the passage?</li><li>The primary purpose of the passage is to (discuss which of the following?)</li><li>The passage is primarily concerned with (doing which of the following)</li><li>The passage is structured to lead to the conclusion that …</li><li>Which of the following generalizations most directly underlies the author’s central point?</li></ul><h3 id="词汇">词汇</h3><ul><li>In the context in which it appears, “X” most nearly means …</li><li>Replacement of the word “X” with which of the following results in the least change in meaning for the passage?</li></ul><h3 id="类比">类比</h3><ul><li>Which of the following is most similar to/is most closely analogous to/most closely parallels X?</li></ul>]]></content>
      
      <categories>
          
          <category> 学♂习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GRE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GRE填空思路分析[3]——推理的线索来源·同义线索</title>
      <link href="/2017/07/24/GRE%E5%A1%AB%E7%A9%BA%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90%5B3%5D%E2%80%94%E2%80%94%E6%8E%A8%E7%90%86%E7%9A%84%E7%BA%BF%E7%B4%A2%E6%9D%A5%E6%BA%90%C2%B7%E5%90%8C%E4%B9%89%E7%BA%BF%E7%B4%A2/"/>
      <content type="html"><![CDATA[<p>同义重复线索一般有四种: <strong>简单重复解释、因果关系、递进关系、指代关系</strong>.</p><h2 id="简单重复解释">简单重复解释</h2><p>尽管是“简单”重复解释, 但此类题目并不简单.</p><p>简单重复解释的标志一般有以下几种:</p><ul><li>冒号: 对相关线索的解释;</li><li>分号: 表示分号前后信息的重复;</li><li>修饰解释结构:<ul><li>……, 解释成分, (定语从句/同位语从句/分词短语);</li><li>…… n., 解释成分.</li></ul></li></ul><p>直白地说, 简单重复解释就是两部分内容一致.</p><p>例如下面一道难题:</p><blockquote><p>例: In modern times, friendship has become a ____ relationship: a form of connection in terms of which all are understood and against which all are measured. A. conciliatory B. mercenary C. paradigmatic D. contentious E. supplementary</p></blockquote><p>文章在冒号前的部分指出: 现在, 友谊成为了一种 X 的关系. 冒号后则指出: 所有的东西都是通过友谊来理解和度量的. 本题的难点主要就在于冒号后句子的理解. in terms of 后面的 which 指代的是之前的 a form of connection. 同理, against 后的 which 也指的是这种特定的 connection. 由于 against 与 in terms of 中间用 and 连接, 实际上意思是类似的. 所以冒号后的整个句子意思为: 所有的(all)东西都是通过 friendship 来理解和度量的, 所以 X 应该是一个表示“标准”的词语. 故选择 C. paradigmatic 意为“典范”.</p><p>一道容易错的题目如下:</p><blockquote><p>例: Scholarly works on detective stories often begin with (i)____, suggesting that there is something vaguely wrong with adults who spend their time reading such f iction and certainly something (ii)____ those who devote energy to its analysis.</p></blockquote><table><thead><tr class="header"><th style="text-align: left;">Blank(i)</th><th style="text-align: left;">Blank(ii)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">A. chronologies</td><td style="text-align: left;">D. awry in</td></tr><tr class="even"><td style="text-align: left;">B. apologies</td><td style="text-align: left;">E. astute about</td></tr><tr class="odd"><td style="text-align: left;">C. synopses</td><td style="text-align: left;">F. courageous about</td></tr></tbody></table><p>文中虽然没有出现冒号和分号, 但在第一空后有一个 suggesting, 说明 suggesting 前后说的是同一件事.</p><ul><li>前: 关于侦探小说的研究时常以 X 开头;</li><li>后: and 前后同样应该说的是同一件事.<ul><li>前: adults 读侦探小说是错误的;</li><li>后: 在侦探小说的分析上耗费能量是 Y 的.</li></ul></li></ul><p>由 suggesting 后的句子的内部结构即可选出第二空为 D. awry in, 意为“错误”. 至此 suggesting 后的部分已经完整, 意为“读侦探小说是错误的”. 考虑第一空的答案, 只有 B. apologies 满足条件.</p><p>还有两道难题如下:</p><blockquote><p>例: The new art museum’s (i)____ building a ugurs well for that ambitious institution because it speaks of (ii)____ contemporary architecture on the part of the board of directors that may (iii)____ equal astuteness about contemporary art.</p></blockquote><table><thead><tr class="header"><th style="text-align: left;">Blank(i)</th><th style="text-align: left;">Blank(ii)</th><th style="text-align: left;">Blank(iii)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">A. nondescript</td><td style="text-align: left;">D. a discernment about</td><td style="text-align: left;">G. conceal</td></tr><tr class="even"><td style="text-align: left;">B. outstanding</td><td style="text-align: left;">E. a hostility toward</td><td style="text-align: left;">H. supplant</td></tr><tr class="odd"><td style="text-align: left;">C. outdated</td><td style="text-align: left;">F. an intoxication by</td><td style="text-align: left;">I. promise</td></tr></tbody></table><p>首先考虑第一空. 文章首先指出了博物馆的建筑具有 X 特点, 这预示着他们很有野心. 从这个很有野心出发, 可知他们的建筑也一定是具有一些很厉害的特点, 容易选出 A 选项.</p><p>文章随后开始解释原因. 整句话是一个 it speaks of … that … 的结构, 于是 that 前后说的应该是同一件事情:</p><ul><li>前: 董事会就现代建筑的 X 而言 <span class="math inline">\(\Rightarrow\)</span> 董事会对于现代建筑具有 X;</li><li>后: 可能会 Y 董事会对当代艺术同等的机智.</li></ul><p>其实本来挺明白的意思稍微翻译一下变得狗屁不通。。在 that 后边出现了一个 equal astuteness, 说明 that 之前也一定得有一个 astuteness, 于是只能在空格处, 故第二空应选 D. a discernment about. 至此 that 前的部分已经完整, 意为“董事会对现代建筑具有机智(什么垃圾东西)”. 故 that 后的部分也应表达这个方向的意思, 故 that 之后的部分意思应为“董事会对当代艺术也有着同等的机智”, 这中间的连接词便应选择 I. promise. 完整的意思便是“董事会对现代建筑所表现出的机智暗示着他们可能对当代艺术也有着同等的机智.”</p><p>与前一部分合并起来, 整句话的意思就是: <strong>新美术馆杰出的建筑预示着他们很有野心, 因为董事会对现代建筑所表现出的机智暗示着他们可能对当代艺术也有着同等的机智.</strong> MD, 真别扭.</p><blockquote><p>例: Belanger dances with an (i)____ that draws ones attention as if by seeking to (ii)____ it; through finesse and understatement, he manages to seem at once intensely present and curiously detached.</p></blockquote><table><thead><tr class="header"><th style="text-align: left;">Blank(i)</th><th style="text-align: left;">Blank(ii)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">A. undermonstrative panache</td><td style="text-align: left;">D. focus</td></tr><tr class="even"><td style="text-align: left;">B. unrestrained enthusiasm</td><td style="text-align: left;">E. overwhelm</td></tr><tr class="odd"><td style="text-align: left;">C. unattractive gawkiness</td><td style="text-align: left;">F. deflect</td></tr></tbody></table><p>文章中有分号出现, 说明前后两部分说的是同一件事:</p><ul><li>前: Belanger 的舞蹈伴随着一种 X, 通过 Y 的方式吸引着人们的注意;</li><li>后: 通过故意设计出的技巧和 understatement, 他能够非常神奇地既保持 detached, 又表现出强烈的感情.</li></ul><p>考虑前后两部分之间的对应, finesse and understatement 的对应点应是第一空 understatement 在这里的意思应是“不完全的展现”, 故对比语义可以选出 A. undemonstrative panache.</p><p>接下来考虑第二空, Belanger 为了吸引大家的关注, 用了 Y 手段. it 指代的是前文的 attention, 正常情况下, 吸引大家的关注应采取 focus 的手段. 但考虑到后文的 curiously 以及 undemonstrative panache, 这种低调的炫酷, 应该选择 focus 的反面, 即 F.</p><h2 id="因果关系">因果关系</h2><p><strong>因果关系的基本原则</strong>: 因果等价——有什么原因, 就有什么结果(因为爱, 所以爱). <strong>因果关系的重要标志</strong>:</p><ul><li>given…: 考虑到, 由于;</li><li>in that…: 因为;</li><li>so…that…: 非常…因为… .</li></ul><p>以下是两个例子:</p><blockquote><p>例: The politician’s record while in office, though (i)____, hardly accounts for her high standing three decades later–a standing all the more (ii)____ because of continuing assaults on her reputation during those years.</p></blockquote><table><thead><tr class="header"><th style="text-align: left;">Blank(i)</th><th style="text-align: left;">Blank(ii)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">A. bewildering</td><td style="text-align: left;">D. unusual</td></tr><tr class="even"><td style="text-align: left;">B. admirable</td><td style="text-align: left;">E. regrettable</td></tr><tr class="odd"><td style="text-align: left;">C. unappreciated</td><td style="text-align: left;">F. persistent</td></tr></tbody></table><p>文章的大概结构为: 这个政客在办公室里的纪录尽管非常 X, 但仍然很难对她在30年之后如此高的地位做出解释——这些年来对她持续不断的批评攻击使得这个地位更加的 Y.</p><p>破折号前边是一个转折, 前后意思应相反, 故 X 应该是“牛b”的意思, 故选择 B, 令人尊敬.</p><p>破折号后边是一个因果关系, 原因的部分指出这些年来她遭受着持续不断的攻击, 但仍然能到达了如此高的地位, 所以这应该是很不寻常的, 选择 D.</p><blockquote><p>例: The gaps in existing accounts of the playwright’s life are not (i)____, since much of the documentary evidence on which historians have relied is (ii)____.</p></blockquote><table><thead><tr class="header"><th style="text-align: left;">Blank(i)</th><th style="text-align: left;">Blank(ii)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">A. trifling</td><td style="text-align: left;">D. credible</td></tr><tr class="even"><td style="text-align: left;">B. obvious</td><td style="text-align: left;">E. extent</td></tr><tr class="odd"><td style="text-align: left;">C. implicit</td><td style="text-align: left;">F. incomplete</td></tr></tbody></table><p>文章在第一空的后边出现了 since, 意味着前后的部分存在对应关系, 故可以寻找两部分之间的对应.</p><ul><li>since 前: 对剧作家生平的解释中的 gap 并不 X;</li><li>since 后: 很多被历史学家所相信的证据都是 Y 的.</li></ul><p>两句话的结构都非常简单, 都是“A 具有特征 B”, 由此可以得到, 两个空格之间是互相关联的. 于是无法直接求解两个空格的答案, 只能逐个考虑.</p><p>第一空显然是不能选择 C 的, C 选项意为“含蓄”, 用来形容 gap 显然是不恰当的.</p><p>若第一空选择 A, 则前半句的意思为“对于剧作家生平的解释之间, 差异并不是很小的”, 也就是在说“这些解释是完全不靠谱的”, 因为彼此之间差异很大. 于是后半句也应表示“这些解释压根儿不靠谱”, 故第二空选择 F. 至此, AF 是可行的方案.</p><p>若第二空选择 B, 则前半句的意思为“对于剧作家生平的解释之间, 差异并不明显”, 后半句应选择一个“靠谱的证据”, 故选择 D 选项. 此时 BD 看起来也是很合理的一个答案…</p><p>嗯 官方给出的答案是 AF…</p><h2 id="递进关系">递进关系</h2><p><strong>递进关系的基本原则</strong>: 表示前后程度的加深或变浅. <strong>递进关系的重要标志</strong>:</p><ul><li><strong>Even</strong>: 句首让步, 句中递进;</li><li><strong>indeed</strong>: 进一步地讨论;</li><li><strong>almost, not only…but also…</strong>;</li><li><strong>not just…but downright</strong>: 不仅…更是彻底的…;</li><li><strong>at best…, at worst…</strong>: 说好听了…, 说不好听了…;</li><li><strong>at least</strong>: 至少, 表示对前面的削弱.</li></ul><p>以下是一道很长的题…:</p><blockquote><p>例: The order applies to all Federal agency whose actions may affect the status of invasive species and requires agencies to identify such actions and to the extent parcticable and permitted by law, and since invasive species severely reduce the number of native species and <strong>even</strong> (i)____ their existence, the agency has determined and made public its determination that the benefits of such actions clearly outweigh the potential harm caused by invasive species; and that all feasible <strong>and</strong> (ii)____ measures to (iii)____ risk of harm of the introduction of invasive species will be taken in conjunction with the actions.</p></blockquote><table><thead><tr class="header"><th style="text-align: left;">Blank(i)</th><th style="text-align: left;">Blank(ii)</th><th style="text-align: left;">Blank(iii)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">A. escalate</td><td style="text-align: left;">D. prudent</td><td style="text-align: left;">G. remedy</td></tr><tr class="even"><td style="text-align: left;">B. preclude</td><td style="text-align: left;">E. mawkish</td><td style="text-align: left;">H. counterbalance</td></tr><tr class="odd"><td style="text-align: left;">C. diminish</td><td style="text-align: left;">F. braggart</td><td style="text-align: left;">I. minimize</td></tr></tbody></table><p>第一空之前有一个 even, 说明 X their existence 是对 severely reduce 的程度加深, 故应选择 B, 阻碍它们的生存. 第二空与 feasible 之间用 and 连接, 说明 Y 与 feasible 方向相同, 故选择 D, 意为谨慎. 前文一直在讲物种入侵的内容, 那么这些方法必然是降低物种入侵带来的危害的, 故之坑考虑 HI 选项. 若选 H, 则意为“抵消风险”, 从根本上来将, 风险是不能抵消的, 因为风险是客观存在的一种东西, 无法被抵消, 只能被弱化. 故第三空应选择 I.</p><p>综上所述, 选择 BDI.</p><p>以下是 not just… but downright… 的一个例子:</p><blockquote><p>例: Making loans and fighting poverty are normally two of the least glamorous pursuits around, but remarkable enough put the two together, and you have an economic innovation that has become not just (i)____ but downright ____.</p></blockquote><table><thead><tr class="header"><th style="text-align: left;">Blank(i)</th><th style="text-align: left;">Blank(ii)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">A. popular</td><td style="text-align: left;">D. chic</td></tr><tr class="even"><td style="text-align: left;">B. pointless</td><td style="text-align: left;">E. unfathomable</td></tr><tr class="odd"><td style="text-align: left;">C. dangerous</td><td style="text-align: left;">F. sensible</td></tr></tbody></table><p>看到 not just… but downright… 的结构, 很容易知道 X→Y 是递进的关系, 观察选项只能选择 A(流行) 和 D(时髦).</p><h2 id="指代关系">指代关系</h2><p><strong>指代关系的基本原则</strong>:</p><ul><li>such…, this…, the former…, the equal…, the same… 这些词后提及的名词一定在前文出现过;</li><li>物主代词+空格, 则前文一定提到过.</li></ul><p>以下是一个例子:</p><blockquote><p>例: Though extremely (i)____ about his own plans, the man allowed his associates no such privacy and was constantly (ii)____ information about what they intended to do next.</p></blockquote><table><thead><tr class="header"><th style="text-align: left;">Blank(i)</th><th style="text-align: left;">Blank(ii)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">A. candid</td><td style="text-align: left;">D. soliciting</td></tr><tr class="even"><td style="text-align: left;">B. idiosyncratic</td><td style="text-align: left;">E. altering</td></tr><tr class="odd"><td style="text-align: left;">C. reticent</td><td style="text-align: left;">F. eschewing</td></tr></tbody></table><p>文章整体是一个转折的结构: 尽管他对于自己的计划非常 X, 但他却总是 Y 别人下一步的动作.</p><p>考虑到转折, 前后的意思一定是相反的, 而后半句中出现了 such privacy, 故这个 privacy 一定在前文出现过, 故只能是在空格处, 故第一空应选择表示“保护隐私”的词语, 故选择 C 沉默寡言. 考虑到转折, 后文一定是“不尊重隐私”的意思, 故选择 D 渴求, 不断打听. 整体的意思为: 尽管他对自己的计划保持沉默, 但他却不遗余力地打听其他人下一步的动作.</p><p>一道难题如下:</p><blockquote><p>例: To label Hamilton a foreigner because he was born outside what later became the United States is to assume anachornistically the existence of the nation before the fact. It is true that Hamilton ame to believe that he was a (i)____ the United States, but his (ii)____ was stemmed not from his (iii)____ but from his confrontation with American democracy which he considered to be a disease afflicting the nation.</p></blockquote><table><thead><tr class="header"><th style="text-align: left;">Blank(i)</th><th style="text-align: left;">Blank(ii)</th><th style="text-align: left;">Blank(iii)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">A. symbol of</td><td style="text-align: left;">D. alienation</td><td style="text-align: left;">G. ideology</td></tr><tr class="even"><td style="text-align: left;">B. stranger in</td><td style="text-align: left;">E. ambition</td><td style="text-align: left;">H. profession</td></tr><tr class="odd"><td style="text-align: left;">C. citizen of</td><td style="text-align: left;">F. patriotism</td><td style="text-align: left;">I. birthplace</td></tr></tbody></table><p>文章的第一句话没有设空, 意思为: 因 Hamilton 没有出生在这个后来叫做美国的地方就称 Hamilton 为外国人是不恰当的, 因为在美国建立之前就将这个地方成为美国是时代错误的. 由此我们可以得到:</p><ol type="1"><li>Hamilton 确实没有出生在美国的土地上;</li><li>不能直接称 Hamilton 为外国人.</li></ol><p>考察第一空, 整句为 It is true that… but… 的结构, 故 It is true… 的部分应是一个让步, 故这句话表达的意思应是“Hamilton 确实有些像个外国人”, 故第一空应填 B.</p><p>第二空是题目的难点. 前半句说了“尽管 Hamilton 看起来确实很奇怪”, 故后半句应回到文章的管线“Hamilton 不能因为不生在美国土地就被称为外国人”上面来. 考虑至此, 第三空的答案已经得出, 应选择 I 选项. 继续推断, 可推测出第二空应选择 D.</p><p>第二句整体的意思为: 虽然 Hamilton 在美国看起来确实很奇怪, 但他的疏离并非源于他的出生地, 而是他对于美国民主的反对.</p><p>综上所述, 本题应选择 BDI.</p><p>另一道难题也是三空题:</p><blockquote><p>例: Recent proposals for fixing the climate have taken the form of large-scale geoengineering projects such as launching mirrors into space to reflect solar radiation away from Earth, undertaking that are vastly more (i)____ than anything a nineteenth-century rainmaker could have cooked up. What is unclear, as one looks back at the history of weather modification research, is whether this resourceful ambition will be (ii)____, or if, by contrast, it serves to make the scientific community’s (iii)____ that much more devastating.</p></blockquote><table><thead><tr class="header"><th style="text-align: left;">Blank(i)</th><th style="text-align: left;">Blank(ii)</th><th style="text-align: left;">Blank(iii)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">A. effective</td><td style="text-align: left;">D. anticipate</td><td style="text-align: left;">G. avidity</td></tr><tr class="even"><td style="text-align: left;">B. enterprising</td><td style="text-align: left;">E. challenged</td><td style="text-align: left;">H. impotence</td></tr><tr class="odd"><td style="text-align: left;">C. accessible</td><td style="text-align: left;">F. productive</td><td style="text-align: left;">I. resignation</td></tr></tbody></table><p>最近“向空中发射一个镜子反射太阳辐射以改善气候”的提案是远比19世纪的 rainmaker 编造的东西更 X 的任务. 但当你回头审视人们对于修改天气的研究的时候, this resourceful ambition 是否会 Y 依然不甚清楚, 或者相反, 他会使得科学界的 Z 更加具有破坏力.</p><p>注意到文中有 this resourceful ambition… 存在指代关系, 于是 resourceful ambition 一定在前文提到过, 经过比较可以确定对应位置在第一空处. 接下来需要明确 resourceful ambition 的含义, resourceful 的意思是“能在困难中有效地处理”, 一般有两种解读, 一种是有效的(effective), 一种是有创造力的(imaginative). 对应到第一空的选项, 分别可以选择 A. 有效 和 B. 创新. 至此还没有有效的证据对此处的意思进行推定.</p><p>继续考虑第二和第三空, 第三空后的 that 此处等价于 so, 表示强调. 能使得 Z 更具有破坏力, 说明 Z 本身就具有破坏力, 故此处应填负面评价的词汇, 考察选项, 应选择 H. 此处应注意, G. avidity 不能翻译为“贪婪”, 事实上 avidity 约等于 ambition. 由 by contrast, 反推第二空应填正面评价的词, 考察选项可选出 F, 事实上 productive 也恰好就是 impotence 的反义词.</p><p>现在回头去思考第一空, 我们已经大约知道了 X = resourceful, 故第二空所在的句子意思为“这种 X 的 ambition 是否有效还不清楚”. 若第一空选择 A, 则与该句矛盾, 故第一空只能选择 B.</p><p>总结以下, 解题的思路是:</p><ol type="1"><li>this resourceful ambition… → X=resourceful → X=A/B;</li><li>Z 是有破坏力的 → Z=H;</li><li>by contrast… + 2 → Y=F → ambition是否有效还不清楚;</li><li>3 + 1 → X<span class="math inline">\(\neq\)</span>A → X=B.</li></ol><p>综上所述, 本题答案为 BFH.</p>]]></content>
      
      <categories>
          
          <category> 学♂习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GRE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GRE阅读题目分析[3]</title>
      <link href="/2017/07/23/GRE%E9%98%85%E8%AF%BB%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%5B3%5D/"/>
      <content type="html"><![CDATA[<h2 id="如何读信息">如何读信息</h2><h3 id="意群信息提取原则">意群信息提取原则</h3><p>始终默认所读的逻辑关系是成立的, 寻找概括、补充、修正关键信息次, 以验证已经确定的关系.</p><h4 id="顺-3种情况">顺: 3种情况</h4><ol type="1"><li>同义改写: =——前后完全相同;</li><li>举例: <span class="math inline">\(\in\)</span>——例子符合逻辑;</li><li>理由: 联系, 补足理由与观点之间的gap<ul><li>e.g. 万炜会成功的, 因为他很努力. (努力就会成功)</li><li>e.g. 万炜一定会成功的, 因为努力的人都成功了. (万炜一定很努力)</li></ul></li></ol><h4 id="转-质疑挑双方的异同补足反驳理由和结论之间的gap">转: 质疑——挑双方的异同/补足反驳理由和结论之间的gap</h4><ul><li>e.g. 主流观点认为万炜帅, 但其实只在学校比较帅.</li><li>e.g. 主流观点认为万炜聪明, 但他GRE挂了. (聪明人不会挂GRE)</li><li>e.g. 主流观点认为万炜聪明, 可聪明的人应该过了GRE. (万炜一定没有过GRE)</li></ul><h4 id="比-类比对比">比: 类比/对比</h4><ol type="a"><li>对比: A vs B.</li><li>类比: A <span class="math inline">\(\approx\)</span> B.</li></ol><h2 id="观点单一的文章">观点单一的文章</h2><blockquote><p>George Milner cites three primary problems with the labeling of Cahokia, the large archeological site by the Mississippi River, as a state rather than a chiefdom. First, finds at Cahokia are essentially similar to finds at other Mississippian chiefdoms, except that the amount of earth moved in building the mounds at Cahokia was greater than else where. Second, fewer people lived at Cahokia than is commonly estimated (Milner estimates that there were only a few thousand inhabitants, more common estimates are 10,000 or 20,000 inhabitants); therefore, extensive taxes, and tribute were not necessary to support them. Finally, while there is evidence of extensive earth movement, craftwork, trade, and elite at Cahokia, this does not indicate that Cahokia was politically centralized, economically specialized of aggressively expansionistic.</p></blockquote><blockquote><p>The passage implies that political centralization is a feature that A. has not historically tended to emerge in centers with fewer than 20,000 inhabitants B. distinguished other Mississippian chiefdoms from Cahokia C. is considered characteristic of state but not of chiefdoms D. often results from aggressive expansionism and sconomic specialization E. has historically been necessary for extensive trade to occur</p></blockquote><p>文章开头指出, George Milner 认为, Cahokia 应该是 chiefdom, 而不是 state. 需要注意 “cite three problems” 的意思应该是负面的, 认为后面的句子是不正确的. 故 GM 应该不认同 Cah 是 state, 而认为 Cah 是 chief 的. 简记为 GM: cah=chief vs. state.</p><p>随后文章开始逐一解释 GM 的三个问题:</p><ol type="1"><li>Cah 与 chief 很相似, 除了土比较多. 把握住文章的第一句话, 考虑到本句不可能是新信息, 故GM不具备的特点应该就是 state 的特点. 于是可以建立符号对应: state: 土多;</li><li>cah 具有人少的特点, 并且不需要 tax, trade 和 tribute (记为 3t). 继续扣住文章第一句话, 本句就是在说 chief→人少, 不需要3t. 继续推理可得, state→人多, 需要3t;</li><li>尽管 cah 存在 em, cr, tr, el, 但是 cah 并不是 pe, es, ae 的. 这里出现了一个让步, 故前半句应该是对另一方的妥协, 即前半句是在说“尽管cah具有一些state的特点”, 故 em, cr, tr, el 均为 state 的特点. 同理, 后半句在说“但cah仍然是chief”. 故 chief 一定是非pe, 非es, 非ae的.</li></ol><p>总结一下, 本篇文章的结构如下:</p><p>GM: Cah=chief vs. state 1. cah像chief　　　state土多 2. 人少, $$3t　　　人多, 3t 3. <span class="math inline">\(\neg\)</span>pe, <span class="math inline">\(\neg\)</span>es, <span class="math inline">\(\neg\)</span>ae　　　em, cr, tr, el</p><h2 id="存在观点冲突的文章">存在观点冲突的文章</h2><blockquote><p>Astronomers studying a certain kind of supernova (exploding star) were surprised to find the supernovas were fainter than expected. Seeking explanations, they discounted the possibility that cosmic dust might be screening out some of the light, because it would filter out blue light more than red, causing the supernovas to appear redder than they really are. Also, unless spread very smoothly throughout space, the dust would introduce large variations in the <strong>measurements</strong>. Another possibility is gravitational lensing, the bending of light rays as they skirt galaxies <em>en route</em>. Such lensing occasionally causes brightening, but most often it contributes to the dimness of distant supernovas. Calculations show, however, that this effect becomes important only for sources more distant than the supernovas studied.</p></blockquote><blockquote><ol type="1"><li>According to the passage, the astronomers rejected gravitational lensing as an explanation for their findings because A. gravitational lensing can cause supernovas to appear brighter than they really are. B. their calculations showed a negligible effect of gravitational lensing for light rays from distant sources. C. light rays trabeling from the supernovas studied did not have to skirt galaxies. D. the effect of gravitational lensing on the appearance of supernovas is unpredictable. E. the supernovas studied were too near for gravitational lensing to have the observed dimming effect.</li><li>The passage implies which of the following about the measurements made by the astronomers? A. There were small calculation errors in their measurements. B. There were no large variations in their measurements. C. Their measurements were skewed by unevenly spread cosmic dust. D. Their measurements were incomplete because cosmos dust screened out some of the light. E. It was possible to take more measurements of red light than of blue light.</li></ol></blockquote><p>文章开头是一个事实——supernova 比看起来要暗一些, 那么后文一定是在对这件事情进行解释. 下文指出, 宇航员们首先排除了宇宙尘埃的影响, 因为比起红光, 尘埃会过滤更多的蓝光. &lt;???&gt;这个句子很迷, 至此还没有非常有效的信息, 但是可以初步得到一个类似于“尘埃使得supernova变红并不能使之变暗”的结论. 后文的 Also, unless … 指出, 在一般情况下, 尘埃会带来很大的边数. 这个地方与问题看起来联系仍然不是非常紧密. 这里的内容读起来非常迷, 留在分析题目时继续讨论.</p><p>下文的 Another possibility is … 一句指出, 除了尘埃之外还有一种可能的原因, 就是 gravitational lensing, 简记为 GL. 但是接下来突然出现了 Such lensing occasionally causes brightening. (??? 作者在搞什么? GL 不是 supernova 变弱的原因吗? 怎么忽然又能使之变亮了?) 继续阅读后文, 发现后文存在一个 but, 即可知上文的 brighten 其实是一个让步. but 后指出, 多数情况下, GL 还是会使 supernova 变暗的.</p><p>文章到这里还没有结束. 最后一句中的 however 看起来就像一个大大的“卧槽”. 忍住骂人的冲动继续读, 大概可以了解到最后一句的意思是“尽管…, 但是计算表明 GL 只对那些比supernova更远的星星有效果.” 此处应有“卧槽”, 读了这么半天, 原来问题还是没有解决. 先提到了尘埃, 然后说尘埃被排除了. 提到GL这个高大上的东西的时候, 读者一定看到了希望, 然后…GL就被证明是错误的了.</p><p>综上所述, 这篇文章的内容可以简化为:</p><p>super faint → dust? × → GL? → contribute to dimness: √ → 适用距离太远: ×.</p><p>文章的第一题显然出题点就是最后一句, 所以该题的答案一定是“supernova 太近了, GL 适用距离太远了”. 很容易选出E选项.</p><p>第二题比较困难, 考察的就是事实与观点之间的gap. 在分析文章时, 尘埃附近的内容读起来比较迷, 原因就在于<strong>作者只提供了最终结果和做出判断的前提, 没有给出二者之间的详尽推理</strong>. 文中指出, dust 被排除在外, 言下之意就是 dust 对于 supernova 变暗没有贡献. 而下文的 Also, unless … 一句指出, 除非光线的传播非常顺畅, 否则观测一定有很大变数. 上文提到 dust 是可以阻碍光线传播的, 于是光线顺畅地传播等价于没有尘埃. 所以这句话实际上应该理解为: 除非尘埃不存在, 否则观测会存在很大的变数. 至此, 我们得到的信息是: 宇航员认为 supernova 的黯淡不是 dust 造成的, 并且若 dust 存在, 则一定会给观测带来很大的变数. 那么这两件事情之间需要补充的gap就是: 在观测中没有遇到很大的变数. 这里宇航员的推理就是一个典型的 <span class="math inline">\(p\to q, \neg q\Rightarrow \neg p\)</span> 的推理过程. 在这里, <span class="math inline">\(p\)</span> dust 的存在, <span class="math inline">\(q\)</span> 观测存在很大的变数. 已知 <span class="math inline">\(p\to q\)</span>, 宇航员一定是观测到了 <span class="math inline">\(\neg q\)</span>, 才敢断言 <span class="math inline">\(\neg p\)</span>. 于是这道题的答案应是 B.</p><p>顺带一提第二题中令人费解的事实和结论. 文章指出:</p><blockquote><p>宇航员排除了 dust 的影响, 因为 dust 会使得 supernova 变红. 并且, 除非 dust 不存在, 否则 dust 会给观测带来很大的变数.</p></blockquote><p>这里的原理是: 红光的波长比较长, 于是在传播时不容易衰减. 于是距离比较远的天体看起来也比较偏红, 因为波长短的光在长距离传播中被散射掉了. 尘埃会使得 supernova 变红, 自然也就会使得人们对于距离的观测值变大, 即给 measurement 带来 large variation. 所以, dust 的存在, 一定会给观测带来巨大的影响. 基于这些原理, 文中的宇航员才会做出如此的判断.</p><p>第二题的难度较高, 难的原因主要在于逻辑的推导. <strong>常见的一些逻辑如下</strong>:</p><ol type="1"><li>If p, q. —— <span class="math inline">\(p\to q\)</span>;</li><li>Only if p, q. —— <span class="math inline">\(\neg p\to\neg q\)</span>;</li><li>Unless p, q. —— <span class="math inline">\(\neg p\to q\)</span>.</li></ol><p>关于<strong>因果和转折中的条件的真假性</strong>, 有如下分类:</p><ul><li><strong>因果:</strong><ol type="1"><li>Because p, q. —— p 为真;</li><li>If p, q. —— p 不确定;</li><li>If p were true, q would have been true. —— p 为假.</li></ol></li><li><strong>转折:</strong><ol type="1"><li>Even though p, q. —— p 为真;</li><li>Even if p, q. —— p 不确定;</li><li>Even if p were true, q would have been true. —— p 为假.</li></ol></li></ul>]]></content>
      
      <categories>
          
          <category> 学♂习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GRE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GRE填空思路分析[2]——推理的线索来源·反义线索</title>
      <link href="/2017/07/20/GRE%E5%A1%AB%E7%A9%BA%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90%5B2%5D%E2%80%94%E2%80%94%E6%8E%A8%E7%90%86%E7%9A%84%E7%BA%BF%E7%B4%A2%E6%9D%A5%E6%BA%90%C2%B7%E5%8F%8D%E4%B9%89%E7%BA%BF%E7%B4%A2/"/>
      <content type="html"><![CDATA[<p>反义线索主要有对比和让步转折两种.</p><h2 id="对比">对比</h2><h3 id="情况1-矛盾词">情况1: 矛盾词</h3><p><strong>irony, ironical, ironically.</strong></p><p><strong>paradox, paradoxical, paradoxically.</strong></p><p><strong>contradiction, contradictiony.</strong></p><p><strong>opposite, oppositior.</strong></p><p><strong>contrast, contrary.</strong></p><blockquote><p>例: The concept of timelessness is paradoxical from the start, for adult consciousness is permeated by the awareness of duration.</p></blockquote><p>例句中的 timelessness 理解为“永恒的”是没有意义的, timelessness的真实含义应为“无始无终的”. 而 duration 显然是有始有终的一段时间, 故 timelessness 与 duration 形成对立.</p><p>如下面的三题:</p><blockquote><p>例: Paradoxically, Robinson’s excessive denials of the worth of early works of science fiction suggest that she has become quite ____ them. A. enchanted by B. enamored of C. skeptical of D. exasperated by E. offended by F. reflective about</p></blockquote><p>题目很简单, 前半句抛出了对比的一半信息: Robinson 认为科幻作品没有价值. 故后半句应表示出“Robinson 认为科幻作品有价值” 的意思. 故选择 AB 选项.</p><blockquote><p>例: An apparent paradox led the scientists to pursue their present line of research. They were struck by the fact that a single mathematic formula can be used to describe physical phenomena that appears to be so ____. A. rudimentary (基本的, basic) B. interdependent (相互依赖) C. interrelated (相互关联) D. complex E. heterogeneous (不同) F. dissimilar</p></blockquote><p>题目中有 be struck by… 的结构, 表明后面存在对比. a single formula 能够用以描述一些物理现象. 此处似乎无法直接确定选项, 于是可以将前文的single直接取反, 即可得到后面的物理现象应该是“不同的”. 故选 EF 选项.</p><blockquote><p>例: From the outset, the concept of freedom of the seas from the proprietary claims of nations was challenged by a contrary notion–that of the ____ of the oceans for reasons of national security and profit. A. promotion B. exploration C. enclosure D. appropriation E. conservation F. surveying</p></blockquote><p>句首的 from the outset 等价于 from the beginning. 随后文章指出, 自由的概念被一个 contrary notion 所挑战, 故后面应该是说的如何不自由. 选项中可以找到 freedom 的广义反义词为 CD.</p><h3 id="情况2-强烈情感词">情况2: 强烈情感词</h3><p><strong>surprisingly, astoundingly, weird, startling, curiously (莫名其妙), remarkable (异乎寻常), be struck by.</strong></p><blockquote><p>例: Thomas Painem whose political writing was often flamboyant, was in private life a <strong>surprisingly</strong> simple man: he lived in rented rooms, ate little, and wore drab clothes.</p></blockquote><p>文章中 Thomas Paine 的作品酷炫与生活简单形成了对比. 信号词就是surprisingly.</p><p>在出现对比的时候一定要理清文章的逻辑和内容, 否则可能会因此选错. 如以下的两题</p><blockquote><p>例: While in many ways their personalities could not have been more different–she was ebulliend where he was glum, relaxed where he was awkward, garrulous where he was ____–they were surprisingly well suited. A. solicitous (渴求的) B. munificent (大方的) C. irresolute (犹豫不决) D. laconic (言简意赅, concise) E. fastidious (小心谨慎, 一丝不苟, 挑剔苛求) F. taciturn (沉默寡言)</p></blockquote><p>文章中很容易看到 surprisingly 的存在, surprisingly 后指出两人很般配, 于是可知前文应该是说两人是不般配, 甚至相对立的. 文章在空格前指出了 she was garrulous, garrulous 意为“啰嗦”, 故后文应表示“他话很少”的意思, 故选择 DF 选项.</p><blockquote><p>例: Scholars have marveled over the (i)____ that Shakespeare displays in his works, noting that such broad learning is all the more remarkable given that books were relatively (ii)____ in Shakespeare’s time.</p></blockquote><table><thead><tr class="header"><th style="text-align: left;">Blank (i)</th><th style="text-align: left;">Blank (ii)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">A. meticulousness (一丝不苟, fastidious)</td><td style="text-align: left;">D. edifying (有教育意义的)</td></tr><tr class="even"><td style="text-align: left;">B. humor</td><td style="text-align: left;">E. scarce</td></tr><tr class="odd"><td style="text-align: left;">C. erudition (博学)</td><td style="text-align: left;">F.inexpensive</td></tr></tbody></table><p>文章的前半部分有一个 noting that such broad learning…, 此处的 broad learning 是新提出的, 故前文一定提到过. 浏览前文, 并没有提到相关内容, 故一定是空格处提出的. 于是(i)空应选C项. 结合marvel 和remarkable, 可知前后两部分形成了对比, 于是莎士比亚读的书应该是很少, 才能与他的博学形成对比. 故第(ii)空应填 E.</p><h3 id="情况3-其他常见对比关系">情况3: 其他常见对比关系</h3><p>其他常见对比关系:</p><ul><li>时间点前后: recently, previous, before, current, now, today, yesterday, later, future, initially, no longer;</li><li>表象和实质: in fact, in reality, ostensible(表面上的), normally;</li><li>一般对特殊;</li><li>整体对个体;</li><li>结构对比:<ul><li>不是A, 而是B: not A but B, far from A to B, less A than B;</li><li>是A, 而不是B: more A than B, A rather than B.</li></ul></li></ul><p>以下是两道比较难的题目, 都是双空题.</p><blockquote><p>例: The museum’s compelling new architechural exhibition looks at eleven projects around the world that have had major (i)____ impacts despite modest budget. It is part of (ii)____ in the museum’s architecture and design department, which in the past has championed architecture’s artistic value over its real- world consequences.</p></blockquote><table><thead><tr class="header"><th style="text-align: left;">Blank(i)</th><th style="text-align: left;">Blank(ii)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">A. social</td><td style="text-align: left;">D. an emphasis on theory</td></tr><tr class="even"><td style="text-align: left;">B. aesthetic</td><td style="text-align: left;">E. a shift in philosophy</td></tr><tr class="odd"><td style="text-align: left;">C. critical</td><td style="text-align: left;">F. a rejection of programatism</td></tr></tbody></table><p>文章首句指出了博物馆的展览关注的是11座造价不高的建筑, 而 despite 表明了空格与 modest budget 之间存在对比关系, 但至此仍然无法在 ABC 中找到正确选项. 第二句中的 it 指代的应是前文提到的展览, 接下来空格附近的内容也无法确定, 但下文出现了 which, 一定会对这里的内容进行解释. 注意到 in the past 的存在表明了此处应该存在一种时间上的今昔对比, champion A over B 意为“支持 A 而不支持 B”, 即曾经不重视 real- world consequences, 故如今应当重视. 注意这里谈论的内容仍然是与展览相关, 故此处的信息一定是前文提到的, 于是第(i)空应选择 A 选项, 以表示该展览重视了 real- world consequences.</p><p>第二空附近的内容被后面 which 引导的从句所解释, 故两方面内容应该是基本等价的, 概括从句内容可知是博物馆对于 artistic value 和 real- world consequences 的态度发生了转变, 故第二空选择 E 选项. 此处的 philosophy 不表示“哲学”的意思, 而是表示一种“理念”的意思.</p><p>值得注意的是, in the past 在整个文章中的地位极其重要, 如果没有看到 in the past, 则第(i)空选择 B. aesthetic 也可以说得通, 而第二个空也会错误理解为“博物馆仍然不重视real- world consequences”, 从而错选为 F. a rejection of pragmatism, 意为“对实用主义的消极态度.”</p><blockquote><p>例: Britain’s deteriorating economy after 1945 was (i)____ by policians who favored the manufacuring sector over the service sector: rather than attempting to (ii)____ the decline of manufacturing, they should have promoted service industries.</p></blockquote><table><thead><tr class="header"><th style="text-align: left;">Blank(i)</th><th style="text-align: left;">Blank(ii)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">A. mishandled</td><td style="text-align: left;">D. augment</td></tr><tr class="even"><td style="text-align: left;">B. bolstered</td><td style="text-align: left;">E. arrest</td></tr><tr class="odd"><td style="text-align: left;">C. forestalled</td><td style="text-align: left;">F. escalate</td></tr></tbody></table><p>文章在第(i)空之前的部分提到了英国恶化的经济状况, 空格后的 by politicians… 表明空格表示的是政客的一些操作. 随后文章指出了政客的想法是 favored the manufacturing sector over the service sector, 意为“把制造业看得比服务业更重要.” 至此仍然没有清晰的线索指向第(i)空的操作.</p><p>接下来出现了冒号, 则冒号后的内容方向一定是与前文一致的. 不妨设第(ii)空的内容为 X, 则冒号后的内容为, 政客本应该促进服务业的发展, 而非 X 制造业的衰落. 至此第(ii)空的线索已经明确. 政客们的操作目的应是拯救英国衰退的经济, 故 X 应表达“阻止制造业的衰退”的意思, 故应选择 E 选项. 最后的虚拟语气 they should have promoted… 是非常关键的线索. 一般来说, 虚拟语气暗含着对比: “他们本应该…”, 实际上是在表明“他们如果不这样就会很好, 但他们搞砸了.” 所以这句话实际上表明了“政客们使得英国本就不景气的经济雪上加霜.” 于是第一空应选择 A. mishandled, 意为经营不善.</p><p>综上所述, 题目应选择 AE 选项.</p><h2 id="让步转折">让步转折</h2><p>让步转折的主要标志: <strong>but, while, though, although, despite, in spite of, notwithstanding, nonetheless, nevertheless, for all, yet, unless, however, whatever, regardless of, albeit</strong>.</p><p>其中有一些注意事项:</p><ol type="1"><li>despite 是介词, 后面需要接词, 不能直接跟句子, 如果需要跟句子, 则需要 despite that… ;</li><li>notwithsatnding 可以做副词或介词, 意为“尽管”;</li><li>forall = despite;</li><li>albeit = although;</li><li>nonethless 和 nevertheless 的用法:<ul><li>若二者单独出现, 则意为“然而”;</li><li>若前文已有转折词, 则二者无意义.</li></ul></li><li>but 用法的一个特例: but…more… 表示“进一”, “更多的”.</li></ol><p>在做题时要通过各种信号词来推测空格与已知信息的正负关系, 不能忽略掉任何一个, 否则就容易理解错误. 如下面的例子:</p><blockquote><p>例: Clearly the government faced a dilemma: it could hardly ____ trials, especially in the absence of irrefutable evidence, but it also would not welcome, in the midst of war, the scandal that would raise if trials were avoided. A. be keen on B. be inclined to C. arrange D. dispense with E. turn its back on F. credit</p></blockquote><p>开头提到了一个困境, 暗示后文是两件事情的对立. 设空格为 X, 则容易分析出 hardly X trials 与 would not welcome the scandal 是矛盾的. 考虑到 scandal 是在避免 trials 的情况下出现的, 故 scandal = <span class="math inline">\(\neg\)</span> welcome trials. 于是之前得到的结论, <span class="math inline">\(\neg\)</span> X trials =<span class="math inline">\(\neg\)</span><span class="math inline">\(\neg\)</span><span class="math inline">\(\neg\)</span> welcome trials. 故 X trials = welcome trials. 于是应选择正向的选项, 即AB.</p><p>如果在分析过程将 welcome 的宾语错当为 trials, 或漏掉转折的标志, 则有可能会错选DE.</p><p>值得一提的是, dilemma 专指的是左右两难的困境. 即 dilemma 一定是两件事情之间的纠结状态.</p><p>一个难题如下:</p><blockquote><p>例: As serious as she is about the bullfight, she does not allow respect to ____ her sense of whimsy when painting it. A. inspire B. provoke C. suppress D. attack E. satisfy</p></blockquote><p>题目中出现了 As 引导的半倒装句, 一般来说表示让步. 后面的 allow respect to … 也是一个比较难以分析的地方. 事实上, 此处的结构为 allow sb to …, 若理解为 allow (respect to …) … 则题目无法下手. 关系和内容明确后, 文章变为了 serious to bullfight=<span class="math inline">\(\neg\)</span> not allow to X her sense of whimsy while paint it. 即 X = <span class="math inline">\(\neg\)</span> serious. 即应选择负面的词语, 为 C 选项.</p><p><strong>关于 as, 有如下几条:</strong></p><ul><li>as 引导的半倒装句表示让步.<ul><li>Student as she is, she does not study hard.</li><li>尽管她是个学生, 她并不好好学习.</li></ul></li><li>As … as … = So … as …<ul><li>As: adv. = so;</li><li>as: conj. 正如, 就像.</li></ul></li></ul><p>再次回到题目, 文章中相对应的部分实际上是 So serious 和 respect.</p><h2 id="同主体让步转折">同主体让步转折</h2><p>同主体让步转折, 顾名思义就是主体不变的情况下进行让步和转折. 但前后不可能完全对立, 即不可能出现“他很帅, 但很丑”这样明显错误的句子. 但考虑到不完全对立, 可以有“我很丑但我很温柔”这样的句子, 这样的情形就被称为同主体让步转折. 可以总结为以下几条:</p><ul><li>形式: Although A…, A…<ul><li>前后转折主体为统一事物, 并处于同一时空范围内.</li></ul></li><li>原则<ul><li>前后两个空格不能截然相反;</li><li>前后两个空格可以是正负相对但意思无关的概念. (丑-温柔, 聪明-懒惰)</li></ul></li></ul><p>以下是一道难题:</p><blockquote><p>例: His affection for his sister, though not ____, was plainly too great to permit a painless departure. A. unsteady B. noticeable C. ambivalent D. careless E. unbounded</p></blockquote><p>此处的 affection 意为“爱”. 观察到文中的 though, 结合语义可得到 not X = <span class="math inline">\(neg\)</span> great. 故 X 为正向的词语. 符合要求的有 BE 两项.</p><p>此题很容易错选B选项. B. noticeable 带入文章中意为“尽管他对姐姐的爱不是那么明显, 但仍然足够great.” 虽然情感方向正确, 但后文的plainly 意为“明显的, 显然的”, 与此处的 not noticeable 矛盾. 故综合考虑应选择 E. unbounded.</p><p>以下是另一道难题:</p><blockquote><p>例: While not completely nonplussed by the unusually caustic responses from members of the audience, the speaker was nonetheless visibly ____ by their criticism. A. humiliated B. discomfited C. deluded D. disgraced E. embarrassed F. tantalized</p></blockquote><p>文章的大概意思为“尽管speaker还没有被完全弄得困惑, 但他显然还是被弄得 X.” 值得注意的是文章中 nonetheless 不表示转折, 意为“仍然”. 于是 X 应是负面的词, 但强烈程度不及“nonplussed”. 单纯考虑情感方向, 可以选择 AD. 羞辱 或者 BE. 不爽/尴尬. 继续考虑到强烈程度的问题, 应选择 BE.</p><p>本题的 F 选项 tantalized 意为“挑逗”. <strong>GRE中常出现的“挑逗”共有3个: tantalized &lt; allure &lt; seduce. 引诱程度依次加深</strong>. seduce 意为“色诱”.</p>]]></content>
      
      <categories>
          
          <category> 学♂习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GRE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GRE填空思路分析[1]——词句推理</title>
      <link href="/2017/07/20/GRE%E5%A1%AB%E7%A9%BA%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90%5B1%5D/"/>
      <content type="html"><![CDATA[<h2 id="verbal-reasoning-的特点">Verbal Reasoning 的特点</h2><ul><li>第一个记分的语文的填空部分一定是2个单空, 3个双空, 1个三空.</li><li>建议用时: 10min填空, 20min阅读.</li><li>填空题目不考察背景知识, 所有线索均来自于题目.</li></ul><h2 id="词汇问题">词汇问题</h2><h3 id="第一类问题-词义理解有误">第一类问题: 词义理解有误:</h3><p>韦氏词典+美国传统辞典;</p><h3 id="第二类问题-望文生义">第二类问题: 望文生义:</h3><table><thead><tr class="header"><th style="text-align: left;">单词</th><th style="text-align: left;">真实含义</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">invaluable/priceless</td><td style="text-align: left;">特别值钱</td></tr><tr class="even"><td style="text-align: left;">impassive</td><td style="text-align: left;">消极冷漠</td></tr><tr class="odd"><td style="text-align: left;">impassion</td><td style="text-align: left;">热情</td></tr><tr class="even"><td style="text-align: left;">effortless</td><td style="text-align: left;">不费力的</td></tr><tr class="odd"><td style="text-align: left;">ignorance</td><td style="text-align: left;">无知</td></tr><tr class="even"><td style="text-align: left;">salient</td><td style="text-align: left;">显著的</td></tr><tr class="odd"><td style="text-align: left;">appraise</td><td style="text-align: left;">评价</td></tr><tr class="even"><td style="text-align: left;">acclaim</td><td style="text-align: left;">喝彩</td></tr><tr class="odd"><td style="text-align: left;">servered</td><td style="text-align: left;">切开</td></tr><tr class="even"><td style="text-align: left;">reserve/reverse</td><td style="text-align: left;">保留/相反</td></tr><tr class="odd"><td style="text-align: left;">guild</td><td style="text-align: left;">协会</td></tr></tbody></table><h3 id="第三类问题-熟词僻义">第三类问题: 熟词僻义:</h3><table><thead><tr class="header"><th style="text-align: left;">单词</th><th style="text-align: left;">熟词生义</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">turf</td><td style="text-align: left;">地盘</td></tr><tr class="even"><td style="text-align: left;">list</td><td style="text-align: left;">倾斜</td></tr><tr class="odd"><td style="text-align: left;">licence</td><td style="text-align: left;">自由</td></tr></tbody></table><h3 id="第四类问题-纯难词词根猜测">第四类问题: 纯难词/词根猜测</h3><p>背单词…Orz</p><h2 id="长难句理解">长难句理解</h2><h3 id="长句">长句</h3><p>三个概念:</p><ul><li>that 的作用:<ol type="1"><li>代词, 表示“那个”;</li><li>引导从句.</li></ol></li><li>同位语: 跟在名词后, 表示对其的修饰;</li><li>分词短语:<ol type="1"><li>做定语, 表示对前面名词的修饰;</li><li>做状语, 与主语用逗号隔开表示主语的状态. <strong>用逗号隔开的必定是状语, 反之可能是定语.</strong></li></ol></li></ul><blockquote><p>例: The increase in the numbers of married women employed outside the home in the twentieth century had less to do with the mechanization of housework and an increase in leisure time for these women than it did with their own economic necessity and with high marriage rates that shrank the available pool of single women workers, previously, in many cases, the only women employers would hire.</p></blockquote><p>例句中, The increase 是主语, had less to do with 是谓语, than it did with… and with 是宾语. 至此主干已经清楚, 最后的 the only women 是同位语.</p><h3 id="难句">难句</h3><blockquote><p>例: For some time now, ____ has been persumed not to exist: the cynical conviction that everybody has an angle is considered wisdom. A. rationality B. flexibility C. diffidence <strong>D</strong>. disinterestedness E. insincerity</p></blockquote><p>例句的最后部分 everybody has an angle is considered wisdom 的意思是“每个人都很自私.” 考虑到冒号前的not, 前后两部分意思应相反, 故选择D, 意为“无私.”</p><blockquote><p>例: The current ____ of package music under Miles Davis’ name might prompt ant reasonable person to conclude that the recording vault has been plundered bare. <strong>A</strong>. glut (过量) B. revival (复活) <strong>C</strong>. hodgepodge (大杂烩) D. surfeit (过量) E. modicum (少量) F. dearth (少量)</p></blockquote><p>例句的最后部分 the recording valut has been plundered bare 直译为“唱片金库被掠夺一空.” 此处的意思为“Miles Davis 已经江郎才尽.” 于是题目应选择 AD 选项.</p><h2 id="推理的步骤与注意事项">推理的步骤与注意事项</h2><h3 id="逻辑和语义">逻辑和语义</h3><p>逻辑的判断方法:</p><ol type="1"><li>是否有反义: 首先判断分句与分句之间是否有反义转折词;</li><li>是否有否定: 其次判断空格或抑制信息前后是否有否定;</li><li>有几个否定: 转折词汇也算作否定, 判断否定的层数;</li></ol><p>常见的否定词: <strong>no/not, less, little, anything but, few, never, hardly=barely, rarely=seldom</strong>.</p><p>语义的判断方法: 判断广义同反义.</p><p>广义同义概念:</p><ul><li>严格同义词;</li><li>感情色彩相同的词, 如: 勤奋-善良, 邪恶-懒惰;</li><li>正负方向相同的词, 如: 增高-变多;</li><li>逻辑相关词, 如: 艺术-艺术家, 科学-科学报告.</li></ul><p>广义反义概念:</p><ul><li>严格反义词;</li><li>感情色彩相反的词;</li><li>正负方向相反的词;</li><li>与极端词相对应的中性词, 如: 上升-下降, 上升-静止 均可.</li></ul><h3 id="推理的步骤">推理的步骤</h3><p>一般有以下的五步:</p><ul><li>通读题干, 明确哪一空最好做;</li><li>明确空格作用: 如表示谁的动作, 修饰的是谁的属性;</li><li>判断逻辑同反义关系;</li><li>判断空格的语义对应线索;</li><li>对空格做出预测, 选出正确选项.</li></ul><p><strong>填空的后半句一定没有新概念出现, 若有, 则一定在前半部分出现过.</strong></p><h3 id="推理的注意事项">推理的注意事项</h3><ul><li>一定要以文章的剩余信息为依据, 解题线索一定来自题目本身, 不要带入主观假设和偏见;</li><li>需要有必要的常识 common sense</li></ul><blockquote><p>例: Nature’s energy efficiency often (i)____ human technology: despite the intensity of the light fireflied produce, the amount of heat is negligible (可忽略的); only recently have humans developed chemical light-producing systems whose efficiency (ii)____ the firefly’s system.</p></blockquote><table><thead><tr class="header"><th style="text-align: left;">Blank (i)</th><th style="text-align: left;">Blank (ii)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">A. outstrips (超过)</td><td style="text-align: left;">D.rivals (与…相匹敌)</td></tr><tr class="even"><td style="text-align: left;">B. reflects</td><td style="text-align: left;">E. manipulates</td></tr><tr class="odd"><td style="text-align: left;">C. determines</td><td style="text-align: left;">F. inhibits (抑制)</td></tr></tbody></table><p>例句中首先说明了萤火虫的光很强但发热很少, 下文又提到了能量效率. 能量效率=有用能量/总能量 就是一个常识, 于是容易知道萤火虫的发光效率非常高. 而萤火虫是冒号后新出现的东西, 故一定是前文所提到的, 可知萤火虫所属的阵营是自然, 于是可以猜测下文要说的是人类的能量效率比较低. 于是本题应选择 AD 选项.</p>]]></content>
      
      <categories>
          
          <category> 学♂习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GRE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GRE阅读题目分析[2]</title>
      <link href="/2017/07/16/GRE%E9%98%85%E8%AF%BB%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%5B2%5D/"/>
      <content type="html"><![CDATA[<h2 id="文章内容">文章内容</h2><blockquote><p>Many scholars have argued that government investment in manufacturing in the southern United States during the Second World War spurred a regional economic boom that lasted into the postwar period. But much of this investment went to specialized plants, many of them unsuitable for postwar production. Large-scale, wartime government funding led to a massive increase in the number and scale of munitions facilities. By the war’s end, 216 munitions establishment costing more than $3.5 billion had been built, many of them located in the south. Indeed, according to one estimate, more than 70 percent of federally financed manufacturing construction capital in Alabama, Arkansas, Mississippi, and Tennessee went into munitions plants. 　　Even in the northern regions with strong prewar manufacturing economics, these plants were difficult to deal with once the imperative of war had been removed. In the south few industrialists had the capacity or desire to transform these factories to a peacetime function. Accordingly, at war’s end almost all of the southern munitions facilities were shut down, placed on standby, operated at a very low capacity, or converted to nonmanufacturing functions, usually storage. Although some reopened a few years later for use during the Korean War, the impact of the special plants on the South’s postwar economy was marginal at best.</p></blockquote><h2 id="结构分析">结构分析</h2><h3 id="文章开头">文章开头</h3><p>由文章的第一句中 “many scholars have argued that…” 可知该句为引用观点, 故该文章很有可能是一个质疑型的文章. 首句指出: <strong>很多学者认为, 二战期间, 政府对美国南方在工业方面的投资刺激了经济的发展, 并持续到了战后</strong>. 这一句所包含的信息量很大, 作者可以质疑很多方面, 比如, 作者可以质疑投资是否真的能刺激经济发展, 也可以质疑这种发展能否持续到战后. 所以文章的方向目前为止还不甚明朗, 需要继续阅读.</p><p>接下来出现了 but, 表示作者开始了自己的质疑. 作者指出, 这些受益的工厂有很多都是特殊的工厂, 不适合于战后的情形. 至此, 作者的态度已经比较明朗, 就是在质疑经济的发展能否持续到战后的问题. 目前为止文章的内容框架已经可以概括为:</p><blockquote><p>很多学者认为, 二战期间, 政府对美国南方在工业方面的投资刺激了经济的发展, 并持续到了战后. 但由于这些工厂的特殊性, 这种经济的发展不能持续到战后.</p></blockquote><h3 id="后文展开">后文展开</h3><p>接下来的 Large-scale… 一句, 行文的方向显然没有发生变化, 于是这句话不会与作者的观点产生冲突, 也不会产生新的信息. 本句谈到的信息为政府把钱投资给了军工厂, 那么这个信息一定是旧信息, 那么前文提到的“特殊的”工厂指的也就应该是军工厂了. 下一句 By the war’s end… 也是在谈政府为军工厂投资的事情, 仍然没有新信息出现.</p><p>随后是 Indeed 引导的句子, 可知该句话中行文的方向不发生变化, 于是其内容仍然不会脱离框架所的涉指范围. 结合语义, 可知本句仍在谈论投资对象的问题.</p><h3 id="第二段">第二段</h3><p>在第二段的开头提到了北方的情况(可以出题考为什么在此处提到北方的情况), 指出这些战后的军工厂在北方同样难以处理. 那么作者为什么要在此处提及北方的情况呢? 显然南方才是全文的重点, 整个文章都应该是围绕着南方展开的. 所以显然这个北方的情况也是服务于南方的, 实际上是在表明 “连北方的都难以处理, 更不用说南方的情况了, 一定更糟糕”. 所以此处提及北方的情况, 实际上仍然是在为作者自己得观点所服务.</p><p>接下来讨论回到了南方, 指出几乎没有人愿意处理南方的军工厂, 仍然在强调战后军工厂的副作用. 接下来的 Accordingly… 一句, 更是直接指出了, 在战后, 几乎所有的军工厂都废掉了.</p><p>在下文出现了 although 一词, 显然是一个让步. 故前半句应该是一个小小的妥协, 后半句仍然回到自己的观点. 故此处在读句子之前就完全可以猜出这句话的意思是“尽管有些军工厂还没有废掉, 但是它们也废掉了”. 至此, 整篇文章的内容已经结束.</p><h3 id="整体结构">整体结构</h3><p>文章比较长, 但最核心的其实只有两句话:</p><blockquote><p>Many scholars have argued that government investment in manufacturing in the southern United States during the Second World War spurred a regional economic boom that lasted into the postwar period. But much of this investment went to specialized plants, many of them unsuitable for postwar production. 许多学者认为经济发展能够持续至战后, 但是并不能.</p></blockquote><h2 id="问题分析">问题分析</h2><h3 id="问题一">问题一</h3><p>文章的问题是针对 Indeed, according to one estimate, more than 70 percent of federally financed manufacturing construction capital in Alabama, Arkansas, Mississippi, and Tennessee went into munitions plants 一句提出的, 该句是对上文观点的展开, 故功能应该是支持前文的观点.</p><p>事实上, 原题目如下:</p><blockquote><p>In the passage, the mention of “Alabama, Arkansas, Mississippi, and Tennessee” serves primarily to 　　A. suggest that some states were better than others at anticipating postwar economic needs 　　B. identify evidence used to support a view held by scholars mentioned at the beginning of the passage 　　C. suggest that federal investment in some kinds of manufacturing was excessive 　　D. identify the states that received the largest allocations of federal funds 　　<strong>E</strong>. provide information to support a point about the nature of government investment made earlier in the paragraph</p></blockquote><p>根据以上分析, 本题应选择 E.</p>]]></content>
      
      <categories>
          
          <category> 学♂习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GRE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GRE阅读题目分析[1]</title>
      <link href="/2017/07/16/GRE%E9%98%85%E8%AF%BB%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%5B1%5D/"/>
      <content type="html"><![CDATA[<h2 id="文章内容">文章内容</h2><blockquote><p>In 1755 British writer Samuel Johnson published an acerbic letter to Lord Chesterfield rebuking his patron for neglecting and declining further support. Johnson’s rejection of his patron’s belated assistance has often been identified as a key moment in the history of publishing, marking the end of the culture of patronage. However, <strong>patronage had been in decline for 50 years, yet would survive, in attenuated form, for another 50</strong>. Indeed, Johnson was in 1762 awarded a pension by the Crown — a subtle form of sponsorship, tantamount to state patronage. The importance of Johnson’s letter is not so much historical as emotional; it would become a touchstone for all who repudiated patrons and for all who embraced the laws of the marketplace.</p></blockquote><h2 id="结构分析">结构分析</h2><h3 id="文章开头">文章开头</h3><p>文章前两句指出, 有观点认为: “SJ 喷 LC 的事件标志着 patronage 的结束”. 随后文中出现 However, 由于前文是引用观点, 故 However 可能起到质疑的作用, 于是本句的核心方向应该是 “partonage 并没有结束”. 后文中又出现了一个 yet, 表明该句中存在让步, 于是前半句应是对于引用观点的妥协, 结合语义, 可理解为 “partonage 虽然在变弱”. 后半句显然与引用观点意思相反, 应为 “partonage 还没有结束”.</p><p>到这里, 文章已经抛出了一个观点, 文章的大概走势是:</p><blockquote><p>有人认为 SJ 喷 LC 的事件标志着 patronage 的结束, 但实际上, 尽管 patronage 削弱了, 却没有结束.</p></blockquote><p>按照常理, 下文应该对作者自己的观点进行展开.</p><h3 id="后文展开">后文展开</h3><p>下文首先出现的是 indeed, 考虑语义, indeed 意为“确实”, 不改变文章的观点方向, 故下文的意思仍应该是“partonage 没有结束”, 结合 “tantamount to state patronage”, 可知该句确实表明了类似的意思. 最后一句仍然是作者自己观点的展开, “not so much … as …” 指出 SJ 喷 LC 的事件, 在 emotional 方面的重要性要大于 historical 方面的重要性, 实际上也是在说这件事不能标志着 patronage 的结束.</p><h3 id="整体结构">整体结构</h3><p>总体看来, 这篇文章的核心意思就是上文提到的走势, 而核心的两句话就是:</p><blockquote><p>Johnson’s rejection of his patron’s belated assistance has often been identified as a key moment in the history of publishing, marking the end of the culture of patronage. However, patronage had been in decline for 50 years, yet would survive, in attenuated form, for another 50. 许多人认为 SJ 喷 LC 标志着 patronage 的结束, 但实际上并没有.</p></blockquote><h2 id="问题分析">问题分析</h2><h3 id="问题一">问题一</h3><p>首先从加粗句出发考虑, 涉及到的就是 however 的功能. 由以上的分析, 该句的功能为质疑前文的引用观点, 故可以如下设计正确选项:</p><ol type="1"><li>Present a view that chanllenges a understanding of Johnson’s rejection of his patron’s belated assistance.</li><li>Outline an opposing interpretation of Johnson’s rejection of his patron’s belated assistance.</li><li>Qualify the declaration that Johnson’s rejection was the end of patronage.</li><li>……</li></ol><p>事实上, 原题目如下:</p><blockquote><p>Which of the following best describes the function of the highlighted sentence in the context of the passage as a whole? 　　A. It points out the <del> most obvious</del> implications of Johnson’s letter to his patron 　　B. It suggests a <del>motivation</del> for Johnson’s rejection of Chesterfield’s patronage 　　<strong>C</strong>. It provides information that qualifies the assertion that Johnson’s letter sharply defined the end of a publishing era 　　D. It provides a possible <del>defense</del> for Chesterfield’s alleged neglect of Johnson 　　E. It refutes the notion that <del>patrons are found primarily among the nobility</del></p></blockquote><p>根据以上分析, 本题应选择 C.</p><h3 id="问题二">问题二</h3><p>文章的另一道题目是针对 1762 的事件 (Indeed, Johnson was in 1762 awarded a pension by the Crown — a subtle form of sponsorship, tantamount to state patronage) 提出的.</p><p>这句话是对作者自己观点的展开, 所以从功能上来就是对自己观点的加强, 很容易设计出如下的正确选项:</p><ol type="1"><li>Support that Johnson’s rejection was not the end of patronage.</li></ol><p>原题目如下:</p><blockquote><p>The author of the passage mentions Johnson’s 1762 pension award in order to 　　A：Reveal that Johnson remained consistent in his rebuke of Lord Chesterfield well after 1755 　　B：Provide evidence for a general trend in the later half of the eighteenth century of private patronage’s being replaced by state sponsorship 　　C：Situated the debate over the end of patronage within the wider realm of eighteenth-century economic history 　　D：Suggest that Johnson’s letter to Chesterfield was noticed by the crown only years after it was published 　　<strong>E</strong>：Emphasize that patronage still helped support Johnson’s writing after his letter to chesterfield</p></blockquote><p>根据以上分析, 本题最合适的选项应为 E 选项. 值得注意的是 C 选项中 debate 一词的使用. Debate 的存在必然是有两派对立的引用观点, 否则不足以构成 debate. 注意作者观点与引用观点的对立并不算做 debate, 因为从作者的角度出发, 自己的观点一定是正确的, 不存在争论的必要.</p>]]></content>
      
      <categories>
          
          <category> 学♂习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GRE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2015年数学分析期末考试试卷</title>
      <link href="/2017/07/04/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62015%E5%B9%B4%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7/"/>
      <content type="html"><![CDATA[<h2 id="试题">试题</h2><h3 id="计算题">计算题</h3><p>共40分, 每题5分.</p><ol type="1"><li><p>求极限 <span class="math inline">\(\lim\limits_{n\to\infty}\sqrt{n}(\sqrt{n+1}-\sqrt{n})\)</span>;</p></li><li><p>求极限 <span class="math inline">\(\lim\limits_{x\to\infty}\sqrt{(a+x)(b+x)}-\sqrt{(a-x)(b-x)}\)</span>;</p></li><li><p>求不定积分 <span class="math inline">\(\int e^{\sqrt{x}}dx\)</span>;</p></li><li><p>求不定积分 <span class="math inline">\(\int \frac{1}{1+x^4}dx\)</span>;</p></li><li><p>求广义积分 <span class="math inline">\(\int\nolimits_0^1 lnxdx\)</span>;</p></li><li><p>求广义积分 <span class="math inline">\(\int\nolimits_0^{+\infty}\frac{dx}{1+x^3}\)</span>;</p></li><li><p>求二重积分 <span class="math inline">\(\iint\nolimits_D [x+y]dxdy\)</span>, 其中 <span class="math inline">\(D=[0,2]\times[0,2]\)</span>, <span class="math inline">\([x+y]\)</span> 是取整函数;</p></li><li><p>设二阶偏导数连续的二元函数 <span class="math inline">\(z=f(x,y)\)</span> 满足方程 <span class="math display">\[\frac{\partial^2 f}{\partial x^2}(x,y)-\frac{\partial^2 f}{\partial y^2}(x,y)=0\]</span> 且 <span class="math inline">\(f(x,2x)=x\)</span>, <span class="math inline">\(\frac{\partial f}{\partial x}(x,y)\)</span> 当 <span class="math inline">\(y=2x\)</span> 时等于 <span class="math inline">\(x^2\)</span>. 求 <span class="math inline">\(\frac{\partial^2 f}{\partial x^2}(x,y)\)</span> 当 <span class="math inline">\(y=2x\)</span> 时的值.</p></li></ol><h3 id="证明题">证明题</h3><p>共60分, 每题10分.</p><ol type="1"><li><p>求证数列 <span class="math inline">\(x_n=(-1)^n\)</span> 当 <span class="math inline">\(n\to\infty\)</span> 时发散;</p></li><li><p>设 <span class="math inline">\(f,g\)</span> 在闭区间 <span class="math inline">\([a,b]\)</span> 连续, 证明 <span class="math display">\[\int\nolimits_a^b f(x)g(x)dx\leqslant\frac{1}{2}\left[\int\nolimits_a^bf^2(x)dx+\int\nolimits_a^bg^2(x)dx\right];\]</span></p></li><li><p>设广义积分 <span class="math inline">\(\int\nolimits_0^{+\infty}\frac{\sin^2 x}{x^2}dx\)</span> 和 <span class="math inline">\(\int\nolimits_0^{+\infty}\frac{\sin x}{x}dx\)</span> 都收敛, 证明: <span class="math display">\[\int\nolimits_0^{+\infty}\frac{\sin^2 x}{x^2}dx=\int\nolimits_0^{+\infty}\frac{\sin x}{x}dx;\]</span></p></li><li><p>设 <span class="math display">\[f(x,y)=\begin{cases} \frac{xy}{x^2+y^2}, &amp; (x,y)\neq(0,0), \\ 0, &amp; (x,y)=(0,0). \\ \end{cases}\]</span></p></li><li><p>设函数 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\(x=0\)</span> 连续, 且 <span class="math inline">\(\lim\limits_{x\to\infty}\frac{f(2x)-f(x)}{x}=a\)</span>. 求证: <span class="math inline">\(f&#39;(0)\)</span> 存在, 且 <span class="math inline">\(f&#39;(0)=a\)</span>.</p></li><li><p>设 <span class="math display">\[P_n(x)=\frac{1}{n!2^n}\frac{d^n}{dx^n}(x^2-1)^n,\]</span> 证明: <span class="math display">\[\int\nolimits_{-1}^1 P_n(x)P_m(x)dx = \begin{cases} 0, &amp; m\neq n,\\ \frac{2}{2n+1}, &amp; m=n. \\ \end{cases}\]</span></p></li></ol>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 各种试卷 </tag>
            
            <tag> 数学分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2016年高等代数期中考试试卷</title>
      <link href="/2017/07/04/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62016%E5%B9%B4%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0%E6%9C%9F%E4%B8%AD%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7/"/>
      <content type="html"><![CDATA[<h2 id="试题">试题</h2><p>以下各题中, 所指的向量空间都是有限的.</p><ol type="1"><li><p>假设域 <span class="math inline">\(F\)</span> 上的2维向量空间 <span class="math inline">\(V\)</span> 有一组基 <span class="math inline">\(v_1,v_2\)</span>. 设 <span class="math inline">\(\sigma:V\rightarrow V\)</span> 是一个线性变换, 且满足 <span class="math inline">\(\sigma(v_1)=0\)</span>, <span class="math inline">\(\sigma(v_2)=v_1\)</span>. 证明: 如果 <span class="math inline">\(W\)</span> 是 <span class="math inline">\(V\)</span> 的一个 <span class="math inline">\(\sigma\)</span>-不变子空间, 则或者 <span class="math inline">\(W=0\)</span>, 或者 <span class="math inline">\(W\)</span> 是由 <span class="math inline">\(v_1\)</span> 生成的1维子空间, 或者 <span class="math inline">\(W=V\)</span>.</p></li><li><p>设 <span class="math inline">\(V\)</span> 是域 <span class="math inline">\(F\)</span> 上的向量空间, <span class="math inline">\(W\)</span> 是 <span class="math inline">\(V\)</span> 的一个子空间. 证明: 存在 <span class="math inline">\(V\)</span> 的子空间 <span class="math inline">\(W&#39;\)</span>, s.t. <span class="math inline">\(V=W\oplus W&#39;\)</span>.</p></li><li><p>判断下列域 <span class="math inline">\(F\)</span> 上的 <span class="math inline">\(n\)</span> 阶方阵 <span class="math inline">\(A\)</span> 能否对角化, 并说明理由.</p><ol type="1"><li><p><span class="math inline">\(A\)</span> 满足 <span class="math inline">\(A\neq 0\)</span>, <span class="math inline">\(A^2=0\)</span>.</p></li><li><p><span class="math inline">\(A\)</span> 满足 <span class="math inline">\(A^2=A\)</span>.</p></li></ol></li><li><p>设 <span class="math inline">\(\sigma:V\rightarrow V&#39;\)</span> 是一个线性映射. 证明 <span class="math inline">\(\sigma\)</span> 诱导出向量空间的同构 <span class="math display">\[\overline{\sigma}:V/\ker\sigma \xrightarrow{\sim} {\rm Im}\sigma,\quad v+\ker\sigma\mapsto\sigma(v).\]</span></p></li><li><p>试用向量组的线性相关性理论证明线性方程组有解的判别准则.</p></li></ol>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 各种试卷 </tag>
            
            <tag> 高等代数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2016年数学分析期中考试试卷</title>
      <link href="/2017/07/04/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62016%E5%B9%B4%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E6%9C%9F%E4%B8%AD%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7/"/>
      <content type="html"><![CDATA[<h2 id="试题">试题</h2><h3 id="计算题">计算题</h3><p>共50分, 前4题每题5分, 后3题每题10分.</p><ol type="1"><li><p><span class="math inline">\(\lim\limits_{(x,y)\to(0,0)}\frac{\sin(xy)}{xy}\)</span>.</p></li><li><p><span class="math inline">\(\lim\limits_{(x,y)\to(0,0)}(x+y)\sin\frac{1}{x^2+y^2}\)</span>.</p></li><li><p><span class="math inline">\(\lim\limits_{x\to\infty}\lim\limits_{y\to\infty}\frac{xy}{x+y}\)</span>.</p></li><li><p><span class="math inline">\(\lim\limits_{(x,y)\to(+\infty,+\infty)}\left(\frac{xy}{x^2+y^2}\right)^{x^2}\)</span>.</p></li><li><p>设 <span class="math inline">\(f(x,y)=(x+y,x-y,xy)\in\mathbb{R}^3\)</span>, <span class="math inline">\(g(x,y,z)=(xyz,ze^{xy})\in\mathbb{R}^2\)</span>. 记 <span class="math inline">\(F=f\circ g\)</span>, 求 <span class="math inline">\(F\)</span> 的Frechet导数 <span class="math inline">\(F&#39;(x,y,z)\)</span>.</p></li><li><p>求 <span class="math inline">\(f(x,y)=x^3+y^3-3xy\)</span> 的普通极值.</p></li><li><p>设方程 <span class="math inline">\(y-\frac{1}{2}\sin y=x\)</span> 能确定隐函数 <span class="math inline">\(y=f(x)\)</span>, 令 <span class="math inline">\(z=e^{x+y}\)</span>, 求 <span class="math inline">\(\frac{dz}{dx}\)</span>, <span class="math inline">\(\frac{d^2z}{dx^2}\)</span>.</p></li></ol><h3 id="证明题">证明题</h3><p>共50分, 每题10分.</p><ol type="1"><li><p>证明: <span class="math inline">\(f(x,y)=\frac{xy}{x+y}\)</span> 在 <span class="math inline">\((x,y)=(0,0)\)</span> 处极限不存在.</p></li><li><p>设数值函数 <span class="math inline">\(f(x)\)</span> 在紧集 <span class="math inline">\(D\subset\mathbb{R}^n\)</span> 上连续, 且恒为正值, 求证: <span class="math inline">\(\exists~K&gt;0\)</span>, s.t. <span class="math inline">\(\forall~x\in D\)</span>, 有 <span class="math inline">\(f(x)&gt;K\)</span>.</p></li><li><p>证明: <span class="math display">\[f(x,y)=\begin{cases}\frac{xy}{\sqrt{x^2+y^2}}, &amp; (x,y)\neq(0,0) \\ 0, &amp; (x,y)=(0,0) \\ \end{cases}\]</span> 在 <span class="math inline">\((0,0)\)</span> 的邻域中连续且有有界的偏导数 <span class="math inline">\(f_x&#39;(x,y)\)</span> 和 <span class="math inline">\(f&#39;_y(x,y)\)</span>, 但函数在点 <span class="math inline">\((0,0)\)</span> 不可微 .</p></li><li><p>设 <span class="math inline">\(f:\mathbf{R}^n\rightarrow\mathbf{R}^n\)</span> 是开集 <span class="math inline">\(G\)</span> 上的 <span class="math inline">\(C^1\)</span> 类函数, 且 <span class="math inline">\(J_f(x_0)=0\)</span>, 记 <span class="math inline">\(y_0=f(x_0)\)</span>. 如果 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(x_0\)</span> 存在反函数 <span class="math inline">\(f^{-1}\)</span>, 求证 <span class="math inline">\(f^{-1}\)</span> 在 <span class="math inline">\(y_0\)</span> 不可微.</p></li><li><p>证明: 由方程 <span class="math display">\[y=x\varphi(x)+\psi(z)\]</span> 所定义的隐函数 <span class="math inline">\(z=z(x,y)\)</span> 满足方程 <span class="math display">\[\left(\frac{\partial z}{\partial y}\right)^2\frac{\partial^2 z}{\partial x^2}-2\frac{\partial z}{\partial x}\frac{\partial z}{\partial y}\frac{\partial^2 z}{\partial x\partial y}+\left(\frac{\partial z}{\partial x}\right)^2\frac{\partial^2 z}{\partial y^2}=0.\]</span></p></li></ol>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 各种试卷 </tag>
            
            <tag> 数学分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2016年数学分析期末考试试卷</title>
      <link href="/2017/07/03/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62016%E5%B9%B4%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7/"/>
      <content type="html"><![CDATA[<h2 id="试题">试题</h2><h3 id="计算题">计算题</h3><p>共20分, 前四题每题5分, 后3题每题10分.</p><ol type="1"><li><p>计算二重积分 <span class="math inline">\(\iint\limits_E xydxdy\)</span>, 其中 <span class="math inline">\(E\)</span> 是四条抛物线 <span class="math display">\[y^2=px,~y^2=qx,~x^2=ay,~x^2=by\]</span> 所围成的区域, <span class="math inline">\(0&lt;p&lt;q\)</span>, <span class="math inline">\(0&lt;a&lt;b\)</span>.</p></li><li><p>计算三重积分 <span class="math inline">\(\iiint\limits_Vxyzdxdydz\)</span>, 其中 <span class="math inline">\(V\)</span> 是由曲面 <span class="math display">\[x^2+y^2+z^2=1,x\geqslant,y\geqslant0,z\geqslant0\]</span> 所围成的区域.</p></li><li><p>计算第一型曲线积分 <span class="math inline">\(\int\nolimits_C(x^2+y^2)ds\)</span>, 其中 <span class="math inline">\(C\)</span> 为曲线 <span class="math display">\[x=a(\cos t+t\sin t),y=a(\sin t-t\cos t)~(0\leqslant t \leqslant 2\pi).\]</span></p></li><li><p>计算第一型曲面积分 <span class="math inline">\(\iint\limits_S(x+y+z)dS\)</span>, 其中 <span class="math inline">\(S\)</span> 为曲面 <span class="math inline">\(x^2+y^2+z^2=a^2\)</span>, <span class="math inline">\(z\geqslant0\)</span>.</p></li><li><p>设 <span class="math inline">\(\sin z-xyz=0\)</span>, 当 <span class="math inline">\(\cos z-xy\neq0\)</span> 时, 求 <span class="math inline">\(\frac{\partial z}{\partial x}\)</span>, <span class="math inline">\(\frac{\partial^2 z}{\partial y\partial x}\)</span>.</p></li><li><p>求函数 <span class="math inline">\(f(x,y,z)=x-2y+2z\)</span> 在球面 <span class="math inline">\(x^2+y^2+z^2=1\)</span> 上的最大、最小值.</p></li><li><p>计算第二型曲线积分 <span class="math inline">\(\oint\nolimits_C e^x[(1-\cos y)dx-(y-\sin y)dy]\)</span>, 其中 <span class="math inline">\(C\)</span> 是曲线 <span class="math inline">\(y=\sin x\)</span> 介于 <span class="math inline">\([0,1]\)</span> 的一段, <span class="math inline">\(C\)</span> 的方向对应于 <span class="math inline">\(x\)</span> 增加的方向.</p></li></ol><h3 id="证明题">证明题</h3><p>共50分, 每题10分.</p><ol type="1"><li><p>设二元数值函数 <span class="math inline">\(f(x,y)\)</span> 在 <span class="math inline">\([a,b]\times[c,d]\)</span> 上连续, 一元数值函数序列 $ &amp;#123; _n(x) &amp;#125; $ 在 <span class="math inline">\([a,b]\)</span> 上一致收敛, 且 <span class="math inline">\(\phi_n(x)\in [c,d]\)</span>. 则 <span class="math inline">\(g_n=f(x,\phi_n(x))\)</span> 在 <span class="math inline">\([a,b]\)</span> 上一致收敛.</p></li><li><p>设数值函数 <span class="math inline">\(z=f(x,y)\)</span> 在矩形区域 <span class="math inline">\(D=[a,b]\times[c,d]\subset\mathbb{R}^2\)</span> 上偏导数有界, 求证: <span class="math inline">\(f\)</span> 在 <span class="math inline">\(D\)</span> 上一致连续.</p></li><li><p>设三重积分 <span class="math inline">\(\iiint\limits_D f(x,y,z)dxdydz\)</span> 存在, 区域 <span class="math inline">\(D\)</span> 关于 <span class="math inline">\(xOy\)</span> 平面对称, 被积函数 <span class="math inline">\(f\)</span> 关于 <span class="math inline">\(x\)</span> 是一个奇函数, 即 <span class="math inline">\(f(-x,y,z)=-f(x,y,z)\)</span>, 求证: <span class="math inline">\(\iiint\limits_D f(x,y,z)dxdydz=0\)</span>.</p></li><li><p>设 <span class="math inline">\(f\in C[0,a]\)</span>, 即 <span class="math inline">\(f\)</span> 在区间 <span class="math inline">\([0,1]\)</span> 上连续, 证明: <span class="math display">\[\int\nolimits_0^a dx_1\int\nolimits_0^{x_1}dx_2\cdots\int_0^{x_{n-1}} f(x_1)f(x_2)\cdots f(x_n)dx_n=\frac{1}{n!}\left[\int\nolimits_0^a f(x)dx\right]^n.\]</span></p></li><li><ol type="i"><li>设 <span class="math inline">\(S\)</span> 为 <span class="math inline">\(\mathbb{R}^3\)</span> 空间中分片光滑的封闭定向曲面, <span class="math inline">\(\nu_0\)</span> 为任意固定的方向, <span class="math inline">\(N\)</span> 为 <span class="math inline">\(S\)</span> 的单位外法向量, 求证 <span class="math display">\[\iint\limits_S \cos(\nu_0, N)dS=0.\]</span> (ii) 证明Lebesgue引理: 设 <span class="math inline">\(\mathbb{R}^n\)</span> 中的紧集 <span class="math inline">\(D\)</span> 有一个开覆盖 $= &amp;#123; G_&amp;#125; $, 则存在正数 <span class="math inline">\(l&gt;0\)</span>, 对于 <span class="math inline">\(\forall~x\in D\)</span>, <span class="math inline">\(\exists~G_\alpha\in\mathfrak{C}\)</span>, s.t. <span class="math inline">\(x\)</span> 的球(方)邻域 <span class="math inline">\(U(x,l)\subset G_\alpha\)</span>.</li></ol></li></ol>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 各种试卷 </tag>
            
            <tag> 数学分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2016年近世代数期末考试试卷</title>
      <link href="/2017/07/03/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62016%E5%B9%B4%E8%BF%91%E4%B8%96%E4%BB%A3%E6%95%B0%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7/"/>
      <content type="html"><![CDATA[<h2 id="试题">试题</h2><ol type="1"><li>(20分) 整数集 <span class="math inline">\(\mathbb{Z}\)</span> 关于普通加法构成有理数集 <span class="math inline">\(\mathbb{Q}\)</span> 的子群. 任取 <span class="math inline">\(q\in\mathbb{Q}\)</span>, 用 <span class="math inline">\([q]=q+\mathbb{Z}\)</span> 表示商群 <span class="math inline">\(\mathbb{Q}/\mathbb{Z}\)</span> 中对应的元素.<ol type="1"><li>写出商群 <span class="math inline">\(\mathbb{Q}/\mathbb{Z}\)</span> 的单位元.</li><li>求元素 <span class="math inline">\([\frac{9}{4}]\)</span> 在群 <span class="math inline">\(\mathbb{Q}/\mathbb{Z}\)</span> 的阶.</li><li>证明: 群 <span class="math inline">\(\mathbb{Q}/\mathbb{Z}\)</span> 中每个元素的阶都有限.</li><li><span class="math inline">\(\mathbb{Q}/\mathbb{Z}\)</span> 是不是循环群? 为什么?</li></ol></li><li>(15分) 下列三个群互相同构吗? 说明理由. 其中, <span class="math inline">\(A_4\)</span> 代表4次交错群, <span class="math inline">\(\mathbb{Z}_{12}\)</span> 代表模12的剩余类加群, 等等.<ol type="1"><li><span class="math inline">\(\mathbb{Z}_{12}\)</span>.</li><li><span class="math inline">\(\mathbb{Z}_3\times\mathbb{Z}_4\)</span>. (群的外直积)</li><li><span class="math inline">\(A_4\)</span>.</li></ol></li><li><p>(10分) 设 <span class="math inline">\(G\)</span> 是一个群, 任取 <span class="math inline">\(x\in G\)</span>, 称 $C_x= &amp;#123; gxg^{-1}|gG &amp;#125; $ 为元素 <span class="math inline">\(x\)</span> 所在的共轭类. 每个共轭类 <span class="math inline">\(C_x\)</span> 中所含元素的个数一定整除群的阶 <span class="math inline">\(|G|\)</span>, 为什么?</p></li><li>(20分) 令 $[i]= &amp;#123; a+bi|a,b &amp;#125; $ 代表高斯整环. 在 <span class="math inline">\(\mathbb{Z}[i]\)</span> 中定义范数如下: <span class="math display">\[N(a+bi)=a^2+b^2.\]</span><ol type="1"><li>求出 <span class="math inline">\(\mathbb{Z}[i]\)</span> 中的所有单位 (即乘法可逆元).</li><li>求出 <span class="math inline">\(\mathbb{Z}[i]\)</span> 的商域.</li><li>素数2是 <span class="math inline">\(\mathbb{Z}[i]\)</span> 中的逆元吗? 为什么?</li><li>有人说, <span class="math inline">\(\mathbb{Z}[i]\)</span> 中的非零素理想也是极大理想. 你认为对吗? 为什么?</li></ol></li><li>(10分) 设 <span class="math inline">\(E=\mathbb{Q}(\sqrt{2},i)\)</span> 是有理数域 <span class="math inline">\(\mathbb{Q}\)</span> 的扩域.<ol type="1"><li>求扩域的次数 <span class="math inline">\([E:\mathbb{Q}]\)</span>.</li><li>证明: <span class="math inline">\(E=\mathbb{Q}(\sqrt{2}+i)\)</span>.</li></ol></li><li>(20分) 考虑有限域 <span class="math inline">\(\mathbb{Z}_3\)</span> 上的不可约多项式 <span class="math inline">\(p(x)=x^2+x-1\)</span>.<ol type="1"><li>设 <span class="math inline">\(\alpha\)</span> 是 <span class="math inline">\(p(x)\)</span> 在它的分裂域中的一个根. 单扩域 <span class="math inline">\(\mathbb{Z}_3(\alpha)\)</span> 是 <span class="math inline">\(\mathbb{Z}_3\)</span> 上的几次扩域?</li><li>写出 <span class="math inline">\(\mathbb{Z}_3(\alpha)\)</span>作为 <span class="math inline">\(\mathbb{Z}_3\)</span> 上的向量空间的一组基.</li><li>用这组基表达 <span class="math inline">\(\alpha\)</span> 和 <span class="math inline">\(1+\alpha\)</span> 在 <span class="math inline">\(\mathbb{Z}_3(\alpha)\)</span> 中的逆元.</li><li>证明: <span class="math inline">\(p(x)\)</span> 整除 <span class="math inline">\(x^9-x\)</span> (在 <span class="math inline">\(\mathbb{Z}_3[x]\)</span> 中).</li></ol></li><li><p>(5分) 考虑81元域 <span class="math inline">\(F\)</span> 的非零元乘法群 <span class="math inline">\(F^\times\)</span>. 设 <span class="math inline">\(\alpha\)</span> 是 <span class="math inline">\(F^\times\)</span> 的生成元. 证明: <span class="math inline">\(\alpha^{40}=-1\)</span>.</p></li></ol>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 各种试卷 </tag>
            
            <tag> 近世代数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2016年近世代数期中考试试卷</title>
      <link href="/2017/07/03/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62016%E5%B9%B4%E8%BF%91%E4%B8%96%E4%BB%A3%E6%95%B0%E6%9C%9F%E4%B8%AD%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7/"/>
      <content type="html"><![CDATA[<h2 id="试题">试题</h2><ol type="1"><li><p>(10分) 用 <span class="math inline">\(S_4\)</span> 代表4次对称群. 按共轭类写出 <span class="math inline">\(S_4\)</span> 的全部元素.</p></li><li>(10分)<ol type="1"><li>循环群 <span class="math inline">\(\mathbb{Z}_{28}\)</span> 中的7阶元有几个?</li><li><span class="math inline">\(\mathbb{Z}_{28}\)</span> 有几个7阶子群?</li></ol></li><li>(15分) 令 <span class="math inline">\(\varphi:(\mathbb{R},+)\longrightarrow (\mathbb{C}^\times,\cdot)\)</span> 是由 <span class="math inline">\(\varphi(x)=e^{ix}\)</span> 定义的函数, 其中 <span class="math inline">\((\mathbb{R},+)\)</span> 和 <span class="math inline">\((\mathbb{C}^\times,+)\)</span> 分别代表实数的加法群和非零复数的乘法群.<ol type="1"><li>证明: <span class="math inline">\(\varphi\)</span> 是一个群同态.</li><li>求 <span class="math inline">\(\ker\varphi\)</span> 和 <span class="math inline">\({\rm Im}~\varphi\)</span>.</li><li>根据同态基本定理, 你能得到什么结论?</li></ol></li><li><p>(15分) 应用群作用证明: 8阶群的中心至少有两个元素.</p></li><li>(10分) 求下列环中的(乘法)可逆元:<ol type="1"><li>模8的剩余类环 <span class="math inline">\(\mathbb{Z}/8\mathbb{Z}\)</span>.</li><li>高斯整环 <span class="math inline">\(\mathbb{Z}[i]\)</span>.</li></ol></li><li>(20分)<ol type="1"><li><span class="math inline">\(\mathbb{Z}_{10}\)</span> 与 <span class="math inline">\(\mathbb{Z}_2\times\mathbb{Z}_5\)</span> 作为环同构吗? 为什么?</li><li><span class="math inline">\(\mathbb{Z}_9\)</span> 与 <span class="math inline">\(\mathbb{Z}_3\times\mathbb{Z}_3\)</span> 作为环同构吗? 为什么?</li></ol></li><li>(20分)<ol type="1"><li>利用环的同态基本定理证明: <span class="math inline">\(\mathbb{Z}[x]/\langle x^2+1\rangle\cong\mathbb{Z}[i]\)</span>.</li><li><span class="math inline">\(\langle x^2+1 \rangle\)</span> 是 <span class="math inline">\(\mathbb{Z}[i]\)</span> 的素理想吗? 是极大理想吗?</li></ol></li></ol>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 各种试卷 </tag>
            
            <tag> 近世代数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2017年实变函数期末考试试卷</title>
      <link href="/2017/07/02/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62017%E5%B9%B4%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7/"/>
      <content type="html"><![CDATA[<h2 id="试题">试题</h2><ol type="1"><li><p>(15分) 设 $ &amp;#123; E_k &amp;#125; $ 是 <span class="math inline">\([0,1]\)</span> 中的可测集列, <span class="math inline">\(m(E_k)=1~(k=1,2,\cdots)\)</span>, 试证明 <span class="math display">\[m\left(\bigcap_{k=1}^\infty E_k\right)=1.\]</span></p></li><li><p>(15分) 试证明点集 <span class="math inline">\(E\)</span> 可测的充分必要条件是: 对于任给的 <span class="math inline">\(\epsilon&gt;0\)</span>, 存在开集 <span class="math inline">\(G_1,G_2\)</span>: <span class="math display">\[G_1\supset E,\quad G_2\supset E^C\]</span> 使得 <span class="math inline">\(m(G_1\cap G_2)&lt;\epsilon\)</span>.</p></li><li><p>(15分) 设 <span class="math inline">\(E\subset \mathbb{R}\)</span> 上可测函数列 $ &amp;#123; f_k(x) &amp;#125; $ 满足 <span class="math display">\[f_k(x)\geqslant f_{k+1}(x),(k=1,2,\cdots).\]</span> 若 <span class="math inline">\(f_k\)</span> 在 <span class="math inline">\(E\)</span> 上依测度收敛到0, 试问 <span class="math inline">\(f_k\)</span> 在 <span class="math inline">\(E\)</span> 上是否几乎处处收敛到0.</p></li><li><p>(15分) 设 <span class="math inline">\(f(x)\)</span> 是 <span class="math inline">\((0,1)\)</span> 上的非负可测函数, 若存在 <span class="math inline">\(c\)</span> 使得 <span class="math display">\[\int\nolimits_{[0,1]}[f(x)]^ndx=c,(n=1,2,\cdots)\]</span> 试证明存在非负可测集 <span class="math inline">\(E\subset(0,1)\)</span>, s.t. <span class="math inline">\(f(x)=\chi_E(x)\)</span>, a.e. 若 <span class="math inline">\(f(x)\)</span> 不是非负的, 结论又如何?</p></li><li><p>(15分) 设 <span class="math inline">\(f\in L(0,a)\)</span>, <span class="math inline">\(g(x)=\int\nolimits_x^a \frac{f(t)}{t}dt\)</span>, <span class="math inline">\(a&gt;x&gt;0\)</span>. 试证明 <span class="math inline">\(g\in L(0,a)\)</span>, 且有 <span class="math display">\[\int\nolimits_0^a g(x)dx=\int\nolimits_0^a f(x)dx.\]</span></p></li><li><p>(15分) 设 <span class="math inline">\(f\in L^2(0,\infty)\)</span>, 且 <span class="math inline">\(f\geqslant 0\)</span>. 设 <span class="math inline">\(F(x)=\int\nolimits_0^x f(t)dt\)</span>, 试证明 <span class="math display">\[F(x)=o(\sqrt{x})~(x\to0,x\to\infty).\]</span></p></li><li>(10分) 设 <span class="math inline">\(f\in L^1(\mathbb{R}^n)\)</span>, 对 <span class="math inline">\(x\in\mathbb{R}^n\)</span>, 称 <span class="math display">\[\hat{f}(x)=\int\nolimits_{\mathbb{R}^n} f(t)e^{-2\pi x\cdot t}dx\]</span> 为 <span class="math inline">\(f\)</span> 的Fourier变换. 请验证以下几个性质:<ol type="a"><li><span class="math inline">\(||\hat{f}||_{L^\infty(\mathbb{R}^n)}\leqslant ||f||_{L^1(\mathbb{R}^n)}\)</span>.</li><li><span class="math inline">\(\hat{f}\)</span> 在 <span class="math inline">\(\mathbb{R}^n\)</span> 上一致连续.</li><li><span class="math inline">\(\lim\limits_{|x|\to\infty}\hat{f}(x)=0\)</span>. (提示: 计算阶梯函数的Fourier变换, 再应用阶梯函数在 <span class="math inline">\(L^1(\mathbb{R}^n)\)</span> 的稠密性).</li></ol></li></ol><p>记号说明: <span class="math inline">\(x,t\in\mathbb{R}^n\)</span>, 那么 <span class="math inline">\(x\cdot t=x_1t_1+x_2t_2+\cdots+x_nt_n\)</span>. 欧拉公式: <span class="math display">\[e^{i\theta}=\cos\theta+i\sin\theta.\]</span></p>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 各种试卷 </tag>
            
            <tag> 实变函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2017年复变函数期末考试试卷</title>
      <link href="/2017/07/02/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62017%E5%B9%B4%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7/"/>
      <content type="html"><![CDATA[<h2 id="试题">试题</h2><ol type="1"><li><p>(15分)叙述函数 <span class="math inline">\(f(z)=u(x,u)+iv(x,y)\)</span> 在一点的(复)可微和解析的定义且讨论函数 <span class="math inline">\(f(z)=x^3y+iy^3x\)</span> 的(复)可微性和解析性(在何处(复)可微和解析).</p></li><li>(25分)将下列函数在指定圆环内展成洛朗级数:<ol type="1"><li><span class="math inline">\(\frac{1}{z^2(z^2-9)},\quad 3&lt;|z|&lt;+\infty\)</span>;</li><li><span class="math inline">\(\cos(\frac{1}{z-1}),\quad 1&lt;|z-1|&lt;+\infty\)</span>;</li><li><span class="math inline">\(\frac{f(z)}{z^5}\)</span>, <span class="math inline">\(f(z)\)</span> 为 <span class="math inline">\({\rm Ln}(1-z)\)</span> 在 <span class="math inline">\(|z|&lt;1\)</span> 中满足 <span class="math inline">\(f(0)=0\)</span> 的解析分支.</li></ol></li><li><p>(25分) (1)求函数 (a) <span class="math inline">\(\frac{z^2-4}{z(z^2-1)^2}\)</span> 和 (b) <span class="math inline">\(\frac{1}{z^4\sin z}\)</span> 在复平面 <span class="math inline">\(\mathbb{C}\)</span> (不含 <span class="math inline">\(\infty\)</span> 点)中的孤立奇点, 孤立奇点各属于哪一种类型(极点要指明阶数). (2)求函数 <span class="math inline">\(\frac{1}{\sin z}\)</span>, <span class="math inline">\(\frac{1}{z^2\sin z}\)</span>, <span class="math inline">\(\frac{1}{z^4\sin z}\)</span> 在 <span class="math inline">\(0\)</span> 处的留数.</p></li><li><p>(10分)分式线性映射 <span class="math inline">\(w=T(z)=\frac{z+i}{z-i}\)</span> 将指定区域 $= &amp;#123; z:{}<sub>z&lt;0,{}</sub>z&lt;0 &amp;#125; $ 映射为什么区域? ( <span class="math inline">\(T(\Omega)=~?\)</span> 作草图标明原像区域和像区域, 并说明理由.)</p></li><li><p>(15分)计算积分 <span class="math display">\[(1)~\int\nolimits_{-\infty}^{+\infty}\frac{x^2\cos x}{x^4+1}dx;\quad (2)\int\nolimits_0^{+\infty}\frac{x^\alpha}{4+x^2}dx~~(-1&lt;\alpha&lt;1).\]</span></p></li><li><p>(10分)说明多值函数 <span class="math inline">\((z^2(1+z)^3)^\frac{1}{5}\)</span> 在割去线段 <span class="math inline">\([-1,0]\)</span> 的 <span class="math inline">\(z\)</span> 平面上可以分出五个单值连续分支. 求出在 <span class="math inline">\([-1,0]\)</span> 的上沿取正值的那个单值解析分支 <span class="math inline">\(g_0(z)\)</span> 在 <span class="math inline">\(z=1\)</span> 点处的值和在点 <span class="math inline">\(z=i\)</span> 处的值.</p></li></ol>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 各种试卷 </tag>
            
            <tag> 复变函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>组合数学复习重点</title>
      <link href="/2017/06/24/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/"/>
      <content type="html"><![CDATA[<h2 id="第二章-抽屉原理">第二章 抽屉原理</h2><p>吧 <span class="math inline">\(n+1\)</span> 个物体放入 <span class="math inline">\(n\)</span> 个抽屉, 则至少存在一个抽屉里面有至少两个物体.</p><h2 id="第三章-排列组合">第三章 排列组合</h2><h3 id="重集的排列">重集的排列</h3><p><span class="math inline">\(k\)</span> 种元素, 个数无限: <span class="math inline">\(r\)</span>-排列数为 <span class="math inline">\(k^r\)</span>. <span class="math inline">\(k\)</span> 种元素, 第 <span class="math inline">\(i\)</span> 种有 <span class="math inline">\(n_i\)</span> 个: 全排列为 <span class="math inline">\(\frac{(n_1+\cdots+n_k)!}{n_1!\cdots n_k!}\)</span>.</p><h3 id="重集的组合">重集的组合</h3><p><span class="math inline">\(x_1+\cdots+x_k=r\)</span> 的非负整数解个数为 <span class="math inline">\(\binom{r+k-1}{r}\)</span>.</p><h2 id="第四章-二项式系数">第四章 二项式系数</h2><h3 id="组合恒等式">组合恒等式</h3><ol type="1"><li>(帕斯卡公式): <span class="math inline">\(\binom{\alpha}{k}=\binom{\alpha-1}{k}+\binom{\alpha-1}{k-1}\)</span>;</li><li><span class="math inline">\(\binom{\alpha}{k}\binom{k}{p}=\binom{\alpha}{p}\binom{\alpha-p}{k-p}=\binom{\alpha}{k-p}\binom{\alpha+p-k}{p}\)</span>;</li><li><span class="math inline">\(\binom{\alpha+k}{p+k}\binom{p+k}{k}=\binom{\alpha+k}{k}\binom{\alpha}{p}\)</span>;</li><li><span class="math inline">\(\sum\limits_{k=0}^n\binom{n}{k}=\sum\limits_k\binom{n}{k}=2^n\)</span>;</li><li><span class="math inline">\(\sum\limits_{k=0}^n(-1)^k\binom{\alpha}{k}=(-1)^m\binom{\alpha-1}{m}\)</span>;</li><li><span class="math inline">\(\sum\limits_{k=0}^n\binom{\alpha}{k}\binom{\beta}{n-k}=\binom{\alpha+\beta}{n}\)</span>;</li><li><span class="math inline">\(\sum\limits_{k=0}^n\binom{\alpha+k}{k}\binom{\beta-k}{n-k}=\binom{\alpha+\beta+1}{n}\)</span>.</li></ol><h2 id="第五章-容斥原理">第五章 容斥原理</h2><h3 id="符号说明">符号说明</h3><ul><li><span class="math inline">\(A_i\)</span>: <span class="math inline">\(S\)</span> 中满足性质 <span class="math inline">\(P_i\)</span> 的元素集合;</li><li><span class="math inline">\(N(i)\)</span>: <span class="math inline">\(S\)</span> 中恰好具有 <span class="math inline">\(i\)</span> 个性质的元素集合;</li><li><span class="math inline">\(L(i)\)</span>: <span class="math inline">\(S\)</span> 中至少具有 <span class="math inline">\(i\)</span> 个性质的元素集合;</li><li><span class="math inline">\(W(i)\)</span>: <span class="math inline">\(A_1,\cdots,A_m\)</span> 中所有 <span class="math inline">\(i\)</span> 个交集的元素个数之和.</li></ul><h3 id="容斥原理">容斥原理</h3><ol type="1"><li><span class="math inline">\(N(0)=W(0)-W(1)+W(2)-\cdots+(-1)^mW(m)\)</span>;</li><li><span class="math inline">\(L(1)=|S|-N(0)=W(1)-W(2)+W(3)-\cdots+(-1)^{m-1}W(m)\)</span>.</li></ol><h3 id="重集的组合-1">重集的组合</h3><blockquote><p>求方程 <span class="math inline">\(x_1+\cdots+x_n=r\)</span> 带上下界 <span class="math inline">\((a_i\leqslant x_i\leqslant b_i)\)</span> 的整数解个数.</p></blockquote><p><strong>解答</strong>: 先做变换 <span class="math inline">\(y_i=x_i-a_i\)</span>, 则方程变形为 <span class="math inline">\(y_1+\cdots+y_n=r-a_1-\cdots-a_n\)</span>. 记 <span class="math inline">\(y_i\leqslant b_i-a_i\)</span> 为条件 <span class="math inline">\(P_i\)</span>, 用容斥原理即可.</p><h3 id="错位排列与禁位排列">错位排列与禁位排列</h3><h4 id="错位排列">错位排列</h4><ul><li>递推: <span class="math inline">\(D_n=(n-1)(D_{n-1}+D_{n-2})\)</span>, <span class="math inline">\(D_1=0\)</span>, <span class="math inline">\(D_2=1\)</span>;</li><li>通项: <span class="math inline">\(D_n=n!\cdot\left(1-\frac{1}{1!}+\frac{1}{2!}-\cdots+\frac{1}{n!}\right)\)</span>.</li></ul><h4 id="禁位排列">禁位排列</h4><ul><li>递推: <span class="math inline">\(Q_n=(n-1)Q_{n-1}+(n-2)Q_{n-2}\)</span>;</li><li>组合证明: 考虑去掉 <span class="math inline">\(n\)</span> 的情况, 若前 <span class="math inline">\(n-1\)</span> 项本身就能构成禁位排列, 则只需要 <span class="math inline">\(n\)</span> 不在 <span class="math inline">\(n-1\)</span> 后即可, 方案数 <span class="math inline">\((n-1)Q_{n-1}\)</span>; 若前 <span class="math inline">\(n-1\)</span> 项本身不能构成禁位排列, 则只能有一个 <span class="math inline">\(i\)</span> 使得 <span class="math inline">\(a_{i+1}=a_i+1\)</span>, 则此时 <span class="math inline">\(n\)</span> 只能放在此处, 考虑到 <span class="math inline">\(i\)</span> 有 <span class="math inline">\(n-2\)</span> 种选择, 并且去掉 <span class="math inline">\(i+1\)</span> 后, 序列构成长度为 <span class="math inline">\(n-2\)</span> 的禁位排列, 此时方案数为 <span class="math inline">\((n-2)Q_{n-2}\)</span>, 得证.</li></ul><h2 id="第六章-递推关系与生产函数">第六章 递推关系与生产函数</h2><h3 id="递推关系">递推关系</h3><h4 id="线性-齐次-常系数">线性 齐次 常系数</h4><p><span class="math inline">\(h_n-a_1h_{n-1}-\cdots-a_kh_{n-k}=0\)</span> 的特征方程为 <span class="math inline">\(q_k-a_1q_{k-1}-\cdots-a_k=0\)</span></p><ol type="1"><li>若特征方程有 <span class="math inline">\(k\)</span> 个单根, 则通解为 <span class="math inline">\(h_n=C_1q_1^n+\cdots+C_kq_k^n\)</span>;</li><li>若 <span class="math inline">\(q_i\)</span> 的重数为 <span class="math inline">\(s_i\)</span>, 则通解为 <span class="math inline">\(n^jq_i,~0\leqslant j\leqslant s_i,~1\leqslant i\leqslant k\)</span> 的线性组合.</li></ol><h4 id="非齐次">非齐次</h4><p>求一个特解, 然后求齐次方程的通解. 设 <span class="math inline">\(f(n)=D_r(n)q^n\)</span>, <span class="math inline">\(D_r\)</span> 为 <span class="math inline">\(r\)</span> 次多项式, 则有特解 <span class="math display">\[h(n)=n^sF_r(n)q^n\]</span> 其中 <span class="math inline">\(F_r\)</span> 为多项式, <span class="math inline">\(s\)</span> 是 <span class="math inline">\(q\)</span> 的重数.</p><h3 id="生成函数">生成函数</h3><p>生成函数: <span class="math inline">\(h(x)=\sum\limits_{n=0}^\infty h_nx^n\)</span>.</p><blockquote><p>若递推式为 <span class="math inline">\(h_n+a_1h_{n-1}+\cdots+a_kh_{n-k}=0\)</span>, 则其生成函数为 <span class="math display">\[h(x)=\frac{b_0+b_1x+\cdots+b_{k-1}x^{k-1}}{1+a_1x+\cdots+a_kx^k}.\]</span> 其中 <span class="math inline">\(b_n=\sum\limits_{i=0}^n a_ih_{n-i}\)</span>, <span class="math inline">\(a_0=1\)</span>.</p></blockquote><h2 id="第八章-二分图匹配">第八章 二分图匹配</h2><h3 id="最大匹配">最大匹配</h3><p>找 <span class="math inline">\(M\)</span>-交错链, 标记算法求最大匹配.</p><blockquote><p>König定理: 最大匹配 <span class="math inline">\(=\)</span> 最小点覆盖.</p></blockquote><p><span class="math inline">\(p\)</span>-正则: 每个点度都是 <span class="math inline">\(p\)</span>. 完美匹配: 若二分图 <span class="math inline">\(G\)</span> 满足 <span class="math inline">\(|X|=|Y|=n\)</span>, 且一个匹配含 <span class="math inline">\(n\)</span> 条边, 则称其为完美匹配.</p><blockquote><p>定理: <span class="math inline">\(p\geqslant 1\)</span> 的 <span class="math inline">\(p\)</span>-正则二分图一定有完美匹配.</p></blockquote><h3 id="稳定匹配">稳定匹配</h3><p>延迟认可算法.</p><blockquote><p>定理: 由延迟认可算法得到的匹配是稳定匹配.</p></blockquote><h2 id="第九章-组合设计">第九章 组合设计</h2><h3 id="pk-元域的构造"><span class="math inline">\(p^k\)</span> 元域的构造</h3><p>取 <span class="math inline">\(\mathbb{Z}_p\)</span> 的 <span class="math inline">\(k\)</span> 次不可约多项式 <span class="math inline">\(f\)</span>, 令其 <span class="math inline">\(k\)</span> 个根为 <span class="math inline">\(a_1,\cdots,a_k\)</span>, 则 <span class="math inline">\(\mathbb{Z}_p\)</span> 的 <span class="math inline">\(k\)</span> 次扩张 <span class="math inline">\(\mathbb{Z}_p(a_1,\cdots,a_k)\)</span> 即为 <span class="math inline">\(p^k\)</span> 元域.</p><h3 id="区组设计">区组设计</h3><h4 id="bibd-的性质">BIBD 的性质</h4><ul><li>每一组含 <span class="math inline">\(k\)</span> 个元素;</li><li>每一对都恰好出现在 <span class="math inline">\(\lambda\)</span> 个区组中, 则为平衡区组设计(Balanced);</li><li><span class="math inline">\(k&lt;v\)</span>, 不完全(Incomplete);</li></ul><blockquote><p>定理: BIBD 中, <span class="math inline">\(r(k-1)=\lambda(v-1)\)</span>.</p></blockquote><p>可利用包含 <span class="math inline">\(x_i\)</span> 的元素对的个数来组合证明.</p><blockquote><p>定理: BIBD 中, <span class="math inline">\(bk=vr\)</span>.</p></blockquote><p>可利用 BIBD 的关联矩阵中 <span class="math inline">\(1\)</span> 的个数来组合证明.</p><blockquote><p>定理: BIBD 中, <span class="math inline">\(b\geqslant v\)</span>.</p></blockquote><p><span class="math inline">\(b=v\)</span> 时称为 SBIBD (symmetric).</p><h4 id="符号说明-1">符号说明</h4><ul><li><span class="math inline">\(b\)</span>: 区组的个数;</li><li><span class="math inline">\(v\)</span>: 集合元素总数;</li><li><span class="math inline">\(k\)</span>: 每个区组中的元素个数;</li><li><span class="math inline">\(r\)</span>: 包含任何一个特定元素的不同区组的个数;</li><li><span class="math inline">\(\lambda\)</span>: 包含任何一对特定元素的不同区组的个数.</li></ul><h4 id="sbibd-的构造">SBIBD 的构造</h4><blockquote><p>定理: 若 <span class="math inline">\(B\)</span> 是 <span class="math inline">\(\mathbb{Z}_v\)</span> 的差分集, 则 <span class="math inline">\(B\)</span> 生成的区组构成一个指标为 <span class="math inline">\(\lambda=\frac{k(k-1)}{v-1}\)</span> 的 SBIBD.</p></blockquote><p>如 <span class="math inline">\(\mathbb{Z}_7\)</span> 中取 $B= &amp;#123; 0,1,3 &amp;#125; $, 则 <span class="math display">\[\begin{align}B+0 &amp;= \&amp;#123; 0,1,3 \&amp;#125; , \\B+1 &amp;= \&amp;#123; 1,2,4 \&amp;#125; , \\B+2 &amp;= \&amp;#123; 2,3,5 \&amp;#125; , \\B+3 &amp;= \&amp;#123; 3,4,6 \&amp;#125; , \\B+4 &amp;= \&amp;#123; 4,5,0 \&amp;#125; , \\B+5 &amp;= \&amp;#123; 5,6,1 \&amp;#125; , \\B+6 &amp;= \&amp;#123; 6,0,2 \&amp;#125; , \\\end{align}\]</span> 构成一个 <span class="math inline">\(b=v=7,~k=r=3,~\lambda=1\)</span> SBIBD.</p><h3 id="steiner三元系统">Steiner三元系统</h3><blockquote><p>定理: STS 中, <span class="math inline">\(r=\frac{\lambda(v-1)}{2},~b=\frac{\lambda v(v-1)}{6}\)</span>.</p></blockquote><p>一个 <span class="math inline">\(v=9,~\lambda=1\)</span> 的 STS: <span class="math display">\[\begin{align}&amp; \&amp;#123; 0,1,2 \&amp;#125; , \&amp;#123; 3,4,5 \&amp;#125; , \&amp;#123; 6,7,8 \&amp;#125; , \\&amp; \&amp;#123; 0,3,6 \&amp;#125; , \&amp;#123; 1,4,7 \&amp;#125; , \&amp;#123; 2,5,8 \&amp;#125; , \\&amp; \&amp;#123; 0,4,8 \&amp;#125; , \&amp;#123; 1,5,6 \&amp;#125; , \&amp;#123; 2,3,7 \&amp;#125; , \\&amp; \&amp;#123; 0,5,7 \&amp;#125; , \&amp;#123; 1,3,8 \&amp;#125; , \&amp;#123; 2,4,6 \&amp;#125; . \\\end{align}\]</span></p><h3 id="拉丁方">拉丁方</h3><p><span class="math inline">\(n\)</span> 阶拉丁方: 由 <span class="math inline">\(n\)</span> 个元素构成的 <span class="math inline">\(n\times n\)</span> 方阵, 每行每列都包含了所有 <span class="math inline">\(n\)</span> 个元素.</p><blockquote><p>定理: <span class="math inline">\((r,n)=1\)</span>, 则 <span class="math inline">\(a_{ij}=r\times i+j\)</span> 构成 <span class="math inline">\(\mathbb{Z}_n\)</span> 的拉丁方, 记作 <span class="math inline">\(\mathbf{L}_n^r\)</span>.</p></blockquote><h4 id="正交拉丁方">正交拉丁方</h4><p>将两个 <span class="math inline">\(n\)</span> 阶拉丁方对应位置的元素组成二元有序组, 可以构成一个新的 <span class="math inline">\(n\)</span> 阶方阵. 如果该方阵中, <span class="math inline">\((0,0)\sim (n-1,n-1)\)</span> 都恰好出现一次, 则称这两个拉丁方正交. 称两两正交的拉丁方为MOLS. 第一行为 <span class="math inline">\(0,\cdots,n-1\)</span> 的MOLS由如下定理给出:</p><blockquote><p>定理: 设 <span class="math inline">\(F\)</span> 是一个 <span class="math inline">\(n=p^k\)</span> 元域, 其中元素为 <span class="math inline">\(f_i\)</span>, 则 <span class="math inline">\(a_{ij}=r\times a_i+a_j\)</span> 为拉丁方, <span class="math inline">\(\forall~r\neq 0\in F\)</span>, 记作 <span class="math inline">\(\mathbf{L}_n^r\)</span>. 当 <span class="math inline">\(r\)</span> 取遍所有 <span class="math inline">\(F\)</span> 中非零值时, 可以得到 <span class="math inline">\(n-1\)</span> 个两两正交的拉丁方.</p></blockquote>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微分几何复习重点</title>
      <link href="/2017/06/23/%E5%BE%AE%E5%88%86%E5%87%A0%E4%BD%95%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/"/>
      <content type="html"><![CDATA[<h2 id="重要的定义">重要的定义</h2><h3 id="正则曲线">正则曲线</h3><p>给定参数曲线 <span class="math inline">\(C:r=r(t),~t\in(a,b)\)</span>. 若 <span class="math inline">\(r&#39;(t)\neq 0\)</span> 对于 <span class="math inline">\(\forall~t\)</span> 成立, 则称 <span class="math inline">\(C\)</span> 为<strong>正则曲线</strong>.</p><h3 id="曲线的容许参数变换">曲线的容许参数变换</h3><p>给定正则曲线 <span class="math inline">\(C:r=r(t)\)</span>, 若参数变换 <span class="math inline">\(t=t(u)\)</span> 满足</p><ol type="1"><li><span class="math inline">\(t(u)\)</span> 是 <span class="math inline">\(C^3\)</span> 阶的;</li><li><span class="math inline">\(t&#39;(u)\)</span> 处处非零,</li></ol><p>则称之为<strong>容许的参数变换</strong>. 当 <span class="math inline">\(t&#39;(u)&gt;0\)</span> 时称为保向的, <span class="math inline">\(t&#39;(u)&lt;0\)</span> 时称为反向的.</p><h3 id="曲率向量">曲率向量</h3><p>正则曲线 <span class="math inline">\(C:r=r(t)\)</span> 的单位切向量场 <span class="math inline">\(T(t(s))\)</span> 关于弧长 <span class="math inline">\(s\)</span> 的导向量 <span class="math inline">\(\frac{dT}{ds}=\frac{d^2r}{ds^2}\)</span> 称为曲线 <span class="math inline">\(C\)</span> 在 <span class="math inline">\(r(t(s))\)</span> 处的<strong>曲率向量</strong>; 曲率向量的模长 <span class="math inline">\(\kappa=|\frac{dT}{ds}|\)</span> 称为 <span class="math inline">\(C\)</span> 在 <span class="math inline">\(r(t(s))\)</span> 处的<strong>曲率</strong>.</p><h3 id="相对曲率">相对曲率</h3><p>给定二阶连续可微的弧长参数化平面曲线 <span class="math inline">\(C:r=r(s)=(x(s),y(s))\)</span>, 局部可取到切向角 <span class="math inline">\({\rm Arctan}\frac{y&#39;}{x&#39;}\)</span> 的可微单值支, 定义其对 <span class="math inline">\(s\)</span> 的导数 <span class="math inline">\(\kappa_r=\theta&#39;(s)\)</span> 为<strong>相对曲率</strong>.</p><h3 id="正则曲面">正则曲面</h3><p>给定参数曲面 <span class="math inline">\(S:r=r(u,v),~(u,v)\in U\)</span>. 若处处有 <span class="math inline">\(r_u(u,v)\times r_v(u,v)\neq 0\)</span>, 则称 <span class="math inline">\(S\)</span> 为<strong>正则曲面</strong>.</p><h3 id="曲面的容许参数变换">曲面的容许参数变换</h3><p>给定正则曲面 <span class="math inline">\(S:r=r(u,v)\)</span>, 若参数变换 <span class="math inline">\((u,v)=(u(x,y),v(x,y))\)</span> 满足:</p><ol type="1"><li>是连续可微的一一对应;</li><li>Jacobi 行列式 <span class="math inline">\(\frac{\partial(u,v)}{\partial(x,y)}\)</span> 处处非零,</li></ol><p>则称之为<strong>容许的参数变换</strong>, 若 <span class="math inline">\(\frac{\partial(u,v)}{\partial(x,y)}&gt;0\)</span>, 称为保向的, 若 <span class="math inline">\(\frac{\partial(u,v)}{\partial(x,y)}&lt;0\)</span>, 称为反向的.</p><h3 id="局部等距对应">局部等距对应</h3><p>对于两张对应的曲面, 若它们对应着的弧段总是具有相等的弧段长度, 则称这个对应是两张曲面的一个<strong>局部等距对应</strong>.</p><h3 id="内蕴量和内蕴几何体">内蕴量和内蕴几何体</h3><p>在曲面上, 由其第一基本形式可完全确定的几何量, 称为曲面的<strong>内蕴量</strong>; 由其第一基本形式可完全确定属性的几何体, 称为曲面的<strong>内蕴几何体</strong>.</p><h3 id="主曲率和主方向">主曲率和主方向</h3><p>曲面 <span class="math inline">\(S\)</span> 上的点 <span class="math inline">\(P\)</span> 处的法曲率关于切方向的两个最值, 分别称为曲面 <span class="math inline">\(S\)</span> 在 <span class="math inline">\(P\)</span> 处的<strong>主曲率</strong>, 使得法曲率达到最值的两个方向称为<strong>主方向</strong>.</p><h3 id="脐点">脐点</h3><p>若曲面 <span class="math inline">\(S\)</span> 在 <span class="math inline">\(P\)</span> 处的两个主曲率相等, 则称 <span class="math inline">\(P\)</span> 为曲面 <span class="math inline">\(S\)</span> 的<strong>脐点</strong>. 若脐点处的主曲率均为0, 称为平点, 否则称为圆点.</p><h3 id="极小曲面">极小曲面</h3><p>若曲面的平均曲率恒为零, 称之为<strong>极小曲面</strong>.</p><h3 id="抽象曲面">抽象曲面</h3><p>称二元有序组 <span class="math inline">\((D,ds^2)\)</span> 为一张<strong>抽象曲面</strong>, 其中 <span class="math inline">\(D\subset\mathbf{R}^2\)</span> 是参数平面 <span class="math inline">\(\mathbf{R}^2\)</span> 上指定的区域, <span class="math inline">\(ds^2\)</span> 是定义域上的正定的二次微分形式.</p><h2 id="重要的定理">重要的定理</h2><h3 id="曲线论基本定理">曲线论基本定理</h3><p>给定区间 <span class="math inline">\(I=(a,b)\)</span> 上的连续可微函数 <span class="math inline">\(\overline{\kappa}(s)&gt;0\)</span> 和连续函数 <span class="math inline">\(\overline{\tau}(s)\)</span>, 则在 <span class="math inline">\(E^3\)</span> 中</p><ol type="1"><li>存在弧长 <span class="math inline">\(s\)</span> 参数化曲线 <span class="math inline">\(C:r=r(s)\)</span>, 使其曲率函数 <span class="math inline">\(\kappa(s)=\overline{\kappa}(s)\)</span>, 并且其挠率函数 <span class="math inline">\(\tau(s)=\overline{\tau}(s)\)</span>;</li><li>上述曲线 <span class="math inline">\(C\)</span> 在合同的意义下是唯一的.</li></ol><h3 id="可展曲面的分类定理">可展曲面的分类定理</h3><p>可展曲面必是煮面、锥面和切线面之一或由它们沿直母线所适当拼接而成.</p><h3 id="局部等距对应的条件">局部等距对应的条件</h3><p>两张曲面能建立局部等距对应的充要条件是按照对应关系有相同的第一基本形式.</p><h3 id="gauss绝妙定理">Gauss绝妙定理</h3><p>曲面 <span class="math inline">\(S\)</span> 的Gauss曲率是内蕴量, 可表示为 <span class="math display">\[K=\frac{-R_{1212}}{g_{11}g_{22}-(g_{12})^2}.\]</span> 在正交网下, 有 <span class="math display">\[K=\frac{-1}{\sqrt{EG}}\left(\left[\frac{(\sqrt{E})_2}{\sqrt{G}}\right]_2+\left[\frac{(\sqrt{G})_1}{\sqrt{G}}\right]_1\right).\]</span></p><h3 id="曲面论基本定理">曲面论基本定理</h3><p>给定 <span class="math inline">\((u^1,u^2)\)</span> 平面上的单连通区域 <span class="math inline">\(U\)</span>. 给定 <span class="math inline">\(U\)</span> 上的 <span class="math inline">\(C^2\)</span> 函数 <span class="math inline">\(\overline{g}_{ij}\)</span> 和 <span class="math inline">\(\overline{\Omega}_{ij}\)</span>, s.t. <span class="math inline">\(\overline{g}\)</span> 正定, <span class="math inline">\(\overline{\Omega}\)</span> 对称, 并且 <span class="math inline">\(\overline{g}\)</span> 和 <span class="math inline">\(\overline{\Omega}\)</span> 满足 Gauss-Codazzi方程, 则在 <span class="math inline">\(E^3\)</span> 中</p><ol type="1"><li>存在正则曲面 <span class="math inline">\(S:r=r(u^1,u^2),~(u^1,u^2)\in U\)</span>, s.t. 其第一第二基本形式分别为 <span class="math inline">\(\overline{g}\)</span> 和 <span class="math inline">\(\overline{\Omega}\)</span>;</li><li>上述曲面 <span class="math inline">\(S\)</span> 在合同的意义下是唯一的.</li></ol><h3 id="测地线存在唯一性定理">测地线存在唯一性定理</h3><p>给定正则曲面 <span class="math inline">\(S:(u^1,u^2)\)</span> 上任意一点 <span class="math inline">\(P_0(u_0^1,u_0^2)\)</span>, 则存在 <span class="math inline">\(P_0\)</span> 的某个邻域 <span class="math inline">\(\Sigma_0\subset S\)</span>, s.t. 在 <span class="math inline">\(\Sigma_0\)</span> 内从点 <span class="math inline">\(P_0\)</span> 出发沿指定单位切向 <span class="math inline">\(T_0\in T_{P_0}\)</span> 存在唯一一条测地线 <span class="math inline">\(C:r(u^1(s),u^2(s))\)</span>, s.t. <span class="math display">\[\left(r_i\frac{du^i}{ds}\right)\Bigg|_{s=s_0}=T_0,~u^i(s_0)=u_0^i,~i=1,2.\]</span></p><h2 id="重要的式子">重要的式子</h2><h3 id="euler公式">Euler公式</h3><p><span class="math display">\[\kappa_n(P,a)=\kappa_1|_P\cos^2\theta+\kappa_2|_P\sin^2\theta.\]</span></p><h3 id="rodriques公式">Rodriques公式</h3><p>已知正则曲面 <span class="math inline">\(S:r(u^1,u^2)\)</span> 的弧长参数化曲线 <span class="math inline">\(C:r(u^1(s),u^2(s))\)</span>, 则 <span class="math inline">\(C\)</span> 是曲率线等价于沿 <span class="math inline">\(C\)</span> 存在 <span class="math inline">\(\lambda(s)\)</span>, s.t. <span class="math display">\[\frac{dn}{ds}=-\lambda(s)\frac{dr}{ds}.\]</span> 即, 沿 <span class="math inline">\(C\)</span> 有 <span class="math inline">\(dn=-\lambda(s)dr\)</span>.</p><h3 id="正交曲率线网下的gauss-codazzi方程">正交曲率线网下的Gauss-Codazzi方程</h3><p><span class="math display">\[\begin{cases}L_2 &amp;= HE_2, \\N_1 &amp;= HG_1. \\\end{cases}\]</span></p><h2 id="判断内蕴量几何体">判断内蕴量(几何体)</h2><h3 id="常见的内蕴量内蕴几何体">常见的内蕴量(内蕴几何体)</h3><p>曲线的弧段长度, 曲线的测地曲率, 曲线的交角, 曲面的第一基本形式, 曲线的区域面积, Gauss曲率, 测地线, 测地圆周, 测地开圆盘, 抛物点, 黎曼曲率张量, 联络系数.</p><h3 id="常见的不是内蕴量的东西">常见的不是内蕴量的东西</h3><p>曲线的曲率, 曲线的挠率, 法曲率, 直线, 圆周, <strong>第一基本形式的系数矩阵</strong>, 第二基本形式, 主曲率, 主方向, 脐点, 平点, 圆点, 平均曲率, Weingarten矩阵, 第三基本形式, 渐近曲线.</p>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微分几何 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>概率论复习重点</title>
      <link href="/2017/06/23/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/"/>
      <content type="html"><![CDATA[<h2 id="第二章-概率空间">第二章 概率空间</h2><h3 id="性质和定理">性质和定理</h3><p>设 <span class="math inline">\((\Omega,\mathscr{F},\mathbb{P})\)</span> 为概率空间, 有如下性质和定理成立.</p><h4 id="可列可加性和次可加性">可列可加性和次可加性</h4><p><span class="math inline">\(\forall~ \&amp;#123; A_n \&amp;#125; \subset\mathscr{F}\)</span>, 有 <span class="math display">\[\mathbb{P}\left(\bigcup_{n=1}^\infty A_n\right)\leqslant\sum\limits_{n=1}^\infty \mathbb{P}(A_n).\]</span> 对于两两不相容的集合列 $ &amp;#123; A_n &amp;#125; $, 有 <span class="math display">\[\mathbb{P}\left(\bigcup_{n=1}^\infty A_n\right)=\sum\limits_{n=1}^\infty \mathbb{P}(A_n).\]</span></p><h4 id="连续性">连续性</h4><p>若事件 <span class="math inline">\(A_n\subset A_{n+1}\)</span>, <span class="math inline">\(n\geqslant 1\)</span>, 则 <span class="math display">\[\mathbb{P}\left(\bigcup\limits_{n=1}^\infty A_n\right)=\lim\limits_{n\to\infty}\mathbb{P}(A_n).\]</span> 若事件 <span class="math inline">\(A_n\supset A_{n+1}\)</span>, <span class="math inline">\(n\geqslant 1\)</span>, 则 <span class="math display">\[\mathbb{P}\left(\bigcap\limits_{n=1}^\infty A_n\right)=\lim\limits_{n\to\infty}\mathbb{P}(A_n).\]</span></p><h4 id="全概率公式">全概率公式</h4><p>设 $ &amp;#123; B_n &amp;#125; $ 为 <span class="math inline">\(\Omega\)</span> 的一个分割, 则 <span class="math display">\[\mathbb{P}(A)=\sum\limits_n \mathbb{P}(B_n)\mathbb{P}(A|B_n),\quad\forall~A\in\mathscr{F}.\]</span></p><h4 id="bayes公式">Bayes公式</h4><p>设 $ &amp;#123; B_n &amp;#125; $ 为 <span class="math inline">\(\Omega\)</span> 的一个分割, 对于 <span class="math inline">\(\forall~A\in\mathscr{F}\)</span>, 如果 <span class="math inline">\(\mathbb{P}(A)&gt;0\)</span>, 则对于 <span class="math inline">\(\forall~1\leqslant k\leqslant n\)</span>, 有 <span class="math display">\[\mathbb{P}(B_k|A)=\frac{\mathbb{P}(B_k)\mathbb{P}(A|B_k)}{\sum\limits_{n=1}^\infty \mathbb{P}(B_n)\mathbb{P}(A|B_n)}.\]</span></p><h4 id="事件的独立性">事件的独立性</h4><p>若 <span class="math inline">\(\mathbb{P}(AB)=\mathbb{P}(A)\mathbb{P}(B)\)</span>, 则称 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 独立.</p><h2 id="第三章-随机变量及其分布">第三章 随机变量及其分布</h2><h3 id="正态分布">正态分布</h3><h4 id="密度函数">密度函数</h4><p><span class="math display">\[\varphi_{a,\sigma}(x)=\frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{(x-a)^2}{2\sigma^2}},\quad a\in\mathbb{R},~\sigma&gt;0;\]</span></p><h4 id="分布函数">分布函数</h4><p><span class="math display">\[\Phi_{a,\sigma}(x)=\int\nolimits_{-\infty}^x \varphi_{a,\sigma}(t)dt;\]</span></p><h4 id="标准正态分布">标准正态分布</h4><p><span class="math display">\[\varphi(x)=\varphi_{0,1}(x)=\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}};\]</span></p><h4 id="正态分布的性质">正态分布的性质</h4><p><span class="math display">\[\Phi_{a,\sigma}(x)=\Phi(\frac{x-a}{\sigma}),\quad \Phi(x)=1-\Phi(-x).\]</span></p><h3 id="联合分布">联合分布</h3><h4 id="联合分布函数">联合分布函数</h4><p><span class="math display">\[F(x_1,\cdots,x_n)=\mathbb{P}(\xi_1\leqslant x_1,\cdots,\xi_n\leqslant x_n);\]</span></p><h4 id="联合密度函数">联合密度函数</h4><p><span class="math display">\[F(x_1,\cdots,x_n)=\int\cdots\int\nolimits_{\mathbf{R}^n}p(x_1,\cdots,x_n)dx_1\cdots dx_n;\]</span></p><h4 id="边缘分布函数">边缘分布函数</h4><p><span class="math display">\[F_1(x)=\lim\limits_{y\to\infty}F(x,y),\quad F_2(y)=\lim\limits_{x\to\infty}F(x,y);\]</span></p><h4 id="边缘密度">边缘密度</h4><ol type="1"><li>离散情形: <span class="math display">\[p_{i\bullet}=\sum\limits_j p_{ij},\quad p_{\bullet j}=\sum\limits_i p_{ij};\]</span></li><li>连续情形: <span class="math display">\[p_1(x)=\int\nolimits_{-\infty}^\infty p(x,y)dy,\quad p_2(y)=\int\nolimits_{-\infty}^\infty p(x,y)dx;\]</span></li></ol><h4 id="随机变量的独立">随机变量的独立</h4><p>联合密度等于边缘密度的乘积. 1. 离散情形: <span class="math display">\[p_{ij}=p_{i\bullet}p_{\bullet j},\quad\forall~i,j;\]</span> 2. 连续情形: <span class="math display">\[p(x,y)=p_1(x)p_2(y);\]</span> 若 <span class="math inline">\(\xi_1\)</span> 与 <span class="math inline">\(\xi_2\)</span> 独立, 则对于任何Borel可测函数 <span class="math inline">\(f_1\)</span> 与 <span class="math inline">\(f_2\)</span>, <span class="math inline">\(\eta_1=f_1(\xi_1)\)</span> 与 <span class="math inline">\(\eta_2=f_2(\xi_2)\)</span> 独立.</p><h3 id="随机变量函数的分布">随机变量函数的分布</h3><h4 id="分布函数-1">分布函数</h4><p>设 <span class="math inline">\(f(x_1,\cdots,x_n)\)</span> 为 <span class="math inline">\(n\)</span> 元Borel可测函数, <span class="math inline">\(p\)</span> 为 <span class="math inline">\((\xi_1\cdots,\xi_n)\)</span> 的密度函数, 则 <span class="math inline">\(\eta=f(\xi_1,\cdots,\xi_n)\)</span> 的分布函数为 <span class="math display">\[F_\eta(y)=\underset{f(x_1,\cdots,x_n)\leqslant y}{\int\cdots\int}p(x_1,\cdots,x_n)dx_1\cdots dx_n.\]</span></p><h4 id="卷积公式">卷积公式</h4><p>设 <span class="math inline">\((\xi,\eta)\)</span> 的联合密度函数为 <span class="math inline">\(p\)</span>, 则 <span class="math inline">\(\xi+\eta\)</span> 的密度函数为 <span class="math display">\[p_{\xi+\eta}(z)=\int\nolimits_{-\infty}^\infty p(x,z-x)dx=\int\nolimits_{-\infty}^\infty p(z-y,y)dy.\]</span></p><h4 id="商密度公式">商密度公式</h4><p>设 <span class="math inline">\((\xi,\eta)\)</span> 的联合密度为 <span class="math inline">\(p\)</span>, 则 <span class="math inline">\(\xi/\eta\)</span> 的密度函数为 <span class="math display">\[p_{\xi/\eta}(z)=\int\nolimits_{-\infty}^\infty |y|p(zy,y)dy.\]</span></p><h4 id="高维情形">高维情形</h4><p>设 <span class="math inline">\(n\)</span> 维随机向量 <span class="math inline">\(\xi\)</span> 的联合密度为 <span class="math inline">\(p\)</span>, <span class="math inline">\(f_i(x)\)</span> 为 <span class="math inline">\(n\)</span> 维Borel可测函数, <span class="math inline">\(\eta=(f_1(\xi),\cdots,f_n(\xi))\)</span>. 若对于 <span class="math inline">\(\eta\)</span> 的像空间 <span class="math inline">\(D\)</span> 中任何一个 <span class="math inline">\(y\)</span>, 方程组 <span class="math inline">\(y_i=f_i(x)\)</span>有唯一的可微解 <span class="math inline">\(x_i=h_i(y)\)</span>, 则 <span class="math inline">\(\eta\)</span> 的联合密度函数为 <span class="math display">\[q(y)==p(h_1(y),\cdots,h_n(y))|J|,\quad y\in D,\]</span> 其中 <span class="math inline">\(J=\frac{\partial(h_1(y),\cdots,h_n(y))}{\partial (y_1,\cdots,y_2)}\)</span> 为Jacobi行列式.</p><h2 id="第四章-数字特征与特征函数">第四章 数字特征与特征函数</h2><h3 id="数学期望">数学期望</h3><p>定义: 简单随机变量 <span class="math inline">\(\mathbb{E}(\xi)=\sum\limits_{i=1}^n x_i\mathbb{P}(\xi=x_i)\rightarrow\)</span> 非负随机变量用简单随机变量逼近 <span class="math inline">\(\mathbb{E}(\xi)=\lim\limits_{n\to\infty}\mathbb{E}(\xi_n)\rightarrow\)</span>, 一般随机变量 <span class="math inline">\(\mathbb{E}(\xi)=\mathbb{E}(\xi^+)-\mathbb{E}(\xi^-).\)</span></p><h4 id="单调收敛定理">单调收敛定理</h4><p>若 <span class="math inline">\(\xi_n\)</span> 为非负随机变量, 且 <span class="math inline">\(\xi_n\uparrow\xi\)</span>, 则 <span class="math inline">\(\lim\limits_{n\to\infty}\mathbb{E}(\xi_n)=\mathbb{E}(\xi)\)</span>.</p><h4 id="数学期望的性质">数学期望的性质</h4><ol type="1"><li>线性性质: <span class="math inline">\(\mathbb{E}(a\xi+b\eta)=a\mathbb{E}(\xi)+b\mathbb{E}(\eta)\)</span>;</li><li>若 <span class="math inline">\(\xi\)</span> 与 <span class="math inline">\(\eta\)</span> 独立, 则 <span class="math inline">\(\mathbb{E}(\xi\eta)=\mathbb{E}(\xi)\mathbb{E}(\eta).\)</span></li></ol><h4 id="数学期望的计算">数学期望的计算</h4><ol type="1"><li>离散型: <span class="math inline">\(\mathbb{E}(\xi)=\sum\limits_{k=1}^n x_kp_k\)</span> 或 <span class="math inline">\(\mathbb{E}(\xi)=\sum\limits_{k=1}^\infty x_kp_k\)</span>;</li><li>连续型: <span class="math inline">\(\mathbb{E}(\xi)=\int\nolimits_{-\infty}^\infty xp(x)dx\)</span>.</li></ol><h4 id="条件期望">条件期望</h4><ol type="1"><li>离散型: <span class="math inline">\(\mathbb{E}(\xi|\eta=y)=\sum\limits_{i=1}^n\mathbb{P}(\xi=x_i|\eta=y)\)</span>,</li><li>连续型: <span class="math inline">\(\mathbb{E}(\xi|\eta=y)=\int\nolimits_{-\infty}^\infty xp(x|\eta=y)dx\)</span>.</li><li>条件期望的平滑性: <span class="math inline">\(\mathbb{E}(\xi)=\mathbb{E}(\mathbb{E}(\xi|\eta))\)</span>.</li></ol><h3 id="方差">方差</h3><p>计算: <span class="math inline">\(D(\xi)=\mathbb{E}(\xi-\mathbb{E}(\xi))^2\)</span>; 协方差: <span class="math inline">\({\rm cov}(\xi_i,\xi_j)=\mathbb{E}((\xi_1-\mathbb{E}(\xi_1))(\xi_2-\mathbb{E}(\xi_2)))\)</span>. 容易证明协方差具有如下性质: <span class="math display">\[D(\xi+\eta)=D(\eta)+D(\xi)\Longleftrightarrow {\rm cov}(\xi,\eta)=0,\]</span> <span class="math display">\[{\rm cov}(\xi_1+\xi_2,\eta)={\rm cov}(\xi_1,\eta)+{\rm cov}(\xi_2,\eta).\]</span></p><h2 id="第五章-大数定律和中心极限定理">第五章 大数定律和中心极限定理</h2><h3 id="收敛性">收敛性</h3><h4 id="几乎处处收敛">几乎处处收敛</h4><p>若 <span class="math inline">\(\mathbb{P}(\lim\limits_{n\to\infty}\xi_n=\xi)=1\)</span>, 则称 <span class="math inline">\(\xi_n\)</span> 几乎处处收敛到 <span class="math inline">\(\xi\)</span>, 记作 <span class="math inline">\(\xi_n\xrightarrow{a.e.}\xi\)</span>.</p><h4 id="依概率收敛">依概率收敛</h4><p>若 <span class="math inline">\(\lim\limits_{n\to\infty}\mathbb{P}(|\xi_n-\xi|\geqslant\epsilon)=0\)</span>, <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, 则称 <span class="math inline">\(\xi_n\)</span> 依概率收敛于 <span class="math inline">\(\xi\)</span>, 记作 <span class="math inline">\(\xi_n\xrightarrow{\mathbb{P}}\xi\)</span>.</p><h4 id="弱收敛">弱收敛</h4><p>设 <span class="math inline">\(\xi_n\)</span> 和 <span class="math inline">\(\xi\)</span> 的分布函数分别为 <span class="math inline">\(F_n(x)\)</span> 和 <span class="math inline">\(F(x)\)</span>, 若 <span class="math inline">\(\lim\limits_{n\to\infty}F_n(x)=F(x)\)</span>, <span class="math inline">\(\forall~x\in C_F\)</span>, 其中 <span class="math inline">\(C_F\)</span> 为 <span class="math inline">\(F\)</span> 的连续点全体, 则称 <span class="math inline">\(\xi_n\)</span> 弱收敛于 <span class="math inline">\(\xi\)</span>, 记作 <span class="math inline">\(\xi_n\xrightarrow{w}\xi\)</span>.</p><h4 id="r-阶矩收敛"><span class="math inline">\(r\)</span> 阶矩收敛</h4><p>给定 <span class="math inline">\(r&gt;0\in\mathbb{R}\)</span>, 若 <span class="math inline">\(\xi\)</span> 和 <span class="math inline">\(\xi_n\)</span> 的 <span class="math inline">\(r\)</span> 阶矩均存在, 并且 <span class="math inline">\(\lim\limits_{n\to\infty}\mathbb{E}(|\xi_n-\xi|^r)=0\)</span>, 则称 <span class="math inline">\(\xi_n\)</span> <span class="math inline">\(r\)</span> 阶矩收敛于 <span class="math inline">\(\xi\)</span>, 记作 <span class="math inline">\(\xi_n\xrightarrow{L_r}\xi\)</span>.</p><h3 id="几种收敛的关系">几种收敛的关系</h3><p><span class="math inline">\(\xi_n\xrightarrow{a.e.}\)</span> 或 <span class="math inline">\(\xi_n\xrightarrow{L_r}\xi\Rightarrow\)</span> <span class="math inline">\(\xi_n\xrightarrow{\mathbb{P}}\xi\Rightarrow\)</span> <span class="math inline">\(\xi_n\xrightarrow{w}\xi\)</span>. 特别地, <span class="math inline">\(\forall~c\in\mathbb{R}\)</span>, <span class="math inline">\(\xi_n\xrightarrow{w} c\Rightarrow c_n\xrightarrow{\mathbb{P}} c\)</span>.</p><h3 id="大数定律">大数定律</h3><h4 id="大数定律-1">大数定律</h4><p>设 <span class="math inline">\(\xi_n\)</span> 为数学期望均有限的随机变量列, 若:</p><p><span class="math display">\[\frac{1}{n}\sum\limits_{k=1}^n (\xi_k-\mathbb{E}(\xi_k))\xrightarrow{\mathbb{P}}0~,\]</span> 则称 <span class="math inline">\(\xi_n\)</span> 满足弱大数定律. <span class="math display">\[\frac{1}{n}\sum\limits_{k=1}^n (\xi_k-\mathbb{E}(\xi_k))\xrightarrow{\text{a.e.}}0~,\]</span> 则称 <span class="math inline">\(\xi_n\)</span> 满足强大数定律.</p><h4 id="markov条件">Markov条件</h4><p>设随机变量列 <span class="math inline">\(\xi_n\)</span> 满足 <span class="math display">\[\frac{1}{n^2}D\left(\sum\limits_{k=1}^n \xi_k\right)\xrightarrow{n\to\infty}0~,\]</span> 则 <span class="math inline">\(\xi_n\)</span> 满足大数定律.</p><h4 id="bernoulli大数定律">Bernoulli大数定律</h4><p>设 <span class="math inline">\(\mu_n\)</span> 为 <span class="math inline">\(n\)</span> 重Bernoulli试验中成功的次数, <span class="math inline">\(p\)</span> 为单次成功概率, 则 <span class="math inline">\(\frac{\mu_n}{n}\xrightarrow{\mathbb{P}}p\)</span>.</p><h4 id="辛钦大数定律">辛钦大数定律</h4><p>设 <span class="math inline">\(\xi_n\)</span> 为独立同分布随机变量列, 弱大数定律成立的充要条件是 <span class="math inline">\(\mathbb{E}(\xi_1)=a\)</span> 为有限实数.</p><h4 id="kolmogorov强大数定律">Kolmogorov强大数定律</h4><p>设 $ &amp;#123; _n &amp;#125; $ 是独立随机变量列, 满足 <span class="math inline">\(\sum\limits_{k=1}^\infty \frac{D(\xi_n)}{n^2}&lt;\infty\)</span>, 则 $ &amp;#123; _n &amp;#125; $ 满足大数定律.</p>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>复变复习重点</title>
      <link href="/2017/06/22/%E5%A4%8D%E5%8F%98%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/"/>
      <content type="html"><![CDATA[<h2 id="重要的定义和定理">重要的定义和定理</h2><h3 id="实可微的定义">实可微的定义</h3><p>设 <span class="math inline">\(f\)</span> 是从开集 <span class="math inline">\(\Omega\)</span> 到 <span class="math inline">\(\mathbb{C}\)</span> 中的函数, <span class="math inline">\(a\in\Omega\)</span>, 如果有复常数 <span class="math inline">\(A,b\)</span>, s.t. <span class="math display">\[\lim\limits_{z\to\infty}\frac{f(a+z)-f(a)-Ax-By}{z}=0,\]</span> 则称 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(a\)</span> 处<strong>实可微</strong>.</p><h3 id="复可微">复可微</h3><p>设 <span class="math inline">\(f\)</span> 是定义在开集 <span class="math inline">\(\Omega\)</span> 上的复变函数, <span class="math inline">\(a\in\Omega\)</span>, 如果有常数 <span class="math inline">\(\alpha\)</span>, s.t. <span class="math display">\[\lim\limits_{z\to\infty}\frac{f(a+z)-f(a)}{z}=\alpha\]</span> 存在, 我们称 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(a\in\Omega\)</span> 处<strong>复可微</strong>或称 <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(a\)</span> 可导, 并把 <span class="math inline">\(\alpha\)</span> 记作 <span class="math inline">\(f&#39;(a)\)</span>.</p><h3 id="cauchy-riemann方程">Cauchy-Riemann方程</h3><p>如果 <span class="math inline">\(f(z)=u(x,y)+iv(x,y)\)</span> 在 <span class="math inline">\(a\in\Omega\)</span> 处实可微, <span class="math inline">\(u,v\)</span> 为实值函数, 则 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(a\)</span> 处复可微当且仅当 <span class="math inline">\(\frac{\partial f}{\partial \overline{z}}(a)=0\)</span>, 或 <span class="math display">\[\begin{cases}&amp;\frac{\partial u}{\partial x}=\frac{\partial y}{\partial y} \\&amp; \frac{\partial u}{\partial y}=-\frac{\partial v}{\partial x} \\\end{cases}\]</span> 以上式子被称为Cauchy-Riemann方程, 简称C-R方程.</p><h3 id="复解析">复解析</h3><p>如果存在 <span class="math inline">\(a\)</span> 的一个邻域 <span class="math inline">\(D(a,r)\subset\Omega\)</span>, 使得 <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(D(a,r)\)</span> 中每点都有导数, 则称 <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(a\)</span> 点<strong>解析</strong>. 如果 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(\Omega\)</span> 上的每点解析, 则称 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(\Omega\)</span> 中<strong>解析</strong>或<strong>全纯</strong>.</p><h3 id="cauchy高阶求导公式">Cauchy高阶求导公式</h3><p>设 <span class="math inline">\(\Omega\)</span> 是一个单连通区域, <span class="math inline">\(C\)</span> 是全在区域 <span class="math inline">\(\Omega\)</span> 中的闭Jordan分段光滑曲线, <span class="math inline">\(C\)</span> 所围区域是 <span class="math inline">\(\omega\)</span>. 如果 <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 中解析, 则有如下<strong>Cauchy公式</strong> <span class="math display">\[f(z_0)=\frac{1}{2\pi i}\int\nolimits_C\frac{f(z)dz}{z-z_0}\qquad(z_0\in\omega)\]</span> 且对于任意整数 <span class="math inline">\(m\)</span>, <span class="math inline">\(f\)</span> 的 <span class="math inline">\(m\)</span> 阶复导数 <span class="math inline">\(f^{(m)}(z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 中存在解析, 且有如下的Cauchy高阶求导公式 <span class="math display">\[f^{(m)}(z_0)=\frac{m!}{2\pi i}\int\nolimits_C\frac{f(z)dz}{(z-z_0)^{m+1}}\qquad(z_0\in\omega,~m\in\mathbb{N}^+)\]</span></p><h3 id="泰勒taylor定理">泰勒(Taylor)定理</h3><p>设 <span class="math inline">\(f\)</span> 在区域 <span class="math inline">\(\Omega\)</span> 内解析, <span class="math inline">\(a\in\Omega\)</span>, 只要 $D(a,R)= &amp;#123; z:|z-a|&lt;R &amp;#125; $ 包含在 <span class="math inline">\(\Omega\)</span> 中, 则 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(D(a,R)\)</span> 内能展成幂级数 <span class="math display">\[f(z)=\sum\limits_{n=0}^\infty c_n(z-a)^n=c_0+c_1(z-a)+\cdots+c_n(z-a)^n+\cdots,\]</span> 其中系数 <span class="math display">\[c_n=\frac{f^{(n)}(a)}{n!}=\frac{1}{2\pi i}\int\nolimits_{\partial D(a,\rho)}\frac{f(\zeta)d\zeta}{(\zeta-a)^{n+1}},\quad (0&lt;\rho&lt;R,n\in\mathbb{N})\]</span> 且如果 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(D(a,R)\)</span> 内能展成幂级数, 则其系数一定满足上述要求.</p><h3 id="解析函数唯一性定理">解析函数唯一性定理</h3><p>设函数 <span class="math inline">\(g\)</span> 和 <span class="math inline">\(h\)</span> 在区域 <span class="math inline">\(\Omega\)</span> 内解析, <span class="math inline">\(a\in\Omega\)</span>, 且 <span class="math inline">\(\Omega\)</span> 内有一个收敛于 <span class="math inline">\(a\in\Omega\)</span> 的点列 $ &amp;#123; z_n &amp;#125; ~(z_na)$, s.t. <span class="math inline">\(g(z_k)=h(z_k)~(k\in\mathbb{N})\)</span>, 则 <span class="math inline">\(g\)</span> 和 <span class="math inline">\(h\)</span> 在 <span class="math inline">\(\Omega\)</span> 内恒等.</p><h3 id="洛朗laurent定理">洛朗(Laurent)定理</h3><p>设 <span class="math inline">\(f\)</span> 在区域 <span class="math inline">\(\Omega\)</span> 内解析, 只要 <span class="math inline">\(B(r,R)= \&amp;#123; z:r&lt;|z-a|&lt;R \&amp;#125; \subset\Omega\)</span>, 则 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(B(r,R)\)</span> 内能展成洛朗级数, 其中系数 <span class="math display">\[c_n=\frac{1}{2\pi i}\int\nolimits_{\partial D(a,\rho)}\frac{f(\zeta)d\zeta}{(\zeta-a)^{n+1}}\quad (r&lt;\rho&lt;R,~n\in\mathbb{Z}),\]</span> 且展式是唯一的(即系数 <span class="math inline">\(c_n\)</span> 由 <span class="math inline">\(f(z)\)</span> 和圆环 <span class="math inline">\(B(r,R)\)</span> 唯一确定).</p><h3 id="孤立奇点">孤立奇点</h3><p>设函数 <span class="math inline">\(f\)</span> 在点 <span class="math inline">\(a\)</span> 的某一去心邻域 $D(a,r)&amp;#123; a &amp;#125; = &amp;#123; z:0&lt;|z-a|&lt;r &amp;#125; $ 内解析, 则点 <span class="math inline">\(a\)</span> 称为 <span class="math inline">\(f\)</span> 的<strong>孤立奇点</strong>.</p><h3 id="留数定理">留数定理</h3><p>考虑 <span class="math inline">\(n+1\)</span> 条Jordan闭分段光滑曲线 <span class="math inline">\(C_0,C_1,\cdots,C_n\)</span>, 其中 <span class="math inline">\(C_1,C_2,\cdots,C_n\)</span> 中每一条都在其余各条的外部, 而它们又都在 <span class="math inline">\(C_0\)</span> 的内部. 在 <span class="math inline">\(C_0\)</span> 的内部同时又在 <span class="math inline">\(C_1,C_2,\cdots,C_n\)</span> 外部的点集构成一个多界的多连通区域 <span class="math inline">\(\Omega\)</span>, 以 <span class="math inline">\(C_1,C_2,\cdots,C_n\)</span> 为它的边界. <span class="math inline">\(z_k\in\Omega,~k=1,2,\cdots,m\)</span>, 函数 <span class="math inline">\(f\)</span> 在闭域 <span class="math inline">\(\overline{\Omega}=\Omega\cup\partial\Omega\)</span> 上除去孤立奇点 <span class="math inline">\(z_1,z_2,\cdots,z_k\)</span> 外是解析的, 则 <span class="math display">\[\int\nolimits_{\partial\Omega}f(z)dz=2\pi i\sum\limits_{k=1}^n {\rm Res}(f,z_k).\]</span></p><h3 id="儒歇rouche定理">儒歇(Rouche)定理</h3><p>设 <span class="math inline">\(\Omega\)</span> 是区域, <span class="math inline">\(\omega\subset\Omega\)</span> 是有界区域, 其边界 <span class="math inline">\(C=\partial\omega\subset\Omega\)</span> 是一条Jordan闭分段光滑曲线, 如果 <span class="math inline">\(f\)</span> 和 <span class="math inline">\(g\)</span> 在开集 <span class="math inline">\(\Omega\)</span> 中解析且在 <span class="math inline">\(C\)</span> 上有 <span class="math inline">\(|f(z)|&gt;|g(z)|\)</span>, 则函数 <span class="math inline">\(f(z)\)</span> 与 <span class="math inline">\(f(z)+g(z)\)</span> 在 <span class="math inline">\(C\)</span> 的内部 <span class="math inline">\(\omega\)</span> 有相同的( <span class="math inline">\(k\)</span> 阶零点算 <span class="math inline">\(k\)</span> 次)零点个数, 即 <span class="math display">\[N(f+g,C)=N(f,C).\]</span></p><h2 id="典型题目">典型题目</h2><h3 id="证明复级数的cauchy乘积收敛">证明复级数的Cauchy乘积收敛</h3><h4 id="师大复变习题一-31">师大复变习题一 31</h4><blockquote><p>设复级数 <span class="math inline">\(s=\sum\limits_{n=0}^\infty\alpha_n\)</span>, <span class="math inline">\(s&#39;=\sum\limits_{n=0}^\infty\alpha_n&#39;\)</span> 收敛, 且其中一个绝对收敛, 则其 Cauchy 乘积 <span class="math display">\[\sum\limits_{n=0}^\infty(\alpha_0\alpha_n&#39;+\alpha_1\alpha_{n-1}&#39;+\cdots+\alpha_n\alpha_0&#39;)=\sum\limits_{n=0}^\infty\sum\limits_{k=0}^n\alpha_k\alpha_{n-k}&#39;\]</span>也收敛, 且其和为 <span class="math inline">\(ss&#39;\)</span>.</p></blockquote><p><strong>证明</strong>: 不妨设 <span class="math inline">\(\sum\limits_{n=0}^\infty|\alpha_n|\)</span> 收敛, 记 <span class="math inline">\(S_m=\sum\limits_{n=0}^m\alpha_n\)</span>, <span class="math inline">\(S_m&#39;=\sum\limits_{n=0}^m\alpha_n&#39;\)</span>, <span class="math inline">\(\gamma_n=\alpha_0\alpha_n&#39;+\alpha_1\alpha_{n-1}&#39;+\cdots+\alpha_n\alpha_0&#39;\)</span>, <span class="math inline">\(\tau_m=\sum\limits_{n=0}^m\gamma_n\)</span>, 则有 <span class="math inline">\(S_m\to s\)</span>, <span class="math inline">\(S_m&#39;\to s&#39;\)</span>.</p><p>于是, <span class="math inline">\(\tau_m=\sum\limits_{n=0}^m\gamma_n=\alpha_0S_m&#39;+\cdots+\alpha_nS_0&#39;=S_ms&#39;+\delta_m\)</span></p><p>其中, <span class="math inline">\(\delta_m=\alpha_0(S_m&#39;-s&#39;)+\alpha_1(S_{m-1}&#39;-s&#39;)+\cdots+\alpha_n(S&#39;-s&#39;)\)</span></p><p>由于 $ &amp;#123; S_m’ &amp;#125; $ 收敛, 故 $ &amp;#123; S_m’ &amp;#125; $ 有界, 故 <span class="math inline">\(\exists~M&gt;0\)</span>, s.t. <span class="math inline">\(\forall~m\in\mathbb{N}\)</span>, <span class="math inline">\(|S_m&#39;-s&#39;|&lt;M\)</span></p><p>又由 <span class="math inline">\(\sum\limits_{n=0}^m\alpha_n\)</span> 绝对收敛, 知 <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, <span class="math inline">\(\exists~N_1\in\mathbb{N}\)</span>, s.t. <span class="math inline">\(\sum\limits_{k=N_1+1}^m|\alpha_k|&lt;\frac{\epsilon}{4M+1}\)</span>.</p><p>再记 <span class="math inline">\(L=\sum\limits_{k=0}^{N_1}|\alpha_k|\)</span>, 同理由 <span class="math inline">\(S_m&#39;\to s&#39;\)</span> 可得 <span class="math inline">\(\exists~N_2\in\mathbb{N}\)</span>, s.t. <span class="math inline">\(\forall~m&gt;N_2\)</span>, <span class="math inline">\(|S_m&#39;-s&#39;|&lt;\frac{\epsilon}{4L+1}\)</span>.</p><p>于是当 <span class="math inline">\(m&gt;N_1+N_2\)</span> 时有: <span class="math display">\[|\delta_m|\leq\sum\limits_{k=0}^m|\alpha_k||S_{m-k}&#39;-s&#39;|+(|\alpha_{N_1}|+\cdots+|\alpha_m|)M\leq\frac{\epsilon}{4L+1}\times L+\frac{\epsilon}{4M+1}&lt;\frac{\epsilon}{2}\]</span></p><p>故: <span class="math display">\[|\tau_m-ss&#39;|=|S_ms&#39;-ss&#39;+\delta_m|\leq |s&#39;||S_m-s|+|\delta_m|&lt;\frac{\epsilon}{2|s&#39;|}|s&#39;|+\frac{\epsilon}{2}=\epsilon\]</span></p><p>即 <span class="math inline">\(\sum\limits_{n=0}^\infty\sum\limits_{k=0}^n\alpha_k\alpha_{n-k}&#39;\)</span> 收敛到 <span class="math inline">\(ss&#39;\)</span>.</p><h3 id="分式线性映射映像区域">分式线性映射映像区域</h3><h4 id="师大复变习题五-5.1">师大复变习题五 5.(1)</h4><blockquote><p>求区域 $= &amp;#123; z:{}<sub>z&gt;0,{}</sub>z&gt;0 &amp;#125; $ 在分式线性映射 <span class="math inline">\(w=\frac{z-i}{z+i}\)</span> 下的映像区域.</p></blockquote><p><strong>解答</strong>: 记 $L_1= &amp;#123; z:{}~z=0 &amp;#125; $, $L_2= &amp;#123; z:{}~z=0 &amp;#125; $. 由于 <span class="math inline">\(T(z)=\infty\Leftrightarrow z=-i\)</span>, 并且 <span class="math inline">\(-i\)</span> 在 <span class="math inline">\(L_2\)</span> 上, 不在 <span class="math inline">\(L_1\)</span> 上, 故 <span class="math inline">\(T(L_1)\)</span> 为圆, <span class="math inline">\(T(L_2)\)</span> 为直线. <strong>一方面</strong>, <span class="math inline">\(T(-i)=\infty\)</span>, <span class="math inline">\(T(i)=0\)</span>, 并且 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(-i\)</span> 关于 <span class="math inline">\(L_1\)</span> 对称, 故 <span class="math inline">\(\infty\)</span> 和 <span class="math inline">\(0\)</span> 关于 <span class="math inline">\(T(L_1)\)</span> 对称. 即 <span class="math inline">\(T(L_1)\)</span> 以 <span class="math inline">\(0\)</span> 为心. 取 <span class="math inline">\(0\in L_1\)</span>, 则有 <span class="math inline">\(T(0)=-1\in T(L_1)\)</span>, 故 $T(L_1)= &amp;#123; z:|z|=1 &amp;#125; $. <strong>另一方面</strong>, <span class="math inline">\(T(-1)=\frac{-1-i}{-1+i}=i\)</span>, <span class="math inline">\(T(1)=-i\)</span>, 故 <span class="math inline">\(T(L_2)\)</span> 为过原点的直线. 取 <span class="math inline">\(0\in L_2\)</span>, 有 <span class="math inline">\(-1\in T(L_2)\)</span>, 即 <span class="math inline">\(T(L_2)\)</span> 为实轴. 取 <span class="math inline">\(1+i\in\Omega\)</span>, 则 <span class="math inline">\(T(1+i)=\frac{1}{1+2i}=\frac{1}{5}-\frac{2}{5}i\in T(\Omega)\)</span>, 即可确定像区域.</p><h3 id="已知原区域和像区域求映射">已知原区域和像区域求映射</h3><h4 id="师大复变习题五-12">师大复变习题五 12</h4><blockquote><p>求把区域 $ &amp;#123; z:|z-3i|&gt;2,~|z-4|&gt;2 &amp;#125; $ 映射为同心圆环 $ &amp;#123; w:1&lt;|w|&lt;R &amp;#125; $ 的分式线性映射 <span class="math inline">\(w=T(z)\)</span> 并求 <span class="math inline">\(R\)</span>.</p></blockquote><p><strong>解答</strong>: 记 $L_1= &amp;#123; z:|z-3i|=2 &amp;#125; $, $L_2= &amp;#123; z:|z-4|=2 &amp;#125; $. 由于 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(\infty\)</span> 为 <span class="math inline">\(T(L_1)\)</span> 和 <span class="math inline">\(T(L_2)\)</span> 的公共对称点, 故只需要寻找一对 <span class="math inline">\(L_1\)</span> 和 <span class="math inline">\(L_2\)</span> 的公共对称点. 考虑在圆心连线上寻找, 可以找到 <span class="math inline">\(\frac{4}{5}+\frac{12}{5}i\)</span> 和 <span class="math inline">\(\frac{16}{5}+\frac{3}{5}i\)</span> 为 <span class="math inline">\(L_1\)</span> 和 <span class="math inline">\(L_2\)</span> 的公共对称点. 于是可令 <span class="math inline">\(T(z)=\lambda\frac{z-\frac{16}{5}-\frac{3}{5}i}{z-\frac{4}{5}-\frac{12}{5}i}=\lambda\frac{5z-16-3i}{5z-4-12i}\)</span>. 此时只差 <span class="math inline">\(\lambda\)</span> 确定表达式. 不妨取 $ &amp;#123; w:|w|=1 &amp;#125; $ 为 <span class="math inline">\(T(L_2)\)</span>, 则 <span class="math inline">\(|T(2)|=1\)</span>, 可得 <span class="math inline">\(|\lambda|\cdot|\frac{10-16-3i}{10-4-12i}|=1\)</span>, 即 <span class="math inline">\(|\lambda|=2\)</span>. 故由 <span class="math inline">\(T(i)=R\)</span> 可知 <span class="math inline">\(|\lambda|\cdot|\frac{5i-16-3i}{5i-4-12i}|=R\)</span>, 即 <span class="math inline">\(R=4\)</span>. 至此, 映射的放大倍数已经确定, 只需要取一个点来确定方向, 不妨取 <span class="math inline">\(T(2)=-1\)</span>, 则 <span class="math inline">\(\lambda\cdot\frac{-6-3i}{6-12i}=-1\)</span>, 可得 <span class="math inline">\(\lambda=-2i\)</span>. 即 <span class="math inline">\(T(z)=-2i\cdot\frac{5z-16-3i}{5z-4-12i}\)</span>. 最后一步中, 如不取 <span class="math inline">\(T(2)=-1\)</span>, 则最后所得表达式与原表达式之间相差一个旋转, 映像区域仍然不变.</p>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复变函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2015年复变函数期末考试试卷</title>
      <link href="/2017/06/14/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62015%E5%B9%B4%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7/"/>
      <content type="html"><![CDATA[<h2 id="试题">试题</h2><ol type="1"><li>(20分)<ol type="1"><li>叙述孤立奇点的定义.</li><li>求下列各函数在复平面 <span class="math inline">\(\mathbb{C}\)</span> (不含 <span class="math inline">\(\infty\)</span> 点)中的孤立奇点, 孤立奇点各属于哪一种类型(极点指明阶数); <span class="math display">\[(a)~\frac{1}{z(z^2+1)^2};~(b)~\frac{e^z-1-z}{z^2(\cos z-1)}~;~(c)\frac{1}{z^3\sin(1/z)}\]</span></li><li>求 (a) 和 (b) 中函数在孤立奇点 <span class="math inline">\(0\)</span> 的留数.</li></ol></li><li><p>(20分) 叙述留数定理并计算下列积分: <span class="math display">\[(1)~\int\nolimits_{|z|=2}\frac{z-6}{z^2(z^2-1)}dz;~(2)\int\nolimits_{-\infty}^{+\infty}\frac{x\sin xdx}{(1+x^2)(4+x^2)}.\]</span></p></li><li><p>(15分)分式线性映射 <span class="math inline">\(w=T(z)=\frac{z-1}{z+1}\)</span> 将区域 $=&amp;#123; z:{}<sub>z&lt;0,{}</sub>z&lt;0 &amp;#125; $ 映射为什么区域？即求 <span class="math inline">\(T(\Omega)=?\)</span> (作图标明原像区域和像区域.)</p></li><li><p>(20分)叙述儒歇(Rouche)定理并求方程 <span class="math inline">\(z^5-5z^2+z+1=0\)</span> 在圆环 <span class="math inline">\(1&lt;|z|&lt;2\)</span> 内根的个数.</p></li><li><p>(15分)设 <span class="math inline">\(f(z)\)</span> 在区域 <span class="math inline">\(\Omega\)</span> 内解析, 且 <span class="math inline">\(|f(z)|\)</span> 在区域 <span class="math inline">\(\Omega\)</span> 内为常数. 试证明 <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 中为常数.</p></li><li>(10分)<ol type="1"><li>说明多值函数 <span class="math inline">\((z(1-z)^2)^{\frac{1}{3}}\)</span> 在割去线段 <span class="math inline">\([0,1]\)</span> 的 <span class="math inline">\(z\)</span> 平面上可以分出三个单值解析分支;</li><li>求出在 <span class="math inline">\([0,1]\)</span> 的上沿取正值的那个单值解析分支 <span class="math inline">\(g_0(z)\)</span> 在点 <span class="math inline">\(z=-1\)</span> 处的值 <span class="math inline">\(g_0(-1)=?\)</span>;</li><li>计算积分 <span class="math inline">\(\int\nolimits_0^1\frac{\sqrt[3]{x(1-x)^2}dx}{(1+x)}\)</span>.</li></ol></li></ol>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 各种试卷 </tag>
            
            <tag> 复变函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2011年概率论期末考试试卷</title>
      <link href="/2017/06/14/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62011%E5%B9%B4%E6%A6%82%E7%8E%87%E8%AE%BA%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7/"/>
      <content type="html"><![CDATA[<h2 id="试题">试题</h2><ol type="1"><li>(20分)设某地区成年居民中肥胖者占 <span class="math inline">\(10\%\)</span>, 不胖不瘦者占 <span class="math inline">\(82\%\)</span>, 瘦者占 <span class="math inline">\(8\%\)</span>. 又知道肥胖者患高血压的概率为 <span class="math inline">\(20\%\)</span>, 不胖不瘦者患高血压的概率为 <span class="math inline">\(10\%\)</span>, 瘦者患高血压的概率为 <span class="math inline">\(5\%\)</span>, 试求<ol type="1"><li>该地区居民患高血压的概率;</li><li>若知某人患高血压, 则他属于肥胖者的概率有多大?</li></ol></li><li>(20分)设 <span class="math inline">\(\&amp;#123; \xi_i,~i=1,2,\cdots \&amp;#125;\)</span> 为一列独立同分布的随机变量, 它们都服从 <span class="math inline">\([-1,1]\)</span> 上的均匀分布.<ol type="1"><li>求 <span class="math inline">\(\xi_1\)</span> 的特征函数;</li><li>设 <span class="math inline">\(\eta\)</span> 服从参数为 <span class="math inline">\(\lambda\)</span> 的Possion分布, 即 <span class="math inline">\(\mathbb{P}(\eta=k)=\frac{\lambda^k}{k!}e^{-\lambda},~k=0,1,2,\cdots\)</span>. 求 <span class="math inline">\(\eta\)</span> 的母函数;</li><li>假定 <span class="math inline">\(\eta_n\)</span> 服从参数为 <span class="math inline">\(3n\)</span> 的Possion分布, 并且与 <span class="math inline">\(\&amp;#123; \xi_i,~i=1,2,\cdots \&amp;#125;\)</span> 相互独立. 证明 <span class="math inline">\(X_n:=\sum\nolimits_{i=1}^{\eta_n}\xi_i\)</span> 的特征函数为 <span class="math inline">\(f_n(x)=e^{3n(\frac{\sin t}{t}-1)}\)</span> (约定 <span class="math inline">\(\sum\nolimits_{i=1}^0\xi_i=0\)</span>).</li><li>证明: 当 <span class="math inline">\(n\to\infty\)</span> 时, <span class="math inline">\(\frac{1}{\sqrt{n}}X_n\stackrel{w}{\rightarrow}N(0,1)\)</span>.</li></ol></li><li>(30分)若 <span class="math inline">\(\xi\sim N(0,\sigma^2)\)</span>,<ol type="1"><li>给出 <span class="math inline">\(\xi\)</span> 的特征函数表达式;</li><li>对于 <span class="math inline">\(\forall~b\in\mathbb{R}\)</span>, 证明 <span class="math display">\[\mathbb{P}(\xi=b)=0~\text{或}~1;\]</span></li><li>若 <span class="math inline">\(\vec{\xi}=(\xi_1,\xi_2,\cdots,\xi_n)\sim N(0,A&#39;A)\)</span>, 其中 <span class="math inline">\(A\)</span> 为 <span class="math inline">\(n\times n\)</span> 矩阵, 其 <span class="math inline">\((s,t)\)</span> 位置的元素 <span class="math display">\[a_{st}=\begin{cases}1, &amp; s = t - 1 \\0, &amp; s\neq t - 1\end{cases}\]</span> 利用 <span class="math inline">\(\xi\)</span> 的特征函数计算 <span class="math inline">\(\vec{\xi}\)</span> 的特征函数;</li><li><span class="math inline">\(\vec{\xi}\)</span> 是 <span class="math inline">\(n\)</span> 维连续型随机变量吗? 证明你的结果;</li><li><span class="math inline">\(\&amp;#123; \xi_n \&amp;#125;_{n=1}^{\infty}\)</span> 满足大数定律吗? 证明你的结果;</li><li><span class="math inline">\(\&amp;#123; \xi_n \&amp;#125;_{n=1}^{\infty}\)</span> 满足中心极限定理吗? 证明你的结果.</li></ol></li><li>(15分)<ol type="1"><li>证明依概率收敛的极限在几乎必然的意义下唯一, 即: 若 <span class="math inline">\(\xi_n\stackrel{\mathbb{P}}{\rightarrow}{\xi},~\xi_n\stackrel{\mathbb{P}}{\rightarrow}{\eta}\)</span>, 必有 <span class="math inline">\(\mathbb{P}(\xi=\eta)=1\)</span>;</li><li>设 <span class="math inline">\(\xi\sim N(0,1)\)</span>, 证明: <span class="math inline">\(-\xi\sim N(0,1)\)</span>;</li><li>距离说明: 弱收敛的极限在几乎必然的意义下不唯一, 即: 如果 <span class="math inline">\(\xi_n\stackrel{w}{\rightarrow}{\xi},~\xi_n\stackrel{w}{\rightarrow}{\eta}\)</span>, 未必有 <span class="math inline">\(\mathbb{P}(\xi=\eta)=1\)</span>.</li></ol></li><li>设 <span class="math inline">\(\&amp;#123; \xi_n \&amp;#125;\)</span> 为独立随机变量列, <span class="math inline">\(\mathbb{E}(\xi_n)=0\)</span>, <span class="math inline">\(D(\xi_n)&lt;\infty\)</span>, <span class="math inline">\(n\geqslant 1\)</span>.<ol type="1"><li><span class="math inline">\(\forall~\epsilon&gt;0\)</span>, 记 <span class="math inline">\(A_1=\&amp;#123; |S_1|\geq\epsilon \&amp;#125;\)</span>, <span class="math display">\[A_k=\&amp;#123; |S_k|\geq\epsilon \&amp;#125;\cap\left(\bigcap\limits_{k=1}^{k-1}\&amp;#123; |S_j|&lt;\epsilon \&amp;#125;\right),\quad k=2,\cdots,n.\]</span> 证明 <span class="math inline">\(A_1,A_2,\cdots,A_n\)</span> 互不相容;</li><li>证明 <span class="math inline">\(S_n-S_k\)</span> 与 <span class="math inline">\(S_k\chi_{A_k}\)</span> 相互独立, 其中 <span class="math inline">\(\chi_{A_k}\)</span> 表示事件 <span class="math inline">\(A_k\)</span> 的示性函数;</li><li>记 <span class="math inline">\(S_n=\sum\limits_{k=1}^n\xi_k\)</span>, 证明 <span class="math display">\[\mathbb{P}\left(\max_{1\leq k\leq n}|S_k|\geq\epsilon\right)\leq\frac{D(S_n)}{\epsilon^2},\qquad\forall~\epsilon&gt;0.\]</span></li></ol></li></ol>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率论 </tag>
            
            <tag> 各种试卷 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2016年高等代数期末考试试卷</title>
      <link href="/2017/06/11/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62016%E5%B9%B4%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7/"/>
      <content type="html"><![CDATA[<h2 id="试题">试题</h2><ol type="1"><li>(20分)设 <span class="math inline">\(\alpha\)</span> 为 <span class="math inline">\(n\)</span> 维欧氏空间 <span class="math inline">\(V\)</span> 中的一个单位向量, 定义映射 <span class="math display">\[\sigma_\alpha:~V\longrightarrow V,\quad\xi\longmapsto\xi-2(\xi,\alpha)\alpha.\]</span><ol type="1"><li>证明 <span class="math inline">\(\sigma_\alpha\)</span> 为一个正交变换. 这样的正交变换称为由 <span class="math inline">\(\alpha\)</span> 定义的镜面反射.</li><li>证明: 存在 <span class="math inline">\(V\)</span> 的规范正交基, 使得 <span class="math inline">\(\sigma_\alpha\)</span> 在这组基下的矩阵为: <img src="http://static.zybuluo.com/lzcwr/eg1j1mhvalsquvdlvgd3tzjq/image_1biasuj6e1okl1o5o1cd5101p13fb9.png">.</li></ol></li><li><p>(10分)设 <span class="math inline">\(A\)</span> 是3阶实对称矩阵，<span class="math inline">\(A\)</span> 的特征值为0, 3, 3. 已知 <span class="math inline">\(\xi_1=(1,1,1)^T,~\xi_2=(-1,1,0)^T\)</span> 分别是属于特征值0和3的特征向量. 求属于特征值3的与 <span class="math inline">\(\xi_2\)</span> 线性无关的另一个特征向量 <span class="math inline">\(\xi_3\)</span>.</p></li><li>(20分)设3元实二次型 <span class="math inline">\(q(x_1,x_2,x_3)=2x_1^2+x_2^2-4x_1x_2-4x_2x_3\)</span>.<ol type="1"><li>求 <span class="math inline">\(q\)</span> 的秩和正惯性指数.</li><li>求一个正交替换，将 <span class="math inline">\(q\)</span> 化为典范形.</li></ol></li><li>(20分)设矩阵 <img src="http://static.zybuluo.com/lzcwr/cq3zyrsoavxwdas24ico22x0/image_1biasv76j1nru1rh1e3lu7o5hpm.png">.<ol type="1"><li>分别求 <span class="math inline">\(A\)</span> 的特征多项式和最小多项式.</li><li>矩阵 <span class="math inline">\(A\)</span> 能否对角化？如不能, 求出它的若尔当标准型.</li></ol></li><li><p>(15分)设 <span class="math inline">\(q(x_1,x_2,\cdots,x_n)=x^TAx\)</span> 是一实二次型, 其中 <span class="math inline">\(A=(a_{ij})\)</span> 是 <span class="math inline">\(n\)</span> 阶实对称矩阵. 设 <span class="math inline">\(\lambda\)</span> 与 <span class="math inline">\(\mu\)</span> 分别是 <span class="math inline">\(A\)</span> 的最大与最小特征值. 证明: 对于 <span class="math inline">\(\mathbf{R}^n\)</span> 中任一列向量 <span class="math inline">\(\alpha\)</span>, 有 <span class="math display">\[\mu|\alpha|^2\leqslant\alpha^TA\alpha\leqslant\lambda|\alpha|^2.\]</span></p></li><li><p>(15分)证明: 如果 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 都是 <span class="math inline">\(n\)</span> 阶实对称矩阵, 并且 <span class="math inline">\(A\)</span> 正定, 那么存在 <span class="math inline">\(n\)</span> 阶实可逆矩阵 <span class="math inline">\(P\)</span>, 使得 <span class="math inline">\(P^TAP\)</span> 和 <span class="math inline">\(P^TBP\)</span> 都是对角矩阵.</p></li></ol><h2 id="简略解答">简略解答</h2><ol type="1"><li>一定记得先验证它是一个线性变换, 再验证其正交性, 否则会丢掉4分.</li><li>早就不记得了, 其余全略.</li></ol>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 各种试卷 </tag>
            
            <tag> 高等代数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京师范大学2017年复变函数期中考试试卷</title>
      <link href="/2017/06/11/%E5%8C%97%E4%BA%AC%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62017%E5%B9%B4%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E6%9C%9F%E4%B8%AD%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7/"/>
      <content type="html"><![CDATA[<h2 id="试题">试题</h2><ol type="1"><li><p>(20分)设 <span class="math inline">\(z_1,z_2\)</span> 是任意两个复数, 证明 <span class="math display">\[|z_1+z_2|^2+|z_1-z_2|^2=2(|z_1|^2+|z_2|^2),\]</span> 并说明其几何意义(画图说明).</p></li><li><p>(20分)叙述函数 <span class="math inline">\(f(z)=u(x,y)+iv(x,y)\)</span> 在一点的(复)可微和解析的定义且讨论函数 <span class="math inline">\(f(z)=x^2y+ixy^2\)</span> 的(复)可微性和解析性(在何处(复)可微和解析).</p></li><li><p>(25分)将函数 <span class="math inline">\(\frac{z}{z^2+8z+20}\)</span> 按 <span class="math inline">\(z+4\)</span> 的幂展出, 并指出其收敛半径.</p></li><li>(25分)在下了区域中, 哪些区域存在 <span class="math inline">\(\sqrt{(z^2-1)(z^2-4)}\)</span> 的解析分支？请说明理由.<ol type="1"><li><span class="math inline">\(\mathbb{C}\backslash((-\infty,-1]\cup[1,+\infty))\)</span>;</li><li><span class="math inline">\(\mathbb{C}\backslash[-2,2]\)</span>;</li><li><span class="math inline">\(\mathbb{C}\backslash([-2,-1]\cup[1,2))\)</span>;</li><li><span class="math inline">\(\mathbb{C}\backslash((-\infty,-2]\cup[-1,2))\)</span>.</li></ol></li><li><p>(10分)设 <span class="math inline">\(\Omega\)</span> 为平面上的一个非空区域(区域 <span class="math inline">\(\Omega\)</span> 是连通开集, <span class="math inline">\(\Omega\)</span> 中任意两点可以用曲线连接), 如果 <span class="math inline">\(D\subset\Omega\)</span>, <span class="math inline">\(D\)</span> 是一个非空开集且 <span class="math inline">\(D\neq\Omega\)</span>, 证明存在 <span class="math inline">\(D\)</span> 的边界点 <span class="math inline">\(c\in\partial\Omega\)</span> 满足 <span class="math inline">\(c\in\Omega\)</span>.</p></li></ol><h2 id="粗略解答">粗略解答</h2><ol type="1"><li>显然. 几何意义: 平行四边形四边的平方和等于对角线的平方和.</li><li>由C-R方程可知, 函数只在原点可微, 处处不解析.</li><li>拆成分式即可直接展开，此处只列出前几项以供参考: <span class="math display">\[-1+\frac{x+4}{4}+\frac{1}{4} (x+4)^2-\frac{1}{16} (x+4)^3-\frac{1}{16} (x+4)^4+\frac{1}{64} (x+4)^5+O\left((x+4)^6\right).\]</span></li><li>(1)存在, (2)存在, (3)不存在, (4)存在.</li><li>证明从略.</li></ol>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 各种试卷 </tag>
            
            <tag> 复变函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mathematica技巧[2]——修改输入和输出字体</title>
      <link href="/2017/05/09/Mathematica%E6%8A%80%E5%B7%A7%5B2%5D%E2%80%94%E2%80%94%E4%BF%AE%E6%94%B9%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E5%AD%97%E4%BD%93/"/>
      <content type="html"><![CDATA[<p><code>Mathematica</code>自带的修改字体功能似乎并没有什么用……如果想修改的话，需要手动运行代码修改。代码分为两部分</p><h2 id="函数定义">函数定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">setFont[fontFamily_, fontSize_] := With[</span><br><span class="line">    &#123;</span><br><span class="line">        styleNB = Notebook[</span><br><span class="line">            &#123;</span><br><span class="line">                Cell[StyleData[StyleDefinitions -&gt; &quot;Default.nb&quot;]],</span><br><span class="line">                Cell[StyleData[&quot;StandardForm&quot;],</span><br><span class="line">                FontFamily -&gt; ToString[fontFamily],</span><br><span class="line">                FontSize -&gt; ToExpression[fontSize]]</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        styleSheetName = FileNameJoin[</span><br><span class="line">            &#123;</span><br><span class="line">                $UserBaseDirectory, </span><br><span class="line">                &quot;SystemFiles&quot;, </span><br><span class="line">                &quot;FrontEnd&quot;, </span><br><span class="line">                &quot;StyleSheets&quot;, </span><br><span class="line">                &quot;myStyle.nb&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    If[</span><br><span class="line">    FileExistsQ[styleSheetName], </span><br><span class="line">    SetOptions[$FrontEnd,</span><br><span class="line">    DefaultStyleDefinitions -&gt; &quot;Default.nb&quot;]</span><br><span class="line">    ];</span><br><span class="line">    Export[styleSheetName, styleNB];</span><br><span class="line">    SetOptions[$FrontEnd, DefaultStyleDefinitions -&gt; styleSheetName]</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="函数运行">函数运行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setFont[&quot;字体名称&quot;, 字体大小]</span><br><span class="line">比如：</span><br><span class="line">setFont[&quot;Consolas&quot;, 12]</span><br><span class="line">或者</span><br><span class="line">setFont[&quot;Monaco&quot;, 13]</span><br></pre></td></tr></table></figure><h2 id="用法">用法</h2><p>将以上函数和运行的代码粘贴进一个<code>.nb</code>文档，运行即可修改字体。</p>]]></content>
      
      <categories>
          
          <category> 代码学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mathematica </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>几篇TOEFL独立写作范文</title>
      <link href="/2017/04/13/%E5%87%A0%E7%AF%87TOEFL%E7%8B%AC%E7%AB%8B%E5%86%99%E4%BD%9C%E8%8C%83%E6%96%87/"/>
      <content type="html"><![CDATA[<h2 id="第一篇">第一篇</h2><p>In such a competitive society with ceaseless changes, there is a heated debate of the most fundamental factor of keeping close bond with people we love. Obviously, opinions vary from person to person in accordance with their inner preference. After a scrupulous assessment, I would render my support to spending time with them as much as possible.</p><p>To begin with, regarding the potential harm brought by being apart from the closest people, to say that moving far away is crucial for everyone to attach importance to valuable relationships is an exaggeration. Admittedly, whenever we step into a totally unfamiliar cultural background, it is likely that we would suffer in nostalgia and feel it hard to adapt to new environment immediately, which allows us to realize the indispensable role they play in our life. However, when analyzing this issue from an objective angle, we would find that the benefits caused by getting away from our parents are dwarfed by its negative influences. Even if the technological development enables us to keep in touch with our friends and families across a long distance, there are still emotional feelings and genuine expressions that cannot be discerned by others through the Internet.</p><p>In addition, compared with living in a great distance, spending time together provides a greater opportunity for us to enhance our mutual relationship much more effectively. Living in a fast paced society, young generation has been suffered overwhelming pressure from daily work and intensive study, which means that hardly can they squeeze time to accompany their families and friends. As a result, they will definitely treasure the scarce chance of holiday to have fun with their beloved friends and relatives. For instance, in Spring Festival in China, which is one of the most grandeur festivals for Chinese people, not only will people set off firecrackers to celebrate the important moment, but also they can share the latest information with each other and enjoy the harmonious atmosphere together. Consequently, it would benefit their relationship in the long run.</p><p>Last but not least, living with our close friends or families together paves a good way for us to give them cares and unconditioned help, so that we would not regret for not standing besides them in their darkest time. Numerous people post their regretful comments on Facebook because of their families death and their absence in their tough times. There is no denying that facing challenges together and forming a unity fortress are the most effective ways to establish the solid relationships in everyone’s life. Since during the process of figuring out best solutions, we are likely to stand in others shoes to analyze problems and get deeper understanding of others. Generally speaking, people tend to cherish those friends who lend them a hand whenever they are stuck in dilemma.</p><p>In conclusion, considering the details mentioned above, it is a better choice for us to take time to accompany people who are important to us, instead of being far away from them. (498)</p><h2 id="第二篇">第二篇</h2><p>独立写作题目：Do you agree or disagree with the following statement? Workers would be much happier if they are doing different types of tasks at the same time than doing the same task. </p><p>范文立场选择：Disagree</p><h3 id="opening-60-100-words">Opening (60-100 Words)</h3><h4 id="intro">Intro</h4><p>Reasonable schedule arrangement and patient handling of each task demonstrate a person’s overall potential in his career. Especially in such a society with intensive competition, working pressures urge employees to devote much to the fulfillment of numerous projects. Therefore, some people would like to do several projects at a time for adjusting to a stressful working condition. </p><h4 id="thesis">Thesis</h4><p>However, as far as I am concerned, finishing one task completely then to another should be more efficient because attentiveness is crucial to the performance of any projects. </p><h3 id="body-120-150-words">Body (120-150 Words)</h3><h4 id="topic">Topic</h4><p>Last but not least, the focus of attention determines the final result of a project and is immediately related to working quality.</p><h4 id="state">State</h4><p>Doing several projects at the same time might divert attentiveness and may also undermine the general progress subsequently.</p><h4 id="e.g.">e.g.</h4><p>To illustrate, in the field of architecture which I am majoring in, there is sufficient evidence to show that treating each progress, from scheme design to construction documentation, with attention continually might keep each step more efficient and prepare more fruitful outcomes in the upcoming phase. In other words, it is more reliable for an architect to finish one design and then proceed to the next as well as an unnecessary mix-up of various programs can be a drag on the whole plan. </p><h4 id="close">Close</h4><p>It is no exaggeration to say that stopping one temporarily and changing to others might incur some undesirable accidents.</p><h2 id="第三篇">第三篇</h2><p>Facing the fierce competition in modern society, the pursuit for the success has been the essence of the education. There are multiple choices to promote students’ academic performance and accomplish final goals for students. Personally speaking, I would regard receiving support from families and friends as the most important element to be an elite.</p><p>First and foremost, modern society has witnessed that the career of private tutorship is developing at an alarming rate recently. Admittedly, knowledgeable advisors enable students to enlarge their knowledge base. However, this solution should be not considered as a wise choice. After all, parents and friends are the ones who know us best, because they have experienced every moment of our life with us. No matter what dilemma students are trapped in, it is their closest friends and families who are able to render solid support and lead them step out of woods. What’s more, considering the crucial role played by parents and friends, hiring private advisors would turn out to be a huge drain of parents’ money.</p><p>In addition, it is admitted that attending high school is an imperative factor, which defines students’ educational background and shapes their value. However, it is less rigorous to say that high school education holds the key to accomplish one’s dream. Tracing back to our childhood, whenever we were stuck in a disappointed situation, only if our parents spotted our anomaly, there is no doubt that they would reach out to us and have a deep conversation with us. All they want to do was to encourage us to step out of the shade with a positive attitude and embrace the bright life bravely. Comparatively speaking, high school teachers are only aiming at the promotion of students’ grades. Hardly can they teach students in accordance with their aptitude.</p><p>Last but not least, unconditional support of our families and friends constitutes the steppingstone towards further achievement. No one can substitute their imperative position in our life. For instance, after graduation from high school, not until I packed up my baggage and went abroad for study did I realize how important it is to master fundamental skills, such as financial management, car maintenance and cooking by myself, all of which are taught by my mother. Also, living in a foreign and unfamiliar environment is a huge challenge faced by international students, including me. However, in the darkest and hardest time, my friends always make video call through the convenient Internet, which enables me to receive their warm greetings and erase the severe nostalgia. It is because of their love that I have enough strength and faith to rise above the obstacles.</p><p>In conclusion, with respect to the most effective factor of success, nothing can be compared with the generous love and care from our families and beloved friends. (467)</p>]]></content>
      
      <categories>
          
          <category> 学♂习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TOEFL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LaTeX技巧[1]——打生僻字</title>
      <link href="/2017/04/04/LaTeX%E6%8A%80%E5%B7%A7%5B2%5D%E2%80%94%E2%80%94%E6%89%93%E7%94%9F%E5%83%BB%E5%AD%97/"/>
      <content type="html"><![CDATA[<h2 id="几句废话">几句废话</h2><p>按照惯例还是要来一两句废话的。</p><p>作为一个名字里边有“喆”字的人，经常面临着打不出来“喆”字的问题，比如在使用 xeCJK 包时，就面临着无法直接输入“喆”字的问题，非常坑爹。</p><p>幸好有些办法搞定……</p><h2 id="左右结构的生僻字">左右结构的生僻字</h2><p>既然打不出来“喆”，那“吉”总可以搞定吧，那我打两个一半宽度的“吉”不就好了吗？</p><p>实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\hbox&#123;\resizebox&#123;1.1ex&#125;&#123;1.8ex&#125;&#123;吉&#125;&#125;\hbox&#123;\resizebox&#123;1.1ex&#125;&#123;1.8ex&#125;&#123;吉&#125;&#125;</span><br></pre></td></tr></table></figure><p>其中的高度和宽度可以自行调整。</p><p>类似“喆”的左右结构的生僻字都可以用这种方法解决。</p>]]></content>
      
      <categories>
          
          <category> 代码学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LaTeX技巧[2]——修改数学公式字体</title>
      <link href="/2017/04/04/LaTeX%E6%8A%80%E5%B7%A7%5B1%5D%E2%80%94%E2%80%94%E4%BF%AE%E6%94%B9%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%AD%97%E4%BD%93/"/>
      <content type="html"><![CDATA[<h2 id="几句废话">几句废话</h2><p><span class="math inline">\(\LaTeX\)</span> 的公式环境总的来说不难看，但同一个字体看的次数多了，也难免审美疲劳。加上有些环境下编译的时候字体也比较难看，所以了解一下怎么修改公式的字体就是必须的了。</p><h2 id="修改方法">修改方法</h2><p><span class="math inline">\(\LaTeX\)</span> 中修改公式字体的方法就是把对应的包加上就可以了，我用过的不错的字体有以下几种：</p><h3 id="mathptmx">Mathptmx</h3><p><strong>设置方法</strong>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\usepackage&#123;amsmath&#125;</span><br><span class="line">\usepackage&#123;amssymb&#125;</span><br><span class="line">\usepackage&#123;mathptmx&#125;</span><br><span class="line">\usepackage&#123;bm&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><figure><img src="http://static.zybuluo.com/lzcwr/byvnq0i9n5z08k52qby9jf2g/image_1bcq9rkcm1e1e18v3s5aiu337l9.png" alt="image_1bcq9rkcm1e1e18v3s5aiu337l9.png-21.5kB"><figcaption>image_1bcq9rkcm1e1e18v3s5aiu337l9.png-21.5kB</figcaption></figure><h3 id="fourier">Fourier</h3><p>别把这个和傅里叶联系起来哈……虽然好像确实是傅里叶。。</p><p><strong>设置方法</strong>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\usepackage&#123;amsmath&#125;</span><br><span class="line">\usepackage&#123;amssymb&#125;</span><br><span class="line">\usepackage&#123;fourier&#125;</span><br><span class="line">\usepackage&#123;bm&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><figure><img src="http://static.zybuluo.com/lzcwr/byn049o08zgpwt3i7qwqr5eo/image_1bcq9v8ll3g192i8n7kvi1c9jm.png" alt="image_1bcq9v8ll3g192i8n7kvi1c9jm.png-20.9kB"><figcaption>image_1bcq9v8ll3g192i8n7kvi1c9jm.png-20.9kB</figcaption></figure><h3 id="eulervm">Eulervm</h3><p><strong>设置方法</strong>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\usepackage&#123;amsmath&#125;</span><br><span class="line">\usepackage&#123;amssymb&#125;</span><br><span class="line">\usepackage&#123;ccfonts&#125;</span><br><span class="line">\usepackage[euler-digits]&#123;eulervm&#125;</span><br><span class="line">\usepackage&#123;bm&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><figure><img src="http://static.zybuluo.com/lzcwr/wnn2y9xvridffmxvepsfauqt/image_1bcqa813i155614ba12h11hk0n2u13.png" alt="image_1bcqa813i155614ba12h11hk0n2u13.png-23kB"><figcaption>image_1bcqa813i155614ba12h11hk0n2u13.png-23kB</figcaption></figure><h2 id="参考资料">参考资料</h2><ul><li><a href="http://blog.sina.com.cn/s/blog_5e16f1770100g593.html" target="_blank" rel="noopener">LaTeX技巧86：常用的数学公式字体（含代码）一</a></li></ul>]]></content>
      
      <categories>
          
          <category> 代码学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>组合杂题</title>
      <link href="/2017/03/21/%E7%BB%84%E5%90%88%E6%9D%82%E9%A2%98/"/>
      <content type="html"><![CDATA[<h2 id="几句废话">几句废话</h2><p>组合数学还挺好玩儿的，是哇</p><h2 id="年03月21日">2017年03月21日</h2><h3 id="保险箱问题">保险箱问题</h3><p>这个题是老师在课上提出来的，比较有意思，随手记录一下.</p><blockquote><p><span class="math inline">\(6\)</span> 个人共用一个保险箱，要求任意 <span class="math inline">\(3\)</span> 人在一起时都可以打开保险箱，并且最少需要 <span class="math inline">\(3\)</span> 人才能打开. 请问至少需要多少把锁？每个人至少需要多少把钥匙？</p></blockquote><p><strong>解答</strong>：先估计一个锁数量的下界. 由题意，每 <span class="math inline">\(2\)</span> 个人都不能打开该保险箱， 故每 <span class="math inline">\(2\)</span> 个人都至少有一把不能打开的锁，且对于不同的两人组，不能打开的锁互不相同，故锁的数量不能少于 <span class="math inline">\(2\)</span> 元子集的个数，即 <span class="math inline">\(\binom{6}{2}=15\)</span>.</p><p>再考虑钥匙的数量. 由于任意 <span class="math inline">\(3\)</span> 个人都能打开保险箱，故每个人都需要有<strong>不包括自己的所有二人组所没有的钥匙</strong>，即每个人至少要有 <span class="math inline">\(\binom{5}{2}=10\)</span> 把钥匙.</p><p>以上只是对于下界的估计，要证明其最小性还需构造一组情况来证明最小值可以取到. 构造很容易，不多赘述.</p>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一些概率论题目</title>
      <link href="/2017/03/10/%E4%B8%80%E4%BA%9B%E6%A6%82%E7%8E%87%E8%AE%BA%E9%A2%98%E7%9B%AE/"/>
      <content type="html"><![CDATA[<h2 id="几句废话">几句废话</h2><p>本来觉得概率论是比较简单的课，学了几节课才知道原来简单的是别人家的概率论…我们自家的概率论其实很蛋疼…据刘伟说他当时概率论分比较低…弱菜非常恐慌…于是便在学习中顺便整理一下给自己启发的题目. 由于教材采用师大版概率论（李勇 主编），故题目大多来自于该书.</p><h2 id="年03月10日">2017年03月10日</h2><h3 id="师大概率论-练习-1.2.4">师大概率论 练习 1.2.4</h3><blockquote><p>甲乙两人抛硬币，甲抛 <span class="math inline">\(n+1\)</span> 枚，乙抛 <span class="math inline">\(n\)</span> 枚，求甲的正面比乙多的概率.</p></blockquote><p><strong>解答</strong>：考虑甲乙都抛 <span class="math inline">\(n\)</span> 枚硬币的情形，设甲正面比乙多的概率为 <span class="math inline">\(p\)</span>，则由对称性可知，乙比甲正面多的概率也为 <span class="math inline">\(p\)</span>. 故两人正面一样多的概率为 <span class="math inline">\(1-2p\)</span>. 再考虑甲抛的第 <span class="math inline">\(n+1\)</span> 枚硬币，有 <span class="math inline">\(\frac{1}{2}\)</span> 概率为正面，<span class="math inline">\(\frac{1}{2}\)</span> 为反面，则有如下讨论：</p><ul><li>若都抛 <span class="math inline">\(n\)</span> 枚时，甲比乙正面多，则无论甲的第 <span class="math inline">\(n+1\)</span> 枚为正面还是反面，甲的正面都会比乙多. 该情况出现的概率为 <span class="math inline">\(p_1=p\times1=p\)</span>；</li><li>若都抛 <span class="math inline">\(n\)</span> 枚时，甲比乙正面少，则无论甲的第 <span class="math inline">\(n+1\)</span> 枚为正面还是反面，甲的正面都无法比乙多. 该情况出现的概率为 <span class="math inline">\(p_2=p\times1=p\)</span>；</li><li>若都抛 <span class="math inline">\(n\)</span> 枚时，甲乙正面一样多，且甲的第 <span class="math inline">\(n+1\)</span> 枚为正面，甲的正面就会比乙多. 该情况出现的概率为 <span class="math inline">\(p_3=\frac{1-2p}{2}\times\frac{1}{2}\)</span>；</li><li>若都抛 <span class="math inline">\(n\)</span> 枚时，甲乙正面一样多，且甲的第 <span class="math inline">\(n+1\)</span> 枚为正面，甲的正面就会比乙少. 该情况出现的概率为 <span class="math inline">\(p_3=\frac{1-2p}{2}\times\frac{1}{2}\)</span>.</li></ul><p>以上情况中，第一种和第三种出现时，甲的正面会比乙多，否则不会. 故甲正面比乙多的概率为 <span class="math inline">\(p_1+p_3=\frac{1}{2}\)</span>.</p><hr><p>兔凡提出了一种很好玩儿的解答.</p><p><strong>解答</strong>：甲抛 <span class="math inline">\(n+1\)</span> 枚，乙抛 <span class="math inline">\(n\)</span> 枚，只可能有两种情况出现：</p><ul><li>甲的正面比乙多；</li><li>甲的反面比乙多.</li></ul><p>两种情况不会同时发生，并且概率和为 <span class="math inline">\(1\)</span>，又由对称性可知两种情况出现的概率相同，故都为 <span class="math inline">\(\frac{1}{2}\)</span>.</p><h3 id="师大概率论-练习-1.2.9">师大概率论 练习 1.2.9</h3><blockquote><p>在单位圆周上任取三点 <span class="math inline">\(A,B,C\)</span>，试求事件 $E=&amp;#123; ABC &amp;#125; $ 的概率.</p></blockquote><p><strong>解答</strong>：设 <span class="math inline">\(\triangle ABC\)</span> 的三个内角分别为 <span class="math inline">\(x,y,z\)</span>，则能构成三角形的条件为：</p><p><span class="math display">\[x+y+z=\pi\qquad x,y,z&gt;0\]</span></p><p>在三维坐标系中，“能构成三角形”所对应的样本空间为一个三角形，三个顶点分别为 <span class="math inline">\(D(0,0,\pi),E(0,\pi,0),F(0,0,\pi)\)</span>. 而能构成锐角三角形的条件为：</p><p><span class="math display">\[x+y+z=\pi\qquad 0&lt;x,y,z&lt;\frac{\pi}{2}\]</span></p><p>也会构成一个三角形，三个顶点分别为 <span class="math inline">\(G(0,\frac{\pi}{2},\frac{\pi}{2}),H(\frac{\pi}{2},0,\frac{\pi}{2}),I(\frac{\pi}{2},\frac{\pi}{2},0)\)</span>. 于是 <span class="math inline">\(\triangle ABC\)</span> 为锐角三角形的概率为 <span class="math inline">\(\frac{S_{\triangle GHI}}{S_{\triangle DEF}}=\frac{1}{4}\)</span> .</p><h2 id="年03月22日">2017年03月22日</h2><h3 id="师大概率论-练习-2.1.7">师大概率论 练习 2.1.7</h3><blockquote><p>设 <span class="math inline">\(\mathbb{P}(A)+\mathbb{P}(B)=1\)</span>，证明 <span class="math inline">\(\mathbb{P}(AB)=\mathbb{P}(\overline{A}\overline{B})\)</span>.</p></blockquote><p><strong>证明</strong>：由于事件“<strong><span class="math inline">\(A,B\)</span> 中有且仅有一个发生</strong>”和事件“<strong><span class="math inline">\(A,B\)</span> 中有且仅有一个不发生</strong>”是相同的事件，故其概率也应该相同.</p><p>由容斥原理，事件“<span class="math inline">\(A,B\)</span> 中至少有一个发生”的概率为 <span class="math inline">\(\mathbb{P}(A\cup B)=\mathbb{P}(A)+\mathbb{P}(B)-\mathbb{P}(AB)\)</span>.</p><p>故事件“<strong><span class="math inline">\(A,B\)</span> 中有且仅有一个发生</strong>”的概率为 <span class="math inline">\(\mathbb{P}(A)+\mathbb{P}(B)-\mathbb{P}(AB)\)</span>.</p><p>同理，事件“<span class="math inline">\(A,B\)</span> 中至少有一个不发生”的概率为 <span class="math inline">\(\mathbb{P}(\overline{A}\cup\overline{B})=\mathbb{P}(\overline{A})+\mathbb{P}(\overline{B})-\mathbb{P}(\overline{A}\overline{B})\)</span>.</p><p>故事件“<span class="math inline">\(A,B\)</span> 中有且仅有一个不发生”的概率为 <span class="math inline">\(\mathbb{P}(\overline{A})+\mathbb{P}(\overline{B})-\mathbb{P}(\overline{A}\overline{B})\)</span>.</p><p>于是有，<span class="math display">\[\mathbb{P}(A)+\mathbb{P}(B)-\mathbb{P}(AB)=\mathbb{P}(\overline{A})+\mathbb{P}(\overline{B})-\mathbb{P}(\overline{A}\overline{B}).\]</span></p><p>又由于 <span class="math inline">\(\mathbb{P}(A)+\mathbb{P}(B)=1\)</span>，故 <span class="math inline">\(\mathbb{P}(\overline{A})+\mathbb{P}(\overline{B})=1\)</span>，故有：<span class="math display">\[\mathbb{P}(AB)=\mathbb{P}(\overline{A}\overline{B}).\]</span></p><h2 id="年03月25日">2017年03月25日</h2><h3 id="师大概率论-练习-2.3.2">师大概率论 练习 2.3.2</h3><blockquote><p>试证明事件 <span class="math inline">\(A_1,A_2,\cdots,A_n\)</span> 相互独立的充要条件为：对每个事件 <span class="math inline">\(\hat{A}_{k}=A_k\)</span> 或者 <span class="math inline">\(\overline{A_k}(k=1,2,\cdots,n)\)</span>，总有 <span class="math display">\[\mathbb{P}(\hat{A}_{1}\hat{A}_{2}\cdots\hat{A}_{n})=\mathbb{P}(\hat{A}_{1})\mathbb{P}(\hat{A}_{2})\cdots\mathbb{P}(\hat{A}_{n}).\]</span></p></blockquote><p><strong>证明</strong>：显然 <span class="math inline">\(n=2\)</span> 时成立.</p><p>假设 <span class="math inline">\(n=k\)</span> 时结论成立，则有：</p><p><strong>必要性</strong>：令 <span class="math inline">\(B=A_k\cap A_{k+1}\)</span>，则 <span class="math inline">\(A_1,A_2,\cdots,A_{k-1},B\)</span> 相互独立. 于是有</p><p><span class="math display">\[\mathbb{P}(\hat{A}_{1}\hat{A}_{2}\cdots\hat{A}_{n-1}\hat{B})=\mathbb{P}(\hat{A}_{1})\mathbb{P}(\hat{A}_{2})\cdots\mathbb{P}(\hat{A}_{n-1})\mathbb{P}(\hat{B}).\]</span></p><p>即</p><p><span class="math display">\[\mathbb{P}(\hat{A}_{1}\hat{A}_{2}\cdots\hat{A}_{n-1}A_k A_{k+1})=\mathbb{P}(\hat{A}_{1})\mathbb{P}(\hat{A}_{2})\cdots\mathbb{P}(\hat{A}_{n-1})\mathbb{P}(A_k)\mathbb{P}(A_{k+1}).\]</span></p><p>同理也有：</p><p><span class="math display">\[\mathbb{P}(\hat{A}_{1}\hat{A}_{2}\cdots\hat{A}_{n-1}\overline{A_k} A_{k+1})=\mathbb{P}(\hat{A}_{1})\mathbb{P}(\hat{A}_{2})\cdots\mathbb{P}(\hat{A}_{n-1})\mathbb{P}(\overline{A_k})\mathbb{P}(A_{k+1}).\]</span></p><p><span class="math display">\[\mathbb{P}(\hat{A}_{1}\hat{A}_{2}\cdots\hat{A}_{n-1}A_k \overline{A_{k+1}})=\mathbb{P}(\hat{A}_{1})\mathbb{P}(\hat{A}_{2})\cdots\mathbb{P}(\hat{A}_{n-1})\mathbb{P}(A_k)\mathbb{P}(\overline{A_{k+1}}).\]</span></p><p><span class="math display">\[\mathbb{P}(\hat{A}_{1}\hat{A}_{2}\cdots\hat{A}_{n-1}\overline{A_k} \overline{A_{k+1}})=\mathbb{P}(\hat{A}_{1})\mathbb{P}(\hat{A}_{2})\cdots\mathbb{P}(\hat{A}_{n-1})\mathbb{P}(\overline{A_k})\mathbb{P}(\overline{A_{k+1}}).\]</span></p><p>即有 <span class="math inline">\(\mathbb{P}(\bigcap\limits_{i=1}^{k+1}\hat{A}_{i})=\prod\limits_{i=1}^{k+1}\mathbb{P}(\hat{A}_{i})\)</span>. 必要性得证.</p><p><strong>充分性</strong>：对于 <span class="math inline">\(\forall~1&lt;s&lt;k+1\)</span>，<span class="math inline">\(\forall~1\leq i_1&lt;i_2&lt;\cdots&lt;i_s\leq k+1\)</span>，由条件，对于 <span class="math inline">\(\forall~j\)</span> s.t. <span class="math inline">\(1\leq j\leq k+1\)</span> 且 $j&amp;#123; i_1,i_2,,i_s &amp;#125; $，总有：</p><p><span class="math display">\[\mathbb{P}(\hat{A}_{1}\cdots\hat{A}_{j-1}A_j\hat{A}_{j+1}\cdots\hat{A}_{k+1})=\mathbb{P}(\hat{A}_{1})\cdots\mathbb{P}(\hat{A}_{j-1})\mathbb{P}(A_j)\mathbb{P}(\hat{A}_{j+1})\cdots\mathbb{P}(\hat{A}_{k+1})\]</span></p><p>且</p><p><span class="math display">\[\mathbb{P}(\hat{A}_{1}\cdots\hat{A}_{j-1}\overline{A_j}\hat{A}_{j+1}\cdots\hat{A}_{k+1})=\mathbb{P}(\hat{A}_{1})\cdots\mathbb{P}(\hat{A}_{j-1})\mathbb{P}(\overline{A_j})\mathbb{P}(\hat{A}_{j+1})\cdots\mathbb{P}(\hat{A}_{k+1})\]</span></p><p>由于 <span class="math inline">\(\mathbb{P}(A_j)+\mathbb{P}(\overline{A_j})=1\)</span>，将以上两式相加即得：</p><p><span class="math display">\[\mathbb{P}(\hat{A}_{1}\cdots\hat{A}_{j-1}\hat{A}_{j+1}\cdots\hat{A}_{k+1})=\mathbb{P}(\hat{A}_{1})\cdots\mathbb{P}(\hat{A}_{j-1})\mathbb{P}(\hat{A}_{j+1})\cdots\mathbb{P}(\hat{A}_{k+1})\]</span></p><p>式中共有 <span class="math inline">\(k\)</span> 个事件，故由假设可知这 <span class="math inline">\(k\)</span> 个事件相互独立. 又由于 $&amp;#123; <em>{i_1},,</em>{i_s} &amp;#125; &amp;#123; <em>{1},,</em>{k+1} &amp;#125; $，故有 <span class="math inline">\(\mathbb{P}(\bigcap\limits_{j=1}^{s}A_{i_j})=\prod\limits_{j=1}^{s}\mathbb{P}(A_{i_j})\)</span>，<span class="math inline">\(\forall~1\leq i_1&lt;\cdots&lt;i_s\leq k+1\)</span>. 充分性得证.</p><p><strong>综上所述</strong>，原命题成立.</p>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一些实变函数题目</title>
      <link href="/2017/03/09/%E4%B8%80%E4%BA%9B%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0%E9%A2%98%E7%9B%AE/"/>
      <content type="html"><![CDATA[<h2 id="符号说明">符号说明</h2><p><span class="math inline">\(\mathcal{M}(E)\)</span> 表示 <span class="math inline">\(E\)</span> 的外测度; <span class="math inline">\(m(E)\)</span> 表示 <span class="math inline">\(E\)</span> 的测度.</p><h2 id="年03月09日">2017年03月09日</h2><h3 id="习题1-第一组-7">习题1 第一组 7</h3><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 是定义在 <span class="math inline">\([0,1]\)</span> 上的实值函数, 且存在常数 <span class="math inline">\(M\)</span>, 使得对于 <span class="math inline">\([0,1]\)</span> 中的任意有限个数 <span class="math inline">\(x_1,x_2,\cdots,x_n\)</span>, 均有 <span class="math inline">\(|f(x_1)+f(x_2)+\cdots+f(x_n)|\leqslant M\)</span>, 试证下述集合是可数集: <span class="math display">\[E= \{ x\in[0,1]~|~f(x)\neq0 \} \]</span></p></blockquote><p><strong>证明</strong>: 考虑如下的两族集合:</p><p><span class="math display">\[A_n= \{ x\in[0,1]~|~f(x)&gt;\frac{1}{n} \} \]</span> <span class="math display">\[B_n= \{ x\in[0,1]~|~f(x)&lt;-\frac{1}{n} \} \]</span></p><p>则有:</p><p><span class="math display">\[E=\bigcup_{n=1}^\infty \{ x\in[0,1]~|~|f(x)|&gt;\frac{1}{n} \} =\bigcup_{n=1}^\infty(A_n\cup B_n)\]</span></p><p>而对于 <span class="math inline">\(A_n\)</span>, 任取其中的 <span class="math inline">\(p\)</span> 个数 <span class="math inline">\(x_1,x_2,\cdots,x_p\)</span>, 均有:</p><p><span class="math display">\[p\times\frac{1}{n}&lt;|f(x_1)+f(x_2)+\cdots+f(x_n)|\leqslant M\]</span></p><p>于是有 <span class="math inline">\(p&lt;nM\)</span>, 即 <span class="math inline">\(\forall~n\)</span>, <span class="math inline">\(A_n\)</span> 只含有限个数. 同理 <span class="math inline">\(\forall~n\)</span>, <span class="math inline">\(B_n\)</span> 也只含有限个数. 故 <span class="math inline">\(\forall~n\)</span>, <span class="math inline">\(A_n\cup B_n\)</span> 只含有限个数. 于是 <span class="math inline">\(E\)</span> 为可数个有限集合的并, 故 <span class="math inline">\(E\)</span> 是可数集.</p><h3 id="习题1-第一组-12">习题1 第一组 12</h3><blockquote><p>设 <span class="math inline">\(E=\bigcup\limits_{n=1}^\infty A_n\)</span>. 若 <span class="math inline">\(|E|=\aleph\)</span>, 试证明 <span class="math inline">\(\exists~n_0\)</span>, s.t. <span class="math inline">\(|A_{n_0}|=\aleph\)</span>.</p></blockquote><p><strong>证明</strong>: 显然 <span class="math inline">\(\forall~n\)</span>, <span class="math inline">\(|A_n|\leqslant\aleph\)</span>. 若 <span class="math inline">\(\forall~n\)</span>, <span class="math inline">\(|A_n|&lt;\aleph\)</span>, 则每个 <span class="math inline">\(A_n\)</span> 都是至多可数集. 即 <span class="math inline">\(E\)</span> 为至多可数个至多可数集的并集, 即 <span class="math inline">\(E\)</span> 至多可数, 与 <span class="math inline">\(|E|=\aleph\)</span> 矛盾. 故 <span class="math inline">\(\exists~n_0\)</span>, s.t. <span class="math inline">\(|A_{n_0}|=\aleph\)</span>.</p><h3 id="习题1-第一组-13">习题1 第一组 13</h3><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 是定义在 <span class="math inline">\(\mathbf{R}^1\)</span> 上的单调上升函数, 试证明点集 <span class="math display">\[E= \{ x:\forall~\epsilon&gt;0,~f(x+\epsilon)-f(x-\epsilon)&gt;0 \} \]</span> 是 <span class="math inline">\(\mathbf{R}^1\)</span> 中的闭集.</p></blockquote><p><strong>证明</strong>: 考虑 <span class="math inline">\(\forall~x\in E&#39;\)</span>, <span class="math inline">\(\exists~ \{ x_n \} \subset E\)</span>, s.t. <span class="math inline">\(\lim\limits_{n\to\infty}x_n=x\)</span>. 故 <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, <span class="math inline">\(\exists~N\)</span>, s.t. <span class="math inline">\(\forall~n&gt;N\)</span>, <span class="math inline">\(|x-x_n|&lt;\frac{\epsilon}{2}\)</span>. 于是由条件有 <span class="math inline">\(f(x_{N+1}+\frac{\epsilon}{2})-f(x_{N+1}-\frac{\epsilon}{2})&gt;0\)</span>, 由 <span class="math inline">\(f\)</span> 的单调性, 有 <span class="math display">\[(f(x+\epsilon)-f(x-\epsilon))-(f(x_{N+1}+\frac{\epsilon}{2})-f(x_{N+1}-\frac{\epsilon}{2}))&gt;0\]</span> 即 <span class="math inline">\(x\in E\)</span>. 故 <span class="math inline">\(E\)</span> 为闭集.</p><h3 id="习题1-第一组-14">习题1 第一组 14</h3><blockquote><p>设 <span class="math inline">\(F\subset\mathbf{R}^n\)</span> 为有界闭集, <span class="math inline">\(E\)</span> 是 <span class="math inline">\(F\)</span> 中的一个无限子集, 试证明: <span class="math inline">\(E&#39;\cap F\neq\varnothing\)</span>. 反之, 若 <span class="math inline">\(F\subset\mathbf{R}^n\)</span> 且对 <span class="math inline">\(F\)</span> 中任一无限子集 <span class="math inline">\(E\)</span>, 有 <span class="math inline">\(E&#39;\cap F\neq\varnothing\)</span>, 试证明 <span class="math inline">\(F\)</span> 是有界闭集.</p></blockquote><p><strong>证明</strong>: 一方面, 由于 <span class="math inline">\(E\subset F\)</span>, 故 <span class="math inline">\(E\)</span> 中存在收敛子列, 故 <span class="math inline">\(E&#39;\neq\varnothing\)</span>. 由于 <span class="math inline">\(F\)</span> 是有界闭集, 故 <span class="math inline">\(E&#39;\subset F&#39;\subset F\)</span>, 于是 <span class="math inline">\(E&#39;\cap F\neq\varnothing\)</span>. 另一方面, <strong>首先证明 <span class="math inline">\(F\)</span> 是闭集</strong>: <span class="math inline">\(\forall~x\in F&#39;\)</span>, <span class="math inline">\(\exists~E= \{ x_n \} _{n=1}^{+\infty}\subset F\)</span>, s.t. <span class="math inline">\(\lim\limits_{n\to\infty}x_n=x\)</span>, 即 $E’= { x } $. 又由于 <span class="math inline">\(\forall~E\subset F\)</span>, 均有 <span class="math inline">\(E&#39;\cap F\neq\varnothing\)</span>, 故 <span class="math inline">\(x\in F\)</span>, 即 <span class="math inline">\(F\)</span> 为闭集. <strong>其次证明 <span class="math inline">\(F\)</span> 有界</strong>: 若 <span class="math inline">\(F\)</span> 无界, 则任取 <span class="math inline">\(E\)</span> 为 <span class="math inline">\(F\)</span> 中的发散序列, 即可得到 <span class="math inline">\(E&#39;=\varnothing\)</span>, 此时显然有 <span class="math inline">\(E&#39;\cap F=\varnothing\)</span>, 矛盾. 故 <span class="math inline">\(F\)</span> 有界. <strong>综上</strong>, <span class="math inline">\(F\)</span> 有界闭集.</p><h3 id="习题1-第一组-15">习题1 第一组 15</h3><blockquote><p>设 <span class="math inline">\(F\subset\mathbf{R}^n\)</span> 为闭集, <span class="math inline">\(r&gt;0\)</span>, 证明点集: <span class="math display">\[E= \{ t\in\mathbf{R^n}:~\exists~x\in F,~|t-x|=r \} \]</span> 是闭集.</p></blockquote><p><strong>证明</strong>: <span class="math inline">\(\forall~t\in E&#39;\)</span>, <span class="math inline">\(\exists~ \{ t_n \} _{n=1}^{+\infty}\subset E\)</span>, s.t. <span class="math inline">\(\lim\limits_{n\to\infty}t_n=t\)</span>, 由 <span class="math inline">\(E\)</span> 的定义: <span class="math inline">\(\forall~n\)</span>, <span class="math inline">\(\exists~x_n\in F\)</span>, s.t. <span class="math inline">\(|t_n-x_n|=r\)</span>. 由于 $ { t_n } $ 是收敛子列, 故 $ { t_n } $ 有界, 于是 $ { x_n } $ 也是有界数列, 故 $ { x_n } $ 有收敛子列, 不妨设为 $ { x_{n_k} } $. 取 <span class="math inline">\(x=\lim\limits_{k\to\infty}x_{n_k}\)</span>, 则有 <span class="math inline">\(|t-x|=r\)</span>, 并且 <span class="math inline">\(x\in F\)</span>（由 <span class="math inline">\(F\)</span> 是闭集可知）, 即 <span class="math inline">\(t\in E\)</span>. 即 <span class="math inline">\(E\)</span> 是闭集.</p><h2 id="年03月15日">2017年03月15日</h2><h3 id="习题1-第一组-25">习题1 第一组 25</h3><blockquote><p>设 <span class="math inline">\(f:\mathbf{R}\to\mathbf{R}\)</span>, 令$G_1= \{ (x,y):~y&lt;f(x) \} $, $G_2= \{ (x,y):~y&gt;f(x) \} $, 试证明 <span class="math inline">\(f\in C(\mathbf{R})\)</span> 当且仅当 <span class="math inline">\(G_1\)</span> 与 <span class="math inline">\(G_2\)</span> 是开集.</p></blockquote><p><strong>证明</strong>: <strong>必要性</strong>是显然的, 以下证明<strong>充分性</strong>:</p><p>假设 <span class="math inline">\(f\notin C(\mathbf{R})\)</span>, 则 <span class="math inline">\(\exists~x_0\in\mathbf{R}\)</span>, <span class="math inline">\(\epsilon&gt;0\)</span>, 和 <span class="math inline">\(x_n\)</span>, 满足 <span class="math inline">\(|x_n-x_0|&lt;\frac{1}{n}\)</span>, 但 <span class="math inline">\(|f(x_n)-f(x_0)|\geqslant\epsilon\)</span>. 不妨设 <span class="math inline">\(f(x_n)\geqslant f(x_0)+\epsilon\)</span>, 则 <span class="math inline">\((x_n,f(x_0)+\epsilon)\in G_2^c\)</span>. 由于满足条件的 <span class="math inline">\(x_n\)</span> 构成数列 $ { x_n } $ 且满足 <span class="math inline">\(\lim\limits_{n\to\infty}x_n=x_0\)</span>, 故 <span class="math inline">\(\lim\limits_{n\to\infty}(x_n,f(x_0)+\epsilon)=(x_0,f(x_0)+\epsilon)\)</span>, 又由 <span class="math inline">\(G_2\)</span> 为开集可知 <span class="math inline">\(G_2^c\)</span> 为闭集. 即有 <span class="math inline">\((x_0,f(x_0)+\epsilon)\in G_2^c\)</span>. 故 <span class="math inline">\(f(x_0)\geqslant f(x_0)+\epsilon\)</span>, 矛盾. 故 <span class="math inline">\(f\in C(\mathbf{R})\)</span>.</p><p><strong>综上</strong>, <span class="math inline">\(f\in C(\mathbf{R})\Longleftrightarrow G_1,~G_2\)</span> 为开集.</p><h3 id="证明完全集是不可数集">证明完全集是不可数集</h3><p>这个题目完全是在做周《实变函数论》1.5 的 思考题1 时相到的, <span class="math inline">\(n=2\)</span> 的情况可以参考周《实变函数论》1.5 的 例23.</p><blockquote><p>已知 <span class="math inline">\(E\subset\mathbf{R}^n\)</span> 为完全集, 证明 <span class="math inline">\(E\)</span> 不可数.</p></blockquote><p><strong>证明</strong>: 假设 <span class="math inline">\(E\)</span> 是可数集, 令 $E= { x_1,x_2,,x_n } $. 则可如下构造一个开球列 $ { B_n } $:</p><ol type="1"><li>取 <span class="math inline">\(B_1=B(x_1,r_1)\subset E\)</span>, 则 <span class="math inline">\(\exists~x_{k_1}\in E\)</span>, s.t. <span class="math inline">\(x_{k_1}\in B_1\)</span>, 但 <span class="math inline">\(\forall~i\)</span>, s.t. <span class="math inline">\(2\leqslant i\leqslant k_1-1\)</span>, 均有 <span class="math inline">\(x_i\notin E\)</span>;</li><li>取 <span class="math inline">\(B_1=B(x_{k_1},r_2)\)</span>, s.t. <span class="math inline">\(B_2\subset B_1\)</span>, 且 <span class="math inline">\(r_2&lt;\frac{r_1}{2}\)</span>, 则 <span class="math inline">\(\exists~x_{k_2}\in E~(k_2&gt;k_1)\)</span>, s.t. <span class="math inline">\(x_{k_2}\in B_2\)</span>, 但 <span class="math inline">\(\forall~i\)</span>, s.t. <span class="math inline">\(k_1+1\leqslant i\leqslant k_2-1\)</span>, 均有 <span class="math inline">\(x_i\notin E\)</span>;</li><li><span class="math inline">\(\cdots\cdots\)</span></li><li>取 <span class="math inline">\(B_n=B(x_{k_{n-1}},r_n)\)</span>, s.t. <span class="math inline">\(B_n\subset B_{n-1}\)</span>, 且 <span class="math inline">\(r_n&lt;\frac{r_{n-1}}{2}\)</span>, 则 <span class="math inline">\(\exists~x_{k_n}\in E~(k_n&gt;k_{n-1})\)</span>, s.t. <span class="math inline">\(x_{k_n}\in B_n\)</span>, 但 <span class="math inline">\(\forall~i\)</span>, s.t. <span class="math inline">\(k_{n-1}+1\leqslant i\leqslant k_n-1\)</span>, 均有 <span class="math inline">\(x_i\notin E\)</span>;</li></ol><p>考虑 $ { B_n } $ 的闭包构成的集合列 $ {  } $, 显然有 <span class="math inline">\(\lim\limits_{n\to\infty}|\overline{B_n}|=0\)</span>, 即 $ {  } $ 形成了一个闭集套, 令 $_{n=1}^= { a } $.</p><p>则应有 <span class="math inline">\(a\in E\)</span>, 而由 $ { B_n } $ 的定义可知 <span class="math inline">\(a\notin E\)</span>, 矛盾. 故 <span class="math inline">\(E\)</span> 为不可数集.</p><h3 id="习题1-第一组-26">习题1 第一组 26</h3><blockquote><p>设 <span class="math inline">\(\mathbf{R}\)</span> 中的一切开集构成的集合族为 <span class="math inline">\(\mathscr{G}\)</span>, 证明 <span class="math inline">\(|\mathscr{G}|=\aleph\)</span>. （<span class="math inline">\(|\mathscr{G}|\)</span> 表示 <span class="math inline">\(\mathscr{G}\)</span> 的基数）.</p></blockquote><p><strong>证明</strong>: <strong>一方面</strong>, 令 $= { (0,x)<sub>|</sub>x } $, 则 <span class="math inline">\(|\mathscr{A}|\subset\mathscr{G}\)</span>, 且 <span class="math inline">\(|\mathscr{A}|=\aleph\)</span>. 故 <span class="math inline">\(|\mathscr{G}|\geqslant\aleph\)</span>.</p><p><strong>另一方面</strong>, 设 <span class="math inline">\(E\)</span> 为 <span class="math inline">\(\mathbf{R}\)</span> 中以有理数为端点的开区间的全体, 则由 <span class="math inline">\(E\subset\mathbf{Q}^2\)</span> 可知 <span class="math inline">\(E\)</span> 为可数集, 于是有 <span class="math inline">\(|\mathscr{P}(E)|=\aleph\)</span>.</p><p>由于 <span class="math inline">\(\mathbf{R}\)</span> 中的每个开区间都可以表示为可数个有理开区间的并, 故对于 <span class="math inline">\(G\in\mathscr{G}\)</span>, 设 <span class="math inline">\(G=\bigcup\limits_{n=1}^\infty(\alpha_n,\beta_n)\)</span>, 其中 <span class="math inline">\((\alpha_n,\beta_n)\in E\)</span>. 据此可构造如下映射:</p><p><span class="math display">\[\varphi:~\mathscr{P}(E)\longrightarrow\mathscr{G},\quad \{ (\alpha_n,\beta_n) \} _{n=1}^{+\infty}\longmapsto G~.\]</span></p><p>由于数列的极限唯一, 故 <span class="math inline">\(\varphi\)</span> 是良好定义的, 又由于 <span class="math inline">\(G\)</span> 的逼近方法不唯一, <span class="math inline">\(\overline{\mathbf{Q}}=\mathbf{R}\)</span>, 故 <span class="math inline">\(\varphi\)</span> 为满射但不为单射. 故 <span class="math inline">\(|\mathscr{G}|\leqslant|\mathscr{P}(E)|=\aleph\)</span>.</p><p><strong>综上</strong>, <span class="math inline">\(|\mathscr{G}|=\aleph\)</span>.</p><h2 id="年03月27日">2017年03月27日</h2><h3 id="思考题-2-ii">2.1 思考题 2 (ii)</h3><blockquote><p>设 <span class="math inline">\(A,B,C\)</span> 是 <span class="math inline">\(\mathbf{R}^n\)</span> 中的点集, 且有 <span class="math display">\[\mathcal{M}(A\triangle B)=\mathcal{M}(B\triangle C)=0\]</span> 求证 <span class="math inline">\(\mathcal{M}(A\triangle C)=0\)</span>.</p></blockquote><p><strong>证明</strong>: 注意到 <span class="math display">\[A\backslash C=(A\cap C^c)\cap(B\cup B^c)=[A\cap (B\backslash C)]\cup[C^c\cap(A\backslash B)]\]</span> 又由条件有 <span class="math display">\[\mathcal{M}(A\backslash B)=\mathcal{M}(B\backslash A)=\mathcal{M}(B\backslash C)=\mathcal{M}(C\backslash B)=0\]</span> 可以很容易地得到 <span class="math inline">\(\mathcal{M}(A\backslash C)=0\)</span>, 类似可得 <span class="math inline">\(\mathcal{M}(C\backslash A)=0\)</span>, 故 <span class="math inline">\(\mathcal{M}(A\triangle C)=0\)</span>.</p><h3 id="思考题-3">2.1 思考题 3</h3><blockquote><p>设 <span class="math inline">\(E\subset\mathbf{R}^n\)</span>, 若对于 <span class="math inline">\(\forall~x\in E\)</span>, 总存在开球 <span class="math inline">\(B(x,\delta_x)\)</span>, 使得 <span class="math inline">\(\mathcal{M}(E\cap B(x,\delta_x))=0\)</span>, 试证明 <span class="math inline">\(\mathcal{M}(E)=0\)</span>.</p></blockquote><p><strong>证明</strong>: 有条件, 存在一个开球族 <span class="math inline">\(\mathscr{B}\)</span>, s.t. <span class="math inline">\(x\in E\)</span>, 并且 <span class="math inline">\(E=\bigcup\limits_{B_x\in\mathscr{B}}(E\cap B_x)\)</span>. 可以取适当的 <span class="math inline">\(\delta_x\)</span>, 使得 <span class="math inline">\(B\)</span> 中的开球两两不相交, 此时 <span class="math inline">\(\mathscr{B}\)</span> 为 <span class="math inline">\(\mathbf{R}^n\)</span> 中互不相交的开集族, 即 <span class="math inline">\(\mathscr{B}\)</span> 至多可数, 且 <span class="math inline">\(\forall~B_x\in\mathscr{B}\)</span>, 总有 <span class="math inline">\(\mathcal{M}(B_x\cap E)=0\)</span>.</p><p>故由测度的 <span class="math inline">\(\sigma\)</span>-可加性, <span class="math inline">\(\mathcal{M}(E)=\sum\limits_{B_x\in\mathscr{B}}\mathcal{M}(E\cap B_x)=0\)</span>.</p><p><strong>这个证法是错误的……以后再修改</strong></p><p>(翻到一个叫 <strong>lindelof 定理</strong> 的东西……这个题目好像就是定理的直接推论.）</p><h3 id="思考题-2">2.2 思考题 2</h3><blockquote><p>设 $ { A_n } $ 是互不相交的可测集列, <span class="math inline">\(B_n\subset A_n~(n=1,2,\cdots)\)</span>, 证明: <span class="math display">\[\mathcal{M}\left(\bigcup\limits_{n=1}^\infty B_n\right)=\sum\limits_{n=1}^\infty \mathcal{M}(B_n).\]</span></p></blockquote><p><strong>证明</strong>: 由于 <span class="math inline">\(\mathcal{M}\left(\bigcup\limits_{n=1}^\infty B_n\right)\leqslant\sum\limits_{n=1}^\infty \mathcal{M}(B_n)\)</span> 显然成立, 故只需证明 <span class="math inline">\(\mathcal{M}\left(\bigcup\limits_{n=1}^\infty B_n\right)\geqslant\sum\limits_{n=1}^\infty \mathcal{M}(B_n)\)</span>.</p><p>对于有限项的 <span class="math inline">\(B_k\)</span>, 由于 <span class="math inline">\(B_k\)</span> 两两不交, 由外测度的定义有 <span class="math inline">\(\sum\limits_{k=1}^n \mathcal{M}(B_k)=\mathcal{M}\left(\bigcup\limits_{k=1}^n B_k\right)\)</span>.</p><p>显然 <span class="math inline">\(\mathcal{M}\left(\bigcup\limits_{k=1}^n B_k\right)\)</span> 对于 <span class="math inline">\(n\)</span> 显然是递增集合列, 故对上式取极限可得:</p><p><span class="math display">\[\sum\limits_{k=1}^n \mathcal{M}(B_k)=\mathcal{M}\left(\bigcup\limits_{k=1}^n B_k\right)\leqslant \mathcal{M}\left(\bigcup\limits_{k=1}^\infty B_k\right).\]</span></p><p>即有 <span class="math inline">\(\forall~n\in\mathbf{N}\)</span>, 均有 <span class="math inline">\(\sum\limits_{k=1}^n \mathcal{M}(B_k)\leqslant \mathcal{M}\left(\bigcup\limits_{k=1}^\infty B_k\right)\)</span>,</p><p>故对上式左侧也取极限, 有 <span class="math inline">\(\sum\limits_{k=1}^\infty \mathcal{M}(B_k)\leqslant \mathcal{M}\left(\bigcup\limits_{k=1}^\infty B_k\right).\)</span></p><p>即结论成立.</p><h3 id="思考题-3-1">2.2 思考题 3</h3><blockquote><p>设有点集 <span class="math inline">\(E_1,E_2\)</span>, 且 <span class="math inline">\(E_1\in\mathscr{M}\)</span>. 若 <span class="math inline">\(m(E_1\triangle E_2)=0\)</span>, 求证 <span class="math inline">\(E_2\in\mathscr{M}\)</span>, 且 <span class="math inline">\(m(E_1)=m(E_2)\)</span>.</p></blockquote><p><strong>证明</strong>: 考虑 <span class="math inline">\(E_2=[E_1\backslash(E_1\backslash E_2)]\cup(E_2\backslash E_1)\)</span>, 则易得结论.</p><h2 id="年04月20日">2017年04月20日</h2><h3 id="思考题-4">2.2 思考题 4</h3><blockquote><p>设点集 <span class="math inline">\(B\)</span> 满足: 对于 <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, <span class="math inline">\(\exists~A\in\mathscr{M}\)</span>, s.t. <span class="math inline">\(\mathcal{M}(A\triangle B)&lt;\epsilon\)</span>, 试证明 <span class="math inline">\(B\)</span> 是可测集.</p></blockquote><p><strong>证明</strong>: 由条件, <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, <span class="math inline">\(\exists~ \{ A_k \} _{k=1}^{+\infty}\subset\mathscr{M}\)</span>, s.t. <span class="math inline">\(\mathcal{M}(B\triangle A_k)&lt;\frac{\epsilon}{2^k}\)</span>, (<span class="math inline">\(k\in\mathbf{N})\)</span>.</p><p>故 <span class="math inline">\(\mathcal{M}(B\backslash A_k)&lt;\frac{\epsilon}{2^k}\)</span>, 且 <span class="math inline">\(\mathcal{M}(A_k\backslash B)&lt;\frac{\epsilon}{2^k}\)</span>.</p><p>令 <span class="math inline">\(A=\bigcup\limits_{k=1}^{\infty}A_k\)</span>, 则由任意 <span class="math inline">\(A_k\)</span> 均为可测集可知, <span class="math inline">\(A\)</span> 为可测集.</p><p>又有 <span class="math inline">\(B\backslash A=\bigcap\limits_{k=1}^{\infty}(B\backslash A_k)\)</span>, <span class="math inline">\(A\backslash B=\bigcap\limits_{k=1}^{\infty}(A_k\backslash B)\)</span>, 故 <span class="math inline">\(\mathcal{M}(B\backslash A)\leqslant\mathcal{M}(B\backslash A_k)\)</span>, 且 <span class="math inline">\(\mathcal{M}(A\backslash B) \leqslant\sum\limits_{k=1}^{\infty}\mathcal{M}(A_k\backslash B)\)</span>.</p><p>故 <span class="math inline">\(\mathcal{M}(B\backslash A)\leqslant\frac{\epsilon}{2^k}\)</span>, <span class="math inline">\(\mathcal{M}(A\backslash B)\leqslant\sum\limits_{k=1}^{\infty}\frac{\epsilon}{2^k}=\epsilon\)</span>, 即 <span class="math inline">\(\mathcal{M}(A\backslash B)=\mathcal{M}(B\backslash A)=0\)</span>.</p><p>于是 <span class="math inline">\(A\backslash B\)</span> 和 <span class="math inline">\(B\backslash A\)</span> 可测. 故由 <span class="math inline">\(B=(B\backslash A)\cup(A\backslash(A\backslash B))\)</span>, 故 <span class="math inline">\(B\)</span> 为可测集.</p><h3 id="思考题-8">2.2 思考题 8</h3><blockquote><p>设有 <span class="math inline">\(\mathbf{R}^1\)</span> 中可测集列 $ { E_k } $, 且当 <span class="math inline">\(k\geqslant k_0\)</span> 时, <span class="math inline">\(E_k\subset[a,b]\)</span>. 若存在 <span class="math inline">\(\lim\limits_{k\to\infty}E_k=E\)</span>, 试证明: <span class="math inline">\(m(E)=\lim\limits_{k\to\infty}m(E_k)\)</span>.</p></blockquote><p><strong>证明</strong>: <strong>一方面</strong>, 由于 <span class="math inline">\(\varlimsup\limits_{k\to\infty}E_k=\bigcap\limits_{j=1}^{\infty}\bigcup\limits_{k=j}^{\infty}E_k=\lim\limits_{k\to\infty}(\bigcup\limits_{j=k}^{\infty}E_j)\)</span>.</p><p>故 <span class="math inline">\(m\left(\varlimsup\limits_{k\to\infty}E_k\right)=m\left(\lim\limits_{k\to\infty}(\bigcup\limits_{j=k}^{\infty}E_j)\right)\geqslant\varlimsup\limits_{k\to\infty}m(E_k)\)</span>.</p><p>又由于 $ { E_k } $ 收敛, 故有:</p><p><span class="math display">\[m(E)=m(\lim\limits_{k\to\infty}E_k)=m(\varlimsup\limits_{k\to\infty}E_k)\geqslant\varlimsup\limits_{k\to\infty}m(E_k)\geqslant\lim\limits_{k\to\infty}m(E_k).\]</span></p><p>即 <span class="math inline">\(m(E)\geqslant\lim\limits_{k\to\infty}m(E_k)\)</span>.</p><p><strong>另一方面</strong>, <span class="math inline">\(\varliminf\limits_{k\to\infty}E_k=\bigcup\limits_{j=1}^{\infty}\bigcap\limits_{k=j}^{\infty}E_k=\lim\limits_{k\to\infty}(\bigcup\limits_{j=k}^{\infty}E_j)\)</span>.</p><p>故 <span class="math inline">\(m\left(\varliminf\limits_{k\to\infty}E_k\right)=m\left(\lim\limits_{k\to\infty}(\bigcap\limits_{j=k}^{\infty}E_j)\right)\leqslant\varliminf\limits_{k\to\infty}m(E_k)\)</span>.</p><p>故 <span class="math inline">\(m(E)\leqslant\varliminf\limits_{k\to\infty}m(E_k)\leqslant\lim\limits_{k\to\infty}m(E_k)\)</span>.</p><p><strong>综上所述</strong>, <span class="math inline">\(m(E)=\lim\limits_{k\to\infty}m(E_k)\)</span>.</p><h2 id="年04月24日">2017年04月24日</h2><h3 id="习题2-第一组-8">习题2 第一组 8</h3><blockquote><p>设 $ { E_k } $ 是 <span class="math inline">\([0,1]\)</span> 中的可测集列, <span class="math inline">\(m(E_k)=1\)</span>, <span class="math inline">\((k=0,1,\cdots)\)</span>, 试证明: <span class="math inline">\(m\left(\bigcap\limits_{k=1}^{\infty}E_k\right)=1\)</span>.</p></blockquote><p><strong>证明</strong>: 由于 $ { E_k } $ 可测, 且 <span class="math inline">\(m(E_k)=1\)</span>, <span class="math inline">\(\forall~k\in\mathbf{N}_+\)</span>, 又 <span class="math inline">\(E_k\subset[0,1]\)</span>, 故 <span class="math inline">\(m([0,1]\backslash E_k)=0\)</span>, <span class="math inline">\(\forall~k\in\mathbf{N}_+\)</span>.</p><p>于是 <span class="math display">\[m\left(\bigcap\limits_{k=1}^{\infty}E_k\right)=1-\left([0,1]\backslash\bigcap\limits_{k=1}^{\infty}E_k\right)=1-\left(\bigcup\limits_{k=1}^{\infty}([0,1]\backslash E_k)\right)=1-\sum\limits_{k=1}^{\infty}m([0,1]\backslash E_k)=1.\]</span></p><p>又由于 <span class="math inline">\(m(\bigcap\limits_{k=1}^{\infty}E_k)\leqslant m(E_1)=1\)</span>, 故 <span class="math inline">\(m\left(\bigcap\limits_{k=1}^{\infty}E_k\right)=1\)</span>.</p><h3 id="习题2-第一组-11">习题2 第一组 11</h3><blockquote><p>设 $ { B_} _{I}$ 是 <span class="math inline">\(\mathbf{R}^n\)</span> 中一族开球, 记 <span class="math inline">\(G=\bigcup\limits_{\alpha\in I}B_\alpha\)</span>. 若有 <span class="math inline">\(0&lt;\lambda&lt;m(G)\)</span>, 试证明存在有限个互不相交的开球 <span class="math inline">\(B_{\alpha_1},B_{\alpha_2},\cdots,B_{\alpha_m}\)</span>, 使得 <span class="math inline">\(\sum\limits_{k=1}^m m(B_{\alpha_k})\)</span> 大于 <span class="math inline">\(\frac{\lambda}{3^n}.\)</span></p></blockquote><p><strong>证明</strong>: 取紧集 <span class="math inline">\(K\subset G\)</span>, s.t. <span class="math inline">\(m(K)&gt;\lambda\)</span>, 则 $ { B_} $ 构成 <span class="math inline">\(K\)</span> 的一个开覆盖. 于是存在有限子覆盖 <span class="math inline">\(B_1,B_2\cdots,B_k\)</span>.</p><p>取其中半径最大者为 <span class="math inline">\(B_{\alpha_1}\)</span>, 则将 <span class="math inline">\(B_{\alpha_1}\)</span> 的半径扩大三倍即可将 <span class="math inline">\(B_i\)</span> 中所有与 <span class="math inline">\(B_{\alpha_1}\)</span> 相交的开球全部覆盖;</p><p>再取 <span class="math inline">\(B_i\)</span> 中与 <span class="math inline">\(B_{\alpha_1}\)</span> 不相交的球中半径最大者为 <span class="math inline">\(B_{\alpha_2}\)</span>, 则将其半径扩大三倍即可将与其相交的开球全部覆盖.</p><p>如此继续下去可以选出有限个开球 <span class="math inline">\(B_{\alpha_1},B_{\alpha_2}\cdots,B_{\alpha_m}\)</span>, s.t. 将其中的每一个球半径扩大三倍可以构成 <span class="math inline">\(K\)</span> 的覆盖.</p><p>于是 <span class="math inline">\(\sum\limits_{i=1}^m 3^n\times m(B_{\alpha_i})&gt;\lambda\)</span>, 即 <span class="math inline">\(\sum\limits_{k=1}^m m(B_{\alpha_k})&gt;\frac{\lambda}{3^n}\)</span>, 原命题得证.</p><h2 id="年04月25日">2017年04月25日</h2><h3 id="习题2-第一组-12">习题2 第一组 12</h3><blockquote><p>设 $ { B_k } $ 是 <span class="math inline">\(\mathbf{R}^n\)</span> 中递减可测集列, <span class="math inline">\(\mathcal{M}(A)&lt;\infty\)</span>. 令 <span class="math inline">\(E_k=A\cap B_k~(k=0,1,\cdots)\)</span>, <span class="math inline">\(E=\bigcap\limits_{k=1}^\infty E_k\)</span>, 试证明 <span class="math display">\[\lim\limits_{k\to\infty}\mathcal{M}(E_k)=\mathcal{M}(E).\]</span></p></blockquote><p><strong>证明</strong>: 令 <span class="math inline">\(A\)</span> 的等测包为 <span class="math inline">\(H\)</span>, 则 $ { B_kH } $ 为递减可测集列.</p><p>于是 <span class="math inline">\(\lim\limits_{k\to\infty} m(H\cap B_k)=m\left(\lim\limits_{k\to\infty}(H\cap B_k)\right)=m\left((\bigcap\limits_{k=1}^\infty B_k)\cap H\right)\)</span>.</p><p>而对于 <span class="math inline">\(\forall~k\)</span>, <span class="math inline">\(m(H\cap B_k)-m\left(\bigcap\limits_{k=1}^\infty(H\cap B_k)\cap H\right)=m\left((H\cap B_k)\backslash\bigcap\limits_{k=1}^\infty(H\cap B_k)\right)\)</span>.</p><p>又由于 <span class="math inline">\(H\)</span> 和 <span class="math inline">\(B_k\)</span> 均为可测集, 故 <span class="math inline">\(m\left((H\cap B_k)\backslash\bigcap\limits_{k=1}^\infty(H\cap B_k)\right)=\mathcal{M}\left((H\cap B_k)\backslash\bigcap\limits_{k=1}^\infty(H\cap B_k)\right)\)</span>.</p><p>即 <span class="math inline">\(m(H\cap B_k)-m\left(\bigcap\limits_{k=1}^\infty(H\cap B_k)\right)=\mathcal{M}\left((H\cap B_k)\backslash\bigcap\limits_{k=1}^\infty(H\cap B_k)\right)\)</span>.</p><p>由于 <span class="math inline">\(A\subset H\)</span>, 故 <span class="math display">\[\begin{align}m(H\cap B_k)-m\left(\bigcap\limits_{k=1}^\infty(H\cap B_k)\right) &amp;\geqslant \mathcal{M}\left(A\cap (B_k\backslash\bigcap\limits_{k=1}^{\infty}B_k)\right) \\ &amp;= \mathcal{M}\left((A\cap B_k) \backslash \bigcap\limits_{k=1}^{\infty}(A\cap B_k)\right) \\ &amp;= \mathcal{M}(E_k\backslash\bigcap\limits_{k=1}^{\infty} E_k) = \mathcal{M}(E_k\backslash E) \\ &amp;\geqslant \mathcal{M}(E_k)-\mathcal{M}(E).\end{align}\]</span></p><p>由于 <span class="math inline">\(E_k\)</span> 递减, 故 <span class="math inline">\(\mathcal{M}(E_k)\geqslant\mathcal{M}(E)\)</span>, <span class="math inline">\(\forall~k\in\mathbf{N}_+\)</span>, 即 <span class="math inline">\(\mathcal{M}(E_k)-\mathcal{M}(E)\geqslant 0\)</span>.</p><p>又由于 <span class="math inline">\(\lim\limits_{k\to\infty}\left(m(H\cap B _k)-m(\bigcap\limits_{k=1}^{\infty}(H\cap B_k)\right)=0\)</span>.</p><p>故 <span class="math inline">\(\lim\limits_{k\to\infty}\mathcal{M}(E_k)-\mathcal{M}(E)=0\)</span>, 即 <span class="math inline">\(\lim\limits_{k\to\infty}\mathcal{M}(E_k)=\mathcal{M}(E)\)</span>.</p><h2 id="年04月26日">2017年04月26日</h2><h3 id="习题2-第一组-14">习题2 第一组 14</h3><blockquote><p>试证明点集 <span class="math inline">\(E\)</span>　可测的充要条件是: 对任意 <span class="math inline">\(\epsilon&gt;0\)</span>, 存在开集 <span class="math inline">\(G_1,G_2\)</span>: <span class="math display">\[G_1\supset E,\quad G_2\supset E^c,\]</span> 使得 <span class="math inline">\(m(G_1\cap G_2)&lt;\epsilon\)</span>.</p></blockquote><p><strong>证明</strong>: <strong>必要性</strong>: 由于 <span class="math inline">\(E\)</span> 为可测集, 故:</p><ol type="1"><li>存在开集 <span class="math inline">\(G\supset E\)</span>, s.t. <span class="math inline">\(m(G)-m(E)&lt;\frac{\epsilon}{2}\)</span>.</li><li>存在闭集 <span class="math inline">\(F\subset E\)</span>, s.t. <span class="math inline">\(m(E)-m(F)&lt;\frac{\epsilon}{2}\)</span>.</li></ol><p>取 <span class="math inline">\(G_1=G\)</span>, <span class="math inline">\(G_2=F^c\)</span>, 则 <span class="math inline">\(\mathcal{M}(G_1\cap G_2)=m(G\backslash F)=m(G)-m(F)&lt;\epsilon\)</span>.</p><p><strong>充分性</strong>: 取递减开集列 <span class="math inline">\(G_{1n}\)</span> 和 <span class="math inline">\(G_{2n}\)</span>, s.t. <span class="math inline">\(\forall~n\)</span>, 有 <span class="math inline">\(E\subset G_{1n}\)</span>, <span class="math inline">\(E^c\subset G_{2n}\)</span> 且 <span class="math inline">\(m(G_{1n}-G_{2n})&lt;\frac{1}{n}\)</span>.</p><p>则取 <span class="math inline">\(G=\lim\limits_{n\to\infty} G_{1n}\)</span>, 即可使得 <span class="math inline">\(G\)</span> 为可测集, 且 <span class="math inline">\(\mathcal{M}(G\backslash E)\leqslant\mathcal{M}(G_{1n}\cap G_{2n})\)</span>. 取极限, 即有 <span class="math inline">\(\mathcal{M}(G\backslash E)=0\)</span>.</p><p>于是 <span class="math inline">\(G\backslash E\)</span> 为零测集, 即 <span class="math inline">\(E\)</span> 可测.</p><h3 id="习题2-第一组-15">习题2 第一组 15</h3><blockquote><p>设 <span class="math inline">\(E\subset[0,1]\)</span> 是可测集且有 <span class="math display">\[m(E)\geqslant\epsilon &gt;0,\quad x_i\in[0,1],~i=1,2,\cdots,n,\]</span> 其中 <span class="math inline">\(n&gt;\frac{2}{\epsilon}\)</span>. 试证明 <span class="math inline">\(E\)</span> 中存在两个点, 其距离等于 $ { x_1,x_2,,x_n } $ 中某两个点的距离.</p></blockquote><p><strong>证明</strong>: 由于 <span class="math inline">\(\forall~i\in\mathbf{N}\)</span>, s.t. <span class="math inline">\(1\leqslant i\leqslant n\)</span>, 总有 <span class="math inline">\(x_i\in[0,1]\)</span>. 于是 <span class="math inline">\(E+ \{ x_i \} \subset[0,2]\)</span>, <span class="math inline">\(\forall~i\)</span>.</p><p>故 <span class="math inline">\(\bigcup\limits_{i=1}^n (E+ \{ x_i \} )\subset[0,2]\)</span>, 故 <span class="math inline">\(m\left(\bigcup\limits_{i=1}^n (E+ \{ x_i \} )\right)\leqslant 2\)</span>.</p><p>由于 <span class="math inline">\(n&gt;\frac{2}{\epsilon}\)</span>, 故 <span class="math inline">\(\exists~i\neq j\)</span>, s.t. <span class="math inline">\((E+ \{ x_i \} )\cap(E+ \{ x_j \} )\neq\varnothing\)</span>. （否则 <span class="math inline">\(\sum\limits_{i=1}^n m(E+ \{ x_i \} )\leqslant 2\)</span>, 即 <span class="math inline">\(n\leqslant\frac{\epsilon}{2}\)</span>, 矛盾.） 原命题得证.</p><h2 id="年05月11日">2017年05月11日</h2><h3 id="思考题-3-2">3.2 思考题 3</h3><blockquote><p>设 $ { f_k(x) } $ 在 <span class="math inline">\(E\)</span>上依测度收敛于零, <span class="math inline">\(g(x)\)</span> 是 <span class="math inline">\(E\)</span> 上实值可测函数. 若 <span class="math inline">\(m(E)=+\infty\)</span>, 试说明 $ { g(x)f_k(x) } $ 在 <span class="math inline">\(E\)</span> 上不一定依测度收敛于零.</p></blockquote><p><strong>证明</strong>: 取 <span class="math inline">\(g(x)=x,~f_k(x)=\frac{1}{k}\)</span> 即可.</p><h3 id="习题3-第一组-4">习题3 第一组 4</h3><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 是 <span class="math inline">\(E\subset\mathbf{R}^n\)</span> 上几乎处处有限的可测函数, <span class="math inline">\(m(E)&lt;\infty\)</span>, 试证明对于 <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, 存在 <span class="math inline">\(E\)</span> 上的有界可测函数 <span class="math inline">\(g(x)\)</span>, s.t. <span class="math inline">\(m( \{ x\in E:|f(x)-g(x)|&gt;0 \} )&lt;\epsilon\)</span>.</p></blockquote><p><strong>证明</strong>: 令 $E_= { xE:|f(x)|=} $, $E_n= { xE:|f(x)|n } $, <span class="math inline">\(n=1,2,\cdots\)</span>, 则 <span class="math inline">\(E\supset E_1\supset E_2\supset\cdots\)</span>, <span class="math inline">\(E_\infty=\bigcap\limits_{n=1}^\infty E_n\)</span>. 又由于 <span class="math inline">\(f(x)\)</span> 几乎处处有限, 故 <span class="math inline">\(\lim\limits_{n\to\infty}m(E_n)=m(\lim\limits_{n\to\infty}E_n)=0\)</span>. 故 <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, <span class="math inline">\(\exists~N\)</span>, s.t. <span class="math inline">\(m(E_N)=m( \{ x\in E:|f(x)|\geqslant N \} )&lt;\epsilon\)</span>, 故可以取函数 <span class="math display">\[g(x)=   \begin{cases}   f(x), &amp; x\in E\backslash E_N \\   0, &amp; x\in E_N   \end{cases}\]</span> 则 <span class="math inline">\(g(x)\)</span> 有界可测, 并且 <span class="math inline">\(m( \{ x\in E:|f(x)-g(x)|&gt;0 \} )\leqslant m(E_N)&lt;\epsilon\)</span>.</p><h3 id="习题3-第一组-5">习题3 第一组 5</h3><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 及 <span class="math inline">\(f_n(x)~(n=1,2,\cdots)\)</span> 都是 <span class="math inline">\(A\subset\mathbf{R}^1\)</span> 上几乎处处有限的可测函数. 若对于 <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, 存在 <span class="math inline">\(A\)</span> 的可测子集 <span class="math inline">\(B:m(A\backslash B)&lt;\epsilon\)</span>, s.t. <span class="math inline">\(f_n(x)\)</span> 在 <span class="math inline">\(B\)</span> 上一致收敛于 <span class="math inline">\(f(x)\)</span>, 试证明 <span class="math inline">\(f_n(x)\)</span> 在 <span class="math inline">\(A\)</span> 上几乎处处收敛于 <span class="math inline">\(f(x)\)</span>.</p></blockquote><p><strong>证明</strong>: 由条件, 对于 <span class="math inline">\(\epsilon_m=\frac{1}{2^m}\)</span>, 存在 <span class="math inline">\(A\)</span> 的可测子集 <span class="math inline">\(B_m\)</span>, s.t. <span class="math inline">\(m(A\backslash B_m)&lt;\epsilon_m\)</span>, 且 <span class="math inline">\(f_n(x)\)</span> 在 <span class="math inline">\(B_m\)</span> 上一致收敛于 <span class="math inline">\(f(x)\)</span>. 令 <span class="math inline">\(B=\bigcap\limits_{j=1}^\infty\bigcup\limits_{m=j}^\infty(A\backslash B_m)\)</span>, 由于 <span class="math display">\[m(B)\leqslant m(\bigcup\limits_{m=j}^\infty(A\backslash B_m))\leqslant\sum\limits_{m=j}^\infty m(A\backslash B_m)&lt;\sum\limits_{m=j}^\infty\frac{1}{2^m},\quad\forall~j.\]</span> 故 <span class="math inline">\(m(B)=0\)</span>. 故 <span class="math inline">\(\forall~x\in A\backslash B=\bigcap\limits_{j=1}^\infty\bigcup\limits_{m=j}^\infty B_m\)</span>, <span class="math inline">\(\exists~j_0\)</span>, s.t. <span class="math inline">\(x\in\bigcap\limits_{m=j_0}^\infty B_m\)</span>, 由于 <span class="math inline">\(f_n\)</span> 在 <span class="math inline">\(B_m\)</span> 上一致收敛, 故在 <span class="math inline">\(x\)</span> 处应收敛. 由于 <span class="math inline">\(m(B)=0\)</span>, 故 <span class="math inline">\(f_n\)</span> 在 <span class="math inline">\(A\)</span> 上几乎处处收敛于 <span class="math inline">\(f\)</span>.</p><h3 id="习题3-第一组-6">习题3 第一组 6</h3><blockquote><p>设 $ { f_k(x) } $ 是 <span class="math inline">\(E\subset\mathbf{R}^n\)</span> 上的实值可测函数列, <span class="math inline">\(m(E)&lt;\infty\)</span>, 试证明 <span class="math display">\[\lim\limits_{k\to\infty}f_k(x)=0,\quad\text{a.e.}~x\in E\]</span> 的充要条件是 <span class="math display">\[\forall~\epsilon&gt;0,~\lim\limits_{k\to\infty}m( \{ x\in E:\sup\limits_{k\geqslant j} \{ |f_k(x)| \} \geqslant\epsilon \} )=0.\]</span></p></blockquote><p><strong>证明</strong>: 记 $I= { xE:f_k(x)0~(k) } $, $I_m=_{k} { |f_k(x)| } $, 则 <span class="math inline">\(I=\bigcup\limits_{m=1}^\infty I_m\)</span>. <strong>充分性</strong>: 若 <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, 总有 <span class="math inline">\(\lim\limits_{j\to\infty} m\left( \{ x\in E:\sup\limits_{k\geqslant} \{ f_k(x) \} \geqslant\epsilon \} \right)=0\)</span>, 则 <span class="math display">\[\begin{align}\mathcal{M}(I) &amp;\leqslant \sum\limits_{m=1}^\infty m(I_m) \\&amp;= \sum\limits_{m=1}^\infty m\left( \bigcap\limits_{j=1}^\infty\bigcup\limits_{k=j}^\infty \{ x\in E:|f_k(x)|\geqslant\frac{1}{m} \}  \right) \\&amp;= \sum\limits_{m=1}^\infty \left( \lim\limits_{j\to\infty}m(\bigcup\limits_{k=j}^\infty  \{ x\in E:|f_k(x)|\geqslant\frac{1}{m} \} ) \right) \\&amp;\leqslant \sum\limits_{m=1}^\infty \lim\limits_{j\to\infty}m\left( \{ x\in E:\sup\limits_{k\geqslant j}|f_k(x)|\geqslant\frac{1}{m} \} \right) \\&amp;= 0 \\\end{align}\]</span> 即有 <span class="math inline">\(\mathcal{M}(I)=0\)</span>, 故 <span class="math inline">\(\lim\limits_{k\to\infty}f_k(x)=0\)</span>, a.e. <span class="math inline">\(x\in E\)</span>. <strong>必要性</strong>: 由于 <span class="math inline">\(\lim\limits_{k\to\infty}f_k(x)=0\)</span>, a.e. <span class="math inline">\(x\in E\)</span>, 故 <span class="math inline">\(m(I)=0\)</span>. 而 <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, 总有 <span class="math display">\[\begin{align}\varlimsup\limits_{j\to\infty}m\left( \{ x\in E:\sup\limits_{k\geqslant j}|f_k(x)|\geqslant\epsilon \} \right)&amp;\geqslant \varlimsup\limits_{j\to\infty}m\left(\bigcup\limits_{k=j}^\infty  \{ x\in E:|f_k(x)|\geqslant\frac{\epsilon}{2} \} \right) \\&amp;= m\left(\bigcap\limits_{j=1}^\infty \bigcup\limits_{k=j}^\infty \{ x\in E:|f_k(x)|\geqslant\frac{\epsilon}{2} \} \right) \\&amp;\leqslant m(I) \\&amp; =0 \\\end{align}\]</span> <strong>综上</strong>: <span class="math inline">\(\lim\limits_{k\to\infty}f_k(x)=0,~\text{a.e.}~x\in E\Longleftrightarrow\forall~\epsilon&gt;0,~\lim\limits_{k\to\infty}m( \{ x\in E:\sup\limits_{k\geqslant j} \{ |f_k(x)| \} \geqslant\epsilon \} )=0\)</span>.</p><h3 id="习题3-第一组-7">习题3 第一组 7</h3><blockquote><p>设 <span class="math inline">\(f(x),f_1(x),f_2(x),\cdots\)</span> 是 <span class="math inline">\([a,b]\)</span> 上几乎处处有限的可测函数, 且有 <span class="math display">\[\lim\limits_{k\to\infty}f_k(x)=f(x),\quad\text{a.e.}~x\in[a,b],\]</span> 试证明 <span class="math inline">\(\exists~E_n\subset[a,b]~(n=1,2,\cdots)\)</span>, s.t. <span class="math inline">\(m\left([a,b]\backslash\bigcup\limits_{n=1}^\infty E_n\right)=0\)</span>, 而 $ { f_k(x) } $ 在每个 <span class="math inline">\(E_n\)</span> 上一致收敛于 <span class="math inline">\(f(x)\)</span>.</p></blockquote><p><strong>证明</strong>: 由Egorov定理, <span class="math inline">\(\forall~n\)</span>, <span class="math inline">\(\exists~E_n\subset[a,b]\)</span>, s.t. <span class="math inline">\(m([a,b]\backslash E_n)\leqslant\frac{1}{n}\)</span>, 且在 <span class="math inline">\(E_n\)</span> 上, <span class="math inline">\(f_k(x)\rightrightarrows f(x)\)</span>. 又有 <span class="math display">\[\begin{align}m\left([a,b]\backslash\bigcup\limits_{n=1}^\infty E_n\right)&amp;= m\left(\bigcap_{n=1}^\infty ([a,b]\backslash E_n)\right) \\&amp;\leqslant \lim\limits_{n\to\infty}([a,b]\backslash E_n) \\&amp;\leqslant \lim\limits_{n\to\infty}\frac{1}{n}=0.\\\end{align}\]</span> 原命题得证.</p><h2 id="年05月12日">2017年05月12日</h2><h3 id="习题4-第一组-1">习题4 第一组 1</h3><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 是 <span class="math inline">\(E\subset\mathbf{R}^n\)</span> 上几乎处处大于零的可测函数, 且满足 <span class="math inline">\(\int_Ef(x){\rm d}x=0\)</span>, 试证明 <span class="math inline">\(m(E)=0\)</span>.</p></blockquote><p><strong>证明</strong>: <strong>反证法</strong> 假设 <span class="math inline">\(m(E)&gt;0\)</span>, 记 $E_n= { xE:f(x)&gt; } $, 并令 <span class="math inline">\(F=\bigcup\limits_{n=1}^\infty E_n\)</span>, 则由 <span class="math inline">\(E=(E\backslash F)\cup F\)</span> 且 <span class="math inline">\(m(E\backslash F)=0\)</span> 可知, <span class="math inline">\(\exists n_0\)</span>, s.t. <span class="math inline">\(m(E_{n_0})&gt;0\)</span>. 于是有 <span class="math inline">\(0=\int_Ef(x){\rm d}x\geqslant\int_{E_{n_0}}f(x){\rm d}x\geqslant\frac{1}{n_0}m(E_{n_0})\)</span>, 得 <span class="math inline">\(m(E_{n_0})=0\)</span>, 矛盾. 于是 <span class="math inline">\(m(E)=0\)</span>.</p><h3 id="习题4-第一组-4">习题4 第一组 4</h3><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 是 <span class="math inline">\(\mathbf{R}^1\)</span> 上的非负可测函数, 令 <span class="math display">\[F(x)=\int\nolimits_{(-\infty,x]}f(t)dt,\quad x\in\mathbf{R}^1.\]</span> 若 <span class="math inline">\(F\in L(\mathbf{R}^1)\)</span>, 试证明 <span class="math inline">\(\int\nolimits_{\mathbf{R}^1}f(x)dx=0\)</span>.</p></blockquote><p><strong>证明</strong>: 由于 <span class="math inline">\(F\in L(\mathbf{R}^1)\)</span>, 故 <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, <span class="math inline">\(\exists~N\)</span> s.t. <span class="math inline">\(\int\nolimits_{ \{ x:|x|&gt;N \} }F(x)dx&lt;\epsilon\)</span>. 又由于 <span class="math inline">\(f(x)\geqslant0\)</span>, 故 <span class="math inline">\(F(x)\)</span> 随 <span class="math inline">\(x\)</span> 递增, 且 <span class="math inline">\(\lim\limits_{x\to\infty}F(x)=\int\nolimits_{\mathbf{R}^1}f(x)dx\)</span>. 于是 <span class="math inline">\(\forall~y&gt;N\)</span>, 均有: <span class="math display">\[F(y)=\int\nolimits_{y}^{y+1}F(y)dx\leqslant\int\nolimits_y^{y+1}F(x)dx\leqslant\int\nolimits_{ \{ x:|x|&gt;N \} }F(x)dx&lt;\epsilon\]</span>, 于是 <span class="math inline">\(\lim\limits_{y\to\infty}F(y)=0\)</span>. 即 <span class="math inline">\(\int\nolimits_{\mathbf{R}^1}f(x)dx=0\)</span>.</p><h3 id="习题4-第一组-5">习题4 第一组 5</h3><blockquote><p>设 <span class="math inline">\(f_k(x)~(k=1,2,\cdots)\)</span> 是 <span class="math inline">\(\mathbf{R}^n\)</span> 上非负可积函数列, 若对于任何一可测集 <span class="math inline">\(E\subset\mathbf{R}^n\)</span>, 总有 <span class="math display">\[\int\nolimits_Ef_k(x)dx\leqslant\int\nolimits_Ef_{k+1}(x)dx,\]</span> 试证明 <span class="math display">\[\lim\limits_{k\to\infty}\int\nolimits_Ef_k(x)dx=\int\nolimits_E \lim\limits_{k\to\infty} f_k(x)dx.\]</span></p></blockquote><p><strong>证明</strong>: 取 <span class="math inline">\(E_k= \{ x:f_k(x)&gt;f_{k+1}(x) \} ~(k=1,2,\cdots)\)</span>, 则由条件有 <span class="math inline">\(\int\nolimits_{E_k}(f_k(x)-f_{k+1}(x))dx\leqslant0\)</span>. 又由 <span class="math inline">\(E_k\)</span> 的定义可知 <span class="math inline">\(f_k(x)-f_{k+1}(x)&gt;0\)</span>, 故 <span class="math inline">\(m(E_k)=0\)</span>, <span class="math inline">\(\forall~k\)</span>. 于是 <span class="math inline">\(m\left(\bigcup\limits_{k=1}^\infty E_k \right)=0\)</span>, 故 <span class="math inline">\(f_k(x)\)</span> 在 <span class="math inline">\(E\)</span> 上几乎处处满足Levi定理的使用条件, 故在 <span class="math inline">\(E\)</span> 上由Levi定理有 <span class="math display">\[\lim\limits_{k\to\infty}\int\nolimits_Ef_k(x)dx=\int\nolimits_E \lim\limits_{k\to\infty} f_k(x)dx.\]</span></p><h2 id="年06月07日">2017年06月07日</h2><h3 id="习题4-第一组-7">习题4 第一组 7</h3><blockquote><p>假设有定义在 <span class="math inline">\(\mathbf{R}^n\)</span> 上的函数 <span class="math inline">\(f(x)\)</span>, 如果对于 <span class="math inline">\(\forall~\epsilon&gt;0\)</span>, <span class="math inline">\(\exists~g,h\in L(\mathbf{R}^n)\)</span>, s.t. <span class="math inline">\(g(x)\leqslant f(x)\leqslant h(x)~(x\in\mathbf{R}^n)\)</span>, 并且 <span class="math inline">\(\int\nolimits_{\mathbf{R}^n}[h(x)-g(x)]dx&lt;\epsilon\)</span>, 试证明 <span class="math inline">\(f\in L(\mathbf{R}^n).\)</span></p></blockquote><p><strong>证明</strong>: 由条件, 取可积函数列 <span class="math inline">\(g_k(x),h_k(x)\)</span>, s.t. <span class="math inline">\(g_k(x)\leqslant f(x)\leqslant h_k(x)\)</span> 且 <span class="math inline">\(\int\nolimits_{\mathbf{R}^n}[h_k(x)-g_k(x)]dx&lt;\frac{1}{k}\)</span>. 故 $ { h_k(x)-g_k(x) } $ 为非负可积函数列. 又由于 <span class="math inline">\(\lim\limits_{k\to\infty}\int\nolimits_{\mathbf{R}^n}[h_k(x)-g_k(x)]dx=0\)</span>, 故 <span class="math inline">\(h_k(x)-g_k(x)\)</span> 依测度收敛于0. 故由Riesz定理, 存在子列 $ { h_{k_j}-g_{k_j} } $, s.t. <span class="math inline">\(\lim\limits_{j\to\infty}[h_{k_j}(x)-g_{k_j}(x)]=0\)</span>, a.e. <span class="math inline">\(x\in\mathbf{R}^n\)</span>. 又 <span class="math inline">\(|f(x)|\leqslant \max \{ |g_k(x)|,|h_k(x)| \} \leqslant|g_k(x)|+|h_k(x)|\)</span>. 故 <span class="math inline">\(|f|\in L(\mathbf{R}^n)\)</span>, 故 <span class="math inline">\(f\in L(\mathbf{R}^n)\)</span>.</p><h3 id="习题4-第一组-8">习题4 第一组 8</h3><blockquote><p>设 $ { E_k } $ 是 <span class="math inline">\(\mathbf{R}^n\)</span> 中测度有限的可测集列, 且有 <span class="math display">\[\lim\limits_{k\to\infty}\int\nolimits_{\mathbf{R}^n}|\chi_{E_k}(x)-f(x)|=0,\]</span> 试证明存在可测集 <span class="math inline">\(E\)</span> s.t. <span class="math inline">\(f(x)=\chi_E(x)\)</span>, a.e. <span class="math inline">\(x\in\mathbf{R}^n\)</span>.</p></blockquote><p><strong>证明</strong>: 由条件, <span class="math inline">\(\chi_{E_k}(x)\)</span> 依 <span class="math inline">\(L^1\)</span> 范数收敛于 <span class="math inline">\(f(x)\)</span>, 故 <span class="math inline">\(\chi_{E_k}(x)\)</span> 依测度收敛于 <span class="math inline">\(f(x)\)</span>. 由Riesz定理, 存在其几乎处处收敛于 <span class="math inline">\(f(x)\)</span> 的子列 <span class="math inline">\(\chi_{E_{k_i}}(x)\)</span>. 令 <span class="math inline">\(E_{k_i}\to E\)</span>, 则应有 <span class="math inline">\(f(x)=\chi_E(x)\)</span>, a.e. <span class="math inline">\(x\in\mathbf{R}^n\)</span>.</p><h2 id="年06月20日">2017年06月20日</h2><h3 id="习题4-第一组-13">习题4 第一组 13</h3><blockquote><p>设 <span class="math inline">\(f\in L(\mathbf{R}^1),p&gt;0\)</span>, 试证明 <span class="math display">\[\lim\limits_{n\to\infty}n^{-p}f(nx)=0,\quad\text{a.e.}~x\in\mathbf{R}^1.\]</span></p></blockquote><p><strong>证明</strong>: 考虑级数 <span class="math inline">\(\sum\limits_{n=1}^\infty|n^{-p}f(nx)|\)</span>, 则 <span class="math inline">\(n^{-p}f(nx)\)</span> 为非负可测函数, 即 <span class="math display">\[\begin{align}\int\nolimits_{\mathbf{R}^1}\left(\sum\limits_{n=1}^\infty|n^{-p}f(nx)|\right)dx&amp;= \sum\limits_{n=1}^\infty\int\nolimits_{\mathbf{R}^1}|n^{-p}f(nx)|dx \\&amp;= \sum\limits_{n=1}^\infty\int\nolimits_{\mathbf{R}^1}|n^{-p-1}f(nx)|d(nx) \\&amp;= \sum\limits_{k=1}^\infty\frac{1}{n^{p+1}}\cdot\int\nolimits_{\mathbf{R}^1}|f(x)|dx \\\end{align}\]</span> 由于 <span class="math inline">\(1+p&gt;1\)</span>, 故 <span class="math inline">\(\sum\limits_{k=1}^\infty\frac{1}{n^{p+1}}\)</span> 收敛, 又由于 <span class="math inline">\(\int\nolimits_{\mathbf{R}^1}|f(x)|dx\)</span> 有限, 故 <span class="math inline">\(\int\nolimits_{\mathbf{R}^1}\left(\sum\limits_{n=1}^\infty|n^{-p}f(nx)|\right)dx\)</span> 有限, 故 <span class="math inline">\(\sum\limits_{n=1}^\infty|n^{-p}f(nx)|\)</span> 有限, 即有 <span class="math inline">\(\lim\limits_{n\to\infty}n^{-p}f(nx)=0\)</span>, a.e. <span class="math inline">\(x\in\mathbf{R}^1\)</span>.</p><h3 id="习题4-第一组-21">习题4 第一组 21</h3><blockquote><p>(依测度收敛的Fatou引理) 设 $ { f_k(X) } $ 是 <span class="math inline">\(E\)</span> 上依测度收敛于 <span class="math inline">\(f(x)\)</span> 的非负可测函数列, 试证明 <span class="math display">\[\int\nolimits_E f(x)dx\leqslant \varliminf\limits_{k\to\infty}\int\nolimits_E f_k(x)dx.\]</span></p></blockquote><p><strong>证明</strong>: 由Riesz定理, 存在子列 $ { f_{k_i}(x) } $, s.t. <span class="math inline">\(\lim\limits_{i\to\infty}f_{k_i}(x)=f(x)\)</span>, a.e. <span class="math inline">\(x\in\mathbf{R}^n\)</span>. 故由Fatou引理, 有: <span class="math display">\[\begin{align}\int\nolimits_Ef(x)dx &amp;= \int\nolimits_E \lim\limits_{i\to\infty}f_{k_i}(x)dx \\&amp;= \int\nolimits_E \varliminf\limits_{i\to\infty}f_{k_i}(x)dx \\&amp;\leqslant \varliminf\limits_{i\to\infty}\int\nolimits_{E} f_{k_i}(x)dx \\&amp;= \varliminf\limits_{k\to\infty}\int\nolimits_E f_k(x)dx.\\\end{align}\]</span> 即 <span class="math inline">\(\int\nolimits_E f(x)dx\leqslant \varliminf\limits_{k\to\infty}\int\nolimits_E f_k(x)dx\)</span>. <strong>这个证法可能有问题, 慢慢解决.</strong></p><h3 id="习题4-第一组-23">习题4 第一组 23</h3><blockquote><p>设 <span class="math inline">\(f\in L(\mathbf{R}^n)\)</span>, <span class="math inline">\(f_k\in L(\mathbf{R}^n)~(k=1,2,\cdots)\)</span>, 且对任一可测集 <span class="math inline">\(E\subset\mathbf{R}^n\)</span>, 均有 <span class="math display">\[\int\nolimits_Ef_k(x)dx\leqslant \int\nolimits_Ef_{k+1}(x)dx~(k=1,2,\cdots),\]</span> <span class="math display">\[\lim\limits_{k\to\infty}\int\nolimits_Ef_k(x)dx=\int\nolimits_Ef(x)dx,\]</span> 试证明 <span class="math inline">\(\lim\limits_{k\to\infty}f_k(x)=f(x)\)</span>, a.e. <span class="math inline">\(x\in\mathbf{R}^n\)</span>.</p></blockquote><p><strong>证明</strong>: 易由 <span class="math inline">\(\int\nolimits_Ef_k(x)dx\leqslant \int\nolimits_Ef_{k+1}(x)dx\)</span> 知 <span class="math inline">\(f_k(x)\leqslant f_{k+1}(x)\)</span>, a.e. <span class="math inline">\(x\in\mathbf{R}^n\)</span>. 于是 $ { f_k(x)-f_1(x) { $ 为非负渐升列, 由Levi定理, 有 <span class="math display">\[\begin{align}\int\nolimits_Ef(x)dx-\int\nolimits_Ef_1(x)dx&amp;= \lim\limits_{k\to\infty}\int\nolimits_Ef_k(x)dx-\int\nolimits_Ef_1(x)dx \\&amp;= \lim\limits_{k\to\infty}\int\nolimits_E\left(f_k(x)-f_1(x)\right)dx \\&amp;= \int\nolimits_E\lim\limits_{k\to\infty}(f_k(x)-f_1(x))dx \\&amp;= \int\nolimits_E\lim\limits_{k\to\infty}f_k(x)dx-\int\nolimits_Ef_1(x)dx \\\end{align}\]</span> 即 <span class="math inline">\(\int\nolimits_Ef(x)dx=\int\nolimits_E\lim\limits_{k\to\infty}f_k(x)dx\)</span>, 故 <span class="math inline">\(\lim\limits_{k\to\infty}f_k(x)=f(x)\)</span>, a.e. <span class="math inline">\(x\in\mathbf{R}^n\)</span>.</p><h2 id="年06月21日">2017年06月21日</h2><h3 id="习题4-第一组-30">习题4 第一组 30</h3><blockquote><p>计算下列积分: (1) <span class="math inline">\(\int\nolimits_{x&gt;0}\int\nolimits_{y&gt;0}\frac{dxdy}{(1+y)(1+x^2Y)}\)</span>;　　　(2)<span class="math inline">\(\int\nolimits_0^\infty\frac{\ln x}{x^2-1}dx\)</span></p></blockquote><p><strong>解答</strong>: (1) 由Tonelli定理, <span class="math inline">\(\int\nolimits_{x&gt;0}\int\nolimits_{y&gt;0}\frac{dxdy}{(1+y)(1+x^2y)}=\int\nolimits_{x&gt;0}\int\nolimits_{y&gt;0}\frac{\sqrt{y}dx}{1+x^2y}\frac{dy}{\sqrt{y}(1+y)}=2\int\nolimits_{x&gt;0}\frac{dx}{1+x^2}\int\nolimits_{y&gt;0}\frac{dy}{1+y^2}=\frac{\pi^2}{2}\)</span>. (2) <span class="math inline">\(\frac{\pi^2}{2}=\int\nolimits_{x&gt;0}\frac{1}{x^2-1}\int\nolimits_{y&gt;0}\left(\frac{x^2}{1+x^2y}-\frac{1}{1+y}\right)dxdy=\int\nolimits_{x&gt;0}\frac{1}{x^2-1}\left(\ln \frac{1+x^2y}{1+y}|_0^\infty\right)dx=2\int\nolimits_0^\infty\frac{\ln x}{x^2-1}dx\)</span>, 故 <span class="math inline">\(\int\nolimits_0^\infty\frac{\ln x}{x^2-1}dx=\frac{\pi^2}{2}\)</span>.</p>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实变函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo与Mathjax的冲突及（部分）解决</title>
      <link href="/2017/03/08/Hexo%E4%B8%8EMathjax%E7%9A%84%E5%86%B2%E7%AA%81%E5%8F%8A%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89%E8%A7%A3%E5%86%B3/"/>
      <content type="html"><![CDATA[<h2 id="问题出现的原因蛋疼的转义">问题出现的原因：蛋疼的转义</h2><p>Markdwon本身的特殊符号与Latex中的符号会出现冲突：</p><table><thead><tr class="header"><th style="text-align: center;">符号</th><th style="text-align: center;">Markdown中意义</th><th style="text-align: center;">LaTeX中意义</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>_</code></td><td style="text-align: center;">斜体</td><td style="text-align: center;">下标</td></tr><tr class="even"><td style="text-align: center;"><code>\\</code></td><td style="text-align: center;">转义为<code>\</code></td><td style="text-align: center;">换行</td></tr><tr class="odd"><td style="text-align: center;"><code>*</code></td><td style="text-align: center;">加粗</td><td style="text-align: center;">无变化</td></tr></tbody></table><p>这些问题是存在于Markdown语法中的，然而辣鸡Hexo默认使用marked.js解析markdown，于是表示斜体的<code>_</code>会被处理为<code>&lt;em&gt;</code>标签，如<code>x_i</code>在开始被渲染的时候，处理为<code>x&lt;em&gt;i&lt;/em&gt;</code>，这个时候Mathjax就无法将其渲染成下标了。 类似的问题还有很多，比如<code>*</code>和<code>\</code>字符。 所以从根本上来讲，是辣鸡Hexo使用的Markdown引擎造成的。。垃圾Hexo。。</p><h2 id="解决方案一手动转义">解决方案一：手动转义</h2><p>手动转义的意思很明确，你不是把我的<code>\\</code>转成了<code>\</code>么？那好，我输<code>\\\\</code>还不行么？你总得给我转成<code>\\</code>了吧？ 同理，在下标的地方写成<code>\_</code>，也同样能够避免这个问题。 听起来很棒耶，但手动转义的缺点其实是很明显的：无法移植。你辛辛苦苦改了很久的文章也许往其他平台上面一贴就面目全非了，因为大多数的Markdown解释引擎都没有这个毛病（垃圾Hexo）<del>这你不就傻逼了么</del>，所以手动转义需谨慎。。</p><h2 id="解决方案二保护公式">解决方案二：保护公式</h2><p>另一个听起来很棒的想法就是用代码环境来保护公式，并且在解析的时候，只要发现<code>$...$</code>字样就按照公式来解析。 听起来不错耶！既解决了转义的问题，又不会破坏兼容性。但是这种方法也会带来一个很严重的问题：如果你要插入的某段代码中也含有<code>$...$</code>的字样，就会出现错误。。 该方法详见 <a href="http://liam0205.me/2015/09/09/fix-conflict-between-mathjax-and-markdown/" target="_blank" rel="noopener">解决 MathJax 与 Markdown 的冲突</a>。</p><h2 id="解决方案三更换引擎">解决方案三：更换引擎</h2><p>既然这个marked.js这么烂，我们干脆把它换掉好了，简单粗暴没有后患。替代marked.js的方案有很多，只以<code>Hexo-renderer-pandoc</code>为例：</p><ul><li>安装Pandoc，官网提供了deb安装包，按照官网教程就可以安装完成。</li><li>卸载Hexo默认的markd,再安装新的:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall Hexo-renderer-marked --save</span><br><span class="line">npm install Hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure><p>这种解决方案的一点小瑕疵是语法与Markdown有很小的差别，需要注意一下。</p><h2 id="解决方案四修改引擎">解决方案四：修改引擎</h2><p>这个marked.js虽然烂，可是你说不定觉得它还是可以抢救一下的。。按照如下方法进行抢救也能一定程度上解决问题：</p><ul><li>找到<code>marked.js</code>，路径为<code>\nodes_modules/marked/lib/marked.js</code>；</li><li>将marked.js中的如下第一行代码改为第二行以去掉<code>\</code>的转义：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">escape: /^\\([\\`*&#123;&#125;\[\]()#+\-.!_&gt;])/,</span><br><span class="line">escape: /^\\([`*&#123;&#125;\[\]()# +\-.!_&gt;])/,</span><br></pre></td></tr></table></figure><ul><li>将marked.js中的如下第一行代码改为第二行以更改<code>&lt;em&gt;</code>符号：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br><span class="line">em:/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><ul><li><a href="https://segmentfault.com/a/1190000007261752" target="_blank" rel="noopener">SegmentFault——Hexo下mathjax的转义问题</a></li><li><a href="http://lukang.me/2014/mathjax-for-hexo.html" target="_blank" rel="noopener">空念远兮——在 Hexo 中完美使用 Mathjax 输出数学公式</a></li></ul><table><tbody><tr class="odd"><td><strong>垃圾Hexo！！！</strong></td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数学系转专业考试题及解答不完全版（2015.04）</title>
      <link href="/2017/03/08/%E6%95%B0%E5%AD%A6%E7%B3%BB%E8%BD%AC%E4%B8%93%E4%B8%9A%E8%80%83%E8%AF%95%E9%A2%98%E5%8F%8A%E8%A7%A3%E7%AD%94%E4%B8%8D%E5%AE%8C%E5%85%A8%E7%89%88%EF%BC%882015-04%EF%BC%89/"/>
      <content type="html"><![CDATA[<h2 id="几句废话">几句废话</h2><p>又是一年转专业的时候，转专业这件事也又一次被提起。最初的转专业想法是在刚入校形成的，经历了一些波折之后最终确定了转专业的事情，于是在2015年的4月（其实也可能是3月，记不清了）参加了转专业的考试。 笔试结果出来之后得知洲洲没有通过笔试，洲洲希望我能整理一份题目和解答给他（或许是留作纪念）。但由于考完之后没有很及时地整理，导致了个别问题的遗漏（至多两个）。 整理完之后将纸质版交给了洲洲，为了保存一下相关内容，我便将该文档拍照发到了<a href="https://tieba.baidu.com/lzcwr" target="_blank" rel="noopener">我的贴吧：lzcwr吧</a>里边。但是由于我当时过于naive，还不懂得“图像压缩”的问题，便直接将画质很差的图像上传到了网上。。导致帖子里边的图片全部是AV画质。。有兴趣可以点击<a href="https://tieba.baidu.com/p/3726485475" target="_blank" rel="noopener">原帖地址</a>看看。。现在想起来有点后悔，于是决定重新整理一份（在较大程度上能还原原试卷）。</p><h2 id="试题">试题</h2><ol type="1"><li>设数列 $ &amp;#123; x_n &amp;#125; $ 满足 <span class="math inline">\(x_n&gt;0\)</span> ，且 <span class="math inline">\(\forall n\in \mathbb{N}\)</span> ，都有 <span class="math inline">\(x_{n+1}+\frac{1}{x_n}&lt;2\)</span> ，求证：<span class="math display">\[\lim_{n\to\infty}x_n=1\]</span></li><li>若函数 <span class="math inline">\(f(x)\)</span> 满足 <span class="math inline">\(f(x+y)=f(x)\times f(y)\)</span> ，且 <span class="math inline">\(f(0)=1\)</span> ， <span class="math inline">\(f&#39;(0)=2\)</span> ，求 <span class="math inline">\(f(x)\)</span> 的表达式.</li><li>求极限：<span class="math display">\[\lim\limits_{x\to0}\frac{\sin x^6}{x^2-\arcsin x^2}\]</span></li><li>设 <span class="math inline">\(f(x)=x^3\sin2x\)</span>，求：<span class="math inline">\(f^{(10)}(0)\)</span>.</li><li>求积分：<span class="math display">\[\int_0^{\frac{\pi}{4}}\frac{x\sec^2x{\rm d}x}{(1+\tan x)^2}\]</span></li><li>求证：<span class="math display">\[\frac{2}{3}n\sqrt{n}&lt;1+\sqrt{2}+\sqrt{3}+\cdots+\sqrt{n}&lt;\frac{4n+3}{6}\sqrt{n}\]</span></li><li>令 <span class="math inline">\(f(x)=xe^{-x}\)</span>，设 <span class="math inline">\(f(x)\)</span> 有极值点 <span class="math inline">\((x_1,y_1)\)</span>，拐点 <span class="math inline">\((x_2,y_2)\)</span>：<ul><li>求 <span class="math inline">\((x_1,y_1)\)</span> 和 <span class="math inline">\((x_2,y_2)\)</span>.</li><li>求函数与 <span class="math inline">\(x\)</span> 轴在 <span class="math inline">\(x=x_1\)</span> 与 <span class="math inline">\(x=x_2\)</span> 之间围成的面积.</li></ul></li><li>令 <span class="math inline">\(f(x)\)</span> 为定义在 <span class="math inline">\((-\infty,+\infty)\)</span> 上的函数，且对 <span class="math inline">\(\forall x\in\mathbb{R}\)</span>，均有 <span class="math inline">\(|f(x)|\leq M_1\)</span>，<span class="math inline">\(|f&#39;&#39;(x)|\leq M_2\)</span>，求证：<span class="math display">\[|f&#39;(x)|\leq \sqrt{2M_1M_2}\]</span></li></ol><h2 id="解答">解答</h2><p>因为我比较懒。。一些简单题目就不做详细的解答了。。一定要看详细解答的可以去原帖看av画质的图片，应该能看懂。。（别问我为什么不用有序列表）</p><p>1.由条件，<span class="math inline">\(x_{n+1}-x_n&lt;2-(x_n+\frac{1}{x_n})\)</span>，而由均值不等式有 <span class="math inline">\(x_n+\frac{1}{x_n}\geq 2\)</span>，于是 <span class="math inline">\(x_{n+1}-x_n&lt;0\)</span>，即数列 $ &amp;#123; x_n &amp;#125; $递减。于是数列 $ &amp;#123; x_n &amp;#125; $单调有界，有极限。由 <span class="math inline">\(x_{n+1}+\frac{1}{x_n}&lt;2\)</span> 易得结论；</p><p>2.两边同时取对数即变为 Cauchy 方程 <span class="math inline">\(g(x+y)=g(x)+g(y)\)</span>，用 Cauchy 方法即可求解；</p><p>3.换元 <span class="math inline">\(y=x^2\)</span> 后将分子分母分别泰勒展开至 <span class="math inline">\(y^3\)</span> 即可得答案为 <span class="math inline">\(-6\)</span>；</p><p>4.这个题不会做自觉面壁；</p><p>5.无脑积分：md劳资怎么改都generate不了，只好截个图算了。。</p><figure><img src="http://static.zybuluo.com/lzcwr/xqwm7m3zaqlzycg19g7gpg6q/image_1ban69j2711o8rs1c56bip16on9.png" alt="image_1ban69j2711o8rs1c56bip16on9.png-56.3kB"><figcaption>image_1ban69j2711o8rs1c56bip16on9.png-56.3kB</figcaption></figure><p>6.一方面考虑 <span class="math inline">\(f(x)=\sqrt{x}\)</span> 在 <span class="math inline">\([0,n]\)</span> 的积分，有 <span class="math inline">\(\sum_{i=1}^{n}\sqrt{i}&gt;\int_0^n\sqrt{x}{\rm d}x=\frac{2}{3}n\sqrt{n}\)</span>；另一边不等式只需给右边做差，证明 <span class="math inline">\(\sqrt{k}&lt;\frac{4k+3}{6}\sqrt{k}-\frac{4k-1}{6}\sqrt{k-1}\)</span> 即可（不会做的自觉面壁）；</p><p>7.这个题不会做的继续面壁吧；</p><p>8.考场上没做出来，后来问会了但是现在也不记得了……比较难，这样的题考场上做不出来可以理解。</p><p>祝要转专业的各位转专业成功！</p><hr><p>不能忍。。存一下第五题的公式代码……问题解决了再贴上去……</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;align&#125;</span><br><span class="line">\int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;\frac&#123;x\sec^2x&#125;&#123;(1+\tan x)^2&#125;&#123;\rm d&#125;x &amp;= \int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;\frac&#123;x&#125;&#123;(1+\tan x)^2&#125;&#123;\rm d&#125;(1+\tan x) \\</span><br><span class="line"> &amp;= -\int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;x&#123;\rm d&#125;(\frac&#123;1&#125;&#123;1+\tan x&#125;) \\</span><br><span class="line"> &amp;= -(\frac&#123;x&#125;&#123;1+\tan x&#125;\Big|_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;-\int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;\frac&#123;&#123;\rm d&#125;x&#125;&#123;1+\tan x&#125;) \\</span><br><span class="line"> &amp;= -\frac&#123;\pi&#125;&#123;8&#125;+\int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;\frac&#123;\cos x&#125;&#123;\sin x+\cos x&#125;&#123;\rm d&#125;x \\</span><br><span class="line"> &amp;= -\frac&#123;\pi&#125;&#123;8&#125;+\int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;\frac&#123;\frac&#123;1&#125;&#123;2&#125;(\cos x+\sin x)+\frac&#123;1&#125;&#123;2&#125;(\cos x-\sin x)&#125;&#123;\sin x+\cos x&#125;&#123;\rm d&#125;x \\</span><br><span class="line"> &amp;= -\frac&#123;\pi&#125;&#123;8&#125;+\int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;\frac&#123;1&#125;&#123;2&#125;&#123;\rm d&#125;x+\frac&#123;1&#125;&#123;2&#125;\int_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125;\frac&#123;&#123;\rm d&#125;(\sin x+\cos x)&#125;&#123;\sin x+\cos x&#125; \\</span><br><span class="line"> &amp;= \frac&#123;1&#125;&#123;2&#125;\ln(\sin x+\cos x)\Big|_0^&#123;\frac&#123;\pi&#125;&#123;4&#125;&#125; \\</span><br><span class="line"> &amp;= \frac&#123;1&#125;&#123;2&#125;\ln\sqrt&#123;2&#125; = \frac&#123;\ln2&#125;&#123;4&#125;</span><br><span class="line">\end&#123;align&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 各种试卷 </tag>
            
            <tag> 数学分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构——树状数组 Binary Indexed Tree</title>
      <link href="/2017/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%20Binary%20Indexed%20Tree/"/>
      <content type="html"><![CDATA[<h2 id="树状数组概述">树状数组概述</h2><p>树状数组(binary indexed tree)能够高效地获取数组的子段和。 一般来说，树状数组可以用于解决数组子段和的动态查询或高效查询问题。</p><blockquote><p>传统的数组单点修改的复杂度为<span class="math inline">\(~O(1)~\)</span>，查询子段和的复杂度为<span class="math inline">\(~O(n)~\)</span>。 而树状数组的修改和查询子段和复杂度均为<span class="math inline">\(~O(\log n)~\)</span>。 所以在多组查询或动态查询时，用树状数组可以有效减小耗时，提高程序效率。</p></blockquote><h2 id="树状数组的操作">树状数组的操作</h2><h3 id="构建">构建</h3><p>从已知数组构建树状数组就是把线性的数组变成一棵树。那么，树状数组是如何把线性结构的数组变成一棵树的呢？以下以一个长度为8的数组为例：</p><p>原始数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[8]</span><br></pre></td></tr></table></figure><p>在修改和查询子段和时，很容易想到一种类似二分的想法来构建一棵树状的数组来保存原数组的所有信息。 用这种方法构造出的数组具有如下的结构（图片来自<a href="http://baike.baidu.com/link?url=MWXznqHrg5WOaQXOilx_IgGzC_YzDNcwVqbMqltULN9YUIPgB75WQU2xpoIfPXsq7z21_2LSn3wILiRRZXC97xYZleNY6LkqUEIlsCsOLeUEamNkjYhEvMKisCmKMNXK" target="_blank" rel="noopener">百度百科-树状数组</a>）：</p><figure><img src="http://static.zybuluo.com/lzcwr/cygbcza2ann0629f6fanea4n/image_1b9ho5pkm1vdbnld1hkc551nji9.png" alt="image_1b9ho5pkm1vdbnld1hkc551nji9.png-86.1kB"><figcaption>image_1b9ho5pkm1vdbnld1hkc551nji9.png-86.1kB</figcaption></figure><p>这样的一棵树满足如下的条件：</p><ul><li><span class="math inline">\(C_1=A_1\)</span></li><li><span class="math inline">\(C_2=A_1+A_2\)</span></li><li><span class="math inline">\(C_3=A_3\)</span></li><li><span class="math inline">\(C_4=A_1+A_2+A_3+A_4\)</span></li><li><span class="math inline">\(C_5=A_5\)</span></li><li><span class="math inline">\(C_6=A_5+A_6\)</span></li><li><span class="math inline">\(C_7=A_7\)</span></li><li><span class="math inline">\(C_8=A_1+A_2+A_3+A_4+A_5+A_6+A_7+A_8\)</span></li></ul><p>从中可以发现，若结点的标号为<span class="math inline">\(~n~\)</span>，则该结点的求和区域长度为<span class="math inline">\(~2^k~\)</span>，此处的<span class="math inline">\(~k~\)</span>为<span class="math inline">\(~n~\)</span>的二进制表示的末尾<span class="math inline">\(~0~\)</span>的个数。 由于<span class="math inline">\(~n~\)</span>号结点求和区域的最末一位一定是<span class="math inline">\(~A_n~\)</span>，于是有：</p><p><span class="math display">\[ C[n] = \sum_{i = n - 2^k + 1}^{n} A[i] = A[n-2^k+1]+A[n-2^k+1]+\cdots+A[n-1]+A[n] \]</span></p><p>于是构建树状数组的问题就变成了如何求<span class="math inline">\(~2^k~\)</span>的问题。 利用位运算的性质，有一个非常漂亮的解答（<span class="math inline">\(\oplus\)</span>表示异或）：</p><p><span class="math display">\[2^k=n\&amp;(n\oplus (n-1))=n\&amp;(-n)\]</span></p><p>这就是树状数组构建的核心：<code>lowbit()</code>函数，代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int lowbit(int x)   </span><br><span class="line">&#123;   </span><br><span class="line">    return x &amp; (-x);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单点修改">单点修改</h3><p>树状数组的单点修改过程很简单：修改需要修改的点，然后沿着树上的路径把受到牵连的点一并修改。 由于树高为<span class="math inline">\(~O(\log n)~\)</span>，故复杂度<span class="math inline">\(~O(\log n)~\)</span>。 示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void add(int x, int y) // 在x位置上加上y</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = x; i &lt;= n; i += lowbit(i)) // 找到与x相关的所有位置</span><br><span class="line">        c[i] += y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求前n项和">求前<span class="math inline">\(~n~\)</span>项和</h3><p>求前<span class="math inline">\(~n~\)</span>项和时，由于在<span class="math inline">\(~C_n~\)</span>记录了下标从<span class="math inline">\(~n-lowbit(n)+1~\)</span>到<span class="math inline">\(~n~\)</span>的子段和，故可以直接在结果中加上<span class="math inline">\(~C_n~\)</span>，接下来只需要计算<span class="math inline">\(~C[n-lowbit(n)]~\)</span>的值。一直循环下去即可。 由于树高为<span class="math inline">\(~O(\log n)~\)</span>，故复杂度<span class="math inline">\(~O(\log n)~\)</span>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int sum(int x) // 前x项和</span><br><span class="line">&#123;</span><br><span class="line">    int ret(0);</span><br><span class="line">    for(int i = x; i &gt;= 1; i -= lowbit(i))</span><br><span class="line">        ret += c[i];</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维树状数组">二维树状数组</h2><p>其结构与普通的树状数组相同，只不过在求前<span class="math inline">\(~n~\)</span>项和时是从<span class="math inline">\(~(1,1)~\)</span>到<span class="math inline">\(~(x,y)~\)</span>求和。 示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int lowbit(int x)</span><br><span class="line">&#123;</span><br><span class="line">return x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line">void add(int x, int y, int val) // 将[x][y]的值增加val</span><br><span class="line">&#123;</span><br><span class="line">for(int i = x; i &lt; N; i += lowbit(i))</span><br><span class="line">for(int j = y; j &lt; N; j += lowbit(j))</span><br><span class="line">sum[i][j] += val;</span><br><span class="line">&#125;</span><br><span class="line">int sum(int x, int y) // 求以[1][1]为左上角端点,[x][y]为右下角端点的矩阵和</span><br><span class="line">&#123;</span><br><span class="line">int ret(0);</span><br><span class="line">for(int i = x; i &gt; 0; i -= lowbit(i))</span><br><span class="line">for(int j = y; j &gt; 0; j -= lowbit(j))</span><br><span class="line">ret += sum[i][j];</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树状数组的应用">树状数组的应用</h2><ul><li>动态查询子段和——HDU 1166 敌兵布阵；</li><li>求逆序数——HDU 1349 Minimum Inversion Number；</li></ul><h3 id="练习题目">练习题目</h3><ul><li>POJ 1195 Mobile phones</li><li>POJ 2481 Cows</li><li>POJ 2155 Matrix</li><li>POJ 3321 Apple Tree</li><li>HDU 1556 color the ball</li><li>POJ 2299 Ultra-QuickSort</li></ul><h3 id="参考资料">参考资料</h3><ul><li><a href="http://blog.csdn.net/matrix_reloaded/article/details/32101509" target="_blank" rel="noopener">Matrix_Reloaded——树状数组题目集</a></li><li><a href="http://dongxicheng.org/structure/binary_indexed_tree/" target="_blank" rel="noopener">董的博客——树状数组</a></li><li><a href="http://blog.csdn.net/x_iya/article/details/8943264" target="_blank" rel="noopener">晚晴小筑——树状数组学习笔记</a></li></ul>]]></content>
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构——平衡树 Treap</title>
      <link href="/2017/02/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%B9%B3%E8%A1%A1%E6%A0%91%20Treap/"/>
      <content type="html"><![CDATA[<h2 id="treap概述">Treap概述</h2><p>Treap是一种平衡二叉树，不过Treap会记录一个优先级（一般来说是随机生成），即Treap在以关键码构成二叉搜索树的同时，还会按照优先级的高低满足堆的性质，因此得名Treap（Tree + Heap）。 Treap不是二叉堆，二叉堆必须是完全二叉树，但Treap不必是。</p><p>对于每个结点，该结点的优先级不大于其所有孩子的优先级。Treap引入优先级的原因就是防止BST（二叉搜索树）退化成一条链，从而影响查询效率。</p><p>所以对于结点上的关键字来说，它是一颗BST，而对于结点上的优先级来讲，它是一个小顶堆。其平均查找长度为<span class="math inline">\(~O(\log n)~\)</span>。 Treap有插入、删除、旋转和查询等基本操作，进而可以实现查询第<span class="math inline">\(~k~\)</span>大和查询关键字<span class="math inline">\(~x~\)</span>排名等功能。</p><h2 id="treap的结构">Treap的结构</h2><p>Treap是一颗BST，所以Treap的每一个结点都需要记录一个关键字和两个儿子指针； Treap又是一个小顶堆，所以需要记录一个优先级。 结点的构建方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Treap_Node</span><br><span class="line">&#123;</span><br><span class="line">    Treap_Node *left, *right; // 儿子指针</span><br><span class="line">    int value, fix; // 值和优先级</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="treap的操作">Treap的操作</h2><h3 id="旋转">旋转</h3><p>Treap本身对于关键字的构建和二叉查找树相同，但为对优先级维持其最小堆的性质，需要对树的结构进行调整，称为旋转，其操作方式如下：</p><ul><li><strong>左旋</strong>：将子树的根结点旋转到其根的左子树位置，同时根节点的右子节点成为该子树的根；</li><li><strong>右旋</strong>：将子树的根结点旋转到其根的右子树位置，同时根节点的左子节点成为该子树的根。</li></ul><p>例如下面这两棵树（表示方法为<code>[关键字-优先级]</code>）可以互相对根结点旋转得到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      [<span class="number">4</span><span class="number">-3</span>]                       [<span class="number">2</span><span class="number">-1</span>]</span><br><span class="line">      /   \     ==== 左旋 ===&gt;    /   \</span><br><span class="line">   [<span class="number">3</span><span class="number">-1</span>] [<span class="number">5</span><span class="number">-5</span>]                 [<span class="number">1</span><span class="number">-2</span>] [<span class="number">4</span><span class="number">-3</span>]</span><br><span class="line">   /   \        &lt;=== 右旋 ====       /   \</span><br><span class="line">[<span class="number">1</span><span class="number">-2</span>] [<span class="number">2</span><span class="number">-4</span>]                       [<span class="number">3</span><span class="number">-4</span>] [<span class="number">5</span><span class="number">-5</span>]</span><br></pre></td></tr></table></figure><p>旋转的实例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Left_Rotate</span><span class="params">(Treap_Node *&amp;a)</span> <span class="comment">//左旋 节点指针一定要传递引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Treap_Node *b = a -&gt; right;</span><br><span class="line">  a -&gt; right = b -&gt; left;</span><br><span class="line">  b -&gt; left = a;</span><br><span class="line">  a = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Right_Rotate</span><span class="params">(Treap_Node *&amp;a)</span> <span class="comment">//右旋 节点指针一定要传递引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Treap_Node *b = a -&gt; left;</span><br><span class="line">  a -&gt; left = b -&gt; right;</span><br><span class="line">  b -&gt; right = a;</span><br><span class="line">  a = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用下标来压缩代码量，具体实现方法在后边的模板给出。</p><h3 id="插入">插入</h3><p>在Treap中插入元素的法则与在BST中插入的法则相同，但插入完成后可能会破坏堆的性质，所以插入完成后要进行旋转，具体方法如下：</p><ol type="1"><li>从根结点开始访问；</li><li>若当前结点为空，则直接插入，否则执行下一步；</li><li>递归访问左右子树：</li></ol><ul><li>若插入的关键字小于当前访问结点，则访问其左子树，若插入后左子结点的优先级小于当前访问结点的优先级，则对当前结点进行右旋；</li><li>若插入的关键字大于当前访问结点，则访问其右子树，若插入后右子结点的优先级小于当前访问结点的优先级，则对当前结点进行左旋；</li></ul><p>以下是一个例子：</p><p>先在Treap中按照BST的方法插入<code>[3-2]</code>结点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                                          [2-1]</span><br><span class="line">   [2-1]                                  /   \</span><br><span class="line">   /   \                               [1-3] [5-4]</span><br><span class="line">[1-3] [5-4]      ==== 插入[3-2] ===&gt;          /   \</span><br><span class="line">      /   \                      不平衡 =&gt; [4-5] [6-6]</span><br><span class="line">   [4-5] [6-6]                            /</span><br><span class="line">                                       [3-2]</span><br></pre></td></tr></table></figure><p>由于当前访问结点<code>[4-5]</code>的左子结点<code>[3-2]</code>的优先级小于当前结点的优先级，需要进行右旋操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   [2-1]                                [2-1]</span><br><span class="line">   /   \                                /   \</span><br><span class="line">[1-3] [5-4]                          [1-3] [5-4] &lt;= 不平衡</span><br><span class="line">      /   \      == 对[4-5]右旋 =&gt;          /   \</span><br><span class="line">   [4-5] [6-6]                           [3-2] [6-6]</span><br><span class="line">   /                                        \</span><br><span class="line">[3-2]                                      [4-5]</span><br></pre></td></tr></table></figure><p>至此<code>[3-2]</code>和<code>[4-5]</code>已经调整完毕，向上回溯发现<code>[5-4]</code>的左子结点<code>[3-2]</code>优先级低于<code>[5-4]</code>，故对<code>[5-4]</code>进行一次右旋操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   [2-1]                                [2-1]      </span><br><span class="line">   /   \                                /   \      </span><br><span class="line">[1-3] [5-4]                          [1-3] [3-2]   </span><br><span class="line">      /   \      == 对[5-4]右旋 =&gt;              \  </span><br><span class="line">   [3-2] [6-6]                                [5-4]</span><br><span class="line">       \                                      /   \      </span><br><span class="line">      [4-5]                                [4-5] [6-6]</span><br></pre></td></tr></table></figure><p>至此，整个树调整完毕，插入操作结束。</p><p>插入的示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Treap_Node *root;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Treap_Node *&amp;P, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!P) <span class="comment">// 找到位置，建立节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        P = <span class="keyword">new</span> Treap_Node;</span><br><span class="line">        P -&gt; value = value;</span><br><span class="line">        P -&gt; fix = rand(); <span class="comment">// 生成优先级</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(value &lt;= P -&gt; value)</span><br><span class="line">    &#123;</span><br><span class="line">        Treap_Insert(P -&gt; left, r);</span><br><span class="line">        <span class="keyword">if</span>(P -&gt; left -&gt; fix &lt; P -&gt; fix)</span><br><span class="line">            Right_Rotate(P); <span class="comment">// 左子结点优先级低，右旋</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Treap_Insert(P -&gt; right, r);</span><br><span class="line">        <span class="keyword">if</span>(P -&gt; right -&gt; fix &lt; P -&gt; fix)</span><br><span class="line">            Left_Rotate(P); <span class="comment">// 右子结点优先级低，左旋</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询">查询</h3><p>与BST相同的二分查找，查询复杂度为<span class="math inline">\(~O(\log n)~\)</span>。</p><h3 id="删除">删除</h3><p>Treap的删除是基于旋转操作的，很容易理解的便是，只需要将要删除的结点旋转为叶子结点，再执行删除，具体步骤如下：</p><ul><li>先在Treap中找到该结点，则有两种情况分述如下；</li></ul><ol type="1"><li>该节点为叶节点或链节点；</li><li>该节点有两个非空子节点；</li></ol><ul><li>针对情况1，若该节点有非空子结点，则用非空子节点代替该结点，否则用空节点代替该结点，然后删除该结点；</li><li>针对情况2，要先通过旋转使该结点使之可以直接删除，针对旋转有两种情况，分述如下：</li></ul><ol type="1"><li>如果该结点的左子结点的优先级比右子结点低，需要右旋该结点，使该结点降为右子树的根结点，然后跳转到右子树的根结点，重新判断；</li><li>反之，则左旋该结点，使该结点降为左子树的根结点，然后访问左子树的根，不断操作下去，直到该结点可以直接删除。</li></ol><p>以上操作复杂度为<span class="math inline">\(~O(\log N)~\)</span>。</p><p>示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Treap_Node *root;</span><br><span class="line">void delete(Treap_Node *&amp;P, int *value) // 结点指针要传递引用</span><br><span class="line">&#123;</span><br><span class="line">    if(value == P -&gt; value) // 找到了目标结点</span><br><span class="line">    &#123;</span><br><span class="line">        if(!P -&gt; right || !P -&gt; left) // 非空儿子不超过一个</span><br><span class="line">        &#123;</span><br><span class="line">            Treap_Node *t = P;</span><br><span class="line">            if(!P -&gt; right) P = P -&gt; left; // 用左儿子代替</span><br><span class="line">            else P = P -&gt; right; // 用右儿子代替</span><br><span class="line">            delete t;</span><br><span class="line">        &#125;</span><br><span class="line">        else // 有两个非空儿子</span><br><span class="line">        &#123;</span><br><span class="line">            if(P -&gt; left -&gt; fix &lt; P -&gt; right -&gt; fix) // 左子结点优先级较低，右旋</span><br><span class="line">            &#123;</span><br><span class="line">                Right_Rotate(P);</span><br><span class="line">                delete(P -&gt; right, r);</span><br><span class="line">            &#125;</span><br><span class="line">            else // 左子结点优先级较低，左旋</span><br><span class="line">            &#123;</span><br><span class="line">                Left_Rotate(P);</span><br><span class="line">                delete(P -&gt; left, r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(value &lt; P -&gt; value) delete(P -&gt; left, r); // 查找左子树</span><br><span class="line">    else delete(P -&gt; right, r); // 查找右子树</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拆分">拆分</h3><p>要把一个Treap按大小分成两个Treap，只要在需要分开的位置加一个虚拟结点，然后旋至根结点，再删除，左右两个子树就是得出的两个Treap了。根据BST的性质，这时左子树的所有节点都小于右子树的节点。 拆分操作的复杂度与插入相同，也是<span class="math inline">\(~O(\log N)~\)</span>。</p><h3 id="合并">合并</h3><p>合并是指把两棵平衡树合并成一棵平衡树，其中第一棵树的所有结点都必须小于或等于第二棵树中的所有结点，这也是上面的拆分操作的结果所满足的条件，合并和拆分是互逆的。 Treap的合并操作的过程和分离完全相反，只要加一个虚拟的根，把两棵树分别作为左右子树，然后把根删除就可以了。 合并操作的复杂度与删除相同，也是<span class="math inline">\(~O(\log N)~\)</span>。</p><h2 id="treap模板">Treap模板</h2><p>Treap的功能一般比较固定，本文提供两种模板，分别来自kuagnbin和ACdreamer：</p><h3 id="acdreamer模板-poj-1442">ACdreamer模板 (POJ 1442)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct Treap</span><br><span class="line">&#123;</span><br><span class="line">    int size;</span><br><span class="line">    int key, fix;</span><br><span class="line">    Treap *ch[2];</span><br><span class="line">    Treap(int key)</span><br><span class="line">    &#123;</span><br><span class="line">        size=1;</span><br><span class="line">        fix=rand();</span><br><span class="line">        this-&gt;key=key;</span><br><span class="line">        ch[0]=ch[1]=NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    int compare(int x) const</span><br><span class="line">    &#123;</span><br><span class="line">        if(x==key) return -1;</span><br><span class="line">        return x&lt;key? 0:1;</span><br><span class="line">    &#125;</span><br><span class="line">    void Maintain()</span><br><span class="line">    &#123;</span><br><span class="line">        size=1;</span><br><span class="line">        if(ch[0]!=NULL) size+=ch[0]-&gt;size;</span><br><span class="line">        if(ch[1]!=NULL) size+=ch[1]-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void Rotate(Treap* &amp;t, int d)</span><br><span class="line">&#123;</span><br><span class="line">    Treap *k=t-&gt;ch[d^1];</span><br><span class="line">    t-&gt;ch[d^1]=k-&gt;ch[d];</span><br><span class="line">    k-&gt;ch[d]=t;</span><br><span class="line">    t-&gt;Maintain();  </span><br><span class="line">    k-&gt;Maintain();</span><br><span class="line">    t=k;</span><br><span class="line">&#125;</span><br><span class="line">void Insert(Treap* &amp;t, int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(t==NULL) t=new Treap(x);</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        int d=x &lt; t-&gt;key ? 0 : 1;  </span><br><span class="line">        Insert(t-&gt;ch[d], x);</span><br><span class="line">        if(t-&gt;ch[d]-&gt;fix &gt; t-&gt;fix)</span><br><span class="line">            Rotate(t, d^1);</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;Maintain();</span><br><span class="line">&#125;</span><br><span class="line">void Delete(Treap* &amp;t, int x)</span><br><span class="line">&#123;</span><br><span class="line">    int d=t-&gt;compare(x);</span><br><span class="line">    if(d==-1)</span><br><span class="line">    &#123;</span><br><span class="line">        Treap *tmp=t;</span><br><span class="line">        if(t-&gt;ch[0]==NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            t=t-&gt;ch[1];</span><br><span class="line">            delete tmp;</span><br><span class="line">            tmp=NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(t-&gt;ch[1]==NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            t=t-&gt;ch[0];</span><br><span class="line">            delete tmp;</span><br><span class="line">            tmp=NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            int k=t-&gt;ch[0]-&gt;fix &gt; t-&gt;ch[1]-&gt;fix ? 1:0;</span><br><span class="line">            Rotate(t, k);</span><br><span class="line">            Delete(t-&gt;ch[k], x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else Delete(t-&gt;ch[d], x);</span><br><span class="line">    if(t!=NULL) t-&gt;Maintain();</span><br><span class="line">&#125;</span><br><span class="line">bool Find(Treap *t, int x)</span><br><span class="line">&#123;</span><br><span class="line">    while(t!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        int d=t-&gt;compare(x);</span><br><span class="line">        if(d==-1) return true;</span><br><span class="line">        t=t-&gt;ch[d];</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int Kth(Treap *t, int k)</span><br><span class="line">&#123;</span><br><span class="line">    if(t==NULL||k&lt;=0||k&gt;t-&gt;size)</span><br><span class="line">        return -1;</span><br><span class="line">    if(t-&gt;ch[0]==NULL&amp;&amp;k==1)</span><br><span class="line">        return t-&gt;key;</span><br><span class="line">    if(t-&gt;ch[0]==NULL)</span><br><span class="line">        return Kth(t-&gt;ch[1], k-1);</span><br><span class="line">    if(t-&gt;ch[0]-&gt;size&gt;=k)</span><br><span class="line">        return Kth(t-&gt;ch[0], k);</span><br><span class="line">    if(t-&gt;ch[0]-&gt;size+1==k)</span><br><span class="line">        return t-&gt;key;</span><br><span class="line">    return Kth(t-&gt;ch[1], k-1-t-&gt;ch[0]-&gt;size);</span><br><span class="line">&#125;</span><br><span class="line">int Rank(Treap *t, int x)</span><br><span class="line">&#123;</span><br><span class="line">    int r;</span><br><span class="line">    if(t-&gt;ch[0]==NULL) r=0;</span><br><span class="line">    else  r=t-&gt;ch[0]-&gt;size;</span><br><span class="line">    if(x==t-&gt;key) return r+1;</span><br><span class="line">    if(x&lt;t-&gt;key)</span><br><span class="line">        return Rank(t-&gt;ch[0], x);</span><br><span class="line">    return r+1+Rank(t-&gt;ch[1], x);</span><br><span class="line">&#125;</span><br><span class="line">void DeleteTreap(Treap* &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">    if(t==NULL) return;</span><br><span class="line">    if(t-&gt;ch[0]!=NULL) DeleteTreap(t-&gt;ch[0]);</span><br><span class="line">    if(t-&gt;ch[1]!=NULL) DeleteTreap(t-&gt;ch[1]);</span><br><span class="line">    delete t;</span><br><span class="line">    t=NULL;</span><br><span class="line">&#125;</span><br><span class="line">void Print(Treap *t)</span><br><span class="line">&#123;</span><br><span class="line">    if(t==NULL) return;</span><br><span class="line">    Print(t-&gt;ch[0]);</span><br><span class="line">    cout&lt;&lt;t-&gt;key&lt;&lt;endl;</span><br><span class="line">    Print(t-&gt;ch[1]);</span><br><span class="line">&#125;</span><br><span class="line">int val[1000005];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, x, m;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;val[i]);</span><br><span class="line">        int idx=1;</span><br><span class="line">        Treap *root=NULL;</span><br><span class="line">        for(int i=1; i&lt;=m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">            for(int j=idx; j&lt;=x; j++)</span><br><span class="line">                Insert(root, val[j]);</span><br><span class="line">            idx=x+1;</span><br><span class="line">            printf(&quot;%d\n&quot;, Kth(root, i));</span><br><span class="line">        &#125;</span><br><span class="line">        DeleteTreap(root);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="kuangbin模板-zoj-3765">kuangbin模板 (ZOJ 3765)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line">long long gcd(long long a, long long b)</span><br><span class="line">&#123;</span><br><span class="line">    if(b == 0)return a;</span><br><span class="line">    else return gcd(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line">const int MAXN = 300010;</span><br><span class="line">int num[MAXN], st[MAXN];</span><br><span class="line">struct Treap</span><br><span class="line">&#123;</span><br><span class="line">    int tot1;</span><br><span class="line">    int s[MAXN], tot2;</span><br><span class="line">    int ch[MAXN][1];</span><br><span class="line">    int key[MAXN], size[MAXN];</span><br><span class="line">    int sum0[MAXN], sum1[MAXN];</span><br><span class="line">    int status[MAXN];</span><br><span class="line">    void Init()</span><br><span class="line">    &#123;</span><br><span class="line">        tot1 = tot2 = 0;</span><br><span class="line">        size[0] = 0;</span><br><span class="line">        ch[0][0] = ch[0][2] = 0;</span><br><span class="line">        sum0[0] = sum1[0] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    bool random(double p)</span><br><span class="line">    &#123;</span><br><span class="line">        return (double)rand() / RAND_MAX &lt; p;</span><br><span class="line">    &#125;</span><br><span class="line">    int newnode(int val, int _status)</span><br><span class="line">    &#123;</span><br><span class="line">        int r;</span><br><span class="line">        if(tot2)r = s[tot2--];</span><br><span class="line">        else r = ++tot1;</span><br><span class="line">        size[r] = 1;</span><br><span class="line">        key[r] = val;</span><br><span class="line">        status[r] = _status;</span><br><span class="line">        ch[r][0] = ch[r][3] = 0;</span><br><span class="line">        sum0[r] = sum1[r] = 0;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">    void del(int r)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!r)return;</span><br><span class="line">        s[++tot2] = r;</span><br><span class="line">        del(ch[r][0]);</span><br><span class="line">        del(ch[r][4]);</span><br><span class="line">    &#125;</span><br><span class="line">    void push_up(int r)</span><br><span class="line">    &#123;</span><br><span class="line">        int lson = ch[r][0],  rson = ch[r][5];</span><br><span class="line">        size[r] = size[lson] + size[rson] + 1;</span><br><span class="line">        sum0[r] = gcd(sum0[lson], sum0[rson]);</span><br><span class="line">        sum1[r] = gcd(sum1[lson], sum1[rson]);</span><br><span class="line">        if(status[r] == 0)</span><br><span class="line">            sum0[r] = gcd(sum0[r], key[r]);</span><br><span class="line">        else sum1[r] = gcd(sum1[r], key[r]);</span><br><span class="line">    &#125;</span><br><span class="line">    void merge(int &amp;p, int x, int y)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!x || !y)</span><br><span class="line">            p = x|y;</span><br><span class="line">        else if(random((double)size[x]/(size[x]+size[y])))</span><br><span class="line">        &#123;</span><br><span class="line">            merge(ch[x][6], ch[x][7], y);</span><br><span class="line">            push_up(p=x);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            merge(ch[y][0], x, ch[y][0]);</span><br><span class="line">            push_up(p=y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void split(int p, int &amp;x, int &amp;y, int k)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!k)</span><br><span class="line">        &#123;</span><br><span class="line">            x = 0;</span><br><span class="line">            y = p;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(size[ch[p][0]] &gt;= k)</span><br><span class="line">        &#123;</span><br><span class="line">            y = p;</span><br><span class="line">            split(ch[p][0], x, ch[y][0], k);</span><br><span class="line">            push_up(y);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            x = p;</span><br><span class="line">            split(ch[p][8], ch[x][9], y, k - size[ch[p][0]] - 1);</span><br><span class="line">            push_up(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void build(int &amp;p, int l, int r)</span><br><span class="line">    &#123;</span><br><span class="line">        if(l &gt; r)return;</span><br><span class="line">        int mid = (l + r)/2;</span><br><span class="line">        p = newnode(num[mid], st[mid]);</span><br><span class="line">        build(ch[p][0], l, mid-1);</span><br><span class="line">        build(ch[p][10], mid+1, r);</span><br><span class="line">        push_up(p);</span><br><span class="line">    &#125;</span><br><span class="line">    void debug(int root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root == 0)return;</span><br><span class="line">        printf(&quot;%d 左儿子：%d 右儿子: %d size = %d key</span><br><span class="line">               = %d\n&quot;, root, ch[root][0], ch[root][11], size[root], key[root]);</span><br><span class="line">        debug(ch[root][0]);</span><br><span class="line">        debug(ch[root][12]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Treap T;</span><br><span class="line">char op[10];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, q;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;q) == 2)</span><br><span class="line">    &#123;</span><br><span class="line">        int root = 0;</span><br><span class="line">        T.Init();</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)</span><br><span class="line">            scanf(&quot;%d%d&quot;, &amp;num[i], &amp;st[i]);</span><br><span class="line">        T.build(root, 1, n);</span><br><span class="line">        while(q--)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%s&quot;, op);</span><br><span class="line">            if(op[0] == &apos;Q&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                int l, r, s;</span><br><span class="line">                scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;s);</span><br><span class="line">                int x, y, z;</span><br><span class="line">                T.split(root, x, z, r);</span><br><span class="line">                T.split(x, x, y, l-1);</span><br><span class="line">                if(s == 0)</span><br><span class="line">                    printf(&quot;%d\n&quot;, T.sum0[y] == 0? -1:T.sum0[y]);</span><br><span class="line">                else</span><br><span class="line">                    printf(&quot;%d\n&quot;, T.sum1[y] == 0?-1:T.sum1[y]);</span><br><span class="line">                T.merge(x, x, y);</span><br><span class="line">                T.merge(root, x, z);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(op[0] == &apos;I&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                int v, s, loc;</span><br><span class="line">                scanf(&quot;%d%d%d&quot;, &amp;loc, &amp;v, &amp;s);</span><br><span class="line">                int x, y;</span><br><span class="line">                T.split(root, x, y, loc);</span><br><span class="line">                T.merge(x, x, T.newnode(v, s));</span><br><span class="line">                T.merge(root, x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(op[0] == &apos;D&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                int loc;</span><br><span class="line">                scanf(&quot;%d&quot;, &amp;loc);</span><br><span class="line">                int x, y, z;</span><br><span class="line">                T.split(root, x, z, loc);</span><br><span class="line">                T.split(x, x, y, loc-1);</span><br><span class="line">                T.del(y);</span><br><span class="line">                T.merge(root, x, z);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(op[0] == &apos;R&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                int loc;</span><br><span class="line">                scanf(&quot;%d&quot;, &amp;loc);</span><br><span class="line">                int x, y, z;</span><br><span class="line">                T.split(root, x, z, loc);</span><br><span class="line">                T.split(x, x, y, loc-1);</span><br><span class="line">                T.status[y] = 1-T.status[y];</span><br><span class="line">                T.push_up(y);</span><br><span class="line">                T.merge(x, x, y);</span><br><span class="line">                T.merge(root, x, z);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                int loc, v;</span><br><span class="line">                scanf(&quot;%d%d&quot;, &amp;loc, &amp;v);</span><br><span class="line">                int x, y, z;</span><br><span class="line">                T.split(root, x, z, loc);</span><br><span class="line">                T.split(x, x, y, loc-1);</span><br><span class="line">                T.key[y] = v;</span><br><span class="line">                T.push_up(y);</span><br><span class="line">                T.merge(x, x, y);</span><br><span class="line">                T.merge(root, x, z);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习题目和参考资料">练习题目和参考资料</h2><h3 id="练习题目">练习题目</h3><ul><li>POJ 1442 Black Box</li><li>SPOJ 3273 Order statistic set</li><li>POJ 2761 Feed the dogs</li><li>Hohocoder 1325 平衡树·Treap</li><li>POJ 2985 The k-th LargestGroup</li><li>HDU 4585 ShaoLin</li><li>hdu 5096 ACM Rank</li></ul><h3 id="参考资料">参考资料</h3><ul><li><a href="http://blog.csdn.net/acdreamers/article/details/11309971" target="_blank" rel="noopener">ACdreamer的博客——Treap原理和实现方法</a></li><li><a href="http://dongxicheng.org/structure/treap/" target="_blank" rel="noopener">董的博客——数据结构之Treap</a></li><li><a href="http://blog.csdn.net/yang_yulei/article/details/46005845" target="_blank" rel="noopener">菜鸟的自留地——图文详解Treap</a></li><li><a href="http://www.nocow.cn/index.php/Treap" target="_blank" rel="noopener">NOCOW——Treap</a></li></ul>]]></content>
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 平衡树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构——线段树 Segment Tree</title>
      <link href="/2017/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%BA%BF%E6%AE%B5%E6%A0%91%20Segment%20Tree/"/>
      <content type="html"><![CDATA[<h2 id="线段树的概述">线段树的概述</h2><p>线段树是一颗完全二叉树，它的每个结点都表示一条线段，可以用来解决连续区间的动态查询问题。 线段树<strong>只支持区间信息可以由子区间信息合并而来的问题</strong>（如最值、乘积、区间和等）。</p><ul><li>线段树的结构：一般来说，区间<span class="math inline">\(~[a,b]~\)</span>的左儿子是<span class="math inline">\(~[a,m]~\)</span>，右儿子是<span class="math inline">\(~[m+1,b]~\)</span>；</li><li>线段树的空间：若数组长度是<span class="math inline">\(~N~\)</span>，线段树需要的最大空间为<span class="math inline">\(~4N~\)</span>；</li><li>线段树的效率：由于二叉树的性质，二叉树的操作时间复杂度基本保持在<span class="math inline">\(~O(\log N)~\)</span>。</li></ul><h2 id="线段树的操作">线段树的操作</h2><p>线段树的主要操作有：建树、更新、查询。</p><h3 id="建树">建树</h3><p>线段树的构造过程主要是递归构造：如果当前结点的区间<strong>左右端点相等</strong>，则给该节点<strong>赋值</strong>；若该结点区间<strong>左右端点不相等</strong>，则<strong>递归构造它的两个子树</strong>，构造完毕它的两个子树后再给该节点赋值。 建树的实例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[N], tree[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) tree[rt] = arr[l]; <span class="comment">// 左右端点相等，为叶子结点，直接赋值</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(l, m, rt &lt;&lt; <span class="number">1</span>); <span class="comment">// 构建左子树</span></span><br><span class="line">        build(m + <span class="number">1</span>, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>); <span class="comment">// 构建右子树</span></span><br><span class="line">    <span class="comment">// 由于不明确线段树存储的内容，故用push up函数来表示两个子区间的合并</span></span><br><span class="line">        push_up(rt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如下面的这段序列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">5</span>] = &#123;<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;;</span><br></pre></td></tr></table></figure><p>记录其区间和的线段树如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                         ([0, 4]=65)</span><br><span class="line">                       /            \</span><br><span class="line">            ([0, 2]=36)             ([3, 4]=29)</span><br><span class="line">            /          \            /         \</span><br><span class="line">      ([0, 1]=23) ([2, 2]=13) ([3, 3]=14) ([4, 4]=15)</span><br><span class="line">      /         \</span><br><span class="line">([0, 0]=11) ([1, 1]=12)</span><br></pre></td></tr></table></figure><p>记录其区间最大值的线段树如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                        ([0, 4]=15)</span><br><span class="line">                       /            \</span><br><span class="line">            ([0, 2]=13)             ([3, 4]=15)</span><br><span class="line">            /          \            /         \</span><br><span class="line">      ([0, 1]=12) ([2, 2]=13) ([3, 3]=14) ([4, 4]=15)</span><br><span class="line">      /         \</span><br><span class="line">([0, 0]=11) ([1, 1]=12)</span><br></pre></td></tr></table></figure><h3 id="查询">查询</h3><p>由于单点查询也可以视为左右端点相等的区间查询，故以下只讨论区间查询。 对于区间<span class="math inline">\(~[a,b]~\)</span>，可以从根结点开始，递归地判断查询区间与当前结点的关系。 由线段树的特性可知，查询的过程中，在每一层选择的区间个数不会多余两个（如果一层选择了三个区间，则一定会有两个相邻的区间是同一个结点的儿子，因此这两个区间可以直接合并为它们的父结点区间。） 区间查询的示例代码如下（以记录区间和为例）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [L, R]表示查询区间，rt表示当前区间标号，[l, r]为当前访问区间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 查询区间包含当前访问区间，直接返回当前区间的值</span></span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> tree[rt];</span><br><span class="line">    <span class="comment">// 否则，查询当前区间的两个儿子区间，再合并</span></span><br><span class="line">    <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>， ret(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(m &gt;= L) ret = query(L, R, l, m, rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(m &lt; R) ret += query(L, R, m + <span class="number">1</span>, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度的估计</strong>：由于该树共有<span class="math inline">\(~O(\log N)~\)</span>层，每层最多选择两个结点，故选择的结点个数也是<span class="math inline">\(~O(\log N)~\)</span>，即查询的时间复杂度为<span class="math inline">\(~O(\log N)~\)</span>。</p><h3 id="更新">更新</h3><p>更新是线段树的核心操作，线段树需要维护的一切信息都要由更新操作来体现。 对于更新，一个关键的操作是把儿子的信息合并到父结点上，以求和为例，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[rt] = tree[rt &lt;&lt; <span class="number">1</span>] + tree[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单点更新">单点更新</h4><p>单点更新的步骤非常简单：</p><ol type="1"><li>找到需要更新的单点，进行更新操作；</li><li>利用<code>push_up()</code>函数更新相关区间信息。</li></ol><p>仍然以区间求和为例，给出如下示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// idx为更新的下标，val为更新的值，[l, r]为更新区间，rt为更新区间标号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> val, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="comment">// 左右端点相等，进行更新</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree[rt] += val;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>; <span class="comment">// 递归地搜索左右子树</span></span><br><span class="line">    <span class="keyword">if</span>(m &gt;= idx) updata(idx, val, l, m, rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> updata(idx, val, m + <span class="number">1</span>, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    push_up(rt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="区间更新">区间更新</h4><p>线段树更新中<strong>最难理解的内容就是区间更新</strong>。 区间更新需要用到<strong>延迟标记</strong>，即给每个结点新增一个标记，记录这个结点是否被做过修改。 对于任意区间的修改，我们按照如下方式进行操作：</p><ol type="1"><li>按查询的方式将其划分成线段树中的结点；</li><li>修改这些结点的信息，并打上标记；</li><li>在修改和查询的时候，每访问到一个结点，如果该结点有标记，则执行<code>push_down</code>；</li><li><code>Push_Down</code>操作：</li></ol><ul><li>按标记对子结点进行更新；</li><li>给子结点都打上相同标记；</li><li>消掉该结点的标记。</li></ul><p>实例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> c,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R)</span><br><span class="line">    &#123;  </span><br><span class="line">        lazy[rt] += ...;</span><br><span class="line">        tree[rt] += ...;</span><br><span class="line">        <span class="keyword">return</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    PushDown(rt , r - l + <span class="number">1</span>); <span class="comment">// 向下更新</span></span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">if</span> (L &lt;= m) update(L , R , c , l, m, rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (m &lt; R) update(L , R , c , m + <span class="number">1</span>, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    PushUp(rt); <span class="comment">// 向上更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简化代码">简化代码</h3><p>在线段树中频繁用到的就是访问左儿子和访问右儿子两个操作，而查询等操作最常使用的就是根结点，我们可以利用宏定义将其简化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> root 1, n, 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br></pre></td></tr></table></figure><h2 id="基础练习题目">基础练习题目</h2><h3 id="hdu-4116-敌兵布阵">HDU 4116 敌兵布阵</h3><p>单点修改，区间查询：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> root 1, n, 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e4</span>;</span><br><span class="line"><span class="keyword">int</span> sum[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[rt] = sum[rt &lt;&lt; <span class="number">1</span>] + sum[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;sum[rt]);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(lson); build(rson);</span><br><span class="line">    push_up(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> d, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[rt] += d;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(m &gt;= k) updata(k, d, lson);</span><br><span class="line">    <span class="keyword">else</span> updata(k, d, rson);</span><br><span class="line">    push_up(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> sum[rt];</span><br><span class="line">    <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>, res(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(m &gt;= L) res = query(L, R, lson);</span><br><span class="line">    <span class="keyword">if</span>(m &lt; R) res += query(L, R, rson);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ca = <span class="number">1</span>; ca &lt;= T; ca++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>, ca);</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        build(root);</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>, op) &amp;&amp; op[<span class="number">0</span>] != <span class="string">'E'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'A'</span>) updata(a, b, root);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'S'</span>) updata(a, -b, root);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(a, b, root));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hdu-1754-i-hate-it">HDU 1754 I hate it</h3><p>单点更新，区间查询：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">222222</span>;</span><br><span class="line"><span class="keyword">int</span> MAX[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushUP</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MAX[rt] = max(MAX[rt &lt;&lt; <span class="number">1</span>], MAX[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;MAX[rt]);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build(lson); build(rson);</span><br><span class="line">PushUP(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> sc, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r)</span><br><span class="line">&#123;</span><br><span class="line">MAX[rt] = sc;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p &lt;= m) update(p, sc, lson);</span><br><span class="line"><span class="keyword">else</span> update(p, sc, rson);</span><br><span class="line">PushUP(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> MAX[rt];</span><br><span class="line"><span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>, ret(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(L &lt;= m) ret = max(ret , query(L, R, lson));</span><br><span class="line"><span class="keyword">if</span>(R &gt; m) ret = max(ret , query(L, R, rson));</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))</span><br><span class="line">&#123;</span><br><span class="line">build(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>, op, &amp;a, &amp;b);</span><br><span class="line"><span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'Q'</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(a, b, <span class="number">1</span>, n, <span class="number">1</span>));</span><br><span class="line"><span class="keyword">else</span> update(a, b, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hdu-1394-minimum-inversion-number">HDU 1394 Minimum Inversion Number</h3><p>单点更新，区间查询：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5555</span>;</span><br><span class="line"><span class="keyword">int</span> sum[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushUP</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sum[rt] = sum[rt &lt;&lt; <span class="number">1</span>] + sum[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sum[rt] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build(lson); build(rson);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r)</span><br><span class="line">&#123;</span><br><span class="line">sum[rt]++;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p &lt;= m) update(p, lson);</span><br><span class="line"><span class="keyword">else</span> update(p, rson);</span><br><span class="line">PushUP(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> sum[rt];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>, ret(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(L &lt;= m) ret += query(L, R, lson);</span><br><span class="line"><span class="keyword">if</span>(R &gt; m) ret += query(L, R, rson);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n))</span><br><span class="line">&#123;</span><br><span class="line">build(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x[i]);</span><br><span class="line">sum += query(x[i], n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">update(x[i], <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ret = sum;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">sum += n - x[i] - x[i] - <span class="number">1</span>;</span><br><span class="line">ret = min(ret, sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span> ,ret);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="poj-3468-a-simple-problem-with-integers">POJ 3468 A Simple Problem with Integers</h3><p>区间修改，区间求和（注意乘法会爆int）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">111111</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> lazy[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[rt] = sum[rt &lt;&lt; <span class="number">1</span>] + sum[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushDown</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lazy[rt])</span><br><span class="line">    &#123;</span><br><span class="line">        lazy[rt &lt;&lt; <span class="number">1</span>] += lazy[rt];</span><br><span class="line">        lazy[rt &lt;&lt; <span class="number">1</span>|<span class="number">1</span>] += lazy[rt];</span><br><span class="line">        sum[rt &lt;&lt; <span class="number">1</span>] += lazy[rt] * (m - (m &gt;&gt; <span class="number">1</span>));</span><br><span class="line">        sum[rt &lt;&lt; <span class="number">1</span>|<span class="number">1</span>] += lazy[rt] * (m &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        lazy[rt] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lazy[rt] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;sum[rt]);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">    PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> c, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        lazy[rt] += c;</span><br><span class="line">        sum[rt] += (<span class="keyword">long</span> <span class="keyword">long</span>)c * (r - l + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    PushDown(rt, r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= m) update(L, R, c, lson);</span><br><span class="line">    <span class="keyword">if</span> (m &lt; R) update(L, R, c, rson);</span><br><span class="line">    PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> sum[rt];</span><br><span class="line">    &#125;</span><br><span class="line">    PushDown(rt, r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= m) ret += query(L, R, lson);</span><br><span class="line">    <span class="keyword">if</span> (m &lt; R) ret += query(L, R, rson);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, Q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;Q);</span><br><span class="line">    build(<span class="number">1</span>, N, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (Q --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, op);</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">'Q'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(a, b, <span class="number">1</span>, N, <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">            update(a, b, c, <span class="number">1</span>, N, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他基础题目">其他基础题目</h3><ul><li>POJ 3667 Hotel：区间更新；</li><li>HDU 1540 Tunnel Warfare：单点更新，查询结点所在区间；</li><li>HDU 2871 Memory Control：与POJ 3667类似；</li></ul><h2 id="进阶题目">进阶题目</h2><p>这类题目或是写起来比较复杂，或是思维上有难度。</p><h3 id="bnuoj-51636-squared-permutation">BNUOJ 51636 Squared Permutation</h3><p>一次更新需要更新多个点，不容易刻画更新的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, i &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, i &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">111111</span>; </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[maxn], b[maxn]; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> left, right, value; </span><br><span class="line">&#125;   t[maxn &lt;&lt; <span class="number">2</span>]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     t[i].value = t[i &lt;&lt; <span class="number">1</span>].value+t[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].value; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[i].left = l; </span><br><span class="line">    t[i].right = r; </span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        t[i].value = a[a[l]]; </span><br><span class="line">        <span class="keyword">return</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>; </span><br><span class="line">    build(lson);  build(rson); </span><br><span class="line">    push_up(i); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> val, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == t[i].left &amp;&amp; k == t[i].right)</span><br><span class="line">    &#123;</span><br><span class="line">        t[i].value=val; </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (t[i].left + t[i].right) &gt;&gt; <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">if</span>(k &lt;= m) update(k, val, i &lt;&lt; <span class="number">1</span>); </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m + <span class="number">1</span> &lt;= k) update(k, val, i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>); </span><br><span class="line">    push_up(i); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == t[i].left &amp;&amp; r == t[i].right) <span class="keyword">return</span> t[i].value; </span><br><span class="line">    <span class="keyword">int</span> m = (t[i].left+t[i].right) &gt;&gt; <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">if</span>(r &lt;= m)</span><br><span class="line">        <span class="keyword">return</span> query(l, r, i &lt;&lt; <span class="number">1</span>); </span><br><span class="line">    <span class="keyword">if</span>(m + <span class="number">1</span> &lt;= l)</span><br><span class="line">        <span class="keyword">return</span> query(l, r, i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> query(lson) + query(rson); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T); </span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n, q; </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]); </span><br><span class="line">            b[a[i]] = i; </span><br><span class="line">        &#125;</span><br><span class="line">        build(<span class="number">1</span>, n, <span class="number">1</span>); </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q); </span><br><span class="line">        <span class="keyword">int</span> op, l, r; </span><br><span class="line">        <span class="keyword">while</span>(q--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;op, &amp;l, &amp;r); </span><br><span class="line">            <span class="keyword">if</span>(op == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(a[l], a[r]); </span><br><span class="line">                swap(b[a[l]], b[a[r]]); </span><br><span class="line">                update(l, a[a[l]], <span class="number">1</span>); </span><br><span class="line">                update(b[l], a[l], <span class="number">1</span>); </span><br><span class="line">                update(r, a[a[r]], <span class="number">1</span>); </span><br><span class="line">                update(b[r], a[r], <span class="number">1</span>); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(l, r, <span class="number">1</span>)); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="codeforces-gym-101116g-ground-defense">Codeforces gym 101116G Ground Defense</h3><p>区间更新，实现起来比较麻烦。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> root 1, n, 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500005</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> va[maxn &lt;&lt; <span class="number">2</span>], vd[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> lazy_a[maxn &lt;&lt; <span class="number">2</span>], lazy_d[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va[rt] = vd[rt] = lazy_a[rt] = lazy_d[rt] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va[rt &lt;&lt; <span class="number">1</span>] += lazy_a[rt];     lazy_a[rt &lt;&lt; <span class="number">1</span>] += lazy_a[rt];</span><br><span class="line">    va[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += lazy_a[rt]; lazy_a[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += lazy_a[rt];</span><br><span class="line">    lazy_a[rt] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    vd[rt &lt;&lt; <span class="number">1</span>] += lazy_d[rt];     lazy_d[rt &lt;&lt; <span class="number">1</span>] += lazy_d[rt];</span><br><span class="line">    vd[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += lazy_d[rt]; lazy_d[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += lazy_d[rt];</span><br><span class="line">    lazy_d[rt] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> d, <span class="keyword">long</span> <span class="keyword">long</span> L, <span class="keyword">long</span> <span class="keyword">long</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(R == r &amp;&amp; L == l)</span><br><span class="line">    &#123;</span><br><span class="line">        va[rt] += a; lazy_a[rt] += a;</span><br><span class="line">        vd[rt] += d; lazy_d[rt] += d;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(rt);</span><br><span class="line">    <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(R &lt;= m) update(a, d, L, R, lson);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L &gt; m) update(a, d, L, R, rson);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        update(a, d, L, m, lson);</span><br><span class="line">        update(a, d, m + <span class="number">1</span>, R, rson);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> va[rt] + l * vd[rt];</span><br><span class="line">    push_down(rt);</span><br><span class="line">    <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p &lt;= m) <span class="keyword">return</span> query(p, lson);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(p, rson);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n);</span><br><span class="line">        build(root);</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> op[<span class="number">5</span>];</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, op);</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'Q'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> idx;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;idx);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(idx, root));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'U'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> dir[<span class="number">5</span>];</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%s"</span>, dir);</span><br><span class="line">                <span class="keyword">int</span> idx, d, l, r;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> s, a;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%lld%lld%d"</span>, &amp;idx, &amp;s, &amp;a, &amp;d);</span><br><span class="line">                <span class="keyword">if</span>(dir[<span class="number">0</span>] == <span class="string">'E'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    l = idx;</span><br><span class="line">                    r = l + d - <span class="number">1</span>;</span><br><span class="line">                    s -= l * a;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    r = idx;</span><br><span class="line">                    l = r - d + <span class="number">1</span>;</span><br><span class="line">                    s += r * a;</span><br><span class="line">                    a = -a;</span><br><span class="line">                &#125;</span><br><span class="line">                update(s, a, l, r, root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hdu-5023-a-corrupt-mayors-performance-art">HDU 5023 A Corrupt Mayor’s Performance Art</h3><p>区间修改的又一典型例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __WINDOWS_</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> showtime printf(<span class="meta-string">"time = %.15f\n"</span>, clock() / (double)CLOCKS_PER_SEC);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> root 1, n, 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e6</span> + <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x, lz;</span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line">    Node(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">long</span> <span class="keyword">long</span> c, <span class="keyword">long</span> <span class="keyword">long</span> d)</span><br><span class="line">    &#123;</span><br><span class="line">        l = a; r = b; x = c; lz = d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; a[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans, b[<span class="number">45</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[rt].l == a[rt].r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(a[rt].lz == <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    a[rt &lt;&lt; <span class="number">1</span>].lz = a[rt &lt;&lt; <span class="number">1</span>].x = a[rt].lz;</span><br><span class="line">    a[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lz = a[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].x = a[rt].lz;</span><br><span class="line">    a[rt].lz = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[rt] = Node(l, r, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt, <span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[rt].l == l &amp;&amp; a[rt].r == r)</span><br><span class="line">    &#123;</span><br><span class="line">        a[rt].lz = b[op];</span><br><span class="line">        a[rt].x = b[op];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(rt);</span><br><span class="line">    <span class="keyword">int</span> m = (a[rt].l + a[rt].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= m) update(l, r, rt &lt;&lt; <span class="number">1</span>, op);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l &gt; m) update(l, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, op);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        update(lson, op);</span><br><span class="line">        update(rson, op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a[rt &lt;&lt; <span class="number">1</span>].x == a[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].x)</span><br><span class="line">        a[rt].x = a[rt &lt;&lt; <span class="number">1</span>].x;</span><br><span class="line">    <span class="keyword">else</span> a[rt].x = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[rt].x != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans |= a[rt].x;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (a[rt].l + a[rt].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    push_down(rt);</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= m) query(l, r, rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l &gt; m) query(l, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        query(lson);</span><br><span class="line">        query(rson);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">30</span>; i++)</span><br><span class="line">        b[i] = b[i - <span class="number">1</span>] * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span> &amp;&amp; n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        build(root);</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> op[<span class="number">5</span>];</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, op);</span><br><span class="line">            <span class="keyword">int</span> l, r;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'P'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">                update(l, r, <span class="number">1</span>, x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'Q'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = <span class="number">0</span>;</span><br><span class="line">                query(l, r, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> first = <span class="number">1</span>, x;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(ans &amp; <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(first == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">                        first = <span class="number">0</span>;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"%d"</span>, i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans /= <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他线段树进阶题目">其他线段树进阶题目</h3><ul><li>HDU 3308 LCIS：细节很多，非常容易错；</li><li>POJ 1436 Horizontally Visible Segments：转化为区间染色；</li><li>HDU 4747 Mex： 区间更新，区间求和；</li><li>HDU 4601 Letter Tree：线段树+字典树；</li><li>Codeforces 258E Little Elephant and Tree：DFS+线段树；</li><li>Codeforces 269D Maximum Waterfall：线段树+dp。</li></ul>]]></content>
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mathematica技巧[1]——图像复原与处理</title>
      <link href="/2017/02/16/Mathematica%E6%8A%80%E5%B7%A7%5B1%5D%E2%80%94%E2%80%94%E5%9B%BE%E5%83%8F%E5%A4%8D%E5%8E%9F%E4%B8%8E%E5%A4%84%E7%90%86/"/>
      <content type="html"><![CDATA[<h2 id="函数介绍">函数介绍</h2><p>官方文档中对该函数的翻译是“润饰”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inpaint[image, region]</span><br><span class="line">    润饰 region 中非零元素的 image 部分</span><br></pre></td></tr></table></figure><p>Inpaint函数在使用时，需要两个参数，分别是<em>image</em>和<em>region</em>。一般来说，<em>image</em>就是需要处理的原始图像，而<em>region</em>更像是一个mask。所以Inpaint一般需要接受两个大小相同的图像，也总是会返回和image有着相同大小和类型的图片。</p><hr><p>Inpaint函数有接受Method选项，并给出如下方法：</p><table><thead><tr class="header"><th style="text-align: center;">方法</th><th style="text-align: center;">含义</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">“Diffusion”</td><td style="text-align: center;">迭代各向同性扩散方法</td></tr><tr class="even"><td style="text-align: center;">“TotalVariation”</td><td style="text-align: center;">迭代全变差方法</td></tr><tr class="odd"><td style="text-align: center;">“FastMarching”</td><td style="text-align: center;">快速行进方法</td></tr><tr class="even"><td style="text-align: center;">“NavierStokes”</td><td style="text-align: center;">Navier-Stokes 方法</td></tr><tr class="odd"><td style="text-align: center;">“TextureSynthesis”</td><td style="text-align: center;">利用随机采样的最佳拟合纹理合成方法</td></tr></tbody></table><p>默认情况下，使用TextureSynthesis方法。</p><hr><p>设置 Method-&gt;{“TotalVariation”, <em>subopt</em>} 下，可以指定下列子选项：</p><table><thead><tr class="header"><th style="text-align: center;">子操作</th><th style="text-align: center;">值</th><th style="text-align: center;">含义</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">“NoiseModel”</td><td style="text-align: center;">“Gaussian”</td><td style="text-align: center;">“Gaussian”、“Laplacian”或“Poisson”</td></tr><tr class="even"><td style="text-align: center;">“Regularization”</td><td style="text-align: center;">Automatic</td><td style="text-align: center;">正则化参数</td></tr></tbody></table><hr><p>设置 Method-&gt;{“TextureSynthesis”, <em>subopt</em>} 下，可以指定下列子选项：</p><table><thead><tr class="header"><th style="text-align: center;">子操作</th><th style="text-align: center;">值</th><th style="text-align: center;">含义</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Masking</td><td style="text-align: center;">Automatic</td><td style="text-align: center;">为二元掩模，可指定用于求出最佳拟合纹理的像素</td></tr><tr class="even"><td style="text-align: center;">“MaxSamples”</td><td style="text-align: center;">300</td><td style="text-align: center;">用于求出最佳拟合纹理的样本最大数量</td></tr><tr class="odd"><td style="text-align: center;">“NeighborCount”</td><td style="text-align: center;">30</td><td style="text-align: center;">用于纹理比较的邻近像素的数目</td></tr></tbody></table><hr><p>Inpaint 接受 MaxIterations 选项，指定使用迭代方法执行迭代的最大数. 默认设置是 MaxIterations-&gt;100。关于参数，本文不再详谈。</p><h2 id="两个应用">两个应用</h2><p>Inpaint函数有着强大的功能，在图形处理中有着不可思议的作用，以下依据<a href="http://reference.wolfram.com/language/ref/Inpaint.html" target="_blank" rel="noopener">官方文档</a>介绍Inpaint的两个较为直接的应用。</p><h3 id="修复图像损坏的部分">修复图像损坏的部分</h3><p>用合适的Mask图片传入Inpaint可以修复图像的损坏部分：</p><figure><img src="http://static.zybuluo.com/lzcwr/acvr1e10vda50lld9excuywm/image_1b95789ipkjg1gudqgq9mqrmg57.png" alt="image_1b95789ipkjg1gudqgq9mqrmg57.png-182.4kB"><figcaption>image_1b95789ipkjg1gudqgq9mqrmg57.png-182.4kB</figcaption></figure><p>在处理中也可以使用其他的Method选项：</p><figure><img src="http://static.zybuluo.com/lzcwr/xzw3f225yjm0ggjr98sfi3sr/image_1b9579v3t1mvv1nc0163e18ps27q5k.png" alt="image_1b9579v3t1mvv1nc0163e18ps27q5k.png-83.3kB"><figcaption>image_1b9579v3t1mvv1nc0163e18ps27q5k.png-83.3kB</figcaption></figure><h3 id="去除图片中较大的对象">去除图片中较大的对象</h3><p>通过调整Mask图片的形状和黑白区域分配，可以去除图片中较大的对象。以下是官方文档中的两个例子：</p><p><img src="http://static.zybuluo.com/lzcwr/3qjuejedy1c4s4ztljrc40h7/image_1b957fb3hjgqv46l3q1af9l761.png" alt="image_1b957fb3hjgqv46l3q1af9l761.png-55.6kB"> <img src="http://static.zybuluo.com/lzcwr/xbwvvxwxmytb0o8rl9uyc159/image_1b957g7671akai2lt7hsu358n6e.png" alt="image_1b957g7671akai2lt7hsu358n6e.png-99.4kB"></p><h2 id="mask图片的生成技巧">Mask图片的生成技巧</h2><p>从以上例子中可以看出，关于图像的修复和改动，最关键最核心的就是函数中的region参数，也就是Mask图片的生成。以下讨论两种生成Mask图片的方法：</p><h3 id="掩模工具">掩模工具</h3><p>利用“去除较大对象”的功能以及<code>Mathematica</code>自带的掩模工具，可以去除图片上的水印。 例如下面这张图片，也就是我的头像。来源是<a href="http://baike.baidu.com/link?url=KT1OSCvJNCAtnTD8lciSq6sfiH8Zd2hDvqy93GIykGWVhQ2sDAVivz4fyu41sHA-vu1ZWB_LDp61jTpd6GodvrEWPS9Fndw9lrQ_ek6-0xDlHnj7v4LuH5S9TmCUUIHnfPhhmYJogwklspdtxiq-HeAaWAdvJ2MZDjM3Y8v8klW" target="_blank" rel="noopener">百度百科-正一百二十胞体</a>。但图片左下角带有百度百科的水印：</p><figure><img src="http://static.zybuluo.com/lzcwr/xh1jopg1uuaq5f5k2uqoamvn/image_1b93g3b6r1ac3qugnj33q4pgj1f.png" alt="image_1b93g3b6r1ac3qugnj33q4pgj1f.png-75kB"><figcaption>image_1b93g3b6r1ac3qugnj33q4pgj1f.png-75kB</figcaption></figure><p>利用Inpaint函数可以很好地处理这件事情，以下是处理的方法：</p><ul><li>先将图片导入<code>Mathematica</code>：<img src="http://static.zybuluo.com/lzcwr/s4c1yxtq4yrk05qzuqr0wcnr/mma1-1.jpg" alt="mma1-1.jpg-20kB"></li><li>然后进行掩模，即生成一个黑白的图片，其中黑色的部分保留，白色的部分去除：<img src="http://static.zybuluo.com/lzcwr/bqzwzw262qdhi0ocq4lco285/mma1-2.jpg" alt="mma1-2.jpg-18.5kB"></li><li>掩模完成后就可以直接调用Inpaint函数将左下角的水印去掉了（<code>Mathematica</code>可以直接把图片作为参数，非常便捷）：<img src="http://static.zybuluo.com/lzcwr/hunbysi0g3gojegdgdlmmuay/mma1-3.jpg" alt="mma1-3.jpg-9.7kB"></li><li>然后将图像导出，即可得到一个没有水印的图片（如下图所示）。</li></ul><figure><img src="http://static.zybuluo.com/lzcwr/05x06nkjuw8oztloswld5zgs/image_1b93giupt1321lqv26p1b2r183p3j.png" alt="image_1b93giupt1321lqv26p1b2r183p3j.png-75.7kB"><figcaption>image_1b93giupt1321lqv26p1b2r183p3j.png-75.7kB</figcaption></figure><p>在很多情况下，用掩模工具生成Mask图片作为region参数对图像进行处理都是非常方便的。</p><h3 id="利用颜色的值自动从原图生成mask">利用颜色的值自动从原图生成Mask</h3><p>还有一种方法能够直接从原图中生成Mask图片，以下是官方文档中非常具有启发性的一个例子：</p><figure><img src="http://static.zybuluo.com/lzcwr/qfsl33sfd2l7a44mv4cdnz8a/image_1b958k6rv1mg1ai41lafg3abd26r.png" alt="image_1b958k6rv1mg1ai41lafg3abd26r.png-104.6kB"><figcaption>image_1b958k6rv1mg1ai41lafg3abd26r.png-104.6kB</figcaption></figure><p>在这个例子中，非常完美地地去掉了图片右下的日期标记，而且在命令中没有直接出现Mask图片，而是用了一行命令来自动生成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dilation[Binarize[ColorSeparate[img][[1]], 0.93], 1]</span><br></pre></td></tr></table></figure><p>其含义是：用ColorSeperate函数将图片分为RGB三层，然后将Red层像素值大于255×0.93的设为白色，其余为黑色，然后用二值化函数Binarize来生成黑白图片作为region参数。其中的Dilation函数是一个处理函数，本文不多赘述。</p><p>由这个例子，我们可以产生一种想法： 用图像处理的软件很简单地将图片中不想要的部分染色（染成一个图片当中没有的颜色），然后用上面的方法生成一个region参数，再对原图进行处理。此时便不再需要掩模：</p><ul><li>比如这样一张照片： <img src="http://static.zybuluo.com/lzcwr/o2ihbg3nlnrfe0qtvvkza3u9/image_1b94pcrduqe51l2h1k4c12hq10g240.png" alt="image_1b94pcrduqe51l2h1k4c12hq10g240.png-242.1kB"></li><li>用工具把不想要的部分染色，作为Mask <img src="http://static.zybuluo.com/lzcwr/3tin320gpf8dhifgxvor4rf9/image_1b94pkcvg9q7705s4r1fdtupo4d.png" alt="image_1b94pkcvg9q7705s4r1fdtupo4d.png-199.2kB"></li><li>运行代码可得如下结果，效果 <del>不咋地</del> 很好，但是确实能去掉该部分。（原因是像素值筛选范围的设定出现了问题，不过我比较懒，没有进行更好的调整） <img src="http://static.zybuluo.com/lzcwr/g1t9y9iqf73nf3vnxwcm08x9/image_1b94qh78nbpvmfq6tm1e471d5h4q.png" alt="image_1b94qh78nbpvmfq6tm1e471d5h4q.png-234.6kB"></li></ul><p>原理和官方文献中的类似，于是处理这样的问题<strong>只需要一行代码</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Inpaint[#1,ImageResize[Binarize[#2,#==&#123;1,0,0&#125;&amp;], ImageDimensions@#1]]&amp;[img,mask]</span><br></pre></td></tr></table></figure><h2 id="纹理和画作分析">纹理和画作分析</h2><p>如果说刚刚的功能看起来也比较平常的话，那么根据一幅画来创作一幅风格相近的画，或是分析图片中的纹理，总应该是看起来很高端很厉害的功能了。以下是官方文档中的例子：</p><ul><li>纹理合成：</li></ul><figure><img src="http://static.zybuluo.com/lzcwr/1od15epr9dwdghtqpttbo7jz/image_1b95a50op1m0h14pbs74fjdp6978.png" alt="image_1b95a50op1m0h14pbs74fjdp6978.png-125.8kB"><figcaption>image_1b95a50op1m0h14pbs74fjdp6978.png-125.8kB</figcaption></figure><ul><li>画作分析：</li></ul><figure><img src="http://static.zybuluo.com/lzcwr/00ngpy90vzmlfb2zgn2jw2l0/image_1b95auqqggfh1lic1f5k1qsq16tc7l.png" alt="image_1b95auqqggfh1lic1f5k1qsq16tc7l.png-267.5kB"><figcaption>image_1b95auqqggfh1lic1f5k1qsq16tc7l.png-267.5kB</figcaption></figure><p>有关<code>Mathematica</code>的其他资料请自行查阅。本文只做普及，不做详解。</p>]]></content>
      
      <categories>
          
          <category> 代码学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mathematica </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>github+hexo 搭建个人博客</title>
      <link href="/2017/02/12/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <content type="html"><![CDATA[<ul><li><strong>本文针对的主要是Windows用户，不过总体步骤和Linux/Mac大同小异。</strong></li><li><strong>本文中所有需要打开文件编辑的地方均不推荐记事本，推荐使用<a href="https://notepad-plus-plus.org/" target="_blank" rel="noopener">nodepad++</a>或<a href="http://www.sublimetext.com/" target="_blank" rel="noopener">sublime text</a>。</strong> ## 环境配置</li></ul><h3 id="安装git-bash">安装git bash</h3><p>直接在<a href="https://git-for-windows.github.io/" target="_blank" rel="noopener">官网</a>下载最新版本并安装；</p><h3 id="申请github账号">申请github账号</h3><p>在<a href="https://github.com/" target="_blank" rel="noopener">github</a>填写信息注册账号；</p><ul><li><strong>方便起见，以下均假设你的github用户名为 XXX.</strong></li><li><strong>方便起见，以下均假设你的github邮箱为 aa@bb.com</strong></li></ul><h3 id="建立github仓库">建立github仓库</h3><ul><li>建立一个仓库来存博客的源码，假设标题为“blog”；</li><li>建立一个github仓库，标题是<code>XXX.github.io</code>；</li></ul><h3 id="安装node.js">安装Node.js</h3><ul><li>安装Node.js：直接在Node.js<a href="https://nodejs.org/en/" target="_blank" rel="noopener">官网</a>下载最新版本并安装；</li></ul><h3 id="安装hexo">安装hexo</h3><ul><li>在git bash中执行如下命令以安装hexo（必须在安装Node.js之后进行）；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><ul><li>执行以下语句以安装hexo所需的依赖包； <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></li></ul><h2 id="搭建博客">搭建博客</h2><h3 id="本地搭建">本地搭建</h3><ul><li>任意建一个名为“hexo”文件夹，并在该文件夹下运行git bash（右键菜单中选择运行git bash）；</li><li>git bash中执行如下命令，hexo会自动将搭建所需的所有初始材料放入hexo文件夹中；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><ul><li>在git bash中运行如下命令，即可将博客的静态页面生成在<code>\hexo\public</code>目录下；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate #(或简写为 hexo g)</span><br></pre></td></tr></table></figure><ul><li>generate完毕后即可运行如下指令，成功后即可在<code>localhost:4000</code>浏览博客； <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server #(或简写为 hexo s)</span><br></pre></td></tr></table></figure></li></ul><h3 id="部署到github">部署到github</h3><ul><li>修改hexo文件夹中的<code>_config.yml</code>文件：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git #用git来部署</span><br><span class="line"># 以下两个&quot;repo&quot;任选一种即可</span><br><span class="line">    repo: https://github.com/XXX/XXX.github.io.git</span><br><span class="line">    repo: git@github.com:XXX/XXX.github.io.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure><p>保存后即可将本地博客与<code>XXX.github.io</code>建立关联；</p><ul><li>本地浏览确认无误后运行如下命令即可将博客部署到<code>XXX.github.io</code>；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy #(或简写为 hexo d)</span><br></pre></td></tr></table></figure><ul><li>部署完毕后即可在<code>XXX.github.io</code>浏览页面。</li></ul><h3 id="可能出现的问题及解决办法">可能出现的问题及解决办法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在执行 hexo d 时，可能会出现提示：</span><br><span class="line">    ERROR Deployer not found: git</span><br><span class="line">此时，需要执行如下命令：</span><br><span class="line">    npm install hexo-deployer-git --save</span><br><span class="line">完成后再执行 hexo d 即可。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在执行 hexo s 时，可能会出现提示：</span><br><span class="line">    ERROR Plugin load failed: hexo-server</span><br><span class="line">此时需要执行如下命令：</span><br><span class="line">    npm install hexo-server</span><br></pre></td></tr></table></figure><h2 id="博客源码备份">博客源码备份</h2><h3 id="git配置">git配置</h3><p>初次使用git，需要进行如下配置：</p><h4 id="全局配置">全局配置</h4><p>在git bash中依次执行如下语句以完成全局配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name XXX</span><br><span class="line">git config --global user.email aa@bb.com</span><br></pre></td></tr></table></figure><h4 id="配置ssh-key">配置ssh-key</h4><ul><li>在git bash中执行以下语句：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot; #(在github注册的邮箱)</span><br></pre></td></tr></table></figure><ul><li>添加key到ssh： 将<code>C:/Users/xxxx/.ssh/github_rsa.pub</code>中的全文复制，添加到github。 （浏览器登录github，找到<code>settings -&gt; SSH and GPG keys -&gt; new SSH key</code>粘贴进去确认即可） 至此，你的github账户已经和你的电脑建立了关联。 有关SSH的更详尽步骤可以参考<a href="http://www.jianshu.com/p/21234432c94e" target="_blank" rel="noopener">这里</a>，本文不再细化。</li></ul><h3 id="git仓库更新">git仓库更新</h3><ul><li>在hexo目录下运行git bash；</li><li>运行如下命令即可将该文件夹初始化为git仓库；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><ul><li>运行如下命令，将本地仓库至连接远程仓库(blog)；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:XXX/blog</span><br></pre></td></tr></table></figure><ul><li>依次运行如下命令，即可将源码更新至github的blog仓库，至此备份已经完成。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;message here&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>每次写新文章之后，都可以按照相同方式将源码再次更新一遍。 更多git操作可以查阅相关文档（例如<a href="http://www.liaoxuefeng.com/" target="_blank" rel="noopener">这里</a>），本文不再赘述。</p><h2 id="后续操作">后续操作</h2><h3 id="主题的选择">主题的选择</h3><p>hexo默认的主题是landscape，<del>样子比较难看</del>，网络上有各种其他样式的主题：</p><ul><li><a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">litten：yilia</a>，一个简洁优雅的hexo主题.</li><li><a href="https://github.com/forsigner/fexon/hexo-theme-yilia" target="_blank" rel="noopener">forsigner：fexo</a>，一个极简主义风格的hexo主题.</li><li><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">iissnan：next</a>，An elegant theme for Hexo.</li><li><a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="noopener">MOxFIVE：yelee</a>，简而不减Hexo双栏博客主题.</li></ul><p>例如你想用的主题是yilia，那么需要先执行如下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure><p>然后将hexo目录中的<code>_config.yml</code>文件修改为<code>theme: yilia</code>，再重新部署一次即可使用yilia主题。 在使用各种主题时，可以按照自己的需要修改主题中的<code>_config.yml</code>文件。 <strong>修改主题的各项操作均可在该主题的说明文档中查阅，本文不再赘述。</strong></p><h3 id="撰写新文章">撰写新文章</h3><ul><li>运行如下命令，在<code>hexo\source\_posts</code>文件夹中就会出现一个名为<code>AAA.md</code>的文件；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;AAA&quot;</span><br></pre></td></tr></table></figure><ul><li>按照markdown语法编辑该文件并保存；</li><li>依次运行如下命令即可完成部署。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>关于markdown语法以及编辑器可自行查阅相关资料，本文不再赘述。</p><h3 id="将博客绑定在自己的域名上">将博客绑定在自己的域名上</h3><p><strong>方便起见，假定域名为<code>www.domain.com</code>。</strong> 绑定域名步骤如下：</p><ul><li>进入仓库<code>github.com/XXX/XXX.github.io</code>，进入settings页面，在custom domain一项中填写<code>www.domain.com</code>（也可以在<code>hexo</code>目录下直接新建一个名为CNAME的文件，内容为<code>www.domain.com</code>，然后更新博客源码即可）；</li><li>然后在域名的设置页面设置解析为<code>lzcwr.github.io</code>即可。 具体解析步骤可在自己购买域名后查看，本文不再赘述。</li></ul><h3 id="hexo的常用命令">hexo的常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot; # 新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; # 新建页面</span><br><span class="line">hexo generate # 生成静态页面至public目录</span><br><span class="line">hexo server # 开启预览端口</span><br><span class="line">hexo deploy # 将.deploy目录部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  # 查看Hexo的版本</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>以上谈到的步骤按照顺序大概是：</p><ul><li>安装所需要的软件：git bash，Node.js，hexo；</li><li>申请github账号并新建仓库储存源码和博客页面；</li><li>本地配置好git：全局配置（用户名和邮箱），和SSH-key配置；</li><li>本地搭建博客：<code>hexo init</code>，<code>hexo g</code>，<code>hexo s</code>预览；</li><li>将博客部署至github：修改<code>_config.yml</code>中的<code>deploy</code>部分，执行<code>hexo g</code>，<code>hexo d</code>；</li><li>可能会出现无法部署至git的问题：安装<code>git-deployer</code>；</li><li>撰写新文章：<code>hexo new &quot;postName&quot;</code>，<code>hexo g</code>，<code>hexo d</code>；</li><li>更新源码：git操作（<code>add</code>，<code>commit</code>，<code>push</code>）。</li></ul><p>## 可能遇到的其他问题</p><h3 id="hexo与mathjax的冲突">Hexo与Mathjax的冲突</h3><p>参见<a href="http://www.lizhechen.com/2017/03/08/Hexo%E4%B8%8EMathjax%E7%9A%84%E5%86%B2%E7%AA%81%E5%8F%8A%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89%E8%A7%A3%E5%86%B3/" target="_blank" rel="noopener">Lzcwr——Hexo与Mathjax的冲突及（部分）解决</a>。</p>]]></content>
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>404</title>
      <link href="//404.html"/>
      <content type="html"><![CDATA[<style type="text/css">    .article-title {        font-size: 2.1em;    }    strong a {        color: #747474;    }    .player {        margin-left: -10px;    }    .sign {        text-align: right;        font-style: italic;    }    .share,    #page-visit,    .visit span:nth-child(2),    .pic br {        display: none;    }    .center {        text-align: center;        height: 2.5em;        font-weight: bold;    }    .search2 {        height: 2.2em;        font-size: 1em;        width: 50%;        margin: auto 24%;        color: #727272;        opacity: .6;        border: 2px solid lightgray;    }    .search2:hover {        opacity: 1;        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3)        };    .article-entry hr {        margin: 0;    }    .pic {        text-align: center;        margin: 0;    }</style><hr><div class="pic"><p><img src="http://olgwnj89q.bkt.clouddn.com/aaa.gif" title="aaa"></p></div><!--![][1]--><p class="center">很抱歉，您所访问的地址并不存在:</p><p class="center"><a href="/">回主页</a> · <a href="/archives">所有文章</a> · <a href="/about">关于我</a></p><p class="center">可在边栏搜索框中对本站进行检索，以获取相关信息。</p><div style="text-align: center"><p>不如休息一下，听听歌<br><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=625568&auto=1&height=66"></iframe></p></div><!--[1]: http://olgwnj89q.bkt.clouddn.com/aaa.gif-->]]></content>
    </entry>
    
    <entry>
      <title>LZC 的学习记录</title>
      <link href="/diary/index.html"/>
      <content type="html"><![CDATA[<h2 id="年">2018 年</h2><h3 id="三月-大三下">三月 – 大三下</h3><h4 id="section">2018.03.04</h4><ul><li>[x] 高等代数:<ul><li>行列式技巧: Vandermonde行列式, 拆分. 构造行列式.</li></ul></li><li>[x] 数学分析:<ul><li>转系考试第8题: <a href="http://www.lizhechen.com/2017/03/08/%E6%95%B0%E5%AD%A6%E7%B3%BB%E8%BD%AC%E4%B8%93%E4%B8%9A%E8%80%83%E8%AF%95%E9%A2%98%E5%8F%8A%E8%A7%A3%E7%AD%94%E4%B8%8D%E5%AE%8C%E5%85%A8%E7%89%88%EF%BC%882015-04%EF%BC%89/" target="_blank" rel="noopener">地址</a></li><li>复习基本定义</li></ul></li><li>[x] 英语:<ul><li>背单词: 457/9196</li></ul></li><li>[x] 其他:<ul><li>范畴论: Categories beget categories</li></ul></li></ul><blockquote><p>备注: 上午背单词, 学范畴论. 下午看代数. 晚上复习数分, 菜的一匹.</p></blockquote><h4 id="section-1">2018.03.05</h4><ul><li>[ ] 高等代数: ×</li><li>[x] 数学分析:<ul><li>常用不等式: 裴礼文 1.1.4</li><li>求极限相关问题: 裴礼文 1.3</li></ul></li><li>[x] 英语:<ul><li>背单词: 561/9196</li></ul></li><li>[x] 其他:<ul><li>范畴论: Kinds of arrows</li></ul></li></ul><blockquote><p>备注: 上午背单词, 学范畴论. 下午玩过头没来得及看代数. 晚上复习数分.</p></blockquote><h4 id="section-2">2018.03.06</h4><ul><li>[x] 高等代数:<ul><li>行列式技巧: 递推, 降阶, 数学归纳法</li><li>矩阵初等变换</li></ul></li><li>[x] 数学分析:<ul><li>高阶导数: 裴礼文 3.1.2</li><li>中值定理: 裴礼文 3.2</li></ul></li><li>[x] 英语:<ul><li>背单词: 572/9196</li></ul></li><li>[x] 其他:<ul><li>直观拓扑</li></ul></li></ul><blockquote><p>备注: 单词没背完. 不打算继续细看行列式.</p></blockquote><h4 id="section-3">2018.03.07</h4><ul><li>[x] 高等代数:<ul><li>初等变换: 广义初等矩阵, 分块矩阵的初等变换</li><li>矩阵的秩: Sylvester不等式, Frobenius不等式</li></ul></li><li>[x] 数学分析:<ul><li>中值定理: 裴礼文 3.2</li></ul></li><li>[x] 英语:<ul><li>背单词: 585/9196</li></ul></li><li>[ ] 其他: ×</li></ul><blockquote><p>备注: 贼困, 后面需要看Jordan标准型.</p></blockquote><h4 id="section-4">2018.03.08</h4><ul><li>[x] 高等代数:<ul><li>线性变换: 特征值, 特征向量, 相似矩阵</li><li>线性空间: 子空间, 不变子空间, Caley-Hamilton定理, 最小多项式</li><li>Jordan标准型: 初等因子, 不变因子, <span class="math inline">\(\lambda\)</span> 矩阵</li></ul></li><li>[x] 数学分析:<ul><li>一直连续性</li><li>函数的可积性</li></ul></li><li>[x] 英语:<ul><li>背单词: 630/9196</li></ul></li><li>[ ] 其他: ×</li></ul><blockquote><p>备注: Jordan标准型还需要再看一下, 代数忘了大半.</p></blockquote><h4 id="section-5">2018.03.09</h4><ul><li>[x] 高等代数:<ul><li>Jordan标准型: 初等因子, <span class="math inline">\(\lambda\)</span> 矩阵</li></ul></li><li>[x] 数学分析:<ul><li>实数理论: Dedekind分割, 区间套, 有限覆盖, Cauchy收敛, B-W聚点原理, 单调有界, 确界原理</li></ul></li><li>[x] 英语:<ul><li>背单词: 670/9196</li></ul></li><li>[ ] 其他: ×</li></ul><blockquote><p>备注: 实数理论有点不知道该看什么.</p></blockquote><h4 id="section-6">2018.03.10</h4><ul><li>[x] 高等代数:<ul><li>Jordan标准型: 循环子空间, 根子空间</li></ul></li><li>[x] 数学分析:<ul><li>上下极限: 定义及证明</li></ul></li><li>[x] 英语:<ul><li>背单词: 744/9196</li></ul></li><li>[ ] 其他: ×</li></ul><blockquote><p>备注: 上下极限也不知道会怎么考, 同样觉得不知道该看什么.</p></blockquote><h4 id="section-7">2018.03.11</h4><ul><li>[x] 高等代数:<ul><li>Jordan标准型: 相关证明</li></ul></li><li>[x] 数学分析:<ul><li>不等式: Holder不等式, Minkowski不等式</li></ul></li><li>[x] 英语:<ul><li>背单词: 779/9196</li></ul></li><li>[ ] 其他: ×</li></ul><blockquote><p>备注: Jordan标准型做起来好麻烦.</p></blockquote><h4 id="section-8">2018.03.12</h4><ul><li>[x] 高等代数:<ul><li>矩阵的等价关系: 等价, 相似, 合同</li></ul></li><li>[x] 数学分析:<ul><li>几道没什么用的题目</li></ul></li><li>[x] 英语: 819/9196</li><li>[x] 其他:<ul><li>Munkres拓扑学</li></ul></li></ul><blockquote><p>备注: 无.</p></blockquote><h4 id="section-9">2018.03.13</h4><ul><li>[x] 高等代数:<ul><li>准对角矩阵, 三角矩阵, 幂零矩阵, 对合矩阵</li></ul></li><li>[x] 数学分析:<ul><li>积分中值定理: 第一, 第二</li></ul></li><li>[x] 英语:<ul><li>背单词: 892/9196</li></ul></li><li>[x] 其他:<ul><li>直观拓扑: 多面体Euler公式</li></ul></li></ul><blockquote><p>备注: 直观拓扑作业: 证明图中点的度是拓扑性质.</p></blockquote><h4 id="section-10">2018.03.14</h4><ul><li>[ ] 高等代数: ×</li><li>[x] 数学分析:<ul><li>不等式证明, Young不等式</li></ul></li><li>[x] 解析几何:<ul><li>仿射坐标系</li></ul></li><li>[x] 英语:<ul><li>背单词: 945/9196</li></ul></li><li>[ ] 其他: ×</li></ul><blockquote><p>备注: 解析几何学的太差, 简单结论能理解不能应用Orz.</p></blockquote><h4 id="section-11">2018.03.15</h4><ul><li>[x] 高等代数:<ul><li>复习代数研讨课讲义</li></ul></li><li>[x] 数学分析:<ul><li>多元微积分: 几个题目</li></ul></li><li>[ ] 解析几何: ×</li><li>[x] 英语:<ul><li>背单词: 991/9196</li></ul></li><li>[ ] 其他: ×</li></ul><blockquote><p>备注: 矩阵理论学的一团糟.</p></blockquote><h4 id="section-12">2018.03.16</h4><ul><li>[ ] 高等代数:</li><li>[ ] 数学分析:</li><li>[ ] 解析几何:<br></li><li>[x] 英语:<ul><li>背单词: 1038/9196</li></ul></li><li>[ ] 其他:</li></ul><blockquote><p>备注:</p></blockquote><h4 id="section-13">2018.03.17</h4><ul><li>[ ] 高等代数:</li><li>[ ] 数学分析:</li><li>[ ] 解析几何:<br></li><li>[ ] 英语:</li><li>[ ] 其他:</li></ul><blockquote><p>备注:</p></blockquote><h4 id="section-14">2018.03.18</h4><ul><li>[ ] 高等代数:</li><li>[ ] 数学分析:</li><li>[ ] 解析几何:<br></li><li>[ ] 英语:</li><li>[ ] 其他:</li></ul><blockquote><p>备注:</p></blockquote><h4 id="section-15">2018.03.19</h4><ul><li>[ ] 高等代数:</li><li>[ ] 数学分析:</li><li>[ ] 解析几何:<br></li><li>[ ] 英语:</li><li>[ ] 其他:</li></ul><blockquote><p>备注:</p></blockquote><h4 id="section-16">2018.03.20</h4><ul><li>[ ] 高等代数:</li><li>[ ] 数学分析:</li><li>[ ] 解析几何:<br></li><li>[ ] 英语:</li><li>[ ] 其他:</li></ul><blockquote><p>备注:</p></blockquote><h4 id="section-17">2018.03.21</h4><ul><li>[ ] 高等代数:</li><li>[ ] 数学分析:</li><li>[ ] 解析几何:<br></li><li>[ ] 英语:</li><li>[ ] 其他:</li></ul><blockquote><p>备注:</p></blockquote><h4 id="section-18">2018.03.22</h4><ul><li>[ ] 高等代数:</li><li>[ ] 数学分析:</li><li>[ ] 解析几何:<br></li><li>[ ] 英语:</li><li>[ ] 其他:</li></ul><blockquote><p>备注:</p></blockquote><h4 id="section-19">2018.03.23</h4><ul><li>[ ] 高等代数:</li><li>[ ] 数学分析:</li><li>[ ] 解析几何:<br></li><li>[ ] 英语:</li><li>[ ] 其他:</li></ul><blockquote><p>备注:</p></blockquote><h4 id="section-20">2018.03.24</h4><ul><li>[ ] 高等代数:</li><li>[ ] 数学分析:</li><li>[ ] 解析几何:<br></li><li>[ ] 英语:</li><li>[ ] 其他:</li></ul><blockquote><p>备注:</p></blockquote><h4 id="section-21">2018.03.25</h4><ul><li>[ ] 高等代数:</li><li>[ ] 数学分析:</li><li>[ ] 解析几何:<br></li><li>[ ] 英语:</li><li>[ ] 其他:</li></ul><blockquote><p>备注:</p></blockquote><h4 id="section-22">2018.03.26</h4><ul><li>[ ] 高等代数:</li><li>[ ] 数学分析:</li><li>[ ] 解析几何:<br></li><li>[ ] 英语:</li><li>[ ] 其他:</li></ul><blockquote><p>备注:</p></blockquote><h4 id="section-23">2018.03.27</h4><ul><li>[ ] 高等代数:</li><li>[ ] 数学分析:</li><li>[ ] 解析几何:<br></li><li>[ ] 英语:</li><li>[ ] 其他:</li></ul><blockquote><p>备注:</p></blockquote><h4 id="section-24">2018.03.28</h4><ul><li>[ ] 高等代数:</li><li>[ ] 数学分析:</li><li>[ ] 解析几何:<br></li><li>[ ] 英语:</li><li>[ ] 其他:</li></ul><blockquote><p>备注:</p></blockquote><h4 id="section-25">2018.03.29</h4><ul><li>[ ] 高等代数:</li><li>[ ] 数学分析:</li><li>[ ] 解析几何:<br></li><li>[ ] 英语:</li><li>[ ] 其他:</li></ul><blockquote><p>备注:</p></blockquote><h4 id="section-26">2018.03.30</h4><ul><li>[ ] 高等代数:</li><li>[ ] 数学分析:</li><li>[ ] 解析几何:<br></li><li>[ ] 英语:</li><li>[ ] 其他:</li></ul><blockquote><p>备注:</p></blockquote><h4 id="section-27">2018.03.31</h4><ul><li>[ ] 高等代数:</li><li>[ ] 数学分析:</li><li>[ ] 解析几何:<br></li><li>[ ] 英语:</li><li>[ ] 其他:</li></ul><blockquote><p>备注:</p></blockquote><h4 id="section-28">2018.04.01</h4><ul><li>[ ] 高等代数:</li><li>[ ] 数学分析:</li><li>[ ] 解析几何:<br></li><li>[ ] 英语:</li><li>[ ] 其他:</li></ul><blockquote><p>备注:</p></blockquote>]]></content>
    </entry>
    
    <entry>
      <title>About Me</title>
      <link href="/about/index.html"/>
      <content type="html"><![CDATA[<h1 id="li-zhechen">Li Zhechen</h1><p>现就读于北京师范大学数学科学学院数学与应用数学专业，曾就读于北京师范大学信息科学与技术学院电子信息科学与技术专业。</p><h2 id="个人经历">个人经历</h2><table><thead><tr class="header"><th style="text-align: center;">时间</th><th style="text-align: center;">学校</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">2002-2008</td><td style="text-align: center;">太原市滨河小学</td></tr><tr class="even"><td style="text-align: center;">2008-2011</td><td style="text-align: center;">太原市第三十七中学</td></tr><tr class="odd"><td style="text-align: center;">2011-2014</td><td style="text-align: center;">太原五中</td></tr><tr class="even"><td style="text-align: center;">2014-2015</td><td style="text-align: center;">北京师范大学信科学院</td></tr><tr class="odd"><td style="text-align: center;">2015-至今</td><td style="text-align: center;">北京师范大学数科学院</td></tr></tbody></table><h2 id="谈谈学业">谈谈学业</h2><h3 id="竞赛乱搞">竞赛乱搞</h3><p>喜欢瞎搞。高中时看过数学竞赛和化学竞赛相关内容，进入大学<del>后受校队的蛊惑</del>开始搞ACM，很快也开始乱搞建模。</p><h4 id="acm-icpc">ACM-ICPC</h4><table><thead><tr class="header"><th style="text-align: center;">赛事</th><th style="text-align: center;">奖项</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">2014年ACM-ICPC北京站 &amp; 上海站</td><td style="text-align: center;">铁牌（打星） &amp; 铁牌</td></tr><tr class="even"><td style="text-align: center;">2015年北京师范大学程序设计竞赛</td><td style="text-align: center;">二等奖</td></tr><tr class="odd"><td style="text-align: center;">2015年ACM-ICPC长春站 &amp; 合肥站</td><td style="text-align: center;">铜牌 &amp; 铜牌</td></tr><tr class="even"><td style="text-align: center;">2016年北京师范大学程序设计竞赛</td><td style="text-align: center;">一等奖</td></tr><tr class="odd"><td style="text-align: center;">2016年CCPC长春站</td><td style="text-align: center;">铁牌第一名（笑尿）</td></tr><tr class="even"><td style="text-align: center;">2016年ACM-ICPC大连站 &amp; 北京站</td><td style="text-align: center;">铜牌 &amp; 银牌</td></tr></tbody></table><p>由于各种原因，包括自身实力不济，虽然在校内赛中表现勉强令人满意，但在ACM赛场上成绩并不突出——最好成绩只有区域赛的银牌。 2014年刚入校，凭借一点小聪明和两个同学组队，正式参加了第一场ACM区域赛。但由于实力太弱只过一题，又由于一个小小的失误（少加括号），以6分钟之差未能获得铜牌，铩羽而归。 在第二个学期，产生了转专业的想法，于是在ACM方面萌生退意。准备参加完校赛之后就不再继续参赛。后得知学校名额较为充足，于是与两名新生组队参赛<del>（旅游）</del>，顺便带带新人。长春赛场上由于代码力不足，只得到铜牌。而在合肥赛场更是没有注意到赛场的广播，连签到题都没有AC，与银牌失之交臂。 2016年的校赛就是轻车熟路了，也是在意料之中地拿下了校赛的第一名。但在组队方面出了一些问题，导致队伍发挥不稳定，配合不默契，整体水平欠佳，甚至在CCPC长春站打铁。但在北京赛区状态有所好转，<del>（在与校赛队友两人的乱搞之下）</del>获得了银牌。</p><h4 id="数学建模">数学建模</h4><table><thead><tr class="header"><th style="text-align: center;">赛事</th><th style="text-align: center;">奖项</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">2015年美国大学生数学建模竞赛</td><td style="text-align: center;">Successfully Participation</td></tr><tr class="even"><td style="text-align: center;">2016年美国大学生数学建模竞赛</td><td style="text-align: center;">Honorable Mentions</td></tr><tr class="odd"><td style="text-align: center;"><del>2016年北京师范大学数学建模竞赛</del></td><td style="text-align: center;"><del>没奖，铁牌</del> 我才没有参加过</td></tr><tr class="even"><td style="text-align: center;">2016年全国大学生数学建模竞赛</td><td style="text-align: center;">北京市一等奖</td></tr><tr class="odd"><td style="text-align: center;">2017年美国大学生数学建模竞赛</td><td style="text-align: center;"><del>　　　　　　　</del></td></tr></tbody></table><p>入校第一学期寒假，莫名其妙入了建模坑，参加了莫名其妙的美赛。但第一年限于水平和经验，只打了个酱油，得了一发成功参赛。 第二次美赛就要显得略微熟练一些<del>（其实只是懒散）</del>，两个人在寝室吃喝玩乐，早上室友出发时还没起床，晚上躺下了室友才回来。总之是经历了四天度假般的生活，后来发现得了个H奖（俗称二等奖）。谈不上满意，但总是能给自己个交代。<del>（瞎编的论文竟然得了奖）</del>。 后来的校赛国赛就是一支稳定的队伍了<del>（我 + 丰腴夫妇）</del>，仍然坚持着“建模就是乱搞瞎编”的思路，校赛搞出个铁牌（此处应有掌声）。可国赛却大不一样……北京市一等奖，打死阅卷人我也不相信校赛到国赛的这段时间我们能有这么大进步。</p><h3 id="编程乱搞">编程乱搞</h3><p>受到ACM的影响，再加上信科学院环境的潜移默化，我比较喜欢乱写一些代码。<del>不过其中的大部分都是浅尝辄止。</del></p><ul><li>在大一的基础课程中，学习了<strong><code>C语言</code></strong>；</li><li>在搞竞赛的过程中，慢慢学习了<strong><code>C++</code></strong>；</li><li>后来接触了LaTeX，顺手学习了<strong><code>LaTeX</code></strong>；</li><li>在大二和同学申请了网络方面的项目，顺带<del>（被迫）</del>学习了<strong><code>Ruby</code></strong>，<strong><code>html</code></strong>，<strong><code>php</code></strong>；</li><li>在搞竞赛的过程中接触到了一些大数的题目，由此展开学习了<strong><code>Java</code></strong>；</li><li>2015年合肥赛前后，由于电脑硬盘损坏，重新买硬盘时装了Linux系统，于是学会了<strong><code>shell</code></strong>；</li><li>在学习数学的过程中为了<del>偷懒</del>研究，学习了<strong><code>Mathematica</code></strong>；</li><li>后来入了github的坑，搞网站时顺便学习了<strong><code>git</code></strong>。</li></ul><p>作为参加过n次建模的人，实在太弱，仍然不会<code>Matlab</code>（菜不成声.jpg），之前建模用到<code>Matlab</code>全靠丰腴夫妇实力Carry，Orz。</p><h3 id="数学乱搞">数学乱搞</h3><p>从我个人来讲，我是特别讨厌套路（或说是定式）的人。搞竞赛如此，学编程如此，学数学也是如此。 对于数学，我的态度从来都是，不苛求完美，也不研究所谓套路。<del>相比套路我更喜欢乱搞。</del> 家人总希望我能够拿高分，拿果酱。我倒觉得不必。 我只希望“弄懂”，但拿高分需要“弄熟”。<del>（习惯性装B）</del> 我比较排斥几何（别问我为什么，我也不知道），相对来说比较喜欢代数（可能和代数老师的讲课方式有关）。图论什么的，受ACM的影响，当然也不排斥了。 <del>只是学的差而已，喜欢又没有错。</del></p><h2 id="谈谈爱好">谈谈爱好</h2><h3 id="体育运动">体育运动</h3><p>喜欢运动，比较喜欢篮球、乒乓球、羽毛球等。</p><h4 id="篮球">篮球</h4><p>每个大个都有一颗当后卫的心。 赛场上是大前锋或中锋，赛场下几个兄弟们打球<del>我就是控卫</del>基本就是瞎打瞎玩了。 虽然我已不是信科人，但我仍然一如既往地支持信科篮球队。</p><table><thead><tr class="header"><th style="text-align: center;">赛事</th><th style="text-align: center;">奖项</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">2014年北京师范大学明月杯篮球赛</td><td style="text-align: center;">季军</td></tr><tr class="even"><td style="text-align: center;">2015年北京师范大学明月杯篮球赛</td><td style="text-align: center;">亚军</td></tr><tr class="odd"><td style="text-align: center;">2016年北京师范大学明月杯篮球赛</td><td style="text-align: center;">八强</td></tr></tbody></table><p>或许2015年没有夺冠是最大的遗憾吧。</p><h4 id="乒乓球">乒乓球</h4><p>一入校便知有两个室友喜欢打乒乓球，后来二位当上了副队长也没有嫌弃我<del>，组织训练时我便去蹭球</del>。</p><h3 id="游戏">游戏</h3><p>大多数男生的生活，都或多或少地有游戏的参与。</p><ul><li>高中时和一帮弟兄们玩DotA，后来开始玩DotA2 <del> 但是玩得菜</del>；</li><li>上大学之后慢慢开始玩NBA 2K，先是2K14，后来是2K16 <del> 暴虐室友我会乱讲</del>；</li><li>在手机上玩节<del>操</del>奏大师，基本上完虐同学们 <del> 别跟我提Q神</del>；</li><li>直到现在还在玩War3，有时会和室友联机 <del> 虐电脑</del>。</li></ul>]]></content>
    </entry>
    
    <entry>
      <title>标签 &amp; 分类</title>
      <link href="/tags/index.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>search</title>
      <link href="/search/index.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
